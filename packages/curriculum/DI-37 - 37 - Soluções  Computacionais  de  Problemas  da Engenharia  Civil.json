{
  "formatVersion": "1.0",
  "exportDate": "2025-12-06T00:20:04.390Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - DI-37",
      "lastUpdated": "2025-12-06",
      "totalAtomicSkills": 338
    },
    "areas": [
      {
        "id": "10",
        "name": "Engenharia Civil",
        "description": "Área dedicada ao estudo de soluções computacionais aplicadas a problemas da Engenharia Civil.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "DI-37 - Soluções Computacionais de Problemas da Engenharia Civil",
            "description": "Problema de valor inicial. Problema de valor de contorno. Método dos resíduos ponderados. Condicionamento e matriz de Gram. Autovalores e autofunções. Otimização e programação matemática. Solução de equações não-lineares. Ajuste de curvas. Redes neurais artificiais. Geração de números aleatórios. Método de Monte Carlo. Bibliografia: CHAPRA, S. C.; CANALE, R. P. Numerical methods for engineers: with software and programming applications. New York: McGraw-Hill, 2002. KINCAID, D.; CHENEY, W. Numerical analysis: mathematics of scientific computing. Pacific Grove: Brooks Cole, 2001. YANG, W. Y., CAO, W., CHUNG, T. S., MORRIS, J., Applied numerical methods using MATLAB, Chicago: John Wiley, 2005.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Problemas de Valor Inicial e de Contorno",
                "description": "Estudo de problemas diferenciais com condições iniciais e de contorno, incluindo métodos aproximados como o método dos resíduos ponderados.",
                "totalSkills": 44,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Problema de Valor Inicial",
                    "description": "Formulação e características de equações diferenciais ordinárias com condições iniciais especificadas em um ponto inicial.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Definição e Formulação do Problema de Valor Inicial",
                        "description": "Conceito fundamental que define o Problema de Valor Inicial (PVI) como um sistema de equações diferenciais ordinárias (EDOs) acompanhado de condições iniciais especificadas em um ponto inicial único, permitindo a determinação única da solução no domínio considerado.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Identificar a estrutura matemática de um PVI",
                            "description": "Reconhecer e formular um PVI padrão na forma y' = f(t, y), y(t0) = y0, distinguindo-o de outros tipos de problemas diferenciais, com exemplos em contextos de engenharia civil como modelagem de vibrações estruturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal de um Problema de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Ler a definição padrão: um PVI é composto por uma equação diferencial ordinária (EDO) de primeira ordem y' = f(t, y) e uma condição inicial y(t₀) = y₀.",
                                    "Analisar os símbolos: y' representa a derivada dy/dt, f(t,y) é uma função contínua em um retângulo do plano ty.",
                                    "Estudar condições de existência e unicidade pelo teorema de Picard-Lindelöf.",
                                    "Anotar exemplos canônicos como y' = y, y(0)=1."
                                  ],
                                  "verification": "Escrever a definição completa de um PVI em suas próprias palavras e citar o teorema de existência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de EDOs (ex: Boyce & DiPrima), caderno e caneta.",
                                  "tips": "Use diagramas para visualizar o plano ty e a curva integral.",
                                  "learningObjective": "Memorizar e reproduzir a forma matemática exata de um PVI.",
                                  "commonMistakes": "Confundir com EDOs de ordem superior sem reduzir a primeira ordem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os componentes essenciais de um PVI",
                                  "subSteps": [
                                    "Localizar a EDO principal: verificar se está na forma y' = f(t,y) com derivada explícita em y'.",
                                    "Identificar a condição inicial: deve ser y(t₀)=y₀, com t₀ e y₀ especificados.",
                                    "Verificar o domínio: f deve ser definida em um intervalo contendo t₀.",
                                    "Classificar como linear ou não-linear baseado em f."
                                  ],
                                  "verification": "Dado um problema, destacar a EDO e a condição inicial em cores diferentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplos impressos de problemas diferenciais, lápis de cor.",
                                  "tips": "Sempre pergunte: 'Há exatamente uma derivada primeira e uma condição no tempo inicial?'",
                                  "learningObjective": "Diferenciar precisamente os elementos constitutivos de um PVI.",
                                  "commonMistakes": "Ignorar se f depende explicitamente de t ou só de y."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Distinguir PVI de outros tipos de problemas diferenciais",
                                  "subSteps": [
                                    "Comparar com Problemas de Valor de Contorno (PVC): PVC tem condições em pontos diferentes, ex: y(0)=a, y(1)=b.",
                                    "Diferenciar de EDOs de ordem superior: 2ª ordem tem y'', precisa reduzir a sistema de 1ª ordem.",
                                    "Contrastar com problemas de autovalores ou integrais de Volterra.",
                                    "Listar pelo menos 3 diferenças chave em uma tabela."
                                  ],
                                  "verification": "Classificar 5 problemas aleatórios como PVI, PVC ou outro, justificando cada um.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Lista de 10 problemas de EDOs variados (online ou livro), tabela em Excel ou papel.",
                                  "tips": "Lembre: PVI é 'inicial' porque condições são no mesmo t₀.",
                                  "learningObjective": "Reconhecer exclusividade do PVI versus outros formatos.",
                                  "commonMistakes": "Confundir PVI com PVC quando condições estão próximas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar identificação de PVI em contextos de engenharia civil",
                                  "subSteps": [
                                    "Analisar exemplo de vibrações: reduzir equação de massa-mola amortecida a sistema de PVIs de 1ª ordem.",
                                    "Formular PVI para modelagem de fluxo em tubulações: dh/dt = -k sqrt(h), h(0)=h₀.",
                                    "Identificar PVI em assentamento de fundações: dy/dt = c (1 - y/L), y(0)=0.",
                                    "Verificar estrutura em um problema real descritivo."
                                  ],
                                  "verification": "Formular um PVI completo a partir de uma descrição verbal de vibrações estruturais.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Artigos ou vídeos sobre modelagem em engenharia civil, software como MATLAB (opcional).",
                                  "tips": "Busque palavras-chave como 'taxa de mudança inicial' ou 'condição no tempo zero'.",
                                  "learningObjective": "Identificar PVIs em aplicações práticas de engenharia civil.",
                                  "commonMistakes": "Não reduzir EDOs de ordem superior ao formato de 1ª ordem."
                                }
                              ],
                              "practicalExample": "Na modelagem de vibrações de uma viga em ponte suspensa, o deslocamento vertical y(t) e velocidade v(t)=y'(t) formam um sistema PVI: v' = - (k/m) y - (c/m) v, y' = v, com y(0)=0, v(0)=v₀ (golpe de vento). Identifique: EDOs y'=v, v'=f(t,y,v) reduzidas a 1ª ordem, condições iniciais em t=0.",
                              "finalVerifications": [
                                "Reescrever corretamente a forma padrão y'=f(t,y), y(t₀)=y₀.",
                                "Classificar 3 exemplos como PVI ou não, com justificativa.",
                                "Formular um PVI simples para um contexto de engenharia civil.",
                                "Explicar diferença chave entre PVI e PVC.",
                                "Citar teorema de existência para PVI.",
                                "Identificar componentes em um exemplo complexo de vibrações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da forma y'=f(t,y) (30%)",
                                "Correta distinção de outros problemas diferenciais (25%)",
                                "Aplicação contextual em engenharia civil (20%)",
                                "Uso de exemplos concretos e verificações (15%)",
                                "Clareza na formulação e justificativas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem dinâmica de sistemas massa-mola em estruturas.",
                                "Programação: Implementação numérica em Python/MATLAB para solução de PVIs.",
                                "Estatística: Análise de sensibilidade a condições iniciais.",
                                "Engenharia de Materiais: Taxas de deformação e creep em solos."
                              ],
                              "realWorldApplication": "Em engenharia civil, identificar PVIs é crucial para simular vibrações em edifícios durante terremotos (usando software como ANSYS), prevendo assentamentos em fundações ou fluxo em sistemas hidráulicos, garantindo segurança estrutural e otimização de projetos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Escrever a formulação geral de EDOs para PVI",
                            "description": "Escrever a notação matemática geral para EDOs de primeira e maior ordem em forma normal, incluindo sistemas de EDOs, e especificar as condições iniciais correspondentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de EDOs e PVI",
                                  "subSteps": [
                                    "Defina EDO como equação diferencial ordinária envolvendo derivadas de ordem finita em relação a uma variável independente.",
                                    "Explique PVI como problema onde se especifica a solução e suas derivadas em um ponto inicial t0.",
                                    "Identifique a forma normal y' = f(t, y) para EDOs de primeira ordem.",
                                    "Discuta a generalização para ordens superiores e sistemas.",
                                    "Esboce exemplos simples como y' = ky (crescimento exponencial)."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e forneça um exemplo escrito corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de EDOs (capítulo introdutório)",
                                    "Acesso a Khan Academy ou vídeo introdutório sobre EDOs"
                                  ],
                                  "tips": "Use diagramas para visualizar a dependência de t e y.",
                                  "learningObjective": "Compreender os termos básicos e a motivação para formulações gerais de PVI.",
                                  "commonMistakes": [
                                    "Confundir EDO com EDP (parciais)",
                                    "Ignorar a distinção entre forma normal e não normal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular EDOs de Primeira Ordem em Forma Normal",
                                  "subSteps": [
                                    "Escreva a notação geral: y'(t) = f(t, y(t)), com condição inicial y(t0) = y0.",
                                    "Converta uma EDO não linear como y' + y = t para forma normal y' = f(t,y).",
                                    "Pratique com exemplos: y' = y^2 + t.",
                                    "Verifique unicidade via teorema de Picard-Lindelöf.",
                                    "Especifique o domínio onde f é Lipschitz."
                                  ],
                                  "verification": "Escreva 3 exemplos de EDOs de 1ª ordem em forma normal com CI corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Caderno de exercícios",
                                    "Software simbólico como Wolfram Alpha para verificação"
                                  ],
                                  "tips": "Sempre isole a derivada primeira no lado esquerdo.",
                                  "learningObjective": "Dominar a formulação padrão para EDOs de 1ª ordem em PVI.",
                                  "commonMistakes": [
                                    "Esquecer parênteses em y(t)",
                                    "Colocar CI incorreta como y(0)=y0 sem especificar t0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Generalizar para EDOs de Ordem Superior",
                                  "subSteps": [
                                    "Reduza ordem n para sistema de 1ª ordem: y^{(n)} = f(t, y, y', ..., y^{(n-1)}).",
                                    "Introduza variáveis auxiliares: z1 = y, z2 = y', ..., zn = y^{(n-1)}, com z' = A z + g(t).",
                                    "Escreva notação: y^{(n)}(t) = f(t, y(t), ..., y^{(n-1)}(t)), y(t0)=y0, y'(t0)=y1, ..., y^{(n-1)}(t0)=y_{n-1}.",
                                    "Exemplo: y'' + y' + y = 0 como sistema.",
                                    "Verifique redução correta."
                                  ],
                                  "verification": "Converta uma EDO de 2ª ordem em sistema de 1ª ordem com CI.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de fórmulas de EDOs",
                                    "Calculadora gráfica para plotar soluções"
                                  ],
                                  "tips": "Numere as CI sequencialmente para evitar confusão.",
                                  "learningObjective": "Capacitar a transformação de EDOs de alta ordem em sistemas tratáveis.",
                                  "commonMistakes": [
                                    "Erros na cadeia de derivadas auxiliares",
                                    "CI inconsistentes com ordem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular Sistemas de EDOs e Condições Iniciais Completas",
                                  "subSteps": [
                                    "Escreva sistema geral: Y'(t) = F(t, Y(t)), Y(t0) = Y0, onde Y é vetor.",
                                    "Exemplo em Engenharia Civil: modelo de vibração [x''; θ''] = f(t, x, x', θ, θ').",
                                    "Especifique Y0 como vetor coluna com todas as CI.",
                                    "Discuta existência via teorema para sistemas.",
                                    "Pratique com sistema 2x2 não linear."
                                  ],
                                  "verification": "Formule um sistema de 2 EDOs com 4 CI iniciais corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "MATLAB ou Python (SymPy) para validar notação",
                                    "Exemplos de problemas de engenharia"
                                  ],
                                  "tips": "Use notação vetorial consistente (maiúscula para vetores).",
                                  "learningObjective": "Integrar formulações para problemas multivariáveis em PVI.",
                                  "commonMistakes": [
                                    "Notação matricial inconsistente",
                                    "Número errado de CI para o sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Verificar Formulações Gerais",
                                  "subSteps": [
                                    "Compile todas as formas: 1ª ordem, alta ordem, sistemas.",
                                    "Crie template geral: problema PVI com EDO(s) + CI.",
                                    "Aplique a um problema real de engenharia civil.",
                                    "Revise por completude e precisão matemática.",
                                    "Compare com referências padrão."
                                  ],
                                  "verification": "Escreva a formulação completa para um PVI arbitrário de ordem 2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Referência: Boyce & DiPrima",
                                    "Checklist de formulação"
                                  ],
                                  "tips": "Sempre declare o intervalo de t explicitamente se possível.",
                                  "learningObjective": "Consolidar habilidade para escrever qualquer formulação de PVI.",
                                  "commonMistakes": [
                                    "Omitir domínio ou Lipschitz",
                                    "Notação ambígua em sistemas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para modelar o escoamento em uma tubulação (Engenharia Civil): formule y''(t) + 0.1 y'(t) + 9.8 y(t) = 0, com y(0)=1m (deslocamento inicial), y'(0)=0 m/s (velocidade zero), reduzindo a sistema Y'(t) = [0 1; -9.8 -0.1] Y(t), Y(0)=[1;0].",
                              "finalVerifications": [
                                "A derivada está isolada em forma normal y' = f(...).",
                                "Todas as condições iniciais correspondem à ordem do sistema.",
                                "Notação usa y(t), t0 explícito e y0 vetor se aplicável.",
                                "Forma é consistente para 1ª ordem, alta ordem ou sistema.",
                                "Exemplo prático pode ser resolvido numericamente (ex: Euler).",
                                "Sem erros tipográficos em símbolos matemáticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na notação geral (100% correto).",
                                "Inclusão completa de CI para o grau de liberdade.",
                                "Capacidade de redução de ordem superior a 1ª ordem.",
                                "Clareza e legibilidade da formulação escrita.",
                                "Aplicação correta a exemplo contextual (Eng. Civil).",
                                "Uso apropriado de vetores/matrizes em sistemas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos dinâmicos (vibrações, amortecimento).",
                                "Programação: Implementação numérica em MATLAB/Python.",
                                "Matemática Computacional: Métodos de Runge-Kutta.",
                                "Engenharia: Análise estrutural e hidráulica."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, formulações de PVI são usadas para simular vibrações em pontes (ex: Tacoma Narrows), fluxo em redes de tubulações ou deformações em barragens, permitindo soluções computacionais com FEM ou métodos numéricos para previsão e projeto seguro."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Diferenciar PVI de problemas de valor de contorno",
                            "description": "Comparar e contrastar PVI com Problemas de Valor de Contorno (PVC), destacando as diferenças nas condições especificadas e suas implicações em soluções numéricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Formulação do Problema de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Leia a definição formal de PVI para equações diferenciais ordinárias (EDOs): uma EDO com condições iniciais especificadas em um ponto inicial, tipicamente t=0.",
                                    "Identifique os componentes principais: a equação diferencial, a função desconhecida y(t) e as condições y(t0)=y0, y'(t0)=y1, etc.",
                                    "Estude exemplos clássicos, como o decaimento exponencial dy/dt = -ky com y(0)=y0.",
                                    "Anote as características únicas: evolução temporal para frente a partir de condições iniciais.",
                                    "Registre implicações iniciais para soluções analíticas e numéricas."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases definindo PVI e dê um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre EDOs",
                                    "Livro texto de equações diferenciais (ex: Boyce & DiPrima)",
                                    "Acesso a Khan Academy ou MIT OpenCourseWare para vídeos curtos"
                                  ],
                                  "tips": "Use diagramas de setas para visualizar a 'marcha' temporal a partir do ponto inicial.",
                                  "learningObjective": "Definir precisamente PVI e identificar suas condições iniciais.",
                                  "commonMistakes": "Confundir condições iniciais com condições em múltiplos pontos; assumir que PVI só aplica a EDOs de primeira ordem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Definição e Formulação do Problema de Valor de Contorno (PVC)",
                                  "subSteps": [
                                    "Leia a definição formal de PVC: condições especificadas em pontos de contorno distintos, comum em EDOs de segunda ordem ou equações diferenciais parciais (EDPs).",
                                    "Identifique componentes: equação diferencial, condições em extremos do domínio, ex: u(0)=a e u(L)=b para -u''=f(x).",
                                    "Estude exemplos, como a equação de uma viga em flexão com apoios fixos nas extremidades.",
                                    "Note características: solução bidirecional ou 'tiro' entre contornos, não evolutiva no tempo.",
                                    "Anote diferenças preliminares com PVI em termos de domínio e direção de solução."
                                  ],
                                  "verification": "Escreva um resumo similar ao do Step 1 para PVC, incluindo um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre EDOs de contorno",
                                    "Livro texto de métodos numéricos (ex: Burden & Faires)",
                                    "Software como MATLAB para visualizar soluções"
                                  ],
                                  "tips": "Desenhe o domínio espacial (ex: barra de 0 a L) e marque as condições nos fins.",
                                  "learningObjective": "Definir PVC e contrastar superficialmente com PVI.",
                                  "commonMistakes": "Pensar que PVC é sempre para EDPs; ignorar que PVC pode ser para EDOs espaciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e Contrastar Diferenças Chave entre PVI e PVC",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: condições (inicial vs contorno), domínio (temporal vs espacial), direção de solução (unidirecional vs bidirecional).",
                                    "Analise tipos de equações: PVI típico para EDOs evolutivas; PVC para elípticas ou de contorno.",
                                    "Discuta unicidade e existência: Cauchy-Lipschitz para PVI local; condições de contorno garantem global.",
                                    "Examine estabilidade: PVI sensível a condições iniciais; PVC mais 'rígido'.",
                                    "Liste 5 diferenças principais em bullet points."
                                  ],
                                  "verification": "Preencha e revise a tabela comparativa, garantindo pelo menos 5 diferenças claras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Exemplos de problemas de aula",
                                    "Calculadora para testes rápidos"
                                  ],
                                  "tips": "Use cores diferentes na tabela para destacar similaridades e diferenças.",
                                  "learningObjective": "Identificar e articular diferenças fundamentais entre PVI e PVC.",
                                  "commonMistakes": "Focar só em EDOs sem mencionar EDPs; inverter causalidade temporal/espacial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Implicações nas Soluções Numéricas",
                                  "subSteps": [
                                    "Estude métodos para PVI: Euler, Runge-Kutta (marcha explícita para frente).",
                                    "Estude métodos para PVC: diferenças finitas, método do tiro, relaxação.",
                                    "Compare desafios: PVI - acúmulo de erro temporal; PVC - convergência iterativa.",
                                    "Simule um problema simples de cada tipo em pseudocódigo ou software.",
                                    "Conclua com quando usar cada abordagem em engenharia civil computacional."
                                  ],
                                  "verification": "Descreva um método numérico para cada e liste prós/contras em relação ao tipo de problema.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python/MATLAB com bibliotecas scipy.integrate e solve_bvp",
                                    "Tutoriais online de métodos numéricos"
                                  ],
                                  "tips": "Comece com problemas lineares simples para evitar complicações.",
                                  "learningObjective": "Entender impactos das diferenças em algoritmos numéricos.",
                                  "commonMistakes": "Aplicar métodos de PVI diretamente a PVC sem ajustes; subestimar rigidez em PVC."
                                }
                              ],
                              "practicalExample": "Considere a equação dy/dt = -y, y(0)=1 (PVI: condição inicial em t=0, solução y=e^{-t}, resolvida por Runge-Kutta marchando no tempo). Contrastar com -d²u/dx² = 1, u(0)=0, u(1)=0 (PVC: condições em x=0 e x=1, solução u(x)=x(1-x)/2, resolvida por diferenças finitas ou método do tiro iterando entre contornos). Em engenharia civil, PVI modela vibração dinâmica de uma ponte; PVC modela deflexão estática de uma viga.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças principais entre PVI e PVC.",
                                "Classificar corretamente 3 problemas dados como PVI ou PVC.",
                                "Desenhar diagramas esquemáticos das condições para ambos.",
                                "Discutir uma implicação numérica específica para cada tipo.",
                                "Resolver um PVI e um PVC simples analiticamente ou numericamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de PVI e PVC (80% das componentes corretas).",
                                "Identificação correta de pelo menos 4 diferenças chave.",
                                "Clareza na tabela comparativa e exemplos fornecidos.",
                                "Compreensão demonstrada de implicações numéricas via pseudocódigo ou simulação.",
                                "Capacidade de aplicar conceitos a contextos de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica (PVI para movimento) vs. Estática (PVC para equilíbrio).",
                                "Programação: Algoritmos iterativos (Runge-Kutta vs. solvers de BVP em SciPy).",
                                "Matemática Numérica: Estabilidade e convergência de métodos.",
                                "Engenharia Computacional: Simulações FEM para EDPs de contorno."
                              ],
                              "realWorldApplication": "Em engenharia civil, PVIs são usados para simular respostas dinâmicas de estruturas a terremotos (evolução temporal de acelerações), enquanto PVCs modelam análises estáticas de vigas e lajes (condições de apoio nas extremidades), essenciais em softwares como ANSYS para projeto seguro de edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Condições Iniciais em Problemas de Valor Inicial",
                        "description": "Conjunto de valores especificados para a função desconhecida e suas derivadas em um ponto inicial t0, essenciais para garantir a unicidade da solução pelo Teorema de Picard-Lindelöf.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Especificar condições iniciais para EDOs de ordem superior",
                            "description": "Converter EDOs de ordem n em sistemas de primeira ordem e definir as n condições iniciais necessárias, aplicando a cenários como dinâmica de fluidos em canais hidráulicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender EDOs de ordem superior e sua representação",
                                  "subSteps": [
                                    "Defina o que é uma EDO de ordem n e identifique o maior derivado presente.",
                                    "Analise exemplos simples de EDOs de 2ª e 3ª ordem, como y'' + p y' + q y = f(t).",
                                    "Explique por que EDOs de ordem superior são convertidas em sistemas de 1ª ordem para resolução numérica.",
                                    "Discuta problemas de valor inicial (PVI) e o papel das condições iniciais.",
                                    "Estude o contexto de dinâmica de fluidos, onde EDOs modelam variações de altura ou velocidade em canais."
                                  ],
                                  "verification": "Resuma em um parágrafo a diferença entre ordem 1 e ordem n, com um exemplo anotado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta, calculadora, livro de EDOs ou PDF online sobre equações diferenciais.",
                                  "tips": "Use diagramas para visualizar derivadas sucessivas como variáveis de estado.",
                                  "learningObjective": "Identificar e classificar EDOs de ordem superior em contextos de engenharia civil.",
                                  "commonMistakes": "Confundir ordem da equação com o número de condições iniciais necessárias."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter EDO de ordem n em sistema de EDOs de 1ª ordem",
                                  "subSteps": [
                                    "Introduza n variáveis de estado: y1 = y, y2 = y', ..., yn = y^(n-1).",
                                    "Escreva o sistema: y1' = y2, y2' = y3, ..., yn' = expressão da EDO original.",
                                    "Substitua derivadas na equação original para obter yn'.",
                                    "Verifique se o sistema resultante tem exatamente n equações de 1ª ordem.",
                                    "Aplique a um exemplo: para y'' + 2y' + y = 0, defina y1=y, y2=y'; y1'=y2, y2'=-2y2 - y1."
                                  ],
                                  "verification": "Escreva o sistema equivalente para uma EDO dada e confira derivadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha de papel quadriculado, software como MATLAB ou Python (SymPy para verificação simbólica).",
                                  "tips": "Sempre comece definindo y1 como a função original para evitar confusão nas variáveis.",
                                  "learningObjective": "Transformar autonomamente qualquer EDO de ordem superior em um sistema de 1ª ordem.",
                                  "commonMistakes": "Esquecer de incluir todas as derivadas intermediárias ou errar o sinal nas substituições."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar as n condições iniciais necessárias",
                                  "subSteps": [
                                    "Entenda que para nª ordem, são necessárias n condições iniciais: y(t0), y'(t0), ..., y^(n-1)(t0).",
                                    "Mapeie essas condições para o sistema: y1(t0), y2(t0), ..., yn(t0).",
                                    "Identifique condições físicas: ex., posição inicial (y(0)), velocidade inicial (y'(0)).",
                                    "Verifique unicidade da solução pelo teorema de Picard-Lindelöf.",
                                    "Ajuste para cenários reais: em canais, y(0)=altura inicial, y'(0)=velocidade de fluxo inicial."
                                  ],
                                  "verification": "Liste as condições iniciais para o sistema do passo anterior e justifique fisicamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos de problemas de engenharia civil (PDFs de dinâmica de fluidos).",
                                  "tips": "Associe cada condição a uma grandeza física mensurável para maior clareza.",
                                  "learningObjective": "Determinar e justificar o número e tipo corretos de condições iniciais.",
                                  "commonMistakes": "Fornecer menos ou mais condições que n, ou especificar em t errado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a um cenário prático de dinâmica de fluidos em canais hidráulicos",
                                  "subSteps": [
                                    "Modele uma EDO de 2ª ordem para oscilação de nível em canal: y'' + k y' + ω² y = 0.",
                                    "Converta para sistema e especifique CI: y(0)=1m (altura inicial), y'(0)=0.5 m/s (velocidade inicial).",
                                    "Simule numericamente o sistema usando método de Euler ou Runge-Kutta simples.",
                                    "Analise o comportamento: tempo até estabilização do fluxo.",
                                    "Discuta implicações para projeto de canais (prevenção de transbordamento)."
                                  ],
                                  "verification": "Execute simulação e plote gráfico mostrando evolução com CI corretas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, dados de canais hidráulicos reais.",
                                  "tips": "Use valores realistas de k e ω baseados em propriedades do fluido (ex., viscosidade da água).",
                                  "learningObjective": "Integrar conversão e CI em um problema aplicado de engenharia civil.",
                                  "commonMistakes": "Ignorar unidades nas CI, levando a resultados físicos inconsistentes."
                                }
                              ],
                              "practicalExample": "Em um canal hidráulico, modele o nível de água y(t) com y'' + 0.1 y' + 0.5 y = 0 (amortecimento viscoso). Converta: y1 = y, y2 = y'; y1' = y2, y2' = -0.1 y2 - 0.5 y1. Condições iniciais: y1(0) = 2m (altura inicial), y2(0) = 0 m/s (repouso inicial). Simule para prever tempo de estabilização.",
                              "finalVerifications": [
                                "Sistema convertido tem exatamente n equações de 1ª ordem.",
                                "Todas as n condições iniciais estão corretamente mapeadas para variáveis de estado.",
                                "Condições iniciais são fisicamente interpretáveis no contexto do problema.",
                                "Simulação numérica converge sem erros de dimensão.",
                                "Gráfico mostra comportamento esperado (ex., amortecimento oscilatório).",
                                "Unicidade da solução é justificada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na conversão da EDO (100% das derivadas corretas).",
                                "Correto número e mapeamento de condições iniciais (n exatas).",
                                "Justificativa física das CI no contexto de canais hidráulicos.",
                                "Simulação numérica implementada sem erros e com plotagem.",
                                "Análise qualitativa do resultado (estabilidade, tempo de convergência).",
                                "Clareza na documentação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de sistemas lineares e autovalores para soluções analíticas.",
                                "Física: Mecânica de fluidos e equações de Navier-Stokes simplificadas.",
                                "Programação: Implementação de solvers numéricos (Runge-Kutta em Python/MATLAB).",
                                "Engenharia Mecânica: Modelagem de vibrações e amortecedores hidráulicos."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil para canais hidráulicos, especificar condições iniciais permite simular dinâmicas de fluxo com software como HEC-RAS, prevendo inundações, otimizando dimensões de canais e garantindo segurança em barragens ou rios urbanizados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Verificar a consistência das condições iniciais",
                            "description": "Analisar se as condições iniciais fornecidas são suficientes e consistentes para um PVI dado, identificando casos de sub ou superdeterminação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema de Valor Inicial (PVI) e o Papel das Condições Iniciais",
                                  "subSteps": [
                                    "Defina o que é um PVI: uma equação diferencial ordinária (EDO) com condições especificadas em um ponto inicial (geralmente t=0).",
                                    "Identifique os componentes: equação diferencial de ordem n requer exatamente n condições iniciais independentes.",
                                    "Revise exemplos básicos de EDOs de 1ª e 2ª ordem para visualizar condições iniciais.",
                                    "Anote a importância da consistência: condições devem ser suficientes (nem mais, nem menos) e não contraditórias.",
                                    "Classifique tipos de inconsistências: subdeterminação (poucas condições), superdeterminação (muitas condições) e contradições lógicas."
                                  ],
                                  "verification": "Resuma em suas palavras o que é um PVI e liste 3 exemplos de condições iniciais para uma EDO de 2ª ordem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de EDOs (capítulo sobre PVIs)",
                                    "Anotações de aula sobre EDOs",
                                    "Calculadora simbólica online (ex: Wolfram Alpha)"
                                  ],
                                  "tips": "Use diagramas para visualizar a ordem da EDO e o número de condições necessárias.",
                                  "learningObjective": "Entender os fundamentos teóricos de PVIs e o requisito exato de condições iniciais.",
                                  "commonMistakes": [
                                    "Confundir ordem da EDO com grau da equação",
                                    "Ignorar que condições devem ser em pontos distintos ou independentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Ordem da Equação Diferencial e Contar Condições Iniciais Fornecidas",
                                  "subSteps": [
                                    "Reescreva a EDO na forma padrão para determinar sua ordem n (maior derivada presente).",
                                    "Liste todas as condições iniciais fornecidas, especificando variáveis e valores (ex: y(0)=1, y'(0)=2).",
                                    "Conte o número de condições independentes: verifique se cobrem todas as derivadas até ordem n-1.",
                                    "Compare o número de condições com n: identifique subdeterminação (menos que n) ou superdeterminação (mais que n).",
                                    "Documente em uma tabela: ordem n | número de condições | status (suficiente?)."
                                  ],
                                  "verification": "Crie uma tabela comparativa para uma EDO de exemplo e conclua se é sub ou superdeterminada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para tabelas",
                                    "Software de EDOs como MATLAB ou Python (SymPy)",
                                    "Exemplos de PVIs de exercícios anteriores"
                                  ],
                                  "tips": "Sempre reduza a EDO à forma canônica antes de contar a ordem.",
                                  "learningObjective": "Desenvolver habilidade para quantificar requisitos de condições iniciais.",
                                  "commonMistakes": [
                                    "Contar condições redundantes como independentes",
                                    "Errar a ordem ao não simplificar a EDO"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Consistência Lógica e Ausência de Contradições",
                                  "subSteps": [
                                    "Substitua as condições iniciais na EDO e derive valores implícitos para verificar coerência.",
                                    "Para superdeterminação, resolva parcialmente e cheque se condições extras são satisfeitas.",
                                    "Para subdeterminação, identifique parâmetros livres restantes.",
                                    "Use método de eliminação sucessiva de constantes para testar consistência em sistemas.",
                                    "Registre qualquer contradição: ex: y(0)=1 e y'(0) implicando y(0)=2."
                                  ],
                                  "verification": "Para um PVI dado, demonstre matematicamente se as condições são consistentes ou levam a contradição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de cálculo para derivações",
                                    "Ferramenta de resolução simbólica (Mathematica ou SymPy)",
                                    "Lista de PVIs com inconsistências conhecidas"
                                  ],
                                  "tips": "Comece com condições de ordem mais baixa e propague para cima.",
                                  "learningObjective": "Identificar e provar inconsistências lógicas nas condições iniciais.",
                                  "commonMistakes": [
                                    "Não verificar condições derivadas implicitamente",
                                    "Assumir consistência sem substituição explícita"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar Diagnóstico Completo e Propor Correções",
                                  "subSteps": [
                                    "Compile um relatório: ordem, número de condições, tipo de inconsistência (sub/super/consistência).",
                                    "Para subdeterminação, sugira condições adicionais necessárias.",
                                    "Para superdeterminação, identifique quais condições remover ou ajuste aproximado.",
                                    "Para contradições, proponha reformulação do problema.",
                                    "Valide com uma solução numérica ou analítica parcial se possível."
                                  ],
                                  "verification": "Escreva um relatório de 1 página diagnosticando um PVI exemplo e propondo soluções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Template de relatório em Word/Google Docs",
                                    "Exemplos resolvidos de PVIs inconsistentes"
                                  ],
                                  "tips": "Use bullet points para clareza no relatório.",
                                  "learningObjective": "Sintetizar análise em diagnóstico acionável para engenharia prática.",
                                  "commonMistakes": [
                                    "Omitir propostas de correção",
                                    "Diagnóstico superficial sem justificativa matemática"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a EDO y'' + y = 0 (ordem 2, requer 2 condições). Condições: y(0)=0, y'(0)=1, y''(0)=0. Análise: Superdeterminação (3 condições). Verifique consistência: Da EDO, y''(0) = -y(0) = 0, que matches, mas extra desnecessária. Diagnóstico: Superdeterminada mas consistente.",
                              "finalVerifications": [
                                "Corretamente identifica ordem de EDOs variadas (1ª a 4ª ordem).",
                                "Conta precisamente condições independentes vs. redundantes.",
                                "Detecta subdeterminação em 90% dos casos testados.",
                                "Identifica superdeterminação e contradições lógicas.",
                                "Propõe correções viáveis para inconsistências.",
                                "Documenta análise de forma clara e matemática."
                              ],
                              "assessmentCriteria": [
                                "Precisão na determinação da ordem da EDO (100% correto).",
                                "Identificação correta de sub/super determinação (pontos por caso).",
                                "Demonstração matemática de consistência/contradição.",
                                "Qualidade do relatório: clareza, completude e propostas de correção.",
                                "Tempo de análise eficiente sem erros comuns.",
                                "Aplicação em exemplos reais de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de EDOs e existência/unicidade de soluções (Teorema de Picard-Lindelöf).",
                                "Física: Modelagem dinâmica de sistemas (ex: vibrações em estruturas civis).",
                                "Programação: Implementação numérica em Python/MATLAB para validação.",
                                "Estatística: Análise de sensibilidade a condições iniciais incertas."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao modelar vibrações de pontes via EDOs (ex: equação do pêndulo para cabos), condições iniciais inconsistentes podem levar a simulações erradas de colapso estrutural, como visto em análises de fadiga em barragens ou edifícios sob sismos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Aplicar teoremas de existência e unicidade",
                            "description": "Enunciar e aplicar o Teorema de Existência e Unicidade de Peano e Picard-Lindelöf para determinar intervalos onde a solução do PVI existe e é única.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Enunciar e compreender o Teorema de Existência de Peano",
                                  "subSteps": [
                                    "Leia a definição formal do Teorema de Peano para EDOs y' = f(x,y), y(x0)=y0.",
                                    "Identifique as hipóteses: f contínua em um retângulo R ao redor de (x0,y0).",
                                    "Entenda a conclusão: existe um intervalo [x0 - h, x0 + h] onde há pelo menos uma solução.",
                                    "Estude a prova conceitual: método de Peano usando integral de Riemann.",
                                    "Resolva exercícios simples de verificação de continuidade de f."
                                  ],
                                  "verification": "Escreva o enunciado completo do teorema e verifique com uma fonte confiável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de EDOs (ex: Boyce-DiPrima), caderno, calculadora gráfica.",
                                  "tips": "Memorize as hipóteses chave: apenas continuidade de f, sem Lipschitz.",
                                  "learningObjective": "Dominar as condições para existência local de soluções sem unicidade.",
                                  "commonMistakes": "Confundir com unicidade; Peano garante existência, mas permite múltiplas soluções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar e compreender o Teorema de Picard-Lindelöf",
                                  "subSteps": [
                                    "Enuncie o teorema: f contínua e Lipschitz em y em retângulo R.",
                                    "Defina condição de Lipschitz: |f(x,y1) - f(x,y2)| ≤ K |y1 - y2|.",
                                    "Entenda a prova via iterações de Picard: y_{n+1}(x) = y0 + ∫ f(s, y_n(s)) ds.",
                                    "Analise convergência uniforme no intervalo de existência.",
                                    "Compare com Peano destacando a garantia de unicidade."
                                  ],
                                  "verification": "Demonstre Lipschitz para f(x,y) = y em um retângulo dado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Livro de EDOs, software MATLAB para plotar iterações de Picard.",
                                  "tips": "Use gráficos das iterações de Picard para visualizar convergência.",
                                  "learningObjective": "Entender como Lipschitz garante unicidade via contração no espaço de Banach.",
                                  "commonMistakes": "Esquecer que Lipschitz é local; não é global necessariamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar condições e determinar intervalos de existência e unicidade",
                                  "subSteps": [
                                    "Dado PVI y' = f(x,y), y(x0)=y0, defina retângulo R: |x - x0| ≤ a, |y - y0| ≤ b.",
                                    "Verifique continuidade de f em R para Peano (h = min(a, b/M), M=max|f|).",
                                    "Verifique Lipschitz em y: encontre K tal que |f(x,y1)-f(x,y2)| ≤ K|y1-y2|.",
                                    "Calcule intervalo de unicidade: h = min(a, b/(M+K b)).",
                                    "Ajuste h se necessário para maximizar o intervalo."
                                  ],
                                  "verification": "Para um f dado, calcule h_exist e h_unique explicitamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Caderno, calculadora, exemplos de PVIs da engenharia civil (ex: modelo de fluxo).",
                                  "tips": "Sempre esboce o retângulo R no plano xy para visualizar.",
                                  "learningObjective": "Aplicar teoremas para estimar intervalos precisos.",
                                  "commonMistakes": "Usar M incorreto (máximo de |f| em R todo); calcular sobre |x-x0| > a."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar teoremas em problemas práticos de engenharia civil",
                                  "subSteps": [
                                    "Escolha PVI relevante: ex: y' = -k y + f(t), y(0)=y0 (deformação em viga).",
                                    "Verifique condições Peano e Picard-Lindelöf.",
                                    "Determine intervalos e discuta implicações computacionais (ex: estabilidade numérica).",
                                    "Implemente iterações de Picard em MATLAB para validar unicidade.",
                                    "Analise casos onde unicidade falha (ex: f(y)=|y|^{1/2})."
                                  ],
                                  "verification": "Resolva 3 PVIs diferentes e reporte intervalos calculados.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB ou Python (SciPy), dados de engenharia civil simulados.",
                                  "tips": "Comece com f linear (fácil Lipschitz) antes de não-lineares.",
                                  "learningObjective": "Integrar teoremas em contextos computacionais reais.",
                                  "commonMistakes": "Ignorar dependência em x; assumir Lipschitz global sem verificar."
                                }
                              ],
                              "practicalExample": "Para PVI y' = y^2 + 1, y(0)=0 em retângulo |x|≤1, |y|≤2: f contínua (Peano, M=5, h=min(1,2/5)=0.4). Lipschitz? ∂f/∂y=2y ≤4 em R, K=4, h_unique=min(1,2/(5+8))=0.18. Solução única em [-0.18,0.18]; solução exata y=tan(x).",
                              "finalVerifications": [
                                "Enuncie corretamente ambos teoremas com hipóteses e conclusões.",
                                "Calcule intervalos para 3 PVIs dados sem erros aritméticos.",
                                "Explique diferença entre existência e unicidade com contraexemplo.",
                                "Implemente iterações de Picard e verifique convergência.",
                                "Discuta limitações em problemas de engenharia civil.",
                                "Identifique falha de Lipschitz em f não diferenciável."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado dos teoremas (20%)",
                                "Correção nos cálculos de h_exist e h_unique (30%)",
                                "Qualidade da verificação de Lipschitz (20%)",
                                "Aplicação prática em exemplo computacional (15%)",
                                "Análise de erros e limitações (10%)",
                                "Clareza na explicação escrita (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Integração com métodos de Euler/Runge-Kutta para soluções computacionais.",
                                "Programação: Implementação de solvers em MATLAB/Python para validar teoremas.",
                                "Física/Mecânica: Modelagem de vibrações em estruturas civis (EDOs lineares garantem unicidade).",
                                "Cálculo Avançado: Uso de integrais e teorema do valor médio na prova de Picard."
                              ],
                              "realWorldApplication": "Na engenharia civil, ao modelar deformações em vigas sob carga dinâmica (y' = f(t,y)), teoremas garantem que soluções numéricas (ex: FEM) são confiáveis em intervalos onde unicidade vale, evitando simulações instáveis em regimes não-lineares como colapso plástico."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Características das EDOs em Problemas de Valor Inicial",
                        "description": "Propriedades como linearidade, homogeneidade, Lipschitzianidade e estabilidade que influenciam a formulação, existência e métodos numéricos de solução de PVIs.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Classificar EDOs quanto à linearidade e Lipschitz",
                            "description": "Classificar EDOs em lineares/não-lineares, homogêneas/não-homogêneas e verificar a condição de Lipschitz para garantir soluções únicas em PVIs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de EDOs e PVIs",
                                  "subSteps": [
                                    "Defina Equação Diferencial Ordinária (EDO) como uma equação envolvendo derivadas de uma função desconhecida y(t) em relação a t.",
                                    "Explique Problema de Valor Inicial (PVI): y'(t) = f(t, y(t)), y(t0) = y0.",
                                    "Identifique a ordem da EDO (grau da maior derivada).",
                                    "Diferencie EDOs autônomas (não dependem explicitamente de t) de não-autônomas.",
                                    "Estude a forma padrão para EDOs de primeira ordem: y' = f(t, y)."
                                  ],
                                  "verification": "Escreva definições precisas e exemplos simples de EDOs de 1ª e 2ª ordem.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro-texto de EDOs (ex: Boyce & DiPrima)",
                                    "Notas de aula sobre PVIs",
                                    "Calculadora simbólica (Wolfram Alpha)"
                                  ],
                                  "tips": "Use diagramas para visualizar y(t) e y'(t); memorize a forma canônica y' = f(t,y).",
                                  "learningObjective": "Compreender os conceitos básicos de EDOs e PVIs para contextualizar classificações.",
                                  "commonMistakes": [
                                    "Confundir ordem da EDO com grau do polinômio em y",
                                    "Ignorar dependência explícita de t"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar EDOs quanto à Linearidade e Homogeneidade",
                                  "subSteps": [
                                    "Defina EDO linear: y' + p(t)y = g(t) para 1ª ordem (superposição válida).",
                                    "Identifique não-lineares: presença de y^2, sin(y), etc., em coeficientes não-lineares.",
                                    "Classifique como homogênea se g(t)=0 (ou termo independente=0); não-homogênea caso contrário.",
                                    "Reescreva EDOs em forma padrão para verificar linearidade.",
                                    "Pratique com exemplos: y' = 2y + t (linear não-homogênea), y' = y^2 (não-linear homogênea)."
                                  ],
                                  "verification": "Classifique 3 EDOs dadas como linear/não-linear e homogênea/não-homogênea, justificando.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha de exercícios com 10 EDOs variadas",
                                    "Software como MATLAB ou Python (SymPy)",
                                    "Quadro branco para reescrever equações"
                                  ],
                                  "tips": "Sempre isole y' à esquerda; procure termos não-lineares em y ou derivadas.",
                                  "learningObjective": "Dominar critérios para classificar linearidade e homogeneidade em EDOs.",
                                  "commonMistakes": [
                                    "Considerar y' * y como linear",
                                    "Confundir termo forçante g(t) com não-homogeneidade em EDOs de ordem superior"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a Condição de Lipschitz para Unicidade de Soluções",
                                  "subSteps": [
                                    "Enuncie o Teorema de Picard-Lindelöf: se f(t,y) contínua e Lipschitz em y, PVI tem solução única.",
                                    "Defina Lipschitz: existe K>0 tal que |f(t,y1) - f(t,y2)| ≤ K |y1 - y2| para todo t em I, y1,y2 em domínio.",
                                    "Verifique Lipschitz: para lineares, sempre (polinomial em y); para não-lineares, analise derivada parcial ∂f/∂y bounded.",
                                    "Exemplos: y'=y (Lipschitz), y'=y^2 +1 não-Lipschitz globalmente (explosão finita).",
                                    "Use critério local: verifique em intervalo ao redor de y0."
                                  ],
                                  "verification": "Para uma EDO dada, prove ou refute Lipschitz em intervalo específico, calculando ∂f/∂y.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Referência teórica (ex: Coddington)",
                                    "Python com NumPy para plotar |f(t,y1)-f(t,y2)|",
                                    "Papel para derivadas parciais"
                                  ],
                                  "tips": "Comece com ∂f/∂y; se |∂f/∂y| ≤ K finito, então Lipschitz por Teorema do Valor Médio.",
                                  "learningObjective": "Aplicar teste de Lipschitz para prever existência e unicidade de soluções em PVIs.",
                                  "commonMistakes": [
                                    "Confundir Lipschitz com continuidade",
                                    "Aplicar globalmente sem checar boundedness"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Classificações e Praticar em Exemplos Completo",
                                  "subSteps": [
                                    "Combine classificações: linearidade + homogeneidade + Lipschitz em uma tabela para EDO dada.",
                                    "Resolva PVIs simples para validar (ex: separáveis ou exatas).",
                                    "Identifique implicações: lineares → métodos exatos; Lipschitz → solvers numéricos confiáveis.",
                                    "Crie fluxograma de classificação: 1. Linear? 2. Homogênea? 3. Lipschitz?",
                                    "Avalie 5 EDOs de engenharia civil (ex: decaimento, crescimento populacional)."
                                  ],
                                  "verification": "Crie relatório de classificação para 5 PVIs, incluindo justificativas e previsões de unicidade.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Lista de 10 PVIs contextualizados",
                                    "Software de EDOs (ex: SciPy odeint)",
                                    "Template de tabela de classificação"
                                  ],
                                  "tips": "Use cores no fluxograma: verde para 'boa' (linear + Lipschitz), vermelho para cuidado.",
                                  "learningObjective": "Executar classificação completa de EDOs em PVIs com confiança.",
                                  "commonMistakes": [
                                    "Esquecer reescrever em forma padrão antes de classificar",
                                    "Ignorar dependência de t em Lipschitz"
                                  ]
                                }
                              ],
                              "practicalExample": "Classifique o PVI: y' = y(1 - y) + t, y(0)=0.1. Resposta: Não-linear (y(1-y) quadrático), não-homogênea (termo +t), Lipschitz localmente perto de y=0.1 pois ∂f/∂y = 1 - 2y bounded em [-1,1] (K=3).",
                              "finalVerifications": [
                                "Classificar corretamente 90% de 10 EDOs mistas quanto a linearidade/homogeneidade.",
                                "Provar Lipschitz para 5 EDOs lineares e refutar para 2 não-lineares.",
                                "Explicar impacto da classificação em escolha de método numérico.",
                                "Criar fluxograma pessoal de classificação.",
                                "Resolver PVI simples e verificar unicidade prevista.",
                                "Identificar aplicações em 3 contextos de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de linearidade (100% em termos não-lineares).",
                                "Correta distinção homogênea/não-homogênea via termo forçante.",
                                "Aplicação rigorosa do teste de Lipschitz com cálculo de ∂f/∂y.",
                                "Justificativas matemáticas claras e concisas.",
                                "Integração de todas classificações em relatório coeso.",
                                "Uso apropriado de exemplos e contraexemplos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de oscilações em estruturas civis (EDOs lineares).",
                                "Computação: Implementação de solvers numéricos (ex: Runge-Kutta para Lipschitz).",
                                "Matemática Numérica: Estabilidade de métodos para não-lineares.",
                                "Engenharia de Materiais: Deformação viscoelástica (condição de unicidade)."
                              ],
                              "realWorldApplication": "Na engenharia civil, classificar EDOs de vibrações em pontes (ex: y'' + c y' + k y = f(t)) como linear amortecida permite usar métodos exatos ou numéricos garantidos por Lipschitz, prevendo falhas estruturais com soluções únicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Analisar rigidez em PVIs",
                            "description": "Identificar EDOs rígidas em PVIs, comuns em modelagem de engenharia civil como difusão em solos, e discutir implicações para escolha de métodos numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental de rigidez em EDOs",
                                  "subSteps": [
                                    "Defina rigidez como a presença de escalas temporais muito diferentes na solução da EDO, com componentes rápidos (parasitas) e lentos (físicos).",
                                    "Explique a diferença entre EDOs rígidas e não rígidas usando exemplos simples como y' = -λy, onde λ grande indica rigidez.",
                                    "Discuta por que métodos explícitos falham em EDOs rígidas devido à restrição de passo h < 2/λ_max.",
                                    "Compare estabilidade de métodos explícitos (ex: Euler) vs. implícitos (ex: Backward Euler).",
                                    "Revise condições de Lipschitz e como elas se relacionam com rigidez."
                                  ],
                                  "verification": "Resuma em um parágrafo as causas e consequências da rigidez, citando pelo menos dois exemplos matemáticos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de referência em EDOs (ex: Burden & Faires), notas de aula sobre estabilidade numérica.",
                                  "tips": "Use gráficos de soluções analíticas vs. numéricas para visualizar componentes rápidos.",
                                  "learningObjective": "Dominar a definição e causas matemáticas de rigidez em PVIs.",
                                  "commonMistakes": "Confundir rigidez com instabilidade geral; ignorar o papel das autovalores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar indicadores de rigidez em sistemas de EDOs de PVIs",
                                  "subSteps": [
                                    "Analise o espectro de autovalores da matriz jacobiana para detectar autovalores com partes reais grandes negativas.",
                                    "Examine coeficientes da EDO para diferenças de magnitude (ex: termos de difusão vs. reação).",
                                    "Calcule o índice de rigidez: max(|Re(λ_i)|) / min(|Re(λ_i)|) > 1000 indica rigidez.",
                                    "Teste numericamente com método explícito: se h_max for muito pequeno para precisão, suspeite de rigidez.",
                                    "Classifique o PVI como rígido ou não com base em exemplos de engenharia civil."
                                  ],
                                  "verification": "Aplique a um sistema de EDO simples e produza um relatório com autovalores e índice de rigidez.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software MATLAB ou Python (SciPy para autovalores), planilha para cálculos.",
                                  "tips": "Comece com sistemas lineares antes de não-lineares para simplificar.",
                                  "learningObjective": "Desenvolver critérios quantitativos e qualitativos para detectar rigidez.",
                                  "commonMistakes": "Focar apenas em autovalores reais, ignorando complexos; não normalizar escalas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar análise de rigidez a um PVI em modelagem de difusão em solos",
                                  "subSteps": [
                                    "Modele a difusão em solos como ∂c/∂t = D ∂²c/∂x² + R(c), onde R é termo reativo rígido.",
                                    "Discritize espacialmente para obter sistema de EDOs: dy/dt = A y + f(y), com A rígida.",
                                    "Compute autovalores de A e confirme rigidez devido a altas frequências espaciais.",
                                    "Simule com passos adaptativos e observe necessidade de h pequeno em métodos explícitos.",
                                    "Compare soluções com métodos implícitos para validar identificação."
                                  ],
                                  "verification": "Gere gráficos de solução numérica mostrando oscilações em explícito vs. estável em implícito.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python (NumPy, SciPy, Matplotlib), exemplo de código para difusão 1D.",
                                  "tips": "Use malha fina inicialmente para capturar rigidez espacial.",
                                  "learningObjective": "Aplicar detecção de rigidez a um contexto real de engenharia civil.",
                                  "commonMistakes": "Escolha inadequada de condições iniciais; não linearizar corretamente para jacobiana."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir implicações para escolha de métodos numéricos",
                                  "subSteps": [
                                    "Recomende métodos implícitos (ex: BDF, Rosenbrock) para EDOs rígidas em PVIs.",
                                    "Avalie trade-offs: custo computacional vs. eficiência em passos maiores.",
                                    "Explore solvers adaptativos (ex: ode15s no MATLAB) que detectam e tratam rigidez.",
                                    "Considere pré-condicionadores para sistemas lineares rígidos em engenharia.",
                                    "Elabore um fluxograma de decisão para seleção de método baseado em análise de rigidez."
                                  ],
                                  "verification": "Crie um fluxograma e justifique escolhas para dois cenários: rígido e não rígido.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Documentação de solvers (MATLAB ode45 vs ode15s), artigos sobre métodos para EDOs rígidas.",
                                  "tips": "Teste com dados reais de solos para relevância prática.",
                                  "learningObjective": "Ligar análise de rigidez à seleção otimizada de algoritmos numéricos.",
                                  "commonMistakes": "Subestimar custo de implícitos sem considerar passos maiores permitidos."
                                }
                              ],
                              "practicalExample": "Em um modelo de difusão de contaminantes em solo poroso (engenharia ambiental civil), a EDO rígida surge de termos de adsorção rápida vs. difusão lenta. Analisando autovalores da matriz de difusão discretizada (λ_max ≈ -10^6), confirma-se rigidez, exigindo solver implícito como ode23s no MATLAB para simular evolução de pluma de poluente em 24h com h=0.1h estável.",
                              "finalVerifications": [
                                "Identifica corretamente autovalores dominantes em um sistema rígido de difusão.",
                                "Produz gráfico comparando falha explícita vs. sucesso implícito.",
                                "Calcula índice de rigidez >1000 para exemplo de solo.",
                                "Explica implicações para estabilidade numérica em relatório.",
                                "Propõe método adequado com justificativa quantitativa.",
                                "Discute limitações em contextos de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e detecção de rigidez (30%)",
                                "Qualidade da análise numérica e gráficos (25%)",
                                "Relevância ao contexto de PVIs em engenharia civil (20%)",
                                "Profundidade na discussão de implicações para métodos (15%)",
                                "Clareza e estrutura do fluxograma/relatório (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise espectral e teoria de estabilidade de EDOs.",
                                "Programação: Implementação de solvers em Python/MATLAB.",
                                "Física: Modelagem de difusão e transporte em meios porosos.",
                                "Engenharia Ambiental: Simulações de contaminação de solos."
                              ],
                              "realWorldApplication": "Na análise de estabilidade de fundações em solos, modela-se consolidação com EDOs rígidas de drenagem; identificar rigidez permite usar métodos implícitos eficientes para prever assentamentos em barragens ou edifícios, otimizando projetos e reduzindo tempo de simulação de dias para horas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Explorar exemplos numéricos simples de PVIs",
                            "description": "Resolver analiticamente PVIs simples lineares de primeira ordem e interpretar soluções em contextos de engenharia civil, como decaimento radioativo em materiais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a formulação de PVIs lineares de primeira ordem",
                                  "subSteps": [
                                    "Identificar a forma geral de uma EDO linear de 1ª ordem: dy/dt + P(t)y = Q(t).",
                                    "Reconhecer condições de contorno iniciais: y(t0) = y0.",
                                    "Diferenciar PVIs de outros problemas de EDOs.",
                                    "Analisar exemplos simples como decaimento exponencial: dy/dt = -ky.",
                                    "Discutir relevância em engenharia civil, como perda de material radioativo."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a estrutura de um PVI com um exemplo próprio.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de EDOs, quadro branco ou software de anotações (ex: Notion).",
                                  "tips": "Use diagramas para visualizar a evolução temporal da solução.",
                                  "learningObjective": "Dominar a notação e componentes essenciais de PVIs lineares simples.",
                                  "commonMistakes": "Confundir ordem da EDO com grau do polinômio ou ignorar a condição inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver analiticamente um PVI simples",
                                  "subSteps": [
                                    "Calcular o fator integrante: μ(t) = exp(∫P(t) dt).",
                                    "Multiplicar a EDO por μ(t) e integrar ambos os lados.",
                                    "Aplicar a condição inicial para determinar a constante de integração.",
                                    "Simplificar a solução geral para casos homogêneos (Q(t)=0).",
                                    "Verificar a solução diferenciando e substituindo na EDO original."
                                  ],
                                  "verification": "Obter solução analítica correta para dy/dt = -0.1y, y(0)=100.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora simbólica (ex: Wolfram Alpha), papel e lápis.",
                                  "tips": "Pratique com k constante primeiro antes de funções variáveis.",
                                  "learningObjective": "Aplicar o método de fator integrante para soluções exatas.",
                                  "commonMistakes": "Erros no sinal do fator integrante ou na integração indefinida."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar numericamente o PVI usando método simples",
                                  "subSteps": [
                                    "Implementar o método de Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Escolher passo h pequeno (ex: 0.1) e intervalo temporal [0,10].",
                                    "Construir tabela de valores numéricos e plotar gráfico.",
                                    "Comparar solução numérica com a analítica para validar precisão.",
                                    "Analisar erro de truncamento variando h."
                                  ],
                                  "verification": "Gerar tabela/plano com erro <5% em relação à solução exata.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha Excel ou Python (Jupyter Notebook com matplotlib).",
                                  "tips": "Use h=0.01 para precisão inicial; plote para visualização intuitiva.",
                                  "learningObjective": "Implementar e validar aproximações numéricas básicas de PVIs.",
                                  "commonMistakes": "Passo h muito grande causando divergência ou instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar soluções em contextos de engenharia civil",
                                  "subSteps": [
                                    "Mapear parâmetros: k como taxa de decaimento radioativo em materiais.",
                                    "Prever tempo para y(t)<limite de segurança (ex: y(0)=1000 Bq/g).",
                                    "Discutir implicações: tempo de meia-vida, segurança estrutural.",
                                    "Analisar sensibilidade a variações em y0 ou k.",
                                    "Relacionar com normas de engenharia (ex: ABNT NBR para radiação)."
                                  ],
                                  "verification": "Redigir relatório curto (1 página) com interpretação prática.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Dados reais de decaimento (fontes online), software de plotagem.",
                                  "tips": "Use unidades físicas reais para maior realismo.",
                                  "learningObjective": "Conectar soluções matemáticas a problemas reais de engenharia.",
                                  "commonMistakes": "Ignorar unidades ou contexto físico na interpretação."
                                }
                              ],
                              "practicalExample": "Considere um material de construção contaminado com isótopo radioativo: dy/dt = -0.05 y (Bq/g por dia), y(0)=500 Bq/g. Resolver analiticamente: y(t)=500 e^{-0.05t}. Numericamente com Euler (h=1 dia): tabela até t=20 dias, plotar decaimento para verificar quando y(t)<50 Bq/g (limite seguro).",
                              "finalVerifications": [
                                "Solução analítica correta para pelo menos 2 exemplos simples.",
                                "Tabela numérica com erro relativo <10% vs. analítica.",
                                "Gráfico comparativo solução exata vs. numérica.",
                                "Interpretação correta de tempo de meia-vida (t= ln2/k).",
                                "Relatório com aplicação em decaimento radioativo.",
                                "Identificação de 3 erros comuns em simulações numéricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução analítica (100% correto).",
                                "Implementação numérica estável e precisa (erro <5%).",
                                "Qualidade da visualização gráfica e tabelas.",
                                "Profundidade da interpretação contextual em engenharia.",
                                "Clareza na identificação de erros e dicas práticas.",
                                "Conexões interdisciplinares relevantes demonstradas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Leis de decaimento exponencial e radioatividade.",
                                "Química: Cinética de reações de primeira ordem em materiais.",
                                "Computação: Algoritmos numéricos e programação em Python/Excel.",
                                "Estatística: Análise de erro e validação de modelos.",
                                "Gestão Ambiental: Normas de segurança radiológica em construções."
                              ],
                              "realWorldApplication": "Em engenharia civil, modela decaimento radioativo em concretos contaminados por acidentes nucleares, permitindo prever tempo para reutilização segura de estruturas, conformidade com normas ABNT e planejamento de descontaminação."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Problema de Valor de Contorno",
                    "description": "Formulação e características de equações diferenciais com condições especificadas em pontos de contorno distintos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Formulação do Problema de Valor de Contorno",
                        "description": "Definição matemática e estruturação de equações diferenciais ordinárias ou parciais com condições de contorno especificadas em pontos distintos do domínio.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Identificar um Problema de Valor de Contorno (PVC)",
                            "description": "Reconhecer a estrutura de um PVC a partir de uma equação diferencial com condições impostas em extremos distintos do intervalo, diferenciando-o de problemas de valor inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Problemas de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Estude a definição de PVI: equação diferencial com condições especificadas em um único ponto inicial (ex.: y(x₀) = y₀ para EDO de 1ª ordem).",
                                    "Analise exemplos típicos de PVI, como y' = ky com y(0) = y₀ (crescimento exponencial).",
                                    "Identifique que PVIs são comuns em problemas evolutivos no tempo ou em uma direção única.",
                                    "Compare com problemas sem condições iniciais para entender a necessidade de condições.",
                                    "Anote as características: condições no mesmo extremo do intervalo."
                                  ],
                                  "verification": "Explique em voz alta ou por escrito as diferenças fundamentais de um PVI, citando um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre EDOs",
                                    "Livro texto de Equações Diferenciais",
                                    "Vídeo tutorial sobre PVI (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use diagramas de setas para visualizar a 'direção inicial' do problema.",
                                  "learningObjective": "Compreender a estrutura de PVIs como base para diferenciação com PVCs.",
                                  "commonMistakes": [
                                    "Confundir condições iniciais com condições em múltiplos pontos",
                                    "Ignorar o contexto físico (tempo vs. espaço)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Definição e Estrutura de um Problema de Valor de Contorno (PVC)",
                                  "subSteps": [
                                    "Defina PVC: equação diferencial com condições de contorno impostas em dois ou mais pontos distintos do intervalo (ex.: y(a) = α, y(b) = β, onde a ≠ b).",
                                    "Estude EDOs de 2ª ordem comuns em PVCs, como y'' + p(x)y' + q(x)y = g(x).",
                                    "Identifique os 'extremos distintos': condições em limites opostos do domínio espacial.",
                                    "Explore aplicações físicas: vibrações de cordas, fluxo de calor em barras.",
                                    "Diferencie de PVIs: PVCs resolvem problemas estacionários ou espaciais."
                                  ],
                                  "verification": "Escreva a definição de PVC e forneça um exemplo simples com condições em extremos distintos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de exercícios sobre PVC",
                                    "Software como MATLAB ou Python (SymPy) para visualizar",
                                    "Artigo introdutório sobre PVCs"
                                  ],
                                  "tips": "Pense em 'contorno' como fronteiras físicas de um objeto.",
                                  "learningObjective": "Reconhecer os elementos essenciais que definem um PVC.",
                                  "commonMistakes": [
                                    "Achar que qualquer EDO com duas condições é PVC",
                                    "Não notar que condições devem ser em pontos distintos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Estrutura de Equações Diferenciais para Identificação",
                                  "subSteps": [
                                    "Examine a forma geral: EDO + condições de contorno em x = a e x = L (intervalo [a,L]).",
                                    "Identifique termos: ordem da EDO, coeficientes, função forçante e condições.",
                                    "Classifique: se condições em extremos distintos → PVC; se em um ponto → PVI.",
                                    "Pratique decompondo 3 equações exemplo: destaque condições em negrito.",
                                    "Verifique unicidade: PVCs de 2ª ordem precisam de 2 condições de contorno."
                                  ],
                                  "verification": "Decomponha uma equação dada em componentes e classifique como PVC ou não.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de 5 equações mistas (PVI/PVC)",
                                    "Caneta e papel para anotações",
                                    "Calculadora simbólica online"
                                  ],
                                  "tips": "Sempre pergunte: 'Onde estão as condições? São em pontos diferentes?'",
                                  "learningObjective": "Desenvolver habilidade de parsear problemas matemáticos rapidamente.",
                                  "commonMistakes": [
                                    "Contar condições sem verificar posições",
                                    "Confundir condições de derivada com posição"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Diferenciação e Identificação em Exemplos Reais",
                                  "subSteps": [
                                    "Resolva 5 exercícios: classifique como PVI ou PVC e justifique.",
                                    "Compare pares semelhantes: um PVI e um PVC com mesma EDO.",
                                    "Crie seu próprio exemplo de PVC no contexto de engenharia civil.",
                                    "Discuta com colega ou tutor: explique por que é PVC.",
                                    "Registre acertos/erros para autoavaliação."
                                  ],
                                  "verification": "Classifique corretamente pelo menos 4 de 5 problemas propostos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha de exercícios (Google Sheets ou PDF)",
                                    "Fórum online de dúvidas (StackExchange)",
                                    "Exemplos de engenharia civil"
                                  ],
                                  "tips": "Use cores: verde para condições em extremos distintos.",
                                  "learningObjective": "Aplicar o conhecimento para identificar PVCs de forma autônoma.",
                                  "commonMistakes": [
                                    "Influência de contexto físico ignorado",
                                    "Não justificar a diferenciação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação diferencial y''(x) - y(x) = 0 no intervalo [0, π], com condições y(0) = 0 e y(π) = 0. Isso é um PVC porque as condições de contorno estão impostas nos extremos distintos x=0 e x=π, modelando uma corda fixa nas pontas.",
                              "finalVerifications": [
                                "Classifica corretamente 5 exemplos mistos de PVI e PVC.",
                                "Explica a diferença estrutural entre PVI e PVC em termos de condições.",
                                "Identifica extremos distintos em qualquer equação dada.",
                                "Justifica classificações com base na definição formal.",
                                "Cria um exemplo próprio de PVC válido.",
                                "Diferencia PVC de problemas misto ou sobre-determinado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de condições de contorno (90% acerto).",
                                "Clareza na justificativa da diferenciação PVI vs PVC.",
                                "Compreensão do contexto espacial vs temporal.",
                                "Capacidade de decompor equações em componentes.",
                                "Criatividade em exemplos aplicados à engenharia.",
                                "Evita erros comuns como confusão de posições de condições."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Equações Diferenciais Ordinárias.",
                                "Física: Modelagem de ondas e difusão de calor.",
                                "Computação: Implementação numérica com métodos de diferenças finitas.",
                                "Engenharia Civil: Análise estrutural de vigas e placas.",
                                "Estatística: Sensibilidade a condições de contorno em simulações."
                              ],
                              "realWorldApplication": "Na engenharia civil, identificar PVCs é crucial para modelar deformações em vigas com apoios fixos nas extremidades (ex.: y(0)=0, y(L)=0), permitindo simulações computacionais precisas de estruturas sob carga estática."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Formular uma equação diferencial como PVC",
                            "description": "Escrever a forma geral de uma equação diferencial de segunda ordem com condições de contorno em x=a e x=b, incluindo exemplos como y'' + p(x)y' + q(x)y = r(x).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma geral da equação diferencial linear de segunda ordem",
                                  "subSteps": [
                                    "Relembrar que uma EDO de segunda ordem é da forma y'' + p(x)y' + q(x)y = r(x)",
                                    "Identificar os termos: y'' (segunda derivada), p(x)y' (primeira derivada com coeficiente variável), q(x)y (termo da função) e r(x) (termo forçante)",
                                    "Verificar se a equação é linear (coeficientes multiplicam derivadas e função sem produtos não lineares)",
                                    "Exemplificar com p(x), q(x) e r(x) como funções contínuas no intervalo",
                                    "Diferenciar de EDOs homogêneas (r(x)=0) e não homogêneas"
                                  ],
                                  "verification": "Escrever corretamente a forma geral y'' + p(x)y' + q(x)y = r(x) e explicar cada termo verbalmente",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Equações Diferenciais",
                                    "Calculadora gráfica"
                                  ],
                                  "tips": "Sempre normalize dividindo pelo coeficiente de y'' se necessário para colocá-la na forma padrão",
                                  "learningObjective": "Dominar a estrutura matemática da EDO linear de segunda ordem",
                                  "commonMistakes": [
                                    "Confundir com EDOs de primeira ordem",
                                    "Esquecer que coeficientes p(x), q(x) podem ser funções de x",
                                    "Ignorar a linearidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o domínio do problema e os pontos de contorno",
                                  "subSteps": [
                                    "Estabelecer o intervalo de interesse [a, b] onde a solução y(x) é buscada",
                                    "Explicar que a = ponto inicial e b = ponto final do domínio físico (ex: comprimento de uma viga)",
                                    "Garantir que p(x), q(x), r(x) sejam contínuos em [a, b] para existência de solução",
                                    "Discutir condições para unicidade via teorema de existência e unicidade",
                                    "Esboçar graficamente o domínio como um eixo x de a a b"
                                  ],
                                  "verification": "Desenhar o intervalo [a, b] e listar funções contínuas definidas nele",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de plotagem como Desmos ou MATLAB"
                                  ],
                                  "tips": "Escolha [a,b] baseado no problema físico para evitar singularidades nos coeficientes",
                                  "learningObjective": "Especificar corretamente o domínio espacial do PVC",
                                  "commonMistakes": [
                                    "Definir domínio aberto em vez de fechado [a,b]",
                                    "Não verificar continuidade das funções",
                                    "Confundir com problemas de valor inicial (IVP)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar as condições de contorno em x=a e x=b",
                                  "subSteps": [
                                    "Definir condições de Dirichlet: y(a) = α e y(b) = β (valores da função)",
                                    "Definir condições de Neumann: y'(a) = γ e y'(b) = δ (derivadas)",
                                    "Combinar tipos mistos, ex: y(a) = α e y'(b) = δ",
                                    "Garantir que as condições sejam suficientes para segunda ordem (duas condições)",
                                    "Verificar compatibilidade com o problema físico"
                                  ],
                                  "verification": "Escrever duas condições independentes envolvendo y ou y' em a e b",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de tipos de condições de contorno"
                                  ],
                                  "tips": "Para problemas simétricos, condições podem ser y'(a)=0 e y'(b)=0 em vigas",
                                  "learningObjective": "Selecionar e formular condições de contorno apropriadas",
                                  "commonMistakes": [
                                    "Usar apenas uma condição",
                                    "Confundir y(a) com y'(a)",
                                    "Condições inconsistentes com a ordem da EDO"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular o problema de valor de contorno completo",
                                  "subSteps": [
                                    "Combinar a EDO y'' + p(x)y' + q(x)y = r(x) com as condições y(a)=α, y(b)=β (ou equivalentes)",
                                    "Escrever explicitamente: Encontrar y(x) tal que [EDO] para x ∈ [a,b], sujeito a [condições]",
                                    "Verificar notação padrão e clareza",
                                    "Testar com um exemplo simples para validar",
                                    "Preparar para métodos numéricos de solução"
                                  ],
                                  "verification": "Apresentar a formulação completa e resolvê-la analiticamente para caso trivial",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software simbólico como Mathematica ou SymPy"
                                  ],
                                  "tips": "Use notação LaTeX ou clara para documentar a formulação final",
                                  "learningObjective": "Integrar EDO e condições em um PVC coeso",
                                  "commonMistakes": [
                                    "Esquecer o domínio [a,b]",
                                    "Não especificar 'sujeito a' as condições",
                                    "Misturar notação de IVP"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga de comprimento L=1m com carga distribuída w(x)=x, a equação é y''(x) = x/(EI) para x ∈ [0,1], com condições de contorno y(0)=0 (apoiada) e y(1)=0 (apoiada), onde EI é a rigidez flexural constante.",
                              "finalVerifications": [
                                "A EDO está na forma padrão y'' + p(x)y' + q(x)y = r(x)?",
                                "O domínio [a,b] está explicitamente definido?",
                                "Existem exatamente duas condições de contorno em x=a e x=b?",
                                "As funções p,q,r são contínuas em [a,b]?",
                                "A formulação menciona 'encontrar y(x) tal que...' claramente?",
                                "Compatibilidade física das condições é discutida?"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da forma da EDO (30%)",
                                "Precisão nas condições de contorno (25%)",
                                "Clareza e notação padrão (20%)",
                                "Verificação de continuidade e domínio (15%)",
                                "Preparação para solução computacional (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica dos Materiais (deflexão de vigas)",
                                "Computação: Métodos Numéricos (diferenças finitas para PVC)",
                                "Matemática: Teoria de Equações Diferenciais",
                                "Engenharia: Análise Estrutural"
                              ],
                              "realWorldApplication": "Formulação de problemas de deflexão em vigas ou barras em estruturas civis, essenciais para simulações em software como ANSYS ou SAP2000, prevendo deformações sob cargas reais em pontes e edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Classificar tipos de condições de contorno",
                            "description": "Distinguir condições de Dirichlet (valor da função), Neumann (derivada) e mistas em problemas de contorno, com exemplos aplicados a vigas ou perfis em engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de Condições de Contorno",
                                  "subSteps": [
                                    "Defina condições de contorno como restrições impostas nas fronteiras de um domínio em problemas de valores de contorno.",
                                    "Explique o papel das condições de contorno na solução única de EDOs elípticas ou parabólicas.",
                                    "Identifique os tipos principais: Dirichlet, Neumann e mistas.",
                                    "Revise a notação matemática: u(x) = g(x) para Dirichlet e u'(x) = h(x) para Neumann.",
                                    "Discuta a importância em problemas físicos como equilíbrio térmico ou deformação estrutural."
                                  ],
                                  "verification": "Resuma em suas palavras os três tipos principais e forneça uma equação exemplo para cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de EDOs (ex: Boyce & DiPrima)",
                                    "Folha de papel e caneta",
                                    "Vídeo tutorial sobre problemas de contorno (Khan Academy)"
                                  ],
                                  "tips": "Use diagramas para visualizar o domínio e as fronteiras.",
                                  "learningObjective": "Compreender o conceito e a classificação básica de condições de contorno.",
                                  "commonMistakes": [
                                    "Confundir valor da função com sua derivada",
                                    "Ignorar a necessidade de condições para unicidade da solução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Condições de Dirichlet",
                                  "subSteps": [
                                    "Defina condição de Dirichlet: especifica o valor exato da função na fronteira (u = valor conhecido).",
                                    "Resolva um exemplo simples: u(0) = 0 e u(L) = 1 em uma barra térmica.",
                                    "Aplique a um problema de viga: deslocamento fixo nas extremidades (u(0) = u(L) = 0).",
                                    "Calcule uma solução analítica básica para ilustrar.",
                                    "Compare com condições livres."
                                  ],
                                  "verification": "Escreva e resolva um problema de Dirichlet para uma viga cantilever.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (SymPy)",
                                    "Exemplos de problemas de vigas em PDF",
                                    "Calculadora gráfica"
                                  ],
                                  "tips": "Sempre associe a condição física: 'fixo' geralmente é Dirichlet.",
                                  "learningObjective": "Dominar a identificação e aplicação de condições de Dirichlet com exemplos estruturais.",
                                  "commonMistakes": [
                                    "Aplicar Dirichlet onde Neumann é apropriado, como em superfícies livres"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Condições de Neumann",
                                  "subSteps": [
                                    "Defina condição de Neumann: especifica a derivada normal da função na fronteira (du/dn = valor conhecido).",
                                    "Interprete fisicamente: fluxo de calor zero ou momento zero em vigas.",
                                    "Exemplo: du/dx(0) = 0 e du/dx(L) = q em uma viga com carga distribuída.",
                                    "Discuta compatibilidade: integral da derivada deve satisfazer condições de solvibilidade.",
                                    "Resolva numericamente um caso simples."
                                  ],
                                  "verification": "Classifique corretamente 3 exemplos de fronteiras em um diagrama de viga.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Excel para simulações simples",
                                    "Artigo sobre análise de vigas",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Lembre-se: Neumann modela 'livre' ou 'isolado', não valores absolutos.",
                                  "learningObjective": "Identificar e aplicar condições de Neumann em contextos de engenharia civil.",
                                  "commonMistakes": [
                                    "Confundir derivada com valor da função",
                                    "Esquecer condições de compatibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Condições Mistas e Classificação Geral",
                                  "subSteps": [
                                    "Defina condições mistas: combinação de Dirichlet e Neumann em diferentes fronteiras.",
                                    "Exemplo em perfil aerodinâmico: Dirichlet em uma extremidade, Neumann na outra.",
                                    "Crie uma tabela comparativa: tipo, notação, interpretação física, exemplo em viga.",
                                    "Classifique problemas reais: viga engastada (Dirichlet + Neumann).",
                                    "Pratique classificação em 5 problemas variados."
                                  ],
                                  "verification": "Classifique corretamente um problema misto fornecido e justifique.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela em branco para comparação",
                                    "Casos de estudo de engenharia civil (PDFs)",
                                    "Quiz online sobre BVP"
                                  ],
                                  "tips": "Use fluxogramas para decisão: 'Valor dado? Dirichlet. Derivada? Neumann.'",
                                  "learningObjective": "Classificar condições mistas e integrar conhecimentos em cenários complexos.",
                                  "commonMistakes": [
                                    "Classificar incorretamente mistas como puras",
                                    "Ignorar o contexto físico"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar Classificação em Exemplos de Engenharia Civil",
                                  "subSteps": [
                                    "Analise uma viga simply supported: Dirichlet em ambas extremidades.",
                                    "Examine uma viga cantilever: Dirichlet no engaste, Neumann na ponta livre.",
                                    "Classifique condições em um perfil de fundação sob carga.",
                                    "Simule em software e verifique classificação.",
                                    "Discuta erros comuns em modelagem FEM."
                                  ],
                                  "verification": "Produza um relatório curto classificando 3 estruturas reais.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Software ANSYS ou Ftool",
                                    "Imagens de vigas e perfis",
                                    "Manual de estruturas"
                                  ],
                                  "tips": "Sempre valide com física: o que acontece na fronteira?",
                                  "learningObjective": "Aplicar classificação em problemas reais de engenharia civil.",
                                  "commonMistakes": [
                                    "Desconsiderar simetria em problemas",
                                    "Confundir rolamento com engaste"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever de comprimento L sob carga uniforme, a condição no engaste (x=0) é Dirichlet u(0)=0 (deslocamento zero) e no ponta livre (x=L) é Neumann u'(L)=0 (rotação zero, momento zero). Classifique e escreva as equações da equação diferencial de Euler-Bernoulli.",
                              "finalVerifications": [
                                "Classifica corretamente Dirichlet, Neumann e mistas em 5 exemplos dados.",
                                "Explica diferenças físicas com precisão em vigas e perfis.",
                                "Escreve notação matemática correta para cada tipo.",
                                "Identifica condições de solvibilidade em Neumann.",
                                "Aplica classificação em um problema de engenharia civil real.",
                                "Cria tabela comparativa funcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e classificação (40%)",
                                "Uso correto de exemplos estruturais (20%)",
                                "Clareza na notação matemática (15%)",
                                "Profundidade de interpretação física (15%)",
                                "Criatividade em aplicações mistas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs e PDEs elípticas.",
                                "Física: Mecânica dos sólidos e transferência de calor.",
                                "Programação: Implementação em métodos numéricos (finite differences).",
                                "Engenharia Mecânica: Análise de tensões semelhantes.",
                                "Computação Científica: Pré-processamento em FEM."
                              ],
                              "realWorldApplication": "Na análise estrutural de pontes ou edifícios, classificar condições de contorno corretamente garante precisão em simulações FEM, evitando colapsos por modelagem errada, como em vigas com apoios variados."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Características dos Problemas de Valor de Contorno",
                        "description": "Propriedades matemáticas, como existência e unicidade de soluções, estabilidade e relação com autovalores, além de importância em modelagem computacional.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Explicar existência e unicidade de soluções em PVC",
                            "description": "Descrever os teoremas de existência e unicidade para PVCs lineares homogêneos, incluindo o papel da matriz de Gram e condicionamento para problemas discretizados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Problemas de Valor de Contorno (PVC) Lineares Homogêneos",
                                  "subSteps": [
                                    "Definir formalmente um PVC linear homogâneo: encontrar u tal que Au = f com condições de contorno homogêneas Bu=0.",
                                    "Explicar o espaço de funções apropriado, como H^1(Ω) para problemas elípticos.",
                                    "Discutir a forma variacional fraca: ∫∇u·∇v dx = ∫f v dx para todo v em espaço de teste.",
                                    "Identificar hipóteses básicas: coeficientes suaves, domínio Lipschitz.",
                                    "Diferenciar PVC homogêneo de não-homogêneo."
                                  ],
                                  "verification": "Escrever a formulação variacional de um PVC simples e verificar se satisfaz as condições homogêneas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Análise Numérica de EDEs' de Brenner e Scott",
                                    "Notebook com equações LaTeX"
                                  ],
                                  "tips": "Sempre comece pela formulação forte e passe para a fraca para evitar confusões.",
                                  "learningObjective": "Dominar a definição e formulação variacional de PVCs lineares homogêneos.",
                                  "commonMistakes": [
                                    "Confundir condições homogêneas com fontes nulas",
                                    "Ignorar requisitos de regularidade do domínio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Teoremas de Existência e Unicidade (Lax-Milgram)",
                                  "subSteps": [
                                    "Enunciar o teorema de Lax-Milgram: bilinear a(u,v) contínua, coerciva e linear contínua b(v).",
                                    "Provar coercividade: existe α>0 tal que a(u,u) ≥ α||u||^2.",
                                    "Provar continuidade: |a(u,v)| ≤ β||u||||v||.",
                                    "Aplicar a existência via Riesz e unicidade via coercividade.",
                                    "Discutir exemplos: equação de Poisson -Δu=0 com Dirichlet homogêneo."
                                  ],
                                  "verification": "Provar Lax-Milgram para o problema -Δu=f em Ω, u=0 em ∂Ω.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Notas de Evans 'PDE'",
                                    "Software SymPy para manipulação simbólica"
                                  ],
                                  "tips": "Verifique coercividade testando com funções de teste específicas como constantes.",
                                  "learningObjective": "Aplicar teoremas funcionais para garantir existência e unicidade.",
                                  "commonMistakes": [
                                    "Confundir coercividade com positividade",
                                    "Esquecer continuidade da forma linear"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Discretização e Matriz de Gram",
                                  "subSteps": [
                                    "Explicar discretização via Elementos Finitos: base {φ_i}, matriz A_ij = a(φ_j, φ_i).",
                                    "Definir matriz de Gram G_ij = (φ_i, φ_j)_{L2} ou inner product relevante.",
                                    "Mostrar que A é a matriz de Gram da forma bilinear no espaço discreto.",
                                    "Discutir propriedades: simetria, definitude positiva se coerciva.",
                                    "Implementar montagem de A em código simples para malha 1D."
                                  ],
                                  "verification": "Montar matriz A para malha uniforme em [0,1] e verificar se é simétrica positiva definida.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "FEniCS ou MATLAB para EF",
                                    "Código Python com NumPy/SciPy"
                                  ],
                                  "tips": "Use malhas uniformes inicialmente para depuração fácil.",
                                  "learningObjective": "Conectar teoria contínua à discretização via matrizes de Gram.",
                                  "commonMistakes": [
                                    "Esquecer integração numérica nos elementos",
                                    "Confundir Gram L2 com bilinear energy"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Condicionamento em Problemas Discretizados",
                                  "subSteps": [
                                    "Definir número de condicionamento κ(A) = ||A|| ||A^{-1}||.",
                                    "Analisar como refino h→0 afeta κ: para Poisson, κ~1/h^2.",
                                    "Discutir papel da matriz de Gram: eigenvalues extremas ditam condicionamento.",
                                    "Explicar impactos: perda de precisão numérica, necessidade de pré-condicionadores.",
                                    "Testar numericamente: plotar log(κ) vs log(h)."
                                  ],
                                  "verification": "Calcular κ para malhas crescentes e confirmar escalamento O(1/h^2).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB eig() ou SciPy linalg.cond",
                                    "Gráficos com Matplotlib"
                                  ],
                                  "tips": "Use decomposição SVD para eigenvalues precisas em matrizes grandes.",
                                  "learningObjective": "Avaliar estabilidade numérica via condicionamento.",
                                  "commonMistakes": [
                                    "Ignorar normalização da base",
                                    "Confundir condicionamento espectral com Frobenius"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVC -u''(x)=0 em [0,1], u(0)=u(1)=0, a solução única é u=0. Discretize com EF lineares: monte A (tridiagonal [1,-0.5,-0.5]) e verifique det(A)>0, cond(A) crescente com N.",
                              "finalVerifications": [
                                "Enunciar corretamente Lax-Milgram com condições.",
                                "Montar e analisar matriz de Gram para exemplo 1D.",
                                "Plotar condicionamento vs tamanho de malha.",
                                "Explicar por que unicidade falha sem coercividade.",
                                "Verificar numericamente independência linear da base discreta.",
                                "Discutir limites para domínios não-convexos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado de teoremas (90% correto).",
                                "Correta montagem e propriedades da matriz A (sem erros de indexação).",
                                "Análise qualitativa/quantitativa de condicionamento.",
                                "Conexão clara entre teoria contínua e discreta.",
                                "Uso apropriado de exemplos e contraexemplos.",
                                "Clareza na explicação do papel da coercividade."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores e definitude positiva.",
                                "Análise Numérica: estabilidade e pré-condicionadores.",
                                "Física/Engenharia: modelagem de elastostática e difusão.",
                                "Programação: implementação de solvers EF."
                              ],
                              "realWorldApplication": "Em engenharia civil, garante soluções únicas em análises de estruturas (equações elípticas para tensões) e fluxo em barragens, evitando ambiguidades em simulações FEM que previnem falhas estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Analisar autovalores e autofunções em PVCs",
                            "description": "Identificar problemas de autovalores em PVCs homogêneos, como no caso de equações de Sturm-Liouville, e sua relevância para expansões em séries.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de autovalores e autofunções em PVCs",
                                  "subSteps": [
                                    "Defina autovalor λ e autofunção φ(x) em um PVC homogêneo: L[φ] = λ W[φ], onde L é operador diferencial e W é peso.",
                                    "Explique a diferença entre PVCs homogêneos e não homogêneos.",
                                    "Identifique condições de contorno separáveis e regulares.",
                                    "Revise equações diferenciais lineares de segunda ordem associadas.",
                                    "Discuta singularidades e intervalos finitos/infinito."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e dê um exemplo simples de PVC com autovalor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de EDP (ex: Strauss), notas de aula, calculadora simbólica (Mathematica/MATLAB).",
                                  "tips": "Use analogias físicas como modos de vibração para fixar ideias.",
                                  "learningObjective": "Dominar definições e contexto teórico de autovalores em PVCs.",
                                  "commonMistakes": "Confundir autovalores com raízes características de EDOs ordinárias."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular problemas de Sturm-Liouville padrão",
                                  "subSteps": [
                                    "Escreva a forma padrão: - (p(x) y')' + q(x) y = λ r(x) y, com condições de contorno α y(a) + β y'(a) = 0 e γ y(b) + δ y'(b) = 0.",
                                    "Verifique autoadjunção e regularidade do problema.",
                                    "Classifique problemas singulares vs. regulares.",
                                    "Transforme equações não padrão em forma SL via mudança de variáveis.",
                                    "Liste propriedades básicas: autovalores reais, autofunções ortogonais."
                                  ],
                                  "verification": "Formule 2 problemas SL de um conjunto dado e verifique autoadjunção.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folhas de exercícios, software Maple ou Python (SymPy).",
                                  "tips": "Sempre normalize o peso r(x) para 1 inicialmente para simplificar.",
                                  "learningObjective": "Capacitar formulação precisa de PVCs como problemas SL.",
                                  "commonMistakes": "Ignorar condições de contorno ao verificar autoadjunção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver analiticamente para autovalores e autofunções",
                                  "subSteps": [
                                    "Assuma separação de variáveis e resolva a EDO resultante para φ(x).",
                                    "Aplique condições de contorno para encontrar equação transcendental em λ.",
                                    "Solucione para autovalores λ_n e autofunções φ_n(x).",
                                    "Normalize as autofunções no espaço L2 com peso r(x).",
                                    "Plote as primeiras 3 autofunções para visualização."
                                  ],
                                  "verification": "Resolva um PVC SL simples (ex: y'' + λ y = 0, y(0)=y(π)=0) e liste λ1, λ2, φ1, φ2.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Papel quadriculado, Wolfram Alpha para verificação, MATLAB para plot.",
                                  "tips": "Comece com casos clássicos como Laplace ou calor para ganhar confiança.",
                                  "learningObjective": "Executar resolução passo a passo de PVCs SL.",
                                  "commonMistakes": "Esquecer fator de normalização ou sinal nos autovalores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar propriedades e relevância para séries",
                                  "subSteps": [
                                    "Prove ortogonalidade: ∫ φ_m φ_n r dx = 0 se m ≠ n.",
                                    "Discuta completeza do conjunto {φ_n} para expansão em séries.",
                                    "Calcule coeficientes de Fourier-SL para função f(x): c_n = ∫ f φ_n r dx / ||φ_n||^2.",
                                    "Aplique em um PVC não homogêneo via expansão.",
                                    "Avalie convergência e Gibbs phenomenon em séries SL."
                                  ],
                                  "verification": "Expanda f(x)=x em [0,π] usando autofunções do Step 3 e compute 5 termos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Calculadora numérica, Python (NumPy/SciPy para integrais).",
                                  "tips": "Use simetria da função f(x) para simplificar integrais.",
                                  "learningObjective": "Conectar autovalores a métodos de séries para soluções PVC.",
                                  "commonMistakes": "Não ponderar integrais com r(x) ou confundir normas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar numericamente e validar",
                                  "subSteps": [
                                    "Discretize o PVC via diferenças finitas para matriz autovalor.",
                                    "Use eig() no MATLAB/Python para aproximar λ_n e φ_n.",
                                    "Compare resultados analíticos vs. numéricos para n=1-5.",
                                    "Analise erro de truncamento e convergência.",
                                    "Simule aplicação em engenharia (ex: viga vibrante)."
                                  ],
                                  "verification": "Gere tabela comparativa analítico-numérico com erro <1%.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Python (SciPy.linalg.eig), código template.",
                                  "tips": "Use malha fina (N>100) para precisão em autovalores altos.",
                                  "learningObjective": "Validar análise teórica com computação.",
                                  "commonMistakes": "Malha grosseira levando a autovalores espúrios."
                                }
                              ],
                              "practicalExample": "Em uma viga de concreto presa em uma extremidade e livre na outra (PVC: y'' + λ y = 0, y(0)=y'(L)=0), encontre os autovalores λ_n = ((2n-1)π/(2L))^2 e autofunções sen((2n-1)π x /(2L)), use para expandir carga distribuída f(x)=x em séries e prever deformações modais.",
                              "finalVerifications": [
                                "Lista correta de 3 autovalores e autofunções normalizadas para PVC padrão.",
                                "Cálculo preciso de 3 coeficientes de série Fourier-SL.",
                                "Gráfico de convergência da série com erro <0.01.",
                                "Implementação numérica com concordância analítica.",
                                "Explicação da relevância para expansões em problemas não homogêneos.",
                                "Identificação de pelo menos 2 propriedades SL comprovadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (20%): Definições e formulação corretas.",
                                "Resolução analítica (25%): Passos exatos sem erros algébricos.",
                                "Análise de propriedades (20%): Provas e cálculos de ortogonalidade.",
                                "Aplicação em séries (15%): Coeficientes e convergência corretos.",
                                "Validação numérica (10%): Comparação e análise de erro.",
                                "Clareza e documentação (10%): Gráficos, tabelas e explicações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração em estruturas civis.",
                                "Computação: Métodos numéricos de autovalores (eigendecomposição).",
                                "Matemática Aplicada: Análise funcional e espaços de Hilbert.",
                                "Engenharia Mecânica: Análise modal de vigas e placas."
                              ],
                              "realWorldApplication": "Na análise de vibrações de pontes ou edifícios, autovalores de PVCs SL determinam frequências naturais para evitar ressonância em terremotos; usado em software como ANSYS para design sísmico seguro."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.3",
                              "10.1.1.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Relacionar PVCs com aplicações em Engenharia Civil",
                            "description": "Exemplificar o uso de PVCs em modelagem de deflexões de vigas, fluxo em tubulações ou distribuição de tensões, destacando condições de contorno físicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos dos Problemas de Valor de Contorno (PVCs)",
                                  "subSteps": [
                                    "Definir PVC como problemas diferenciais com condições especificadas nas fronteiras do domínio.",
                                    "Diferenciar PVC de Problemas de Valor Inicial (PVI), destacando condições em boundaries vs. condições iniciais.",
                                    "Identificar tipos de condições de contorno: Dirichlet (valor fixo), Neumann (derivada fixa) e Robin (mistura).",
                                    "Exemplificar com equações diferenciais ordinárias (EDOs) simples, como y'' + y = 0 com y(0)=0 e y'(π)=0.",
                                    "Discutir relevância em equações diferenciais parciais (EDPs) para fenômenos contínuos."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a diferença entre PVC e PVI com um exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de EDOs/EDPs",
                                    "Slides ou vídeo introdutório sobre PVCs",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Use diagramas para visualizar boundaries e condições.",
                                  "learningObjective": "Dominar definição, tipos e diferenças fundamentais de PVCs.",
                                  "commonMistakes": "Confundir condições de contorno com condições iniciais em problemas dinâmicos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar aplicações gerais de PVCs em Engenharia Civil",
                                  "subSteps": [
                                    "Mapear PVCs em mecânica estrutural: deflexões de vigas e placas.",
                                    "Relacionar com mecânica dos fluidos: fluxo em tubulações e canais.",
                                    "Associar à análise de tensões: distribuição em barragens e fundações.",
                                    "Destacar condições de contorno físicas: apoios fixos, cargas distribuídas, simetrias.",
                                    "Revisar casos reais como pontes e edifícios sob cargas estáticas."
                                  ],
                                  "verification": "Listar 3 aplicações em Eng Civil com condições de contorno correspondentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigos ou capítulos sobre problemas estruturais",
                                    "Diagramas de vigas e tubos",
                                    "Software como MATLAB para visualização"
                                  ],
                                  "tips": "Pense em 'onde há fronteiras físicas definidas' para identificar PVCs.",
                                  "learningObjective": "Reconhecer contextos práticos de PVCs na Engenharia Civil.",
                                  "commonMistakes": "Ignorar condições de contorno mistas em problemas reais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos específicos de PVCs em modelagem civil",
                                  "subSteps": [
                                    "Modelar deflexão de viga cantilever: EI y'''' = q(x), com y(0)=0, y'(0)=0, y''(L)=0, y'''(L)=-P/EI.",
                                    "Simular fluxo em tubulação: equação de Darcy-Weisbach com condições de pressão e vazão nas extremidades.",
                                    "Estudar distribuição de tensões em placa: biharmonica ∇⁴φ=0 com bordas livres ou fixas.",
                                    "Resolver numericamente um exemplo simples usando método de diferenças finitas.",
                                    "Comparar solução analítica vs. numérica para validar."
                                  ],
                                  "verification": "Resolver e plotar um exemplo de viga com condições corretas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software numérico (MATLAB/Python)",
                                    "Folhas de cálculo para EDOs",
                                    "Referências de mecânica estrutural"
                                  ],
                                  "tips": "Comece com casos analíticos simples antes de numéricos.",
                                  "learningObjective": "Aplicar PVCs em modelagens concretas de vigas, tubos e tensões.",
                                  "commonMistakes": "Aplicar condições erradas, como confundir momento com cisalhamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar condições de contorno físicas com soluções reais",
                                  "subSteps": [
                                    "Interpretar condições físicas: apoio fixo como y=0 e y'=0 (Dirichlet + Neumann).",
                                    "Analisar sensibilidade: variação de contorno afeta solução global.",
                                    "Integrar com software de elementos finitos (FEM) como ANSYS para PVCs complexos.",
                                    "Discutir validação experimental: ensaios de carga em protótipos.",
                                    "Sintetizar lições para projetos civis sustentáveis."
                                  ],
                                  "verification": "Descrever como uma condição de contorno errada impacta uma viga real.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tutoriais de FEM",
                                    "Vídeos de ensaios estruturais",
                                    "Relatórios de projetos civis"
                                  ],
                                  "tips": "Ligue matemática à física real para melhor retenção.",
                                  "learningObjective": "Conectar teoria de PVCs a práticas de engenharia.",
                                  "commonMistakes": "Subestimar importância de condições reais vs. ideais."
                                }
                              ],
                              "practicalExample": "Modelagem da deflexão de uma viga simplesmente apoiada de 5m com carga uniforme de 10kN/m: resolver EI y'''' = q com condições y(0)=0, y(L)=0, y''(0)=0, y''(L)=0, plotando o perfil de deflexão máxima no centro.",
                              "finalVerifications": [
                                "Explicar 3 aplicações de PVCs em Eng Civil com condições específicas.",
                                "Resolver um PVC simples de viga analiticamente.",
                                "Identificar condições de contorno em um diagrama de tubulação.",
                                "Comparar solução numérica com analítica em um exemplo.",
                                "Discutir impacto de erro em contorno físico.",
                                "Listar ferramentas para PVCs em projetos reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e tipos de PVCs (20%)",
                                "Correta identificação de aplicações civis (25%)",
                                "Qualidade da análise de exemplos com condições (25%)",
                                "Profundidade na relação física-matemática (20%)",
                                "Clareza em verificações e exemplos práticos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs/EDPs com métodos analíticos/numéricos",
                                "Física: Mecânica dos sólidos e fluidos estáticos",
                                "Computação: Programação em Python/MATLAB para simulações",
                                "Engenharia de Materiais: Propriedades para condições de contorno"
                              ],
                              "realWorldApplication": "No projeto de pontes como a Ponte Rio-Niterói, PVCs modelam deflexões sob vento e tráfego, garantindo segurança; em sistemas de abastecimento de água, otimizam fluxo em tubulações com condições de pressão nas válvulas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.4",
                            "name": "Discutir métodos aproximados iniciais para PVCs",
                            "description": "Introduzir o método dos resíduos ponderados como abordagem para solução numérica de PVCs, relacionando com discretização e condicionamento numérico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Problemas de Valor de Contorno (PVCs)",
                                  "subSteps": [
                                    "Defina PVCs como equações diferenciais onde condições de contorno são especificadas nas extremidades do domínio.",
                                    "Diferencie PVCs de Problemas de Valor Inicial (PVI) destacando a necessidade de métodos de contorno.",
                                    "Identifique exemplos comuns em Engenharia Civil, como equações de difusão em barras ou vigas.",
                                    "Explique por que soluções analíticas são raras e métodos numéricos são essenciais.",
                                    "Discuta a importância de métodos aproximados iniciais para compreensão intuitiva."
                                  ],
                                  "verification": "Resuma em 3-5 frases os conceitos chave de PVCs e liste 2 exemplos relevantes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de EDOs, slides introdutórios sobre PVCs, calculadora.",
                                  "tips": "Use diagramas esquemáticos para visualizar domínios e condições de contorno.",
                                  "learningObjective": "Compreender a definição e motivação para métodos aproximados em PVCs.",
                                  "commonMistakes": "Confundir PVCs com PVIs ou ignorar a bidirecionalidade das condições de contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Conceitos de Discretização em PVCs",
                                  "subSteps": [
                                    "Explique discretização como divisão do domínio contínuo em pontos ou elementos discretos.",
                                    "Descreva malhas uniformes e não-uniformes, com fórmulas para espaçamento h.",
                                    "Discuta aproximação de derivadas por diferenças finitas (central, forward, backward).",
                                    "Relacione discretização à conversão de EDOs em sistemas algébricos lineares.",
                                    "Apresente notação matricial básica para o operador discretizado."
                                  ],
                                  "verification": "Construa uma malha simples para um PVC de segunda ordem e escreva a aproximação de derivadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, software como MATLAB ou Python (NumPy) para plotar malhas.",
                                  "tips": "Comece com malhas uniformes para simplicidade antes de complicar.",
                                  "learningObjective": "Dominar como discretizar PVCs transformando-os em problemas matriciais.",
                                  "commonMistakes": "Escolher esquemas de diferenças inadequados para condições de contorno específicas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Método dos Resíduos Ponderados",
                                  "subSteps": [
                                    "Defina resíduos como a diferença entre a equação diferencial e sua aproximação.",
                                    "Introduza funções de peso (ex: 1 para colocation, polinômios para Galerkin).",
                                    "Derive a formulação geral: integral ou soma de resíduos ponderados igual a zero.",
                                    "Aplique a um PVC simples, como -u'' + u = f com u(0)=u(1)=0.",
                                    "Compare com método dos elementos finitos como extensão."
                                  ],
                                  "verification": "Implemente o método para um PVC toy e verifique resíduos próximos de zero.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Caderno de derivadas, Python/MATLAB para resolver o sistema resultante.",
                                  "tips": "Use funções de peso constantes inicialmente para reduzir a complexidade.",
                                  "learningObjective": "Aplicar o método dos resíduos ponderados como solução numérica inicial para PVCs.",
                                  "commonMistakes": "Não normalizar resíduos ou escolher funções de peso incompatíveis com a ordem da EDO."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com Condicionamento Numérico e Análise Inicial",
                                  "subSteps": [
                                    "Defina condicionamento como sensibilidade da solução a perturbações nos dados.",
                                    "Discuta impacto da discretização fina (h pequeno) no condicionamento da matriz.",
                                    "Analise estabilidade e convergência do método dos resíduos ponderados.",
                                    "Compare com outros métodos iniciais como diferenças finitas.",
                                    "Sugira estratégias iniciais para melhorar condicionamento, como pré-condicionadores simples."
                                  ],
                                  "verification": "Calcule o número de condição de uma matriz discretizada e interprete valores >10^6.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software com função cond() (MATLAB/Python), exemplos de matrizes tridiagonais.",
                                  "tips": "Foquem em matrizes simétricas positivas definidas comuns em PVCs elípticos.",
                                  "learningObjective": "Avaliar condicionamento numérico em métodos aproximados para PVCs.",
                                  "commonMistakes": "Ignorar o efeito da malha na ill-condicionamento ou confundir com instabilidade."
                                }
                              ],
                              "practicalExample": "Resolva numericamente o PVC -u''(x) + π² u(x) = 0 em [0,1] com u(0)=u(1)=0 usando resíduos ponderados com 5 pontos de malha. Compare solução aproximada (u_h ≈ sen(πx)) com exata, calculando erro L2.",
                              "finalVerifications": [
                                "Explique em suas palavras o método dos resíduos ponderados e dê um exemplo.",
                                "Discretize um PVC dado e forme o sistema linear corretamente.",
                                "Identifique e corrija um erro comum em condicionamento numérico.",
                                "Relacione discretização a aplicações em Engenharia Civil.",
                                "Discuta limitações de métodos iniciais e quando usar avançados.",
                                "Resolva um PVC toy com software e valide resíduos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de PVCs, discretização e resíduos (30%).",
                                "Profundidade técnica: derivação correta do método e análise de condicionamento (25%).",
                                "Clareza na discussão: uso de exemplos e visualizações (20%).",
                                "Aplicação prática: implementação numérica funcional (15%).",
                                "Conexões interdisciplinares: relação com problemas reais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais ordinárias e álgebra linear numérica.",
                                "Programação: Implementação em Python/MATLAB para simulações.",
                                "Física: Modelagem de difusão, elastostática em estruturas civis.",
                                "Engenharia Computacional: Bases para elementos finitos e CFD."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, o método dos resíduos ponderados serve como base inicial para análise numérica de deformações em vigas sob carga (equação de Euler-Bernoulli), permitindo simulações rápidas de protótipos antes de softwares FEM avançados como ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Método dos Resíduos Ponderados",
                    "description": "Técnica aproximada para solução numérica de problemas diferenciais baseada na minimização de resíduos ponderados por funções de peso.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Fundamentos do Método dos Resíduos Ponderados",
                        "description": "Conceitos básicos sobre a definição de resíduo em equações diferenciais e a formulação do método como minimização integral ponderada.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Identificar o resíduo em aproximações de soluções diferenciais",
                            "description": "Calcular o resíduo R(x) = L[u_n(x)] - f(x) para uma equação diferencial linear L[u] = f, onde u_n é uma aproximação polinomial ou em séries, em problemas de valor inicial ou contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Resíduo em Equações Diferenciais",
                                  "subSteps": [
                                    "Leia a definição de uma equação diferencial linear L[u] = f, identificando o operador diferencial L (ex: d²/dx² + p(x)d/dx + q(x)) e o termo fonte f(x).",
                                    "Explique em suas palavras por que uma aproximação u_n(x) (polinomial ou série) não satisfaz exatamente a equação.",
                                    "Escreva a fórmula formal do resíduo: R(x) = L[u_n(x)] - f(x).",
                                    "Diferencie resíduo de erro de truncamento em séries.",
                                    "Discuta o significado físico: resíduo mede o quão 'próxima' está a aproximação da solução exata."
                                  ],
                                  "verification": "Escrever um parágrafo definindo resíduo e dando um exemplo simples verbal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre EDOs lineares",
                                    "Livro texto de métodos numéricos (capítulo de resíduos ponderados)"
                                  ],
                                  "tips": [
                                    "Sempre associe L a um operador linear para garantir aplicabilidade do método."
                                  ],
                                  "learningObjective": "Dominar a definição conceitual de resíduo e seu papel em métodos aproximados.",
                                  "commonMistakes": [
                                    "Confundir resíduo com a solução exata u(x)",
                                    "Ignorar que L é linear",
                                    "Esquecer o sinal na subtração de f(x)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Equação Diferencial e a Aproximação u_n(x)",
                                  "subSteps": [
                                    "Dada uma EDO de valor inicial ou contorno, extraia L[u] e f(x) explicitamente.",
                                    "Selecione ou construa u_n(x) como polinômio de grau n ou série de Taylor parcial, respeitando condições iniciais/contorno.",
                                    "Verifique se u_n satisfaz as condições de contorno (ex: u(0)=a, u'(0)=b).",
                                    "Esboce graficamente u_n(x) e compare qualitativamente com f(x).",
                                    "Anote os coeficientes de u_n para uso posterior."
                                  ],
                                  "verification": "Listar L, f(x) e forma de u_n(x) para um problema dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para esboços",
                                    "Software como GeoGebra ou Python (Matplotlib) para gráficos iniciais"
                                  ],
                                  "tips": [
                                    "Comece com polinômios de baixo grau (n=1 ou 2) para prática."
                                  ],
                                  "learningObjective": "Selecionar corretamente componentes da EDO e aproximação adequada.",
                                  "commonMistakes": [
                                    "Escolher u_n que ignora condições de contorno",
                                    "Confundir ordem da EDO com grau do polinômio",
                                    "Usar aproximação não diferenciável o suficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Operador Diferencial L à Aproximação u_n(x)",
                                  "subSteps": [
                                    "Compute as derivadas necessárias de u_n(x) até a ordem máxima em L (ex: u_n', u_n'' para EDO de 2ª ordem).",
                                    "Substitua u_n e suas derivadas na expressão de L[u_n].",
                                    "Simplifique algebricamente L[u_n(x)], expandindo polinômios se necessário.",
                                    "Verifique cálculos derivando duas vezes e comparando.",
                                    "Escreva L[u_n(x)] em forma polinomial expandida."
                                  ],
                                  "verification": "Comparar L[u_n] computado com aplicação manual em um termo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica (Wolfram Alpha ou SymPy em Python)",
                                    "Folha de exercícios com EDOs simples"
                                  ],
                                  "tips": [
                                    "Use regras de Leibniz para derivadas de produtos se L tiver coeficientes variáveis."
                                  ],
                                  "learningObjective": "Executar corretamente a aplicação de operadores diferenciais lineares.",
                                  "commonMistakes": [
                                    "Erro em derivadas de polinômios",
                                    "Esquecer multiplicar por coeficientes em L",
                                    "Não simplificar termos semelhantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e Interpretar o Resíduo R(x)",
                                  "subSteps": [
                                    "Subtraia f(x) de L[u_n(x)] para obter R(x).",
                                    "Simplifique R(x) para forma polinomial mínima.",
                                    "Avalie R(x) nos pontos de contorno para verificar se é zero (se aplicável).",
                                    "Calcule normas como integral de R² ou máximo absoluto para medir magnitude.",
                                    "Interprete: se ||R|| pequeno, boa aproximação."
                                  ],
                                  "verification": "R(x) deve ser zero nas condições de contorno se u_n as satisfaz.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "SymPy ou MATLAB para verificação numérica",
                                    "Gráficos de R(x) vs x"
                                  ],
                                  "tips": [
                                    "Norma L2: ∫R² dx indica erro global."
                                  ],
                                  "learningObjective": "Computar R(x) precisamente e avaliar qualidade da aproximação.",
                                  "commonMistakes": [
                                    "Sinal errado na subtração",
                                    "Não avaliar em contornos",
                                    "Ignorar simplificação levando a R não zero desnecessário"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Analisar o Resíduo em Contexto",
                                  "subSteps": [
                                    "Plote R(x) e analise zeros, picos e decaimento.",
                                    "Compare R para diferentes graus n de u_n.",
                                    "Discuta como R é usado em métodos de resíduos ponderados (ex: Galerkin).",
                                    "Teste com variação de parâmetros iniciais.",
                                    "Documente insights para relatório."
                                  ],
                                  "verification": "Gerar gráfico onde R diminui com n crescente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python (NumPy, Matplotlib) ou Excel para plotagem"
                                  ],
                                  "tips": [
                                    "Use log-log para ver convergência de ||R|| com n."
                                  ],
                                  "learningObjective": "Interpretar resíduo como métrica de precisão em métodos numéricos.",
                                  "commonMistakes": [
                                    "Não normalizar R",
                                    "Ignorar comportamento assintótico",
                                    "Confundir com minimização em métodos ponderados"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a EDO u'' + 4u = x com u(0)=0, u'(0)=0, use u_1(x) = a x + b x²/2. Determine a,b pelas condições iniciais (a=0, b=1/4). Compute L[u_1] = u_1'' + 4 u_1 = 1 + x - x². Então R(x) = 1 + x - x² - x = 1 - x². Verifique: R(0)=1 ≠0? Não, pois condições são para u, não R.",
                              "finalVerifications": [
                                "Definir corretamente R(x) = L[u_n] - f(x) sem erros conceituais.",
                                "Calcular L[u_n] para polinômio de grau 2 sem erros algébricos.",
                                "Obter R(x) simplificado e avaliá-lo em pontos chave.",
                                "Interpretar se ||R|| pequeno indica boa aproximação.",
                                "Aplicar em novo exemplo sem consulta.",
                                "Plotar R(x) e discutir magnitude."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição e fórmula de R (30%)",
                                "Correção algébrica em L[u_n] e subtração (40%)",
                                "Verificação em condições de contorno (10%)",
                                "Análise qualitativa/quantitativa de R (10%)",
                                "Clareza na documentação e interpretação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Integração com métodos de elementos finitos.",
                                "Programação: Implementação em Python/SymPy para automação.",
                                "Física: Modelagem de vibrações em estruturas civis.",
                                "Estatística: Análise de erro via normas de R.",
                                "Engenharia Computacional: Pré-processamento em simulações FEM."
                              ],
                              "realWorldApplication": "Na engenharia civil, ao modelar deformações em vigas (EDO de Euler-Bernoulli), aproximações polinomiais são usadas em elementos finitos; o resíduo quantifica erro local, guiando refino de malha para precisão em análise estrutural segura."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Formular a minimização de resíduos ponderados",
                            "description": "Estabelecer a condição de ortogonalidade ∫ w_i(x) R(x) dx = 0 para i=1 a n, onde w_i são funções de peso, levando a um sistema de equações lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de resíduo e aproximação trial",
                                  "subSteps": [
                                    "Revise a equação diferencial L[u] = f e as condições de contorno.",
                                    "Escolha uma função de aproximação trial u*(x) = Σ c_j φ_j(x), compatível com condições de contorno.",
                                    "Defina o operador diferencial L e calcule o resíduo R(x) = L[u*(x)] - f(x).",
                                    "Discuta por que o resíduo não é zero e a necessidade de minimizá-lo.",
                                    "Verifique dimensionalmente o resíduo para consistência."
                                  ],
                                  "verification": "Escreva explicitamente R(x) para um problema simples e confirme que é uma função contínua.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Caderno, calculadora, referência de equações diferenciais (ex: livro de métodos numéricos)",
                                  "tips": "Escolha funções φ_j ortogonais se possível para simplificar cálculos futuros.",
                                  "learningObjective": "Identificar e formular o resíduo resultante de uma aproximação trial em problemas de valor inicial/contorno.",
                                  "commonMistakes": "Esquecer de aplicar condições de contorno na trial ou inverter termos em L[u*]."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e justificar funções de peso w_i(x)",
                                  "subSteps": [
                                    "Escolha n funções de peso w_i(x), i=1 a n, onde n é o número de coeficientes desconhecidos.",
                                    "Justifique a escolha: ex: polinômios (método de Galerkin se w_i=φ_i) ou funções delta (colocação).",
                                    "Verifique que w_i satisfazem condições de contorno essenciais quando aplicável.",
                                    "Discuta propriedades como ortogonalidade ou suporte local das funções de peso.",
                                    "Teste com um exemplo: w1=1, w2=x para aproximação linear."
                                  ],
                                  "verification": "Liste as w_i escolhidas e explique por que são adequadas ao problema.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel milimetrado, software simbólico como Mathematica ou SymPy (opcional)",
                                  "tips": "Para problemas com singularidades, use pesos que concentrem perto delas.",
                                  "learningObjective": "Selecionar funções de peso apropriadas para garantir estabilidade e precisão na minimização.",
                                  "commonMistakes": "Escolher w_i que não respeitam o domínio ou condições de contorno, levando a inconsistências."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer as condições de ortogonalidade",
                                  "subSteps": [
                                    "Formule a condição de minimização: projeção do resíduo em espaço nulo das w_i.",
                                    "Escreva ∫_Ω w_i(x) R(x) dx = 0 para i=1 a n, onde Ω é o domínio.",
                                    "Expanda R(x) em termos dos coeficientes c_j: R(x) = Σ c_j L[φ_j](x) - f(x).",
                                    "Substitua na integral: ∫ w_i Σ c_j L[φ_j] dx = ∫ w_i f dx.",
                                    "Confirme que isso resulta em n equações escalares lineares."
                                  ],
                                  "verification": "Derive as n condições de ortogonalidade para um caso com n=2 e verifique nulidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Caderno para integrais, tabela de integrais indefinidas",
                                  "tips": "Use integração por partes se necessário para simplificar ∫ w_i L[φ_j] dx.",
                                  "learningObjective": "Formular matematicamente as condições de ortogonalidade entre resíduos ponderados e pesos.",
                                  "commonMistakes": "Esquecer limites de integração ou sinal negativo em operadores diferenciais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e representar o sistema de equações lineares",
                                  "subSteps": [
                                    "Reorganize as condições em forma matricial: A c = b, onde A_ij = ∫ w_i L[φ_j] dx, b_i = ∫ w_i f dx.",
                                    "Escreva explicitamente a matriz A e vetor b para o exemplo.",
                                    "Discuta simetria/positividade de A em casos como Galerkin.",
                                    "Resolva simbolicamente para pequenos n ou numéricamente para validar.",
                                    "Interprete os coeficientes c_j obtidos como solução aproximada."
                                  ],
                                  "verification": "Construa a matriz A (n x n) e vetor b, confirmando que resolução dá u* coerente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de álgebra linear (MATLAB, Python/NumPy), caderno",
                                  "tips": "Numere linhas/colunas consistentemente com i e j para evitar confusão.",
                                  "learningObjective": "Transformar condições de ortogonalidade em um sistema linear solucionável.",
                                  "commonMistakes": "Inverter índices de A_ij ou esquecer fatoração de constantes nas integrais."
                                }
                              ],
                              "practicalExample": "Para -u''(x) + u(x) = x em [0,1], u(0)=u(1)=0, aproxime u*(x)=c1 x (1-x^2). Então R(x)= 2 c1 + c1 x(1-x^2) -x. Com w1=1, w2=x, imponha ∫0^1 w_i R dx=0, montando [∫w_i(2 + c1 x - c1 x^3 -x)dx wait, calcule corretamente: resolva para c1≈0.5, verificando erro.",
                              "finalVerifications": [
                                "As condições ∫ w_i R dx =0 estão corretamente formuladas para todos i=1..n.",
                                "O resíduo R(x) inclui todos termos da aproximação e fonte f(x).",
                                "A matriz do sistema linear A tem dimensões n x n e é não-singular.",
                                "Solução c minimiza o resíduo no sentido ponderado.",
                                "Verificação numérica: erro de aproximação <5% em pontos de teste.",
                                "Condições de contorno são satisfeitas pela u* obtida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das condições de ortogonalidade (integral correta).",
                                "Correta identificação e expansão do resíduo R(x).",
                                "Montagem exata da matriz A e vetor b sem erros aritméticos.",
                                "Justificativa conceitual da minimização via ortogonalidade.",
                                "Capacidade de aplicar a um exemplo numérico simples.",
                                "Interpretação física da solução aproximada."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: resolução de sistemas Ax=b e propriedades de matrizes.",
                                "Cálculo Integral: avaliação de integrais definidas e por partes.",
                                "Programação Numérica: implementação em Python/MATLAB para automação.",
                                "Física/Engenharia: aproximações em equações de elasticiade ou fluxo."
                              ],
                              "realWorldApplication": "Na engenharia civil, formula-se minimização de resíduos ponderados para aproximar deflexões em vigas irregulares ou distribuições de tensão em estruturas complexas, onde soluções exatas são inviáveis, integrando com software FEM como ANSYS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Explicar o papel das funções de peso",
                            "description": "Diferenciar funções de peso constantes (método dos momentos), delta de Dirac (colocação), harmônicos (Galerkin) e suas implicações na precisão da aproximação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito geral de funções de peso no Método dos Resíduos Ponderados",
                                  "subSteps": [
                                    "Definir o Método dos Resíduos Ponderados (MRP) como uma técnica para aproximar soluções de equações diferenciais.",
                                    "Explicar que as funções de peso (w_i) são usadas para ponderar o resíduo R = L(u_a) - f, onde u_a é a aproximação.",
                                    "Discutir a integral do resíduo ponderado: ∫ w_i R dx = 0 para i=1 a n.",
                                    "Identificar o papel das funções de peso na definição das equações do sistema.",
                                    "Revisar exemplos básicos de MRP sem especificar tipos de pesos."
                                  ],
                                  "verification": "Resumir em um parágrafo o papel das funções de peso e listar 3 propriedades essenciais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de métodos numéricos (ex: Chapra), notas de aula sobre MRP, calculadora simbólica (SymPy ou Mathematica)"
                                  ],
                                  "tips": "Visualize as funções de peso como 'filtros' que enfatizam regiões do domínio.",
                                  "learningObjective": "Entender o fundamento matemático das funções de peso no MRP.",
                                  "commonMistakes": [
                                    "Confundir funções de peso com funções de aproximação (testes), ignorar a normalização dos pesos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar funções de peso constantes (Método dos Momentos)",
                                  "subSteps": [
                                    "Definir funções de peso constantes: w_i(x) = 1 para todos i.",
                                    "Derivar as equações do método: ∫ R dx = 0, levando a momentos do resíduo.",
                                    "Aplicar a um problema simples 1D, como equação de Poisson.",
                                    "Calcular numericamente para um polinômio de aproximação de grau 1.",
                                    "Discutir vantagens: simplicidade, bom para domínios uniformes."
                                  ],
                                  "verification": "Resolver um exemplo e verificar se o resíduo médio é zero.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB/Python para integração numérica, exemplos de problemas de valor de contorno"
                                  ],
                                  "tips": "Use integração analítica quando possível para validar resultados numéricos.",
                                  "learningObjective": "Dominar o método dos momentos e suas funções de peso.",
                                  "commonMistakes": [
                                    "Não dividir corretamente o domínio em subintervalos, assumir pesos normalizados automaticamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar funções de peso delta de Dirac (Método da Colocação)",
                                  "subSteps": [
                                    "Introduzir w_i(x) = δ(x - ξ_i), onde δ é a delta de Dirac e ξ_i são pontos de colocação.",
                                    "Explicar que isso reduz a condição a R(ξ_i) = 0.",
                                    "Comparar com interpolação nodal em problemas discretos.",
                                    "Implementar em um exemplo com 3 pontos de colocação.",
                                    "Avaliar precisão em regiões com gradientes altos."
                                  ],
                                  "verification": "Verificar se o resíduo é zero nos pontos de colocação especificados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python com NumPy/SciPy para deltas aproximadas, gráficos de resíduos"
                                  ],
                                  "tips": "Aproxime delta com picos estreitos em simulações numéricas.",
                                  "learningObjective": "Compreender o método da colocação e suas limitações locais.",
                                  "commonMistakes": [
                                    "Confundir com método de collocation em elementos finitos, ignorar singularidades da delta."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar funções de peso harmônicas (Método de Galerkin)",
                                  "subSteps": [
                                    "Definir w_i(x) = φ_i(x), mesmas funções base da aproximação (ortogonalidade).",
                                    "Derivar condições: ∫ φ_i R dx = 0, levando a fraqueza da formulação.",
                                    "Aplicar a equações elípticas, destacando simetria da matriz.",
                                    "Comparar com outros métodos em termos de convergência.",
                                    "Simular um problema com bases senoidais."
                                  ],
                                  "verification": "Montar o sistema matricial e resolver, checando ortogonalidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software FEniCS ou código próprio para Galerkin, referências sobre MEF"
                                  ],
                                  "tips": "Escolha bases ortogonais para reduzir condicionamento da matriz.",
                                  "learningObjective": "Mestre o método de Galerkin e sua conexão com Elementos Finitos.",
                                  "commonMistakes": [
                                    "Usar bases não-ortogonais sem ajuste, confundir com Petrov-Galerkin."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar métodos e discutir implicações na precisão da aproximação",
                                  "subSteps": [
                                    "Tabelar diferenças: constantes (global), delta (local), harmônicas (projetadas).",
                                    "Analisar convergência: Galerkin ótimo para energia, colocação simples mas oscilante.",
                                    "Avaliar erros em exemplos numéricos compartilhados.",
                                    "Discutir escolhas baseadas no problema (ex: harmônicos para simetria).",
                                    "Explorar implicações em Engenharia Civil (vigas, placas)."
                                  ],
                                  "verification": "Criar uma tabela comparativa com erros L2 e L∞ para um problema teste.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha Excel para tabelas, gráficos comparativos em Python"
                                  ],
                                  "tips": "Use normas de erro padronizadas para comparações justas.",
                                  "learningObjective": "Diferenciar impactos na precisão e escolher adequadamente.",
                                  "commonMistakes": [
                                    "Generalizar precisão sem contexto do problema, ignorar custo computacional."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação -u''(x) + π² u(x) = π² sin(πx) em [0,1] com u(0)=u(1)=0. Aproxime u_a = a1 sin(πx) + a2 sin(2πx). Aplique MRP com pesos constantes (∫R dx=0), delta em x=0.5 (R(0.5)=0) e Galerkin (∫ sin(kπx) R dx=0). Compare erros em u(0.25), u(0.75) e norma L2.",
                              "finalVerifications": [
                                "Explicar verbalmente as diferenças entre os três tipos de funções de peso.",
                                "Resolver um problema teste com cada método e comparar resíduos.",
                                "Identificar cenários onde cada método é preferível.",
                                "Montar matrizes de sistema para um exemplo dado.",
                                "Discutir como pesos afetam oscilações na solução aproximada.",
                                "Prever ordem de convergência qualitativamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática de cada função de peso (80%).",
                                "Correta derivação das condições de MRP para cada caso (90%).",
                                "Análise qualitativa e quantitativa das implicações na precisão (85%).",
                                "Uso adequado de exemplos e gráficos para ilustração (75%).",
                                "Capacidade de escolher método baseado no problema (95%).",
                                "Clareza na comparação e tabela de resultados (80%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e espaços de Sobolev (Galerkin).",
                                "Física: Formulações variacionais em mecânica dos sólidos.",
                                "Programação: Implementação numérica em Python/MATLAB para MRP.",
                                "Engenharia Mecânica: Extensão a dinâmica e vibrações.",
                                "Computação Científica: Pré-condicionadores para sistemas de Galerkin."
                              ],
                              "realWorldApplication": "Na análise estrutural de vigas e lajes em Engenharia Civil, o método de Galerkin com funções harmônicas é usado em softwares FEM como ANSYS para simulações precisas de deformações, enquanto colocação acelera protótipos em projetos de pontes com malhas grosseiras, otimizando tempo e precisão em cenários reais de carregamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Funções de Base e Aproximação da Solução",
                        "description": "Seleção e uso de funções de base para construir a solução aproximada u_n(x) = ∑ c_j φ_j(x), satisfazendo condições de contorno.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Selecionar funções de base adequadas",
                            "description": "Escolher polinômios de Legendre, Tchebychev ou funções trigonômicas para problemas de valor inicial e contorno, garantindo satisfação das condições essenciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Problemas de Valor Inicial (IVP) e de Contorno (BVP)",
                                  "subSteps": [
                                    "Defina IVP como problemas onde condições iniciais são dadas em um ponto (ex: posição e velocidade inicial em dinâmica).",
                                    "Defina BVP como problemas com condições em múltiplos pontos (ex: deslocamentos fixos nas extremidades de uma viga).",
                                    "Identifique condições essenciais (Dirichlet) vs naturais (Neumann) no contexto do Método dos Resíduos Ponderados.",
                                    "Revise o papel das funções de base na aproximação da solução u(x) ≈ Σ c_i φ_i(x).",
                                    "Compare domínios típicos: tempo para IVP, espaço para BVP."
                                  ],
                                  "verification": "Resuma em um diagrama as diferenças entre IVP e BVP, listando exemplos de condições essenciais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de métodos numéricos (ex: 'Numerical Methods for Engineers' de Chapra), notas de aula sobre EDOs/EQPs.",
                                  "tips": "Use tabelas para comparar IVP vs BVP para fixar conceitos rapidamente.",
                                  "learningObjective": "Diferenciar IVP e BVP e identificar condições essenciais para seleção de bases.",
                                  "commonMistakes": "Confundir condições essenciais com naturais; assumir que todas as condições são iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Propriedades das Funções de Base: Legendre, Chebyshev e Trigonométricas",
                                  "subSteps": [
                                    "Descreva polinômios de Legendre: ortogonais em [-1,1], ideais para BVP com condições de contorno simétricas.",
                                    "Explique polinômios de Chebyshev: minimizam erro de Runge, bons para aproximações em intervalos finitos com oscilação uniforme.",
                                    "Detalhe funções trigonométricas (senos/cossenos): periódicas, perfeitas para IVP em domínios periódicos ou semi-infinitos.",
                                    "Plote graficamente cada família usando software para visualizar ortogonalidade e satisfação de condições.",
                                    "Calcule explicitamente os primeiros 3-4 membros de cada base."
                                  ],
                                  "verification": "Gere plots das primeiras funções de cada base e verifique ortogonalidade via integral numérica.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python com NumPy/SciPy/Matplotlib ou MATLAB, tabela de propriedades ortogonais.",
                                  "tips": "Implemente funções geradoras em código para reutilizar em problemas futuros.",
                                  "learningObjective": "Compreender propriedades matemáticas e domínios de aplicação de cada função de base.",
                                  "commonMistakes": "Ignorar o intervalo de ortogonalidade; usar trigonométricas em domínios não-periódicos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender Critérios de Seleção Baseados no Problema e Condições Essenciais",
                                  "subSteps": [
                                    "Para IVP: priorize trigonométricas ou Chebyshev se domínio temporal periódico; Legendre para finitos.",
                                    "Para BVP: Legendre/Chebyshev para condições Dirichlet em extremidades; trigonométricas para Fourier-like.",
                                    "Garanta satisfação de condições essenciais: escolha bases que naturalmente satisfazem (ex: φ(0)=0 para condição u(0)=0).",
                                    "Avalie estabilidade numérica: Chebyshev para evitar oscilações de Gibbs.",
                                    "Selecione ordem da base baseada em precisão desejada (ex: N=5-10 iniciais)."
                                  ],
                                  "verification": "Crie uma tabela de decisão: colunas para tipo de problema/condições, linhas para bases recomendadas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel/Google Sheets para tabela de critérios, exemplos de problemas resolvidos.",
                                  "tips": "Sempre verifique se a base 'encaixa' nas condições essenciais antes de prosseguir para resíduos.",
                                  "learningObjective": "Desenvolver regras heurísticas para seleção ótima de funções de base.",
                                  "commonMistakes": "Selecionar base sem verificar satisfação automática de condições essenciais, levando a sistemas singulares."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Seleção em um Problema Prático e Verificar",
                                  "subSteps": [
                                    "Escolha um BVP exemplo: equação de Laplace em viga com u(0)=u(1)=0.",
                                    "Selecione Legendre (ortogonais em [0,1] após mapeamento) e imponha condições essenciais nos coeficientes.",
                                    "Monte a aproximação, calcule resíduos e resolva o sistema.",
                                    "Compare com solução exata e avalie erro.",
                                    "Teste alternativa (ex: Chebyshev) e discuta superioridade."
                                  ],
                                  "verification": "Implemente código que resolve o problema e plote solução aproximada vs exata, com erro L2 < 1%.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": "Python/SciPy para solver linear, problema exemplo escrito.",
                                  "tips": "Comece com baixa ordem (N=3) para depuração rápida.",
                                  "learningObjective": "Aplicar critérios de seleção em contexto real e validar escolha.",
                                  "commonMistakes": "Esquecer normalização das bases, causando ill-conditioning na matriz."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar com Exemplos Variados e Refinar Seleção",
                                  "subSteps": [
                                    "Resolva IVP exemplo: onda com condições iniciais, usando trigonométricas.",
                                    "Adapte para BVP assimétrico com Chebyshev.",
                                    "Analise sensibilidade: varie N e tipo de base, meça tempo/convergência.",
                                    "Documente lições aprendidas em um relatório curto.",
                                    "Resolva problema aberto de Engenharia Civil (ex: deflexão de viga)."
                                  ],
                                  "verification": "Resolva 3 problemas diferentes, com justificativa de seleção e métricas de erro.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Banco de problemas de EDOs/EQPs em Engenharia Civil, Jupyter Notebook.",
                                  "tips": "Registre tempo de computação para otimização futura.",
                                  "learningObjective": "Consolidar habilidade através de prática iterativa.",
                                  "commonMistakes": "Sobre-generalizar uma base para todos os problemas sem análise específica."
                                }
                              ],
                              "practicalExample": "Em análise de vigas (BVP): para equação -u''(x) = f(x) com u(0)=u(L)=0, selecione polinômios de Legendre mapeados para [0,L], onde φ_i(0)=φ_i(L)=0 naturalmente, evitando imposição manual de condições essenciais e reduzindo dimensões do sistema.",
                              "finalVerifications": [
                                "A base selecionada satisfaz automaticamente todas as condições essenciais?",
                                "O erro de aproximação diminui monotonicamente com aumento de N?",
                                "A matriz de Gram é bem-condicionada (cond < 10^6)?",
                                "Solução converge para caso analítico conhecido?",
                                "Tempo de setup e solve é razoável para engenharia prática?",
                                "Seleção justificada por propriedades da base vs problema?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de IVP/BVP e condições essenciais (30%)",
                                "Correta descrição de propriedades das bases e critérios de seleção (25%)",
                                "Implementação numérica sem erros e com validação (20%)",
                                "Justificativa clara e heurísticas personalizadas (15%)",
                                "Análise de erros comuns e melhorias (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Funcional e Ortogonalidade (Cálculo Avançado)",
                                "Física: Mecânica Estrutural e Dinâmica de Engenharia Civil",
                                "Programação: Métodos Numéricos em Python/MATLAB",
                                "Estatística: Análise de Erro e Convergência"
                              ],
                              "realWorldApplication": "Na simulação computacional de estruturas civis, como vigas e placas sob carga, selecionar Legendre para BVPs de deflexão estática garante precisão com poucos graus de liberdade, otimizando projetos de pontes e edifícios no software FEA (ex: ANSYS customizado)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Construir a expansão da solução aproximada",
                            "description": "Expressar u_n(x) como combinação linear de funções de base φ_j(x), incorporando condições de contorno homogêneas ou não-homogêneas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o problema e as condições de contorno",
                                  "subSteps": [
                                    "Analise a equação diferencial e o domínio do problema.",
                                    "Classifique as condições de contorno como homogêneas (zero) ou não-homogêneas.",
                                    "Determine o número de funções de base necessárias (n) baseado na precisão desejada.",
                                    "Esboce o domínio e rotule as condições de contorno nos extremos.",
                                    "Defina a solução exata aproximada como u_n(x) = soma c_j φ_j(x) + termo particular se aplicável."
                                  ],
                                  "verification": "Confirme que todas as condições de contorno estão corretamente identificadas e anotadas em um diagrama.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Equação diferencial do problema",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre priorize condições essenciais (Dirichlet) sobre naturais (Neumann).",
                                  "learningObjective": "Compreender o impacto das condições de contorno na escolha da expansão.",
                                  "commonMistakes": [
                                    "Confundir homogêneas com não-homogêneas",
                                    "Ignorar o domínio espacial do problema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar funções de base adequadas",
                                  "subSteps": [
                                    "Escolha funções φ_j(x) que satisfaçam as condições de contorno homogêneas (ex: senos para Dirichlet homogêneo).",
                                    "Para condições não-homogêneas, introduza uma solução particular u_p(x) que as satisfaça.",
                                    "Garanta ortogonalidade ou completude das funções no espaço de funções admissíveis.",
                                    "Defina n funções iniciais (ex: φ_1(x) = sin(πx), φ_2(x) = sin(2πx) para [0,1]).",
                                    "Teste se φ_j satisfazem as homogêneas: verifique φ_j(a)=0 e φ_j(b)=0 se aplicável."
                                  ],
                                  "verification": "Substitua as φ_j nas condições homogêneas e confirme que são zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de funções ortogonais",
                                    "Software simbólico como Mathematica ou SymPy"
                                  ],
                                  "tips": "Use polinômios de Legendre ou Chebyshev para problemas em intervalos finitos.",
                                  "learningObjective": "Selecionar bases que garantam admissibilidade da aproximação.",
                                  "commonMistakes": [
                                    "Escolher funções que não zeram nas fronteiras homogêneas",
                                    "Usar n muito pequeno para convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a expansão linear da solução aproximada",
                                  "subSteps": [
                                    "Escreva u_n(x) = ∑_{j=1}^n c_j φ_j(x) para condições homogêneas.",
                                    "Para não-homogêneas, escreva u_n(x) = u_p(x) + ∑_{j=1}^n c_j φ_j(x), onde φ_j satisfazem homogêneas.",
                                    "Expanda a equação diferencial residual R(x) = L[u_n(x)] - f(x), onde L é o operador.",
                                    "Identifique os coeficientes c_j como desconhecidos livres.",
                                    "Simplifique expressões algébricas para preparar resíduos ponderados."
                                  ],
                                  "verification": "Verifique se u_n(x) satisfaz exatamente as condições de contorno ao substituir x=a,b.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora gráfica",
                                    "Editor LaTeX para equações"
                                  ],
                                  "tips": "Normalize as funções de base para facilitar cálculos numéricos.",
                                  "learningObjective": "Formular a trial function como combinação linear incorporando BCs.",
                                  "commonMistakes": [
                                    "Esquecer o termo particular u_p para BCs não-homogêneas",
                                    "Índices errados na soma"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar a expansão",
                                  "subSteps": [
                                    "Calcule u_n nos limites e confirme satisfação das BCs.",
                                    "Verifique linearidade em c_j e independência das φ_j.",
                                    "Teste com n=1 para uma aproximação grosseira e compare.",
                                    "Ajuste funções de base se resíduos iniciais forem altos.",
                                    "Documente a expansão final com notação clara."
                                  ],
                                  "verification": "Substituição nos limites dá valores exatos das BCs e derivadas se Neumann.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software numérico como MATLAB ou Python (NumPy)",
                                    "Gráficos de φ_j(x)"
                                  ],
                                  "tips": "Plote as funções de base para visualização intuitiva.",
                                  "learningObjective": "Garantir que a expansão seja válida e pronta para minimização de resíduos.",
                                  "commonMistakes": [
                                    "Não verificar BCs após adicionar u_p",
                                    "Dependência linear entre φ_j"
                                  ]
                                }
                              ],
                              "practicalExample": "Para -u''(x) + u(x) = 0 em [0,1], com u(0)=1 (não-homogênea), u'(1)=0: u_p(x)=1, φ1(x)=cos(π(x-1)/2), u_n(x)=1 + c1 cos(π(x-1)/2). Verifique: u_n(0)=1+ c1 cos(π(-1)/2)=1+c1*0=1; u_n'(1)= -c1 (π/2) sin(0)=0.",
                              "finalVerifications": [
                                "u_n satisfaz todas as condições de contorno exatamente.",
                                "Expansão é linear em coeficientes c_j.",
                                "Funções φ_j são linearmente independentes e satisfazem BCs homogêneas.",
                                "Residual R(x) é definido corretamente como função dos c_j.",
                                "n é apropriado para o grau de precisão esperado.",
                                "Notação matemática está clara e consistente."
                              ],
                              "assessmentCriteria": [
                                "Correta identificação e tratamento de BCs homogêneas/não-homogêneas (30%).",
                                "Seleção adequada de funções de base com verificação (25%).",
                                "Formulação precisa da expansão u_n(x) (20%).",
                                "Validação completa com substituições nos limites (15%).",
                                "Clareza na documentação e ausência de erros algébricos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Fourier e ortogonalidade de funções.",
                                "Programação: Implementação em Python/MATLAB para plotar u_n(x).",
                                "Física: Modelagem de vibrações em vigas (equações diferenciais elípticas).",
                                "Estatística: Análise de erro de aproximação e convergência."
                              ],
                              "realWorldApplication": "Na engenharia civil, usado em métodos numéricos como elementos finitos para simular deformações em vigas e placas sob cargas, prevendo tensões e deslocamentos em estruturas reais como pontes e edifícios."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Aplicar o método de Galerkin",
                            "description": "Usar funções de peso w_i = φ_i (Galerkin), derivando o sistema A c = b onde A_ij = ∫ φ_i L[φ_j] dx e b_i = ∫ φ_i f dx.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema diferencial e condições de contorno",
                                  "subSteps": [
                                    "Identifique a equação diferencial L[u] = f, onde L é o operador diferencial.",
                                    "Especifique o domínio Ω (ex: intervalo [a,b] para 1D).",
                                    "Defina as condições de contorno (ex: Dirichlet u(a)=u(b)=0).",
                                    "Escolha uma função f(x) de teste simples.",
                                    "Esboce o domínio e anote todas as condições."
                                  ],
                                  "verification": "Verifique se a formulação do problema está escrita corretamente e satisfaz as condições essenciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de EDOs ou notas de aula sobre problemas de contorno"
                                  ],
                                  "tips": "Comece com um problema 1D simples como -u'' + u = f para praticar.",
                                  "learningObjective": "Compreender e formular precisamente o problema de valor de contorno a ser aproximado.",
                                  "commonMistakes": [
                                    "Esquecer condições de contorno essenciais",
                                    "Confundir operador L com a função f",
                                    "Definir domínio incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar funções base φ_i e espaço de aproximação",
                                  "subSteps": [
                                    "Escolha N funções base φ_i(x) que satisfaçam as condições de contorno homogêneas.",
                                    "Exemplos: φ_i(x) = sin(i π x / L) para [0,L] com BCs zero nas extremidades.",
                                    "Verifique ortogonalidade ou propriedades das bases (ex: polinômios de Legendre truncados).",
                                    "Defina a aproximação u_h(x) = ∑_{j=1}^N c_j φ_j(x).",
                                    "Liste explicitamente as φ_1 até φ_N para N=2 ou 3."
                                  ],
                                  "verification": "Confirme que cada φ_i satisfaz as BCs e que u_h também as satisfaz.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy",
                                    "Tabelas de funções ortogonais"
                                  ],
                                  "tips": "Use funções trigonométricas para simplicidade em domínios finitos.",
                                  "learningObjective": "Selecionar adequadamente funções base compatíveis com o problema.",
                                  "commonMistakes": [
                                    "Funções base que não satisfazem BCs",
                                    "Escolha de N muito grande para cálculo manual",
                                    "Normalização esquecida"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a matriz de rigidez A_ij = ∫ φ_i L[φ_j] dx",
                                  "subSteps": [
                                    "Compute L[φ_j] explicitamente para cada j.",
                                    "Calcule a integral ∫_Ω φ_i(x) L[φ_j(x)] dx para i,j=1 a N.",
                                    "Use integração por partes se necessário para operadores diferenciais de segunda ordem.",
                                    "Monte a matriz A simétrica (propriedade de Galerkin).",
                                    "Verifique simetria e positividade (se aplicável)."
                                  ],
                                  "verification": "A matriz A deve ser simétrica e os elementos calculados devem coincidir numericamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de cálculo simbólico (SymPy ou Mathematica)",
                                    "Papel quadriculado para integrais"
                                  ],
                                  "tips": "Integre por partes para reduzir ordens de derivadas e aplicar BCs.",
                                  "learningObjective": "Calcular corretamente os coeficientes da matriz via resíduos ponderados.",
                                  "commonMistakes": [
                                    "Erro em integração por partes (sinal invertido)",
                                    "Não aplicar BCs nas integrais",
                                    "Índices i,j trocados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar o vetor de carga b_i = ∫ φ_i f dx",
                                  "subSteps": [
                                    "Especifique a função f(x) explicitamente.",
                                    "Para cada i=1 a N, compute ∫_Ω φ_i(x) f(x) dx.",
                                    "Use propriedades de ortogonalidade se as φ_i forem ortonormais.",
                                    "Monte o vetor coluna b.",
                                    "Compare com soluções analíticas conhecidas se possível."
                                  ],
                                  "verification": "Os valores de b devem ser positivos se f>0 e φ_i>0 no domínio.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmos do step 3",
                                    "Tabela de integrais indefinidas"
                                  ],
                                  "tips": "Escolha f constante ou polinomial para facilitar cálculos.",
                                  "learningObjective": "Formular o termo de carregamento no método.",
                                  "commonMistakes": [
                                    "Integral no domínio errado",
                                    "f confundida com L[u]",
                                    "Falta de fator de normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Resolver o sistema A c = b e reconstruir a solução aproximada",
                                  "subSteps": [
                                    "Resolva o sistema linear A c = b para os coeficientes c.",
                                    "Use eliminação gaussiana manual para N pequeno ou software.",
                                    "Construa u_h(x) = ∑ c_j φ_j(x).",
                                    "Avalie u_h em pontos chave e compare com solução exata se conhecida.",
                                    "Plote ou tabule u_h vs. solução exata."
                                  ],
                                  "verification": "||A c - b|| < 1e-10 e u_h satisfaz BCs.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB, Python (NumPy/SciPy) ou calculadora matricial"
                                  ],
                                  "tips": "Para N=2, resolva manualmente para entender.",
                                  "learningObjective": "Aplicar o método completo e interpretar resultados.",
                                  "commonMistakes": [
                                    "Singularidade em A (má escolha de base)",
                                    "Erro numérico em resolução",
                                    "Reconstrução errada de u_h"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva -u''(x) + u(x) = π² sin(π x) em [0,1] com u(0)=u(1)=0, usando N=2 funções base φ1(x)=sin(π x), φ2(x)=sin(2π x). Compute A, b, c e u_h(x). Solução exata: u(x)=sin(π x). Verifique erro <5%.",
                              "finalVerifications": [
                                "Matriz A é simétrica e definida positiva.",
                                "Vetor b computado corretamente com integrais exatas.",
                                "Coeficientes c levam a u_h que satisfaz BCs exatamente.",
                                "Erro L2 entre u_h e u_exata < 10% para N=2.",
                                "Resíduo R[u_h] = L[u_h] - f é ortogonal às φ_i.",
                                "Convergência observada ao aumentar N."
                              ],
                              "assessmentCriteria": [
                                "Correção na formulação de A e b (80% peso).",
                                "Precisão numérica da solução c (10% peso).",
                                "Interpretação qualitativa do erro e convergência (5% peso).",
                                "Uso eficiente de ferramentas computacionais (3% peso).",
                                "Clareza na documentação dos passos (2% peso)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Equações Diferenciais.",
                                "Programação: Implementação em Python/MATLAB para MEF.",
                                "Física: Modelagem de vibrações e difusão.",
                                "Engenharia de Computação: Otimização de solvers lineares."
                              ],
                              "realWorldApplication": "Base do Método dos Elementos Finitos (MEF) em análise estrutural de vigas e placas em engenharia civil, simulando deformações em pontes e edifícios sob cargas reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Implementação Numérica e Análise de Condicionamento",
                        "description": "Montagem do sistema matricial, solução numérica e avaliação de estabilidade via matriz de Gram e autovalores.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Montar e resolver o sistema linear resultante",
                            "description": "Computar matrizes de rigidez e carga via integração numérica (Gauss-Legendre) para equações diferenciais de segunda ordem, resolvendo Ac = b com MATLAB ou software similar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema e definir funções de base",
                                  "subSteps": [
                                    "Identifique a equação diferencial de segunda ordem: -u'' + a u = f em domínio [a,b] com condições de contorno u(a)=u_a, u(b)=u_b.",
                                    "Escolha funções de base polinomiais lineares ou quadráticas (ex: φ_i(ξ) = (1-ξ)/2 para nó esquerdo).",
                                    "Defina pontos de Gauss-Legendre e pesos para integração numérica (n=2 ou 3 pontos).",
                                    "Mapeie o domínio físico para referência [-1,1] via transformação jacobiana.",
                                    "Escreva as expressões integrais para K_ij = ∫ φ_i' φ_j' dx e F_i = ∫ φ_i f dx."
                                  ],
                                  "verification": "Verifique se as funções de base somam à 1 (propriedade de partição da unidade) e se os pontos/weights de Gauss estão corretos plotando-os.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Documentação Gauss-Legendre (tabela de pontos/pesos)",
                                    "MATLAB ou Octave instalado",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": "Comece com elementos lineares (2 nós) para simplicidade antes de quadráticos.",
                                  "learningObjective": "Compreender a discretização via método dos resíduos ponderados e preparar integrais elementares.",
                                  "commonMistakes": [
                                    "Esquecer o jacobiano na transformação de variáveis",
                                    "Confundir derivadas das funções de base"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a integração numérica Gauss-Legendre em MATLAB",
                                  "subSteps": [
                                    "Crie função para quadratura Gauss-Legendre: soma w_k * g(ξ_k) onde ξ_k são pontos de Gauss.",
                                    "Defina função para computar K_e (matriz de rigidez elementar) usando derivadas φ' em pontos Gauss.",
                                    "Implemente F_e (vetor de carga elementar) similarmente para ∫ φ f dx.",
                                    "Teste a função de integração com integral conhecida, como ∫_{-1}^1 1 dξ = 2.",
                                    "Ajuste para múltiplos elementos dividindo o domínio."
                                  ],
                                  "verification": "Compare resultado da integração teste com valor analítico (erro < 1e-10).",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "MATLAB script template",
                                    "Tabela de pontos/pesos Gauss (n=2: ξ=[-0.577,0.577], w=[1,1])"
                                  ],
                                  "tips": "Vetorize operações em MATLAB para eficiência; use meshgrid para avaliações múltiplas.",
                                  "learningObjective": "Dominar integração numérica precisa para formar matrizes em métodos de elementos finitos.",
                                  "commonMistakes": [
                                    "Inverter pesos e pontos",
                                    "Não multiplicar por 2/Jacobiano para comprimento do elemento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar o sistema global de equações Ac = b",
                                  "subSteps": [
                                    "Inicialize matrizes globais K (n_dof x n_dof) e F (n_dof x 1) como zeros.",
                                    "Monte por elementos: adicione K_e e F_e nas posições dos nós locais para nós globais.",
                                    "Aplique condições de contorno essenciais: modifique linhas/colunas para nós Dirichlet.",
                                    "Incorpore condições de Neumann se aplicável (adicionar à F).",
                                    "Verifique simetria e diagonal-dominância de A."
                                  ],
                                  "verification": "Confira que K é simétrica positiva definida (eig(K)>0) e soma de linhas de K_e bate com global.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Script MATLAB com loop de montagem",
                                    "Exemplo de malha com 4-8 elementos"
                                  ],
                                  "tips": "Use sparse() para matrizes grandes; indexação lógica acelera montagem.",
                                  "learningObjective": "Aprender montagem de sistemas globais a partir de contribuições elementares.",
                                  "commonMistakes": [
                                    "Sobrepor contribuições em nós compartilhados incorretamente",
                                    "Não zerar linhas de BC essenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o sistema linear e analisar condicionamento",
                                  "subSteps": [
                                    "Use \\ (backslash) em MATLAB para resolver A c = b diretamente.",
                                    "Compute norma de resíduo ||A c - b|| / ||b|| < 1e-8.",
                                    "Calcule cond(A) = norm(A)*norm(inv(A)) ou via svd.",
                                    "Plote solução c vs posição x e compare com solução analítica se conhecida.",
                                    "Refine malha e observe convergência (erro O(h^2) para lineares)."
                                  ],
                                  "verification": "Resíduo pequeno e cond(A) razoável (<1e6); plot converge com refinamento.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Função cond() e backslash em MATLAB",
                                    "Solução analítica de teste: u''=0, u(0)=0,u(1)=1 => u=x"
                                  ],
                                  "tips": "Para problemas mal-condicionados, use pcg() iterativo com pré-condicionador.",
                                  "learningObjective": "Resolver sistemas lineares eficientemente e diagnosticar estabilidade numérica.",
                                  "commonMistakes": [
                                    "Ignorar cond alto levando a NaNs",
                                    "Não normalizar resíduo relativo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar resultados",
                                  "subSteps": [
                                    "Compare com solução exata ou FEM comercial.",
                                    "Calcule erro L2 = sqrt(∫ (u_h - u)^2 dx) via quadratura.",
                                    "Analise sensibilidade a número de pontos Gauss.",
                                    "Documente código com comentários e gere relatório.",
                                    "Teste com f não-trivial, ex: f=π^2 sin(π x)."
                                  ],
                                  "verification": "Erro L2 diminui com h; independência de n_Gauss acima de 2-3 pontos.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Soluções analíticas tabeladas",
                                    "GNUPlot ou MATLAB para gráficos"
                                  ],
                                  "tips": "Salve workspace em .mat para reprodutibilidade.",
                                  "learningObjective": "Garantir confiabilidade da implementação numérica.",
                                  "commonMistakes": [
                                    "Usar malha grosseira sem verificar convergência",
                                    "Erro em BC levando a solução errada"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva -u'' = π² sin(π x) em [0,1], u(0)=u(1)=0. Solução exata: u=sin(π x). Use 4 elementos lineares, Gauss n=2. Espere erro L2 ~1e-3; refine para 16 elementos.",
                              "finalVerifications": [
                                "Matrizes K e F montadas corretamente (simétricas, valores físicos sensatos).",
                                "Resolução Ac=b com resíduo <1e-10.",
                                "Convergência observada ao refinar malha.",
                                "Condicionamento de A <1e8.",
                                "Solução plota suave e bate com analítica em pontos chave.",
                                "Código roda sem erros em <10s para 100 elementos."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro L2 <1% da norma da solução.",
                                "Eficiência: tempo de CPU escalável com DOFs.",
                                "Robustez: funciona para diferentes f e BCs.",
                                "Clareza do código: comentado, modular (funções separadas).",
                                "Análise: relatório discute cond e convergência.",
                                "Validação: múltiplos testes passados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura e álgebra linear esparsa.",
                                "Programação: MATLAB vectorizado e debugging.",
                                "Física/Engenharia Mecânica: Equações de elastica e vigas.",
                                "Estatística: Análise de erro e convergência.",
                                "Computação Científica: Paralelismo para malhas grandes."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado em software como ANSYS para análise estática de vigas/estruturas, simulando deformações sob cargas distribuídas via elementos finitos 1D."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Analisar condicionamento via matriz de Gram",
                            "description": "Calcular a matriz de Gram G_ij = ∫ φ_i φ_j dx, avaliar autovalores para verificar il-condicionamento em bases polinomiais hierárquicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de matriz de Gram e sua relevância no condicionamento",
                                  "subSteps": [
                                    "Estude a definição matemática da matriz de Gram: G_ij = ∫ φ_i(x) φ_j(x) dx sobre o domínio apropriado.",
                                    "Revise bases polinomiais hierárquicas (ex.: Legendre, Chebyshev) e suas propriedades ortogonais.",
                                    "Identifique por que bases hierárquicas podem levar a il-condicionamento em métodos de resíduos ponderados.",
                                    "Analise exemplos teóricos de ortogonalidade e como a Gram afeta a estabilidade numérica.",
                                    "Discuta o número de condicionamento cond(G) = λ_max / λ_min e seus impactos em soluções computacionais."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a relação entre Gram e condicionamento, com um diagrama simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de métodos numéricos (ex.: Atkinson), notas de aula sobre polinômios ortogonais, calculadora simbólica (SymPy ou Mathematica)"
                                  ],
                                  "tips": "Comece com bases ortogonais para contrastar com hierárquicas; visualize integrais como produtos internos.",
                                  "learningObjective": "Entender o papel da matriz de Gram na avaliação de condicionamento de bases funcionais.",
                                  "commonMistakes": [
                                    "Confundir Gram com matriz de massa em FEM",
                                    "Ignorar o domínio de integração específico do problema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular elementos da matriz de Gram para bases polinomiais hierárquicas",
                                  "subSteps": [
                                    "Escolha uma base hierárquica simples (ex.: {1, x, x^2, x^3} no intervalo [-1,1]).",
                                    "Compute analiticamente ∫ φ_i φ_j dx para i,j até ordem 4, usando integrais conhecidas de potências.",
                                    "Implemente numericamente via quadratura Gauss-Legendre para casos de ordem superior.",
                                    "Verifique simetria e positividade definida da matriz G resultante.",
                                    "Compare com bases ortogonais (ex.: Legendre) para quantificar il-condicionamento."
                                  ],
                                  "verification": "Produza a matriz G 4x4 com elementos corretos até 4 casas decimais e confirme simetria.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software Python com NumPy/SciPy, tabela de quadratura Gauss, papel e lápis para cálculos analíticos"
                                  ],
                                  "tips": "Use expansão binomial para integrais; normalize funções para facilitar comparações.",
                                  "learningObjective": "Dominar o cálculo explícito ou numérico dos elementos G_ij.",
                                  "commonMistakes": [
                                    "Erros em limites de integração",
                                    "Não escalar corretamente as funções base"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar autovalores e número de condicionamento",
                                  "subSteps": [
                                    "Use decomposição espectral para obter autovalores λ_i de G (analítico para baixa ordem, numérico via eig).",
                                    "Calcule cond(G) = λ_max / λ_min e cond_2(G) usando norma espectral.",
                                    "Plote autovalores vs. ordem da base para observar deterioração.",
                                    "Teste sensibilidade perturbando G ligeiramente e reavaliando cond.",
                                    "Interprete valores: cond < 10^3 bom, >10^6 il-condicionado."
                                  ],
                                  "verification": "Gere tabela com autovalores e cond para ordens 2,4,6; gráfico mostrando crescimento exponencial de cond.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python/MATLAB com funções eig e cond, planilha Excel para tabulação"
                                  ],
                                  "tips": "Use bibliotecas como numpy.linalg.eig; log-scale para plots de cond.",
                                  "learningObjective": "Avaliar quantitativamente o condicionamento via espectro da Gram.",
                                  "commonMistakes": [
                                    "Autovalores negativos devido a erros numéricos",
                                    "Confundir cond_1 com cond_2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e propor melhorias para condicionamento",
                                  "subSteps": [
                                    "Classifique o condicionamento baseado em cond(G) e discuta impactos em soluções de resíduos ponderados.",
                                    "Compare com pré-condicionadores ou bases ortogonais hierárquicas.",
                                    "Simule um problema de valor de contorno simples (ex.: equação de Poisson) com bases il-condicionadas.",
                                    "Recomende estratégias: reortogonalização Gram-Schmidt, uso de polinômios ortogonais nativos.",
                                    "Documente relatório com conclusões e sugestões para implementação numérica em Engenharia Civil."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo análise e propondo uma melhoria específica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código de exemplo para Poisson 1D, template de relatório"
                                  ],
                                  "tips": "Relacione com estabilidade em FEM para estruturas civis; priorize bases com bom cond.",
                                  "learningObjective": "Aplicar análise de condicionamento para otimizar implementações numéricas.",
                                  "commonMistakes": [
                                    "Subestimar impacto em precisão de soluções",
                                    "Ignorar custos computacionais de ortogonalização"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de viga em flexão (Engenharia Civil), use base hierárquica {1,x,x^2,x^3} para aproximar deslocamentos. Calcule G no domínio [0,L], encontre cond(G)≈10^8 para ordem 4, confirmando il-condicionamento que causa erros em autovalores de rigidez; migre para Legendre hierárquicos reduzindo cond para 10^2.",
                              "finalVerifications": [
                                "Matriz G calculada corretamente e simétrica para base de ordem N≥4.",
                                "Autovalores positivos e cond(G) computado com precisão relativa <1%.",
                                "Gráfico de cond vs. ordem mostra tendência exponencial.",
                                "Interpretação correta: identificar il-condicionamento e propor correção.",
                                "Simulação simples reproduz instabilidade numérica.",
                                "Relatório conciso com todos os resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de G e autovalores (90% correto).",
                                "Profundidade na interpretação de condicionamento e impactos.",
                                "Qualidade dos gráficos e visualizações (clareza, escalas adequadas).",
                                "Criatividade em conexões com problemas reais de Engenharia Civil.",
                                "Completude do relatório com verificações e sugestões práticas.",
                                "Eficiência temporal: conclusão dentro de 5.5 horas totais."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: decomposição espectral e normas de matriz.",
                                "Análise Numérica: estabilidade e erro de arredondamento.",
                                "Programação Computacional: implementação em Python/SciPy para eigendecomposição.",
                                "Física/Mecânica: aplicações em métodos espectrais para PDEs em estruturas.",
                                "Estatística: análise de sensibilidade e variância em autovalores."
                              ],
                              "realWorldApplication": "Na análise numérica de elementos finitos para projetos de pontes ou edifícios, detectar il-condicionamento via Gram evita erros em predições de tensões, otimizando designs seguros e computacionalmente eficientes em softwares como ANSYS ou códigos customizados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Aplicar a problemas de engenharia civil",
                            "description": "Resolver numericamente equações de vigas (d^4w/dx^4 = p/EI) ou difusão térmica com condições de contorno, comparando com soluções exatas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formulação Matemática do Problema de Engenharia Civil",
                                  "subSteps": [
                                    "Identifique o problema específico: equação de viga (d⁴w/dx⁴ = p/EI) ou difusão térmica (∂T/∂t = α ∂²T/∂x²).",
                                    "Defina o domínio geométrico, condições de contorno e condições iniciais (ex: viga engastada em uma extremidade).",
                                    "Especifique parâmetros físicos: módulo E, inércia I, carga p(x), coeficiente α para difusão.",
                                    "Derive a forma fraca ou residual para o método dos resíduos ponderados.",
                                    "Esboce a malha numérica inicial (número de nós e elementos)."
                                  ],
                                  "verification": "Verifique se a formulação está escrita corretamente em um documento ou notebook, com todas as condições de contorno explicitadas e sem erros dimensionais.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Caderno de anotações, calculadora, referência teórica (livro de métodos numéricos em engenharia).",
                                  "tips": "Comece sempre pela equação governante exata antes de discretizar para evitar erros de interpretação.",
                                  "learningObjective": "Compreender e formular precisamente problemas diferenciais de valor inicial/de contorno em contextos de engenharia civil.",
                                  "commonMistakes": "Esquecer unidades consistentes nos parâmetros físicos ou confundir condições de contorno de Dirichlet com Neumann."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementação do Método dos Resíduos Ponderados",
                                  "subSteps": [
                                    "Escolha funções de ponderação (ex: polinômios de Legendre ou funções chapéu).",
                                    "Discretize o domínio em elementos finitos ou nós, formando a malha.",
                                    "Monte o sistema matricial: integre resíduos ponderados para gerar equações algébricas.",
                                    "Implemente em código (Python com NumPy/SciPy ou MATLAB): funções para integração numérica (Gauss-Legendre).",
                                    "Resolva o sistema linear usando solvers (ex: np.linalg.solve)."
                                  ],
                                  "verification": "Execute o código com um problema teste simples e confira se a matriz de rigidez é simétrica positiva definida.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Computador com Python/MATLAB instalado, bibliotecas NumPy, SciPy, Matplotlib.",
                                  "tips": "Use integração numérica exata para baixas ordens de polinômios para validar o código.",
                                  "learningObjective": "Implementar o método dos resíduos ponderados de forma computacional eficiente e correta.",
                                  "commonMistakes": "Índices errados na montagem da matriz global ou falha em impor condições de contorno essenciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicação a um Problema Específico de Engenharia Civil",
                                  "subSteps": [
                                    "Selecione um caso: viga cantilever com carga uniforme ou difusão térmica em laje de concreto.",
                                    "Insira parâmetros reais: E=30 GPa, I=1e-4 m⁴, p=10 kN/m para viga.",
                                    "Execute a simulação numérica e plote resultados (deslocamentos w(x) ou temperatura T(x,t)).",
                                    "Analise condicionamento da matriz (número de condição via np.linalg.cond).",
                                    "Refine a malha e observe convergência."
                                  ],
                                  "verification": "Gere gráficos de solução numérica vs. malha refinada, confirmando redução de erro com refinamento.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Código do passo anterior, dados reais de engenharia (tabelas de materiais).",
                                  "tips": "Salve versões do código para diferentes malhas para comparar facilmente.",
                                  "learningObjective": "Aplicar o método a cenários reais de engenharia civil, avaliando condicionamento numérico.",
                                  "commonMistakes": "Usar parâmetros irreais levando a instabilidades numéricas ou ignorar o tempo de difusão transitório."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação e Comparação com Soluções Exatas",
                                  "subSteps": [
                                    "Obtenha solução exata analítica (ex: para viga cantilever: w(x) = (p/24EI)(x⁴ - 4L³x + 6L²x²)).",
                                    "Calcule erros: L2 norm ||w_num - w_exata|| / ||w_exata||.",
                                    "Plote sobreposições de curvas numérica e exata.",
                                    "Analise taxa de convergência (log-log plot de erro vs. h, passo da malha).",
                                    "Documente insights sobre precisão e condicionamento."
                                  ],
                                  "verification": "Erro relativo < 1% para malha fina e gráfico de convergência com inclinação esperada (ordem do método).",
                                  "estimatedTime": "2 horas",
                                  "materials": "Código anterior, fórmulas analíticas de referência.",
                                  "tips": "Use escalas logarítmicas para visualizar erros pequenos em plots.",
                                  "learningObjective": "Validar soluções numéricas contra exatas e quantificar precisão em problemas de engenharia.",
                                  "commonMistakes": "Comparar soluções em pontos errados ou normalizar incorretamente os erros."
                                }
                              ],
                              "practicalExample": "Resolva numericamente a flexão de uma viga cantilever de comprimento L=5m, engastada em x=0 (w=0, w'=0), livre em x=L (M=0, V=0), sob carga uniforme p=10 kN/m. Use E=200 GPa, I=1e-4 m⁴. Compare com solução exata w(x)=(p/24EI)(6L²x² - 4L³x + x⁴), plotando deslocamentos e erros.",
                              "finalVerifications": [
                                "Solução numérica converge para exata com refinamento de malha (erro <0.5%).",
                                "Número de condição da matriz <1e6, indicando bom condicionamento.",
                                "Condições de contorno satisfeitas em todos os nós (erro <1e-6).",
                                "Gráficos mostram sobreposição visual perfeita para malha fina.",
                                "Relatório documenta parâmetros, código e análises."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro L2 <1% em malha otimizada.",
                                "Eficiência: Tempo de execução <10s para 100 nós.",
                                "Correção: Condições de contorno e parâmetros físicos aplicados corretamente.",
                                "Análise: Discussão clara de convergência e condicionamento.",
                                "Código: Comentado, modular e reproduzível.",
                                "Visualização: Plots profissionais com legendas e escalas adequadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais parciais e análise numérica.",
                                "Programação: Desenvolvimento de algoritmos em Python/MATLAB.",
                                "Física: Mecânica dos sólidos e transferência de calor.",
                                "Engenharia de Materiais: Propriedades como E, I e α."
                              ],
                              "realWorldApplication": "Em projetos de estruturas civis, como dimensionamento de vigas em pontes ou análise térmica de barragens, onde soluções numéricas via resíduos ponderados permitem simular comportamentos complexos sem análises analíticas inviáveis, otimizando projetos e reduzindo custos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Matriz de Gram",
                    "description": "Construção e propriedades da matriz de Gram utilizada na avaliação de ortogonalidade em métodos de resíduos ponderados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Construção da Matriz de Gram",
                        "description": "Definição formal da matriz de Gram como o produto interno entre funções de base em espaços de funções, com passos detalhados para sua montagem em problemas de valor inicial e de contorno.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Identificar funções de base e produto interno",
                            "description": "Reconhecer funções de base polinomiais ou outras apropriadas para métodos de resíduos ponderados e definir o produto interno ponderado ∫ φ_i(x) w(x) φ_j(x) dx no intervalo do problema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de funções de base em espaços funcionais",
                                  "subSteps": [
                                    "Estude a definição de espaço vetorial de funções contínuas ou integráveis em um intervalo [a,b].",
                                    "Aprenda o que são funções linearmente independentes e como formam uma base para um subespaço.",
                                    "Explore exemplos simples de bases: monomiais {1, x, x², ...} e funções de Legendre ou Chebyshev.",
                                    "Pratique verificando linear independência de um conjunto pequeno de funções.",
                                    "Entenda a dimensionalidade do espaço de aproximação polinomial de grau n."
                                  ],
                                  "verification": "Resolva 3 exercícios de identificação de bases lineares em espaços de funções e confira com soluções padrão.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre espaços de Hilbert",
                                    "Software Mathematica ou Python (SymPy) para plotar funções"
                                  ],
                                  "tips": [
                                    "Comece com bases polinomiais simples antes de funções ortogonais.",
                                    "Visualize funções graficamente para intuitar independência.",
                                    "Lembre-se: base mínima gera o espaço sem redundâncias."
                                  ],
                                  "learningObjective": "Compreender o papel das funções de base na aproximação de soluções em métodos numéricos.",
                                  "commonMistakes": [
                                    "Confundir independência linear com ortogonalidade.",
                                    "Escolher funções que não satisfazem condições de contorno do problema.",
                                    "Ignorar o intervalo [a,b] ao definir a base."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar funções de base apropriadas para métodos de resíduos ponderados",
                                  "subSteps": [
                                    "Revise métodos de resíduos ponderados (ex: Galerkin, Collocation, Subdomínio).",
                                    "Selecione polinômios de grau baixo (P0 a P3) para problemas elípticos em Engenharia Civil.",
                                    "Considere funções que satisfazem condições de contorno essenciais (ex: polinômios Lagrange para nós).",
                                    "Avalie bases ortogonais (Legendre) para reduzir acoplamento na matriz de Gram.",
                                    "Teste adequação: completeza, suavidade e suporte no domínio."
                                  ],
                                  "verification": "Para um problema modelo (equação de Laplace em [0,1]), liste 3 bases viáveis e justifique escolhas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigo sobre Método dos Elementos Finitos (Zienkiewicz)",
                                    "Python com NumPy para gerar bases polinomiais",
                                    "Exemplos de problemas em vigas ou placas"
                                  ],
                                  "tips": [
                                    "Priorize bases com nós nos pontos de interesse (ex: extremidades).",
                                    "Use ortogonalidade para eficiência computacional.",
                                    "Verifique se a base span o espaço de soluções admissíveis."
                                  ],
                                  "learningObjective": "Selecionar funções de base otimizadas para resíduos ponderados em problemas de Engenharia.",
                                  "commonMistakes": [
                                    "Escolher bases de alta ordem sem justificativa computacional.",
                                    "Não alinhar base com simetria do problema.",
                                    "Omitir funções que capturam singularidades locais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o produto interno ponderado para a Matriz de Gram",
                                  "subSteps": [
                                    "Defina produto interno padrão: <f,g> = ∫_a^b f(x)g(x) dx.",
                                    "Introduza peso w(x) > 0: <φ_i, φ_j>_w = ∫_a^b φ_i(x) w(x) φ_j(x) dx.",
                                    "Discuta escolhas de w(x): uniforme (w=1), Gauss (para quadratura), ou adaptado ao problema.",
                                    "Calcule entradas da Matriz de Gram G_ij = <φ_i, φ_j>_w analiticamente para bases polinomiais.",
                                    "Implemente numéricamente via quadratura (Gauss-Legendre) para casos complexos."
                                  ],
                                  "verification": "Compute G para base {1,x} em [0,1] com w(x)=1 e verifique simetria/positividade definida.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "SymPy ou MATLAB para integração simbólica",
                                    "Tabela de quadratura Gauss",
                                    "Exercícios de livros de EFs"
                                  ],
                                  "tips": [
                                    "Use propriedades de ortogonalidade para diagonalizar G quando possível.",
                                    "Escolha w(x) para melhorar condicionamento numérico.",
                                    "Sempre normalize o intervalo para padronizar."
                                  ],
                                  "learningObjective": "Formular precisamente o produto interno ponderado adaptado ao contexto do problema.",
                                  "commonMistakes": [
                                    "Esquecer o peso w(x) no integral.",
                                    "Integrar sobre intervalo errado [a,b].",
                                    "Confundir produto interno com norma L2 sem peso."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar identificação de base e produto interno em um problema completo",
                                  "subSteps": [
                                    "Escolha um problema de valor de contorno (ex: equação de difusão em viga).",
                                    "Defina domínio [a,b], condições de contorno e espaço de aproximação.",
                                    "Selecione base φ_i e peso w(x) coerentes.",
                                    "Monte a Matriz de Gram e vetor de carga para resíduos ponderados.",
                                    "Resolva o sistema e valide com solução exata.",
                                    "Analise sensibilidade à escolha de base/peso."
                                  ],
                                  "verification": "Implemente em código e compare erro de aproximação para 2 bases diferentes.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python (SciPy para solvers lineares)",
                                    "Problema modelo: d²u/dx² = f em [0,L] com u(0)=u(L)=0",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": [
                                    "Comece com N=2 funções de base para depuração.",
                                    "Plote resíduos para validar ponderação.",
                                    "Documente escolhas para reprodutibilidade."
                                  ],
                                  "learningObjective": "Aplicar conceitos em fluxo completo de construção da Matriz de Gram.",
                                  "commonMistakes": [
                                    "Base não satisfaz BCs essenciais.",
                                    "Erro de integração numérica levando a G il-condicionada.",
                                    "Ignorar normalização das funções de base."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever [0,L] com carga distribuída, use base polinomial φ1(x)=x/L, φ2(x)=(x/L)^2 para aproximar deflexão u(x). Defina <φi,φj>_w = ∫_0^L φi(x) φj(x) (1 - x/L) dx com w(x) decrescente para ênfase na raiz fixa. Compute G = [[∫φ1²w, ∫φ1φ2w], [∫φ1φ2w, ∫φ2²w]] e resolva Gu = b.",
                              "finalVerifications": [
                                "Lista corretamente 3 funções de base polinomiais adequadas para o intervalo dado.",
                                "Define precisamente o produto interno com peso w(x) e limites [a,b].",
                                "Calcula pelo menos uma entrada da Matriz de Gram analiticamente.",
                                "Justifica escolha de base e peso com base em propriedades do problema.",
                                "Verifica ortogonalidade ou condicionamento da matriz resultante.",
                                "Identifica limitações da escolha para problemas reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática do produto interno (integral correto).",
                                "Adequação da base ao contexto (completeza, BCs, ordem).",
                                "Justificativa técnica para escolhas (ortogonalidade, eficiência).",
                                "Capacidade de computar G manualmente para caso baixo-dimensional.",
                                "Análise de erros potenciais e alternativas.",
                                "Clareza na comunicação via diagramas ou código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Espaços de Hilbert e ortogonalidade em Análise Funcional.",
                                "Computação: Integração numérica e solvers lineares em programação científica.",
                                "Física: Aproximação de campos em Mecânica dos Sólidos (deformações).",
                                "Engenharia: Elementos Finitos para simulações estruturais.",
                                "Estatística: Ponderação em regressão e mínimos quadrados ponderados."
                              ],
                              "realWorldApplication": "Na análise de estruturas civis via Método dos Elementos Finitos (MEF), identificar bases polinomiais e produtos internos ponderados é essencial para montar matrizes de rigidez em softwares como ANSYS ou SAP2000, permitindo simular deformações em pontes, edifícios e barragens sob cargas reais, otimizando projetos contra falhas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Calcular elementos da matriz de Gram",
                            "description": "Realizar cálculos analíticos ou numéricos dos integrais para obter os elementos G_ij = <φ_i, φ_j>, considerando pesos w(x) e limites de integração para problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e preparar os componentes da integral de Gram",
                                  "subSteps": [
                                    "Revise a definição de G_ij = ∫_a^b φ_i(x) φ_j(x) w(x) dx",
                                    "Liste as funções base φ_i(x) e φ_j(x) do conjunto {φ_k}",
                                    "Identifique o peso w(x) e os limites de integração [a, b]",
                                    "Esboce as funções graficamente para visualizar o domínio",
                                    "Verifique se as funções são ortogonais ou normalizadas previamente"
                                  ],
                                  "verification": "Confirme que todos os componentes estão corretamente anotados e coincidem com o problema dado",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Gráfica de funções (software como Desmos ou MATLAB)",
                                    "Definição do problema"
                                  ],
                                  "tips": "Sempre normalize as funções base se possível para simplificar cálculos futuros",
                                  "learningObjective": "Compreender os elementos constitutivos da matriz de Gram em contextos de engenharia civil",
                                  "commonMistakes": [
                                    "Esquecer o peso w(x)",
                                    "Usar limites incorretos",
                                    "Confundir índices i e j"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o método de cálculo: analítico ou numérico",
                                  "subSteps": [
                                    "Avalie se a integral pode ser resolvida analiticamente (polinômios, funções trigonométricas simples)",
                                    "Se analítica: prepare antiderivadas de φ_i φ_j w(x)",
                                    "Se numérica: escolha método (quadratura de Gauss, Simpson, trapezoidal) baseado na precisão necessária",
                                    "Defina tolerância de erro (ex: 10^-6) e número de pontos de integração",
                                    "Implemente o método em software se numérico (MATLAB, Python com SciPy)"
                                  ],
                                  "verification": "Justifique a escolha do método com base na complexidade das funções e valide com um caso teste simples",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora simbólica (Wolfram Alpha ou SymPy)",
                                    "Software numérico (MATLAB, Python)",
                                    "Tabelas de quadratura de Gauss"
                                  ],
                                  "tips": "Prefira analítico para exatidão em problemas acadêmicos; numérico para funções irregulares em engenharia",
                                  "learningObjective": "Escolher apropriadamente métodos de integração para eficiência e precisão",
                                  "commonMistakes": [
                                    "Escolher numérico desnecessariamente lento",
                                    "Ignorar singularidades no integrando",
                                    "Usar poucos pontos em numérico levando a erros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o cálculo para um elemento específico G_ij",
                                  "subSteps": [
                                    "Forme o integrando f(x) = φ_i(x) φ_j(x) w(x)",
                                    "Integre f(x) de a a b usando o método selecionado",
                                    "Registre o valor numérico ou simbólico de G_ij com precisão adequada",
                                    "Repita para pelo menos um par simétrico G_ji para verificar G_ij = G_ji",
                                    "Anote unidades e significância (ex: para problemas de engenharia, manter 4 casas decimais)"
                                  ],
                                  "verification": "Compare G_ij com G_ji; diferença deve ser < 10^-8",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de cálculo (MATLAB, Python NumPy/SciPy)",
                                    "Papel para rascunhos analíticos"
                                  ],
                                  "tips": "Use simetria da matriz para calcular apenas triângulo superior e transpor",
                                  "learningObjective": "Realizar integração precisa para elementos individuais da matriz de Gram",
                                  "commonMistakes": [
                                    "Erro de sinal no integrando",
                                    "Arredondamento prematuro",
                                    "Não verificar simetria"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Completar a matriz e realizar verificações iniciais",
                                  "subSteps": [
                                    "Calcule todos os G_ij para i,j = 1 a n (n dimensão da base)",
                                    "Monte a matriz G simétrica",
                                    "Verifique diagonal positiva (G_ii > 0) e semi-definida positiva (autovalores ≥ 0)",
                                    "Teste condicional da matriz (cond(G) < 10^12 para estabilidade numérica)",
                                    "Documente todos os valores em tabela ou código"
                                  ],
                                  "verification": "Matriz deve ser simétrica e com traço positivo; compute det(G) > 0 se aplicável",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software linear algebra (MATLAB eig(), Python NumPy linalg)",
                                    "Planilha (Excel para matrizes pequenas)"
                                  ],
                                  "tips": "Para bases mal-condicionadas, considere ortogonalização prévia",
                                  "learningObjective": "Construir e validar a matriz de Gram completa para uso em métodos numéricos",
                                  "commonMistakes": [
                                    "Índices trocados na montagem",
                                    "Ignorar ill-condicionamento",
                                    "Não verificar positividez"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga simplesmente apoiada [0, L=10m], funções base φ1(x)=1, φ2(x)=x/L, w(x)=1 (uniforme). Calcule G11=∫0^10 1*1 dx=10, G12=∫0^10 1*(x/10) dx=5, G22=∫0^10 (x/10)^2 dx=10/3. Matriz G = [[10,5],[5,10/3]].",
                              "finalVerifications": [
                                "Calcule corretamente G_ij para um exemplo dado com erro < 1%",
                                "Monte matriz simétrica completa para n=3 funções base",
                                "Identifique e corrija ill-condicionamento se cond(G)>10^10",
                                "Explique escolha de método para um caso complexo",
                                "Valide positividez semi-definida via autovalores",
                                "Aplique G em um sistema simples Ax=b"
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos (erro < 0.1%)",
                                "Justificativa adequada do método de integração",
                                "Correta verificação de simetria e propriedades da matriz",
                                "Eficiência computacional (tempo e recursos)",
                                "Documentação clara de passos e resultados",
                                "Tratamento de casos numéricos/analíticos mistos"
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Numérico: Métodos de integração e quadratura",
                                "Álgebra Linear: Propriedades de matrizes simétricas positivas",
                                "Programação Computacional: Implementação em MATLAB/Python",
                                "Física/Mecânica: Aplicação em métodos de Galerkin para EDP",
                                "Estatística: Análise de erro e condicionamento numérico"
                              ],
                              "realWorldApplication": "Em análise estrutural de vigas e placas via método dos elementos finitos ou Galerkin, a matriz de Gram é essencial para resolver equações diferenciais de equilíbrio, prevendo deformações e tensões em pontes e edifícios sob cargas reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Montar a matriz completa",
                            "description": "Assemblar a matriz simétrica G a partir dos elementos calculados, verificando dimensões para n funções de base em problemas de valor inicial ou contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Organizar os elementos calculados da matriz de Gram",
                                  "subSteps": [
                                    "Liste todos os elementos g_ij = ∫ φ_i(x) φ_j(x) dx para i,j = 1 a n, onde n é o número de funções de base.",
                                    "Separe os elementos da diagonal principal (i=j) dos elementos off-diagonal (i≠j).",
                                    "Anote os valores exatos ou aproximados de cada integral calculada previamente.",
                                    "Crie uma tabela ou grade auxiliar para visualizar os pares (i,j) e seus valores.",
                                    "Confirme que todos os pares necessários foram calculados, sem duplicatas desnecessárias devido à simetria."
                                  ],
                                  "verification": "Verifique se há exatamente n² elementos listados ou n(n+1)/2 únicos considerando simetria.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou planilha digital (Excel/Google Sheets)",
                                    "Resultados prévios de integrais g_ij",
                                    "Calculadora ou software simbólico como SymPy"
                                  ],
                                  "tips": "Aproveite a simetria: g_ij = g_ji para reduzir cálculos; foque em calcular apenas triângulo superior.",
                                  "learningObjective": "Compreender a estrutura dos elementos da matriz de Gram e sua origem em produtos internos.",
                                  "commonMistakes": [
                                    "Esquecer elementos off-diagonal",
                                    "Confundir índices i e j",
                                    "Não considerar simetria levando a duplicatas inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar e preencher a matriz simétrica G",
                                  "subSteps": [
                                    "Crie uma matriz quadrada vazia de dimensões n x n.",
                                    "Preencha a diagonal principal com g_ii para i=1 a n.",
                                    "Preencha o triângulo superior (i<j) com g_ij.",
                                    "Preencha o triângulo inferior (i>j) copiando os valores do superior via transposição (g_ji = g_ij).",
                                    "Rotule as linhas e colunas com os índices das funções de base φ1 a φn."
                                  ],
                                  "verification": "Confirme visualmente que todos os elementos estão preenchidos e a matriz é quadrada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha digital ou software de matriz (MATLAB/Python NumPy)",
                                    "Lista de elementos do Step 1"
                                  ],
                                  "tips": "Use formatação colorida na planilha para diagonal (ex: verde) e off-diagonal (azul) para facilitar inspeção.",
                                  "learningObjective": "Montar matrizes simétricas a partir de produtos internos escalares.",
                                  "commonMistakes": [
                                    "Erro de transposição ao copiar off-diagonal",
                                    "Índices invertidos nas linhas/colunas",
                                    "Deixar células vazias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a propriedade de simetria da matriz",
                                  "subSteps": [
                                    "Para cada par i<j, compare g_ij com g_ji; devem ser iguais dentro de tolerância numérica (ex: 10^-6).",
                                    "Calcule a diferença G - G^T elemento a elemento.",
                                    "Verifique se a diagonal é real e não-negativa (propriedade de Gram).",
                                    "Some os elementos simétricos e confirme consistência.",
                                    "Documente qualquer discrepância e corrija recalculando integrais se necessário."
                                  ],
                                  "verification": "A matriz resultante satisfaz G = G^T exatamente ou numericamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de álgebra linear (NumPy, MATLAB)",
                                    "Matriz preenchida do Step 2"
                                  ],
                                  "tips": "Implemente uma função simples em Python: np.allclose(G, G.T) para verificação automática.",
                                  "learningObjective": "Aplicar e validar propriedades fundamentais de matrizes de Gram.",
                                  "commonMistakes": [
                                    "Ignorar erros numéricos em integrais aproximadas",
                                    "Confundir simetria com diagonalidade",
                                    "Não checar tolerância em cálculos flutuantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar dimensões, completude e prontidão para uso",
                                  "subSteps": [
                                    "Confirme dimensões: shape(G) = (n, n) onde n = número de funções de base.",
                                    "Verifique se todos os elementos são finitos e não-NaN.",
                                    "Calcule o determinante ou traço para sanity check (traço = soma de normas das φ_i).",
                                    "Salve a matriz em formato utilizável (ex: .csv, .mat).",
                                    "Teste multiplicação por vetor de coeficientes para aplicação posterior."
                                  ],
                                  "verification": "Matriz é n x n, simétrica, positiva semi-definida e pronta para resolução de sistemas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Software numérico",
                                    "Matriz final do Step 3"
                                  ],
                                  "tips": "Para problemas grandes, considere sparse matrices se aplicável em FEM.",
                                  "learningObjective": "Garantir que a matriz esteja correta para problemas de valor inicial/contorno.",
                                  "commonMistakes": [
                                    "Dimensões erradas por contagem incorreta de bases",
                                    "Elementos infinitos por singularidades em integrais",
                                    "Não salvar em formato acessível"
                                  ]
                                }
                              ],
                              "practicalExample": "Para n=3 funções de base φ1(x)=1, φ2(x)=x, φ3(x)=x² no intervalo [0,1]:\n∫φ1φ1=1, ∫φ1φ2=0.5, ∫φ1φ3=1/3≈0.333, ∫φ2φ2=1/3≈0.333, ∫φ2φ3=0.25, ∫φ3φ3=1/5=0.2.\nMatriz G = [[1, 0.5, 0.333], [0.5, 0.333, 0.25], [0.333, 0.25, 0.2]]. Verifique simetria e dims 3x3.",
                              "finalVerifications": [
                                "Matriz tem dimensões exatas n x n.",
                                "G = G^T (simetria confirmada).",
                                "Todos elementos da diagonal são positivos.",
                                "Nenhum elemento é NaN ou infinito.",
                                "Traço da matriz igual à soma das normas L2 das funções de base.",
                                "Matriz é positiva semi-definida (autovalores ≥0)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na montagem: todos g_ij corretos (pontos parciais por simetria).",
                                "Verificação de simetria: método e resultados documentados.",
                                "Validação de dimensões: n correto e shape verificado.",
                                "Eficiência: uso de simetria para evitar redundâncias.",
                                "Documentação: passos claros e matriz final salva.",
                                "Aplicação teste: multiplicação G * vetor funciona sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: propriedades de matrizes simétricas e decomposição.",
                                "Programação Computacional: implementação em NumPy/MATLAB para FEM.",
                                "Análise Numérica: tratamento de erros em integrais aproximadas.",
                                "Física/Mecânica: matrizes de rigidez em dinâmica estrutural.",
                                "Estatística: analogia com matriz de covariância em processos gaussianos."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, a matriz de Gram é essencial no Método dos Elementos Finitos (FEM) para montar matrizes de rigidez em simulações de estruturas como pontes ou edifícios, resolvendo equações diferenciais de valor inicial/contorno para prever deformações sob cargas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Propriedades da Matriz de Gram",
                        "description": "Análise das propriedades matemáticas da matriz de Gram, incluindo simetria, definitude positiva e relação com condicionamento numérico em soluções computacionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Verificar simetria e positividade",
                            "description": "Demonstrar que a matriz de Gram é simétrica (G_ij = G_ji) e positiva definida (autovalores positivos), usando propriedades do produto interno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definição de produto interno e matriz de Gram",
                                  "subSteps": [
                                    "Defina o produto interno em espaços vetoriais reais: <u, v> = soma u_i v_i ou integral para funções.",
                                    "Construa a matriz de Gram G para vetores {φ1, ..., φn}: G_ij = <φi, φj>.",
                                    "Liste propriedades do produto interno: simetria <u,v> = <v,u>, definitude <u,u> ≥ 0.",
                                    "Discuta quando G é positiva definida: vetores linearmente independentes.",
                                    "Esboce um exemplo simples com 2 vetores em R^2."
                                  ],
                                  "verification": "Explique verbalmente as propriedades e construa G para um exemplo dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora básica",
                                    "Referência: notas de aula sobre produtos internos"
                                  ],
                                  "tips": "Use notação consistente para evitar confusão entre índices i e j.",
                                  "learningObjective": "Compreender a construção da matriz de Gram a partir de produtos internos.",
                                  "commonMistakes": [
                                    "Confundir produto interno com produto escalar matricial",
                                    "Esquecer normalização em funções base"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar simetria da matriz de Gram (G_ij = G_ji)",
                                  "subSteps": [
                                    "Parta da definição: G_ij = <φi, φj> e G_ji = <φj, φi>.",
                                    "Aplique propriedade de simetria do produto interno: <φi, φj> = <φj, φi>.",
                                    "Conclua que G_ij = G_ji para todo i,j.",
                                    "Verifique em um exemplo 2x2: calcule elementos e confirme igualdade.",
                                    "Generalize para n x n."
                                  ],
                                  "verification": "Escreva a prova formal e teste com matriz exemplo mostrando G = G^T.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplo de vetores: φ1 = [1,0], φ2 = [1,1]"
                                  ],
                                  "tips": "Lembre-se: simetria é direta da propriedade hermitiana do produto interno.",
                                  "learningObjective": "Demonstrar simetria analiticamente usando propriedades axiomáticas.",
                                  "commonMistakes": [
                                    "Assumir simetria sem prova",
                                    "Usar transposição matricial prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar positividade definida (autovalores positivos)",
                                  "subSteps": [
                                    "Lembre definitude: para todo vetor x ≠ 0, x^T G x > 0.",
                                    "Expanda x^T G x = soma_{i,j} x_i x_j <φi, φj> = <soma x_k φk, soma x_m φm> = ||u||^2 onde u = soma x_k φk.",
                                    "Mostre ||u||^2 > 0 se {φ} linearmente independentes (u=0 implica x=0).",
                                    "Conclua que todos autovalores λ > 0 pelo teorema espectral.",
                                    "Discuta caso semi-definida (dependentes lineares)."
                                  ],
                                  "verification": "Derive x^T G x = ||u||^2 e prove >0 para x≠0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de álgebra linear (cap. autovalores)"
                                  ],
                                  "tips": "Visualize geometricamente: G preserva norma via produto interno.",
                                  "learningObjective": "Estabelecer positividade via forma quadrática e independência linear.",
                                  "commonMistakes": [
                                    "Confundir semi-definida com definida",
                                    "Ignorar hipótese de independência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação numérica e interpretação",
                                  "subSteps": [
                                    "Escolha funções base em engenharia civil, ex: φ1(x)=1, φ2(x)=x em [0,1] para problema de viga.",
                                    "Calcule G_ij = integral φi φj dx.",
                                    "Compute autovalores numericamente (det(G - λI)=0 ou software).",
                                    "Confirme simetria (G = G^T) e λ>0.",
                                    "Interprete: estabilidade numérica em métodos de Galerkin."
                                  ],
                                  "verification": "Produza G numérica, mostre simetria e autovalores positivos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software: Python/NumPy ou MATLAB",
                                    "Calculadora para 2x2"
                                  ],
                                  "tips": "Use sympy para integrais simbólicas se disponível.",
                                  "learningObjective": "Aplicar prova teórica em exemplo computacional concreto.",
                                  "commonMistakes": [
                                    "Erro numérico em integrais",
                                    "Escolher bases dependentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de vigas via método dos elementos finitos, use funções base φ1(x)=1, φ2(x)=x em [0,L]. Calcule G = [[L, L^2/2], [L^2/2, L^3/3]]. Verifique G12=G21 (simetria) e autovalores positivos (det>0, trace>0).",
                              "finalVerifications": [
                                "Matriz G é simétrica: todos G_ij = G_ji.",
                                "Forma quadrática x^T G x > 0 para x ≠ 0.",
                                "Todos autovalores computados são positivos.",
                                "Prova analítica cobre simetria e positividade.",
                                "Exemplo numérico confirma propriedades.",
                                "Discussão de independência linear incluída."
                              ],
                              "assessmentCriteria": [
                                "Precisão da prova de simetria (100% corretude axiomática).",
                                "Correta derivação de x^T G x = ||u||^2 > 0.",
                                "Cálculo correto de autovalores em exemplo.",
                                "Uso apropriado de propriedades do produto interno.",
                                "Clareza na verificação numérica e interpretação.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Teorema espectral e formas quadráticas.",
                                "Análise Numérica: Condicionamento de matrizes em FEM.",
                                "Programação: Implementação em Python/NumPy para autovalores.",
                                "Física: Produtos internos em mecânica (energia, normas).",
                                "Estatística: Matrizes de covariância simétricas positivas."
                              ],
                              "realWorldApplication": "Na análise estrutural de edifícios via elementos finitos (software como ANSYS), matrizes de Gram surgem em projeções ortogonais para rigidez; simetria garante eficiência computacional, positividade assegura estabilidade e convergência numérica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Analisar autovalores e autofunções",
                            "description": "Calcular autovalores e autofunções da matriz de Gram para avaliar ortogonalidade das funções de base e impacto no condicionamento do sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de autovalores, autofunções e matriz de Gram",
                                  "subSteps": [
                                    "Defina autovalor λ e autofunção v tal que A v = λ v para matriz A.",
                                    "Explique a matriz de Gram G_ij = <φ_i, φ_j> onde φ são funções de base e < , > é produto interno.",
                                    "Discuta propriedades: G é simétrica positiva semidefinida, autovalores reais ≥0.",
                                    "Relacione com ortogonalidade: se base ortonormal, G = I, todos autovalores=1.",
                                    "Identifique relação com condicionamento: κ(G) = λ_max / λ_min."
                                  ],
                                  "verification": "Resuma em um parágrafo as propriedades e forneça um exemplo 2x2 manual.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de álgebra linear (ex: Strang), caderno, calculadora.",
                                  "tips": "Use notação matricial consistente; desenhe vetores para visualização.",
                                  "learningObjective": "Compreender fundamentos teóricos para análise posterior.",
                                  "commonMistakes": "Confundir autovalor com traço da matriz; ignorar positividade semidefinida."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de Gram e computar autovalores/autofunções numericamente",
                                  "subSteps": [
                                    "Escolha funções de base φ_i (ex: polinômios em [0,1]).",
                                    "Calcule elementos G_ij via integração numérica (quadraturas de Gauss).",
                                    "Implemente em Python (NumPy/SciPy) ou MATLAB: np.linalg.eig(G).",
                                    "Verifique simetria e autovalores reais positivos.",
                                    "Extraia λ_i e v_i ordenados (λ_max a λ_min)."
                                  ],
                                  "verification": "Execute código e imprima G, λ e ||G v_i - λ_i v_i|| < 1e-10 para cada i.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com NumPy/SciPy, MATLAB, funções de base definidas.",
                                  "tips": "Use np.dot para produto interno discreto se integração analítica difícil.",
                                  "learningObjective": "Dominar cálculo computacional preciso de autovalores.",
                                  "commonMistakes": "Erro numérico em integração; não normalizar autofunções."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar ortogonalidade das funções de base via autovalores",
                                  "subSteps": [
                                    "Verifique se todos λ_i ≈1 (tolerância 1e-6) para ortonormalidade.",
                                    "Se λ_i ≠1, compute coeficientes de Gram-Schmidt para ortogonalizar.",
                                    "Visualize autofunções: plote v_i como combinações lineares de φ_j.",
                                    "Calcule norma Frobenius de G - I para quantificar desvio.",
                                    "Interprete: λ_i <1 indica subespaços mal representados."
                                  ],
                                  "verification": "Gere relatório: 'Base ortonormal? Sim/Não' com λ_i listados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Código do Step 2, Matplotlib para plots.",
                                  "tips": "Escolha tolerância baseada em precisão numérica (máquina epsilon).",
                                  "learningObjective": "Interpretar autovalores como medidas de ortogonalidade.",
                                  "commonMistakes": "Ignorar autovalores próximos de zero (bases linearmente dependentes)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impacto no condicionamento do sistema",
                                  "subSteps": [
                                    "Calcule número de condicionamento κ = λ_max / λ_min.",
                                    "Avalie: κ<10 bom, 10-100 moderado, >100 ruim (il-condicionado).",
                                    "Simule sistema G α = b, resolva com np.linalg.solve, cheque resíduo.",
                                    "Compare tempo/erro com base ortonormal.",
                                    "Recomende melhorias: ortogonalização ou refinamento de base."
                                  ],
                                  "verification": "Relate κ, resíduo ||G α - b|| / ||b|| <1e-8, e sugestões.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Código anterior, vetor b aleatório.",
                                  "tips": "Log10(κ) para escala; teste com b nos autovetores.",
                                  "learningObjective": "Ligar autovalores ao condicionamento e estabilidade numérica.",
                                  "commonMistakes": "Dividir por λ_min=0; confundir com traço."
                                }
                              ],
                              "practicalExample": "Considere base {1, x} em [0,1] com <f,g>=∫fg dx. G = [[1, 0.5], [0.5, 1/3]]. Autovalores ≈1.366, 0.0335. κ≈40.8 (moderado). Autofunções mostram mistura; base não ortogonal, impacta solvers de EDPs em vigas.",
                              "finalVerifications": [
                                "Todos autovalores ≥0 e reais.",
                                "κ calculado corretamente como λ_max/λ_min.",
                                "Interpretação correta de ortogonalidade (todos λ≈1).",
                                "Resíduo de verificação de autofunções <1e-10.",
                                "Sugestões práticas para melhorar condicionamento.",
                                "Relatório inclui plots de autofunções."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erro <1e-8).",
                                "Interpretação teórica correta de propriedades.",
                                "Código reproduzível e comentado.",
                                "Análise qualitativa/quantitativa de ortogonalidade e κ.",
                                "Identificação de erros comuns evitados.",
                                "Aplicação em exemplo realista."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Diagonalização e decomposição espectral.",
                                "Análise Numérica: Estabilidade de solvers lineares.",
                                "Métodos Numéricos: Elementos Finitos e bases ortogonais.",
                                "Física/Engenharia: Expansões em séries de Fourier/Legendre."
                              ],
                              "realWorldApplication": "Em simulações de EDPs para estruturas civis (ex: vibrações de pontes via elementos finitos), analisar Gram de bases polinomiais avalia qualidade da discretização: bases mal condicionadas causam erros em predições de tensões, otimizando malhas para projetos seguros."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Avaliar condicionamento numérico",
                            "description": "Computar o número de condicionamento cond(G) = λ_max / λ_min e interpretar seu efeito na estabilidade de soluções em métodos numéricos para engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Autovalores e Matriz de Gram",
                                  "subSteps": [
                                    "Defina matriz de Gram como G = A^T A, onde A é matriz de vetores base em problemas de engenharia civil.",
                                    "Explique autovalores λ como soluções de det(G - λI) = 0, com λ_max e λ_min sendo os maiores e menores positivos.",
                                    "Discuta propriedades: G é simétrica positiva definida, logo todos λ > 0.",
                                    "Relacione com problemas de valor inicial/contorno em métodos numéricos para estruturas.",
                                    "Identifique contexto em engenharia civil, como discretizações em MEF."
                                  ],
                                  "verification": "Resuma em 3 frases as propriedades espectrais da matriz de Gram e forneça um exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de álgebra linear",
                                    "Software MATLAB ou Python (NumPy)",
                                    "Exemplos de matrizes de Gram de treliças"
                                  ],
                                  "tips": "Visualize autovalores como 'esticamentos' nos autovetores para intuição geométrica.",
                                  "learningObjective": "Dominar definições e propriedades de autovalores na matriz de Gram para contextos numéricos.",
                                  "commonMistakes": [
                                    "Assumir autovalores negativos em G",
                                    "Confundir λ_max com traço da matriz",
                                    "Ignorar simetria positiva"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Autovalores e Computar cond(G)",
                                  "subSteps": [
                                    "Construa uma matriz de Gram exemplo de um problema de engenharia civil (ex: vetores de deslocamento).",
                                    "Use decomposição espectral: eig(G) em software para obter λ_max e λ_min.",
                                    "Calcule cond(G) = λ_max / λ_min com precisão numérica.",
                                    "Teste com matriz 2x2: G = [[4,2],[2,3]], verifique λ ≈ 5.37, 1.63, cond ≈ 3.3.",
                                    "Automatize cálculo em script Python/MATLAB para matrizes maiores."
                                  ],
                                  "verification": "Forneça cond(G) correto para matriz exemplo com erro < 0.1%.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "MATLAB",
                                    "Calculadora simbólica (SymPy)"
                                  ],
                                  "tips": "Sempre normalize λ_min para evitar divisão por zero; use funções built-in para precisão.",
                                  "learningObjective": "Executar cálculo preciso de cond(G) usando ferramentas computacionais.",
                                  "commonMistakes": [
                                    "Erro de arredondamento em λ próximas",
                                    "Usar norma Frobenius em vez de espectral",
                                    "Inverter fórmula: usar λ_min/λ_max"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o Número de Condicionamento e Estabilidade",
                                  "subSteps": [
                                    "Classifique: cond(G) ≈ 1 (bem condicionada), >10^6 (mal condicionada).",
                                    "Explique impacto: alto cond amplifica erros de arredondamento em soluções numéricas.",
                                    "Relacione com estabilidade em métodos para PVPs/PVCs: perturbações em G propagam para soluções.",
                                    "Analise exemplo: cond=10^4 leva a perda de 4 dígitos precisão em double.",
                                    "Discuta mitigação: pré-condicionadores ou refinamento de malha."
                                  ],
                                  "verification": "Interprete cond=1000 em parágrafo: efeitos na estabilidade e exemplos de falha.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Artigos sobre estabilidade numérica",
                                    "Gráficos de erro vs cond",
                                    "Simulador online de condicionamento"
                                  ],
                                  "tips": "Pense em termos de 'sensibilidade': pequenas mudanças em entrada causam grandes em saída.",
                                  "learningObjective": "Interpretar qualitativa e quantitativamente o impacto de cond(G) na robustez numérica.",
                                  "commonMistakes": [
                                    "Achar cond baixo sempre bom sem contexto",
                                    "Ignorar máquina epsilon",
                                    "Confundir com tempo de convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Problema Real de Engenharia Civil",
                                  "subSteps": [
                                    "Selecione problema: discretização de treliça ou viga em MEF gerando G.",
                                    "Compute cond(G) e avalie estabilidade da solução de deslocamentos.",
                                    "Simule perturbação: adicione ruído 10^-10 e compare soluções.",
                                    "Conclua: se ||Δx|| / ||x|| >> 10^-10, instável devido a alto cond.",
                                    "Proponha melhorias: reescalonamento ou bases ortogonais."
                                  ],
                                  "verification": "Relatório curto com cond(G), gráfico de erro e recomendação.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Software FEniCS ou Abaqus para MEF",
                                    "Dataset de treliça simples",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Comece com malha grosseira para cond baixo, refine para ver piora.",
                                  "learningObjective": "Aplicar avaliação de condicionamento em cenários práticos de engenharia civil.",
                                  "commonMistakes": [
                                    "Malha não uniforme levando a G singular",
                                    "Esquecer normalização de unidades",
                                    "Sobrepor instabilidade a outros erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de uma treliça 2D com 3 nós, vetores de deslocamento A = [[1,0,0.5],[0,1,0.5]], G = A^T A = [[1.25,0.25,0.75],[0.25,1.25,0.25],[0.75,0.25,1.25]]. Autovalores: λ_max≈2.5, λ_min≈0.5, cond(G)=5. Interpretação: moderadamente condicionada, erros arredondam <2 dígitos em forças internas.",
                              "finalVerifications": [
                                "Cálculo de cond(G) exato para matriz 3x3 exemplo.",
                                "Interpretação correta: cond>10^4 indica risco de instabilidade.",
                                "Simulação de perturbação mostra amplificação proporcional a cond.",
                                "Identificação de pelo menos 2 estratégias de mitigação.",
                                "Relatório integra cálculo, interpretação e aplicação civil.",
                                "Gráfico de erro vs cond para validação visual."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de autovalores e cond(G): erro <0.01%.",
                                "Interpretação profunda do impacto na estabilidade numérica.",
                                "Uso correto de software com código reproduzível.",
                                "Aplicação contextualizada em engenharia civil (MEF/PVPs).",
                                "Identificação de erros comuns e mitigação proposta.",
                                "Clareza no relatório com gráficos e conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: decomposição espectral e normas de matriz.",
                                "Análise Numérica: estabilidade de algoritmos e erro propagado.",
                                "Engenharia Estrutural: MEF para análise de estruturas civis.",
                                "Programação Computacional: bibliotecas NumPy/SciPy para eigen.",
                                "Física Aplicada: dinâmica de sistemas discretizados em PVCs."
                              ],
                              "realWorldApplication": "Na simulação numérica de pontes via elementos finitos, alto cond(G) em matrizes de rigidez causa soluções instáveis, levando a previsões erradas de tensões e risco de colapso subestimado; engenheiros usam essa métrica para validar malhas e escolher solvers robustos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Aplicação em Métodos de Resíduos Ponderados",
                        "description": "Uso da matriz de Gram para avaliar ortogonalidade e resolver sistemas lineares em métodos de resíduos ponderados aplicados a problemas de valor inicial e de contorno.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Avaliar ortogonalidade via matriz de Gram",
                            "description": "Verificar se funções de base são ortogonais quando G é diagonal e usar isso para simplificar equações em métodos de Galerkin ou momentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Ortogonalidade e Matriz de Gram",
                                  "subSteps": [
                                    "Defina ortogonalidade de funções no contexto de espaços de funções L2: duas funções φ_i e φ_j são ortogonais se ∫ φ_i φ_j w dx = 0 para i ≠ j, onde w é o peso.",
                                    "Explique o produto interno: <φ_i, φ_j> = ∫_a^b φ_i(x) φ_j(x) w(x) dx.",
                                    "Descreva a matriz de Gram G como G_{ij} = <φ_i, φ_j>, uma matriz simétrica positiva definida.",
                                    "Identifique que G diagonal implica base ortogonal (off-diagonais zero).",
                                    "Relacione com métodos de resíduos ponderados: ortogonalidade simplifica o sistema linear."
                                  ],
                                  "verification": "Resuma em suas palavras a relação entre G diagonal e ortogonalidade, com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de métodos numéricos (ex: Burden & Faires)",
                                    "Papel e caneta",
                                    "Acesso a Khan Academy ou vídeo sobre produtos internos"
                                  ],
                                  "tips": "Visualize ortogonalidade como vetores perpendiculares em espaços funcionais.",
                                  "learningObjective": "Dominar definições fundamentais para avaliação posterior.",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade com ortonormalidade (requer norma 1)",
                                    "Ignorar o peso w(x) no produto interno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Matriz de Gram para Funções de Base Dadas",
                                  "subSteps": [
                                    "Selecione funções de base φ1, φ2, ..., φn em um intervalo [a,b] com peso w(x).",
                                    "Calcule cada elemento G_{ij} = ∫_a^b φ_i(x) φ_j(x) w(x) dx analiticamente ou numericamente.",
                                    "Use integração exata para polinômios baixos ou quadratura numérica para casos complexos.",
                                    "Monte a matriz G completa, verificando simetria (G_{ij} = G_{ji}).",
                                    "Implemente em software como Python (SymPy) ou MATLAB para automação."
                                  ],
                                  "verification": "Compute G para φ1=1, φ2=x em [0,1] com w=1 e confirme valores não-zero off-diagonal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software: Python com SymPy ou MATLAB",
                                    "Calculadora simbólica online (Wolfram Alpha)",
                                    "Folha de exercícios com integrais"
                                  ],
                                  "tips": "Para polinômios, expanda e integre termo a termo para evitar erros.",
                                  "learningObjective": "Capacitar cálculo preciso da matriz de Gram.",
                                  "commonMistakes": [
                                    "Erros em limites de integração",
                                    "Esquecer fator w(x)",
                                    "Arredondamentos prematuros em cálculos numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Ortogonalidade Verificando Diagonalidade de G",
                                  "subSteps": [
                                    "Examine elementos off-diagonal de G: se todos ≈0 (tolerância 1e-6), base é ortogonal.",
                                    "Defina tolerância numérica para flutuações de precisão.",
                                    "Se G diagonal, normalize para ortonormalidade dividindo por normas (diagonal de G).",
                                    "Compare com bases conhecidas ortogonais (ex: Fourier, Legendre).",
                                    "Documente conclusão: 'Base ortogonal' ou 'Não ortogonal, precisa orthogonalizar'."
                                  ],
                                  "verification": "Para funções seno em Fourier, mostre G diagonal; para {1,x}, mostre não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Jupyter Notebook para matrizes",
                                    "Documentação NumPy para tolerâncias"
                                  ],
                                  "tips": "Use cond(G) para checar ill-conditioning se off-diagonais pequenas.",
                                  "learningObjective": "Desenvolver critério quantitativo para ortogonalidade.",
                                  "commonMistakes": [
                                    "Tolerância muito rígida ignorando erros numéricos",
                                    "Confundir diagonal dominante com diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Ortogonalidade para Simplificar Métodos de Galerkin ou Momentos",
                                  "subSteps": [
                                    "No método de Galerkin, sistema é K c = f, onde K_{ij} = <a(φ_j,φ_i), L(u)> ≈ G * algo; se G diagonal, decouple.",
                                    "Para momentos: coeficientes c_i = <r, ψ_i> / <φ_i, ψ_i>, simplifica se ψ_i = φ_i e ortogonal.",
                                    "Resolva sistema diagonal explicitamente: c_i = f_i / G_{ii}.",
                                    "Compare tempo computacional: O(n) vs O(n^3) para não-ortogonal.",
                                    "Teste em EDP simples como -u''=f em viga (engenharia civil)."
                                  ],
                                  "verification": "Simplifique equação Galerkin para base ortogonal e resolva analiticamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código MATLAB/Python para Galerkin 1D",
                                    "Exemplo de viga em Cantor & Hart (MECânica dos Materiais)"
                                  ],
                                  "tips": "Comece com n=2 funções para validar simplificação manualmente.",
                                  "learningObjective": "Aplicar benefício prático da ortogonalidade em métodos numéricos.",
                                  "commonMistakes": [
                                    "Não inverter corretamente G diagonal",
                                    "Aplicar simplificação sem verificar ortogonalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de viga cantilever (engenharia civil): use base φ1=1, φ2=x^2 em [0,L] com w=1. Calcule G = [[L,0],[0,L^3/3]]? Não, off-diagonal ≠0. Troque por funções Legendre orthogonalizadas: G diagonal, simplifique Galerkin para deslocamentos u(x) ≈ c1 P0 + c2 P1, resolvendo c_i = ∫ f P_i / ∫ P_i^2 diretamente.",
                              "finalVerifications": [
                                "Calcule G para base dada e identifique corretamente se diagonal.",
                                "Explique verbalmente por que G diagonal simplifica Galerkin.",
                                "Implemente código que verifica ortogonalidade e avisa se não.",
                                "Resolva mini-problema de EDP com base ortogonal vs não.",
                                "Discuta impacto em precisão e eficiência computacional.",
                                "Compare com orthogonalização de Gram-Schmidt manual."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de integrais para G (erro <1%).",
                                "Correta identificação de diagonalidade com justificativa.",
                                "Demonstração clara da simplificação em equações.",
                                "Uso apropriado de tolerâncias numéricas.",
                                "Explicação coerente de aplicações em engenharia civil.",
                                "Código funcional e comentado para automação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Ortogonalidade em expansões em série de Fourier para ondas/vibrações.",
                                "Computação: Álgebra linear (autovalores de G), programação numérica (SciPy).",
                                "Estatística: Produtos internos em regressão ortogonal (polinômios).",
                                "Engenharia Mecânica: Análise modal com modos ortogonais."
                              ],
                              "realWorldApplication": "Em simulações FEM para estruturas civis (ex: pontes), bases ortogonais via Gram reduzem tempo de solução de sistemas lineares de horas para minutos, melhorando iterações em otimização de projetos contra falhas por fadiga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Resolver sistemas com inversão da Gram",
                            "description": "Formar e resolver o sistema G c = b, onde b envolve resíduos ponderados, usando decomposição LU ou Cholesky para problemas de engenharia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e preparar funções base e pesos",
                                  "subSteps": [
                                    "Identifique o problema de valor inicial ou de contorno (ex: equação diferencial em viga ou fluxo).",
                                    "Escolha 2-4 funções base phi_i(x) que satisfaçam condições de contorno.",
                                    "Defina a função peso w(x) para ponderação dos resíduos (ex: w=1 para uniforme).",
                                    "Discretize o domínio em pontos de colocation ou Gauss para integrais numéricas.",
                                    "Defina o resíduo r = L(u_approx) - f, onde u_approx = sum c_k phi_k."
                                  ],
                                  "verification": "Documente o problema, liste funções phi_i e w(x), e confirme que phi_i satisfazem BCs.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software simbólico como SymPy ou MATLAB",
                                    "Referência de métodos numéricos"
                                  ],
                                  "tips": "Comece com funções polinomiais simples para testar.",
                                  "learningObjective": "Compreender o setup do método de resíduos ponderados com matriz de Gram.",
                                  "commonMistakes": [
                                    "Escolher funções que não satisfazem condições de contorno",
                                    "Ignorar normalização das funções base",
                                    "Usar pesos inadequados para o problema físico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Matriz de Gram G",
                                  "subSteps": [
                                    "Calcule G_ij = ∫ phi_i(x) phi_j(x) w(x) dx sobre o domínio.",
                                    "Use quadratura numérica (ex: trapézio ou Gauss) se integral analítico impossível.",
                                    "Implemente em código (Python/NumPy ou MATLAB) para matriz NxN.",
                                    "Verifique se G é simétrica e definida positiva (autovalores >0).",
                                    "Ajuste precisão da discretização até convergência."
                                  ],
                                  "verification": "G simétrica com todos autovalores positivos e cond(G) < 1e6.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "MATLAB ou Octave",
                                    "Tabela de pontos Gauss"
                                  ],
                                  "tips": "Use funções vetorizadas para eficiência computacional.",
                                  "learningObjective": "Dominar cálculo da Gram matrix em métodos ponderados.",
                                  "commonMistakes": [
                                    "Erro na discretização levando a G não simétrica",
                                    "Poucos pontos de quadratura causando imprecisão",
                                    "Confundir inner product com produto escalar sem peso"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o vetor b dos resíduos ponderados",
                                  "subSteps": [
                                    "Defina aproximação inicial u0 (ex: zero ou solução grosseira).",
                                    "Calcule resíduo r(x) = f(x) - L(u0(x)).",
                                    "Compute b_i = ∫ r(x) phi_i(x) w(x) dx para cada i.",
                                    "Implemente numericamente de forma consistente com G.",
                                    "Normalize b se necessário para escala."
                                  ],
                                  "verification": "b não nulo e consistente em magnitude com G.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Mesmo código de G",
                                    "Função f(x) e operador L definidos"
                                  ],
                                  "tips": "Reutilize a malha de quadratura de G para b.",
                                  "learningObjective": "Formar o lado direito do sistema ponderado corretamente.",
                                  "commonMistakes": [
                                    "Usar resíduo errado (ex: de u exata em vez de u0)",
                                    "Inverter ordem de phi_i em b_i",
                                    "Esquecer multiplicar por w(x)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o sistema G c = b com decomposição LU ou Cholesky",
                                  "subSteps": [
                                    "Verifique se G é definida positiva (Cholesky preferível para simetria).",
                                    "Execute decomposição LU: PA = LU, resolva Ly = Pb, Uc = y.",
                                    "Ou Cholesky: G = LL^T, resolva L y = b, L^T c = y.",
                                    "Implemente em SciPy.linalg.lu_factor ou cho_factor.",
                                    "Extraia coeficientes c e compute u_approx = sum c_k phi_k."
                                  ],
                                  "verification": "||G c - b|| < 1e-10 (resíduo do sistema).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python SciPy.linalg",
                                    "MATLAB lu() ou chol()",
                                    "Debugger para matrizes"
                                  ],
                                  "tips": "Use Cholesky para eficiência em problemas simétricos.",
                                  "learningObjective": "Aplicar solvers diretos para sistemas da Gram matrix.",
                                  "commonMistakes": [
                                    "Pivotação inadequada em LU causando instabilidade",
                                    "Confundir forward/back substitution",
                                    "Aplicar Cholesky em matriz não-PD"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar solução e interpretar resultados",
                                  "subSteps": [
                                    "Calcule resíduo global ∫ r^2 w dx e compare com inicial.",
                                    "Plote u_approx vs solução exata ou dados reais.",
                                    "Analise sensibilidade a mais funções base.",
                                    "Documente coeficientes c e tempo computacional.",
                                    "Discuta estabilidade numérica (cond(G))."
                                  ],
                                  "verification": "Redução de resíduo >90% e u_approx física plausível.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "Solução analítica de referência"
                                  ],
                                  "tips": "Sempre plote para insight visual.",
                                  "learningObjective": "Avaliar qualidade da aproximação em contexto de engenharia.",
                                  "commonMistakes": [
                                    "Aceitar solução sem checar resíduo",
                                    "Ignorar ill-conditioning de G",
                                    "Interpretar c sem contexto físico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga de Euler-Bernoulli em [0,L=1], resolva u''''=1 com u(0)=u'(0)=u(1)=u'(1)=0. Use phi1=x^2(1-x)^2, phi2=x^3(1-x), w=1. Discretize com 20 pontos Gauss. Compute G 2x2, b com r inicial de u0=0, resolva para c via Cholesky. Resultado: c≈[0.05, 0.1], u_approx próxima de 1/24 x^2 (1-x)^2.",
                              "finalVerifications": [
                                "Sistema G c = b resolvido com resíduo <1e-8.",
                                "Matriz G simétrica positiva definida.",
                                "Coeficientes c levam a u_approx satisfazendo BCs.",
                                "Redução significativa no resíduo ponderado.",
                                "Convergência ao adicionar mais phi_i.",
                                "Tempo computacional escalável para N=10."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de G e b (erro <1%).",
                                "Correta implementação de LU/Cholesky sem erros numéricos.",
                                "Interpretação física da solução u_approx.",
                                "Eficiência computacional (O(N^3) consciente).",
                                "Verificação completa de resíduos e estabilidade.",
                                "Código reproduzível e comentado.",
                                "Aplicação correta a problema de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Solvers lineares e quadratura.",
                                "Programação: NumPy/SciPy para computação científica.",
                                "Análise Estrutural: Aproximações em vigas e elementos finitos.",
                                "Estatística: Menos quadrados ponderados.",
                                "Física Computacional: Métodos de Galerkin/Collocation."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para aproximação numérica em análise de vigas não-lineares, ajuste de perfis hidráulicos via dados experimentais, ou solução aproximada de BVPs em fundações, onde decomposição rápida de Gram permite iterações em otimização estrutural com resíduos minimizados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Implementar em software numérico",
                            "description": "Codificar a construção e uso da matriz de Gram em MATLAB ou similar, testando em problemas de valor inicial como equações diferenciais em estruturas civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente MATLAB e definir o problema de valor inicial",
                                  "subSteps": [
                                    "Instalar ou abrir o MATLAB e verificar licenças para toolboxes numéricas como ODE solvers.",
                                    "Definir o problema de valor inicial (PVI), ex: equação diferencial y'' + p(x)y' + q(x)y = f(x) com condições iniciais y(a)=ya, y'(a)=ya'.",
                                    "Escolher funções de base (polinômios ou funções de splines) para o método de resíduos ponderados.",
                                    "Criar script MATLAB com variáveis para domínio [a,b], passos de malha e condições iniciais.",
                                    "Plotar o domínio e visualizar condições iniciais para inspeção visual."
                                  ],
                                  "verification": "Executar script inicial sem erros; visualizar plots confirmando setup correto.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "MATLAB instalado, documentação de ODEs, exemplos de PVIs em engenharia civil (viga cantilever).",
                                  "tips": "Use 'clear all; close all; clc' no início para ambiente limpo.",
                                  "learningObjective": "Configurar precisamente um PVI representativo de estruturas civis no MATLAB.",
                                  "commonMistakes": "Índices de malha errados (confundir 0-based vs 1-based); condições iniciais inconsistentes com o problema físico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de Gram para funções de base",
                                  "subSteps": [
                                    "Definir funções de base φ_i(x), ex: φ_i(x) = (x-a)^i para i=0 a n-1.",
                                    "Implementar produto interno <f,g> = ∫_a^b f(x)g(x) w(x) dx, com peso w(x)=1 ou adaptado.",
                                    "Usar quadratura numérica (quadgk ou trapz) para calcular cada entrada G_ij = <φ_i, φ_j>.",
                                    "Montar matriz G(n x n) em loop duplo ou vetorizado com meshgrid.",
                                    "Verificar simetria e positividez semi-definida da matriz com eig ou cond."
                                  ],
                                  "verification": "Matriz G é simétrica (G == G') e autovalores ≥0; imprimir G e stats.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Função quadgk no MATLAB, notas sobre produtos internos em métodos espectrais.",
                                  "tips": "Vetorize loops com bsxfun ou arrayfun para eficiência em n>10.",
                                  "learningObjective": "Codificar corretamente o produto interno e montar matriz de Gram numericamente.",
                                  "commonMistakes": "Escala errada no integral (domínio errado); não normalizar peso w(x)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método de resíduos ponderados usando matriz de Gram",
                                  "subSteps": [
                                    "Definir resíduo R(u_h) = L u_h - f, onde u_h = sum c_k φ_k.",
                                    "Projetar resíduos em funções de base: G c = b, com b_i = <φ_i, f / Lφ> aproximado.",
                                    "Resolver sistema linear G c = b com mldivide (\\) ou lu para precisão.",
                                    "Reconstruir solução aproximada u_h(x) em malha de pontos.",
                                    "Integrar tratamento de não-linearidades se PVI for não-linear (iterativo)."
                                  ],
                                  "verification": "Sistema resolve sem singularidade (cond(G)<1e12); plot u_h vs solução exata.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": "Solver linear MATLAB (mldivide), exemplo de PVI não-homogêneo em estruturas.",
                                  "tips": "Condicione G com chol se mal-condicionada; use sparse para n grande.",
                                  "learningObjective": "Aplicar matriz de Gram para resolver projeção em resíduos ponderados.",
                                  "commonMistakes": "Inverter ordem em b_i; ignorar condições iniciais na projeção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar em problema de engenharia civil e validar resultados",
                                  "subSteps": [
                                    "Escolher PVI real: ex: equação de Euler-Bernoulli para viga y'''' = q(x), y(0)=y'(0)=0, y''(L)=M, y'''(L)=V.",
                                    "Executar código com n=5-10 bases; comparar com ode45 ou solução analítica.",
                                    "Calcular erros L2 e máximo; plotar convergência vs n.",
                                    "Analisar estabilidade numérica variando malha.",
                                    "Documentar código com comentários e salvar como função reutilizável."
                                  ],
                                  "verification": "Erro <1e-4 para n=8; plots mostram convergência; código roda <5s.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Exemplos de EDPs em vigas (livros de engenharia estrutural), ode45 para benchmark.",
                                  "tips": "Use semilogy para plot de erros; teste com q(x)=constante primeiro.",
                                  "learningObjective": "Validar implementação em contexto civil com métricas quantitativas.",
                                  "commonMistakes": "Malha grosseira levando a oscilações (Gibbs); benchmark incorreto."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e estender para problemas mais complexos",
                                  "subSteps": [
                                    "Otimizar código: pré-alocar arrays, usar funções vetorizadas.",
                                    "Estender para BVP ou 2D (placas); adicionar pesos adaptativos.",
                                    "Implementar análise de sensibilidade (variação de parâmetros estruturais).",
                                    "Exportar resultados para relatório (figure save, tabela latex).",
                                    "Testar em cluster ou parallel pool para n>50."
                                  ],
                                  "verification": "Tempo reduzido >50%; extensão roda sem crashes em caso teste 2D.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Parallel Computing Toolbox, exemplos de otimização MATLAB.",
                                  "tips": "Profile com profile on para bottlenecks.",
                                  "learningObjective": "Tornar código robusto e escalável para aplicações reais.",
                                  "commonMistakes": "Não pré-alocar causando lentidão; ignorar limites de memória."
                                }
                              ],
                              "practicalExample": "Resolva y'' + y = 0 em [0, π] com y(0)=0, y(π)=0 usando 4 funções de base lineares. Construa G com trapz, resolva Gc=b onde b_i=∫ φ_i sin(x) dx, plote u_h vs sin(x). Erro L2 deve cair de 0.1 para 0.01 ao dobrar n.",
                              "finalVerifications": [
                                "Código executa sem erros para n=2-20.",
                                "Matriz G é simétrica e positiva semi-definida (todos autovalores ≥0).",
                                "Solução converge monotonicamente (erro diminui com n).",
                                "Resultados batem com ode45 dentro de 1e-6.",
                                "Tempo total <10min para simulação completa.",
                                "Plots mostram solução física coerente (sem oscilações anômalas)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro L2 <1e-5 para n=10.",
                                "Eficiência: Tempo de execução O(n^2) ou melhor.",
                                "Robustez: Funciona para diferentes PVIs civis sem ajustes.",
                                "Clareza: Código comentado, variáveis intuitivas.",
                                "Validação: Comparação quantitativa com analítico/numérico.",
                                "Escalabilidade: n até 50 sem crash."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura e solvers lineares.",
                                "Programação: Boas práticas em MATLAB (vetorização, profiling).",
                                "Engenharia Estrutural: Modelagem de vigas/placas via EDPs.",
                                "Física: Princípios de equilíbrio em estruturas dinâmicas.",
                                "Análise de Dados: Plots de convergência e erros."
                              ],
                              "realWorldApplication": "Simulação de deformações em vigas sob carga sísmica, otimizando projetos de pontes ou edifícios para reduzir custos e riscos, integrando com software FEM como ANSYS para validação em pré-projeto."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Condicionamento Numérico",
                    "description": "Análise do condicionamento de sistemas matriciais gerados por métodos aproximados para problemas de valor inicial e de contorno.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Problemas de Valor Inicial e de Contorno",
                        "description": "Compreensão dos problemas diferenciais de valor inicial (PVI) e de valor de contorno (PVC), incluindo sua formulação matemática e relevância na engenharia civil para modelagem de fenômenos como difusão e ondas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Formular Problemas de Valor Inicial",
                            "description": "Dado um problema diferencial ordinário ou parcial, formular corretamente as condições de valor inicial, identificando variáveis dependentes, independentes e condições iniciais para simulações em engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o Problema Diferencial",
                                  "subSteps": [
                                    "Leia atentamente a equação diferencial ordinária (EDO) ou parcial (EPD) fornecida.",
                                    "Identifique o ordem da equação (primeira, segunda, etc.).",
                                    "Determine se é EDO (uma variável independente) ou EPD (múltiplas).",
                                    "Anote os termos da equação, incluindo derivadas e funções.",
                                    "Classifique o problema como de valor inicial com base no contexto."
                                  ],
                                  "verification": "Confirme que a ordem e o tipo da equação foram anotados corretamente em um rascunho.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplos de EDOs/EPDs de engenharia civil"
                                  ],
                                  "tips": [
                                    "Comece pelo lado esquerdo da equação para mapear derivadas.",
                                    "Use diagramas para visualizar dependências."
                                  ],
                                  "learningObjective": "Compreender a estrutura matemática do problema diferencial.",
                                  "commonMistakes": [
                                    "Confundir EDO com EPD",
                                    "Ignorar coeficientes variáveis",
                                    "Não anotar a ordem corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Variáveis Dependentes e Independentes",
                                  "subSteps": [
                                    "Liste todas as variáveis na equação.",
                                    "Classifique a variável independente (ex: tempo t ou posição x).",
                                    "Identifique a variável dependente principal (ex: y(t) ou u(x,t)).",
                                    "Note derivadas parciais se for EPD (ex: ∂u/∂t, ∂²u/∂x²).",
                                    "Crie um mapeamento: 'y depende de t'."
                                  ],
                                  "verification": "Crie uma tabela com colunas 'Variável', 'Tipo (dep/indep)', 'Derivadas envolvidas' e revise.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Planilha ou tabela em software como Excel/Google Sheets",
                                    "Livro de EDOs para referência"
                                  ],
                                  "tips": [
                                    "Em engenharia civil, tempo 't' é comum como independente em dinâmicas.",
                                    "Desenhe setas de dependência para visualização."
                                  ],
                                  "learningObjective": "Distinguir precisamente variáveis em problemas diferenciais.",
                                  "commonMistakes": [
                                    "Confundir variável dependente com parâmetro constante",
                                    "Esquecer variáveis em EPDs multidimensionais",
                                    "Não considerar todas as derivadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar Condições Iniciais",
                                  "subSteps": [
                                    "Analise o contexto físico (ex: posição inicial, velocidade inicial em vibrações).",
                                    "Identifique valores dados no problema (ex: y(0) = 0, y'(0) = v0).",
                                    "Garanta que haja tantas condições quanto a ordem da equação.",
                                    "Especifique condições para todas variáveis dependentes se múltiplas.",
                                    "Verifique unidades consistentes (ex: metros, segundos)."
                                  ],
                                  "verification": "Escreva as condições iniciais separadamente e confira com o problema original.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Problemas de exemplo em engenharia civil",
                                    "Calculadora para unidades"
                                  ],
                                  "tips": [
                                    "Para estruturas, repouso inicial é y(0)=0, y'(0)=0.",
                                    "Ordene condições por ordem de derivada."
                                  ],
                                  "learningObjective": "Selecionar condições iniciais apropriadas ao contexto.",
                                  "commonMistakes": [
                                    "Número insuficiente de condições",
                                    "Condições em pontos errados (ex: t=1 ao invés de t=0)",
                                    "Ignorar velocidade inicial em problemas dinâmicos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular o Problema Completo de Valor Inicial",
                                  "subSteps": [
                                    "Escreva a equação diferencial.",
                                    "Adicione as condições iniciais abaixo dela.",
                                    "Inclua domínio (ex: t ≥ 0).",
                                    "Formate para simulação numérica (ex: compatível com MATLAB/Runge-Kutta).",
                                    "Teste consistência: derivadas nas condições fazem sentido."
                                  ],
                                  "verification": "Compare com um exemplo resolvido e simule um passo numérico simples.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Software de EDOs como MATLAB ou Python (SciPy)",
                                    "Templates de formulação"
                                  ],
                                  "tips": [
                                    "Use notação padrão: y'' + p y' + q y = f, y(0)=a, y'(0)=b.",
                                    "Prepare para métodos numéricos como Euler."
                                  ],
                                  "learningObjective": "Montar um problema de valor inicial pronto para simulação.",
                                  "commonMistakes": [
                                    "Esquecer domínio ou condições",
                                    "Notação inconsistente",
                                    "Não preparar para numérico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever sujeita a carga dinâmica: EDO y'' + ω² y = F(t), com condições iniciais y(0) = 0 (deslocamento inicial zero), y'(0) = 0 (velocidade inicial zero), onde y(t) é deslocamento (dependente), t é tempo (independente). Formule para simulação de vibração.",
                              "finalVerifications": [
                                "Equação diferencial está corretamente transcrita?",
                                "Variáveis dependentes e independentes identificadas com precisão?",
                                "Número de condições iniciais igual à ordem da equação?",
                                "Condições especificadas no ponto inicial correto (ex: t=0)?",
                                "Unidades e contexto físico consistentes?",
                                "Formato pronto para implementação numérica?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de variáveis (90% correto).",
                                "Correção e completude das condições iniciais.",
                                "Clareza na formulação escrita.",
                                "Consistência com contexto de engenharia civil.",
                                "Preparação para simulação (inclui domínio e notação numérica).",
                                "Ausência de erros comuns como condições insuficientes."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de estruturas e vibrações.",
                                "Programação: Implementação em Python/MATLAB para solvers numéricos.",
                                "Matemática Numérica: Métodos de Runge-Kutta e estabilidade.",
                                "Engenharia de Software: Validação de modelos computacionais."
                              ],
                              "realWorldApplication": "Em simulações de resposta sísmica de edifícios, formular condições iniciais (repouso antes do terremoto) permite prever deslocamentos e tensões via software como ANSYS, otimizando projetos contra colapsos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Formular Problemas de Valor de Contorno",
                            "description": "Especificar condições de contorno em problemas diferenciais parciais, diferenciando entre condições de Dirichlet, Neumann e Robin, com aplicações em problemas de engenharia civil como fluxo em barragens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Problemas de Valor de Contorno",
                                  "subSteps": [
                                    "Estude a definição de equações diferenciais parciais (PDEs) e problemas de valor inicial (IVPs) versus problemas de valor de contorno (BVPs).",
                                    "Identifique domínios espaciais (1D, 2D, 3D) e o papel das condições de contorno na especificação única da solução.",
                                    "Revise exemplos simples de BVPs, como a equação do calor em uma barra com extremidades fixas.",
                                    "Diferencie condições de contorno de condições iniciais em termos de tempo versus espaço.",
                                    "Pratique esboçando domínios geométricos comuns em engenharia civil, como perfis de barragens."
                                  ],
                                  "verification": "Escreva um parágrafo explicando a diferença entre IVP e BVP, com um diagrama de domínio.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de PDEs (ex: Strauss 'Partial Differential Equations'), videoaulas sobre BVPs, papel e lápis para diagramas"
                                  ],
                                  "tips": "Sempre visualize o domínio físico antes de matematizar.",
                                  "learningObjective": "Dominar os fundamentos teóricos de BVPs para contextualizar condições de contorno.",
                                  "commonMistakes": [
                                    "Confundir condições de contorno com iniciais",
                                    "Ignorar a geometria do domínio",
                                    "Assumir soluções sem condições completas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Condições de Dirichlet",
                                  "subSteps": [
                                    "Defina condição de Dirichlet: valor da função desconhecida especificado na fronteira.",
                                    "Estude exemplos matemáticos: u(x,y)=f na ∂Ω.",
                                    "Aplique em 1D: equação de Laplace em [0,1] com u(0)=0, u(1)=1.",
                                    "Discuta propriedades: bem-posedness e unicidade da solução.",
                                    "Pratique formulando para um problema de temperatura em uma parede de barragem."
                                  ],
                                  "verification": "Formule e resolva analiticamente um BVP de Dirichlet simples em 1D.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software simbólico como Mathematica ou Python SymPy",
                                    "Exercícios de PDEs",
                                    "Artigos sobre fluxo em barragens"
                                  ],
                                  "tips": "Use notação consistente: Ω para domínio, ∂Ω para fronteira.",
                                  "learningObjective": "Especificar corretamente condições de Dirichlet em problemas físicos.",
                                  "commonMistakes": [
                                    "Especificar derivadas em vez de valores",
                                    "Inconsistência nas unidades físicas",
                                    "Esquecer normalização da fronteira"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Condições de Neumann e Robin",
                                  "subSteps": [
                                    "Defina Neumann: derivada normal da solução especificada (fluxo). Ex: ∂u/∂n = g na ∂Ω.",
                                    "Defina Robin: combinação linear de u e ∂u/∂n, como convecção.",
                                    "Compare com Dirichlet: Neumann para isolantes, Robin para trocas de calor.",
                                    "Resolva exemplos: Neumann homogêneo em uma placa, Robin em tubulações.",
                                    "Analise compatibilidade: integral de g deve ser zero para Neumann puro."
                                  ],
                                  "verification": "Derive a condição de compatibilidade para um BVP de Neumann e aplique em um exemplo.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Notas sobre condições de contorno mistas",
                                    "Python/MATLAB para plotar soluções",
                                    "Referências de engenharia civil"
                                  ],
                                  "tips": "Lembre-se: vetor normal aponta para fora do domínio.",
                                  "learningObjective": "Diferenciar e formular Neumann e Robin com precisão matemática.",
                                  "commonMistakes": [
                                    "Confundir normal interna/externa",
                                    "Ignorar fator de convecção em Robin",
                                    "Violar condição de solvibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular Problemas Completos com Aplicações em Engenharia Civil",
                                  "subSteps": [
                                    "Integre condições em PDEs reais: Laplace para fluxo potencial em solos.",
                                    "Formule para barragem: Dirichlet na superfície livre (pressão conhecida), Neumann nas paredes (impermeável).",
                                    "Especifique domínio, PDE, condições iniciais/contorno e parâmetros físicos.",
                                    "Valide formulação: verifique dimensões, bem-posedness e relevância física.",
                                    "Simule numericamente uma formulação simples usando método de diferenças finitas."
                                  ],
                                  "verification": "Escreva a formulação completa de um BVP para fluxo em barragem e implemente uma simulação básica.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software FEniCS ou MATLAB PDE Toolbox",
                                    "Dados reais de barragens",
                                    "Papel para esboços"
                                  ],
                                  "tips": "Comece com problemas 1D para validar antes de 2D.",
                                  "learningObjective": "Criar formulações acionáveis para problemas de engenharia.",
                                  "commonMistakes": [
                                    "Condições incompatíveis",
                                    "Escala errada de parâmetros",
                                    "Ignorar anisotropia do meio"
                                  ]
                                }
                              ],
                              "practicalExample": "Formule o problema de fluxo estacionário em uma seção transversal de barragem: ∇²φ=0 em Ω (domínio 2D da barragem), φ= h na superfície livre (Dirichlet, h=altura da água), ∂φ/∂n=0 nas paredes e base (Neumann, impermeável), ∂φ/∂n = k(φ - φ_ext) na face de jusante (Robin, perda por evaporação).",
                              "finalVerifications": [
                                "Explique verbalmente as três condições de contorno com exemplos físicos.",
                                "Formule corretamente um BVP misto para um domínio dado.",
                                "Identifique erros em uma formulação incompleta fornecida.",
                                "Simule e plote uma solução numérica básica.",
                                "Discuta bem-posedness da sua formulação para barragem.",
                                "Compare soluções analíticas e numéricas em 1D."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e notação das condições (Dirichlet, Neumann, Robin).",
                                "Correta identificação do domínio e fronteiras relevantes.",
                                "Compatibilidade física e matemática da formulação.",
                                "Inclusão de parâmetros reais de engenharia civil.",
                                "Capacidade de validar e simular a formulação.",
                                "Clareza na documentação e explicação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Analogia com campos eletromagnéticos e térmicos.",
                                "Computação: Implementação em métodos numéricos (elementos finitos).",
                                "Engenharia Mecânica: Fluxo de fluidos incompressíveis.",
                                "Matemática Numérica: Análise de estabilidade e convergência.",
                                "Geotecnia: Permeabilidade em solos e rochas."
                              ],
                              "realWorldApplication": "Na engenharia civil, formulações de BVPs são essenciais para analisar vazamento em barragens (ex: simular fluxo sísmico em Itaipu), tensões em fundações e difusão de contaminantes em aquíferos, otimizando segurança e design com simulações FEM."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Identificar Discretizações Matriciais",
                            "description": "Reconhecer como PVI e PVC geram sistemas matriciais após discretização, preparando para análise de condicionamento em métodos numéricos aproximados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de PVI e PVC",
                                  "subSteps": [
                                    "Defina Problema de Valor Inicial (PVI) com exemplo de equação diferencial ordinária (EDO).",
                                    "Defina Problema de Valor de Contorno (PVC) com condições em extremos do domínio.",
                                    "Compare diferenças entre PVI e PVC em termos de condições e aplicações em engenharia civil.",
                                    "Identifique equações diferenciais parciais (EDPs) comuns em PVC, como equação de Poisson.",
                                    "Liste exemplos de PVC em estruturas civis, como equilíbrio de tensões."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre PVI e PVC com um exemplo cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre EDOs e EDPs",
                                    "Livro de métodos numéricos (ex: Burden & Faires)",
                                    "Caneta e papel para esboços"
                                  ],
                                  "tips": "Use diagramas temporais para PVI e espaciais para PVC para visualizar melhor.",
                                  "learningObjective": "Compreender as bases conceituais de PVI e PVC como pré-requisito para discretização.",
                                  "commonMistakes": [
                                    "Confundir condições iniciais de PVI com condições de contorno de PVC",
                                    "Ignorar o domínio espacial em PVC"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Métodos de Discretização Básicos",
                                  "subSteps": [
                                    "Estude o método das diferenças finitas para EDOs em PVI (ex: método de Euler).",
                                    "Aprenda discretização espacial para PVC (ex: diferenças finitas centrais para Laplace).",
                                    "Entenda a malha numérica: pontos de grade h e k para tempo/espaço.",
                                    "Derive a aproximação discreta para uma EDO simples: u' = f(u,t) → u_{n+1} = u_n + h f(u_n,t_n).",
                                    "Discuta convergência e estabilidade básica da discretização."
                                  ],
                                  "verification": "Aplique diferenças finitas a uma EDO simples e verifique o esquema discreto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (NumPy)",
                                    "Tabela de fórmulas de diferenças finitas",
                                    "Papel quadriculado para malha"
                                  ],
                                  "tips": "Comece com malhas uniformes para simplicidade antes de irregularidades.",
                                  "learningObjective": "Dominar técnicas básicas de discretização que transformam problemas contínuos em discretos.",
                                  "commonMistakes": [
                                    "Usar passos de tempo/espaço inadequados levando a instabilidade",
                                    "Esquecer aproximações de derivadas de segunda ordem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer Geração de Sistemas Matriciais",
                                  "subSteps": [
                                    "Para PVI: mostre como discretização temporal gera sistema linear implícito A u^{n+1} = b.",
                                    "Para PVC: derive matriz tridiagonal para equação de Laplace em 1D (A u = f).",
                                    "Identifique estrutura da matriz: diagonal dominante, simétrica para problemas elípticos.",
                                    "Escreva o sistema matricial geral Au = b após discretização de PVC.",
                                    "Analise dimensões da matriz baseada no número de pontos da malha."
                                  ],
                                  "verification": "Construa a matriz A para uma malha com 5 pontos e verifique simetria.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora matricial ou Python (SciPy)",
                                    "Exemplos impressos de malhas discretizadas",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Use stencil de diferenças finitas para visualizar vizinhanças locais.",
                                  "learningObjective": "Identificar como discretizações produzem sistemas matriciais lineares.",
                                  "commonMistakes": [
                                    "Não aplicar condições de contorno corretamente nas linhas da matriz",
                                    "Confundir matrizes de massa e rigidez em contextos FEM"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar Identificação em Exemplos",
                                  "subSteps": [
                                    "Resolva um PVI simples (ex: y' = -y, y(0)=1) e identifique o sistema matricial.",
                                    "Discretize um PVC (ex: -u''=f, u(0)=u(1)=0) e extraia a matriz tridiagonal.",
                                    "Compare sistemas de PVI e PVC: evolução temporal vs. estacionário.",
                                    "Prepare para condicionamento: note largura de banda da matriz.",
                                    "Teste com variação de malha e observe mudanças na matriz."
                                  ],
                                  "verification": "Identifique corretamente matriz e vetor direito em dois exemplos dados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Jupyter Notebook com códigos de discretização",
                                    "Problemas de exercício resolvidos",
                                    "Gráficos de malhas"
                                  ],
                                  "tips": "Implemente em código para validar manualmente.",
                                  "learningObjective": "Reconhecer padrões matriciais em discretizações reais de PVI/PVC.",
                                  "commonMistakes": [
                                    "Ignorar condições de contorno nas extremidades da matriz",
                                    "Não reconhecer simetria positiva definida"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o PVC -u''(x) = π² sin(πx) em [0,1] com u(0)=u(1)=0. Usando diferenças finitas com 4 intervalos (h=0.25), a matriz A é tridiagonal: [[2,-1,0,0],[-1,2,-1,0],[0,-1,2,-1],[0,0,-1,2]] / h², e b = [π² sin(π/8), π² sin(3π/8), π² sin(5π/8), π² sin(7π/8)]. Identifique A como simétrica e diagonal dominante.",
                              "finalVerifications": [
                                "Explicar como discretização de PVI gera sistemas evolutivos matriciais.",
                                "Construir matriz para PVC 1D com condições Dirichlet.",
                                "Identificar estrutura tridiagonal em diferenças finitas.",
                                "Diferenciar matrizes de PVI vs. PVC.",
                                "Relacionar tamanho da malha ao da matriz.",
                                "Reconhecer preparação para análise de condicionamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da matriz A (100% correto).",
                                "Correta aplicação de condições de contorno.",
                                "Identificação de propriedades matriciais (simetria, diagonal dominante).",
                                "Explicação clara da relação discretização → sistema linear.",
                                "Uso adequado de notação e malhas.",
                                "Capacidade de generalizar para EDPs 2D."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Computacional: Análise de erros e estabilidade.",
                                "Programação: Implementação em Python/MATLAB para gerar matrizes.",
                                "Física Aplicada: Modelagem de difusão e elastostática.",
                                "Engenharia de Software: Otimização de solvers matriciais.",
                                "Análise Numérica: Pré-condicionadores para condicionamento."
                              ],
                              "realWorldApplication": "Em engenharia civil, discretizações matriciais de PVCs modelam análise estática de vigas e placas (ex: método dos elementos finitos inicia com matrizes de rigidez), permitindo simulações de tensões em pontes e edifícios via software como ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Métodos Aproximados e Método dos Resíduos Ponderados",
                        "description": "Estudo do método dos resíduos ponderados (como Galerkin) para aproximação de soluções de PVI e PVC, gerando sistemas lineares Ax=b cujas propriedades matriciais afetam a estabilidade numérica.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Aplicar Método dos Resíduos Ponderados",
                            "description": "Implementar o método dos resíduos ponderados para discretizar um PVC simples, derivando a matriz de rigidez e vetor de carga em contextos de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formulação do Problema de Valor de Contorno (PVC)",
                                  "subSteps": [
                                    "Identifique a equação diferencial governante do PVC simples, como -d/dx (EA du/dx) = q(x) para uma barra axial.",
                                    "Defina as condições de contorno (ex: u(0)=0, EA du/dx(L)=P para carga concentrada).",
                                    "Especifique o domínio geométrico (ex: barra de comprimento L) e propriedades materiais (E, A constantes ou variáveis).",
                                    "Esboce o problema graficamente, marcando nós potenciais para discretização.",
                                    "Escreva a forma fraca/integral da equação usando integração por partes."
                                  ],
                                  "verification": "Verifique se a equação diferencial e condições de contorno estão corretamente transcritas e o esboço reflete o domínio.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis para esboços",
                                    "Livro-texto de MEF (ex: Bathe ou Zienkiewicz)",
                                    "Calculadora simbólica (ex: Mathematica ou SymPy)"
                                  ],
                                  "tips": "Sempre comece com problemas 1D simples para construir intuição; use notação consistente (u para deslocamento, ε para deformação).",
                                  "learningObjective": "Compreender e formular matematicamente um PVC simples em termos de equação diferencial e condições de contorno.",
                                  "commonMistakes": [
                                    "Confundir condições essenciais (Dirichlet) com naturais (Neumann)",
                                    "Esquecer integração por partes na forma fraca",
                                    "Assumir propriedades constantes sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Seleção de Funções de Aproximação e Peso",
                                  "subSteps": [
                                    "Escolha funções de aproximação polinomiais (ex: Lagrange lineares para 2 nós: N1=(1-ξ), N2=ξ).",
                                    "Defina funções de peso (ex: Galerkin: Wi = Ni; ou collocation para pontos específicos).",
                                    "Expresse a solução aproximada ũ(x) = Σ ui Ni(x).",
                                    "Calcule derivadas das funções de forma: dNi/dx.",
                                    "Verifique ortogonalidade ou propriedades das funções no domínio."
                                  ],
                                  "verification": "Liste as funções Ni e Wi explicitamente e compute ũ(x) para um caso teste com ui conhecidos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de álgebra simbólica (SymPy ou MATLAB Symbolic)",
                                    "Tabelas de funções de forma padrão de MEF"
                                  ],
                                  "tips": "Para PVC simples, use funções lineares para evitar singularidades; teste com ξ normalizado [-1,1].",
                                  "learningObjective": "Selecionar e expressar funções de aproximação e peso adequadas para minimizar resíduos.",
                                  "commonMistakes": [
                                    "Usar funções que não satisfazem condições essenciais automaticamente",
                                    "Confundir funções de peso com aproximação",
                                    "Erros em derivadas de funções lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montagem das Equações dos Resíduos Ponderados",
                                  "subSteps": [
                                    "Escreva o resíduo R = L(ũ) - q(x), onde L é o operador diferencial.",
                                    "Formule ∫ Wi R dΩ = 0 para cada i.",
                                    "Aplique integração por partes: ∫ Wi (d/dx (EA dũ/dx)) dx = [Wi EA dũ/dx] - ∫ (dWi/dx) EA (dũ/dx) dx.",
                                    "Substitua ũ por Σ uj Nj para obter forma matricial: Σj Kij uj = Fi.",
                                    "Identifique Kij = ∫ (dWi/dx) EA (dNj/dx) d x e Fi = ∫ Wi q dx + termos de contorno."
                                  ],
                                  "verification": "Derive explicitamente Kij e Fi para um elemento unitário e verifique simetria de K.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha Excel ou Python para integração numérica",
                                    "Referência: Notas de aula sobre MEF 1D"
                                  ],
                                  "tips": "Mantenha EA dentro da integral para generalidade; use coordenadas locais para elementos.",
                                  "learningObjective": "Derivar as equações integrais dos resíduos ponderados levando à forma matricial.",
                                  "commonMistakes": [
                                    "Esquecer termos de contorno naturais em Fi",
                                    "Sinais errados na integração por partes",
                                    "Não linearizar corretamente o operador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discretização, Montagem Global e Resolução",
                                  "subSteps": [
                                    "Divida o domínio em nelements (ex: 2 elementos para 3 nós).",
                                    "Compute [k]^e e {f}^e para cada elemento e monte [K] global por superposição.",
                                    "Aplique condições de contorno (ex: fixe u1=0 removendo linha/coluna).",
                                    "Resolva [K]{u} = {F} analiticamente ou numericamente.",
                                    "Compare com solução exata para validar."
                                  ],
                                  "verification": "Obtenha {u} e plote deslocamentos; erro <5% vs. analítico indica sucesso.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy para montagem e solve",
                                    "Gráficos via Matplotlib"
                                  ],
                                  "tips": "Numere nós consistentemente; use loop para múltiplos elementos para automação.",
                                  "learningObjective": "Discretizar o PVC, montar sistema global e extrair matriz de rigidez/vetor de carga.",
                                  "commonMistakes": [
                                    "Sobreposição incorreta de elementos compartilhando nós",
                                    "Não impor BCs essenciais corretamente",
                                    "Escala errada em unidades"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificação e Análise de Resultados",
                                  "subSteps": [
                                    "Calcule reações, deformações ε = du/dx e tensões σ = Eε.",
                                    "Avalie convergência refinando malha (h-refinement).",
                                    "Analise condicionamento de [K] (ex: cond([K]) ).",
                                    "Documente matriz [K] final e {F}.",
                                    "Discuta limitações do método (ex: para não-linearidades)."
                                  ],
                                  "verification": "Relatório com plots de u(x) exato vs. numérico e tabela de erros por nó.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python completo",
                                    "Ferramenta de plotagem"
                                  ],
                                  "tips": "Sempre normalize erros em norma L2; refine malha até convergência.",
                                  "learningObjective": "Validar a discretização e interpretar resultados em contexto estrutural.",
                                  "commonMistakes": [
                                    "Ignorar singularidade se todos nós livres",
                                    "Comparar com solução errada",
                                    "Não reportar condicionamento numérico"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma barra axial de L=1m, E=200GPa, A=0.01m², carga distribuída q(x)=1000x N/m, u(0)=0, F(L)=0: Discretize em 2 elementos, use Galerkin linear, derive [K] 2x2 global após BC, resolva {u} ≈ [0, 2.5e-6]m, verifique σ máx ≈ 50MPa.",
                              "finalVerifications": [
                                "Derivação correta da forma fraca com termos de contorno.",
                                "Matriz [K] simétrica positiva definida e vetor {F} consistente.",
                                "Solução numérica converge para exata com refinamento de malha.",
                                "Cálculo de deformações/tensões coerente com equilíbrio.",
                                "Código implementado reproduz resultados manualmente.",
                                "Relatório documenta passos e erros <1%."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática (30%)",
                                "Correção na derivação de [K] e {F} (25%)",
                                "Implementação computacional funcional (20%)",
                                "Análise de convergência e erros (15%)",
                                "Clareza no relatório e gráficos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais e métodos variationais.",
                                "Programação: Implementação numérica com Python/NumPy.",
                                "Física: Equilíbrio estático e lei de Hooke.",
                                "Engenharia de Software: Modularidade em código MEF.",
                                "Estatística: Análise de erro e condicionamento matricial."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado no pré-processador de softwares como ANSYS ou SAP2000 para análise de vigas/pilas sob cargas distribuídas (ex: pontes, edifícios), otimizando malhas para precisão vs. custo computacional em projetos reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Gerar Sistemas Matriciais Associados",
                            "description": "Construir matrizes esparsas a partir de funções de base no método dos resíduos ponderados, identificando simetria e estrutura para problemas de valor inicial e contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão dos Fundamentos do Método dos Resíduos Ponderados (MRP)",
                                  "subSteps": [
                                    "Estudar a formulação do problema de valor inicial ou contorno como uma equação diferencial.",
                                    "Compreender o conceito de resíduo e funções de ponderação no MRP.",
                                    "Analisar o caso especial de Galerkin, onde funções de ponderação coincidem com funções de base.",
                                    "Identificar condições para simetria nas matrizes resultantes.",
                                    "Revisar exemplos teóricos de problemas em uma dimensão."
                                  ],
                                  "verification": "Resumir em um parágrafo os princípios do MRP e listar 3 condições para simetria.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de métodos numéricos (ex: Burden & Faires)",
                                    "Notas de aula sobre EDEs",
                                    "Calculadora simbólica (Wolfram Alpha)"
                                  ],
                                  "tips": "Comece com problemas 1D simples para visualizar o resíduo.",
                                  "learningObjective": "Compreender os princípios teóricos do MRP e seu papel na geração de sistemas matriciais.",
                                  "commonMistakes": [
                                    "Confundir resíduos com erros de aproximação",
                                    "Ignorar a escolha das funções de ponderação",
                                    "Não reconhecer simetria inerente ao método Galerkin"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Seleção e Definição de Funções de Base Apropriadas",
                                  "subSteps": [
                                    "Definir o domínio do problema e discretizá-lo em elementos.",
                                    "Escolher funções de base polinomiais ou outras adequadas (ex: lineares, quadráticas).",
                                    "Garantir continuidade e condições de contorno nas funções de base.",
                                    "Calcular derivadas e integrais necessárias para as matrizes.",
                                    "Verificar ortogonalidade ou propriedades que levam a esparsidade."
                                  ],
                                  "verification": "Esboçar funções de base para um elemento de 2 nós e computar uma integral simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software simbólico (SymPy em Python)",
                                    "Referências sobre elementos finitos"
                                  ],
                                  "tips": "Use funções lineares para problemas iniciais para simplicidade.",
                                  "learningObjective": "Selecionar funções de base que garantam estabilidade e precisão na aproximação.",
                                  "commonMistakes": [
                                    "Escolher funções não satisfazendo condições de contorno",
                                    "Usar bases de alta ordem sem necessidade",
                                    "Esquecer normalização das funções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construção das Matrizes Elementares Esparsas",
                                  "subSteps": [
                                    "Derivar a matriz de rigidez integrando produtos de derivadas das funções de base.",
                                    "Construir a matriz de massa via integrais de produtos das funções de base.",
                                    "Incorporar termos de contorno e fontes no vetor de carga.",
                                    "Aplicar Gauss-Lobatto ou quadratura numérica para integrais exatas.",
                                    "Verificar a esparsidade contando não-zeros na matriz elementar."
                                  ],
                                  "verification": "Montar matriz de rigidez 2x2 para elemento linear e confirmar valores analíticos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python (NumPy/SciPy)",
                                    "Tabela de integrais Gaussianas",
                                    "Exemplos resolvidos de elementos finitos"
                                  ],
                                  "tips": "Implemente uma função para computar integrais automaticamente.",
                                  "learningObjective": "Construir matrizes elementares associadas ao MRP de forma precisa e eficiente.",
                                  "commonMistakes": [
                                    "Erros em limites de integração",
                                    "Confundir matriz de rigidez com massa",
                                    "Não usar quadratura para eficiência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montagem do Sistema Global e Análise de Propriedades",
                                  "subSteps": [
                                    "Montar matriz global somando contribuições elementares via conectividade.",
                                    "Aplicar condições de contorno para reduzir o sistema.",
                                    "Identificar e explorar simetria (ex: simétrica definida positiva).",
                                    "Analisar estrutura esparsa e perfil para solvers eficientes.",
                                    "Validar o sistema com uma solução conhecida simples."
                                  ],
                                  "verification": "Gerar sistema global para malha com 3 elementos e plotar esparsidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com Matplotlib e SciPy.sparse",
                                    "spy plot em MATLAB",
                                    "Malha de teste pré-definida"
                                  ],
                                  "tips": "Use índices locais-globais corretamente para evitar erros de montagem.",
                                  "learningObjective": "Montar e analisar sistemas matriciais completos, destacando esparsidade e simetria.",
                                  "commonMistakes": [
                                    "Índices errados na montagem",
                                    "Não impor contornos corretamente",
                                    "Ignorar esparsidade ao armazenar matriz densa"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de comprimento L=1m sob carga uniforme q=1N/m, discretize em 4 elementos com funções de base lineares. Construa matriz de rigidez K e vetor f, impondo u(0)=0 e resolvendo Ku=f para deslocamentos nodais.",
                              "finalVerifications": [
                                "Construir matriz elementar correta para função linear.",
                                "Montar sistema global sem erros de conectividade.",
                                "Identificar pelo menos 70% de zeros na matriz global.",
                                "Confirmar simetria da matriz de rigidez.",
                                "Resolver sistema e comparar com solução analítica.",
                                "Plotar diagrama de esparsidade corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas integrais e derivações matriciais (erro <1%).",
                                "Correta identificação de esparsidade e simetria.",
                                "Eficiência na montagem (tempo computacional razoável).",
                                "Aplicação correta de condições de contorno.",
                                "Validação com exemplo numérico.",
                                "Clareza na documentação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Propriedades de matrizes esparsas e simétricas.",
                                "Programação Numérica: Implementação em Python/MATLAB.",
                                "Física Aplicada: Mecânica dos sólidos e EDEs em engenharia.",
                                "Computação Científica: Solvers iterativos para sistemas grandes.",
                                "Estatística: Análise de erro na aproximação numérica."
                              ],
                              "realWorldApplication": "Na análise estrutural de pontes e edifícios, gera-se sistemas matriciais esparsos para simular deformações sob cargas dinâmicas, otimizando tempo de computação em softwares como ANSYS ou Abaqus para projetos seguros e econômicos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Avaliar Estabilidade Inicial da Discretização",
                            "description": "Verificar propriedades básicas de estabilidade nos sistemas gerados, como diagonal-dominância, antes de análise avançada de condicionamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Sistema de Equações Discretizadas",
                                  "subSteps": [
                                    "Selecione um problema de valor inicial ou de contorno relevante, como a equação de Poisson em 1D ou 2D.",
                                    "Aplique o método de discretização (ex: diferenças finitas ou elementos finitos no método dos resíduos ponderados).",
                                    "Monte a matriz de rigidez A e o vetor de carregamento b, incorporando condições de contorno.",
                                    "Implemente o sistema em software numérico para visualização.",
                                    "Valide a montagem comparando com casos analíticos conhecidos."
                                  ],
                                  "verification": "A matriz A é simétrica e reflete corretamente a geometria da malha; compare com stencil teórico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software como MATLAB, Python (NumPy/SciPy) ou Julia",
                                    "Documentação do método dos resíduos ponderados",
                                    "Exemplo de PDE simples (ex: -u'' = 1 em [0,1])"
                                  ],
                                  "tips": [
                                    "Use malhas uniformes inicialmente para facilitar cálculos manuais.",
                                    "Salve a matriz em formato esparso para eficiência.",
                                    "Visualize a malha com ferramentas como Matplotlib."
                                  ],
                                  "learningObjective": "Compreender a origem do sistema linear a partir da discretização PDE.",
                                  "commonMistakes": [
                                    "Ignorar condições de contorno essenciais.",
                                    "Erros de indexação nos nós da malha.",
                                    "Confundir matriz de massa com matriz de rigidez."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Diagonal Dominância nas Linhas da Matriz",
                                  "subSteps": [
                                    "Para cada linha i da matriz A, calcule a soma S_i = Σ_{j≠i} |A_{i,j}|.",
                                    "Compare |A_{i,i}| com S_i: verifique se |A_{i,i}| ≥ S_i (dominância fraca) ou > S_i (estrita).",
                                    "Identifique e liste linhas que violam a condição.",
                                    "Compute a razão de dominância r_i = |A_{i,i}| / S_i para quantificar.",
                                    "Gere um relatório ou mapa de calor das razões r_i."
                                  ],
                                  "verification": "Todas as linhas atendem à dominância ou são flagged com razões r_i < 1; valide com código automatizado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Códigos prontos para checagem de diagonal dominance (ex: função em SciPy)",
                                    "Matriz A do passo anterior",
                                    "Ferramentas de plotagem (Matplotlib/Seaborn)"
                                  ],
                                  "tips": [
                                    "Priorize linhas próximas às fronteiras, onde violações são comuns.",
                                    "Use tolerância numérica pequena (1e-10) para comparações.",
                                    "Automatize com loop vetorizado para grandes matrizes."
                                  ],
                                  "learningObjective": "Aplicar e interpretar a condição de diagonal dominância para estabilidade de solvers iterativos.",
                                  "commonMistakes": [
                                    "Usar valores absolutos incorretamente.",
                                    "Esquecer linhas com S_i = 0 (dominância trivial).",
                                    "Confundir dominância de linha com coluna."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Propriedades Complementares de Estabilidade",
                                  "subSteps": [
                                    "Verifique simetria: confirme A = A^T com norma ||A - A^T|| < ε.",
                                    "Teste positividade diagonal: todos A_{i,i} > 0.",
                                    "Calcule traço e determinantes parciais para indícios de definitude positiva.",
                                    "Estime norma de condicionamento básica cond(A) ≈ ||A|| * ||A^{-1}|| usando decomposição SVD.",
                                    "Analise autovalores mínimos para detecção de rigidez."
                                  ],
                                  "verification": "Relatório lista simetria (sim/não), diagonal positiva, e cond(A) < 10^6 como threshold inicial.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Bibliotecas de álgebra linear (SciPy.linalg, MATLAB eigs)",
                                    "Matriz A validada",
                                    "Referências teóricas sobre propriedades de matrizes M- (diagonal dominante)"
                                  ],
                                  "tips": [
                                    "Use eigsh para autovalores em matrizes grandes e esparsas.",
                                    "Combine com Gershgorin para bounds teóricos.",
                                    "Registre thresholds contextuais para engenharia civil (ex: cond < 10^4)."
                                  ],
                                  "learningObjective": "Identificar múltiplas indicadores de estabilidade além da diagonal dominância.",
                                  "commonMistakes": [
                                    "Assumir simetria sem verificação numérica.",
                                    "Interpretar cond alta como instável sem contexto.",
                                    "Negligenciar autovalores negativos em problemas elípticos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Planejar Análises Avançadas",
                                  "subSteps": [
                                    "Sintetize achados: classifique o sistema como estável inicial (bom), marginal ou instável.",
                                    "Correlacione violações com aspectos da discretização (ex: malha refinada, elementos distorcidos).",
                                    "Recomende ajustes: refinar malha, mudar pesos nos resíduos ou pré-condicionadores.",
                                    "Documente em relatório com gráficos e métricas.",
                                    "Teste sensibilidade variando parâmetros da discretização."
                                  ],
                                  "verification": "Relatório conclusivo com classificação e plano de ação; simule ajuste e reverifique.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Templates de relatório LaTeX/Markdown",
                                    "Gráficos gerados anteriormente",
                                    "Literatura sobre condicionamento em FEM"
                                  ],
                                  "tips": [
                                    "Use thresholds adaptativos baseados no problema físico.",
                                    "Integre com análise de erro a priori.",
                                    "Salve sessão para análises de condicionamento avançadas."
                                  ],
                                  "learningObjective": "Integrar verificações em workflow de análise numérica robusta.",
                                  "commonMistakes": [
                                    "Superestimar estabilidade por métricas isoladas.",
                                    "Ignorar contexto físico (ex: materiais heterogêneos).",
                                    "Não propor soluções acionáveis."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação -u'' + u = 1 em [0,1] com u(0)=u(1)=0, discretize com diferenças finitas centradas em malha h=0.2 (6 nós internos). A matriz tridiagonal é A = [2+ h^2/2, -1-h^2/2; ...]. Verifique: cada linha tem |a_ii| = 2.02 > |a_{i,i-1}| + |a_{i,i+1}| = 1.02, confirmando dominância estrita. Implemente em Python e plote razões r_i.",
                              "finalVerifications": [
                                "O aluno identifica corretamente todas as linhas diagonal-dominantes em uma matriz de 10x10.",
                                "Relatório inclui verificação de simetria e positividade diagonal com evidências numéricas.",
                                "Classificação de estabilidade inicial é justificada com métricas quantitativas.",
                                "Recomendações para melhorias são práticas e testadas em simulação simples.",
                                "Análise de sensibilidade demonstra impacto de h na dominância.",
                                "Todos os códigos rodam sem erros e reproduzem resultados esperados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na verificação de diagonal dominância (100% das linhas corretas: 30%).",
                                "Cobertura completa de propriedades complementares (simetria, cond: 25%).",
                                "Qualidade do relatório e visualizações (clareza, gráficos: 20%).",
                                "Interpretação e recomendações acionáveis (profundidade: 15%).",
                                "Eficiência computacional e automação de verificações (10%).",
                                "Correção de erros comuns identificados (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Propriedades espectrais e normas de matrizes.",
                                "Programação Numérica: Implementação eficiente de solvers esparsos (SciPy, PETSc).",
                                "Análise Numérica: Teoria de erro em métodos de elementos finitos.",
                                "Engenharia Computacional: Integração com CAD/FEM software (ANSYS, Abaqus).",
                                "Estatística Computacional: Análise de incerteza em condicionamento."
                              ],
                              "realWorldApplication": "Em simulações FEM para análise de estruturas civis como pontes ou barragens, avaliar estabilidade inicial da discretização garante convergência rápida de solvers iterativos como GMRES, evitando desperdício computacional em malhas mal condicionadas devido a elementos distorcidos ou materiais heterogêneos, otimizando projetos de engenharia."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Análise de Condicionamento Numérico",
                        "description": "Análise do condicionamento de matrizes oriundas de métodos aproximados, utilizando matriz de Gram, autovalores e autofunções para avaliar sensibilidade a perturbações em problemas de engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Calcular Número de Condicionamento",
                            "description": "Computar o número de condicionamento cond(A) = ||A|| * ||A^{-1}|| para matrizes de sistemas de PVI/PVC, interpretando valores altos como indicativos de ill-condicionamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Número de Condicionamento e Preparar a Matriz",
                                  "subSteps": [
                                    "Defina o número de condicionamento como cond(A) = ||A|| * ||A^{-1}||, onde ||.|| é uma norma matricial consistente.",
                                    "Escolha uma norma adequada (ex: norma 2, norma 1 ou norma infinito) com base no contexto do PVI/PVC.",
                                    "Selecione ou construa uma matriz A de um sistema de PVI/PVC, como a matriz de rigidez em análise estrutural.",
                                    "Verifique se A é invertível (det(A) ≠ 0) usando software ou cálculo manual.",
                                    "Documente o contexto da matriz (origem no problema de engenharia civil)."
                                  ],
                                  "verification": "Confirme que a definição está correta e a matriz A é quadrada e invertível, com norma escolhida justificada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz A de exemplo (ex: 2x2 ou 3x3 de PVC)",
                                    "Calculadora ou software como MATLAB/Octave/Python (NumPy)",
                                    "Folha de papel ou editor de texto"
                                  ],
                                  "tips": "Comece com matrizes pequenas (2x2) para prática manual antes de escalar.",
                                  "learningObjective": "Entender a definição matemática e preparar dados para cálculo preciso.",
                                  "commonMistakes": [
                                    "Escolher norma inconsistente",
                                    "Usar matriz singular sem verificar determinante",
                                    "Ignorar o contexto físico da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Norma da Matriz A (||A||)",
                                  "subSteps": [
                                    "Lembre a fórmula da norma escolhida (ex: ||A||_2 = maior valor singular via SVD).",
                                    "Para norma 1: max(coluna) de soma absoluta dos elementos.",
                                    "Para norma infinito: max(linha) de soma absoluta.",
                                    "Para norma 2: use decomposição SVD ou potência iterativa em software.",
                                    "Registre o valor exato ou aproximado de ||A|| com precisão de 4 casas decimais."
                                  ],
                                  "verification": "Compare o resultado com cálculo manual para matriz pequena ou documentação do software.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software numérico (MATLAB, Python NumPy/SciPy)",
                                    "Tabela de normas matriciais",
                                    "Matriz A impressa"
                                  ],
                                  "tips": "Use funções prontas como np.linalg.norm(A, 2) no Python para validação rápida.",
                                  "learningObjective": "Dominar o cálculo de normas matriciais comuns em contextos numéricos.",
                                  "commonMistakes": [
                                    "Confundir norma de vetor com norma de matriz",
                                    "Arredondamentos prematuros",
                                    "Não especificar qual norma foi usada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Inversa da Matriz A^{-1} e sua Norma (||A^{-1}||)",
                                  "subSteps": [
                                    "Compute A^{-1} usando eliminação gaussiana, fórmula adjunta (para 2x2) ou inv(A) em software.",
                                    "Verifique a inversa multiplicando A * A^{-1} ≈ I (identidade), com erro < 10^{-10}.",
                                    "Aplique a mesma norma usada em ||A|| para calcular ||A^{-1}||.",
                                    "Anote valores de elementos de A^{-1} para análise qualitativa.",
                                    "Discuta estabilidade numérica se elementos forem muito grandes."
                                  ],
                                  "verification": "A * A^{-1} deve resultar em matriz identidade dentro de tolerância numérica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software para inversão (np.linalg.inv)",
                                    "Método manual para matrizes pequenas",
                                    "Critério de parada para verificação"
                                  ],
                                  "tips": "Sempre valide a inversa antes de prosseguir para evitar propagação de erros.",
                                  "learningObjective": "Executar inversão matricial estável e calcular sua norma.",
                                  "commonMistakes": [
                                    "Inversão imprecisa em software sem verificação",
                                    "Usar norma diferente da anterior",
                                    "Ignorar ill-condicionamento durante inversão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar cond(A) e Interpretar o Resultado",
                                  "subSteps": [
                                    "Multiplique ||A|| * ||A^{-1}|| para obter cond(A).",
                                    "Classifique: cond(A) < 10^2 (bem condicionado), 10^2-10^8 (moderado), >10^8 (ill-condicionado).",
                                    "Relacione com sensibilidade: erro relativo em solução ≈ cond(A) * erro em entrada.",
                                    "Compare com cond(A)_2 = σ_max / σ_min (valores singulares).",
                                    "Documente implicações para o PVI/PVC na engenharia civil."
                                  ],
                                  "verification": "Recalcule cond(A) manualmente para confirmação e compare com limite teórico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Resultados dos passos anteriores",
                                    "Tabela de classificação de condicionamento",
                                    "Gráfico de valores singulares"
                                  ],
                                  "tips": "Use log10(cond(A)) para escalas grandes e facilitar interpretação.",
                                  "learningObjective": "Calcular e interpretar cond(A) quanto à estabilidade numérica.",
                                  "commonMistakes": [
                                    "Esquecer multiplicação das normas",
                                    "Interpretação errada de valores altos",
                                    "Não relacionar com erro amplificado"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Validar em Contexto de Engenharia Civil",
                                  "subSteps": [
                                    "Escolha um PVI/PVC real (ex: equação de difusão em barragem).",
                                    "Reexecute os cálculos para essa matriz e compare condicionamentos.",
                                    "Simule perturbação em A e observe impacto na solução x = A^{-1}b.",
                                    "Registre relatório com gráficos de erro vs. cond(A).",
                                    "Proponha melhorias (ex: pré-condicionadores)."
                                  ],
                                  "verification": "Erro na solução simulada deve escalar com cond(A).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplo de matriz de PVC (ex: FEM 1D)",
                                    "Software de plotagem (Matplotlib)",
                                    "Dados de benchmark"
                                  ],
                                  "tips": "Use matrizes de problemas conhecidos para validação cruzada.",
                                  "learningObjective": "Aplicar análise de condicionamento em cenários reais de engenharia.",
                                  "commonMistakes": [
                                    "Não simular perturbações realistas",
                                    "Ignorar contexto físico",
                                    "Concluir sem evidências numéricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez A = [[2, -1], [-1, 2]] de uma viga em PVC (equação de Euler-Bernoulli discretizada). Calcule cond(A)_∞: ||A||_∞ = 3, A^{-1} = (1/3)[[2,1],[1,2]], ||A^{-1}||_∞ = 1, cond(A) = 3 (bem condicionado). Perturbe A em 1% e verifique erro em solução <3%.",
                              "finalVerifications": [
                                "Cálculo de cond(A) correto para pelo menos duas matrizes de teste.",
                                "Interpretação precisa: cond(A)>10^6 indica risco de ill-condicionamento.",
                                "Validação A * A^{-1} ≈ I com erro <10^{-8}.",
                                "Simulação de perturbação mostra amplificação por cond(A).",
                                "Relatório relaciona resultado ao contexto de PVI/PVC.",
                                "Comparação com cond_2 via SVD coincide dentro de 1%."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos de normas e inversa (erro <0.1%).",
                                "Correta escolha e justificativa da norma matricial.",
                                "Interpretação qualitativa e quantitativa de cond(A).",
                                "Validações e verificações executadas em todos os steps.",
                                "Aplicação contextualizada em engenharia civil com simulação.",
                                "Relatório claro com exemplos e gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso de NumPy/SciPy para SVD e normas.",
                                "Álgebra Linear: Decomposições SVD e propriedades de normas.",
                                "Física Computacional: Estabilidade em simulações de PVI/PVC (ex: difusão em solos).",
                                "Estatística: Análise de sensibilidade e propagação de erros.",
                                "Engenharia de Software: Implementação de solvers robustos com pré-condicionamento."
                              ],
                              "realWorldApplication": "Em análise estrutural via Método dos Elementos Finitos (FEM) para barragens ou vigas, matrizes ill-condicionadas (cond(A)>10^{10}) causam erros catastróficos em simulações de deformação sob carga, levando a projetos inseguros; análise prévia permite refinar malhas ou usar solvers iterativos estáveis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Analisar Matriz de Gram",
                            "description": "Construir e analisar a matriz de Gram G = B^T B, onde B é a matriz de base, relacionando seus autovalores ao condicionamento global do sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais da Matriz de Gram",
                                  "subSteps": [
                                    "Defina o que é uma matriz de base B em um espaço vetorial.",
                                    "Explique o produto interno canônico e sua representação matricial B^T B.",
                                    "Discuta o papel da matriz de Gram G em medir comprimentos e ângulos entre vetores de base.",
                                    "Relacione G com a norma euclidiana e propriedades de ortogonalidade.",
                                    "Identifique quando uma base é ortonormal (G = I)."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e forneça um exemplo simples de base ortonormal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Notebook para anotações",
                                    "Software como MATLAB ou Python (NumPy)"
                                  ],
                                  "tips": "Visualize vetores em R^2 para intuitivamente entender ângulos via produto escalar.",
                                  "learningObjective": "Entender a definição e interpretação geométrica da matriz de Gram.",
                                  "commonMistakes": [
                                    "Confundir B^T B com B B^T",
                                    "Ignorar que G é simétrica e definida positiva para bases lineares independentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Matriz de Gram a Partir de uma Matriz de Base",
                                  "subSteps": [
                                    "Selecione uma matriz de base B de dimensão n x m (m vetores em R^n).",
                                    "Calcule o produto matricial B^T (transposta de B).",
                                    "Multiplique B^T por B para obter G (matriz m x m).",
                                    "Verifique se G é simétrica e seus elementos diagonais são quadrados das normas dos vetores.",
                                    "Teste com uma base simples em R^2."
                                  ],
                                  "verification": "Compute G manualmente para B = [[1,0],[0,1],[0,0]] e confirme G = I_2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora matricial ou Python (NumPy: np.dot(B.T, B))",
                                    "Papel quadriculado para cálculos manuais"
                                  ],
                                  "tips": "Use software para validar cálculos manuais e evitar erros aritméticos.",
                                  "learningObjective": "Dominar o cálculo explícito da matriz de Gram.",
                                  "commonMistakes": [
                                    "Erro na transposição (confundir linhas/colunas)",
                                    "Multiplicação incorreta de dimensões incompatíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Autovalores e Autovetores da Matriz de Gram",
                                  "subSteps": [
                                    "Resolva o problema de autovalores: det(G - λI) = 0 para encontrar autovalores λ_i > 0.",
                                    "Calcule autovetores associados normalizados.",
                                    "Ordene autovalores em ordem decrescente: λ_max e λ_min.",
                                    "Verifique a soma dos autovalores (traço de G) e produto (det G).",
                                    "Implemente numericamente em software."
                                  ],
                                  "verification": "Para uma G dada, liste λ1 ≥ λ2 ≥ ... ≥ λm e vetores correspondentes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB eig() ou Python (numpy.linalg.eig)",
                                    "Tabela de polinômios característicos para baixa dimensão"
                                  ],
                                  "tips": "Para matrizes 2x2, use fórmula analítica λ = (tr±sqrt(tr^2-4det))/2.",
                                  "learningObjective": "Computar e interpretar o espectro de autovalores de G.",
                                  "commonMistakes": [
                                    "Esquecer que λ_i ≥ 0 para G definida semi-definida positiva",
                                    "Não normalizar autovetores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Condicionamento Global Usando Autovalores",
                                  "subSteps": [
                                    "Defina o número de condicionamento da base κ(B) = sqrt(λ_max / λ_min).",
                                    "Interprete: κ ≈ 1 indica base quase ortonormal; κ >> 1 indica base mal-condicionada.",
                                    "Relacione com o condicionamento da matriz B: cond(B) ≈ κ(B).",
                                    "Discuta impactos numéricos em soluções de sistemas lineares.",
                                    "Compare com diferentes bases para o mesmo espaço."
                                  ],
                                  "verification": "Calcule κ para duas bases e classifique seu condicionamento (bom/ruim).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de bases mal-condicionadas (ex: vetores quase colineares)",
                                    "Gráficos de vetores via Matplotlib"
                                  ],
                                  "tips": "Gere bases aleatórias e observe variação de κ.",
                                  "learningObjective": "Relacionar autovalores de G ao condicionamento numérico global.",
                                  "commonMistakes": [
                                    "Usar λ_max / λ_min em vez de sqrt",
                                    "Ignorar que λ_min → 0 implica singularidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a base B em R^3 com colunas b1=[1,0,0]^T, b2=[1,1,0]^T, b3=[1,1,1]^T. Calcule G = B^T B = [[1,1,1],[1,2,2],[1,2,3]]. Autovalores ≈ [5.63, 0.30, 0.07]. Então κ(B) = sqrt(5.63/0.07) ≈ 8.99, indicando condicionamento moderado. Em análise estrutural, isso afeta precisão em FEM.",
                              "finalVerifications": [
                                "Construir corretamente G para base arbitrária.",
                                "Calcular autovalores com precisão numérica.",
                                "Computar κ(B) e interpretá-lo qualitativamente.",
                                "Identificar bases mal-condicionadas via λ_min pequeno.",
                                "Explicar relação com estabilidade numérica.",
                                "Aplicar a um exemplo real de engenharia."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matriciais (erro < 1e-6).",
                                "Interpretação correta de autovalores e condicionamento.",
                                "Uso adequado de software para validação.",
                                "Identificação de erros comuns em bases.",
                                "Clareza na explicação oral/escrita da análise.",
                                "Criatividade em exemplos personalizados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Autovalores e decomposição espectral.",
                                "Programação Numérica: Implementação em Python/MATLAB para FEM.",
                                "Engenharia Estrutural: Condicionamento em elementos finitos.",
                                "Análise Numérica: Estabilidade de algoritmos de linear algebra.",
                                "Geometria Computacional: Qualidade de malhas."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos na Engenharia Civil (ex: análise de estruturas via software como ANSYS), bases mal-condicionadas de funções de interpolação levam a erros de arredondamento em soluções de sistemas K u = f, onde K é rígida. Analisar G otimiza malhas para precisão e eficiência computacional."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Interpretar Autovalores e Autofunções",
                            "description": "Calcular espectro de autovalores de matrizes rígidas, identificando modos críticos de ill-condicionamento e propondo pré-condicionadores para solvers em MATLAB ou similares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão conceitual de autovalores e autofunções",
                                  "subSteps": [
                                    "Defina autovalor λ e autofunção v para uma matriz A: Av = λv.",
                                    "Explique o significado físico em matrizes rígidas: rigidez associada a modos de deformação.",
                                    "Discuta o espectro de autovalores: valores reais positivos para matrizes simétricas positivas definidas.",
                                    "Identifique o papel no condicionamento: razão entre maior e menor autovalor indica cond number.",
                                    "Revise propriedades: ortogonalidade de autofunções em matrizes simétricas."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos e resolva um exercício teórico simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang), notas de aula sobre rigidez estrutural"
                                  ],
                                  "tips": "Use analogias mecânicas: autovalores como frequências naturais de vibração.",
                                  "learningObjective": "Compreender os fundamentos matemáticos e físicos de autovalores em contextos estruturais.",
                                  "commonMistakes": [
                                    "Confundir autovalor com traço da matriz",
                                    "Ignorar simetria da matriz rígida",
                                    "Não relacionar com condicionamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Cálculo de autovalores e autofunções em MATLAB",
                                  "subSteps": [
                                    "Construa uma matriz de rigidez K exemplo (ex: truss 2D com 3 barras).",
                                    "Use comando eig(K) para obter [V, D] onde D é diagonal de autovalores.",
                                    "Plote o espectro: sort(D) e visualize razão cond(K) = max(D)/min(D).",
                                    "Verifique ortogonalidade: V'*V ≈ I.",
                                    "Teste com matriz ill-condicionada: escale elementos para min(D) pequeno."
                                  ],
                                  "verification": "Execute script MATLAB e confira se cond(K) > 10^6 indica ill-condicionamento.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Octave, script exemplo de matriz rígida"
                                  ],
                                  "tips": "Sempre normalize autofunções para interpretação física clara.",
                                  "learningObjective": "Dominar o cálculo numérico prático de espectros em ambientes computacionais.",
                                  "commonMistakes": [
                                    "Esquecer de ordenar autovalores",
                                    "Usar eig sem checar simetria",
                                    "Ignorar precisão numérica em matrizes grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretação do espectro e identificação de modos críticos",
                                  "subSteps": [
                                    "Ordene autovalores: λ1 ≤ λ2 ≤ ... ≤ λn; identifique modos rígidos (λ≈0).",
                                    "Analise autofunções: visualize deformações (plot modo v_i).",
                                    "Calcule número de condicionamento κ = λ_max / λ_min; classifique: κ<10 bom, >10^4 ruim.",
                                    "Identifique modos críticos: autovalores muito pequenos indicam direções fracas.",
                                    "Compare com análise manual para matrizes pequenas."
                                  ],
                                  "verification": "Explique em relatório por que um modo com λ_min é crítico para estabilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB com meshgrid para plots de deformação",
                                    "Exemplos de estruturas civis"
                                  ],
                                  "tips": "Foquem em modos de baixa frequência: eles dominam respostas dinâmicas.",
                                  "learningObjective": "Interpretar resultados numéricos em termos de comportamento estrutural.",
                                  "commonMistakes": [
                                    "Interpretar λ_max como instável (é o mais rígido)",
                                    "Não visualizar autofunções",
                                    "Confundir modos rígidos com zeros numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Proposta e implementação de pré-condicionadores",
                                  "subSteps": [
                                    "Escolha pré-condicionador: diagonal (inv(diag(K))), ou incomplete Cholesky.",
                                    "Implemente M = ichol(K) ou M = diag(1./sqrt(diag(K))).",
                                    "Teste solver: resolva Kx=b com pcg(K,b,M) vs backslash.",
                                    "Compare iterações e resíduos: redução em cond efetivo.",
                                    "Avalie impacto: novo espectro de M^{-1/2}KM^{-1/2} mais agrupado."
                                  ],
                                  "verification": "Demonstre redução de 50% nas iterações do solver com pré-condicionador.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Optimization Toolbox para pcg",
                                    "Sistema Kx=b de carga estrutural"
                                  ],
                                  "tips": "Comece com diagonal simples; evolua para ILU se necessário.",
                                  "learningObjective": "Aplicar técnicas de condicionamento para melhorar solvers iterativos.",
                                  "commonMistakes": [
                                    "Não verificar simetria positiva para Cholesky",
                                    "Escolher M singular",
                                    "Ignorar custo computacional de M"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma treliça 2D com 4 nós e barras de rigidez variada, calcule eig(K): λ_min=1e-6 indica modo quase-rígido devido a barra frouxa. Visualize v_min mostrando translação; aplique pré-condicionador diagonal reduzindo cond de 1e9 para 1e4, acelerando pcg em 80%.",
                              "finalVerifications": [
                                "Calcula corretamente eig(K) e ordena espectro.",
                                "Identifica modos com λ < 1e-3 como críticos.",
                                "Propõe pré-condicionador adequado e testa redução de cond.",
                                "Visualiza e interpreta autofunções fisicamente.",
                                "Resolve sistema ill-condicionado com solver condicionado.",
                                "Relata trade-offs entre precisão e custo computacional."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erro <1e-10).",
                                "Correta interpretação física dos modos.",
                                "Efetividade do pré-condicionador (redução κ >50%).",
                                "Clareza em visualizações e relatórios.",
                                "Uso eficiente de comandos MATLAB.",
                                "Identificação de pelo menos 2 erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração e análise modal.",
                                "Programação: Algoritmos numéricos em MATLAB/Python (NumPy).",
                                "Estatística: Análise de componentes principais (PCA via SVD).",
                                "Engenharia Mecânica: Estabilidade de estruturas dinâmicas.",
                                "Matemática Aplicada: Teoria espectral e decomposição."
                              ],
                              "realWorldApplication": "Na análise de pontes ou edifícios altos, interpretar autovalores da matriz de rigidez revela modos de flutter ou colapso (ex: Tacoma Narrows); pré-condicionadores aceleram simulações FEM em software como ANSYS, permitindo otimizações em tempo real para projetos sustentáveis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.3.4",
                            "name": "Mitigar Ill-Condicionamento",
                            "description": "Aplicar técnicas como escalonamento ou escolha de bases ortogonais para melhorar o condicionamento em simulações numéricas de problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Diagnosticar o Ill-Condicionamento na Matriz do Problema",
                                  "subSteps": [
                                    "Calcule o número de condicionamento (cond(A)) da matriz de rigidez ou similar usando normas como 2-norma.",
                                    "Identifique elementos com magnitudes muito discrepantes (ex: ordens de 10^6 vs 10^-3).",
                                    "Analise autovalores para detectar singularidades próximas a zero.",
                                    "Execute simulações de teste com ruído numérico para observar amplificação de erros.",
                                    "Registre o valor inicial de cond(A) e compare com thresholds aceitáveis (<10^12 para double precision)."
                                  ],
                                  "verification": "Confirme se cond(A) > 10^10 e erros relativos > 10^-6 em soluções teste.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB/Python (NumPy/SciPy), matriz de exemplo de problema de engenharia civil (ex: FEM de viga).",
                                  "tips": "Use svd() para decomposição em valores singulares eficiente.",
                                  "learningObjective": "Compreender e quantificar o impacto do ill-condicionamento em simulações.",
                                  "commonMistakes": "Ignorar overflow/underflow ao calcular cond(A); usar norma errada (ex: inf-norm em vez de 2-norm)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Técnicas de Escalonamento",
                                  "subSteps": [
                                    "Normalize colunas/linhas da matriz dividindo por normas (ex: escalonamento diagonal D onde D_ii = max| A_ij |).",
                                    "Aplique escalonamento às variáveis do problema (ex: coordenadas normalizadas por comprimento característico).",
                                    "Reescreva o sistema Ax=b como (D^{-1}AD^{-1}) (D x) = D^{-1} b.",
                                    "Resolva o sistema escalonado e descalone a solução.",
                                    "Teste com diferentes esquemas (row, column, equilibrado)."
                                  ],
                                  "verification": "Verifique se cond(nova matriz) < cond(original) por fator >10x.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python/MATLAB para escalonamento, solver linear (lu_factor ou mldivide).",
                                  "tips": "Prefira escalonamento equilibrado para matrices não simétricas.",
                                  "learningObjective": "Dominar escalonamento para reduzir sensibilidades numéricas.",
                                  "commonMistakes": "Esquecer de escalonar vetor b; aplicar apenas em uma direção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Bases Ortonormais ou Transformações Orthogonais",
                                  "subSteps": [
                                    "Aplique decomposição QR ou SVD para obter bases ortogonais Q.",
                                    "Projete o problema na base ortonormal: substitua A por Q^T A Q.",
                                    "Use Gram-Schmidt ou Householder para ortogonalizar vetores base manualmente se necessário.",
                                    "Integre na simulação FEM alterando funções de forma ou coordenadas.",
                                    "Compare condicionamento da matriz transformada."
                                  ],
                                  "verification": "Confirme ortogonalidade (|Q^T Q - I| < 1e-12) e redução de cond(A).",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Bibliotecas qr() ou svd() em SciPy/MATLAB, exemplo de malha FEM.",
                                  "tips": "SVD é mais robusto para matrices rank-deficient.",
                                  "learningObjective": "Aplicar transformações ortogonais para estabilizar sistemas lineares.",
                                  "commonMistakes": "Perda de simetria em matrices simétricas; não preservar estrutura esparsa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Integrar a Mitigação na Simulação Completa",
                                  "subSteps": [
                                    "Execute simulação full com técnicas aplicadas e compare erros com baseline.",
                                    "Monitore iterações de solvers iterativos (ex: GMRES) para convergência mais rápida.",
                                    "Sensibilize parâmetros para robustez (ex: variação de malha).",
                                    "Documente pipeline completo em script reutilizável.",
                                    "Otimize para performance mantendo condicionamento bom."
                                  ],
                                  "verification": "Solução final com erro relativo <1e-8 e tempo de solve reduzido.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Simulador FEM (ex: FEniCS ou código custom), dados de benchmark.",
                                  "tips": "Combine escalonamento + QR para ganhos sinérgicos.",
                                  "learningObjective": "Integrar mitigações em fluxos de simulação reais de engenharia.",
                                  "commonMistakes": "Não testar em problemas grandes/esparsos; ignorar custos computacionais."
                                }
                              ],
                              "practicalExample": "Em análise FEM de uma ponte estaiada, a matriz de rigidez global tem cond=1e15 devido a cabos longos vs elementos curtos. Aplique escalonamento por comprimentos e QR nos modos de vibração, reduzindo cond para 1e8 e permitindo convergência em 20 iterações vs falha anterior.",
                              "finalVerifications": [
                                "Número de condicionamento reduzido abaixo de 10^10.",
                                "Erro relativo na solução < 10^-8 comparado a referência analítica.",
                                "Solver converge em <50 iterações para problemas grandes.",
                                "Nenhuma amplificação de ruído numérico observada.",
                                "Pipeline roda em <10% tempo extra.",
                                "Robustez mantida sob perturbações de 1% nos dados de entrada."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Redução efetiva de erros numéricos (métrica: ||x - x_ref|| / ||x_ref||).",
                                "Eficiência: Tempo de computação e iterações do solver.",
                                "Robustez: Performance sob variações de malha/parâmetros.",
                                "Correção técnica: Escalonamento/ortogonalização implementados sem bugs.",
                                "Documentação: Código comentado com explicações das técnicas.",
                                "Escalabilidade: Funciona para matrices >1000x1000 esparsas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposições QR/SVD e normas matriciais.",
                                "Programação Numérica: Implementação eficiente em Python/MATLAB.",
                                "Mecânica dos Sólidos: Modelagem FEM em estruturas civis.",
                                "Estatística: Análise de erros e sensibilidade.",
                                "Otimização: Integração com solvers iterativos."
                              ],
                              "realWorldApplication": "Em projetos de edifícios altos ou barragens, mitiga instabilidades numéricas em FEM, evitando erros catastróficos em predições de deslocamentos e tensões, garantindo segurança e conformidade com normas como Eurocode."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Condicionamento de Matrizes e Matriz de Gram",
                "description": "Análise do condicionamento numérico de matrizes e aplicação da matriz de Gram em processos ortogonais.",
                "totalSkills": 44,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Número de Condição de Matrizes",
                    "description": "Medida quantitativa da sensibilidade de uma matriz à perturbações numéricas, definida como o produto das normas da matriz e sua inversa.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Definição e Interpretação do Número de Condição",
                        "description": "Compreensão fundamental do número de condição como medida quantitativa da sensibilidade de uma matriz a perturbações numéricas, definido como o produto das normas da matriz A e de sua inversa A^{-1}, ou κ(A) = ||A|| · ||A^{-1}||.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Identificar a definição formal do número de condição",
                            "description": "Reconhecer e reproduzir a fórmula κ(A) = ||A|| · ||A^{-1}|| para qualquer norma de matriz compatível, explicando seu significado em termos de amplificação de erros relativos na solução de sistemas lineares Ax = b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender normas de matrizes",
                                  "subSteps": [
                                    "Estudar a definição de norma de matriz compatível com norma vetorial.",
                                    "Revisar exemplos comuns: norma 1 (coluna máxima), norma infinito (linha máxima) e norma 2 (espectral).",
                                    "Explorar propriedades chave: positividade, homogeneidade e submultiplicatividade (||AB|| ≤ ||A|| ||B||).",
                                    "Praticar cálculo de normas para matrizes 2x2.",
                                    "Entender por que normas são usadas em análise numérica."
                                  ],
                                  "verification": "Listar e calcular corretamente pelo menos duas normas para uma matriz exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Calculadora ou Python/NumPy"
                                  ],
                                  "tips": "Sempre verifique a compatibilidade da norma com a norma vetorial para evitar erros.",
                                  "learningObjective": "Dominar conceitos fundamentais de normas de matrizes e suas propriedades.",
                                  "commonMistakes": [
                                    "Confundir norma de matriz com norma de vetor.",
                                    "Ignorar a submultiplicatividade em estimativas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a matriz inversa e sua norma",
                                  "subSteps": [
                                    "Recordar que A^{-1} existe se det(A) ≠ 0 e satisfaz A A^{-1} = I.",
                                    "Calcular a inversa para matrizes pequenas usando fórmula adjunta ou Gauss-Jordan.",
                                    "Entender que ||A^{-1}|| mede a 'ampliação' causada pela inversão.",
                                    "Comparar ||A|| e ||A^{-1}|| em exemplos onde A é bem ou mal condicionada.",
                                    "Discutir singularidade: se A não invertível, κ indefinido."
                                  ],
                                  "verification": "Computar A^{-1} e suas normas para uma matriz 2x2 dada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB ou Octave",
                                    "Folha de exercícios de inversas"
                                  ],
                                  "tips": "Use decomposição LU para inversas numéricas estáveis em matrizes maiores.",
                                  "learningObjective": "Relacionar a norma da inversa com a sensibilidade da matriz.",
                                  "commonMistakes": [
                                    "Calcular inversa incorretamente para matrizes singulares.",
                                    "Esquecer de normalizar normas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a definição formal do número de condição",
                                  "subSteps": [
                                    "Derivar κ(A) = ||A|| · ||A^{-1}|| para norma compatível.",
                                    "Verificar que κ(A) ≥ 1 para qualquer A invertível.",
                                    "Provar propriedades: κ(αA) = κ(A), κ(AB) ≤ κ(A)κ(B).",
                                    "Calcular κ(A) para matrizes identidade (κ=1) e mal condicionadas.",
                                    "Explorar dependência da escolha da norma."
                                  ],
                                  "verification": "Escrever e justificar a fórmula κ(A), calculando para dois exemplos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Notas de análise numérica",
                                    "Python com NumPy.linalg.norm e inv"
                                  ],
                                  "tips": "Escolha norma 2 para interpretação geométrica (maiores autovalores).",
                                  "learningObjective": "Identificar e reproduzir precisamente a definição formal de κ(A).",
                                  "commonMistakes": [
                                    "Omitir a multiplicação das normas.",
                                    "Aplicar a singular matrices."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o significado em amplificação de erros",
                                  "subSteps": [
                                    "Analisar sistema Ax = b com perturbação δb: ||δx||/||x|| ≤ κ(A) ||δb||/||b||.",
                                    "Estender para erros em A: perturbações relativas amplificadas por κ(A).",
                                    "Explicar que κ(A) ≈ 1 indica bom condicionamento; alto κ indica ill-conditioning.",
                                    "Simular numericamente com ruído para visualizar amplificação.",
                                    "Discutir implicações em precisão de soluções computacionais."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito como κ amplifica erros relativos em Ax=b.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código Python para simulação de erros",
                                    "Artigo sobre condicionamento"
                                  ],
                                  "tips": "Teste com ε-machine para ver limites de precisão flutuante.",
                                  "learningObjective": "Compreender o impacto de κ(A) na estabilidade numérica de sistemas lineares.",
                                  "commonMistakes": [
                                    "Confundir condicionamento com rank.",
                                    "Ignorar erros relativos vs absolutos."
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[2, 1], [1, 1]], calcule ||A||_2 ≈ 2.618, A^{-1} = [[1, -1], [-1, 2]], ||A^{-1}||_2 ≈ 2.618, assim κ(A) ≈ 6.828. Perturbe b = [3, 2] com δb = [0.001, 0], resolva e observe amplificação relativa em x.",
                              "finalVerifications": [
                                "Reproduzir κ(A) = ||A|| · ||A^{-1}|| corretamente.",
                                "Calcular κ para matriz 2x2 com norma especificada.",
                                "Explicar amplificação de erros relativos em Ax=b.",
                                "Identificar que κ ≥ 1 e =1 iff A é escalar múltiplo de ortogonal.",
                                "Simular exemplo numérico com perturbação.",
                                "Discutir independência de norma (aproximações similares)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula e notação matemática.",
                                "Correta interpretação em termos de erros relativos.",
                                "Cálculos numéricos exatos ou com erro <1%.",
                                "Uso apropriado de normas compatíveis.",
                                "Explicação clara de propriedades e limites.",
                                "Aplicação contextual em engenharia."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: normas e decomposições.",
                                "Análise Numérica: estabilidade e erros de arredondamento.",
                                "Engenharia Computacional: elementos finitos.",
                                "Programação Científica: bibliotecas NumPy/SciPy.",
                                "Física Aplicada: modelagem de estruturas dinâmicas."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao resolver sistemas lineares em análise de estruturas via método dos elementos finitos (ex: rigidez de vigas), um alto κ(A) indica sensibilidade a imprecisões de medição ou discretização, podendo causar falhas em previsões de deformações ou colapsos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Interpretar o impacto da sensibilidade numérica",
                            "description": "Analisar como um κ(A) próximo de 1 indica boa condicionamento (baixa sensibilidade a perturbações) e valores altos (ex.: >10^6) indicam ill-condicionamento, relacionando com estabilidade em soluções computacionais de problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de sensibilidade numérica e o número de condição κ(A)",
                                  "subSteps": [
                                    "Defina sensibilidade numérica como a medida de como pequenas perturbações nos dados de entrada afetam a saída do problema.",
                                    "Explique que o número de condição κ(A) = ||A|| * ||A⁻¹|| quantifica essa sensibilidade para sistemas lineares Ax = b.",
                                    "Discuta que κ(A) é adimensional e sempre ≥1 para matrizes invertíveis.",
                                    "Relacione com normas matriciais comuns (ex.: norma 2 ou infinito).",
                                    "Estude exemplos simples de matrizes identidade (κ=1) vs. diagonais desbalanceadas."
                                  ],
                                  "verification": "Resuma em 3 frases o que é κ(A) e por que ele mede sensibilidade; confira com referência padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Calculadora científica",
                                    "Referência: Livro de Álgebra Numérica (ex.: Burden & Faires)"
                                  ],
                                  "tips": "Use normas consistentes ao calcular κ(A) para evitar confusões; visualize graficamente perturbações.",
                                  "learningObjective": "Entender a definição e o papel fundamental do número de condição na análise de estabilidade numérica.",
                                  "commonMistakes": [
                                    "Confundir κ(A) com o determinante det(A)",
                                    "Ignorar que κ(A) ≥1",
                                    "Usar normas diferentes para ||A|| e ||A⁻¹||"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar κ(A) próximo de 1 como bom condicionamento",
                                  "subSteps": [
                                    "Calcule κ(A) para matrizes bem condicionadas (ex.: identidade ou ortogonais).",
                                    "Simule perturbações pequenas (ε ≈ 10^{-10}) em b ou A e observe o erro relativo na solução x.",
                                    "Verifique que erro na saída ≈ ε * κ(A), que é pequeno quando κ≈1.",
                                    "Discuta estabilidade: soluções computacionais são confiáveis.",
                                    "Compare com precisão de máquina (machine epsilon)."
                                  ],
                                  "verification": "Introduza perturbação de 10^{-8} em um sistema com κ=1.2 e confirme que erro relativo <10^{-7}.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (NumPy)",
                                    "Matrizes de exemplo bem condicionadas"
                                  ],
                                  "tips": "Use função cond() no MATLAB para verificação rápida; foque em erros relativos.",
                                  "learningObjective": "Reconhecer que κ baixo implica baixa sensibilidade e alta confiabilidade computacional.",
                                  "commonMistakes": [
                                    "Subestimar impacto de precisão finita da máquina",
                                    "Confundir erro absoluto com relativo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar valores altos de κ(A) (>10^6) como ill-condicionamento",
                                  "subSteps": [
                                    "Gere matrizes ill-condicionadas (ex.: Hilbert ou Vandermonde).",
                                    "Calcule κ(A) e simule perturbações: observe amplificação de erros (até κ vezes maior).",
                                    "Analise que soluções tornam-se instáveis, com x sensível a ruídos.",
                                    "Discuta limiares práticos: κ>10^6 é crítico em computação de dupla precisão.",
                                    "Explore decomposição SVD para entender autovalores pequenos."
                                  ],
                                  "verification": "Para matriz com κ=10^8, perturbe b por 10^{-10} e meça erro em x >10^{-2}.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Matrizes Hilbert pré-definidas"
                                  ],
                                  "tips": "Evite calcular A⁻¹ diretamente para grandes matrizes; use cond() ou svdvals().",
                                  "learningObjective": "Identificar ill-condicionamento e seus efeitos amplificadores de erros numéricos.",
                                  "commonMistakes": [
                                    "Achar que κ alto sempre significa singular",
                                    "Ignorar que ill-condicionado não é necessariamente singular"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar sensibilidade com estabilidade em problemas de engenharia civil",
                                  "subSteps": [
                                    "Aplique a matrizes de rigidez (K) em análise estrutural (ex.: treliça ou viga).",
                                    "Simule montagem de K e compute κ(K); introduza perturbações em cargas ou geometria.",
                                    "Avalie impacto em deslocamentos u = K^{-1}F: instabilidade leva a erros em tensões.",
                                    "Discuta remédios: pré-condicionadores, refinamento ou reformulação do modelo.",
                                    "Compare com normas de engenharia (ex.: tolerâncias em projetos ASCE)."
                                  ],
                                  "verification": "Em um modelo de viga, com κ(K)>10^7, demonstre variação >5% em deslocamentos com ruído pequeno.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software FEA como ANSYS ou código Python customizado",
                                    "Modelos estruturais simples"
                                  ],
                                  "tips": "Comece com estruturas 2D simples; normalize unidades para evitar escalas erradas.",
                                  "learningObjective": "Aplicar interpretação de κ(A) à estabilidade de soluções computacionais em engenharia civil.",
                                  "commonMistakes": [
                                    "Desconsiderar escalonamento de unidades em matrizes físicas",
                                    "Confundir condicionamento com convergência iterativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma treliça plana de 3 barras, monte a matriz de rigidez global K (6x6). Calcule κ(K)≈1.5x10^5. Perturbe as coordenadas nodais por 10^{-6}m e observe que deslocamentos variam até 10% devido à amplificação por κ, demonstrando risco em simulações de colapso estrutural.",
                              "finalVerifications": [
                                "Explicar corretamente que κ≈1 significa baixa sensibilidade a perturbações.",
                                "Demonstrar com exemplo numérico que κ>10^6 amplifica erros além da precisão de máquina.",
                                "Relacionar ill-condicionamento a instabilidade em solvers lineares de FEA.",
                                "Propor pelo menos uma estratégia para mitigar alto κ em matrizes de engenharia.",
                                "Calcular κ para uma matriz dada e interpretar seu impacto qualitativamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e cálculo de κ(A) (30%)",
                                "Correta interpretação de valores baixos vs. altos de κ (25%)",
                                "Análise de simulações com perturbações e erros relativos (20%)",
                                "Aplicação contextual a problemas de engenharia civil (15%)",
                                "Identificação de erros comuns e dicas práticas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposições SVD e normas matriciais.",
                                "Programação Numérica: Tratamento de erros e precisão flutuante.",
                                "Análise Estrutural: Matrizes de rigidez e estabilidade de elementos finitos.",
                                "Física Computacional: Modelagem de sistemas dinâmicos sensíveis."
                              ],
                              "realWorldApplication": "Na análise de pontes ou edifícios via Método dos Elementos Finitos, matrizes de rigidez ill-condicionadas (devido a elementos alongados ou malha irregular) podem propagar erros numéricos em predições de tensões, levando a projetos inseguros ou superdimensionados; engenheiros usam κ para validar modelos antes de decisões críticas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Relacionar com autovalores",
                            "description": "Entender que para normas espectrais, κ(A) = |λ_max| / |λ_min|, onde λ são autovalores, e aplicar isso para diagnosticar condicionamento em matrizes simétricas positivas definidas comuns em análise estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de autovalores e norma espectral",
                                  "subSteps": [
                                    "Defina autovalor λ e autovetor v de uma matriz A tal que Av = λv.",
                                    "Explique que a norma espectral ||A||_2 é o maior valor absoluto dos autovalores: ||A||_2 = max_i |λ_i|.",
                                    "Discuta como autovalores determinam propriedades espectrais de A.",
                                    "Identifique que para matrizes simétricas, autovalores são reais.",
                                    "Calcule autovalores de uma matriz 2x2 simples para prática."
                                  ],
                                  "verification": "Resuma as definições em um parágrafo e calcule autovalores de uma matriz exemplo corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Calculadora ou Python/NumPy",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Sempre verifique o polinômio característico det(A - λI) = 0 para matrizes pequenas.",
                                  "learningObjective": "Compreender as definições básicas de autovalores e norma espectral.",
                                  "commonMistakes": "Confundir norma espectral com norma de Frobenius ou 1-norma."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a fórmula do número de condição κ(A) para norma espectral",
                                  "subSteps": [
                                    "Lembre que o número de condição κ(A) = ||A|| ||A^{-1}||.",
                                    "Mostre que para norma espectral, κ(A) = |λ_max| / |λ_min|, onde λ_max e λ_min são os autovalores de maior e menor módulo.",
                                    "Derive brevemente por que ||A^{-1}||_2 = 1 / min |λ_i|.",
                                    "Explique o significado: κ(A) próximo de 1 indica bom condicionamento.",
                                    "Compare com outras normas para contextualizar."
                                  ],
                                  "verification": "Escreva a prova da fórmula κ(A) = |λ_max| / |λ_min| e dê um exemplo numérico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de métodos numéricos",
                                    "Software MATLAB ou Jupyter Notebook"
                                  ],
                                  "tips": "Foque em matrizes normais (simétricas) onde isso se aplica diretamente.",
                                  "learningObjective": "Dominar a relação exata entre κ(A) e autovalores na norma espectral.",
                                  "commonMistakes": "Esquecer que λ_min é o menor em módulo, não valor absoluto zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar propriedades de matrizes simétricas positivas definidas (SPD)",
                                  "subSteps": [
                                    "Defina matriz SPD: simétrica com autovalores positivos.",
                                    "Liste propriedades: A^{-1} também SPD, decomposição espectral A = QΛQ^T.",
                                    "Calcule κ(A) para uma SPD exemplo, confirmando λ > 0.",
                                    "Discuta implicações para estabilidade numérica em equações lineares Ax = b.",
                                    "Verifique se uma matriz dada é SPD via autovalores."
                                  ],
                                  "verification": "Classifique uma matriz 3x3 como SPD e compute seu κ(A).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy para eigvals",
                                    "Exemplos de matrizes de rigidez"
                                  ],
                                  "tips": "Use np.linalg.eig para computar autovalores numéricos.",
                                  "learningObjective": "Aplicar a relação κ(A) especificamente a matrizes SPD.",
                                  "commonMistakes": "Assumir todos autovalores positivos sem verificação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o conceito para diagnosticar condicionamento em análise estrutural",
                                  "subSteps": [
                                    "Identifique matrizes SPD comuns: matriz de rigidez K em elementos finitos.",
                                    "Para uma K mal condicionada (λ_max >> λ_min), explique riscos de erro numérico.",
                                    "Compute κ(K) para uma malha de viga ou treliça simples.",
                                    "Interprete: κ > 10^6 indica problemas em solvers iterativos.",
                                    "Sugira remédios: pré-condicionadores ou refinamento de malha."
                                  ],
                                  "verification": "Analise uma matriz de rigidez exemplo e diagnostique seu condicionamento.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software FEniCS ou MATLAB para matrizes de elementos finitos",
                                    "Exemplo de estrutura simples"
                                  ],
                                  "tips": "Comece com estruturas 1D para simplicidade antes de 2D/3D.",
                                  "learningObjective": "Diagnosticar condicionamento prático em contextos de engenharia civil.",
                                  "commonMistakes": "Ignorar que modos rígidos podem causar λ_min ≈ 0."
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez K de uma viga com 2 graus de liberdade: K = [[2k, -k], [-k, k]], onde k=1. Autovalores: λ1=0 (modo rígido), λ2=3k. Mas para SPD ancorada: ajuste para [[2k, -k], [-k, 2k]], λ_min≈0.585k, λ_max≈2.414k, κ(K)≈4.12. Diagnóstico: bem condicionado para simulações.",
                              "finalVerifications": [
                                "Calcular corretamente λ_max e λ_min de uma SPD.",
                                "Computar κ(A) = |λ_max| / |λ_min| com precisão.",
                                "Interpretar κ(A) > 10^10 como mal condicionado.",
                                "Verificar se matriz de rigidez é SPD.",
                                "Diagnosticar riscos em análise estrutural.",
                                "Aplicar em exemplo real de viga ou treliça."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de autovalores (erro < 1%).",
                                "Explicação clara da derivação de κ(A).",
                                "Correta identificação de SPD via autovalores positivos.",
                                "Interpretação adequada do valor de κ em contextos numéricos.",
                                "Aplicação prática a matrizes de engenharia civil.",
                                "Uso correto de software para verificação."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição espectral.",
                                "Métodos Numéricos: Estabilidade de solvers lineares.",
                                "Física: Modos de vibração em estruturas.",
                                "Engenharia Computacional: Elementos Finitos."
                              ],
                              "realWorldApplication": "Na análise estrutural por elementos finitos, diagnosticar o condicionamento da matriz de rigidez K para prever erros em solvers como CG, evitando falhas em simulações de pontes ou edifícios sob cargas dinâmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Normas de Matrizes Utilizadas no Cálculo",
                        "description": "Estudo das normas de matrizes mais comuns (1-norma, ∞-norma, norma de Frobenius e norma espectral) e sua aplicação no produto para obter o número de condição.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Calcular normas de matrizes básicas",
                            "description": "Computar ||A||_1 (coluna máxima), ||A||_∞ (linha máxima), ||A||_F (raiz soma quadrados elementos) e ||A||_2 (valor singular máximo) para matrizes 2x2 e 3x3, usando definições matemáticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as definições matemáticas das normas de matrizes básicas",
                                  "subSteps": [
                                    "Estude a definição da norma 1: ||A||_1 = máximo da soma dos valores absolutos dos elementos de cada coluna.",
                                    "Estude a definição da norma infinito: ||A||_∞ = máximo da soma dos valores absolutos dos elementos de cada linha.",
                                    "Estude a norma de Frobenius: ||A||_F = √(∑_{i,j} |a_ij|^2), soma dos quadrados de todos os elementos elevada à raiz quadrada.",
                                    "Estude a norma 2 (espectral): ||A||_2 = maior valor singular de A, obtido via decomposição SVD ou para matrizes simétricas como o módulo do maior autovalor de A^T A.",
                                    "Memorize fórmulas e pratique identificação visual em matrizes 2x2."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito cada definição com um exemplo simples de matriz 2x2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Tabela de referência de normas de matrizes"
                                  ],
                                  "tips": "Use diagramas para visualizar somas por linha/coluna; comece com matrizes com elementos positivos para simplificar.",
                                  "learningObjective": "Compreender precisamente as definições matemáticas das quatro normas para matrizes pequenas.",
                                  "commonMistakes": [
                                    "Confundir norma 1 (colunas) com norma ∞ (linhas)",
                                    "Esquecer raiz quadrada na norma Frobenius",
                                    "Ignorar valores absolutos nos elementos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular normas 1 e infinito para matrizes 2x2 e 3x3",
                                  "subSteps": [
                                    "Selecione uma matriz 2x2 exemplo, como A = [[3, -1], [2, 4]].",
                                    "Calcule ||A||_1: some absolutos por coluna e pegue o máximo.",
                                    "Calcule ||A||_∞: some absolutos por linha e pegue o máximo.",
                                    "Repita para uma matriz 3x3, anotando somas intermediárias.",
                                    "Verifique cálculos trocando linhas/colunas intencionalmente para testar compreensão."
                                  ],
                                  "verification": "Mostre cálculos passo a passo para duas matrizes diferentes, com resultados corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Sempre use valores absolutos |a_ij|; organize somas em tabela para clareza.",
                                  "learningObjective": "Executar cálculos precisos das normas 1 e ∞ manualmente.",
                                  "commonMistakes": [
                                    "Não usar módulo nos negativos",
                                    "Somar errado o máximo entre somas",
                                    "Confundir orientação da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a norma de Frobenius para matrizes 2x2 e 3x3",
                                  "subSteps": [
                                    "Para a mesma matriz 2x2, liste todos os elementos e calcule |a_ij|^2.",
                                    "Some os quadrados e aplique a raiz quadrada para ||A||_F.",
                                    "Repita para matriz 3x3, usando fórmula ∑∑ |a_ij|^2.",
                                    "Compare com normas 1 e ∞ para notar diferenças.",
                                    "Pratique com matriz nula ou identidade para casos triviais."
                                  ],
                                  "verification": "Calcule ||A||_F para três matrizes e confira com calculadora ou software.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora com raiz quadrada",
                                    "Planilha Excel ou Python (opcional)"
                                  ],
                                  "tips": "Calcule soma de quadrados primeiro, depois raiz; para precisão, use decimais.",
                                  "learningObjective": "Dominar o cálculo da norma Frobenius como uma 'norma euclidiana' da matriz.",
                                  "commonMistakes": [
                                    "Esquecer a raiz quadrada",
                                    "Somar elementos ao invés de quadrados",
                                    "Erro em potências de negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a norma 2 (espectral) para matrizes 2x2 e 3x3 simples",
                                  "subSteps": [
                                    "Para matriz 2x2 simétrica, calcule autovalores de A^T A (ou A se simétrica).",
                                    "Use fórmula para 2x2: ||A||_2 = √(maior autovalor de A^T A).",
                                    "Para 3x3, introduza SVD conceitual ou use software para valores singulares.",
                                    "Calcule manualmente para A = [[1,0],[0,2]] (diagonal fácil).",
                                    "Integre com normas anteriores em um relatório comparativo."
                                  ],
                                  "verification": "Forneça ||A||_2 correto para duas matrizes, mostrando passos ou output de software.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software como MATLAB/Octave ou Python NumPy/SciPy",
                                    "Papel para autovalores"
                                  ],
                                  "tips": "Comece com matrizes diagonais onde ||A||_2 = max|diag|; valide com np.linalg.norm(A, 2).",
                                  "learningObjective": "Aplicar conceitos de valores singulares para norma espectral em contextos computacionais.",
                                  "commonMistakes": [
                                    "Confundir com autovalores de A ao invés de A^T A",
                                    "Não pegar módulo do maior",
                                    "Ignorar SVD para não-simétricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada a matriz de rigidez em uma estrutura 2x2 A = [[4, -2], [-2, 4]], calcule: ||A||_1 = 6, ||A||_∞ = 6, ||A||_F = √(4² + (-2)² + (-2)² + 4²) = √(40) ≈ 6.32, ||A||_2 ≈ 6 (maior valor singular). Use para avaliar condicionamento em simulações de engenharia civil.",
                              "finalVerifications": [
                                "Calcule todas as normas corretamente para uma matriz 3x3 aleatória.",
                                "Explique diferenças entre normas em termos de vetores/linhas/colunas.",
                                "Valide resultados com software (ex: np.linalg.norm).",
                                "Compare normas para matriz identidade vs. mal-condicionada.",
                                "Resolva problema: qual norma é maior para A com elementos grandes em uma linha?",
                                "Demonstre cálculo manual sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos (erro < 0.01).",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Eficiência nos passos (tempo dentro do estimado).",
                                "Correta identificação de erros comuns evitados.",
                                "Integração com contexto de engenharia (condicionamento).",
                                "Uso adequado de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Autovalores e SVD.",
                                "Cálculo Numérico: Erros de arredondamento em normas.",
                                "Engenharia Civil: Análise de estabilidade estrutural via matrizes de rigidez.",
                                "Programação: Implementação em Python/MATLAB para normas.",
                                "Física: Normas em vetores de forças e deslocamentos."
                              ],
                              "realWorldApplication": "Em engenharia civil computacional, normas de matrizes avaliam o condicionamento de sistemas lineares de equações em simulações de estruturas (ex: método dos elementos finitos), prevendo sensibilidade a erros numéricos e garantindo precisão em projetos de pontes e edifícios."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Determinar norma da inversa de uma matriz",
                            "description": "Calcular ||A^{-1}|| após encontrar a inversa analítica ou numérica, e computar κ(A) para normas específicas, verificando propriedades como κ(αA) = κ(A) para escalar α ≠ 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular a inversa da matriz A analiticamente ou numericamente",
                                  "subSteps": [
                                    "Selecione uma matriz A quadrada invertível (ex: 2x2 ou 3x3) e compute seu determinante para confirmar invertibilidade.",
                                    "Use a fórmula da inversa via adjunta: A^{-1} = (1/det(A)) * adj(A), calculando cofatores e transposição.",
                                    "Alternativamente, aplique eliminação de Gauss-Jordan para obter a inversa.",
                                    "Para métodos numéricos, utilize software como Python (numpy.linalg.inv) ou MATLAB (inv(A)).",
                                    "Verifique a inversa multiplicando A * A^{-1} = I (matriz identidade)."
                                  ],
                                  "verification": "Confirme que A * A^{-1} resulta na matriz identidade com tolerância numérica < 10^{-10}.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para cálculo manual",
                                    "Software: Python com NumPy ou MATLAB/Octave"
                                  ],
                                  "tips": "Comece com matrizes 2x2 para prática; use precisão dupla em software para evitar erros de arredondamento.",
                                  "learningObjective": "Dominar métodos analíticos e numéricos para inversão de matrizes.",
                                  "commonMistakes": [
                                    "Dividir incorretamente pela determinante zero",
                                    "Erros na transposição da adjunta",
                                    "Ignorar verificação de identidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e calcular a norma da matriz A e da inversa A^{-1}",
                                  "subSteps": [
                                    "Escolha uma norma matricial compatível (ex: norma 1, norma infinita, norma de Frobenius ou norma espectral).",
                                    "Para norma infinita (máxima soma de linhas absolutas): compute max_i Σ_j |a_{ij}| para A e para A^{-1}.",
                                    "Para norma de Frobenius: √(Σ Σ |a_{ij}|^2); use funções built-in como norm(A, 'fro') no MATLAB.",
                                    "Calcule ||A|| e ||A^{-1}|| separadamente, registrando valores exatos ou aproximados.",
                                    "Compare com normas vetoriais subjacentes para validação."
                                  ],
                                  "verification": "Os valores das normas devem coincidir entre cálculo manual e software (diferença < 0.01).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de normas matriciais",
                                    "Software com funções norm()"
                                  ],
                                  "tips": "Norma infinita é simples para mão; Frobenius para generalidade; evite norma 2 sem SVD pronto.",
                                  "learningObjective": "Aplicar definições de normas matriciais induzidas e não-induzidas.",
                                  "commonMistakes": [
                                    "Confundir norma de linha com coluna",
                                    "Esquecer valores absolutos",
                                    "Usar norma errada para contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o número de condição κ(A) = ||A|| * ||A^{-1}||",
                                  "subSteps": [
                                    "Multiplique os valores obtidos: κ(A) = ||A||_p * ||A^{-1}||_p para norma p escolhida.",
                                    "Interprete o valor: κ(A) ≈ 1 indica boa condição; >10^6 sugere ill-condicionada.",
                                    "Repita para diferentes normas e compare (ex: κ_1 vs κ_∞).",
                                    "Documente κ(A) e discuta implicações para estabilidade numérica.",
                                    "Teste sensibilidade: perturbe A ligeiramente e re-compute κ."
                                  ],
                                  "verification": "κ(A) deve ser simétrico em normas compatíveis e consistente com software (cond(A)).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software para cond() ou norm()"
                                  ],
                                  "tips": "Sempre use a mesma norma para ||A|| e ||A^{-1}||; log10(κ) para escala.",
                                  "learningObjective": "Entender o número de condição como medida de sensibilidade.",
                                  "commonMistakes": [
                                    "Usar normas diferentes",
                                    "Interpretar κ=1 como sempre bem-condicionado",
                                    "Ignorar escala da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar propriedades do número de condição, como κ(αA) = κ(A)",
                                  "subSteps": [
                                    "Escolha escalar α ≠ 0 (ex: α=2) e compute B = αA.",
                                    "Encontre B^{-1} = (1/α) A^{-1}.",
                                    "Calcule ||B|| = |α| ||A|| e ||B^{-1}|| = (1/|α|) ||A^{-1}||, logo κ(B) = κ(A).",
                                    "Verifique numericamente para confirmar independência de escalar.",
                                    "Explore propriedades adicionais: κ(A^T) = κ(A), κ(U A) onde U unitária."
                                  ],
                                  "verification": "κ(αA) = κ(A) com tolerância < 10^{-8} numericamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmos do Step 1-3"
                                  ],
                                  "tips": "Prove analiticamente primeiro: ||αA|| * ||(αA)^{-1}|| = |α| ||A|| * (1/|α|) ||A^{-1}|| = κ(A).",
                                  "learningObjective": "Reconhecer invariâncias do número de condição.",
                                  "commonMistakes": [
                                    "Esquecer fator 1/|α| na inversa",
                                    "Assumir para α=0",
                                    "Não verificar numericamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[2, 1], [1, 1]] (det(A)=1), A^{-1} = [[1, -1], [-1, 2]]. Norma ∞: ||A||_∞ = 3, ||A^{-1}||_∞ = 3, κ(A)=9. Para B=2A = [[4,2],[2,2]], B^{-1}=0.5 A^{-1}, ||B||_∞=6, ||B^{-1}||_∞=1.5, κ(B)=9=κ(A).",
                              "finalVerifications": [
                                "Cálculo correto de A^{-1} com verificação identidade.",
                                "Normas ||A|| e ||A^{-1}|| precisas para norma escolhida.",
                                "κ(A) computado corretamente como produto.",
                                "Propriedade κ(αA)=κ(A) demonstrada analítica e numericamente.",
                                "Interpretação qualitativa de condicionamento fornecida.",
                                "Consistência entre métodos manual e software."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erros < 10^{-6}.",
                                "Correta aplicação de definições de normas e inversa.",
                                "Demonstração clara de propriedades invariantes.",
                                "Uso adequado de software com validação manual.",
                                "Interpretação contextual em engenharia (ex: estabilidade).",
                                "Documentação completa com passos lógicos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/MATLAB para análise computacional.",
                                "Análise Numérica: Estudo de erros de arredondamento e estabilidade.",
                                "Física/Engenharia Mecânica: Condicionamento em matrizes de rigidez para elementos finitos.",
                                "Estatística: Normas em regressão linear multivariada.",
                                "Otimização: Uso de κ(A) em métodos iterativos para sistemas lineares."
                              ],
                              "realWorldApplication": "Na engenharia civil, matrizes de rigidez em análise de estruturas por elementos finitos podem ser mal-condicionadas (alto κ(A)), amplificando erros em soluções de deslocamentos sob cargas; calcular ||A^{-1}|| e κ(A) ajuda a escalonar matrizes ou usar pré-condicionadores para precisão em simulações de pontes ou edifícios."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Comparar diferentes normas no condicionamento",
                            "description": "Avaliar como diferentes normas afetam o valor de κ(A), usando exemplos de matrizes mal-condicionadas como a matriz de Hilbert, e discutir escolha de norma em contextos computacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições e fórmulas das normas de matrizes comuns",
                                  "subSteps": [
                                    "Estudar a norma 1 (norma de colunas máximas): ||A||_1 = max_j Σ_i |a_ij|",
                                    "Estudar a norma infinito (norma de linhas máximas): ||A||_∞ = max_i Σ_j |a_ij|",
                                    "Estudar a norma 2 (valor singular máximo): ||A||_2 = σ_max(A)",
                                    "Estudar a norma de Frobenius: ||A||_F = √(Σ_i Σ_j |a_ij|^2)",
                                    "Comparar propriedades de submultiplicatividade e consistência com normas vetoriais"
                                  ],
                                  "verification": "Listar corretamente as fórmulas das quatro normas e suas propriedades principais em um quadro comparativo",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Álgebra Linear Numérica (ex: Golub & Van Loan)",
                                    "Notebook com Python/NumPy ou MATLAB"
                                  ],
                                  "tips": "Use tabelas para memorizar fórmulas e pratique com matrizes 2x2 simples",
                                  "learningObjective": "Compreender as definições matemáticas e computacionais das normas principais usadas no condicionamento",
                                  "commonMistakes": [
                                    "Confundir norma de matriz com norma de vetor",
                                    "Esquecer que norma 2 requer decomposição SVD"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular normas e número de condição para matrizes bem-condicionadas",
                                  "subSteps": [
                                    "Escolher matrizes de teste bem-condicionadas (ex: identidade e matriz diagonal)",
                                    "Calcular manualmente ||A|| e ||A^{-1}|| para normas 1, ∞ e Frobenius",
                                    "Usar software para norma 2 e verificar κ(A) = ||A|| * ||A^{-1}||",
                                    "Comparar valores de κ(A) entre normas e anotar diferenças mínimas",
                                    "Plotar gráficos de κ vs. normas para visualização"
                                  ],
                                  "verification": "Apresentar tabela com cálculos exatos e relativos erros < 1% comparado ao software",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou papel para cálculos manuais",
                                    "Python com NumPy/SciPy ou MATLAB"
                                  ],
                                  "tips": "Comece com matrizes pequenas para validar implementações antes de automatizar",
                                  "learningObjective": "Aplicar fórmulas de normas para estimar κ(A) em casos ideais",
                                  "commonMistakes": [
                                    "Não inverter corretamente a matriz",
                                    "Ignorar precisão numérica em cálculos manuais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar impacto das normas na matriz de Hilbert mal-condicionada",
                                  "subSteps": [
                                    "Gerar matriz de Hilbert H_n para n=5 e n=10 usando fórmula h_ij = 1/(i+j-1)",
                                    "Calcular ||H|| e ||H^{-1}|| para todas as normas usando software",
                                    "Computar κ(H) em cada norma e observar discrepâncias (ex: κ_2 >> κ_1)",
                                    "Analisar inversa de Hilbert e discutir por que é mal-condicionada",
                                    "Executar perturbação pequena em H e medir variação relativa em soluções Ax=b"
                                  ],
                                  "verification": "Relatório com tabela de κ para Hilbert mostrando κ_2 ≈ 10^13 para n=10, com gráficos de comparação",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/MATLAB para gerar Hilbert (scipy.linalg.hilb)",
                                    "Gráficos com Matplotlib"
                                  ],
                                  "tips": "Use precisão dupla e valide com documentação conhecida de condicionamento de Hilbert",
                                  "learningObjective": "Demonstrar como normas afetam a detecção de mal-condicionamento",
                                  "commonMistakes": [
                                    "Usar n muito grande causando overflow",
                                    "Não normalizar perturbações corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir escolha de norma em contextos computacionais",
                                  "subSteps": [
                                    "Avaliar custo computacional: norma 1/∞ O(n), Frobenius O(n^2), 2 O(n^3 via SVD)",
                                    "Discutir quando usar cada norma (ex: norma 2 para erros espectrais, ∞ para erros máximos)",
                                    "Analisar trade-offs em estabilidade numérica e precisão",
                                    "Pesquisar referências em solvers lineares (ex: LAPACK escolhe norma 2)",
                                    "Concluir com recomendações para engenharia computacional"
                                  ],
                                  "verification": "Escrever parágrafo de 200 palavras justificando escolha de norma para um problema específico",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Artigos sobre análise numérica (ex: Higham 'Accuracy and Stability')",
                                    "Documentação NumPy/SciPy"
                                  ],
                                  "tips": "Relacione com problemas reais como FEM para fixar conceitos",
                                  "learningObjective": "Avaliar critérios práticos para seleção de normas no condicionamento",
                                  "commonMistakes": [
                                    "Ignorar custo computacional em grandes matrizes",
                                    "Generalizar sem contexto"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a matriz de Hilbert 3x3: H = [[1,1/2,1/3],[1/2,1/3,1/4],[1/3,1/4,1/5]], calcule κ_1(H)≈4.32, κ_∞(H)≈5.41, κ_2(H)≈5.38 e κ_F(H)≈4.79. Note que κ_2 captura melhor o mal-condicionamento crescente com n.",
                              "finalVerifications": [
                                "Calcular corretamente κ(A) para Hilbert 5x5 em 3 normas diferentes com erro <0.1%",
                                "Explicar por que κ_2 é preferida em análise espectral",
                                "Identificar norma ótima para maximizar/minimizar κ em dado contexto",
                                "Simular perturbação e prever impacto usando κ",
                                "Comparar κ de Hilbert vs. matriz identidade",
                                "Listar 3 vantagens/desvantagens de cada norma"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de normas e κ (90%+ acurácia)",
                                "Compreensão conceitual: explicação clara de diferenças entre normas",
                                "Aplicação prática: uso correto de software e validação",
                                "Análise crítica: discussão fundamentada de escolhas contextuais",
                                "Criatividade: exemplos originais além de Hilbert",
                                "Clareza na comunicação: tabelas/gráficos bem organizados"
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar funções norm() em Python/MATLAB",
                                "Análise Numérica: Estabilidade de algoritmos de inversão",
                                "Engenharia Computacional: Condicionamento em métodos dos elementos finitos (FEM)",
                                "Otimização: Normas em problemas de minimização quadrática",
                                "Física Computacional: Simulações de dinâmica estrutural"
                              ],
                              "realWorldApplication": "Em engenharia civil, ao resolver sistemas lineares Kx=f de equações de equilíbrio em análises FEM de estruturas, a escolha da norma 2 para κ(K) detecta instabilidades numéricas, evitando erros catastróficos em simulações de pontes ou edifícios sob cargas dinâmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Cálculo Prático e Aplicações",
                        "description": "Implementação computacional do número de condição e sua relevância em problemas de engenharia civil, como solução de sistemas lineares em análise estrutural e métodos numéricos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Implementar cálculo de κ(A) em software",
                            "description": "Usar MATLAB ou Python (NumPy) para calcular cond(A) built-in e manualmente com normas, testando em matrizes de problemas de valor inicial/contorno ou resíduos ponderados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de software e revisar conceitos de condicionamento",
                                  "subSteps": [
                                    "Instale Python com NumPy e SciPy ou MATLAB se preferir.",
                                    "Crie um novo script ou notebook Jupyter para experimentos.",
                                    "Revise definições: κ(A) = ||A|| * ||A^{-1}|| para normas compatíveis.",
                                    "Gere matrizes de teste iniciais (ex: identidade, diagonal dominante).",
                                    "Teste importações: import numpy as np; from scipy.linalg import inv."
                                  ],
                                  "verification": "Ambiente configurado se scripts rodam sem erros de importação e matrizes são criadas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "SciPy",
                                    "Jupyter Notebook (opcional)",
                                    "MATLAB (alternativa)"
                                  ],
                                  "tips": "Use ambientes virtuais (conda/venv) para evitar conflitos de pacotes.",
                                  "learningObjective": "Configurar ferramentas e recordar base teórica do número de condição.",
                                  "commonMistakes": [
                                    "Esquecer de instalar SciPy para inversão",
                                    "Confundir normas (use p=1,2,inf)",
                                    "Não testar importações iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular κ(A) usando funções built-in",
                                  "subSteps": [
                                    "Defina matrizes de exemplo: A = np.array([[1,0],[0,1]]), B mal-condicionada como Hilbert.",
                                    "Use np.linalg.cond(A, p=2) para norma 2 (singular values).",
                                    "Teste diferentes normas: p=None (2), p=1, p=np.inf.",
                                    "Registre resultados em tabela (print ou pandas DataFrame).",
                                    "Compare com MATLAB: cond(A,2) se disponível."
                                  ],
                                  "verification": "Resultados cond coincidem com documentação (ex: cond(eye(2))=1) e variam por norma.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy",
                                    "Código de matrizes de teste"
                                  ],
                                  "tips": "Para matrizes grandes, use cond(A,'fro') para norma Frobenius eficiente.",
                                  "learningObjective": "Dominar uso de funções prontas para análise rápida de condicionamento.",
                                  "commonMistakes": [
                                    "Passar p inválido",
                                    "Não especificar norma levando a defaults inesperados",
                                    "Ignorar warnings de singularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar cálculo manual de κ(A) com normas",
                                  "subSteps": [
                                    "Calcule norma de A: np.linalg.norm(A, ord=2), np.linalg.norm(A, ord=1), etc.",
                                    "Inverta A: A_inv = np.linalg.inv(A).",
                                    "Calcule norma de A_inv similarmente.",
                                    "Multiplique normas: kappa = norm_A * norm_Ainv para cada tipo.",
                                    "Implemente função personalizada def calc_cond_manual(A, p): ... com docstring."
                                  ],
                                  "verification": "Resultados manuais igualam built-in dentro de tolerância 1e-10 (np.allclose).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NumPy",
                                    "SciPy.linalg.inv"
                                  ],
                                  "tips": "Use np.linalg.pinv para pseudo-inversa em casos singulares.",
                                  "learningObjective": "Entender implementação interna e flexibilidade com normas personalizadas.",
                                  "commonMistakes": [
                                    "Erro de propagação numérica em inversão",
                                    "Normas incompatíveis (sempre use mesma ord)",
                                    "Não tratar matrizes singulares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar em matrizes de engenharia civil e analisar resultados",
                                  "subSteps": [
                                    "Gere matriz de Gram ou rigidez: ex. para treliça 2D com np.array de elementos finitos simples.",
                                    "Calcule κ built-in e manual para problemas IVP/BVP simulados (ex: A de resíduos ponderados).",
                                    "Compare discrepâncias e avalie estabilidade (κ>1e6 indica mal-condicionado).",
                                    "Visualize com plots: cond vs tamanho matriz ou eigenvalues.",
                                    "Documente insights em relatório curto no código."
                                  ],
                                  "verification": "Códigos produzem κ consistentes; análise identifica condicionamento ruim em matrizes reais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "NumPy",
                                    "Matplotlib para plots",
                                    "Exemplos de matrizes estruturais"
                                  ],
                                  "tips": "Escalone matrizes problemáticas com np.linalg.solve para validar.",
                                  "learningObjective": "Aplicar em contextos reais e interpretar impactos numéricos.",
                                  "commonMistakes": [
                                    "Matrizes não simétricas positivas definidas",
                                    "Ignorar escala (normalize A)",
                                    "Não plotar para insights visuais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise estrutural, calcule κ(A) para matriz de rigidez K de uma treliça 3-bar: K = [[2,-1,-1],[-1,2,-1],[-1,-1,2]] * 1e6. Built-in: ~1e6 (mal-condicionado devido a escala). Manual confirma, alertando para erros em FEM com grandes deslocamentos.",
                              "finalVerifications": [
                                "Código built-in e manual produzem κ idênticos (erro <1e-12).",
                                "Testes em 3+ matrizes (bem/mal-condicionadas) com normas 1,2,inf.",
                                "Função personalizada documentada e reutilizável.",
                                "Análise escrita identifica causas de alto condicionamento.",
                                "Plots mostram relação cond-tamanho ou eigenvalues.",
                                "Aplicação em matriz de engenharia civil validada."
                              ],
                              "assessmentCriteria": [
                                "Precisão: coincidência built-in vs manual (>99.9%).",
                                "Completude: todas normas implementadas e testadas.",
                                "Eficiência: tempo de execução razoável para n=100.",
                                "Documentação: comentários e relatório claro.",
                                "Análise: interpretação correta de impactos (erro relativo ~κ*eps).",
                                "Robustez: trata singularidades com warnings."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: implementação de algoritmos numéricos.",
                                "Álgebra Linear: normas, inversas e estabilidade.",
                                "Análise Numérica: análise de erro e condicionamento.",
                                "Engenharia Computacional: simulações FEM/MEF.",
                                "Visualização de Dados: plots de eigenvalues e cond."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos para estruturas civis (ex: pontes, edifícios), alto κ(A) em matrizes de rigidez prevê amplificação de erros de arredondamento, guiando pré-condicionadores ou refinamento de malha para precisão em análises sísmicas ou de cargas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Analisar condicionamento em exemplos reais",
                            "description": "Aplicar κ(A) a matrizes de rigidez em engenharia civil, interpretando resultados para prever precisão em métodos como Monte Carlo ou ajuste de curvas em otimização estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e preparar um exemplo real de matriz de rigidez",
                                  "subSteps": [
                                    "Escolha uma estrutura simples de engenharia civil, como uma treliça com 3-4 nós ou uma viga contínua.",
                                    "Derive ou obtenha a matriz de rigidez [K] usando método dos elementos finitos (MEF) básico ou equações elementares.",
                                    "Armazene a matriz em formato numérico, garantindo simetria e positiva definitude.",
                                    "Identifique propriedades da estrutura: dimensões, materiais (módulo de elasticidade E, seção A).",
                                    "Exporte para software de análise (ex: MATLAB ou Python)."
                                  ],
                                  "verification": "Verifique se [K] é simétrica e os autovalores são positivos via decomposição espectral.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB/Python (NumPy/SciPy), papel e calculadora, documento de referência MEF.",
                                  "tips": "Comece com estruturas 2D para simplicidade; use unidades consistentes (kN, m).",
                                  "learningObjective": "Compreender a origem física da matriz de rigidez em contextos reais.",
                                  "commonMistakes": "Ignorar unidades ou assumir [K] não simétrica devido a erros de montagem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o número de condição κ(A)",
                                  "subSteps": [
                                    "Calcule as normas ||A|| (ex: norma 2 ou Frobenius) e ||A⁻¹||.",
                                    "Ou, prefira decomposição SVD: κ(A) = σ_max / σ_min, onde σ são valores singulares.",
                                    "Implemente em código: use svd() no MATLAB ou numpy.linalg.svd() no Python.",
                                    "Compare com autovalores: κ₂(A) ≈ λ_max / λ_min para matrizes simétricas positivas definidas.",
                                    "Registre o valor exato de κ(A) e compare com benchmarks (κ<10⁴ bom para precisão)."
                                  ],
                                  "verification": "Confirme κ(A) >1 e valor consistente entre métodos (SVD vs autovalores).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código Python/MATLAB pronto, matriz [K] do passo anterior.",
                                  "tips": "Use norma 2 para precisão; evite norma infinita para matrizes grandes.",
                                  "learningObjective": "Dominar o cálculo prático de κ(A) para matrizes esparsas de engenharia.",
                                  "commonMistakes": "Confundir norma de A com norma condicional; não tratar singularidades numéricas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar resultados de condicionamento",
                                  "subSteps": [
                                    "Classifique: κ<10² (bem condicionado), 10²-10⁶ (moderado), >10⁶ (mal condicionado).",
                                    "Analise razões: elementos muito diferentes (malhas irregulares, materiais heterogêneos).",
                                    "Visualize: plote autovalores ou valores singulares em escala log.",
                                    "Quantifique impacto: erro relativo ≈ κ * eps_machine * ||x||.",
                                    "Documente implicações para estabilidade numérica."
                                  ],
                                  "verification": "Crie um relatório com classificação, gráfico e estimativa de erro.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de plotagem (Matplotlib), tabela de thresholds de condicionamento.",
                                  "tips": "Use log10(κ) para interpretação intuitiva; foque em σ_min pequeno.",
                                  "learningObjective": "Interpretar κ(A) qualitativa e quantitativamente em termos de precisão.",
                                  "commonMistakes": "Interpretar κ baixo como sempre bom, ignorando contexto da máquina."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar interpretação a métodos numéricos reais",
                                  "subSteps": [
                                    "Simule Monte Carlo: resolva [K]u = f com ruído, meça variância de u vs κ.",
                                    "Teste ajuste de curvas: otimize parâmetros em modelo estrutural minimizando ||Au - b||.",
                                    "Preveja precisão: para Monte Carlo, var(u) ∝ κ²; para otimização, convergência lenta se κ alto.",
                                    "Compare cenários: malha refinada vs grosseira, observe κ e erros.",
                                    "Proponha mitigação: pré-condicionadores (ILU) ou refinamento adaptativo."
                                  ],
                                  "verification": "Gere gráficos de erro vs κ e relatório de previsões validadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Códigos de simulação Monte Carlo/otimização (SciPy.optimize), dados sintéticos.",
                                  "tips": "Use 1000 iterações Monte Carlo; monitore resíduos em otimização.",
                                  "learningObjective": "Prever e validar impactos de condicionamento em métodos práticos.",
                                  "commonMistakes": "Não quantificar erro relativo; ignorar efeitos de ruído aleatório."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e otimizar análise",
                                  "subSteps": [
                                    "Resuma achados: κ, classificação, impactos previstos e observados.",
                                    "Teste sensibilidade: altere geometria/material e recalcule κ.",
                                    "Recomende ações: remalhar, escalar [K], usar solvers condicionados.",
                                    "Valide com software comercial (ex: ANSYS output de condicionamento).",
                                    "Prepare apresentação com lições aprendidas."
                                  ],
                                  "verification": "Checklist completo: resumo escrito, otimizações testadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software ANSYS/ABAQUS trial, template de relatório.",
                                  "tips": "Priorize otimizações custo-efetivas como escalonamento diagonal.",
                                  "learningObjective": "Integrar análise em workflow de otimização estrutural.",
                                  "commonMistakes": "Não testar múltiplos cenários; superestimar impacto sem simulação."
                                }
                              ],
                              "practicalExample": "Considere uma treliça planar com 4 nós e 5 barras (E=200 GPa, A=0.01 m²). Monte [K] 8x8, calcule κ≈10⁵ devido a barra longa. Em Monte Carlo para análise probabilística de cargas, erro em deslocamentos ≈5%; ajuste de curvas para calibrar E resulta em convergência 10x mais lenta.",
                              "finalVerifications": [
                                "κ(A) calculado corretamente com erro <1% vs método alternativo.",
                                "Interpretação classifica condicionamento com justificativa física.",
                                "Simulações mostram correlação erro-κ quantitativa.",
                                "Recomendações de mitigação testadas e eficazes.",
                                "Relatório completo com gráficos e conclusões acionáveis.",
                                "Validação cruzada com software comercial coincide."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de κ(A) e normas (90%+ acurácia).",
                                "Profundidade na interpretação e ligação com propriedades estruturais.",
                                "Qualidade das simulações numéricas e análise de resultados.",
                                "Criatividade e viabilidade das otimizações propostas.",
                                "Clareza e completude do relatório final.",
                                "Demonstração de impacto real em precisão de métodos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação SVD e solvers em Python/MATLAB.",
                                "Estatística: Análise de variância em Monte Carlo probabilístico.",
                                "Otimização: Gradientes em ajuste de curvas e pré-condicionadores.",
                                "Física/Mecânica: Relação entre geometria/material e autovalores.",
                                "Gestão de Projetos: Decisões baseadas em análise de risco numérico."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios altos, análise de κ([K]) previne erros em simulações sísmicas via Monte Carlo, garantindo precisão em otimização de seções para economia de material sem comprometer segurança (ex: ponte Golden Gate modelagem MEF)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.3",
                            "name": "Estratégias para melhorar condicionamento",
                            "description": "Discutir pré-condicionadores, escalonamento e relação com matriz de Gram para reduzir κ(A), com exemplos em equações não-lineares e redes neurais aplicadas a problemas civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o número de condição κ(A) e motivos para melhorá-lo",
                                  "subSteps": [
                                    "Calcule κ(A) = ||A|| * ||A⁻¹|| para matrizes normais (ex: norma 2).",
                                    "Analise impactos de alto κ(A) em sistemas lineares Ax=b, como amplificação de erros.",
                                    "Discuta relação com decomposição SVD e autovalores.",
                                    "Examine exemplos em engenharia civil: matrizes de rigidez mal condicionadas.",
                                    "Compare κ(A) antes e após transformações."
                                  ],
                                  "verification": "Calcule κ(A) para uma matriz de exemplo e identifique se κ(A) > 10¹⁰ indica problema.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (NumPy, SciPy), MATLAB ou papel/caneta para matrizes pequenas.",
                                  "tips": "Use norma Frobenius para simplificação inicial em testes.",
                                  "learningObjective": "Explicar quantitativamente por que baixo κ(A) melhora estabilidade numérica.",
                                  "commonMistakes": "Confundir κ(A) com determinante; ignorar normas adequadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar escalonamento diagonal para melhorar condicionamento",
                                  "subSteps": [
                                    "Identifique escalas desbalanceadas nas linhas/colunas da matriz A.",
                                    "Crie matriz diagonal D com inversos das normas das linhas.",
                                    "Compute Ã = D A D⁻¹ e verifique novo κ(Ã).",
                                    "Teste em matriz de exemplo de análise estrutural (ex: treliça).",
                                    "Avalie perda de precisão numérica pós-escalonamento."
                                  ],
                                  "verification": "Reduza κ(A) em pelo menos 50% com escalonamento em uma matriz 5x5.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Jupyter Notebook com NumPy; matrizes de teste pré-definidas.",
                                  "tips": "Escalone colunas separadamente se A não for simétrica.",
                                  "learningObjective": "Implementar escalonamento para equilibrar matrizes e reduzir κ(A).",
                                  "commonMistakes": "Usar escalas absolutas sem normalizar; esquecer de escalonar ambos lados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar pré-condicionadores simples (ex: Jacobi, Gauss-Seidel)",
                                  "subSteps": [
                                    "Construa pré-condicionador M ≈ A (diagonal para Jacobi).",
                                    "Resolva M⁻¹ A x = M⁻¹ b iterativamente (ex: GMRES).",
                                    "Compare iterações com e sem pré-condicionador.",
                                    "Aplique a equações não-lineares via Newton-Raphson linearizado.",
                                    "Meça redução em κ(M⁻¹ A)."
                                  ],
                                  "verification": "Demonstre convergência 2x mais rápida com pré-condicionador em sistema 10x10.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "SciPy (sparse.linalg), exemplos de matrizes esparsas civis.",
                                  "tips": "Comece com diagonal dominante; teste incomplete LU para avançado.",
                                  "learningObjective": "Usar pré-condicionadores para acelerar solvers iterativos.",
                                  "commonMistakes": "Escolher M mal aproximado; ignorar custo computacional de M⁻¹."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar matriz de Gram e aplicações em redes neurais para problemas civis",
                                  "subSteps": [
                                    "Compute G = Aᵀ A (Gram) e analise κ(G) vs κ(A).",
                                    "Relacione com minimização de erros em regressão (NNs).",
                                    "Aplique em equações não-lineares de fluxo em solos (civil).",
                                    "Integre em rede neural para predição de deformações estruturais.",
                                    "Valide redução de κ via simulação."
                                  ],
                                  "verification": "Construa Gram para dados civis e mostre κ(G) < κ(Aᵀ A) ideal.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "TensorFlow/PyTorch para NNs; dados de elementos finitos.",
                                  "tips": "Gram melhora ortogonalidade em features de input.",
                                  "learningObjective": "Conectar Gram a condicionamento em ML aplicado a civil.",
                                  "commonMistakes": "Confundir Gram com covariância; não normalizar dados de entrada."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar estratégias em um caso prático completo",
                                  "subSteps": [
                                    "Monte matriz de rigidez de viga (FEA civil).",
                                    "Aplique escalonamento + pré-condicionador + Gram.",
                                    "Resolva Ax=b e compare erros relativos.",
                                    "Estenda a não-linear (grande deformação).",
                                    "Documente melhorias em κ e precisão."
                                  ],
                                  "verification": "Relatório com κ inicial/final e erro < 10⁻⁶.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "FEniCS ou código custom em Python.",
                                  "tips": "Use sparse matrices para eficiência.",
                                  "learningObjective": "Combinar técnicas para otimizar condicionamento em cenários reais.",
                                  "commonMistakes": "Sobrecarregar com múltiplos pré-condicionadores sem testar."
                                }
                              ],
                              "practicalExample": "Em análise de uma treliça 2D com 10 nós, matriz A 20x20 tem κ(A)=10¹². Após escalonamento diagonal e pré-condicionador Jacobi, κ cai para 10⁵, reduzindo iterações GMRES de 500 para 50, com erro residual <10⁻⁸.",
                              "finalVerifications": [
                                "κ(A) reduzido em >90% pós-estratégias.",
                                "Erro relativo em solução Ax=b <10⁻⁶.",
                                "Convergência iterativa <100 passos.",
                                "Gram matrix com autovalores bem distribuídos.",
                                "Aplicação bem-sucedida em exemplo não-linear civil.",
                                "Código reproduzível com comentários."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de κ(A) e normas (90%).",
                                "Correta implementação de escalonamento e pré-condicionadores (85%).",
                                "Análise qualitativa/quantitativa de melhorias (80%).",
                                "Integração com Gram e NNs (75%).",
                                "Aplicação contextual a engenharia civil (90%).",
                                "Clareza em exemplos e verificações (85%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso de SciPy/NumPy para solvers.",
                                "Machine Learning: Pré-condicionamento em treinamento de NNs.",
                                "Estatística: Análise de autovalores e SVD.",
                                "Física Computacional: Modelos FEA em civil.",
                                "Otimização: Redução de condição em problemas não-lineares."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos para barragens ou pontes, estratégias reduzem tempo computacional de dias para horas, permitindo análises em tempo real de deformações sob cargas dinâmicas, essencial para segurança estrutural em engenharia civil."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Análise de Condicionamento Numérico",
                    "description": "Avaliação da estabilidade e precisão das soluções de sistemas lineares com base no número de condição.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Número de Condição de Matrizes",
                        "description": "Conceito fundamental que quantifica o condicionamento de uma matriz, medindo a sensibilidade das soluções de sistemas lineares a pequenas perturbações nos dados de entrada.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Definir o número de condição",
                            "description": "Explicar a definição matemática do número de condição κ(A) = ||A|| * ||A⁻¹|| para uma matriz A invertível, destacando sua interpretação como amplificador relativo de erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender normas de matrizes",
                                  "subSteps": [
                                    "Definir norma de vetor como uma medida de tamanho (ex.: norma euclidiana ||x||_2 = sqrt(x^T x)).",
                                    "Explicar norma de matriz induzida: ||A|| = sup_{x≠0} ||Ax|| / ||x||.",
                                    "Listar normas comuns: norma 1 (coluna máxima), norma infinito (linha máxima), norma 2 (valor singular máximo).",
                                    "Calcular exemplos simples para matrizes 2x2.",
                                    "Destacar propriedades: ||A|| ≥ 0, ||AB|| ≤ ||A|| ||B||."
                                  ],
                                  "verification": "Calcular corretamente ||A|| para pelo menos duas matrizes exemplo usando diferentes normas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Caderno",
                                    "Calculadora",
                                    "Matrizes de exemplo 2x2"
                                  ],
                                  "tips": "Comece com normas 1 e infinito, pois são mais fáceis de calcular manualmente.",
                                  "learningObjective": "Dominar o conceito e cálculo de normas de matrizes como base para o número de condição.",
                                  "commonMistakes": [
                                    "Confundir norma induzida com norma de Frobenius.",
                                    "Esquecer que normas são invariantes a escalas relativas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a matriz inversa e sua norma",
                                  "subSteps": [
                                    "Recordar que A^{-1} existe se det(A) ≠ 0 e satisfaz A A^{-1} = I.",
                                    "Explicar que ||A^{-1}|| mede sensibilidade à perturbação na solução de Ax = b.",
                                    "Calcular A^{-1} para matriz simples e sua norma.",
                                    "Discutir que ||A|| ||A^{-1}|| ≥ 1 sempre, pois ||I|| = 1.",
                                    "Relacionar com estabilidade numérica em computação."
                                  ],
                                  "verification": "Computar A^{-1} e ||A^{-1}|| para uma matriz 2x2 dada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno",
                                    "Fórmula de inversa 2x2",
                                    "Calculadora"
                                  ],
                                  "tips": "Use a fórmula adjunta/det para matrizes pequenas para evitar erros.",
                                  "learningObjective": "Compreender o papel da norma da inversa na amplificação de erros.",
                                  "commonMistakes": [
                                    "Calcular inversa incorreta devido a erro em determinante.",
                                    "Ignorar que A deve ser invertível."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir formalmente o número de condição κ(A)",
                                  "subSteps": [
                                    "Escrever a fórmula exata: κ(A) = ||A|| ⋅ ||A^{-1}|| para norma consistente.",
                                    "Explicar independência qualitativa da norma escolhida (até fator constante).",
                                    "Calcular κ(A) para matriz identidade (deve ser 1).",
                                    "Comparar com matrizes diagonais: κ = max|λ_i| / min|λ_i| para norma 2.",
                                    "Verificar unidade adimensional de κ(A)."
                                  ],
                                  "verification": "Escrever a definição e calcular κ para A = I_2 e uma matriz diagonal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno",
                                    "Exemplos de matrizes",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre especifique a norma usada para evitar ambiguidades.",
                                  "learningObjective": "Formular precisamente a definição matemática de κ(A).",
                                  "commonMistakes": [
                                    "Escrever κ(A) = ||A^{-1}|| / ||A|| em vez do produto.",
                                    "Omitir requisito de invertibilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar κ(A) como amplificador relativo de erros",
                                  "subSteps": [
                                    "Explicar em Ax = b: erro relativo em x ≤ κ(A) ⋅ erro relativo em b.",
                                    "Discutir perturbações: δx / ||x|| ≈ κ(A) ⋅ δb / ||b||.",
                                    "Classificar: κ ≈ 1 (bem condicionado), κ >> 1 (mal condicionado).",
                                    "Relacionar com autovalores: κ_2(A) = σ_max / σ_min.",
                                    "Dar exemplo numérico de amplificação."
                                  ],
                                  "verification": "Explicar verbalmente como κ amplifica erros e dar bound para erro relativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Caderno",
                                    "Sistema linear exemplo",
                                    "Gráfico de vetores (opcional)"
                                  ],
                                  "tips": "Pense geometricamente: κ mede distorção de elipse unitária por A.",
                                  "learningObjective": "Interpretar κ(A) como medida de sensibilidade numérica.",
                                  "commonMistakes": [
                                    "Confundir amplificação absoluta com relativa.",
                                    "Achar que κ pequeno sempre garante precisão exata."
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 1], [0, 2]] (norma 2): autovalores de A^T A dão σ_max ≈ 2.236, σ_min ≈ 1, A^{-1} = [[1, -0.5], [0, 0.5]], κ_2(A) ≈ 2.236. Se δb/b = 10^{-6}, erro em x pode ser até 2.236 × 10^{-6}.",
                              "finalVerifications": [
                                "Escreve corretamente κ(A) = ||A|| ||A^{-1}||.",
                                "Calcula normas e κ para matriz 2x2 simples.",
                                "Explica amplificação de erros relativos.",
                                "Identifica que κ ≥ 1 e seu significado.",
                                "Relaciona κ com condicionamento em sistemas lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula matemática de κ(A).",
                                "Correção nos cálculos de normas e inversa.",
                                "Clareza na interpretação como amplificador de erros.",
                                "Uso apropriado de exemplos numéricos.",
                                "Compreensão de independência da norma.",
                                "Identificação de matrizes bem/mal condicionadas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: normas e autovalores.",
                                "Análise Numérica: estabilidade de algoritmos.",
                                "Engenharia Computacional: solvers de sistemas lineares.",
                                "Física Aplicada: modelagem de estruturas em engenharia civil."
                              ],
                              "realWorldApplication": "Em engenharia civil, na análise de estruturas via método dos elementos finitos, matrizes de rigidez podem ter κ grande devido a malha irregular ou elementos esbeltos, amplificando erros de arredondamento em softwares como ANSYS, levando a simulações imprecisas de tensões e deslocamentos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Calcular o número de condição usando normas",
                            "description": "Computar κ(A) utilizando normas vetoriais e matriciais comuns (norma 1, 2, ∞), com exemplos numéricos simples para matrizes 2x2 e 3x3.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Normas Vetoriais e Matriciais",
                                  "subSteps": [
                                    "Defina a norma 1 para vetores: soma dos valores absolutos dos componentes (|x|_1 = Σ |x_i|).",
                                    "Defina a norma 2 (euclidiana): raiz quadrada da soma dos quadrados (|x|_2 = √(Σ x_i²)).",
                                    "Defina a norma ∞ (máxima): máximo valor absoluto dos componentes (|x|_∞ = max |x_i|).",
                                    "Estenda para matrizes: norma 1 é máxima soma de colunas absolutas, norma ∞ é máxima soma de linhas absolutas, norma 2 é maior valor singular.",
                                    "Pratique com vetores simples de 2 e 3 dimensões."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as três normas para um vetor exemplo, distinguindo vetores e matrizes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Papel e caneta para anotações",
                                    "Tabela de fórmulas de normas"
                                  ],
                                  "tips": "Use exemplos numéricos pequenos para fixar; memorize que normas de matrizes induzem normas vetoriais.",
                                  "learningObjective": "Compreender precisamente as normas 1, 2 e ∞ para vetores e matrizes, base para o número de condição.",
                                  "commonMistakes": [
                                    "Confundir norma de vetor com de matriz",
                                    "Esquecer valores absolutos na norma 1 e ∞",
                                    "Calcular norma 2 sem raiz quadrada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Norma de uma Matriz A",
                                  "subSteps": [
                                    "Escolha uma matriz A 2x2 ou 3x3 com entradas numéricas simples (ex: inteiros pequenos).",
                                    "Calcule ||A||_1: encontre a coluna com maior soma de valores absolutos.",
                                    "Calcule ||A||_∞: encontre a linha com maior soma de valores absolutos.",
                                    "Calcule ||A||_2: use decomposição SVD ou aproximação para matrizes pequenas (ou fórmula para 2x2).",
                                    "Registre os valores para cada norma."
                                  ],
                                  "verification": "Mostre cálculos passo a passo para ||A|| com as três normas e confira com software como MATLAB ou Python (NumPy).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software NumPy/MATLAB",
                                    "Matriz A impressa ou anotada"
                                  ],
                                  "tips": "Para norma 2 em 2x2, use ||A||_2 = √(maior autovalor de A^T A); pratique transposição.",
                                  "learningObjective": "Aplicar fórmulas de normas matriciais em matrizes concretas de 2x2 e 3x3.",
                                  "commonMistakes": [
                                    "Não usar valores absolutos nas somas",
                                    "Erro na identificação de máxima linha/coluna",
                                    "Confundir normas subordinadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Inversa de A e Sua Norma",
                                  "subSteps": [
                                    "Verifique se A é invertível (det(A) ≠ 0).",
                                    "Compute A^{-1} para 2x2 usando fórmula adjunta/determinante; para 3x3 use Gauss-Jordan ou fórmula.",
                                    "Calcule ||A^{-1}||_1, ||A^{-1}||_∞ e ||A^{-1}||_2 seguindo os mesmos passos da norma de A.",
                                    "Compare os valores de norma de A e A^{-1}.",
                                    "Anote potenciais amplificações numéricas."
                                  ],
                                  "verification": "Multiplique A * A^{-1} = I (identidade) e confirme normas calculadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software para inversa (opcional: Python SciPy)",
                                    "Folha para eliminação gaussiana"
                                  ],
                                  "tips": "Para 2x2, fórmula direta: A^{-1} = (1/det) * [[d,-b],[-c,a]]; evite divisões por zero.",
                                  "learningObjective": "Dominar cálculo de inversa e normas para matrizes pequenas, preparando para κ(A).",
                                  "commonMistakes": [
                                    "Erro no sinal da adjunta",
                                    "Esquecer fator 1/det(A)",
                                    "Normas incorretas por propagação de erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar e Interpretar o Número de Condição κ(A)",
                                  "subSteps": [
                                    "Calcule κ(A)_p = ||A||_p * ||A^{-1}||_p para p=1,2,∞.",
                                    "Repita para pelo menos duas matrizes: uma 2x2 bem condicionada (κ≈1) e uma mal condicionada (κ>>1).",
                                    "Interprete: κ=1 (perfeita), κ>10^6 (numéricamente singular).",
                                    "Compare normas diferentes e discuta qual usar.",
                                    "Registre resultados em tabela."
                                  ],
                                  "verification": "Confira κ com função cond() em software e interprete corretamente o condicionamento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de resultados",
                                    "Software para validação (NumPy.linalg.cond)"
                                  ],
                                  "tips": "Escolha matrizes com det próximo de zero para mal condicionadas; κ_2 é mais precisa.",
                                  "learningObjective": "Calcular κ(A) usando normas e avaliar estabilidade numérica.",
                                  "commonMistakes": [
                                    "Esquecer multiplicar normas",
                                    "Interpretar κ baixo como bom sem contexto",
                                    "Usar norma errada consistentemente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[2, 1], [1, 1]] (2x2): det(A)=1, A^{-1}=[[1,-1],[-1,2]]. ||A||_1=3, ||A^{-1}||_1=3 → κ_1=9. ||A||_∞=3, ||A^{-1}||_∞=3 → κ_∞=9. ||A||_2≈2.618, ||A^{-1}||_2≈2.618 → κ_2≈6.85. Matriz moderadamente condicionada.",
                              "finalVerifications": [
                                "Calcule κ_2 para matriz 3x3 aleatória e valide com software.",
                                "Identifique se κ>1000 indica problema numérico.",
                                "Explique por que κ depende da norma escolhida.",
                                "Compute κ para matriz diagonal e interprete (deve ser max|λ_i|/min|λ_i|).",
                                "Discuta impacto de perturbação em b para Ax=b."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de normas (erro <1%).",
                                "Correta computação de inversa (A*A^{-1}=I).",
                                "Interpretação adequada de valores de κ (bom/mal condicionada).",
                                "Uso consistente de normas em pares A e A^{-1}.",
                                "Clareza em tabelas e exemplos numéricos.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores e decomposições SVD.",
                                "Cálculo Numérico: estabilidade e erros de arredondamento.",
                                "Engenharia Computacional: solvers de sistemas lineares em FEM.",
                                "Física: análise de estabilidade em sistemas dinâmicos.",
                                "Estatística: sensibilidade em regressão linear."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao resolver Kx=f em análise estrutural via elementos finitos, alto κ(K) indica sensibilidade a erros de medição ou arredondamento, podendo levar a colapsos preditos incorretos em pontes ou edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Relacionar autovalores ao condicionamento",
                            "description": "Demonstrar que para matrizes simétricas positivas definidas, κ₂(A) = λ_max / λ_min, onde λ são autovalores, e interpretar o espectro de autovalores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de autovalores e matrizes simétricas positivas definidas (SPD)",
                                  "subSteps": [
                                    "Definir autovalor λ e autovetor v de uma matriz A, resolvendo Av = λv.",
                                    "Explicar propriedades de matrizes SPD: simétrica (A = A^T), todos autovalores positivos reais, diagonalizável ortogonalmente (A = QΛQ^T).",
                                    "Listar teoremas relevantes: decomposição espectral para SPD.",
                                    "Calcular autovalores de uma matriz 2x2 simples SPD manualmente.",
                                    "Verificar se uma matriz dada é SPD computando autovalores."
                                  ],
                                  "verification": "Resolver corretamente autovalores de pelo menos duas matrizes 2x2 SPD e listar três propriedades chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, calculadora científica, software como MATLAB ou Python (NumPy) para verificação.",
                                  "tips": "Sempre normalize autovetores para facilitar comparações.",
                                  "learningObjective": "Compreender a base teórica de autovalores e identificar matrizes SPD.",
                                  "commonMistakes": "Confundir autovalores com traço ou determinante; esquecer que autovalores de SPD são estritamente positivos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o número de condição κ₂(A) e suas normas associadas",
                                  "subSteps": [
                                    "Definir κ₂(A) = ||A||₂ * ||A⁻¹||₂, onde ||.||₂ é a norma espectral (maior autovalor em módulo).",
                                    "Explicar interpretação: mede sensibilidade de soluções lineares Ax=b a perturbações.",
                                    "Relacionar ||A||₂ = max|λ_i| para autovalores λ_i de A.",
                                    "Para A⁻¹, ||A⁻¹||₂ = 1 / min|λ_i|.",
                                    "Calcular κ₂ para uma matriz diagonal simples."
                                  ],
                                  "verification": "Calcular κ₂(A) para uma matriz 2x2 diagonal e interpretar se está bem ou mal condicionada (κ<10 bem, >1000 mal).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta, software NumPy ou MATLAB para normas.",
                                  "tips": "Use decomposição SVD para computar normas em software.",
                                  "learningObjective": "Dominar a definição e cálculo do número de condição espectral.",
                                  "commonMistakes": "Confundir κ₂ com outras normas (ex: Frobenius); ignorar que κ=1 indica matriz bem condicionada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar que para matrizes SPD, κ₂(A) = λ_max / λ_min",
                                  "subSteps": [
                                    "Usar decomposição espectral A = QΛQ^T, com Λ diagonal de autovalores positivos ordenados λ_min ≤ ... ≤ λ_max.",
                                    "Mostrar ||A||₂ = λ_max, pois Q é ortogonal (||Q||₂=1).",
                                    "Derivar ||A⁻¹||₂ = 1/λ_min, já que A⁻¹ = QΛ⁻¹Q^T.",
                                    "Concluir κ₂(A) = λ_max / λ_min.",
                                    "Provar para uma matriz 2x2 SPD passo a passo."
                                  ],
                                  "verification": "Derivar a fórmula κ₂(A) = λ_max / λ_min algebricamente para uma SPD genérica 2x2.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis para derivação, MATLAB para validar com eig().",
                                  "tips": "Desenhe a decomposição espectral visualmente para intuitar.",
                                  "learningObjective": "Derivar e comprovar a relação direta entre condicionamento e espectro de autovalores.",
                                  "commonMistakes": "Esquecer propriedades ortogonais de Q; aplicar fórmula sem verificar se é SPD."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o espectro de autovalores em relação ao condicionamento",
                                  "subSteps": [
                                    "Analisar como ratio λ_max/λ_min grande indica mal condicionamento (autovalores espalhados).",
                                    "Interpretar: autovalores próximos = bom condicionamento; discrepantes = il-condicionado.",
                                    "Aplicar em contexto: matrizes de rigidez em estruturas civis tendem a ter autovalores variados.",
                                    "Prever estabilidade numérica de solvers lineares baseado no espectro.",
                                    "Discutir pré-condicionadores para reduzir κ efetivo."
                                  ],
                                  "verification": "Para uma matriz exemplo, plotar autovalores e classificar condicionamento, justificando interpretação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB/Python com eig e plot, exemplos de matrizes de engenharia.",
                                  "tips": "Use logscale para visualizar espectro amplo.",
                                  "learningObjective": "Interpretar fisicamente o impacto do espectro no condicionamento numérico.",
                                  "commonMistakes": "Ignorar ordenação (λ_max vs λ_min); superestimar condicionamento por autovalores médios."
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez 2D de uma treliça simples: A = [[2, -1], [-1, 1]]. Verifique SPD (autovalores ≈2.618, 0.382), calcule κ₂(A) = 2.618/0.382 ≈6.85 (bem condicionada). Perturbe para A_pert = [[2.01, -1], [-1, 1]] e observe aumento em κ₂, demonstrando sensibilidade.",
                              "finalVerifications": [
                                "Calcular corretamente autovalores e κ₂ para duas matrizes SPD 2x2.",
                                "Derivar algebricamente κ₂(A) = λ_max/λ_min sem erros.",
                                "Interpretar se κ₂>100 indica problema numérico potencial.",
                                "Aplicar em exemplo de engenharia civil com precisão.",
                                "Plotar espectro e discutir espalhamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula (100% correta).",
                                "Correção nos cálculos numéricos (erro <1%).",
                                "Profundidade na interpretação do espectro (menciona sensibilidade e aplicações).",
                                "Uso adequado de software para validação.",
                                "Identificação de erros comuns evitados.",
                                "Conexão clara com condicionamento numérico."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos de vibração em estruturas (autovalores como frequências naturais).",
                                "Computação: Estabilidade de métodos iterativos como CG para sistemas SPD.",
                                "Estatística: Análise de componentes principais (PCA) usa decomposição espectral.",
                                "Otimização: Condicionamento afeta gradiente descendente em problemas quadráticos."
                              ],
                              "realWorldApplication": "Em análise estrutural de edifícios (Engenharia Civil), matrizes de rigidez mal condicionadas (grande κ₂ devido a autovalores discrepantes) causam erros em simulações FEM; identificar via espectro permite refinamento de malha ou pré-condicionamento para precisão em cargas sísmicas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Estabilidade e Precisão em Sistemas Lineares",
                        "description": "Análise de como o condicionamento afeta a estabilidade numérica e a precisão das soluções de Ax = b sob arredondamentos e perturbações.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Analisar bounds de erro relativos",
                            "description": "Derivar e aplicar as estimativas de erro |δx|/|x| ≤ κ(A) (|δA|/|A| + |δb|/|b|), explicando o papel do condicionamento na amplificação de erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Normas e Condicionamento",
                                  "subSteps": [
                                    "Defina normas de vetores (ex: norma 2, ||x||_2 = sqrt(x^T x)) e matrizes (||A||_2 = maior valor singular).",
                                    "Explique como calcular ||A|| e ||A^{-1}|| usando decomposição SVD ou potência iterativa.",
                                    "Compute o número de condicionamento κ(A) = ||A|| ||A^{-1}|| e interprete valores: κ≈1 bem condicionado, κ>>1 mal condicionado.",
                                    "Discuta implicações: κ mede sensibilidade da solução x a perturbações em A ou b.",
                                    "Pratique com matriz 2x2 simples: A = [[1,0],[0,1]], κ=1."
                                  ],
                                  "verification": "Calcule corretamente κ(A) para duas matrizes dadas e explique se são bem ou mal condicionadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora científica, MATLAB/Octave ou Python (NumPy/SciPy), papel e lápis.",
                                  "tips": "Use norma 2 para precisão; verifique simetria para simplificações.",
                                  "learningObjective": "Compreender a definição e cálculo de κ(A) como medida de condicionamento.",
                                  "commonMistakes": "Confundir norma de matriz com determinante; ignorar inversa na fórmula de κ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Bounds de Erro para Perturbações em b",
                                  "subSteps": [
                                    "Parta de Ax = b, x = A^{-1} b; considere perturbação δb pequena.",
                                    "Derive |δx| ≤ ||A^{-1}|| |δb|, então relativo |δx|/|x| ≤ κ(A) |δb|/|b|.",
                                    "Prove usando desigualdades de normas: ||A^{-1}|| / (||A||^{-1}) = κ(A).",
                                    "Interprete: fator κ amplifica erro relativo em b para x.",
                                    "Estenda para perturbações relativas generalizadas."
                                  ],
                                  "verification": "Escreva a derivação passo a passo e aplique a um exemplo numérico com δb=0.01.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de derivadas, software numérico para verificação.",
                                  "tips": "Mantenha perturbações pequenas (<<1) para aproximações lineares válidas.",
                                  "learningObjective": "Derivar analiticamente a bound de erro relativa para perturbações em b.",
                                  "commonMistakes": "Esquecer o papel de ||A|| no denominador relativo; usar normas inconsistentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Generalizar Bounds para Perturbações em A e b",
                                  "subSteps": [
                                    "Considere perturbação δA: (A+δA)(x+δx) = b + δb.",
                                    "Linearize: δx ≈ -A^{-1} (δA x + δb), derive |δx| ≤ ||A^{-1}|| (|δA| ||x|| + |δb|).",
                                    "Obtenha relativo: |δx|/|x| ≤ κ(A) (|δA|/|A| + |δb|/|b|), assumindo ||δA|| << ||A||.",
                                    "Explique amplificação: κ(A) grande causa perda de dígitos precisos.",
                                    "Valide com expansão em série de Taylor para perturbações."
                                  ],
                                  "verification": "Derive a fórmula completa e compute bound numérico para A perturbada.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software para resolver sistemas perturbados (MATLAB lu() ou Python linalg.solve).",
                                  "tips": "Use aproximação de primeiro ordem; teste com múltiplas perturbações.",
                                  "learningObjective": "Derivar a bound completa de erro relativo incluindo δA e δb.",
                                  "commonMistakes": "Negligenciar termo δA x na linearização; aplicar bound sem verificar hipóteses."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Interpretar em Exemplo Numérico de Engenharia",
                                  "subSteps": [
                                    "Monte sistema linear de truss simples: A 3x3 de rigidez, b de cargas.",
                                    "Perturbe A (1% erro em entrada) e b (0.5% sensor), resolva exato e perturbado.",
                                    "Calcule erros relativos observados vs. bound teórica com κ(A).",
                                    "Analise: se κ=100, espere amplificação ~100x; discuta precisão numérica.",
                                    "Recomende pré-condicionadores ou refinamento para mitigar."
                                  ],
                                  "verification": "Relatório com cálculos: bound vs. erro real, conclusão sobre condicionamento.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/Python para simulação, dados de exemplo de truss.",
                                  "tips": "Escolha A diagonal dominante para κ baixo; compare com A mal condicionada.",
                                  "learningObjective": "Aplicar bound em contexto prático e interpretar papel do condicionamento.",
                                  "commonMistakes": "Usar precisão simples (float32) mascarando erros; ignorar normalização."
                                }
                              ],
                              "practicalExample": "Considere A = [[100, 99], [99, 100]], b = [199, 199], solução x ≈ [1,1]. κ(A) ≈ 200. Perturbe δA/A = 0.01, δb/b=0.01 → bound ≤ 200*(0.01+0.01)=4, significando possível perda total de precisão (erro relativo até 400%). Simule em software para verificar amplificação.",
                              "finalVerifications": [
                                "Deriva corretamente a fórmula |δx|/|x| ≤ κ(A) (|δA|/|A| + |δb|/|b|).",
                                "Calcula κ(A) precisamente para matrizes 2x2 e 3x3.",
                                "Aplica bound em exemplo numérico, comparando erro teórico vs. observado.",
                                "Explica verbalmente como κ amplifica erros em 2-3 cenários.",
                                "Identifica matrizes mal condicionadas e sugere melhorias.",
                                "Implementa código simples para análise de sensibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (100% dos passos corretos).",
                                "Correção numérica: erros simulados dentro da bound prevista.",
                                "Profundidade de interpretação: discute amplificação e dígitos perdidos.",
                                "Criatividade em exemplos: aplica a contexto de engenharia civil.",
                                "Clareza na comunicação: gráficos de erro vs. κ.",
                                "Solução de problemas: mitiga condicionamento em caso teste."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Propagação de erros em medições experimentais.",
                                "Programação: Implementação numérica estável em Python/MATLAB.",
                                "Física/Engenharia Mecânica: Análise de estruturas com matrizes de rigidez.",
                                "Otimização: Uso de pré-condicionadores em métodos iterativos."
                              ],
                              "realWorldApplication": "Em análise finita de elementos para estruturas civis (ex: pontes), matrizes de rigidez mal condicionadas amplificam erros de discretização ou medições de carga, levando a designs inseguros; análise de bounds guia refino de malha ou uso de solvers robustos como GMRES."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Classificar matrizes como bem ou mal condicionadas",
                            "description": "Identificar matrizes bem condicionadas (κ ≈ 1) versus mal condicionadas (κ >> 1), com exemplos de problemas em engenharia civil como análise estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Condicionamento de Matrizes",
                                  "subSteps": [
                                    "Defina o número de condição κ(A) como κ(A) = ||A|| * ||A^{-1}||, onde ||.|| é uma norma de matriz compatível.",
                                    "Explique que matrizes bem condicionadas têm κ ≈ 1 (pouca amplificação de erros), enquanto mal condicionadas têm κ >> 1 (alta sensibilidade a perturbações).",
                                    "Discuta o impacto na estabilidade numérica de sistemas lineares Ax = b.",
                                    "Revise normas comuns: norma 2 (espectral), norma de Frobenius e norma máxima.",
                                    "Identifique que κ ≥ 1 sempre, com igualdade para matrizes escalares positivas."
                                  ],
                                  "verification": "Resuma em suas palavras o significado de κ ≈ 1 vs κ >> 1 e liste 2 normas de matrizes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang), calculadora ou Python/NumPy"
                                  ],
                                  "tips": "Use a norma 2 para precisão em engenharia, pois relaciona com autovalores.",
                                  "learningObjective": "Entender o conceito teórico de condicionamento e seu papel na precisão numérica.",
                                  "commonMistakes": [
                                    "Confundir condicionamento com singularidade (det(A)=0), ignorar que κ mede sensibilidade relativa."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Número de Condição para Matrizes Simples",
                                  "subSteps": [
                                    "Escolha uma norma (ex: norma 2) e calcule ||A|| para uma matriz 2x2 dada.",
                                    "Calcule a inversa A^{-1} usando fórmula analítica ou software.",
                                    "Compute ||A^{-1}|| com a mesma norma.",
                                    "Multiplique para obter κ(A) e interprete o resultado.",
                                    "Repita para uma matriz diagonal (esperado κ=1)."
                                  ],
                                  "verification": "Forneça κ para A = [[1,0],[0,1]] e verifique se κ=1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy (np.linalg.cond()), MATLAB ou papel para 2x2"
                                  ],
                                  "tips": "Use np.linalg.cond(A, p=2) no Python para automação rápida.",
                                  "learningObjective": "Dominar o cálculo prático de κ(A) usando normas e inversas.",
                                  "commonMistakes": [
                                    "Usar normas incompatíveis, esquecer de inverter corretamente matrizes singulares (evite-as)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos de Matrizes Bem e Mal Condicionadas",
                                  "subSteps": [
                                    "Teste matriz identidade (bem condicionada, κ=1).",
                                    "Teste matriz mal condicionada como A = [[1,1],[1,1+ε]] com ε pequeno (κ grande).",
                                    "Compare soluções de Ax=b com b perturbado para ambas.",
                                    "Plote ||δx||/||x|| vs ||δb||/||b|| para visualizar amplificação.",
                                    "Classifique: κ < 10^3 bem, >10^6 mal (limiares aproximados)."
                                  ],
                                  "verification": "Classifique A = [[1,0],[0,1000]] como mal condicionada e justifique com κ.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Jupyter Notebook com NumPy/Matplotlib, exemplos de matrizes pré-definidas"
                                  ],
                                  "tips": "Gere matrizes Hilbert para testes extremos: scipy.linalg.hilb(n).",
                                  "learningObjective": "Diferenciar numericamente matrizes bem vs mal condicionadas via exemplos.",
                                  "commonMistakes": [
                                    "Ignorar escala das entradas (normalize matrizes), confundir com det(A) pequeno."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Classificação em Contexto de Engenharia Civil",
                                  "subSteps": [
                                    "Considere matriz de rigidez K de uma treliça simples (bem condicionada se diagonal dominante).",
                                    "Gere ou use K mal condicionada (ex: elementos longos e finos).",
                                    "Calcule κ(K) e avalie estabilidade em análise estrutural.",
                                    "Simule deslocamentos δ com ruído em cargas e observe erros.",
                                    "Recomende pré-condicionadores ou refinamento de malha para mitigar."
                                  ],
                                  "verification": "Classifique uma matriz de rigidez 3x3 de viga e proponha melhoria se mal condicionada.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software FEA como ANSYS/MATLAB Structural, ou código Python custom"
                                  ],
                                  "tips": "Em FEA, verifique condicionamento antes de solver; use CG com pré-condicionador.",
                                  "learningObjective": "Aplicar classificação de condicionamento a problemas reais de estruturas.",
                                  "commonMistakes": [
                                    "Não considerar simetria positiva definida em K, superestimar impacto sem testes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de uma treliça 2D com matriz de rigidez K = [[2, -1], [-1, 1]] (bem condicionada, κ≈2), vs K_ill = [[1, 0.999], [0.999, 1]] (mal, κ≈10^6). Resolver K u = F com F perturbado mostra erros pequenos na primeira, explosivos na segunda.",
                              "finalVerifications": [
                                "Calcule κ para 3 matrizes dadas e classifique corretamente.",
                                "Explique verbalmente o risco de usar solver em matriz com κ=10^8.",
                                "Identifique norma adequada para K simétrica (norma 2).",
                                "Simule perturbação e meça amplificação de erro.",
                                "Proponha 2 estratégias para melhorar condicionamento em FEA.",
                                "Compare κ de matriz diagonal vs triangular ill-condicionada."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de κ (erro <1%).",
                                "Classificação correta baseada em limiares (ex: κ<10^4 bem).",
                                "Interpretação física das implicações em estabilidade estrutural.",
                                "Uso correto de software para verificação.",
                                "Identificação de erros comuns em exemplos práticos.",
                                "Conexão clara com análise numérica em engenharia."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Normas e autovalores.",
                                "Análise Numérica: Estabilidade de algoritmos de solver.",
                                "Engenharia Estrutural: Matrizes de rigidez em Método dos Elementos Finitos.",
                                "Programação: Implementação em Python/NumPy para automação.",
                                "Física: Sensibilidade em equilíbrios dinâmicos."
                              ],
                              "realWorldApplication": "Na análise estrutural de pontes ou edifícios via elementos finitos, matrizes mal condicionadas (devido a malhas distorcidas) causam erros em previsões de tensões/deslocamentos, levando a designs inseguros; engenheiros verificam κ para validar simulações antes de construção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Avaliar impacto de métodos numéricos",
                            "description": "Comparar o condicionamento antes e após pré-condicionadores ou decomposições (ex: QR, Cholesky), focando em estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular o número de condicionamento da matriz original",
                                  "subSteps": [
                                    "Selecionar uma matriz A representativa de um problema de engenharia civil, como matriz de rigidez de uma estrutura.",
                                    "Implementar a função para calcular o número de condicionamento κ(A) = ||A|| * ||A⁻¹|| usando normas apropriadas (ex: norma 2).",
                                    "Verificar simetria e positiva definitividade se aplicável para decomposições futuras.",
                                    "Registrar o valor inicial de κ(A) e identificar se é mal-condicionado (κ > 10⁶).",
                                    "Analisar o impacto potencial na precisão de soluções de Ax = b."
                                  ],
                                  "verification": "Confirme que κ(A) foi calculado corretamente comparando com função built-in (ex: cond() no MATLAB ou numpy.linalg.cond()).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (NumPy, SciPy), MATLAB ou Octave; matriz de exemplo de rigidez estrutural.",
                                  "tips": "Use norma espectral (2) para precisão em problemas simétricos.",
                                  "learningObjective": "Compreender e computar métricas de condicionamento para avaliar estabilidade inicial.",
                                  "commonMistakes": "Confundir normas (usar L1 em vez de L2); ignorar propriedades da matriz como simetria."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e aplicar pré-condicionador ou decomposição",
                                  "subSteps": [
                                    "Escolher método baseado na matriz: Cholesky para simétrica positiva definida; QR para geral.",
                                    "Implementar decomposição: para Cholesky, obter L tal que A = LLᵀ; para QR, A = QR.",
                                    "Construir pré-condicionador M⁻¹ (ex: M = LLᵀ para Cholesky).",
                                    "Formar sistema pré-condicionado: M⁻¹Ax = M⁻¹b.",
                                    "Verificar se a decomposição foi bem-sucedida (resíduos baixos)."
                                  ],
                                  "verification": "Reconstrua A a partir dos fatores e verifique ||A - fatores|| < 10⁻¹⁰.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Bibliotecas numéricas (SciPy.linalg.cholesky, qr); código de exemplo para matrizes esparsas.",
                                  "tips": "Para matrizes grandes/esparsas, use decomposições incompletas (ILU) para eficiência.",
                                  "learningObjective": "Aplicar técnicas de pré-condicionamento para melhorar condicionamento.",
                                  "commonMistakes": "Aplicar Cholesky em matriz não positiva definida (leva a NaN); não normalizar fatores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular condicionamento do sistema pré-condicionado",
                                  "subSteps": [
                                    "Computar κ(M⁻¹A) usando a mesma norma do passo 1.",
                                    "Avaliar estabilidade: comparar eigenvalues ou usar bounds teóricos.",
                                    "Medir redução relativa: fator = κ(original)/κ(pré-condicionado).",
                                    "Simular solução de Ax = b com ruído para observar propagação de erros.",
                                    "Documentar mudanças em precisão numérica esperada."
                                  ],
                                  "verification": "Execute solver iterativo (ex: GMRES) e compare resíduos antes/depois.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de solvers lineares (SciPy.sparse.linalg); gerador de ruído aleatório.",
                                  "tips": "Monitore iterações do solver: menos iterações indicam melhor condicionamento.",
                                  "learningObjective": "Quantificar melhoria no condicionamento pós-pré-condicionamento.",
                                  "commonMistakes": "Calcular κ(M⁻¹A) em vez de κ(M⁻¹Ax); ignorar custo computacional do pré-condicionador."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e analisar impacto na estabilidade",
                                  "subSteps": [
                                    "Comparar κ_original vs κ_novo graficamente (bar chart ou log scale).",
                                    "Analisar estabilidade: erro relativo ||x - x_exact|| / ||x_exact|| com ruído.",
                                    "Discutir trade-offs: redução de κ vs custo de setup do pré-condicionador.",
                                    "Testar sensibilidade a perturbações em b ou A.",
                                    "Concluir sobre eficácia para problemas de engenharia civil."
                                  ],
                                  "verification": "Relatório escrito com tabelas/gráficos mostrando redução > 10x em κ e erro < 10⁻⁸.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramentas de plotagem (Matplotlib); template de relatório.",
                                  "tips": "Use log10(κ) para visualizar melhorias grandes.",
                                  "learningObjective": "Interpretar numericamente o impacto em estabilidade e precisão.",
                                  "commonMistakes": "Atribuir causalidade sem testes de sensibilidade; superestimar benefícios sem custo."
                                }
                              ],
                              "practicalExample": "Em uma treliça 2D com matriz de rigidez 10x10 mal-condicionada (κ ≈ 10⁸ devido a elementos longos), aplique Cholesky: κ reduz para 10³, erros de deslocamento caem de 10% para 0.01% com ruído de medição.",
                              "finalVerifications": [
                                "Número de condicionamento reduzido por pelo menos um fator de 10.",
                                "Erro relativo na solução < 10⁻⁶ após pré-condicionamento.",
                                "Solver converge em < 50 iterações vs > 200 originais.",
                                "Decomposição reconstruída com precisão máquina.",
                                "Análise sensível a variações de 1% em A/b.",
                                "Relatório inclui gráficos comparativos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de condicionamento (erro < 1%).",
                                "Correta seleção e implementação do pré-condicionador.",
                                "Análise qualitativa/quantitativa do impacto na estabilidade.",
                                "Uso apropriado de normas e verificações numéricas.",
                                "Interpretação contextualizada para engenharia civil.",
                                "Clareza em relatórios e visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Teoria de normas e decomposições.",
                                "Programação Numérica: Implementação de solvers e análise de erros.",
                                "Mecânica Estrutural: Matrizes de rigidez em análise finita.",
                                "Estatística: Análise de sensibilidade e propagação de erros."
                              ],
                              "realWorldApplication": "Na análise de estruturas civis como pontes ou edifícios, pré-condicionadores como Cholesky aceleram solvers para matrizes de milhões de DOFs, garantindo precisão em simulações sísmicas onde condicionamento ruim causa erros catastróficos em predições de deformação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Aplicações Práticas e Computação Numérica",
                        "description": "Implementação e análise computacional do condicionamento usando ferramentas como MATLAB, com foco em problemas da engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Implementar cálculo de κ em software",
                            "description": "Usar funções como cond(A,'2') no MATLAB para calcular e interpretar o número de condição em matrizes de rigidez estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente MATLAB e preparar matriz de exemplo",
                                  "subSteps": [
                                    "Instale e abra o MATLAB.",
                                    "Crie uma matriz de rigidez simples 2x2, como A = [2, -1; -1, 2].",
                                    "Verifique as propriedades básicas da matriz usando size(A) e det(A).",
                                    "Salve o script em um arquivo .m para reutilização.",
                                    "Execute o script para confirmar que a matriz está correta."
                                  ],
                                  "verification": "Matriz A é exibida corretamente no Command Window sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "MATLAB instalado",
                                    "Editor de script MATLAB"
                                  ],
                                  "tips": "Use o Live Editor para documentar inline.",
                                  "learningObjective": "Configurar ambiente e criar matriz de rigidez básica.",
                                  "commonMistakes": [
                                    "Esquecer ponto e vírgula causando spam no output",
                                    "Matriz não simétrica",
                                    "Não verificar determinante zero"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o cálculo do número de condição κ usando cond()",
                                  "subSteps": [
                                    "Digite o comando cond(A, '2') para norma 2 (espectral).",
                                    "Calcule também cond(A, 'inf') para comparação.",
                                    "Armazene o resultado em uma variável: kappa = cond(A, '2').",
                                    "Exiba o valor com fprintf('κ₂ = %g\n', kappa).",
                                    "Teste com uma matriz mal condicionada, como A_ill = [1, 1; 1+eps, 1]."
                                  ],
                                  "verification": "Valor de κ é exibido e cond(A,'2') retorna número finito >1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Script MATLAB do Step 1",
                                    "Documentação MATLAB cond()"
                                  ],
                                  "tips": "Use '2' para norma espectral relevante em engenharia estrutural.",
                                  "learningObjective": "Executar função cond() corretamente para diferentes normas.",
                                  "commonMistakes": [
                                    "Usar cond(A) sem norma específica (padrão é 'fro')",
                                    "Confundir norma '2' com 'inf'",
                                    "Não lidar com singularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o número de condição em contexto estrutural",
                                  "subSteps": [
                                    "Relacione κ alto (>10^6) com ill-conditioning em matrizes de rigidez.",
                                    "Calcule autovalores com eig(A) para verificar razão maior/menor.",
                                    "Compare κ com sqrt(λ_max/λ_min).",
                                    "Discuta implicações: sensibilidade a erros de arredondamento em FEM.",
                                    "Anote interpretação em comentários no script."
                                  ],
                                  "verification": "Relatório escrito confirma que κ indica condicionamento (bom se <10^3).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Script anterior",
                                    "Teoria de análise numérica"
                                  ],
                                  "tips": "Para rigidez, κ reflete distorção geométrica da estrutura.",
                                  "learningObjective": "Interpretar κ quanto à estabilidade numérica.",
                                  "commonMistakes": [
                                    "Ignorar que κ=1 é identidade perfeita",
                                    "Confundir com rank",
                                    "Não relacionar a autovalores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a matriz de rigidez real de uma estrutura",
                                  "subSteps": [
                                    "Gere matriz de rigidez de uma treliça simples (ex: 2 barras).",
                                    "Use sparse() para matrizes grandes e eficientes.",
                                    "Calcule κ e compare com pré-condicionamento.",
                                    "Visualize com spy(A) para esparsidade.",
                                    "Salve resultados em relatório PDF via publish()."
                                  ],
                                  "verification": "κ calculado para matriz real e relatório gerado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de matriz de treliça",
                                    "Função sparse() doc"
                                  ],
                                  "tips": "Estruturas reais têm K esparsa; use cond(full(K),'2') se necessário.",
                                  "learningObjective": "Aplicar em cenários reais de engenharia civil.",
                                  "commonMistakes": [
                                    "Não usar sparse para grandes matrizes",
                                    "Calcular cond em submatrizes erradas",
                                    "Ignorar unidades"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar o código para uso profissional",
                                  "subSteps": [
                                    "Crie função personalizada: function kappa = calcKappa(K).",
                                    "Adicione tratamento de erros com try-catch.",
                                    "Teste com múltiplas matrizes e plote κ vs tamanho.",
                                    "Otimize com pré-condicionadores como ichol().",
                                    "Compartilhe código via GitHub para revisão."
                                  ],
                                  "verification": "Função roda em batch sem crashes e otimiza κ.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MATLAB Profiler",
                                    "GitHub account"
                                  ],
                                  "tips": "Use vectorização para speed-up em loops.",
                                  "learningObjective": "Tornar implementação robusta e escalável.",
                                  "commonMistakes": [
                                    "Não tratar NaN/Inf",
                                    "Código não reutilizável",
                                    "Ignorar performance"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma treliça 2D com 2 nós e 1 barra: K = [k, -k; -k, k] onde k=EA/L. cond(K,'2') ≈1 (bem condicionado). Adicione nó com ângulo agudo: κ explode para >10^10, simulando colapso numérico em solvers FEM.",
                              "finalVerifications": [
                                "Código MATLAB executa sem erros para matrizes de rigidez variadas.",
                                "κ calculado bate com eigvals (sqrt(max/min)) dentro de 1% de tolerância.",
                                "Interpretação escrita identifica condicionamento bom/ruim corretamente.",
                                "Relatório inclui plots de spy(K) e valores de κ.",
                                "Função customizada aceita input sparse e retorna κ otimizado.",
                                "Testes com matrizes ill-condicionadas mostram warnings apropriados."
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo de cond(A,'2') comparado a manual.",
                                "Correta interpretação de κ em termos de sensibilidade estrutural.",
                                "Eficiência do código (tempo <1s para 1000x1000 sparse).",
                                "Robustez: lida com singular/mal-condicionadas.",
                                "Documentação clara com comentários e relatório.",
                                "Criatividade em aplicações reais (ex: pré-condicionamento)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Desenvolvimento de funções MATLAB reutilizáveis.",
                                "Análise Numérica: Teoria de autovalores e normas matriciais.",
                                "Engenharia Mecânica: Modelagem FEM de estruturas.",
                                "Estatística: Análise de sensibilidade e erros de propagação.",
                                "Computação Científica: Uso de solvers esparsos como pcg()."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios, engenheiros civis usam κ para validar matrizes de rigidez FEM antes de solver deslocamentos; κ alto sinaliza necessidade de refinar malha ou geometria, evitando falhas numéricas em softwares como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Interpretar resultados em contextos reais",
                            "description": "Analisar casos de estudo onde alto condicionamento causa perda de precisão em simulações de engenharia civil, propondo melhorias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e compreender um caso de estudo relevante",
                                  "subSteps": [
                                    "Identifique um caso de estudo em engenharia civil envolvendo simulações numéricas, como análise de elementos finitos (FEM) de uma estrutura de ponte ou edifício.",
                                    "Descreva o modelo matemático subjacente, incluindo as matrizes de rigidez envolvidas.",
                                    "Colete dados de entrada reais ou simulados, como geometria, materiais e cargas.",
                                    "Revise literatura ou relatórios sobre falhas conhecidas devido a condicionamento ruim.",
                                    "Documente o contexto real: condições ambientais, normas de construção e implicações de segurança."
                                  ],
                                  "verification": "Crie um resumo escrito do caso com diagrama esquemático e equações principais; verifique se cobre modelo, dados e contexto.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Artigos acadêmicos sobre FEM em engenharia civil, software como MATLAB ou ANSYS (versão trial), cadernos para anotações.",
                                  "tips": "Escolha casos reais de falhas estruturais documentadas, como o colapso de Tacoma Narrows, para maior relevância.",
                                  "learningObjective": "Compreender o problema no contexto de aplicações reais de engenharia civil.",
                                  "commonMistakes": "Ignorar dados reais e usar apenas exemplos teóricos simplificados; superestimar a generalidade sem contexto específico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e analisar o condicionamento da matriz",
                                  "subSteps": [
                                    "Extraia a matriz de rigidez ou similar do modelo do caso de estudo.",
                                    "Calcule o número de condicionamento (cond(A) = ||A|| * ||A^{-1}||) usando normas adequadas (ex: 2-norma).",
                                    "Identifique elementos com altos valores de condicionamento e singularidades próximas.",
                                    "Compare com thresholds aceitáveis (ex: cond < 10^6 para precisão double).",
                                    "Visualize com gráficos de autovalores ou decomposição SVD."
                                  ],
                                  "verification": "Gere relatório com valores de cond, gráficos e interpretação; confira se cond > 10^8 indica problema grave.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB/Python com NumPy/SciPy, planilhas para dados iniciais, tutoriais SVD.",
                                  "tips": "Use funções built-in como cond() no MATLAB para rapidez inicial, depois implemente manualmente para compreensão.",
                                  "learningObjective": "Quantificar o impacto do condicionamento na estabilidade numérica.",
                                  "commonMistakes": "Usar norma errada (ex: 1-norma em vez de 2-norma para FEM); ignorar escala da matriz."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar perda de precisão nos resultados da simulação",
                                  "subSteps": [
                                    "Execute a simulação com matriz original e compare com solução exata ou referência bem condicionada.",
                                    "Meça erros relativos em deslocamentos, tensões e reações (ex: ||x - x_exact|| / ||x_exact||).",
                                    "Correlacione erros com o valor de condicionamento e perturbações de entrada.",
                                    "Analise propagação de erros em componentes críticos da estrutura.",
                                    "Simule ruído real (ex: medições imprecisas) para demonstrar amplificação."
                                  ],
                                  "verification": "Produza tabela/gráficos de erros vs. cond; demonstre que erros crescem com cond alto.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Software FEM (ex: FreeFEM, CalculiX), dados do caso de estudo, ferramentas de plotagem (Matplotlib).",
                                  "tips": "Perturbe entradas em 1e-6 e observe saídas; foque em modos de falha estrutural.",
                                  "learningObjective": "Interpretar numericamente como condicionamento ruim afeta precisão em contextos reais.",
                                  "commonMistakes": "Comparar apenas com soluções analíticas irreais; negligenciar erros de arredondamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Propor e validar melhorias no condicionamento",
                                  "subSteps": [
                                    "Sugira pré-condicionadores (ex: diagonal, ILU) ou reescalonamento da matriz.",
                                    "Aplique técnicas como refinamento de malha ou ortogonalização.",
                                    "Reexecute simulação com melhorias e compare métricas de precisão e tempo computacional.",
                                    "Justifique viabilidade no contexto real (custo, tempo de projeto).",
                                    "Documente trade-offs e recomendações para engenheiros civis."
                                  ],
                                  "verification": "Relatório final com antes/depois: redução em cond e erros; proposta implementável.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Mesmos do step 2-3, mais documentação de pré-condicionadores (ex: PETSc manual).",
                                  "tips": "Priorize métodos simples como escalonamento para protótipos rápidos.",
                                  "learningObjective": "Desenvolver soluções práticas para mitigar problemas de condicionamento.",
                                  "commonMistakes": "Propor métodos caros sem considerar contexto de engenharia civil prática."
                                }
                              ],
                              "practicalExample": "Em uma simulação FEM de uma ponte pênsil com malha irregular, cond(K) = 10^12 causa erros de 20% em tensões críticas perto das torres. Após escalonamento diagonal, cond cai para 10^5, erros para <1%, evitando subestimação de fadiga.",
                              "finalVerifications": [
                                "Explicar verbalmente como alto cond amplifica erros em simulações civis.",
                                "Apresentar gráficos de erros vs. cond para o caso analisado.",
                                "Propor pelo menos duas melhorias viáveis com justificativa quantitativa.",
                                "Identificar riscos reais de segurança ignorados por precisão ruim.",
                                "Comparar resultados melhorados com normas como Eurocode 0.",
                                "Simular variação de parâmetros reais e mostrar robustez."
                              ],
                              "assessmentCriteria": [
                                "Profundidade na análise de cond e erros (30%)",
                                "Relevância do caso de estudo ao contexto civil (20%)",
                                "Qualidade e viabilidade das propostas de melhoria (25%)",
                                "Uso correto de ferramentas numéricas e visualizações (15%)",
                                "Clareza na documentação e correlação com mundo real (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de erros de propagação e intervalos de confiança.",
                                "Programação: Implementação eficiente de solvers numéricos em Python/MATLAB.",
                                "Física Estrutural: Modelagem de rigidez e dinâmica em FEM.",
                                "Gestão de Projetos: Avaliação de custo-benefício em simulações."
                              ],
                              "realWorldApplication": "Em projetos de edifícios altos ou pontes, onde matrizes FEM mal condicionadas por malhas finas levam a erros em análises sísmicas, causando redesigns caros ou riscos de colapso; engenheiros usam essas análises para otimizar malhas e pré-condicionadores, economizando milhões em validações físicas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Relacionar com Matriz de Gram",
                            "description": "Explicar como a matriz de Gram G = AᵀA possui κ(G) = [κ(A)]², e sua relevância em mínimos quadrados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Matrizes e Condicionamento",
                                  "subSteps": [
                                    "Defina matriz de Gram como G = AᵀA para uma matriz A m×n.",
                                    "Explique o número de condicionamento κ(A) = σ_max(A)/σ_min(A), onde σ são valores singulares.",
                                    "Discuta o impacto de alto condicionamento em soluções numéricas.",
                                    "Revise transposta Aᵀ e propriedades de simetria positiva definida de G.",
                                    "Identifique quando A é mal condicionada e implicações para G."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e forneça um exemplo simples de A e G.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang), calculadora matricial ou Python/NumPy"
                                  ],
                                  "tips": "Use notação consistente e visualize com gráficos de valores singulares.",
                                  "learningObjective": "Compreender definições básicas e sua interconexão.",
                                  "commonMistakes": [
                                    "Confundir κ com determinante",
                                    "Ignorar que G é simétrica",
                                    "Esquecer propriedades de autovalores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e Analisar a Matriz de Gram",
                                  "subSteps": [
                                    "Construa G = AᵀA para uma matriz A de exemplo 3x2.",
                                    "Calcule autovalores e valores singulares de A e G usando software.",
                                    "Verifique que G é simétrica e positiva semidefinida.",
                                    "Compare normas e condições iniciais.",
                                    "Explore decomposição SVD de A: A = UΣVᵀ, então G = VΣ²Vᵀ."
                                  ],
                                  "verification": "Mostre cálculos para um exemplo onde κ(A) ≈ 10, calcule κ(G).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy, MATLAB ou papel e lápis para pequeno exemplo"
                                  ],
                                  "tips": "Comece com matrizes pequenas para cálculo manual antes de código.",
                                  "learningObjective": "Dominar construção e propriedades algébricas de G.",
                                  "commonMistakes": [
                                    "Erro no cálculo de AᵀA",
                                    "Não normalizar colunas de A",
                                    "Confundir SVD com autovalores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Relação κ(G) = [κ(A)]²",
                                  "subSteps": [
                                    "Lembre que valores singulares de A são raízes quadradas dos autovalores de G.",
                                    "Mostre σ_max(G) = [σ_max(A)]² e σ_min(G) = [σ_min(A)]².",
                                    "Derive κ(G) = σ_max(G)/σ_min(G) = [σ_max(A)/σ_min(A)]² = [κ(A)]².",
                                    "Prove usando SVD: autovalores de G são σ_i².",
                                    "Discuta casos limites: A ortogonal (κ=1, G=I).",
                                    "Teste numericamente com matriz mal condicionada."
                                  ],
                                  "verification": "Escreva a prova formal e valide com exemplo numérico.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha de papel para derivação, Jupyter Notebook para verificação"
                                  ],
                                  "tips": "Use desigualdades de Rayleigh para intuição sobre extremos.",
                                  "learningObjective": "Derivar e provar a relação quadrática do condicionamento.",
                                  "commonMistakes": [
                                    "Esquecer raiz quadrada nos singulares",
                                    "Aplicar a matrizes não quadradas incorretamente",
                                    "Ignorar multiplicidade de autovalores zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Relevância em Problemas de Mínimos Quadrados",
                                  "subSteps": [
                                    "Recapitule mínimos quadrados: min ||Ax - b||², solução x = (AᵀA)^(-1)Aᵀb.",
                                    "Explique como κ(G) alto amplifica erros em x devido a [κ(A)]².",
                                    "Discuta regularização (ex: ridge) para mitigar.",
                                    "Aplique em contexto de engenharia: ajuste de dados de sensores.",
                                    "Simule numericamente estabilidade com ruído em b."
                                  ],
                                  "verification": "Resolva um sistema sobredeterminado e analise sensibilidade ao condicionamento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python para least squares (np.linalg.lstsq)",
                                    "Dados de exemplo de engenharia civil"
                                  ],
                                  "tips": "Adicione ruído pequeno e observe amplificação.",
                                  "learningObjective": "Conectar teoria à prática numérica em otimização.",
                                  "commonMistakes": [
                                    "Confundir solução normal com pseudoinversa",
                                    "Não considerar rank de A",
                                    "Subestimar impacto quadrático em erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 0], [1.0001, 0.001], [1.0002, 0.002]] (modelo linear mal condicionado, κ(A)≈1000). Calcule G=AᵀA, verifique κ(G)≈10^6. Resolva mínimos quadrados para b=[1,1.0001,1.0002]ᵀ; observe como pequeno ruído em b causa grande erro em x devido ao condicionamento elevado.",
                              "finalVerifications": [
                                "Deriva corretamente κ(G) = [κ(A)]² usando SVD.",
                                "Explica verbalmente o impacto quadrático em estabilidade numérica.",
                                "Implementa exemplo computacional mostrando amplificação de erros.",
                                "Identifica cenários onde isso afeta mínimos quadrados.",
                                "Propõe mitigação como preconditioning ou regularização.",
                                "Aplica a um problema de engenharia civil simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% correta).",
                                "Profundidade na análise numérica com exemplos.",
                                "Clareza na explicação da relevância para mínimos quadrados.",
                                "Uso correto de ferramentas computacionais.",
                                "Identificação de erros comuns e prevenções.",
                                "Conexão explícita com aplicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: SVD e autovalores.",
                                "Cálculo Numérico: Análise de erros e estabilidade.",
                                "Otimização: Problemas de mínimos quadrados e regularização.",
                                "Engenharia Computacional: Simulações em MATLAB/Python.",
                                "Estatística: Ajuste de regressão linear."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao analisar dados de deformação em estruturas via sensores (ex: monitoramento de pontes), usa-se mínimos quadrados para ajustar modelos lineares. Alto condicionamento em A (colunas quase colineares) leva a G com κ(G)=[κ(A)]² extremo, amplificando erros de medição e causando diagnósticos errôneos de falhas estruturais; regularização é essencial para soluções confiáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Definição da Matriz de Gram",
                    "description": "Matriz simétrica positiva definida pelos produtos internos entre vetores de uma base.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Produto Interno",
                        "description": "O produto interno é uma operação bilinear simétrica definida em um espaço vetorial que generaliza o produto escalar, permitindo medir ângulos e comprimentos entre vetores.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Definir produto interno",
                            "description": "Explicar a definição formal de produto interno em espaços vetoriais reais, incluindo propriedades como simetria, linearidade e definitude positiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Espaços Vetoriais Reais",
                                  "subSteps": [
                                    "Revise a definição de espaço vetorial real (R^n).",
                                    "Identifique operações básicas: soma e multiplicação por escalar.",
                                    "Discuta exemplos comuns como R^2 e R^3.",
                                    "Explique o papel de produtos internos em espaços vetoriais.",
                                    "Diferencie produto interno de produto vetorial."
                                  ],
                                  "verification": "Resuma em suas palavras o que é um espaço vetorial real e liste 3 exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (capítulo de espaços vetoriais)",
                                    "Vídeo introdutório sobre vetores em Khan Academy"
                                  ],
                                  "tips": "Use diagramas para visualizar vetores em R^2.",
                                  "learningObjective": "Entender o contexto onde o produto interno é definido.",
                                  "commonMistakes": [
                                    "Confundir espaço vetorial com subespaço",
                                    "Ignorar que é sobre reais (não complexos)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente o Produto Interno",
                                  "subSteps": [
                                    "Estude a definição: função <.,.> : V x V → R bilinear, simétrica e definida positivamente.",
                                    "Escreva a notação matemática: <u,v> = <v,u>, <au + bv, w> = a<u,w> + b<v,w>.",
                                    "Identifique o produto escalar padrão em R^n: <u,v> = sum u_i v_i.",
                                    "Pratique escrevendo a definição para n=2.",
                                    "Compare com axiomas de norma induzida."
                                  ],
                                  "verification": "Escreva a definição formal completa e prove simetria para um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Software como MATLAB ou Python (NumPy) para testar"
                                  ],
                                  "tips": "Memorize os 3 axiomas principais: simetria, linearidade, definitude positiva.",
                                  "learningObjective": "Dominar a definição axiomática do produto interno.",
                                  "commonMistakes": [
                                    "Esquecer bilinearidade em ambos os argumentos",
                                    "Confundir com definitude semi-positiva"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar as Propriedades Essenciais",
                                  "subSteps": [
                                    "Prove simetria: <u,v> = <v,u>.",
                                    "Demonstre linearidade em ambos os argumentos com exemplos numéricos.",
                                    "Verifique definitude positiva: <u,u> ≥ 0 e =0 iff u=0.",
                                    "Calcule norma induzida: ||u|| = sqrt(<u,u>).",
                                    "Discuta ortogonalidade: <u,v>=0 implica perpendiculares."
                                  ],
                                  "verification": "Aplique as propriedades a vetores u=[1,0], v=[0,1] em R^2.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora ou Python script para produtos escalares",
                                    "Quadro branco para provas"
                                  ],
                                  "tips": "Use contraexemplos para propriedades falhas (ex: em espaços não euclidianos).",
                                  "learningObjective": "Aplicar e provar as propriedades fundamentais.",
                                  "commonMistakes": [
                                    "Achar que linearidade é só no primeiro argumento",
                                    "Ignorar o caso <u,u>=0 só para u=0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conectar à Matriz de Gram e Aplicações Iniciais",
                                  "subSteps": [
                                    "Defina matriz de Gram G_{ij} = <e_i, e_j> para base {e_i}.",
                                    "Calcule G para base canônica em R^2.",
                                    "Relacione com condicionamento de matrizes.",
                                    "Discuta como produto interno generaliza o escalar padrão.",
                                    "Explore em contextos de engenharia: rigidez em estruturas."
                                  ],
                                  "verification": "Construa a matriz de Gram para dois vetores em R^3 e verifique simetria.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy para gram_matrix",
                                    "Exercícios de Álgebra Linear"
                                  ],
                                  "tips": "Sempre verifique se a matriz resultante é simétrica positiva definida.",
                                  "learningObjective": "Integrar o conceito à matriz de Gram no contexto de engenharia civil.",
                                  "commonMistakes": [
                                    "Confundir produto interno com autovalores da Gram",
                                    "Usar base não ortonormal sem ajuste"
                                  ]
                                }
                              ],
                              "practicalExample": "Em R^2, para u = [3, 4] e v = [1, 2], o produto interno padrão é <u,v> = 3*1 + 4*2 = 11. Verifique simetria (<v,u>=11), linearidade (2u,v=22) e ||u||=5.",
                              "finalVerifications": [
                                "Defina corretamente o produto interno com todos os axiomas.",
                                "Prove simetria e linearidade para vetores genéricos.",
                                "Calcule corretamente norma e ortogonalidade.",
                                "Construa matriz de Gram para base simples.",
                                "Explique definitude positiva com contraexemplo.",
                                "Relacione ao condicionamento em engenharia."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% dos axiomas).",
                                "Corretude nas provas de propriedades (sem erros algébricos).",
                                "Exemplos numéricos precisos e verificados.",
                                "Conexão clara com matriz de Gram.",
                                "Uso correto de notação matemática.",
                                "Explicação intuitiva das propriedades."
                              ],
                              "crossCurricularConnections": [
                                "Física: Trabalho como produto escalar de força e deslocamento.",
                                "Probabilidade: Esperança como produto interno em espaços L2.",
                                "Computação: Algoritmos de otimização (gradiente descendente).",
                                "Engenharia: Análise de elementos finitos para estruturas civis.",
                                "Estatística: Covariância como produto interno centrado."
                              ],
                              "realWorldApplication": "Na engenharia civil, o produto interno define a matriz de rigidez em métodos de elementos finitos, permitindo simular deformações em pontes e edifícios sob cargas, avaliando estabilidade via condicionamento da Gram."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Calcular produto interno em R^n",
                            "description": "Computar o produto interno padrão entre dois vetores em R^n e generalizar para produtos internos definidos por matrizes positivas definidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Produto Interno Padrão em R^n",
                                  "subSteps": [
                                    "Revise a definição formal: Para vetores u = (u₁, ..., uₙ) e v = (v₁, ..., vₙ) em R^n, o produto interno padrão é ⟨u, v⟩ = Σ_{i=1}^n u_i v_i.",
                                    "Liste as propriedades principais: simetria (⟨u, v⟩ = ⟨v, u⟩), linearidade em cada argumento, e positivo definido (⟨u, u⟩ ≥ 0, com igualdade iff u=0).",
                                    "Visualize geometricamente: o produto interno mede similaridade angular via ⟨u, v⟩ = ||u|| ||v|| cosθ.",
                                    "Discuta normas induzidas: ||u|| = √⟨u, u⟩.",
                                    "Exemplo em R^2: Para u=(1,0), v=(0,1), ⟨u,v⟩=0 (ortogonais)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as 3 propriedades principais e compute ⟨u,u⟩ para u=(1,2).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Papel e lápis ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Associe o produto interno à projeção de v sobre u para intuição geométrica.",
                                  "learningObjective": "Compreender a definição e propriedades do produto interno padrão em R^n.",
                                  "commonMistakes": [
                                    "Confundir com produto vetorial (ortogonalidade em 3D)",
                                    "Esquecer que é soma de produtos componentes, não produto de normas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar o Produto Interno Padrão entre Vetores em R^n",
                                  "subSteps": [
                                    "Selecione dois vetores u e v em R^n (n=2 a 5 para prática inicial).",
                                    "Calcule componente por componente: u_i * v_i para i=1 a n.",
                                    "Some os resultados: ⟨u, v⟩ = u₁v₁ + ... + uₙvₙ.",
                                    "Verifique ortogonalidade: ⟨u,v⟩=0 implica vetores perpendiculares.",
                                    "Pratique com n=3: u=(1,2,3), v=(4,-5,6), compute passo a passo."
                                  ],
                                  "verification": "Forneça pelo menos 3 exemplos corretos de cálculos em R^2, R^3 e R^4.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB com dot(u,v)",
                                    "Folha de exercícios com vetores aleatórios"
                                  ],
                                  "tips": "Use uma tabela para alinhar componentes u_i e v_i antes de multiplicar.",
                                  "learningObjective": "Executar cálculos precisos de produto interno padrão manualmente e via software.",
                                  "commonMistakes": [
                                    "Erro aritmético em somas longas",
                                    "Índices errados em vetores (começar de 0 em vez de 1)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Produto Interno Generalizado via Matriz Positiva Definida",
                                  "subSteps": [
                                    "Defina ⟨u, v⟩_A = u^T A v, onde A é matriz simétrica positiva definida (n x n).",
                                    "Verifique propriedades: ainda simétrico, linear, positivo definido se autovalores de A >0.",
                                    "Construa A simples: diagonal com entradas positivas (ex: A=diag(1,2)).",
                                    "Relacione com norma: ||u||_A = √(u^T A u), usada em otimização.",
                                    "Exemplo: Em R^2, A=[[2,1],[1,2]], compute ⟨u,v⟩_A para u=(1,0), v=(0,1)."
                                  ],
                                  "verification": "Prove que ⟨u,u⟩_A >0 para u≠0 e liste condições para A positiva definida.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software para autovalores (MATLAB eig(A))",
                                    "Notas sobre matrizes simétricas"
                                  ],
                                  "tips": "A é 'métrica interna' que pondera direções diferentemente.",
                                  "learningObjective": "Generalizar produto interno usando matrizes positivas definidas e suas propriedades.",
                                  "commonMistakes": [
                                    "Esquecer transposição u^T",
                                    "Usar A não simétrica ou não positiva definida"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar Produto Interno Generalizado e Aplicar em Contexto",
                                  "subSteps": [
                                    "Escolha A positiva definida (verifique autovalores >0).",
                                    "Compute A v primeiro (multiplicação matriz-vetor).",
                                    "Então u^T (A v) via produto escalar.",
                                    "Pratique com contexto de engenharia: A como matriz de rigidez em estruturas.",
                                    "Compare ⟨u,v⟩ padrão vs ⟨u,v⟩_A para mesmos u,v."
                                  ],
                                  "verification": "Calcule corretamente ⟨u,v⟩_A para 2 exemplos, incluindo verificação de autovalores.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "MATLAB/Python (numpy.dot(u, A@v))",
                                    "Gerador de matrizes aleatórias positivas definidas"
                                  ],
                                  "tips": "Decomponha A = L L^T (Cholesky) para computação numérica estável.",
                                  "learningObjective": "Executar cálculos de produto interno generalizado com precisão numérica.",
                                  "commonMistakes": [
                                    "Erro na ordem de multiplicação (u^T A v ≠ v^T A u se não simétrica)",
                                    "A não positiva definida levando a normas imaginárias"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise estrutural civil, considere vetores de deslocamentos u=[1, 0.5]^T e forças v=[2, 1]^T em R^2. Com matriz de rigidez A=[[3,1],[1,2]] (positiva definida), compute ⟨u,v⟩_A = u^T A v = [1,0.5] [[3,1],[1,2]] [2,1]^T = 4.5, representando energia de deformação ponderada.",
                              "finalVerifications": [
                                "Calcule corretamente ⟨u,v⟩ padrão para 5 pares de vetores em R^3.",
                                "Construa e verifique uma matriz A 2x2 positiva definida.",
                                "Compute ⟨u,v⟩_A para u,v em R^2 com A dada, matching software.",
                                "Explique por que produto interno generalizado é útil em condicionamento de matrizes.",
                                "Identifique ortogonalidade em ambos os produtos internos.",
                                "Liste 3 aplicações em engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos (erro <1e-6).",
                                "Compreensão conceitual das propriedades (explicação clara).",
                                "Uso correto de software para verificação.",
                                "Identificação de erros comuns e correções.",
                                "Conexão com contexto de matriz de Gram.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Trabalho mecânico como produto interno de força e deslocamento.",
                                "Estatística: Forma quadrática u^T Σ^{-1} u em distribuições multivariadas.",
                                "Computação: Similaridade cosseno em ML e kernels em SVM.",
                                "Otimização: Normas ponderadas em problemas quadráticos."
                              ],
                              "realWorldApplication": "Na engenharia civil, produtos internos generalizados via matriz de Gram (G = Φ^T A Φ, A rigidez) avaliam condicionamento em métodos de elementos finitos, otimizando simulações de estruturas como pontes contra vibrações."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Verificar propriedades do produto interno",
                            "description": "Verificar se uma forma bilinear dada satisfaz as propriedades de produto interno, como simetria (<u,v> = <v,u>) e <v,v> > 0 para v ≠ 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as propriedades fundamentais de um produto interno",
                                  "subSteps": [
                                    "Revise a definição formal de produto interno em espaços vetoriais reais: uma forma bilinear simétrica e definida positiva.",
                                    "Identifique as duas propriedades principais: simetria ⟨u,v⟩ = ⟨v,u⟩ para todos u,v, e ⟨v,v⟩ > 0 para todo v ≠ 0.",
                                    "Estude exemplos canônicos, como o produto escalar padrão em R^n: ⟨u,v⟩ = u · v = ∑ u_i v_i.",
                                    "Anote as implicações: simetria garante que a forma bilinear derive de uma matriz simétrica, e positividade garante autovalores positivos.",
                                    "Compare com formas bilineares gerais que não satisfazem essas propriedades."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases confirmando as propriedades e dê um contraexemplo de forma não simétrica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de álgebra linear (capítulo de produtos internos)",
                                    "Bloco de notas e caneta",
                                    "Acesso a Khan Academy ou vídeo tutorial sobre produtos internos"
                                  ],
                                  "tips": "Use analogias com distância euclidiana para intuitivamente entender a positividade.",
                                  "learningObjective": "Dominar as definições exatas e intuitivas das propriedades de produto interno.",
                                  "commonMistakes": "Confundir simetria com comutatividade em geral ou ignorar o caso v=0 na positividade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a propriedade de simetria da forma bilinear dada",
                                  "subSteps": [
                                    "Escreva a forma bilinear fornecida em termos de componentes: ⟨u,v⟩ = ∑∑ a_{ij} u_i v_j.",
                                    "Confirme se a matriz A = (a_{ij}) é simétrica, i.e., a_{ij} = a_{ji} para todos i,j.",
                                    "Substitua u e v por vetores basis padrão e teste ⟨e_i, e_j⟩ = ⟨e_j, e_i⟩.",
                                    "Calcule explicitamente ⟨u,v⟩ e ⟨v,u⟩ para vetores genéricos u=(u1,u2), v=(v1,v2) em R^2.",
                                    "Se não simétrica, pare e conclua que não é produto interno."
                                  ],
                                  "verification": "Mostre que ⟨u,v⟩ - ⟨v,u⟩ = 0 para pelo menos dois pares de vetores independentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como MATLAB/Octave para matrizes simbólicas",
                                    "Papel quadriculado para cálculos matriciais"
                                  ],
                                  "tips": "Represente a forma bilinear como u^T A v e verifique se A = A^T diretamente.",
                                  "learningObjective": "Aplicar teste algébrico e matricial para simetria de forma bilinear.",
                                  "commonMistakes": "Esquecer termos cruzados ou assumir simetria sem calcular a matriz associada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a propriedade de definitude positiva",
                                  "subSteps": [
                                    "Para a matriz simétrica A obtida, compute ⟨v,v⟩ = v^T A v para vários v ≠ 0.",
                                    "Teste vetores unitários e basis: verifique se todos autovalores de A são positivos.",
                                    "Use critério de Sylvester ou teste de Cholesky para definitude positiva.",
                                    "Escolha v aleatórios (ex: (1,0), (0,1), (1,1)) e confirme v^T A v > 0.",
                                    "Se encontrar qualquer v ≠ 0 com ⟨v,v⟩ ≤ 0, conclua falha."
                                  ],
                                  "verification": "Liste 3-5 vetores v ≠ 0 com ⟨v,v⟩ > 0 e confirme todos autovalores > 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software computacional (MATLAB, Python com NumPy para autovalores)",
                                    "Tabela de autovalores calculados"
                                  ],
                                  "tips": "Para dimensões baixas (n≤3), compute autovalores manualmente; para maiores, use software.",
                                  "learningObjective": "Dominar testes para definitude positiva via autovalores e formas quadráticas.",
                                  "commonMistakes": "Confundir semi-definida positiva (≥0) com definida positiva (>0), ou testar apenas v unitários."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a verificação e documentar resultados",
                                  "subSteps": [
                                    "Resuma resultados: simetria? (sim/não); positividade? (sim/não).",
                                    "Se ambas sim, afirme que é produto interno; caso contrário, identifique falha.",
                                    "Discuta implicações para matriz de Gram em condicionamento.",
                                    "Gere relatório com cálculos, matriz A, autovalores e conclusão.",
                                    "Teste com variação da forma para prática adicional."
                                  ],
                                  "verification": "Produza um relatório de 1 página com conclusão clara e evidências.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou LaTeX para relatório",
                                    "Gráficos de autovalores se aplicável"
                                  ],
                                  "tips": "Use tabelas para organizar testes de vetores e resultados.",
                                  "learningObjective": "Sintetizar verificações em conclusão acionável e documentada.",
                                  "commonMistakes": "Ignorar precisão numérica em software ou não testar v=0 explicitamente (deve ser 0)."
                                }
                              ],
                              "practicalExample": "Considere a forma bilinear em R^2: ⟨u,v⟩ = 2 u1 v1 + 3 u1 v2 + 3 u2 v1 + 4 u2 v2. Matriz A = [[2,3],[3,4]] (simétrica). Autovalores: resolvendo det(A - λI)=0, λ1≈0.23>0, λ2≈5.77>0. Teste: para v=(1,0), ⟨v,v⟩=2>0; v=(1,1), ⟨v,v⟩=2+6+4=12>0. Conclusão: é produto interno.",
                              "finalVerifications": [
                                "Matriz associada A é simétrica (A = A^T).",
                                "Todos autovalores de A são estritamente positivos.",
                                "⟨v,v⟩ > 0 computado para 5 vetores linearmente independentes.",
                                "⟨u,v⟩ = ⟨v,u⟩ verificado para pares basis.",
                                "Forma quadrática v^T A v é definida positiva via teste de Cholesky.",
                                "Conclusão correta documentada com contraexemplo se aplicável."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de simetria e matriz A (100% correto).",
                                "Correta identificação e computação de autovalores/autovalores positivos.",
                                "Número e diversidade de testes de vetores v (mínimo 5).",
                                "Clareza na documentação e conclusão lógica.",
                                "Uso apropriado de ferramentas computacionais sem erros numéricos.",
                                "Identificação de erros comuns evitados no processo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Produto escalar em mecânica vetorial e normas euclidianas.",
                                "Computação: Algoritmos de decomposição (Cholesky) em solvers numéricos.",
                                "Estatística: Covariância como produto interno em análise multivariada.",
                                "Engenharia de Materiais: Tensores de tensão simétricos e definitude em modelagem."
                              ],
                              "realWorldApplication": "Em engenharia civil, verificar propriedades de produto interno na matriz de Gram garante bom condicionamento em métodos dos elementos finitos para análise estrutural, evitando instabilidades numéricas em simulações de deformações e tensões em pontes ou edifícios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Base de Vetores",
                        "description": "Uma base é um conjunto de vetores linearmente independentes que gera todo o espaço vetorial, servindo como referência para coordenadas e representações matriciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Identificar uma base",
                            "description": "Determinar se um conjunto de vetores forma uma base em um espaço vetorial finito-dimensional, verificando independência linear e completude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de base, independência linear e dimensão",
                                  "subSteps": [
                                    "Defina base como conjunto de vetores linearmente independentes que geram o espaço vetorial.",
                                    "Recapitule independência linear: nenhum vetor é combinação linear dos outros; equivalente a rank igual ao número de vetores.",
                                    "Lembre que em espaço finito-dimensional V de dimensão m, uma base tem exatamente m vetores.",
                                    "Identifique o campo vetorial (geralmente ℝ) e o espaço V.",
                                    "Anote exemplos simples em ℝ² e ℝ³ para fixar."
                                  ],
                                  "verification": "Escreva definições corretas e exemplos em um papel ou documento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro ou notas de álgebra linear",
                                    "Video-aula rápida sobre bases"
                                  ],
                                  "tips": "Use analogia com 'pilares independentes que sustentam uma estrutura' para visualizar.",
                                  "learningObjective": "Dominar definições precisas para aplicação correta.",
                                  "commonMistakes": [
                                    "Confundir independência linear com ortogonalidade.",
                                    "Ignorar que base requer tanto independência quanto completude (spanning)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar a dimensão do espaço e contar os vetores",
                                  "subSteps": [
                                    "Identifique o espaço vetorial V (ex: ℝⁿ ou subespaço definido).",
                                    "Calcule ou recorde dim(V) = m (para ℝⁿ, m = n; para subespaços, use rank de geradores).",
                                    "Conte o número k de vetores no conjunto S.",
                                    "Verifique preliminarmente se k ≠ m; se não, S não pode ser base.",
                                    "Documente m e k em uma tabela."
                                  ],
                                  "verification": "Tabela com m e k corretos, e nota se k == m.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Descrição do problema"
                                  ],
                                  "tips": "Se V for coluna de matriz, dim(V) = rank da matriz.",
                                  "learningObjective": "Avaliar pré-condição numérica para base.",
                                  "commonMistakes": [
                                    "Assumir dim(V) = n sem verificar se V é subespaço.",
                                    "Contar vetores zero incorretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar independência linear do conjunto",
                                  "subSteps": [
                                    "Forme a matriz A ∈ ℝ^{m×k} com colunas sendo os vetores de S.",
                                    "Calcule o rank de A (redução a forma escalonada, ou use SVD/determinante se k=m quadrada).",
                                    "Verifique se rank(A) = k (independência linear).",
                                    "No contexto de matriz de Gram: compute G = AᵀA; se G positiva definida (autovalores >0), então ind lin.",
                                    "Use software para casos numéricos: numpy.linalg.matrix_rank(A) == k."
                                  ],
                                  "verification": "Rank ou autovalores confirmados iguais a k, com print ou anotação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora matricial ou app (GeoGebra)",
                                    "Python/NumPy ou MATLAB",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Para k=2 em ℝ², verifique se det ≠ 0; generalize com rank.",
                                  "learningObjective": "Aplicar testes computacionais para independência.",
                                  "commonMistakes": [
                                    "Esquecer transposição na matriz de Gram.",
                                    "Arredondamento numérico levando a rank falso."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir se o conjunto forma uma base e validar",
                                  "subSteps": [
                                    "Combine: se k == m E rank(A) == k, então S é base.",
                                    "Se não, identifique falha (ex: dependente ou incompleto).",
                                    "Teste spanning resolvendo A x = b para b arbitrário em V (solução única se base).",
                                    "No contexto engenharia: verifique condicionamento (cond(A) baixo ideal).",
                                    "Registre conclusão com justificativa."
                                  ],
                                  "verification": "Conclusão explícita 'É/Sim base' ou 'Não, porque...' com evidência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de álgebra linear",
                                    "Exemplo prático"
                                  ],
                                  "tips": "Bases canônicas facilitam verificação inicial.",
                                  "learningObjective": "Integrar condições para decisão final.",
                                  "commonMistakes": [
                                    "Concluir base só por k==m sem ind lin.",
                                    "Ignorar erros numéricos em computação."
                                  ]
                                }
                              ],
                              "practicalExample": "Em ℝ³ (dim=3), S = {[1,0,0]ᵀ, [0,1,0]ᵀ, [1,1,1]ᵀ}. k=3==3. Matriz A = [[1,0,1],[0,1,1],[0,0,1]]. Rank(A)=3 (det(A)=1≠0). Logo, base. Contraexemplo: adicione [1,1,1] como quarto vetor, k=4>3, não base.",
                              "finalVerifications": [
                                "Identificar corretamente se 5 conjuntos aleatórios formam base.",
                                "Explicar falhas em conjuntos não-base (ex: dependência ou k≠dim).",
                                "Computar matriz de Gram e confirmar ind lin via autovalores.",
                                "Resolver sistema A x = b e verificar unicidade.",
                                "Aplicar em subespaço de dimensão 2 em ℝ³.",
                                "Verificar condicionamento numérico da base proposta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na determinação de dim(V) e contagem k.",
                                "Correta construção e análise de rank ou det(A).",
                                "Uso apropriado de matriz de Gram no contexto.",
                                "Conclusão lógica integrando ambas condições.",
                                "Identificação de erros numéricos e comuns.",
                                "Clareza na documentação de passos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar rank em NumPy para automação em engenharia.",
                                "Física/Engenharia: Bases para transformação de coordenadas em análise estrutural.",
                                "Estatística: Bases ortonormais em PCA para dados de sensores civis.",
                                "Computação Numérica: Condicionamento afetando estabilidade em simulações FEM."
                              ],
                              "realWorldApplication": "Na engenharia civil, identificar bases em vetores de modos de vibração ou deslocamentos locais garante transformações coordenadas estáveis em análise de estruturas via MEF (Método dos Elementos Finitos), evitando singularidades em matrizes de rigidez."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Verificar independência linear",
                            "description": "Usar o determinante de matrizes ou redução de linhas para verificar se vetores são linearmente independentes em R^n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz de vetores e verificar dimensões",
                                  "subSteps": [
                                    "Liste os vetores fornecidos e identifique o espaço R^n (dimensão n).",
                                    "Forme a matriz A colocando os vetores como colunas (ou linhas, consistentemente).",
                                    "Confirme se a matriz é quadrada (m = n vetores em R^n) ou retangular.",
                                    "Verifique se o número de vetores k ≤ n.",
                                    "Anote as dimensões da matriz (k x n ou n x k)."
                                  ],
                                  "verification": "Matriz A formada corretamente com vetores como colunas e dimensões anotadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora gráfica ou software (MATLAB, Python com NumPy, Octave)"
                                  ],
                                  "tips": "Sempre use vetores coluna para padronização; transpose se necessário.",
                                  "learningObjective": "Formar corretamente a matriz associada a um conjunto de vetores.",
                                  "commonMistakes": [
                                    "Usar vetores como linhas em vez de colunas",
                                    "Confundir dimensões de R^n com número de vetores",
                                    "Esquecer de verificar k ≤ n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o determinante para matrizes quadradas",
                                  "subSteps": [
                                    "Se a matriz A é n x n (quadrada), compute det(A) usando expansão cofatora, regra de Sarrus (para 3x3) ou redução gaussiana.",
                                    "Aplique propriedades: det(A) = 0 se houver linha/coluna zero ou proporcional.",
                                    "Use software para verificação: em Python, np.linalg.det(A).",
                                    "Registre o valor exato ou aproximado de det(A).",
                                    "Se |det(A)| > ε (pequeno threshold numérico), prossiga."
                                  ],
                                  "verification": "Valor de det(A) calculado e != 0 (ou próximo de zero).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de cofatores",
                                    "Software de álgebra linear (NumPy, MATLAB)"
                                  ],
                                  "tips": "Para matrizes 2x2 ou 3x3, use fórmulas diretas para rapidez.",
                                  "learningObjective": "Aplicar métodos de cálculo de determinante para testar independência.",
                                  "commonMistakes": [
                                    "Erro de sinal em cofatores",
                                    "Ignorar precisão numérica em software",
                                    "Confundir det(A^T) com det(A)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar redução de linhas para matrizes gerais",
                                  "subSteps": [
                                    "Se A não é quadrada ou det=0, realize eliminação gaussiana em A.",
                                    "Conte o número de pivôs não-nulos (rank(A)).",
                                    "Compare rank(A) com o número de vetores k.",
                                    "Se rank(A) = k, os vetores são independentes; caso contrário, dependentes.",
                                    "Verifique com software: np.linalg.matrix_rank(A)."
                                  ],
                                  "verification": "Rank(A) determinado e comparado corretamente com k.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado para Gauss-Jordan",
                                    "Python/MATLAB para rank"
                                  ],
                                  "tips": "Pivoteie para evitar divisões por zero; normalize pivôs.",
                                  "learningObjective": "Usar escalonamento para determinar rank e independência.",
                                  "commonMistakes": [
                                    "Parar eliminação prematuramente",
                                    "Contar linhas zero como pivôs",
                                    "Confundir rank com dimensão do espaço"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e concluir independência",
                                  "subSteps": [
                                    "Resuma: independentes se det(A) != 0 (quadrada) ou rank(A) = k.",
                                    "Teste um vetor extra para confirmar (se aplicável).",
                                    "Discuta implicações: base se k=n e independente.",
                                    "Documente o processo em relatório curto.",
                                    "Valide com exemplo conhecido (ex: vetores canônicos)."
                                  ],
                                  "verification": "Conclusão explícita: 'independentes' ou 'dependentes' com justificativa.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Relatório template",
                                    "Exemplos de referência"
                                  ],
                                  "tips": "Sempre relacione com definição: combinação linear trivial só zero.",
                                  "learningObjective": "Interpretar corretamente resultados para decisão final.",
                                  "commonMistakes": [
                                    "Concluir independente se det≈0 por erro numérico",
                                    "Ignorar caso k<n",
                                    "Confundir independência com ortogonalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Verifique se v1=(1,0,0), v2=(0,1,0), v3=(1,1,0) são linearmente independentes em R^3. Forme A=[v1 v2 v3], compute det(A)=-1 !=0 → independentes. Para redução: rank(A)=2 <3 → dependentes? Não, det confirma.",
                              "finalVerifications": [
                                "Matriz A formada corretamente com vetores como colunas.",
                                "Determinante calculado precisamente para caso quadrado.",
                                "Rank determinado via Gauss para caso geral.",
                                "Conclusão matches definição teórica (rank=k).",
                                "Validação numérica com software coincide.",
                                "Relatório documenta passos e justificativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de det ou rank (90%+ acurácia).",
                                "Uso correto de métodos para dimensões variadas.",
                                "Identificação de erros numéricos ou comuns.",
                                "Clareza na interpretação e conclusão.",
                                "Eficiência temporal (dentro de 70 min total).",
                                "Documentação completa com fórmulas usadas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Independência de vetores força em equilíbrio estático.",
                                "Programação: Implementar em NumPy para análise de dados.",
                                "Engenharia Civil: Verificar bases para análise modal de estruturas.",
                                "Estatística: Colinearidade em regressão múltipla."
                              ],
                              "realWorldApplication": "Em engenharia civil, verificar se vetores de deslocamento em uma treliça são independentes para análise estrutural, evitando colapsos por dependências lineares em simulações computacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Definição e Construção da Matriz de Gram",
                        "description": "A matriz de Gram é a matriz simétrica positiva definida cuja entrada (i,j) é o produto interno entre o i-ésimo e j-ésimo vetores de uma base, usada no condicionamento de sistemas lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Construir matriz de Gram",
                            "description": "Dado um conjunto de vetores base {v1, ..., vn}, calcular a matriz G onde G_ij = <vi, vj>, implementando em software como MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais da Matriz de Gram",
                                  "subSteps": [
                                    "Revise a definição de produto interno em espaços vetoriais.",
                                    "Entenda que a Matriz de Gram G é definida por G_ij = <vi, vj> para vetores base {v1, ..., vn}.",
                                    "Identifique propriedades: simétrica, definida semi positiva.",
                                    "Estude exemplos manuais em R^2 ou R^3 para fixar o conceito.",
                                    "Discuta o papel no condicionamento de matrizes."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as propriedades da matriz G e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Notas de aula sobre produto interno",
                                    "Calculadora para exemplos manuais"
                                  ],
                                  "tips": "Comece com vetores ortogonais para simplificar os cálculos iniciais.",
                                  "learningObjective": "Dominar a definição teórica e propriedades da Matriz de Gram.",
                                  "commonMistakes": [
                                    "Confundir produto interno com produto escalar sem normalização.",
                                    "Ignorar que G é simétrica."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar a representação numérica dos vetores base",
                                  "subSteps": [
                                    "Colete o conjunto de vetores {v1, ..., vn} do problema.",
                                    "Represente cada vetor como uma linha ou coluna em uma matriz V (n x dim).",
                                    "Verifique dimensões: se vetores em R^m, V será n x m.",
                                    "Escolha uma base de exemplo se não fornecida.",
                                    "Normalize unidades se aplicável em contexto de engenharia."
                                  ],
                                  "verification": "Crie uma matriz V corretamente dimensionada e imprima para inspeção visual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para esboço",
                                    "Editor de texto ou MATLAB para digitação"
                                  ],
                                  "tips": "Use colunas para vetores em MATLAB para facilitar V*V'.",
                                  "learningObjective": "Preparar dados vetoriais de forma estruturada para computação.",
                                  "commonMistakes": [
                                    "Erros de transposição: vetores linha vs coluna.",
                                    "Dimensões incompatíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os elementos da matriz G manualmente",
                                  "subSteps": [
                                    "Compute <vi, vj> para cada par i,j de 1 a n.",
                                    "Para i=j, calcule a norma ao quadrado ||vi||^2.",
                                    "Preencha a matriz G linha por linha.",
                                    "Verifique simetria: G_ij = G_ji.",
                                    "Calcule determinante ou traço para validação inicial."
                                  ],
                                  "verification": "Compare G_ij com G_ji e normas na diagonal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou planilha Excel",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Faça cálculos para n=2 ou 3 primeiro para praticar.",
                                  "learningObjective": "Executar cálculos manuais precisos de produtos internos.",
                                  "commonMistakes": [
                                    "Esquecer de somar componentes no produto interno.",
                                    "Assinaturas erradas em vetores negativos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar a construção da Matriz de Gram em MATLAB",
                                  "subSteps": [
                                    "Defina a matriz V com os vetores como colunas: V = [v1 v2 ... vn];",
                                    "Calcule G = V' * V; (para produto interno padrão).",
                                    "Exiba G com format long para precisão.",
                                    "Adicione comentários no código explicando cada linha.",
                                    "Teste com dados de exemplo para validar."
                                  ],
                                  "verification": "Execute o script e confirme que G matches o cálculo manual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB ou Octave",
                                    "Script .m preparado"
                                  ],
                                  "tips": "Use spy(G) ou eig(G) para visualizar propriedades.",
                                  "learningObjective": "Programar eficientemente a Matriz de Gram em software numérico.",
                                  "commonMistakes": [
                                    "Usar V*V' em vez de V'*V para vetores colunas.",
                                    "Esquecer ponto no transpose."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e analisar a Matriz de Gram construída",
                                  "subSteps": [
                                    "Verifique se G é simétrica com norm(G - G').",
                                    "Calcule autovalores: deve ser não-negativos.",
                                    "Compare condicionamento cond(G) com o de V.",
                                    "Teste com base mal condicionada para observar efeitos.",
                                    "Documente resultados em relatório curto."
                                  ],
                                  "verification": "Gere relatório confirmando propriedades e precisão numérica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MATLAB com funções eig e cond"
                                  ],
                                  "tips": "Use tolerâncias como 1e-10 para comparações de simetria.",
                                  "learningObjective": "Analisar robustez e validade da implementação.",
                                  "commonMistakes": [
                                    "Ignorar erros de arredondamento em MATLAB.",
                                    "Não testar com casos extremos."
                                  ]
                                }
                              ],
                              "practicalExample": "Dado vetores em R^3: v1 = [1, 0, 0]', v2 = [1, 1, 0]', v3 = [1, 1, 1]'. No MATLAB: V = [1 1 1; 0 1 1; 0 0 1]; G = V'*V; Resultado: G = [1 1 1; 1 2 2; 1 2 3].",
                              "finalVerifications": [
                                "A matriz G é simétrica e G_ij = <vi, vj>.",
                                "Diagonal contém ||vi||^2 corretos.",
                                "Implementação MATLAB reproduz cálculo manual com erro < 1e-10.",
                                "Autovalores de G são não-negativos.",
                                "Código é comentado e reutilizável.",
                                "Testado com pelo menos dois conjuntos de vetores."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos manuais (100% correto).",
                                "Correção do código MATLAB (executa sem erros).",
                                "Validação completa de propriedades.",
                                "Eficiência computacional (O(n^2) implícito).",
                                "Clareza na documentação e exemplos.",
                                "Análise de condicionamento incluída."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Produto interno e ortogonalidade.",
                                "Programação Numérica: MATLAB para álgebra matricial.",
                                "Análise Numérica: Condicionamento e estabilidade.",
                                "Engenharia Civil: Modelagem de estruturas e decomposições.",
                                "Física: Análise de vetores em mecânica."
                              ],
                              "realWorldApplication": "Na engenharia civil, a Matriz de Gram é usada em métodos de elementos finitos para verificar condicionamento de bases vetoriais em simulações estruturais, otimizando soluções computacionais em softwares como ANSYS ou MATLAB para análise de estabilidade de pontes e edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.2",
                              "10.1.2.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Verificar simetria da matriz de Gram",
                            "description": "Demonstrar que a matriz de Gram é simétrica (G = G^T) usando propriedades do produto interno e calcular sua transposta para confirmação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e construção da matriz de Gram",
                                  "subSteps": [
                                    "Recordar que a matriz de Gram G é definida para um conjunto de vetores {v1, v2, ..., vn} como G_ij = <vi, vj>, onde < , > é o produto interno.",
                                    "Construir um exemplo simples com 2-3 vetores em R^2 ou R^3, calculando cada entrada G_ij.",
                                    "Listar as dimensões da matriz G (n x n para n vetores).",
                                    "Verificar se todos os elementos diagonais G_ii são positivos (norma ao quadrado).",
                                    "Anotar a fórmula geral para qualquer produto interno euclidiano."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito como G_ij é calculado e apresentar um exemplo preenchido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Notas sobre produto interno"
                                  ],
                                  "tips": "Comece com vetores ortogonais simples para facilitar os cálculos iniciais.",
                                  "learningObjective": "Compreender a estrutura da matriz de Gram baseada em produtos internos.",
                                  "commonMistakes": [
                                    "Confundir G_ij com a distância entre vetores",
                                    "Usar produto escalar sem normalizar",
                                    "Esquecer que é n x n para n vetores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar propriedades do produto interno relevantes para simetria",
                                  "subSteps": [
                                    "Recordar a propriedade de simetria do produto interno: <u, v> = <v, u> para qualquer u, v.",
                                    "Demonstrar essa propriedade com dois vetores arbitrários no exemplo anterior.",
                                    "Discutir por que isso implica que G_ij = <vi, vj> = <vj, vi> = G_ji.",
                                    "Verificar a propriedade em todos os pares off-diagonal do exemplo.",
                                    "Anotar que isso vale para produtos internos reais (não complexos)."
                                  ],
                                  "verification": "Provar que <u,v> = <v,u> expandindo a definição e mostrar aplicação em G_ij vs G_ji.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo de vetores do Step 1",
                                    "Definição formal de produto interno"
                                  ],
                                  "tips": "Use a expansão bilinear: <u,v> = sum u_k v_k = <v,u>.",
                                  "learningObjective": "Entender como a simetria do produto interno induz simetria na matriz de Gram.",
                                  "commonMistakes": [
                                    "Assumir simetria sem propriedade do produto interno",
                                    "Confundir com conjugado em espaços complexos",
                                    "Ignorar sinal em produtos internos indefinidos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular explicitamente a transposta da matriz de Gram",
                                  "subSteps": [
                                    "Recordar que a transposta G^T tem (G^T)_ij = G_ji.",
                                    "Usando o exemplo, escrever a matriz G e computar G^T trocando linhas por colunas.",
                                    "Calcular numericamente cada entrada de G^T e compará-la com G_ij.",
                                    "Verificar diagonal: (G^T)_ii = G_ii (sempre simétrico).",
                                    "Usar software para confirmar se disponível."
                                  ],
                                  "verification": "Apresentar G e G^T lado a lado, mostrando igualdade elemento a elemento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz G do exemplo",
                                    "Calculadora ou Python com NumPy para matrizes maiores"
                                  ],
                                  "tips": "Para matrizes 3x3+, use índice i,j sistematicamente para evitar erros manuais.",
                                  "learningObjective": "Dominar o cálculo da transposta e sua relação com simetria.",
                                  "commonMistakes": [
                                    "Errar na troca de índices (confundir i,j)",
                                    "Arredondamentos em cálculos decimais",
                                    "Esquecer elementos off-diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar simetria teoricamente e praticamente (G = G^T)",
                                  "subSteps": [
                                    "Provar formalmente: (G^T)_ij = G_ji = <vj, vi> = <vi, vj> = G_ij, usando simetria do produto interno.",
                                    "No exemplo, somar diferenças |G_ij - G_ji| e verificar se é zero.",
                                    "Discutir implicações: G é simétrica positiva semidefinida.",
                                    "Testar com outro conjunto de vetores não ortogonais.",
                                    "Documentar a prova em poucas linhas."
                                  ],
                                  "verification": "Escrever a prova completa e mostrar que G - G^T = matriz nula no exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Prova escrita",
                                    "Dois exemplos de matrizes de Gram"
                                  ],
                                  "tips": "A prova é curta: foque na cadeia de igualdades do produto interno.",
                                  "learningObjective": "Demonstrar e provar que toda matriz de Gram é simétrica.",
                                  "commonMistakes": [
                                    "Prova incompleta sem menção ao produto interno",
                                    "Testar só diagonal",
                                    "Usar vetores linearmente dependentes sem notar"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere vetores v1 = [1, 0]^T, v2 = [1, 1]^T em R^2 com produto interno euclidiano. G = [[<v1,v1>, <v1,v2>], [<v2,v1>, <v2,v2>]] = [[1, 1], [1, 2]]. Transposta G^T = [[1, 1], [1, 2]] = G, confirmando simetria.",
                              "finalVerifications": [
                                "G_ij = G_ji para todos i ≠ j.",
                                "Matriz G - G^T é a matriz nula.",
                                "Prova teórica usando <vi,vj> = <vj,vi> está correta e completa.",
                                "Todos elementos diagonais G_ii ≥ 0.",
                                "Exemplo prático calculado sem erros aritméticos.",
                                "Testado com pelo menos dois conjuntos de vetores diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de produtos internos e transposta (100% correto).",
                                "Clareza e correção da prova teórica (uso explícito da simetria do produto interno).",
                                "Capacidade de generalizar para qualquer conjunto de vetores.",
                                "Identificação correta de propriedades adicionais (ex: diagonal positiva).",
                                "Eficiência no uso de exemplos para ilustração.",
                                "Ausência de erros comuns como confusão de índices."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Propriedades de matrizes simétricas e autovalores reais.",
                                "Análise Numérica: Condicionamento e decomposição QR envolvendo Gram.",
                                "Programação: Implementação em NumPy/Python para verificação automática (np.allclose(G, G.T)).",
                                "Física: Produtos internos em mecânica vetorial para análise estrutural.",
                                "Estatística: Matriz de Gram em regressão e mínimos quadrados."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao resolver sistemas lineares em métodos dos elementos finitos para análise estrutural, a simetria da matriz de Gram garante estabilidade numérica em projeções ortogonais e ajustes de dados experimentais de deformações, evitando erros de condicionamento em simulações de pontes ou edifícios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Provar positiva definida",
                            "description": "Provar que a matriz de Gram é positiva definida para bases linearmente independentes, mostrando que todos os autovalores são positivos ou usando forma quadrática x^T G x = ||∑ x_i v_i||^2 > 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições de matriz de Gram e positiva definida",
                                  "subSteps": [
                                    "Defina a matriz de Gram G para uma base linearmente independente {v₁, v₂, ..., vₙ} como G_{ij} = ⟨v_i, v_j⟩, onde ⟨·,·⟩ é o produto interno.",
                                    "Explique que uma matriz simétrica A é positiva definida se xᵀ A x > 0 para todo x ≠ 0.",
                                    "Lembre que bases linearmente independentes em espaço euclidiano geram subespaços onde normas são bem definidas.",
                                    "Verifique simetria de G (Gᵀ = G) e que é definida não-negativa inicialmente.",
                                    "Discuta o papel do condicionamento em contextos computacionais."
                                  ],
                                  "verification": "Escreva as definições no caderno e confirme com um exemplo simples de 2 vetores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de álgebra linear (ex: Strang)",
                                    "Caderno e caneta",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Use notação consistente para produto interno; comece com dimensão baixa (n=2) para intuição.",
                                  "learningObjective": "Compreender os conceitos fundamentais e sua interconexão.",
                                  "commonMistakes": "Confundir positiva definida com semidefinida; esquecer simetria de G."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a forma quadrática xᵀ G x",
                                  "subSteps": [
                                    "Escreva x = [x₁, ..., xₙ]ᵀ e compute xᵀ G x = ∑_{i,j} x_i x_j ⟨v_i, v_j⟩.",
                                    "Reconheça isso como ⟨∑_i x_i v_i, ∑_j x_j v_j⟩ pelo bilinearidade do produto interno.",
                                    "Defina u = ∑_i x_i v_i, então xᵀ G x = ⟨u, u⟩ = ||u||².",
                                    "Confirme que ||u||² ≥ 0 sempre, pela definição de norma euclidiana.",
                                    "Teste com um vetor x específico em uma base pequena."
                                  ],
                                  "verification": "Derive a igualdade xᵀ G x = ||∑ x_i v_i||² algebricamente e numéricamente para n=2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software simbólico como SymPy ou Mathematica",
                                    "Exemplos de bases"
                                  ],
                                  "tips": "Expanda explicitamente para n=2 para visualizar; evite saltar passos na bilinearidade.",
                                  "learningObjective": "Dominar a derivação da forma quadrática associada à Gram.",
                                  "commonMistakes": "Erro na expansão da soma dupla; ignorar propriedades do produto interno."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar estrita positividade para x ≠ 0",
                                  "subSteps": [
                                    "Mostre que ||u||² = 0 implica u = 0, pela propriedade da norma.",
                                    "Prove que u = ∑ x_i v_i = 0 implica x = 0, pois {v_i} é base linearmente independente.",
                                    "Conclua que xᵀ G x > 0 para x ≠ 0, definindo G positiva definida.",
                                    "Discuta alternativa via autovalores: G simétrica, traço positivo, determinantes principais positivos.",
                                    "Verifique numericamente com autovalores em software."
                                  ],
                                  "verification": "Escreva a prova completa e compute autovalores de G para uma base exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software numérico (MATLAB, Python com NumPy)",
                                    "Tabela de autovalores"
                                  ],
                                  "tips": "Use contrapositiva para LI: se soma zero, coefs zero; teste com dependentes para contraste.",
                                  "learningObjective": "Estabelecer a prova rigorosa de positividade definida.",
                                  "commonMistakes": "Assumir LI sem provar implicação; confundir com ortonormalidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e generalizar a prova",
                                  "subSteps": [
                                    "Generalize para qualquer espaço euclidiano finito-dimensional.",
                                    "Discuta implicações para condicionamento: G bem condicionada se base quase ortogonal.",
                                    "Construa G para uma base em Engenharia Civil (ex: vetores de deslocamento).",
                                    "Resolva exercício: prove para n=3 com vetores não-ortogonais.",
                                    "Reflita sobre aplicações computacionais."
                                  ],
                                  "verification": "Aplique a prova a um exemplo novo e confirme todos autovalores >0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de problemas estruturais",
                                    "Python/Jupyter notebook"
                                  ],
                                  "tips": "Sempre normalize vetores para checar; use eig() em software.",
                                  "learningObjective": "Aplicar e estender a prova com confiança.",
                                  "commonMistakes": "Generalizar sem rigor; ignorar dimensão finita."
                                }
                              ],
                              "practicalExample": "Considere base em ℝ²: v₁ = [1, 0]ᵀ, v₂ = [1, 1]ᵀ. G = [[1,1],[1,2]]. Para x = [1,1]ᵀ, u = [2,1]ᵀ, ||u||² = 5 >0. Compute xᵀ G x = 5 diretamente. Autovalores: ≈0.38, 2.62 >0. Verifique para x=[1,0]ᵀ: ||v₁||²=1>0.",
                              "finalVerifications": [
                                "Deriva corretamente xᵀ G x = ||∑ x_i v_i||².",
                                "Prova que ||u||² >0 iff x≠0 usando LI.",
                                "Confirma todos autovalores positivos numericamente.",
                                "Explica simetria e propriedades de G.",
                                "Aplica a um exemplo concreto sem erros.",
                                "Discute implicações para condicionamento."
                              ],
                              "assessmentCriteria": [
                                "Prova algébrica rigorosa e sem lacunas (40%).",
                                "Correção na derivação da forma quadrática (20%).",
                                "Uso correto de linear independência (15%).",
                                "Verificação numérica com autovalores (15%).",
                                "Clareza e organização da explicação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Condicionamento e estabilidade em solvers lineares.",
                                "Física/Mecânica: Formas quadráticas em energia potencial de estruturas.",
                                "Estatística: Matriz de covariância como Gram em PCA.",
                                "Computação: Otimização quadrática e SVD."
                              ],
                              "realWorldApplication": "Em análise de elementos finitos para estruturas civis, matrizes de rigidez derivam de Gram de funções base, garantindo positividade definida para simulações estáveis de deslocamentos e estresses em pontes ou edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.3.1",
                              "10.1.2.3.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Propriedades da Matriz de Gram",
                    "description": "Simetria, definitude positiva e relação com normas e ângulos entre vetores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Simetria da Matriz de Gram",
                        "description": "A matriz de Gram é simétrica por construção, pois o produto interno entre vetores é comutativo, implicando G = G^T, o que facilita análises numéricas e propriedades espectrais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Definir a matriz de Gram e demonstrar sua simetria",
                            "description": "Construir a matriz de Gram G para um conjunto de vetores e provar matematicamente que G_ij = G_ji utilizando a propriedade de simetria do produto interno <u,v> = <v,u>.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição da Matriz de Gram",
                                  "subSteps": [
                                    "Revise o conceito de produto interno em espaços vetoriais: <u, v> = soma u_i * v_i para vetores em R^n.",
                                    "Defina formalmente a matriz de Gram G para um conjunto de vetores {v1, v2, ..., vk} como G_ij = <vi, vj>.",
                                    "Identifique que G é uma matriz k x k quadrada.",
                                    "Discuta o contexto: usada em condicionamento de matrizes para problemas computacionais em engenharia.",
                                    "Anote a fórmula em um caderno ou software matemático."
                                  ],
                                  "verification": "Escreva a definição exata da matriz de Gram e dê um exemplo com k=2 vetores unitários.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno ou editor LaTeX",
                                    "Livro de álgebra linear ou notas de aula",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Comece com vetores em R^2 para visualização intuitiva; use notação clara para índices i,j.",
                                  "learningObjective": "Compreender a construção conceitual da matriz de Gram a partir do produto interno.",
                                  "commonMistakes": [
                                    "Confundir com matriz de covariância",
                                    "Esquecer que é definida apenas para conjuntos finitos de vetores",
                                    "Ignorar o espaço vetorial subjacente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Matriz de Gram para um Conjunto de Vetores Específico",
                                  "subSteps": [
                                    "Escolha um conjunto de vetores, ex: v1 = [1,0], v2 = [1,1] em R^2.",
                                    "Calcule todos os produtos internos: G11 = <v1,v1>, G12 = <v1,v2>, G21 = <v2,v1>, G22 = <v2,v2>.",
                                    "Monte a matriz G explicitamente.",
                                    "Verifique numericamente se G12 ≈ G21 (devido a precisão finita).",
                                    "Repita com vetores em R^3 para prática."
                                  ],
                                  "verification": "Construa G para vetores dados e mostre os cálculos passo a passo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software como Python (NumPy) ou MATLAB para verificação",
                                    "Exemplos de vetores impressos"
                                  ],
                                  "tips": "Use vetores ortogonais primeiro para simplificar; automatize cálculos em código para eficiência.",
                                  "learningObjective": "Aplicar a definição para computar G manualmente e via software.",
                                  "commonMistakes": [
                                    "Erro aritmético em produtos internos",
                                    "Confundir linhas/colunas na montagem da matriz",
                                    "Usar produto escalar euclidiano incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar Matematicamente a Simetria da Matriz de Gram",
                                  "subSteps": [
                                    "Lembre a propriedade fundamental: <u,v> = <v,u> para todo produto interno.",
                                    "Para elementos genéricos, escreva G_ij = <vi, vj> e G_ji = <vj, vi>.",
                                    "Conclua que G_ij = G_ji pela propriedade de simetria.",
                                    "Discuta implicações: G é simétrica positiva-semidefinida.",
                                    "Escreva a prova formal em notação matemática."
                                  ],
                                  "verification": "Escreva e recite a prova de duas linhas demonstrando G_ij = G_ji.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel para prova",
                                    "Referência de álgebra linear (ex: Strang)",
                                    "LaTeX ou editor de equações"
                                  ],
                                  "tips": "Mantenha a prova concisa; generalize para espaços vetoriais reais ou complexos se aplicável.",
                                  "learningObjective": "Dominar a prova da simetria usando apenas propriedades do produto interno.",
                                  "commonMistakes": [
                                    "Assumir simetria sem prova",
                                    "Confundir com propriedades de matrizes ortogonais",
                                    "Ignorar casos de vetores linearmente dependentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar a Simetria em Contextos Práticos",
                                  "subSteps": [
                                    "Usando o exemplo anterior, confirme G12 = G21 numericamente.",
                                    "Discuta uso em decomposição QR ou SVD para condicionamento.",
                                    "Crie um conjunto de vetores não ortogonais e verifique simetria.",
                                    "Explore det(G) >= 0 como consequência.",
                                    "Registre observações em um relatório curto."
                                  ],
                                  "verification": "Mostre um exemplo onde simetria é verificada e discuta uma implicação prática.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software numérico (Python/MATLAB)",
                                    "Conjuntos de vetores de teste"
                                  ],
                                  "tips": "Use tolerância numérica (1e-10) para comparações; teste com vetores mal-condicionados.",
                                  "learningObjective": "Integrar teoria e prática, reconhecendo simetria em aplicações reais.",
                                  "commonMistakes": [
                                    "Desconsiderar erros de arredondamento",
                                    "Não testar com dimensões maiores",
                                    "Confundir simetria com ortogonalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para vetores v1 = [1, 0, 0], v2 = [1, 1, 0] em R^3: G = [[1, 1], [1, 2]]. Note G12 = <v1,v2> = 1 = <v2,v1> = G21, confirmando simetria. Em engenharia civil, isso surge ao computar Gram para bases de funções de forma em elementos finitos.",
                              "finalVerifications": [
                                "Defina corretamente G_ij e prove G_ij = G_ji em menos de 2 minutos.",
                                "Construa G para 3 vetores arbitrários sem erros aritméticos.",
                                "Explique verbalmente a ligação com simetria do produto interno.",
                                "Identifique G como simétrica positiva-semidefinida.",
                                "Aplique em um exemplo numérico com software, verificando simetria.",
                                "Discuta uma aplicação em condicionamento de matrizes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e construção de G (30%)",
                                "Correção e clareza da prova de simetria (25%)",
                                "Exemplos práticos computados corretamente (20%)",
                                "Compreensão de implicações (positiva-semidefinida) (15%)",
                                "Uso adequado de ferramentas numéricas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Produto interno em mecânica quântica e vetores de força.",
                                "Computação: Algoritmos de Gram-Schmidt para ortogonalização numérica.",
                                "Estatística: Matriz de covariância como caso especial de Gram.",
                                "Engenharia de Software: Implementação em bibliotecas como SciPy para análise de dados."
                              ],
                              "realWorldApplication": "Na engenharia civil, matrizes de Gram são usadas em métodos dos elementos finitos (MEF) para condicionamento de sistemas lineares em simulações estruturais, garantindo estabilidade numérica ao resolver equações de equilíbrio sob cargas, onde a simetria facilita solvers eficientes como Cholesky."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Verificar simetria numericamente em MATLAB",
                            "description": "Implementar código em MATLAB para gerar vetores aleatórios, calcular a matriz de Gram e verificar se G - G' é numericamente zero dentro de tolerância máquina.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente MATLAB e gerar vetores aleatórios",
                                  "subSteps": [
                                    "Abra o MATLAB e limpe o workspace com clc e clear.",
                                    "Defina dimensões: n = 5 (dimensão do espaço), m = 3 (número de vetores).",
                                    "Gere matriz A de n x m com entradas aleatórias: A = randn(n, m);",
                                    "Exiba A com disp(A) para visualização inicial."
                                  ],
                                  "verification": "Matriz A é exibida corretamente com tamanho n x m e valores aleatórios não nulos.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "MATLAB instalado",
                                    "Documentação de randn()"
                                  ],
                                  "tips": [
                                    "Use randn para distribuição normal, mais realista que rand.",
                                    "Salve o script como verifica_simetria.m para reutilização."
                                  ],
                                  "learningObjective": "Entender geração de vetores aleatórios em MATLAB para simular dados de engenharia.",
                                  "commonMistakes": [
                                    "Esquecer de definir n e m adequadamente.",
                                    "Usar rand em vez de randn, levando a distribuições uniformes inadequadas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a matriz de Gram",
                                  "subSteps": [
                                    "Calcule G = A' * A usando multiplicação matricial.",
                                    "Exiba G com disp(G) e verifique dimensões com size(G).",
                                    "Confirme que G é quadrada m x m.",
                                    "Calcule o traço de G para verificação básica de positividade."
                                  ],
                                  "verification": "G é exibida como matriz m x m simétrica aproximada, com elementos positivos no diagonal.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "MATLAB",
                                    "Conhecimento básico de álgebra linear"
                                  ],
                                  "tips": [
                                    "Use A'*A diretamente; evite loops para eficiência.",
                                    "A matriz de Gram sempre satisfaz G >= 0 por construção."
                                  ],
                                  "learningObjective": "Dominar o cálculo da matriz de Gram e suas propriedades fundamentais.",
                                  "commonMistakes": [
                                    "Confundir A*A' com A'*A (dimensões erradas).",
                                    "Não transpor corretamente A'."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar simetria numericamente",
                                  "subSteps": [
                                    "Calcule a diferença D = G - G';",
                                    "Defina tolerância tol = eps * norm(G, 'fro') ou tol = 1e-12;",
                                    "Calcule a norma de D: norm_D = norm(D, 'fro');",
                                    "Verifique se norm_D < tol e exiba o resultado com fprintf."
                                  ],
                                  "verification": "A condição norm_D < tol é verdadeira e exibida na tela.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "MATLAB funções: norm(), eps",
                                    "Documentação de normas matriciais"
                                  ],
                                  "tips": [
                                    "Use norma de Frobenius ('fro') para matrizes.",
                                    "eps é a tolerância máquina padrão (~2.22e-16)."
                                  ],
                                  "learningObjective": "Aplicar verificação numérica de simetria considerando erros de arredondamento.",
                                  "commonMistakes": [
                                    "Usar == para comparação exata (falha por floating-point).",
                                    "Escolher tolerância muito pequena ou grande."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar robustez e interpretar resultados",
                                  "subSteps": [
                                    "Repita o processo com diferentes m e n (ex: n=10, m=5).",
                                    "Teste com vetores linearmente dependentes adicionando ruído.",
                                    "Plote heatmaps de G e D com imagesc para visualização.",
                                    "Documente os valores de norm_D e tol em um relatório no script."
                                  ],
                                  "verification": "Testes múltiplos confirmam simetria em casos variados; plots mostram D próxima de zero.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "MATLAB plotting: imagesc, colorbar",
                                    "Scripts anteriores"
                                  ],
                                  "tips": [
                                    "Aumente m para observar condicionamento.",
                                    "Salve figuras com saveas(gcf, 'gram_sym.png')."
                                  ],
                                  "learningObjective": "Avaliar estabilidade numérica da simetria em cenários realistas.",
                                  "commonMistakes": [
                                    "Ignorar dependência linear afetando condicionamento.",
                                    "Não normalizar tolerância pela norma de G."
                                  ]
                                }
                              ],
                              "practicalExample": "Gere A = randn(4,3); G = A'*A; D = G - G'; tol = eps*norm(G,'fro'); if norm(D,'fro') < tol, disp('Simétrica numericamente!'), end. Resultado: norma(D) ≈ 1e-15 < tol.",
                              "finalVerifications": [
                                "Código executa sem erros em múltiplas execuções.",
                                "Norma de G - G' consistentemente abaixo da tolerância máquina.",
                                "Matriz G possui diagonal positiva e é quadrada.",
                                "Visualizações confirmam simetria visual.",
                                "Testes com dimensões variadas passam na verificação.",
                                "Relatório fprintf exibe valores quantitativos claros."
                              ],
                              "assessmentCriteria": [
                                "Correção no cálculo de G = A'*A.",
                                "Uso apropriado de tolerância baseada em eps e norm.",
                                "Verificação numérica em vez de exata.",
                                "Inclusão de testes de robustez.",
                                "Código limpo, comentado e reproduzível.",
                                "Interpretação correta de resultados numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Propriedades de produto interno e simetria.",
                                "Programação Numérica: Erros de floating-point e normas.",
                                "Engenharia Computacional: Análise de condicionamento em FEM.",
                                "Estatística: Geração de dados aleatórios e simulações.",
                                "Visualização de Dados: Heatmaps para inspeção matricial."
                              ],
                              "realWorldApplication": "Na engenharia civil, matrizes de Gram surgem em métodos de elementos finitos para rigidez estrutural; verificar simetria numericamente garante estabilidade em simulações de análise modal e otimização de estruturas, evitando erros de propagação em solvers iterativos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Relacionar simetria com condicionamento",
                            "description": "Explicar como a simetria da matriz de Gram contribui para o bom condicionamento em problemas de minimos quadrados na engenharia civil, como análise estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de simetria em matrizes e matriz de Gram",
                                  "subSteps": [
                                    "Defina simetria matricial: A = A^T.",
                                    "Construa uma matriz de Gram G = A^T A a partir de uma matriz A de rigidez em análise estrutural.",
                                    "Verifique simetria da matriz de Gram computando G - G^T.",
                                    "Explore propriedades: autovalores reais e positivos para G positiva definida.",
                                    "Calcule exemplos numéricos simples com MATLAB ou Python (NumPy)."
                                  ],
                                  "verification": "Construa uma matriz de Gram 3x3 simétrica e confirme A^T A = (A^T A)^T.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Python/NumPy ou MATLAB",
                                    "Exemplos de matrizes de rigidez"
                                  ],
                                  "tips": "Sempre transpose manualmente para visualizar a simetria.",
                                  "learningObjective": "Compreender por que matrizes de Gram são inerentemente simétricas.",
                                  "commonMistakes": "Confundir simetria com diagonalidade; simetria não implica diagonal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender condicionamento numérico de matrizes",
                                  "subSteps": [
                                    "Defina número de condicionamento cond(A) = ||A|| * ||A^{-1}||.",
                                    "Relacione com autovalores: cond(A) ≈ λ_max / λ_min para matrizes simétricas positivas definidas.",
                                    "Calcule cond para matrizes mal e bem condicionadas.",
                                    "Discuta impactos em minimos quadrados: sensibilidade a perturbações.",
                                    "Use software para plotar autovalores e cond."
                                  ],
                                  "verification": "Calcule cond para uma matriz diagonal com autovalores 1 e 1000, explicando o resultado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação NumPy/SciPy para svd e cond",
                                    "Calculadora matricial online"
                                  ],
                                  "tips": "Use decomposição SVD para cond preciso em software.",
                                  "learningObjective": "Identificar como spread de autovalores afeta condicionamento.",
                                  "commonMistakes": "Ignorar normas; cond depende da norma escolhida (use 2-norm)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar como simetria melhora condicionamento na matriz de Gram",
                                  "subSteps": [
                                    "Prove que simetria implica autovalores reais.",
                                    "Mostre que para G = A^T A, autovalores ≥0, e simetria preserva estabilidade.",
                                    "Compare cond de G simétrica vs não-simétrica em exemplos.",
                                    "Discuta ortogonalidade em QR e impacto em LS.",
                                    "Simule perturbações e meça variação em soluções LS.",
                                    "verification**: "
                                  ]
                                },
                                "Demonstre numericamente que cond(G) é menor que cond(A) para A retangular.",
                                "estimatedTime**: "
                              ]
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Definitude Positiva da Matriz de Gram",
                        "description": "A matriz de Gram é definida positiva (ou semidefinida) quando os vetores são linearmente independentes, garantindo estabilidade numérica em soluções computacionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Provar a definitude positiva",
                            "description": "Demonstrar que para vetores linearmente independentes, x^T G x = ||∑ x_i v_i||^2 > 0 para x ≠ 0, usando propriedades de normas euclidianas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições fundamentais: Matriz de Gram e definitude positiva",
                                  "subSteps": [
                                    "Defina a matriz de Gram G para um conjunto de vetores {v₁, v₂, ..., vₙ} como G_{ij} = ⟨v_i, v_j⟩, onde ⟨·,·⟩ é o produto interno euclidiano.",
                                    "Explique o que significa uma matriz ser definida positiva: para todo x ≠ 0, xᵀ G x > 0.",
                                    "Lembre que vetores linearmente independentes implicam que nenhuma combinação linear não-trivial ∑ x_i v_i = 0 com x ≠ 0.",
                                    "Escreva a norma euclidiana ||u||² = ⟨u, u⟩ > 0 para u ≠ 0.",
                                    "Confirme que o produto interno euclidiano satisfaz propriedades de positividade."
                                  ],
                                  "verification": "Escreva as definições em um papel e verifique se pode recitá-las sem consultar notas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel, lápis, livro de álgebra linear (capítulo sobre produtos internos)",
                                  "tips": "Use notação consistente: sempre ⟨u,v⟩ para produto interno e ||u|| para norma.",
                                  "learningObjective": "Compreender os conceitos pré-requisitos para a prova.",
                                  "commonMistakes": "Confundir matriz de Gram com matriz de covariância ou esquecer a independência linear."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expressar xᵀ G x em termos do produto interno",
                                  "subSteps": [
                                    "Escreva xᵀ G x = ∑_{i=1}^n ∑_{j=1}^n x_i G_{ij} x_j = ∑_{i,j} x_i ⟨v_i, v_j⟩ x_j.",
                                    "Reorganize como ⟨∑_i x_i v_i, ∑_j x_j v_j⟩ pela bilinearidade do produto interno.",
                                    "Defina u = ∑_{i=1}^n x_i v_i, então xᵀ G x = ⟨u, u⟩.",
                                    "Note que isso é independente da base, pois usa propriedades euclidianas.",
                                    "Simplifique para o caso de norma: xᵀ G x = ||u||²."
                                  ],
                                  "verification": "Derive a igualdade xᵀ G x = ||∑ x_i v_i||² algebricamente em uma folha.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, calculadora para verificação numérica opcional",
                                  "tips": "Expanda explicitamente para n=2 para visualizar: x₁² ⟨v1,v1⟩ + 2 x₁ x₂ ⟨v1,v2⟩ + x₂² ⟨v2,v2⟩ = ⟨x1 v1 + x2 v2, x1 v1 + x2 v2⟩.",
                                  "learningObjective": "Conectar a forma quadrática da matriz de Gram à norma euclidiana.",
                                  "commonMistakes": "Esquecer o fator 2 no termo cruzado ou não usar bilinearidade corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que u ≠ 0 para x ≠ 0 sob independência linear",
                                  "subSteps": [
                                    "Assuma por contradição que u = ∑ x_i v_i = 0 com x ≠ 0.",
                                    "Isso implicaria uma combinação linear não-trivial dos v_i igual a zero.",
                                    "Pela hipótese de linear independência, a única solução é x = 0, contradição.",
                                    "Portanto, u ≠ 0 sempre que x ≠ 0.",
                                    "Confirme com definição formal de independência linear."
                                  ],
                                  "verification": "Escreva a prova por contradição e identifique onde a independência é usada.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Papel, exemplos de vetores independentes (ex: v1=[1,0], v2=[0,1])",
                                  "tips": "Teste com x=[1,0]ᵀ: u=v1 ≠0; x=[1,1]ᵀ: u=v1+v2 ≠0.",
                                  "learningObjective": "Aplicar o conceito de independência linear à combinação não-trivial.",
                                  "commonMistakes": "Confundir independência com ortogonalidade ou esquecer a contradição."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a definitude positiva e verificar numericamente",
                                  "subSteps": [
                                    "Como u ≠ 0, ||u||² = ⟨u,u⟩ > 0 pela propriedade da norma euclidiana.",
                                    "Portanto, xᵀ G x = ||u||² > 0 para x ≠ 0.",
                                    "Verifique para x=0: u=0, xᵀ G x=0, satisfazendo semi-definitude.",
                                    "Calcule um exemplo numérico: vetores v1=[1,0]ᵀ, v2=[1,1]ᵀ; G = [[1,1],[1,2]]; teste x=[1,1]ᵀ.",
                                    "Confirme que todos autovalores de G são positivos (opcional, via decomposição)."
                                  ],
                                  "verification": "Escreva a conclusão completa da prova e compute ||u||² >0 para um x específico.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora ou software como MATLAB/Python para exemplo numérico",
                                  "tips": "Sempre normalize vetores para simplificar cálculos iniciais.",
                                  "learningObjective": "Finalizar a prova ligando norma positiva à forma quadrática.",
                                  "commonMistakes": "Ignorar o caso x=0 ou afirmar >0 sem justificar norma positiva."
                                }
                              ],
                              "practicalExample": "Considere vetores linearmente independentes em ℝ²: v₁ = [1, 0]ᵀ, v₂ = [0, 1]ᵀ. A matriz de Gram G = [[1,0],[0,1]] (identidade). Para x = [1, 1]ᵀ ≠ 0, u = [1,1]ᵀ, ||u||² = 2 > 0, e xᵀ G x = 2 > 0. Se adicionar v₃ = [1,1]ᵀ (dependente), G não seria definida positiva.",
                              "finalVerifications": [
                                "Pode derivar xᵀ G x = ||∑ x_i v_i||² sem erros?",
                                "Explica por que u ≠ 0 usando independência linear?",
                                "Verifica numericamente com 2-3 vetores que xᵀ G x > 0 para x ≠ 0?",
                                "Identifica o papel da norma euclidiana na prova?",
                                "Escreve a prova completa em menos de 5 minutos?",
                                "Distingue definitude positiva de semi-definida?"
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação de xᵀ G x = ||u||² (100% correto).",
                                "Uso correto de contradição para independência linear.",
                                "Clareza na ligação entre norma positiva e forma quadrática.",
                                "Inclusão de exemplo numérico com cálculo explícito.",
                                "Ausência de erros conceituais (ex: confundir com ortogonalidade).",
                                "Completude: cobre todos os casos (x≠0 e x=0)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Energia cinética em mecânica (formas quadráticas positivas).",
                                "Estatística: Matrizes de covariância positivas semi-definidas.",
                                "Computação: Condicionamento numérico em solvers de sistemas lineares.",
                                "Otimização: Mínimos locais em funções quadráticas convexas."
                              ],
                              "realWorldApplication": "Em engenharia civil, matrizes de Gram surgem em análise modal de estruturas; sua definitude positiva garante estabilidade numérica em métodos de elementos finitos para simular vibrações e rigidez, evitando soluções instáveis em softwares como ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Verificar autovalores positivos",
                            "description": "Calcular autovalores da matriz de Gram em software numérico e confirmar que todos são positivos, relacionando com estabilidade em métodos de resíduos ponderados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir ou obter a matriz de Gram",
                                  "subSteps": [
                                    "Identifique os vetores ou funções de base relevantes no problema de engenharia civil (ex: funções de forma em elementos finitos).",
                                    "Calcule os produtos internos necessários: para vetores φ_i e φ_j, compute ∫ φ_i φ_j dx ou soma equivalente.",
                                    "Monte a matriz G onde G_ij = <φ_i, φ_j>, garantindo simetria.",
                                    "Verifique dimensões e simetria manualmente para uma matriz pequena.",
                                    "Salve a matriz em formato numérico (array ou arquivo)."
                                  ],
                                  "verification": "Matriz é simétrica e positiva semi-definida visualmente; trace(G) > 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou planilha (Excel/Google Sheets); conhecimento de produtos internos.",
                                  "tips": "Use simetria para reduzir cálculos: G_ij = G_ji.",
                                  "learningObjective": "Compreender a construção da matriz de Gram a partir de bases.",
                                  "commonMistakes": "Esquecer normalização ou usar produto escalar errado (ex: euclidiano vs. L2)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de software numérico",
                                  "subSteps": [
                                    "Instale ou abra Python com bibliotecas NumPy e SciPy (ou MATLAB equivalente).",
                                    "Importe módulos: import numpy as np; from scipy.linalg import eig.",
                                    "Defina a matriz de Gram como array NumPy a partir dos valores calculados.",
                                    "Teste entrada com np.array([[...]]) e imprima shape e is_symmetric.",
                                    "Prepare script para computação de autovalores."
                                  ],
                                  "verification": "Matriz carregada corretamente: print(G) mostra valores esperados e G == G.T.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python 3+ com NumPy/SciPy (via Anaconda/Jupyter Notebook); ou MATLAB.",
                                  "tips": "Use Jupyter Notebook para visualização interativa de resultados.",
                                  "learningObjective": "Dominar setup de ferramentas computacionais para álgebra linear.",
                                  "commonMistakes": "Erro de sintaxe em arrays; importar biblioteca errada (ex: eigvals em vez de eig)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e extrair autovalores",
                                  "subSteps": [
                                    "Execute comando: eigenvalues = np.linalg.eigvals(G) ou [V, D] = eig(G).",
                                    "Ordene autovalores em ordem crescente: eigenvalues.sort().",
                                    "Imprima autovalores reais (parte imaginária deve ser zero para simétrica).",
                                    "Calcule mínimo: min_eig = np.min(eigenvalues.real).",
                                    "Registre todos os valores para análise."
                                  ],
                                  "verification": "Autovalores são reais e ordenados; len(eigenvalues) == G.shape[0].",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Script Python/Jupyter ou MATLAB script.",
                                  "tips": "Para matrizes grandes, use eigsh() do SciPy para autovalores menores eficientes.",
                                  "learningObjective": "Executar computação numérica de autovalores com precisão.",
                                  "commonMistakes": "Ignorar parte imaginária pequena devido a erros numéricos; não ordenar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar positividade e relacionar com estabilidade",
                                  "subSteps": [
                                    "Confirme todos autovalores > 0: assert np.all(eigenvalues.real > 0), 'Não positiva definida'.",
                                    "Calcule condição: cond = eigenvalues[-1]/eigenvalues[0]; cond < threshold (ex: 1e6).",
                                    "Interprete: positividade implica estabilidade em métodos de resíduos ponderados (ex: Galerkin).",
                                    "Documente relatório: liste autovalores, min_eig, e implicações para o problema.",
                                    "Teste sensibilidade alterando base e recalculando."
                                  ],
                                  "verification": "Relatório gerado confirma todos λ > 0 e discute estabilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo script; papel para documentação.",
                                  "tips": "Tolerância numérica: considere > 1e-10 como positivo.",
                                  "learningObjective": "Ligar propriedades espectrais à estabilidade numérica em engenharia.",
                                  "commonMistakes": "Confundir semi-definida (≥0) com definida (>0); ignorar condição numérica."
                                }
                              ],
                              "practicalExample": "Em análise de elementos finitos para uma viga, use funções de forma lineares φ1(x)=1-x, φ2(x)=x no [0,1]. Compute G = [[2/3, 1/2], [1/2, 2/3]]. Autovalores: ~0.166 e 1, ambos >0, confirmando base estável para método Galerkin.",
                              "finalVerifications": [
                                "Todos autovalores reais e positivos (min > 0).",
                                "Matriz simétrica validada (G == G.T).",
                                "Condição numérica razoável (<1e12).",
                                "Relatório relaciona positividade à estabilidade em resíduos ponderados.",
                                "Teste com variação na base confirma robustez.",
                                "Código executável sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da matriz de Gram (90% match com analítico).",
                                "Correta implementação computacional (autovalores exatos até 1e-10).",
                                "Análise qualitativa de positividade e estabilidade (clara e correta).",
                                "Uso eficiente de software (código limpo, comentado).",
                                "Documentação completa com interpretações.",
                                "Tratamento de erros numéricos (tolerâncias)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Teorema espectral para simétricas.",
                                "Programação: NumPy/SciPy para computação científica.",
                                "Engenharia Computacional: Estabilidade em FEM e métodos variacionais.",
                                "Análise Numérica: Condicionamento e precisão flutuante."
                              ],
                              "realWorldApplication": "Em simulações de estruturas civis via elementos finitos (ex: SAP2000 ou ANSYS), verificar definitude positiva da matriz de Gram garante convergência estável do método dos resíduos ponderados, evitando oscilações em análises dinâmicas de pontes ou edifícios."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Aplicar em problemas de engenharia civil",
                            "description": "Usar definitude positiva para justificar a convergência de algoritmos de otimização em ajuste de curvas para modelagem de estruturas civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de Matriz de Gram e Definitude Positiva",
                                  "subSteps": [
                                    "Defina Matriz de Gram como G = A^T A para uma matriz A de dados de entrada.",
                                    "Explique que G é sempre semi-definida positiva e condicione para definitude positiva (autovalores > 0).",
                                    "Discuta implicações em otimização: Hessiana positiva garante mínimo único e convergência de métodos como gradiente descendente.",
                                    "Verifique posto completo de A para garantir definitude positiva de G.",
                                    "Calcule autovalores de um exemplo simples de G 2x2."
                                  ],
                                  "verification": "Resolva um exercício manual confirmando todos autovalores positivos e x^T G x > 0 para x ≠ 0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de álgebra linear (ex: Strang), calculadora ou Python com NumPy.",
                                  "tips": "Use decomposição espectral para visualizar autovalores.",
                                  "learningObjective": "Compreender matematicamente por que G é definida positiva em contextos bem condicionados.",
                                  "commonMistakes": "Confundir semi-definida com definida positiva; ignorar singularidade de A."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar um problema de engenharia civil com ajuste de curvas",
                                  "subSteps": [
                                    "Escolha um caso: modelagem de deflexão de viga cantilever sob carga distribuída.",
                                    "Colete dados simulados: posições x e deflexões y medidas.",
                                    "Formule como regressão linear: y = A β + ε, onde A contém funções base (polinômios).",
                                    "Construa matriz de design A com colunas lineares, quadráticas etc.",
                                    "Verifique linear independência das colunas de A."
                                  ],
                                  "verification": "Gere A com posto completo e confirme rank(A) = número de parâmetros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python (SciPy), dados de exemplo de mecânica das estruturas.",
                                  "tips": "Use funções base ortogonais como Chebyshev para melhor condicionamento.",
                                  "learningObjective": "Traduzir problema físico em modelo matemático de mínimos quadrados.",
                                  "commonMistakes": "Escolher bases colineares levando a A singular; dados ruidosos sem normalização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular algoritmo de otimização para ajuste de curvas",
                                  "subSteps": [
                                    "Defina funcional custo J(β) = ||y - A β||^2 = β^T (A^T A) β - 2 β^T A^T y + const.",
                                    "Mostre gradiente ∇J = 2 A^T A β - 2 A^T y = 2 G β - 2 A^T y.",
                                    "Implemente gradiente descendente: β_{k+1} = β_k - α ∇J(β_k).",
                                    "Escolha α via backtracking ou fixed pequeno.",
                                    "Codifique iterações até convergência (||∇J|| < ε)."
                                  ],
                                  "verification": "Execute 10 iterações e plote J(k) decrescente.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com NumPy/Matplotlib, Jupyter Notebook.",
                                  "tips": "Normalise dados para α estável.",
                                  "learningObjective": "Implementar GD sabendo que G aparece na Hessiana.",
                                  "commonMistakes": "Passo α muito grande causando divergência; não inicializar β=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar convergência usando definitude positiva",
                                  "subSteps": [
                                    "Prove que Hessiana H = 2 G é definida positiva se G o é.",
                                    "Mostre contração: ||β_{k+1} - β*||_G ≤ κ ||β_k - β*||_G com κ <1.",
                                    "Use desigualdade: J(β_{k+1}) ≤ J(β_k) - c ||∇J||^2.",
                                    "Confirme numericamente autovalores de G >0 no modelo da viga.",
                                    "Discuta impacto de condicionamento ruim (autovalores próximos de zero)."
                                  ],
                                  "verification": "Escreva prova curta e verifique convergência em <50 iterações.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Papel para provas, Python para autovalores (np.linalg.eig).",
                                  "tips": "Lembre: convergência linear com taxa (1 - 1/cond(G)).",
                                  "learningObjective": "Ligar teoria espectral à garantia prática de convergência.",
                                  "commonMistakes": "Esquecer fator 2 na Hessiana; assumir G simétrica sem prova."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e analisar o modelo ajustado",
                                  "subSteps": [
                                    "Compare curva ajustada com dados originais (R^2, resíduos).",
                                    "Simule resposta estrutural com β otimizado.",
                                    "Teste sensibilidade variando ruído em y.",
                                    "Compare com solução analítica da viga (deflexão = w x^4 / (8 E I)).",
                                    "Documente relatório com gráficos e conclusões."
                                  ],
                                  "verification": "R^2 > 0.95 e resíduos aleatórios (teste Shapiro-Wilk).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Matplotlib para plots, SciPy para stats.",
                                  "tips": "Use cross-validation para robustez.",
                                  "learningObjective": "Avaliar qualidade do ajuste em contexto engenheiro.",
                                  "commonMistakes": "Overfitting com polinômios altos; ignorar unidades físicas."
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever de 5m com carga uniforme w=10kN/m, dados de deflexão em 6 pontos: ajuste polinômio cúbico via GD, usando G definida positiva para convergir em 20 iterações a β ≈ [0, 0, w/(24EI), wL/(8EI)], validando com teoria de Euler-Bernoulli.",
                              "finalVerifications": [
                                "Autovalores de G todos > 1e-10.",
                                "Convergência de GD em <50 iterações com J final <1e-6.",
                                "R^2 do ajuste >0.98 em dados de viga simulados.",
                                "Prova escrita ligando definitude positiva à redução quadrática de J.",
                                "Resíduos independentes e normalmente distribuídos.",
                                "Aplicação preditiva acerta deflexão máxima dentro de 5% do analítico."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da prova de convergência (30%).",
                                "Implementação funcional e eficiente do GD (25%).",
                                "Qualidade do modelo físico (ajuste preciso, interpretação β) (20%).",
                                "Análise numérica (autovalores, condicionamento) (15%).",
                                "Relatório claro com gráficos e conclusões (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição espectral e autovalores.",
                                "Cálculo Numérico: Métodos iterativos de otimização.",
                                "Mecânica das Estruturas: Teoria de vigas e modelagem.",
                                "Programação: Implementação em Python/NumPy.",
                                "Estatística: Regressão e validação de modelos."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios, modela deformações reais de elementos sob carga para simulações FEM, garantindo convergência rápida em software como ANSYS ou SAP2000, otimizando designs seguros e econômicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Relação com Normas e Ângulos entre Vetores",
                        "description": "A matriz de Gram codifica normas dos vetores na diagonal e cossenos de ângulos nos elementos fora da diagonal, permitindo análise geométrica em espaços vetoriais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Extrair normas dos vetores da diagonal",
                            "description": "Identificar que G_ii = ||v_i||^2 e implementar função para extrair normas a partir da matriz de Gram em contextos de análise numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de produto interno e norma de vetores",
                                  "subSteps": [
                                    "Defina o produto interno <u, v> = u^T v para vetores coluna.",
                                    "Explique que a norma euclidiana ||v|| = sqrt(<v, v>).",
                                    "Identifique que <v_i, v_i> representa a norma ao quadrado do vetor i.",
                                    "Calcule exemplos manuais para 2-3 vetores simples em R^2.",
                                    "Discuta o papel no contexto de matrizes de Gram."
                                  ],
                                  "verification": "Resolva 3 exercícios manuais de cálculo de normas e compare com sqrt(<v,v>).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno e calculadora",
                                    "Documentação de álgebra linear básica"
                                  ],
                                  "tips": "Sempre normalize os vetores para verificar cálculos unitários.",
                                  "learningObjective": "Compreender a relação fundamental entre produto interno e norma.",
                                  "commonMistakes": "Confundir norma com produto interno entre vetores diferentes; esquecer o sqrt na norma."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a matriz de Gram e sua diagonal",
                                  "subSteps": [
                                    "Construa a matriz G onde G_ij = <v_i, v_j> para um conjunto de vetores {v1, ..., vn}.",
                                    "Observe que elementos da diagonal G_ii = <v_i, v_i> = ||v_i||^2.",
                                    "Prove matematicamente por que a diagonal captura as normas ao quadrado.",
                                    "Gere uma matriz de Gram exemplo usando vetores lineares independentes.",
                                    "Analise propriedades simétricas e positivas semi-definidas da G."
                                  ],
                                  "verification": "Construa G para 3 vetores e confirme que diag(G) = [||v1||^2, ||v2||^2, ...].",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Editor de código como Jupyter Notebook"
                                  ],
                                  "tips": "Use np.dot(v_i, v_i) para validar G_ii manualmente.",
                                  "learningObjective": "Identificar explicitamente a relação G_ii = ||v_i||^2 na matriz de Gram.",
                                  "commonMistakes": "Usar produto escalar não euclidiano; ignorar que G é simétrica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar função para extrair normas da diagonal",
                                  "subSteps": [
                                    "Defina uma função def extrair_normas_gram(G): que recebe matriz G (numpy array).",
                                    "Extraia a diagonal com np.diag(G).",
                                    "Calcule normas como np.sqrt(np.diag(G)).",
                                    "Adicione verificações: G simétrica e diagonal não-negativa.",
                                    "Retorne array de normas com docstring explicativa."
                                  ],
                                  "verification": "Teste a função com matriz G conhecida e compare com normas calculadas diretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3+ com NumPy",
                                    "Jupyter Notebook para testes"
                                  ],
                                  "tips": "Use np.linalg.norm(v_i) como benchmark para validação.",
                                  "learningObjective": "Desenvolver código eficiente para extração de normas de G.",
                                  "commonMistakes": "Esquecer sqrt, resultando em normas ao quadrado; não tratar G não quadrada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar a função em contextos numéricos",
                                  "subSteps": [
                                    "Crie conjunto de teste com vetores ruidosos simulando dados reais.",
                                    "Meça precisão numérica com np.allclose entre função e np.linalg.norm.",
                                    "Teste casos edge: vetores nulos, G singular.",
                                    "Analise tempo de execução para matrizes grandes (n=1000).",
                                    "Documente resultados em relatório curto."
                                  ],
                                  "verification": "Todos testes passam com tolerância 1e-10; relatório confirma corretude.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy, Matplotlib para plots opcionais",
                                    "Script de testes unitários"
                                  ],
                                  "tips": "Use pytest para automação de testes.",
                                  "learningObjective": "Garantir robustez da implementação em cenários reais de análise numérica.",
                                  "commonMistakes": "Ignorar erros de precisão flutuante; não testar vetores zero."
                                }
                              ],
                              "practicalExample": "Dado vetores v1 = [3, 4], v2 = [1, 0, 0], matriz G = [[25, 3], [3, 1]]. A função deve retornar [5.0, 1.0], pois sqrt(25)=5 e sqrt(1)=1, correspondendo às normas ||v1||=5 e ||v2||=1.",
                              "finalVerifications": [
                                "Função retorna array com sqrt(G_ii) exato para G de teste.",
                                "Verificação de simetria: np.allclose(G, G.T).",
                                "Normas de vetores nulos retornam 0.0.",
                                "Precisão numérica mantida para matrizes 100x100.",
                                "Docstring completa descrevendo entrada/saída.",
                                "Código comentado explicando G_ii = ||v_i||^2."
                              ],
                              "assessmentCriteria": [
                                "Corretude matemática: G_ii = ||v_i||^2 implementado precisamente.",
                                "Eficiência computacional: O(n) tempo para extração.",
                                "Robustez: Trata entradas inválidas (não quadrada, não simétrica).",
                                "Clareza do código: Nomes descritivos e comentários.",
                                "Testes abrangentes: Cobertura de casos normais e edge.",
                                "Documentação: Explicação da relação teórica."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposições como QR e SVD usam Gram.",
                                "Programação: Desenvolvimento de funções numéricas em Python/NumPy.",
                                "Análise Numérica: Condicionamento e estabilidade de algoritmos.",
                                "Física/Engenharia: Normas de vetores de forças ou deslocamentos em estruturas."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao analisar estruturas via método dos elementos finitos, a matriz de Gram é usada para ortonormalizar vetores de modos de vibração; extrair normas da diagonal permite normalizar amplitudes para avaliação de condicionamento e estabilidade numérica em simulações de dinâmica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Calcular ângulos via elementos off-diagonal",
                            "description": "Calcular cos θ_ij = G_ij / sqrt(G_ii G_jj) e interpretar orthogonalidade (θ=90°) em bases para métodos de Monte Carlo em engenharia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Produto Interno e Normas",
                                  "subSteps": [
                                    "Defina produto interno entre dois vetores v_i e v_j como <v_i, v_j> = soma de v_i[k] * v_j[k].",
                                    "Explique a norma de um vetor ||v_i|| = sqrt(<v_i, v_i>) = sqrt(G_ii).",
                                    "Relacione com o cosseno do ângulo: cos θ_ij = <v_i, v_j> / (||v_i|| ||v_j||)."
                                  ],
                                  "verification": "Escreva as definições corretas e derive cos θ_ij a partir do produto interno.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel, calculadora, notas sobre álgebra linear básica.",
                                  "tips": "Visualize vetores em R^2 para intuição geométrica.",
                                  "learningObjective": "Compreender a base geométrica da fórmula envolvendo elementos da Matriz de Gram.",
                                  "commonMistakes": "Confundir produto interno com produto escalar ponto sem normalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e Interpretar a Matriz de Gram G",
                                  "subSteps": [
                                    "Dado um conjunto de vetores {v1, v2, ..., vn}, calcule G_ij = <v_i, v_j> para i,j=1 a n.",
                                    "Identifique elementos diagonais G_ii = ||v_i||^2 e off-diagonal G_ij para i≠j.",
                                    "Verifique propriedades: G é simétrica positiva semidefinida.",
                                    "verification\": "
                                  ]
                                }
                              ]
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Interpretar geometricamente em problemas reais",
                            "description": "Aplicar a relação para analisar dependência linear em vetores de deslocamentos em simulações estruturais civis usando redes neurais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar interpretação geométrica da Matriz de Gram e dependência linear",
                                  "subSteps": [
                                    "Estude a definição da Matriz de Gram G = V^T V, onde V são vetores de deslocamento.",
                                    "Interprete os elementos diagonais como normas ao quadrado (comprimentos dos vetores).",
                                    "Analise elementos fora da diagonal como produtos internos (cosseno do ângulo vezes normas).",
                                    "Identifique dependência linear: vetores ortogonais (G diagonal), colineares (determinante zero).",
                                    "Visualize geometricamente em 2D/3D: ângulos de 0°/180° indicam dependência."
                                  ],
                                  "verification": "Crie um diagrama vetorial simples e compute G manualmente, confirmando normas e ângulos.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Python com NumPy",
                                    "Matplotlib para visualização",
                                    "Notas de aula sobre álgebra linear"
                                  ],
                                  "tips": "Use vetores unitários para simplificar cálculos iniciais de ângulos.",
                                  "learningObjective": "Compreender como a Matriz de Gram representa geometria vetorial para detecção de dependência.",
                                  "commonMistakes": [
                                    "Confundir produto interno com norma",
                                    "Ignorar normalização nos ângulos",
                                    "Esquecer que det(G)=0 implica dependência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar vetores de deslocamentos em simulações estruturais civis",
                                  "subSteps": [
                                    "Selecione um modelo simples: viga cantilever com nós e deslocamentos em x,y.",
                                    "Gere vetores de deslocamento V de simulações FEM (Finite Element Method).",
                                    "Compute a Matriz de Gram para esses vetores representando deformações.",
                                    "Interprete geometricamente: vetores paralelos indicam modos de falha redundantes.",
                                    "Simule variação de cargas para observar mudanças em ângulos/normas."
                                  ],
                                  "verification": "Gere V de um solver FEM básico e plote vetores com setas coloridas por norma.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Software FEM como FEniCS ou ANSYS Student",
                                    "Python SciPy para simulação simples",
                                    "Exemplos de estruturas civis"
                                  ],
                                  "tips": "Comece com 3-4 nós para reduzir dimensionalidade e focar na geometria.",
                                  "learningObjective": "Mapear vetores de deslocamento reais para interpretação geométrica via Gram.",
                                  "commonMistakes": [
                                    "Usar deslocamentos não normalizados",
                                    "Ignorar coordenadas locais vs globais",
                                    "Confundir deslocamento com rotação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar dependência linear geometricamente em contextos estruturais",
                                  "subSteps": [
                                    "Calcule autovalores de G: zero indica direção de dependência (colapso geométrico).",
                                    "Meça ângulos entre vetores: cosθ ≈ ±1 sinaliza linearidade.",
                                    "Aplique SVD em V para base ortonormal e compare com G.",
                                    "Identifique implicações civis: dependência leva a ill-conditioned sistemas de equações.",
                                    "Teste com ruído: simule medições reais e avalie robustez geométrica."
                                  ],
                                  "verification": "Reporte ângulos <5° ou >175° e confirme det(G) próximo de zero.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Python com SciPy.linalg",
                                    "Jupyter Notebook",
                                    "Dados de simulação estrutural"
                                  ],
                                  "tips": "Use heatmaps para visualizar G e destacar off-diagonais grandes.",
                                  "learningObjective": "Aplicar métricas geométricas para diagnosticar dependências em dados estruturais.",
                                  "commonMistakes": [
                                    "Interpretar autovalores pequenos como zero numérico",
                                    "Negligenciar escala das normas",
                                    "Confundir dependência com ortogonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar análise geométrica com redes neurais para simulações civis",
                                  "subSteps": [
                                    "Treine uma NN simples para prever deslocamentos V a partir de cargas.",
                                    "Extraia V previstos e compute G para checar dependências induzidas pelo modelo.",
                                    "Interprete geometricamente: NN aprende modos independentes se G bem condicionada.",
                                    "Otimize NN penalizando det(G) baixo (regularização geométrica).",
                                    "Valide em caso real: ponte com sensores, analisando dependências em tempo real."
                                  ],
                                  "verification": "Compare G pré/pós-treinamento NN e plote evolução de ângulos.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "TensorFlow ou PyTorch",
                                    "Dataset de simulações civis (ex: Kaggle bridges)",
                                    "GPU opcional para NN"
                                  ],
                                  "tips": "Use dropout na NN para promover diversidade vetorial e independência.",
                                  "learningObjective": "Combinar interpretação geométrica com ML para robustez em simulações estruturais.",
                                  "commonMistakes": [
                                    "Overfitting levando a dependências artificiais",
                                    "Ignorar loss de condicionamento",
                                    "Treinar sem pré-processamento geométrico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de uma ponte pênsil com 10 nós, vetores de deslocamento sob vento mostram dois modos colineares (ângulo 1.2°), detectados por G com det=1e-12; corrigido via NN re-treinada para ortogonalizar modos, evitando ill-conditioning na previsão de colapso.",
                              "finalVerifications": [
                                "Computar G e confirmar todos ângulos entre 30°-150° para independência.",
                                "Verificar det(G) > 1e-6 e cond(G) < 1e4.",
                                "Simular 10 cargas variadas e checar consistência geométrica.",
                                "Treinar NN e validar RMSE <5% com análise Gram pós-treinamento.",
                                "Documentar diagrama vetorial final sem dependências visíveis.",
                                "Testar sensibilidade a ruído: variação <10% em normas/ângulos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação geométrica (normas/ângulos corretos: 30%)",
                                "Detecção correta de dependências (SVD/G: 25%)",
                                "Integração efetiva com NN (melhoria cond(G): 20%)",
                                "Aplicação contextual em civis (relevância simulação: 15%)",
                                "Clareza em visualizações e relatórios (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear avançada e SVD.",
                                "Inteligência Artificial: Regularização em redes neurais.",
                                "Física: Mecânica estrutural e modos de vibração.",
                                "Computação: Programação científica e FEM."
                              ],
                              "realWorldApplication": "Na análise de estabilidade de edifícios altos ou pontes, detectar dependências lineares em vetores de deslocamento via Gram permite identificar falhas prematuras em simulações NN, otimizando designs contra colapsos como no caso Tacoma Narrows, integrando ML para monitoramento em tempo real via IoT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.4",
                            "name": "Implementar visualização de ângulos",
                            "description": "Criar plot em MATLAB mostrando vetores e ângulos derivados da matriz de Gram para validação visual em problemas de valor de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir vetores de exemplo e calcular a matriz de Gram",
                                  "subSteps": [
                                    "Selecione 3-4 vetores relevantes para um problema de valor de contorno, como deslocamentos nodais em uma estrutura simples.",
                                    "Forme a matriz A cujas colunas são os vetores.",
                                    "Calcule a matriz de Gram G = A' * A usando sintaxe MATLAB.",
                                    "Verifique as propriedades: diagonal com normas ao quadrado, off-diagonal com produtos internos.",
                                    "Armazene G para uso posterior."
                                  ],
                                  "verification": "Execute o código e confirme que G é simétrica positiva semidefinida com valores esperados nas diagonais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MATLAB instalado",
                                    "Documentação MATLAB para operações matriciais"
                                  ],
                                  "tips": "Use vetores normalizados inicialmente para simplificar validação.",
                                  "learningObjective": "Compreender como a matriz de Gram captura normas e ângulos entre vetores.",
                                  "commonMistakes": [
                                    "Esquecer transposição (A' em vez de A.T)",
                                    "Usar vetores lineares dependentes levando a G singular"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair ângulos entre vetores da matriz de Gram",
                                  "subSteps": [
                                    "Extraia normas dos vetores da diagonal de G: norm_i = sqrt(G(i,i)).",
                                    "Calcule cossenos dos ângulos: cos_theta_ij = G(i,j) / (norm_i * norm_j).",
                                    "Converta para ângulos em graus: theta_ij = acos(cos_theta_ij) * 180 / pi.",
                                    "Crie uma matriz de ângulos Theta com os valores calculados.",
                                    "Valide ângulos ortogonais (90 graus) onde esperado."
                                  ],
                                  "verification": "Compare ângulos calculados manualmente com os da matriz para pelo menos um par de vetores.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "MATLAB",
                                    "Calculadora ou função atan2 para validação manual"
                                  ],
                                  "tips": "Garanta que cos_theta esteja entre -1 e 1; clip valores se necessário devido a precisão numérica.",
                                  "learningObjective": "Aplicar fórmula de ângulo via produto interno sem calcular vetores explicitamente.",
                                  "commonMistakes": [
                                    "Confundir radianos com graus sem conversão",
                                    "Dividir por zero em normas nulas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar plot de vetores em MATLAB",
                                  "subSteps": [
                                    "Crie figura com quiver ou plot para desenhar vetores originados na origem.",
                                    "Defina escala apropriada com axis equal para preservar proporções.",
                                    "Adicione rótulos para cada vetor (ex: 'v1', 'v2').",
                                    "Configure cores distintas e setas com quiverproperties.",
                                    "Adicione grid e título 'Visualização de Vetores e Ângulos da Gram Matrix'."
                                  ],
                                  "verification": "O plot exibe vetores com comprimentos e direções proporcionais às normas e ângulos reais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "MATLAB Graphics documentation"
                                  ],
                                  "tips": "Use hold on para sobrepor múltiplos vetores.",
                                  "learningObjective": "Dominar visualização vetorial em 2D para inspeção geométrica.",
                                  "commonMistakes": [
                                    "Esquecer axis equal distorcendo ângulos",
                                    "Escala inadequada escondendo vetores pequenos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Anotar ângulos no plot e validar visualmente",
                                  "subSteps": [
                                    "Calcule posições para texto de ângulos no meio dos arcos entre vetores.",
                                    "Use text ou annotation para adicionar labels com valores de theta_ij.",
                                    "Adicione arcos aproximados com plot de circunferência parcial se possível.",
                                    "Compare ângulos visuais com valores numéricos da matriz Theta.",
                                    "Salve o plot e gere relatório de validação."
                                  ],
                                  "verification": "Ângulos anotados coincidem com cálculos da Gram matrix dentro de 1 grau de tolerância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MATLAB",
                                    "Exemplo de código para arcos angulares"
                                  ],
                                  "tips": "Use gtext para posicionamento interativo de labels.",
                                  "learningObjective": "Integrar dados numéricos (Gram) com visualização para validação intuitiva.",
                                  "commonMistakes": [
                                    "Posicionamento errado de textos sobrepondo vetores",
                                    "Arredondamento inadequado de ângulos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever com 3 nós, use vetores de deslocamentos [1,0], [0.6,0.8], [0,1] como colunas de A. Calcule G, extraia ângulos (ex: 53° entre v1 e v2), plote vetores e anote ângulos para validar ortogonalidade parcial em análise modal.",
                              "finalVerifications": [
                                "Matriz G calculada corretamente com normas e cossenos precisos.",
                                "Plot exibe vetores com ângulos visuais matching cálculos (±1°).",
                                "Anotações de ângulos claras e posicionadas corretamente.",
                                "Código MATLAB reproduzível e comentado.",
                                "Validação em contexto de valor de contorno (ex: convergência visual).",
                                "Exportação de figura em alta resolução."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica da Gram matrix e ângulos (90%).",
                                "Qualidade visual do plot: clareza, escalas, legendas (80%).",
                                "Comentários no código explicando relação com condicionamento (70%).",
                                "Validação cruzada com cálculo manual (85%).",
                                "Integração com problema real de engenharia civil (75%).",
                                "Eficiência computacional (sem loops desnecessários)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e geometria vetorial.",
                                "Física: Representação de forças/desperçamentos em estruturas.",
                                "Programação: Visualização de dados com MATLAB/Octave.",
                                "Engenharia Computacional: Validação numérica em FEA.",
                                "Estatística: Análise de correlação via ângulos."
                              ],
                              "realWorldApplication": "Em análise de elementos finitos para estruturas civis, visualizar ângulos da Gram matrix ajuda a diagnosticar il-condicionamento em malhas, previnindo erros em simulações de valores de contorno como deformações em pontes ou barragens."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Aplicação em Processos Ortogonais",
                    "description": "Uso da matriz de Gram no processo de Gram-Schmidt para ortogonalização de bases.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Matriz de Gram",
                        "description": "A matriz de Gram é uma matriz simétrica positiva definida construída a partir de produtos internos de vetores de uma base, utilizada para medir a independência linear e o condicionamento de conjuntos de vetores em processos de ortogonalização.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Calcular a matriz de Gram para um conjunto de vetores",
                            "description": "Dado um conjunto de vetores em R^n, computar a matriz G onde G_ij = <v_i, v_j>, identificando propriedades como simetria e definitude positiva, e relacionando com o condicionamento da base original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o conjunto de vetores e recordar a definição de produto interno",
                                  "subSteps": [
                                    "Selecione um conjunto de m vetores linearmente independentes em R^n, onde m ≤ n.",
                                    "Escreva explicitamente cada vetor v_i como uma lista de componentes.",
                                    "Lembre-se que o produto interno padrão em R^n é <u, v> = sum_{k=1}^n u_k * v_k.",
                                    "Verifique se os vetores estão normalizados ou não, anotando isso.",
                                    "Defina a matriz V cujas colunas são os vetores v_i para visualização."
                                  ],
                                  "verification": "Confirme que todos os vetores estão corretamente listados e o produto interno é compreendido calculando um exemplo simples manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Calculadora ou software como MATLAB/Python (opcional)"
                                  ],
                                  "tips": "Sempre use a base canônica para simplicidade inicial; evite vetores com componentes fracionários complicados no primeiro exemplo.",
                                  "learningObjective": "Compreender a entrada necessária para a matriz de Gram e o produto interno escalar.",
                                  "commonMistakes": [
                                    "Confundir produto interno com produto vetorial",
                                    "Esquecer que vetores devem ser linearmente independentes",
                                    "Usar norma em vez de produto interno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular todos os produtos internos <v_i, v_j>",
                                  "subSteps": [
                                    "Para cada par (i,j) com i,j de 1 a m, compute <v_i, v_j> = v_i · v_j.",
                                    "Comece com a diagonal: <v_i, v_i> = ||v_i||^2 (norma ao quadrado).",
                                    "Calcule os elementos fora da diagonal em ordem sistemática (i<j e i>j).",
                                    "Registre cada valor em uma tabela ou matriz esparsa para organização.",
                                    "Verifique simetria parcial: <v_i, v_j> deve igualar <v_j, v_i>."
                                  ],
                                  "verification": "Todos os m x m produtos internos estão calculados e simétricos (G_ij = G_ji).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel quadriculado",
                                    "Biblioteca NumPy em Python para verificação"
                                  ],
                                  "tips": "Use a distributividade do produto interno para acelerar cálculos em vetores similares.",
                                  "learningObjective": "Dominar o cálculo eficiente de produtos internos para múltiplos pares de vetores.",
                                  "commonMistakes": [
                                    "Erro aritmético em somas longas",
                                    "Confundir índices i e j",
                                    "Esquecer o sinal em componentes negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz G e verificar simetria",
                                  "subSteps": [
                                    "Monte a matriz G de ordem m x m, preenchendo G_ij com <v_i, v_j>.",
                                    "Confirme simetria: G = G^T, verificando G_ij = G_ji para todos i ≠ j.",
                                    "Calcule os autovalores ou verifique definitude positiva semi-definida (todos autovalores ≥ 0).",
                                    "Use o determinante ou teste de Cholesky se m pequeno.",
                                    "Anote a matriz final em formato legível."
                                  ],
                                  "verification": "Matriz G é simétrica e todos elementos diagonais são positivos (||v_i||^2 > 0).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de álgebra linear como MATLAB ou SymPy",
                                    "Papel para matriz manual"
                                  ],
                                  "tips": "Para verificação rápida de simetria, transpose manualmente e compare.",
                                  "learningObjective": "Construir e validar a simetria da matriz de Gram.",
                                  "commonMistakes": [
                                    "Preencher linhas em vez de colunas",
                                    "Ignorar simetria ao copiar valores",
                                    "Erro em transposição"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar propriedades e relacionar com condicionamento da base",
                                  "subSteps": [
                                    "Verifique definitude positiva: todos autovalores > 0 se vetores lin. ind.",
                                    "Calcule o número de condicionamento cond(G) = ||G|| * ||G^{-1}|| ou razão maior/menor autovalor.",
                                    "Compare cond(G) com cond(V) da matriz de vetores: cond(G) ≤ cond(V)^2.",
                                    "Discuta implicações: G bem condicionada indica base estável para ortogonalização.",
                                    "Implemente em código para vetores numéricos e compare."
                                  ],
                                  "verification": "Propriedades confirmadas e relação com condicionamento explicada com números.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy para autovalores e condicionamento",
                                    "Documentação de SVD/QR"
                                  ],
                                  "tips": "Use np.linalg.cond() em Python para condicionamento rápido.",
                                  "learningObjective": "Interpretar a matriz de Gram em termos de estabilidade numérica e condicionamento.",
                                  "commonMistakes": [
                                    "Confundir definitude positiva com simetria",
                                    "Ignorar que cond(G) reflete cond(V)",
                                    "Erro numérico em autovalores para m grande"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado vetores em R^3: v1 = [1,0,0], v2 = [1,1,0], v3 = [1,1,1]. Calcule G: G11=1, G12=1, G13=1; G21=1, G22=2, G23=2; G31=1, G32=2, G33=3. Verifique simetria e cond(G) ≈ 12.3, melhor que cond(V) ≈ 15.8.",
                              "finalVerifications": [
                                "Matriz G corretamente montada e simétrica.",
                                "Todos elementos diagonais positivos e autovalores ≥ 0.",
                                "Número de condicionamento de G calculado e comparado com base original.",
                                "Explicação verbal das propriedades em contexto de processos ortogonais.",
                                "Implementação numérica em código reproduz resultados manuais.",
                                "Identificação de como G é usada em Gram-Schmidt."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de produtos internos (erro < 1e-10).",
                                "Correta identificação de simetria e definitude positiva.",
                                "Análise qualitativa e quantitativa do condicionamento.",
                                "Clareza na documentação da matriz e propriedades.",
                                "Aplicação correta em exemplo prático com interpretação.",
                                "Eficiência no uso de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Produto interno como trabalho ou projeção em vetores de força.",
                                "Computação: Implementação em álgebra linear numérica (NumPy, LAPACK).",
                                "Estatística: Matriz de covariância como Gram matrix de dados.",
                                "Engenharia de Software: Otimização de bases para simulações finitas."
                              ],
                              "realWorldApplication": "Em engenharia civil, a matriz de Gram é usada em decomposição QR para resolver sistemas lineares mal condicionados em análise estrutural (ex.: simulação de vigas com bases de funções modais), melhorando precisão numérica e estabilidade em métodos de elementos finitos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Interpretar o determinante e autovalores da matriz de Gram",
                            "description": "Analisar o determinante de G para verificar independência linear (det(G) ≠ 0) e os autovalores para avaliar o condicionamento numérico da base, aplicando em contextos de engenharia civil como análise estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir a matriz de Gram e calcular seu determinante",
                                  "subSteps": [
                                    "Identifique os vetores base {v1, v2, ..., vn} no contexto de análise estrutural, como deslocamentos nodais.",
                                    "Calcule os produtos internos <vi, vj> para formar a matriz simétrica positiva semi-definida G.",
                                    "Utilize métodos numéricos (ex: numpy.linalg.det() ou decomposição LU) para computar det(G).",
                                    "Registre o valor exato ou aproximado de det(G).",
                                    "Compare det(G) com um limiar pequeno (ex: 1e-10) para decidir se é zero."
                                  ],
                                  "verification": "Confirme que det(G) foi calculado corretamente comparando com cálculo manual para matriz 2x2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software: Python com NumPy ou MATLAB",
                                    "Matriz de vetores base de exemplo"
                                  ],
                                  "tips": "Para matrizes grandes, prefira métodos numéricos estáveis como Cholesky em vez de eliminação gaussiana direta.",
                                  "learningObjective": "Dominar o cálculo preciso do determinante da matriz de Gram a partir de vetores base.",
                                  "commonMistakes": [
                                    "Usar norma euclidiana em vez de produto interno",
                                    "Ignorar normalização prévia dos vetores",
                                    "Confundir det(G) com det da matriz de coordenadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar o determinante para independência linear",
                                  "subSteps": [
                                    "Analise se det(G) = 0, indicando que os vetores são linearmente dependentes.",
                                    "Se det(G) ≠ 0, conclua independência linear; caso contrário, identifique vetores redundantes.",
                                    "Discuta implicações: base inválida para representação única em espaços de deslocamento.",
                                    "Visualize geometricamente: det(G)=0 significa vetores coplanares ou colineares.",
                                    "Documente a conclusão em um relatório curto."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que det(G)=0 implica dependência linear.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz G calculada",
                                    "Gráfico de vetores (ex: Matplotlib)"
                                  ],
                                  "tips": "Teste remoção de um vetor e recalcule det para isolar dependências.",
                                  "learningObjective": "Interpretar det(G) como indicador de independência linear das bases vetoriais.",
                                  "commonMistakes": [
                                    "Achar det(G) pequeno como zero sem threshold",
                                    "Confundir com ortogonalidade (que requer G diagonal)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e analisar os autovalores da matriz de Gram",
                                  "subSteps": [
                                    "Compute os autovalores usando eigendecomposição (numpy.linalg.eigvals() ou similar).",
                                    "Ordene autovalores: λ_max (maior) e λ_min (menor, não-negativo).",
                                    "Verifique se todos λ_i ≥ 0 (propriedade de G simétrica).",
                                    "Calcule o número de condição κ = sqrt(λ_max / λ_min).",
                                    "Classifique: κ < 10 bom, 10-100 moderado, >100 ruim."
                                  ],
                                  "verification": "Liste autovalores e κ corretamente para uma G de teste conhecida.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software numérico",
                                    "Exemplo de G com autovalores analíticos"
                                  ],
                                  "tips": "Use decomposição SVD para precisão em casos mal-condicionados.",
                                  "learningObjective": "Extrair autovalores de G e computar métricas de condicionamento.",
                                  "commonMistakes": [
                                    "Usar autovalores negativos (erro numérico)",
                                    "Confundir κ com λ_max/λ_min em vez de sqrt",
                                    "Ignorar autovalores zero que indicam dependência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar interpretações em análise estrutural de engenharia civil",
                                  "subSteps": [
                                    "Selecione um modelo de treliça ou FEM com deslocamentos nodais como vetores base.",
                                    "Avalie det(G) para validar a malha/independência de graus de liberdade.",
                                    "Use κ para prever estabilidade numérica na solução de sistemas K u = f.",
                                    "Recomende melhorias: ortogonalizar base se κ alto (ex: Gram-Schmidt).",
                                    "Simule erro numérico amplificado por κ em um solver simples."
                                  ],
                                  "verification": "Gere relatório com conclusões e recomendações para o modelo estrutural.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Modelo FEM simples (ex: truss 2D)",
                                    "Software: FEniCS ou ANSYS viewer"
                                  ],
                                  "tips": "Integre com análise de elementos finitos para vetores reais de rigidez.",
                                  "learningObjective": "Aplicar conceitos de det(G) e autovalores ao condicionamento em problemas reais de engenharia civil.",
                                  "commonMistakes": [
                                    "Aplicar em bases não normalizadas",
                                    "Ignorar escala dos vetores (afeta apenas escala de λ)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma treliça 2D com nós A(0,0), B(1,0), C(0.5, √3/2), vetores deslocamento v1=[1,0], v2=[0.5, 0.866]. G = [[1, 0.866], [0.866, 1]]. det(G)=1-0.866²≈0.25≠0 (independentes). Autovalores ≈0.134, 1.866; κ=sqrt(1.866/0.134)≈11.8 (moderado condicionamento, aceitável para análise estática).",
                              "finalVerifications": [
                                "Calcular corretamente det(G) e autovalores para G 3x3 exemplo.",
                                "Explicar ligação entre det(G)=0 e autovalor zero.",
                                "Interpretar κ>100 como risco numérico em FEM.",
                                "Identificar dependência linear em vetores colineares.",
                                "Aplicar threshold para det(G)≈0 em prática computacional.",
                                "Recomendar ortogonalização baseada em análise de G."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de det(G) e autovalores (erro <1e-6).",
                                "Interpretação correta de independência linear via det(G).",
                                "Cálculo exato do número de condição κ.",
                                "Conexão clara com estabilidade numérica em engenharia.",
                                "Uso apropriado de ferramentas numéricas sem erros de implementação.",
                                "Relatório claro com conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Eigendecomposição e propriedades de matrizes simétricas.",
                                "Computação Científica: Algoritmos numéricos para autovalores (QR algorithm).",
                                "Física/Mecânica: Vetores de deslocamento e produtos internos em espaços euclidianos.",
                                "Estatística: Análise de variância via autovalores em PCA para dados estruturais.",
                                "Engenharia de Software: Implementação robusta de solvers FEM condicionados."
                              ],
                              "realWorldApplication": "Na análise de estruturas civis via Método dos Elementos Finitos (FEM), interpretar det(G) garante independência de modos de falha locais, enquanto autovalores avaliam condicionamento para evitar amplificação de erros de arredondamento em simulações sísmicas ou de vento, otimizando malhas computacionais em projetos de pontes e edifícios."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Implementar cálculo da matriz de Gram em MATLAB",
                            "description": "Escrever um script em MATLAB para gerar a matriz de Gram a partir de uma matriz cujas colunas são os vetores da base, utilizando produto interno matricial (A'*A), conforme exemplos em Yang et al. (2005).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente MATLAB e definir a matriz de vetores base",
                                  "subSteps": [
                                    "Abra o MATLAB e crie um novo script (File > New > Script).",
                                    "Defina uma matriz A cujas colunas representem vetores de uma base, por exemplo, A = [1 0 1; 0 1 0; 0 0 1] para vetores em R^3 relevantes a coordenadas estruturais.",
                                    "Exiba a matriz A usando disp(A) ou format short para visualização clara.",
                                    "Comente o script explicando o contexto da base vetorial (ex: vetores de deslocamentos em análise modal).",
                                    "Salve o script como 'gram_matrix_calc.m'."
                                  ],
                                  "verification": "Execute as linhas iniciais e confirme que A é exibida corretamente com dimensões n x m (n linhas, m vetores).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "MATLAB R2020a ou superior",
                                    "Documentação MATLAB sobre matrizes (help matrix)"
                                  ],
                                  "tips": "Escolha vetores normalizados ou escalados realisticamente para aplicações em engenharia civil, evitando singularidades iniciais.",
                                  "learningObjective": "Preparar dados de entrada representando uma base vetorial para computação matricial.",
                                  "commonMistakes": [
                                    "Confundir colunas com linhas (vetores devem ser colunas)",
                                    "Usar matrizes singulares que invalidem a base",
                                    "Esquecer de comentar o propósito da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o cálculo da matriz de Gram via produto interno matricial",
                                  "subSteps": [
                                    "Calcule a transposta de A usando A_trans = A';",
                                    "Compute a matriz de Gram G = A_trans * A;",
                                    "Exiba G usando disp('Matriz de Gram G:'); disp(G);",
                                    "Adicione verificação básica: if norm(G - G') < 1e-10, disp('G é simétrica'); end",
                                    "Comente a linha de cálculo referenciando Yang et al. (2005) e o conceito de produto interno."
                                  ],
                                  "verification": "Execute o script até G e confirme que G(i,j) = <vetor_i, vetor_j> para i,j pares específicos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ajuda MATLAB: help ctranspose, help mtimes",
                                    "Referência: Yang et al. (2005) seção sobre Gram matrices"
                                  ],
                                  "tips": "Use precisão numérica alta com format long se necessário para vetores com componentes decimais.",
                                  "learningObjective": "Aplicar operação matricial A'*A para capturar ângulos e normas da base.",
                                  "commonMistakes": [
                                    "Esquecer a transposta (A*A em vez de A'*A)",
                                    "Usar ./ ou outros operadores errados",
                                    "Ignorar conjugada complexa se vetores forem complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar propriedades e validar a matriz de Gram",
                                  "subSteps": [
                                    "Verifique simetria: compute diff = G - G'; norm(diff) deve ser ~0.",
                                    "Cheque diagonal positiva: diag(G) > 0 para todos elementos.",
                                    "Calcule determinante ou autovalores: eig(G) para confirmar positividez definida.",
                                    "Compare com cálculo manual para subconjunto: ex. G(1,1) == norm(A(:,1))^2.",
                                    "Plote heatmap de G usando imagesc(G) para visualização intuitiva."
                                  ],
                                  "verification": "Todas verificações passam sem warnings e eig(G) tem autovalores positivos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Funções MATLAB: norm, eig, imagesc, help spy",
                                    "Exemplos de bases ortogonais para teste"
                                  ],
                                  "tips": "Para bases quase ortogonais em engenharia, espere off-diagonais pequenas.",
                                  "learningObjective": "Validar que G captura corretamente os produtos internos da base.",
                                  "commonMistakes": [
                                    "Não tolerar erros numéricos (use 1e-10)",
                                    "Confundir simetria com identidade",
                                    "Ignorar autovalores negativos indicando base linearmente dependente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar com entradas variadas e documentar o script completo",
                                  "subSteps": [
                                    "Teste com matriz A diferente: ex. A_ort = eye(3); G deve ser identidade.",
                                    "Teste com base não ortonormal: A = [1 1; 0 1; 1 0]; compute e valide.",
                                    "Adicione função wrapper: function G = gramMatrix(A); G = A'*A; end",
                                    "Inclua header com uso, inputs/outputs e referências.",
                                    "Execute full script e salve output em arquivo .txt via diary."
                                  ],
                                  "verification": "Script funciona para 3+ casos de teste, produzindo G corretas e documentadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor MATLAB para funções",
                                    "Exemplos de Yang et al. (2005)"
                                  ],
                                  "tips": "Vectorize testes em cell array para eficiência.",
                                  "learningObjective": "Garantir robustez e reutilização do código em contextos de engenharia.",
                                  "commonMistakes": [
                                    "Testes só com casos triviais",
                                    "Falta de função para modularidade",
                                    "Documentação incompleta"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma base de vetores de deslocamentos nodais em uma treliça 2D: A = [1 0 2; 0 1 1; 1 1 0] (3 nós x 3 modos). O script computa G = A'*A = [2 1 3; 1 2 2; 3 2 6], confirmando G(1,2)=1 (produto interno entre vetor1 e vetor2).",
                              "finalVerifications": [
                                "Script executa sem erros para matrizes n x m com m <= n.",
                                "G é simétrica com tolerância 1e-12 e diagonal positiva.",
                                "Resultados coincidem com cálculo manual para pelo menos 2 pares de vetores.",
                                "Função wrapper aceita input arbitrário e retorna G corretamente.",
                                "Documentação inclui uso, referências e testes.",
                                "Visualização (heatmap) mostra estrutura esperada para bases reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro < 1e-10 em verificações.",
                                "Eficiência: usa operações matriciais nativas sem loops.",
                                "Robustez: lida com entradas variadas sem crashes.",
                                "Clareza: código comentado e legível.",
                                "Validação completa: inclui propriedades matemáticas chave.",
                                "Modularidade: função reutilizável."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Conceitos de produto interno e bases ortogonais.",
                                "Programação Numérica: Operações eficientes em MATLAB.",
                                "Análise Numérica: Condicionamento e estabilidade de Gram matrices.",
                                "Engenharia Computacional: Aplicações em métodos dos elementos finitos.",
                                "Processamento de Sinais: Similaridades com covariância em análise modal."
                              ],
                              "realWorldApplication": "Na engenharia civil, a matriz de Gram é essencial para ortogonalizar bases em análise modal de estruturas, resolver sistemas super-determinados via mínimos quadrados (ex: ajuste de dados experimentais de vibrações), e melhorar condicionamento em simulações FEM para previsão de falhas em pontes ou edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Processo de Gram-Schmidt",
                        "description": "O processo de Gram-Schmidt transforma uma base linearmente independente em uma base ortogonal (ou ortonormal) por meio de projeções sucessivas, essencial para estabilizar soluções numéricas em problemas de engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Executar o processo de Gram-Schmidt manualmente",
                            "description": "Aplicar os passos do algoritmo Gram-Schmidt para ortogonalizar uma base de vetores em R^3, calculando u_k = v_k - soma proj_{u_j} v_k para j < k, e normalizando para obter base ortonormal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a base de vetores e verificar independência linear",
                                  "subSteps": [
                                    "Liste os vetores da base original {v₁, v₂, v₃} em ℝ³.",
                                    "Calcule o determinante da matriz formada pelos vetores como colunas para verificar se ≠ 0.",
                                    "Confirme que nenhum vetor é múltiplo escalar dos outros.",
                                    "Anote os produtos internos necessários (v_i · v_j).",
                                    "Prepare uma tabela para rastrear projeções e normas."
                                  ],
                                  "verification": "Determinante da matriz ≠ 0 e vetores não colineares.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora científica",
                                    "Tabela de fórmulas de produtos internos"
                                  ],
                                  "tips": "Use vetores unitários simples para prática inicial; sempre normalize no final de cada u_k.",
                                  "learningObjective": "Identificar e preparar uma base linearmente independente para ortogonalização.",
                                  "commonMistakes": [
                                    "Ignorar verificação de independência",
                                    "Usar vetores colineares acidentalmente",
                                    "Esquecer de anotar componentes iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o primeiro vetor ortonormal e₁",
                                  "subSteps": [
                                    "Defina u₁ = v₁.",
                                    "Calcule a norma ||u₁|| = √(u₁ · u₁).",
                                    "Normalize: e₁ = u₁ / ||u₁||.",
                                    "Verifique: e₁ · e₁ = 1.",
                                    "Anote e₁ para uso futuro."
                                  ],
                                  "verification": "||e₁|| = 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de cálculos",
                                    "Fórmula de norma euclidiana"
                                  ],
                                  "tips": "Calcule componentes separadamente para evitar erros aritméticos; arredonde apenas no final.",
                                  "learningObjective": "Aplicar normalização ao primeiro vetor da base.",
                                  "commonMistakes": [
                                    "Dividir pela norma errada",
                                    "Esquecer raiz quadrada na norma",
                                    "Não verificar auto-produto interno"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o segundo vetor ortonormal e₂",
                                  "subSteps": [
                                    "Calcule a projeção proj_{e₁} v₂ = (v₂ · e₁) e₁.",
                                    "Defina u₂ = v₂ - proj_{e₁} v₂.",
                                    "Calcule ||u₂||.",
                                    "Normalize: e₂ = u₂ / ||u₂||.",
                                    "Verifique ortogonalidade: e₁ · e₂ = 0 e ||e₂|| = 1."
                                  ],
                                  "verification": "e₁ · e₂ = 0 e ||e₂|| = 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de vetores anteriores",
                                    "Fórmulas de projeção"
                                  ],
                                  "tips": "Subtraia componentes vetor a vetor; use parênteses para clareza em expressões.",
                                  "learningObjective": "Subtrair projeção do primeiro vetor para obter ortogonalidade.",
                                  "commonMistakes": [
                                    "Usar v₁ em vez de e₁ na projeção",
                                    "Erro de sinal na subtração",
                                    "Norma zero (independência falhou)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o terceiro vetor ortonormal e₃",
                                  "subSteps": [
                                    "Calcule proj_{e₁} v₃ = (v₃ · e₁) e₁.",
                                    "Calcule proj_{e₂} v₃ = (v₃ · e₂) e₂.",
                                    "Defina u₃ = v₃ - proj_{e₁} v₃ - proj_{e₂} v₃.",
                                    "Calcule ||u₃||.",
                                    "Normalize: e₃ = u₃ / ||u₃||."
                                  ],
                                  "verification": "e₁ · e₃ = 0, e₂ · e₃ = 0, ||e₃|| = 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora avançada",
                                    "Folha com e₁ e e₂",
                                    "Matriz para verificações"
                                  ],
                                  "tips": "Some as projeções antes de subtrair; verifique cada produto interno separadamente.",
                                  "learningObjective": "Estender ortogonalização ao terceiro vetor subtraindo múltiplas projeções.",
                                  "commonMistakes": [
                                    "Esquecer uma projeção",
                                    "Erro em coeficientes escalares",
                                    "Dividir por norma muito pequena"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar a base ortonormal completa",
                                  "subSteps": [
                                    "Calcule todos os produtos internos: e_i · e_j = 0 para i ≠ j.",
                                    "Confirme ||e_i|| = 1 para i=1,2,3.",
                                    "Forme a matriz Q com colunas e₁, e₂, e₃ e verifique Q^T Q = I.",
                                    "Compare span({e_i}) = span({v_i}).",
                                    "Documente o processo completo."
                                  ],
                                  "verification": "Todos produtos internos cruzados = 0 e normas = 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Matriz identidade 3x3"
                                  ],
                                  "tips": "Use software como MATLAB para verificação rápida se disponível; foque em precisão numérica.",
                                  "learningObjective": "Validar a ortonormalidade da base resultante.",
                                  "commonMistakes": [
                                    "Arredondamentos acumulados",
                                    "Ignorar verificação de identidade",
                                    "Não checar span preservado"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada a base {v₁=(1,1,0), v₂=(1,0,1), v₃=(0,1,1)}: u₁=v₁, ||u₁||=√2, e₁=(1/√2,1/√2,0); proj_{e₁}v₂=(1/√2)e₁, u₂=(1-1/√2, -1/√2,1), etc., resultando em base ortonormal aproximada.",
                              "finalVerifications": [
                                "Todos e_i · e_j = 0 para i ≠ j.",
                                "||e_i|| = 1 para cada i.",
                                "Matriz Q com colunas e_i satisfaz Q^T Q = I.",
                                "Os vetores e_i geram o mesmo espaço que v_i.",
                                "Nenhum erro aritmético > 10^{-3}.",
                                "Processo documentado passo a passo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de projeções e normas (erro < 0.01).",
                                "Correta aplicação da fórmula u_k = v_k - ∑ proj_{e_j} v_k.",
                                "Verificações de ortogonalidade e normalização completas.",
                                "Identificação e correção de erros comuns.",
                                "Eficiência no tempo estimado total (< 2 horas).",
                                "Clareza na documentação e tabela de rastreamento."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Gram-Schmidt em Python/MATLAB para QR decomposition.",
                                "Física: Ortogonalizar vetores de forças em análise estrutural.",
                                "Estatística: Base para PCA em análise de dados multivariados.",
                                "Engenharia Computacional: Condicionamento numérico de matrizes em simulações FEM."
                              ],
                              "realWorldApplication": "Em engenharia civil, o processo Gram-Schmidt é usado na decomposição QR para resolver sistemas lineares em análise de estruturas (ex: método dos elementos finitos), melhorando a estabilidade numérica ao ortogonalizar matrizes de rigidez e minimizar erros de condicionamento em softwares como ANSYS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Analisar estabilidade numérica do Gram-Schmidt clássico",
                            "description": "Identificar perdas de ortogonalidade devido a erros de arredondamento em implementações clássicas, relacionando com o condicionamento da matriz de Gram e propondo modificações QR para maior robustez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Implementar o Processo de Gram-Schmidt Clássico",
                                  "subSteps": [
                                    "Estude a formulação teórica do Gram-Schmidt clássico: q1 = a1 / ||a1||, qk = (ak - sum_{j=1}^{k-1} (qk_j · ak) qj) / ||...||.",
                                    "Implemente o algoritmo em Python ou MATLAB usando precisão de ponto flutuante duplo.",
                                    "Teste com matriz identidade 5x5 para verificar ortonormalidade exata.",
                                    "Meça a ortonormalidade com ||Q^T Q - I||_F < 1e-14.",
                                    "Documente o código com comentários sobre operações de subtração."
                                  ],
                                  "verification": "A matriz Q resultante satisfaz ||Q^T Q - I||_F < 1e-14 para entrada bem-condicionada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "MATLAB",
                                    "Referência: Golub & Van Loan, Matrix Computations"
                                  ],
                                  "tips": [
                                    "Sempre normalize após subtração para evitar crescimento numérico.",
                                    "Use loops explícitos inicialmente para depuração."
                                  ],
                                  "learningObjective": "Implementar corretamente o Gram-Schmidt clássico e validar em casos ideais.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar os vetores qk.",
                                    "Usar produto escalar incorreto (qk · ak em vez de qj · ak)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Perdas de Ortonormalidade por Erros de Arredondamento",
                                  "subSteps": [
                                    "Gere matrizes de teste ill-condicionadas, como Vandermonde 10x10 com pontos equidistantes em [0,1].",
                                    "Aplique Gram-Schmidt clássico e compute ||Q^T Q - I||_F e ||Q||_2 ≈ 1.",
                                    "Varie o tamanho da matriz (n=5 a 20) e observe o crescimento do erro.",
                                    "Compare com precisão máquina eps ≈ 2e-16.",
                                    "Plote erro vs. tamanho n ou kappa(A)."
                                  ],
                                  "verification": "Gráfico mostrando ||Q^T Q - I||_F > 1e-10 para n>15 em matriz ill-condicionada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "NumPy/MATLAB para geração de matrizes",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": [
                                    "Use np.linalg.norm com 'fro' para norma de Frobenius.",
                                    "Teste em diferentes máquinas para variabilidade de hardware."
                                  ],
                                  "learningObjective": "Detectar e quantificar perda de ortogonalidade em implementações numéricas.",
                                  "commonMistakes": [
                                    "Confundir erro de ortogonalidade com erro de normatização.",
                                    "Não escalar adequadamente as matrizes de entrada."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar Instabilidade com Condicionamento da Matriz de Gram",
                                  "subSteps": [
                                    "Compute a matriz de Gram G = A^T A para as matrizes de teste.",
                                    "Calcule cond(G) = sigma_max / sigma_min usando SVD.",
                                    "Analise teoricamente: erro em GS amplificado por sqrt(kappa(G)) em subtrações.",
                                    "Correlacione numericamente: plote log(||Q^T Q - I||) vs. log(kappa(G)).",
                                    "Estude referências sobre análise de erro backward em GS clássico."
                                  ],
                                  "verification": "Correlação >0.9 entre log(erros) e log(kappa(G)) nos testes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "SciPy linalg.svd",
                                    "Artigos: Higham 'Accuracy and Stability of Numerical Algorithms'"
                                  ],
                                  "tips": [
                                    "Cond(G) = [cond(A)]^2, então foque em A ill-condicionada.",
                                    "Use cond='full' em svd para precisão."
                                  ],
                                  "learningObjective": "Compreender o papel do condicionamento da Gram matrix na estabilidade de GS.",
                                  "commonMistakes": [
                                    "Computar cond(A) em vez de cond(G).",
                                    "Ignorar o fator quadrático em kappa(G)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Propor e Comparar Modificações QR para Maior Robustez",
                                  "subSteps": [
                                    "Implemente QR via Householder reflections ou Givens rotations.",
                                    "Aplique qr(A) built-in e extraia Q; compare ||Q^T Q - I|| com GS clássico.",
                                    "Teste nas mesmas matrizes ill-condicionadas, medindo tempo e erro.",
                                    "Discuta vantagens: Householder preserva ortogonalidade por construção.",
                                    "Relatório comparativo com tabelas de erros e tempos."
                                  ],
                                  "verification": "QR Householder mantém ||Q^T Q - I||_F < 1e-12 mesmo para kappa(A)>1e10.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "SciPy linalg.qr(mode='full')",
                                    "Código fonte Householder de referências"
                                  ],
                                  "tips": [
                                    "Implemente Householder do zero para compreensão.",
                                    "Use economic mode para Q enxuta."
                                  ],
                                  "learningObjective": "Avaliar e implementar alternativas estáveis ao GS clássico.",
                                  "commonMistakes": [
                                    "Confundir Q de QR completo vs. reduced.",
                                    "Não comparar apples-to-apples (mesmo A)."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma matriz Vandermonde 15x15 com pontos x_i = i/15 (i=1..15), cond(A)≈1e12. GS clássico dá ||Q^T Q - I||_F ≈1e-3, enquanto QR Householder dá <1e-13, demonstrando perda catastrófica em GS devido a cancelamentos em subtrações sucessivas.",
                              "finalVerifications": [
                                "Implementar GS clássico e QR para A ill-condicionada e reportar erros.",
                                "Explicar verbalmente o mecanismo de amplificação por kappa(G)^{1/2}.",
                                "Plotar correlação erro vs. condicionamento.",
                                "Propor pelo menos duas modificações (reortogonalização, Householder).",
                                "Verificar ortogonalidade em exemplo real de engenharia civil.",
                                "Discutir limites de precisão máquina."
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção das implementações (80% peso).",
                                "Análise quantitativa de erros e condicionamento.",
                                "Qualidade dos gráficos e correlações observadas.",
                                "Profundidade teórica na relação com kappa(G).",
                                "Clareza no relatório comparativo GS vs. QR.",
                                "Identificação correta de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Teoria de perturbação e estabilidade.",
                                "Programação Científica: Otimização numérica em Python/MATLAB.",
                                "Engenharia Estrutural: Ortonormalização de modos em análise modal.",
                                "Álgebra Linear Computacional: Decomposições QR em solvers.",
                                "Estatística: PCA e regressão least-squares robusta."
                              ],
                              "realWorldApplication": "Na engenharia civil, ao ortonormalizar vetores de modos de vibração de estruturas (ex: pontes), GS clássico falha em matrizes ill-condicionadas de elementos finitos grandes, levando a erros em análises dinâmicas; QR robusto garante precisão em simulações de resposta sísmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.2",
                              "10.1.2.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Implementar Gram-Schmidt em código numérico",
                            "description": "Desenvolver uma função em MATLAB para o processo de Gram-Schmidt, testando com bases mal condicionadas e verificando ortogonalidade via produto interno próximo de zero entre vetores distintos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Teoria e Planejar Algoritmo Gram-Schmidt",
                                  "subSteps": [
                                    "Estude a definição do processo Gram-Schmidt: para uma base {v1, v2, ..., vn}, compute u1 = v1 / ||v1||, u2 = (v2 - proj_u1 v2) / ||...||, etc.",
                                    "Derive manualmente para n=2 e n=3 vetores em R^2 e R^3.",
                                    "Identifique problemas numéricos em bases mal condicionadas (ex.: vetores quase paralelos).",
                                    "Planeje estrutura da função MATLAB: entradas (matriz A com colunas como vetores), saída (matriz Q ortonormal).",
                                    "Defina tolerância para verificação de ortogonalidade (ex.: 1e-12)."
                                  ],
                                  "verification": "Resolva manualmente um exemplo 2D e confirme que os vetores resultantes são ortonormais (produto interno ≈0, norma=1).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação MATLAB funções norm(), dot()",
                                    "Notas de álgebra linear",
                                    "Exemplos de matrizes mal condicionadas"
                                  ],
                                  "tips": "Use pseudocódigo antes de codificar para visualizar loops.",
                                  "learningObjective": "Compreender os passos algébricos e numéricos do Gram-Schmidt para implementação precisa.",
                                  "commonMistakes": [
                                    "Esquecer a normalização após subtração da projeção",
                                    "Não considerar ordem dos vetores na matriz de entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente e Implementar Função Básica",
                                  "subSteps": [
                                    "Abra MATLAB e crie script novo: defina função gramSchmidt(A).",
                                    "Inicialize Q como matriz identidade ou zeros(size(A)).",
                                    "Implemente loop principal: para j=1:n, compute projeções sobre u1 a u_{j-1}, subtraia e normalize.",
                                    "Use funções built-in: dot() para produto interno, norm() para norma euclidiana.",
                                    "Adicione comentários no código explicando cada linha."
                                  ],
                                  "verification": "Execute função com matriz identidade 3x3; Q deve ser igual a A.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB instalado",
                                    "Documentação MATLAB: norm, dot, size"
                                  ],
                                  "tips": "Teste incrementalmente dentro do loop com disp() para depuração.",
                                  "learningObjective": "Desenvolver código MATLAB funcional para Gram-Schmidt clássico.",
                                  "commonMistakes": [
                                    "Índices MATLAB começam em 1, não 0",
                                    "Confundir linhas/colunas: A deve ter colunas como vetores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Otimizar para Estabilidade Numérica e Adicionar Verificações",
                                  "subSteps": [
                                    "Modifique para versão modificada Gram-Schmidt (MG): subtraia projeções sequencialmente em loop interno para reduzir erros de cancelamento.",
                                    "Adicione verificação interna: compute Q'*Q e cheque se é quase identidade.",
                                    "Inclua input para tolerância; use eps() para comparações.",
                                    "Trate casos edge: matrizes singulares ou rank-deficient (retorne warning).",
                                    "Salve função como .m file."
                                  ],
                                  "verification": "Para matriz A mal condicionada (ex.: cond(A)>1e6), ||Q'*Q - eye(n)|| < 1e-10.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB Profiler para timing",
                                    "Exemplos de Hilbert matrix para ill-conditioning"
                                  ],
                                  "tips": "Prefira MG sobre clássico para precisão em floating-point.",
                                  "learningObjective": "Aplicar técnicas numéricas para mitigar instabilidade em implementações.",
                                  "commonMistakes": [
                                    "Acumulação de erros de arredondamento sem MG",
                                    "Não normalizar após cada subtração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar com Casos Diversos e Verificar Ortogonalidade",
                                  "subSteps": [
                                    "Crie script de testes: matrizes bem condicionadas, mal condicionadas (ex.: [1 1.0001 1; 0 0.001 0; 0 0 1]).",
                                    "Compute produtos internos entre colunas de Q: max(abs(Q'*Q - eye(n))) < tol.",
                                    "Teste normas: max(abs(diag(Q'*Q)-1)) < tol.",
                                    "Compare com qr(A) built-in do MATLAB.",
                                    "Gere relatório: plote cond(A), cond(Q), erros."
                                  ],
                                  "verification": "Todos testes passam com ortogonalidade <1e-12; coincidem com qr() em 4 casas decimais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB com toolbox simbólica opcional",
                                    "Função cond()"
                                  ],
                                  "tips": "Use assert() para automação de testes.",
                                  "learningObjective": "Validar implementação numericamente em cenários reais.",
                                  "commonMistakes": [
                                    "Usar produto escalar exato sem tolerância",
                                    "Ignorar perda de ortogonalidade em alta dimensão"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [1 1 0; 0 1 1; 1 0 1] (cond(A)≈3.16). Implemente gramSchmidt(A), obtenha Q com colunas ortogonais: verifique Q(:,1)'*Q(:,2) ≈0, ||Q(:,i)||=1, e compare com [Q,R]=qr(A).",
                              "finalVerifications": [
                                "Produtos internos entre vetores distintos de Q são <1e-12.",
                                "Normas euclidianas das colunas de Q são unitárias (≈1).",
                                "Q*R ≈ A com erro <1e-10.",
                                "Função lida com matrizes 10x10 mal condicionadas sem NaN.",
                                "Código comentado e modular.",
                                "Testes automatizados passam 100%."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro de ortogonalidade <1e-10 em testes.",
                                "Eficiência: tempo execução O(n^2 m) para m x n matriz.",
                                "Robustez: warnings para rank-deficient, sem crashes.",
                                "Legibilidade: código limpo com comentários e variáveis descritivas.",
                                "Validação: coincidente com qr() built-in.",
                                "Documentação: help gramSchmidt exibe uso."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição QR e condicionamento.",
                                "Programação Numérica: Estabilidade em floating-point.",
                                "Engenharia Computacional: Solução de sistemas em análise estrutural.",
                                "Análise Numérica: Erros de arredondamento e algoritmos estáveis."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado na decomposição QR para resolver sistemas lineares grandes em análise de estruturas (ex.: método dos elementos finitos), garantindo estabilidade numérica ao ortogonalizar bases para projeções em modos vibracionais ou otimização de vigas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.3",
                              "10.1.2.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Aplicação da Matriz de Gram no Gram-Schmidt",
                        "description": "Integração da matriz de Gram no processo de Gram-Schmidt para ortogonalização eficiente, utilizando decomposições como Cholesky para resolver sistemas e melhorar a precisão em aplicações computacionais de engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Usar decomposição Cholesky da matriz de Gram",
                            "description": "Computar a fatoração L L^T da matriz de Gram G para obter coeficientes de projeção no Gram-Schmidt modificado, resolvendo G c = b para projeções ortogonais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Matriz de Gram e Decomposição Cholesky",
                                  "subSteps": [
                                    "Defina a matriz de Gram G como G = A^T A, onde A é a matriz cujas colunas são os vetores base.",
                                    "Explique que a decomposição Cholesky fatoriza G = L L^T, onde L é triangular inferior com elementos reais positivos na diagonal.",
                                    "Discuta pré-condições: G deve ser simétrica e definida positiva.",
                                    "Relacione com Gram-Schmidt: usada para projeções ortogonais resolvendo G c = b.",
                                    "Estude a fórmula para elementos de L: l_{ii} = sqrt(g_{ii} - sum_{k=1}^{i-1} l_{ik}^2), l_{ji} = (g_{ji} - sum_{k=1}^{j-1} l_{jk} l_{ik}) / l_{jj} para j > i."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos e pré-condições; teste com uma matriz 2x2 simples.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Notebook Jupyter com NumPy",
                                    "Artigo sobre Gram-Schmidt modificado"
                                  ],
                                  "tips": "Visualize graficamente vetores e suas projeções para intuição.",
                                  "learningObjective": "Compreender a base teórica da decomposição Cholesky aplicada à matriz de Gram.",
                                  "commonMistakes": [
                                    "Confundir G = A A^T com G = A^T A",
                                    "Ignorar verificação de positiva definitude"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Propriedades da Matriz de Gram",
                                  "subSteps": [
                                    "Construa a matriz A com vetores não ortogonais (ex: colunas representando funções base em engenharia).",
                                    "Calcule G = A^T A manualmente e verifique simetria (G = G^T).",
                                    "Teste autovalores de G: todos devem ser positivos para definida positiva.",
                                    "Calcule determinante e traço para confirmação adicional.",
                                    "Use software para validar: np.linalg.eigvals(G) > 0."
                                  ],
                                  "verification": "Confirme simetria e todos autovalores positivos; documente resultados.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Calculadora matricial online",
                                    "Planilha Excel para matrizes pequenas"
                                  ],
                                  "tips": "Para engenharia civil, pense em G de rigidez ou cargas em estruturas.",
                                  "learningObjective": "Garantir que a matriz atenda aos requisitos para Cholesky.",
                                  "commonMistakes": [
                                    "Não verificar simetria devidamente",
                                    "Usar autovalores negativos sem notar ill-condicionamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Decomposição Cholesky Manualmente",
                                  "subSteps": [
                                    "Para matriz 2x2: l11 = sqrt(g11), l21 = g21 / l11, l22 = sqrt(g22 - l21^2).",
                                    "Generalize para 3x3: preencha L coluna por coluna usando fórmulas recursivas.",
                                    "Calcule L L^T e verifique se iguala G (erro < 1e-10).",
                                    "Implemente algoritmo em pseudocódigo.",
                                    "Teste com exemplo: A = [[1,0],[1,1],[0,1]], G = A^T A."
                                  ],
                                  "verification": "L L^T ≈ G numericamente; plote resíduos.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Papel e lápis para cálculo manual",
                                    "MATLAB/Python script para Cholesky",
                                    "Tabela de fórmulas"
                                  ],
                                  "tips": "Comece com matrizes pequenas para praticar recursão.",
                                  "learningObjective": "Dominar o algoritmo passo a passo da decomposição.",
                                  "commonMistakes": [
                                    "Erro em índices (confundir i>j)",
                                    "Raiz quadrada de negativo devido a erros de arredondamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Cholesky para Resolver Projeções Ortogonais",
                                  "subSteps": [
                                    "Resolva L y = b via substituição direta (forward substitution).",
                                    "Resolva L^T c = y via substituição reversa (back substitution).",
                                    "Interprete c como coeficientes de projeção no Gram-Schmidt modificado.",
                                    "Verifique ortogonalidade: proj = A c deve ser ortogonal a resíduos.",
                                    "Compare com Gram-Schmidt clássico para validação."
                                  ],
                                  "verification": "||G c - b|| < 1e-10 e verifique ortogonalidade das bases.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Código Python completo",
                                    "Exemplo de dados de engenharia civil (ex: vetores de deslocamentos)"
                                  ],
                                  "tips": "Use np.linalg.solve para benchmark.",
                                  "learningObjective": "Usar Cholesky para projeções eficientes em contextos reais.",
                                  "commonMistakes": [
                                    "Inverter forward/back substitution",
                                    "Não normalizar diagonal de L"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere vetores em análise estrutural: v1 = [1, 1, 0]^T (carga vertical), v2 = [1, 0, 1]^T (carga lateral). G = [[2,1],[1,2]]. Cholesky: L = [[sqrt(2),0],[0.5*sqrt(2),sqrt(1.5)]]. Para b = [3,2]^T, resolva G c = b obtendo c ≈ [1, 0.707], projeção ortogonal para minimizar erro em simulações.",
                              "finalVerifications": [
                                "G = L L^T com erro numérico < 1e-12.",
                                "Todos autovalores de G positivos.",
                                "Solução c satisfaz G c = b.",
                                "Projeção A c é ortogonal aos resíduos.",
                                "Implementação numérica coincide com solver built-in.",
                                "Aplicação em dados reais de engenharia sem crash."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição Cholesky (erro < 1e-10).",
                                "Correta verificação de positiva definitude.",
                                "Eficiência na resolução de sistemas (tempo vs. direto).",
                                "Interpretação correta no contexto de Gram-Schmidt.",
                                "Capacidade de generalizar para n x n.",
                                "Uso apropriado de software sem dependência excessiva."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear múltipla (projeções ortogonais).",
                                "Física/Engenharia Mecânica: Análise modal de vibrações (matrizes de massa/rigidez).",
                                "Computação: Algoritmos numéricos estáveis (condicionamento).",
                                "Otimização: Problemas quadráticos com restrições.",
                                "Processamento de Sinais: Bases ortogonais em Fourier/Wavelets."
                              ],
                              "realWorldApplication": "Na engenharia civil, usar decomposição Cholesky da matriz de Gram para projeções ortogonais em análise finita de elementos, otimizando bases para simulações de estruturas sob cargas dinâmicas, reduzindo condicionamento e acelerando solvers em software como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1",
                              "10.1.2.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Aplicar em ortogonalização de bases para problemas de engenharia",
                            "description": "Resolver um problema de valor inicial ou resíduos ponderados em engenharia civil, ortogonalizando funções base via Gram-Schmidt com matriz de Gram para minimizar erros numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema de engenharia e selecionar bases iniciais",
                                  "subSteps": [
                                    "Identifique o problema de valor inicial ou resíduos ponderados em engenharia civil, como aproximação de deflexão em vigas.",
                                    "Defina o espaço de funções e selecione um conjunto de bases linealmente independentes (ex: polinômios ou funções trigonométricas).",
                                    "Defina o produto interno ponderado relevante ao problema físico.",
                                    "Liste as funções base e verifique linear independência inicial.",
                                    "Prepare os dados numéricos ou simbólicos para computação."
                                  ],
                                  "verification": "Confirme que as bases iniciais são linealmente independentes calculando o determinante da matriz de coeficientes ou ranque.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, software de álgebra simbólica (Mathematica ou SymPy), referências de problemas de engenharia civil.",
                                  "tips": "Escolha bases que aproximem bem a solução física esperada para reduzir iterações futuras.",
                                  "learningObjective": "Compreender como mapear problemas reais para espaços vetoriais funcionais.",
                                  "commonMistakes": "Selecionar bases não adequadas ao domínio físico, ignorando pesos do produto interno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de Gram",
                                  "subSteps": [
                                    "Calcule os produtos internos entre todas as pares de funções base usando a definição ponderada.",
                                    "Monte a matriz G onde G_ij = <φ_i, φ_j> para i,j = 1 a n.",
                                    "Verifique se a matriz é simétrica positiva definida.",
                                    "Implemente numericamente em software para precisão.",
                                    "Analise o condicionamento inicial da matriz G."
                                  ],
                                  "verification": "A matriz deve ser simétrica e com autovalores positivos; teste com Cholesky ou eigenvalues.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software numérico (MATLAB, Python com NumPy/SciPy), quadros para cálculos manuais.",
                                  "tips": "Use integração numérica (Gauss-Legendre) para produtos internos em casos não analíticos.",
                                  "learningObjective": "Dominar o cálculo da matriz de Gram para bases funcionais em contextos ponderados.",
                                  "commonMistakes": "Erros em limites de integração ou esquecimento de fatores de peso."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar ortogonalização Gram-Schmidt usando a matriz de Gram",
                                  "subSteps": [
                                    "Inicie com ψ_1 = φ_1 / ||φ_1||.",
                                    "Para k=2 a n: ψ_k = φ_k - ∑_{j=1}^{k-1} <φ_k, ψ_j> ψ_j, normalizando.",
                                    "Use a matriz G para coeficientes eficientes: c_j = (G^{-1})_{kj} ou fatoração.",
                                    "Implemente iterativamente, atualizando bases ortogonais.",
                                    "Monitore estabilidade numérica em cada iteração."
                                  ],
                                  "verification": "Verifique ortogonalidade: <ψ_i, ψ_j> = 0 para i ≠ j e ||ψ_i|| = 1.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python/MATLAB com solvers lineares, planilha para tracking.",
                                  "tips": "Fatore a matriz G (QR ou Cholesky) para evitar inversões diretas e minimizar erros.",
                                  "learningObjective": "Executar Gram-Schmidt modificado com suporte matricial para estabilidade.",
                                  "commonMistakes": "Acumulação de erros de arredondamento sem reortogonalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o problema usando bases ortogonais e minimizar erros",
                                  "subSteps": [
                                    "Projete a solução no espaço ortogonal: coeficientes α_i = <f, ψ_i> / ||ψ_i||^2.",
                                    "Reconstrua a aproximação u ≈ ∑ α_i ψ_i.",
                                    "Calcule resíduos ponderados e compare com condição original.",
                                    "Avalie convergência adicionando mais bases.",
                                    "Otimize hiperparâmetros baseados em condicionamento."
                                  ],
                                  "verification": "Resíduo normado < threshold (ex: 1e-6); compare com solução exata se disponível.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software de plotagem (Matplotlib), dados de benchmark de engenharia.",
                                  "tips": "Use bases ortogonais para diagonalizar o sistema, acelerando soluções.",
                                  "learningObjective": "Aplicar bases ortogonais para soluções eficientes e numéricas estáveis.",
                                  "commonMistakes": "Ignorar normalização, levando a coeficientes instáveis."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar solução e analisar condicionamento numérico",
                                  "subSteps": [
                                    "Calcule número de condicionamento da matriz final vs. inicial.",
                                    "Teste sensibilidade a perturbações nos dados.",
                                    "Compare com métodos alternativos (ex: SVD).",
                                    "Documente melhorias em precisão e tempo computacional.",
                                    "Gere relatório com gráficos de erro."
                                  ],
                                  "verification": "Condição reduzida em pelo menos 1 ordem de magnitude; testes de robustez passados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de análise numérica (cond() no MATLAB), relatórios LaTeX.",
                                  "tips": "Sempre plote resíduos vs. grau de aproximação para insights visuais.",
                                  "learningObjective": "Avaliar impacto da ortogonalização na estabilidade numérica.",
                                  "commonMistakes": "Subestimar erros de propagação em problemas mal-condicionados."
                                }
                              ],
                              "practicalExample": "Em análise de uma viga simplesmente apoiada sob carga distribuída variável, ortogonalize funções polinomiais Legendre (φ1=x, φ2=x^2, φ3=x^3) com peso w(x)=1 no intervalo [0,L] via Gram-Schmidt e matriz G para aproximar a deflexão u(x), minimizando resíduos ponderados e evitando ill-conditioning em métodos de Galerkin.",
                              "finalVerifications": [
                                "Bases finais ψ_i satisfazem <ψ_i, ψ_j> = δ_ij.",
                                "Número de condicionamento da matriz de projeção reduzido significativamente.",
                                "Resíduo ponderado ||r|| < 1e-8.",
                                "Solução converge monotonicamente com mais bases.",
                                "Testes de sensibilidade mostram estabilidade.",
                                "Comparação com solução analítica exata dentro de 1%."
                              ],
                              "assessmentCriteria": [
                                "Precisão da ortogonalização (erro em produtos internos < 1e-10).",
                                "Eficiência computacional (tempo de execução vs. método direto).",
                                "Redução no condicionamento matricial (κ_final / κ_inicial < 0.1).",
                                "Correção da solução física (erro relativo < 5%).",
                                "Qualidade da documentação e análise de erros.",
                                "Robustez a variações nos dados de entrada."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Espaços vetoriais e produtos internos.",
                                "Análise Numérica: Estabilidade e condicionamento.",
                                "Programação Computacional: Implementação em Python/MATLAB.",
                                "Física/Engenharia Mecânica: Modelos de vigas e equações diferenciais.",
                                "Estatística: Análise de resíduos e mínimos quadrados."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos (FEM) para estruturas civis, ortogonalização Gram-Schmidt melhora condicionamento de matrizes de rigidez, reduzindo tempo de solução em análises sísmicas ou de fadiga em pontes e edifícios, evitando erros numéricos em softwares como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.2.2",
                              "10.1.2.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Autovalores e Autofunções",
                "description": "Cálculo e propriedades de autovalores e autofunções para soluções computacionais em engenharia.",
                "totalSkills": 53,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Definição de Autovalores e Autovetores",
                    "description": "Conceito formal de autovalor λ e autovetor v satisfazendo Av = λv para uma matriz A.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Autovetor",
                        "description": "Um autovetor de uma matriz quadrada A é um vetor coluna não nulo v ∈ ℝⁿ (ou ℂⁿ) tal que a aplicação de A sobre v resulta em um múltiplo escalar de v, preservando a direção do vetor.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Definir formalmente autovetor",
                            "description": "Enunciar a definição precisa de autovetor para uma matriz quadrada A, destacando que v ≠ 0 e que existe λ tal que Av = λv.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de vetores e multiplicação matriz-vetor",
                                  "subSteps": [
                                    "Defina um vetor como uma lista ordenada de números, representado como coluna (ex: v = [v1, v2]^T).",
                                    "Explique a multiplicação de uma matriz quadrada A (n x n) por um vetor v (n x 1), resultando em Av (n x 1).",
                                    "Realize um exemplo simples: Para A = [[2,0],[0,3]] e v = [1,1]^T, compute Av = [2,3]^T.",
                                    "Verifique as dimensões: A deve ser quadrada e compatível com v.",
                                    "Discuta como Av representa uma transformação linear do vetor v."
                                  ],
                                  "verification": "Computar corretamente Av para pelo menos duas matrizes diferentes sem erros dimensionais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou software como MATLAB/Octave (opcional)"
                                  ],
                                  "tips": "Sempre escreva vetores como colunas e verifique dimensões antes de multiplicar.",
                                  "learningObjective": "Compreender como matrizes transformam vetores no espaço linear.",
                                  "commonMistakes": [
                                    "Esquecer o transposto ^T para vetores coluna.",
                                    "Confundir multiplicação escalar com matricial."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de múltiplo escalar e direção invariante",
                                  "subSteps": [
                                    "Defina um múltiplo escalar de um vetor: λv, onde λ é escalar e v ≠ 0.",
                                    "Explique que λv tem a mesma direção que v (se λ > 0) ou oposta (λ < 0), mas mesmo sentido de magnitude ajustada.",
                                    "Diferencie de qualquer outro vetor w ≠ k v para algum k.",
                                    "Exemplo: Para v = [1,0]^T, 3v = [3,0]^T é múltiplo, mas [1,1]^T não é.",
                                    "Discuta por que v = 0 é trivial e excluído."
                                  ],
                                  "verification": "Identificar corretamente múltiplos escalares em exemplos dados e excluir v=0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos impressos de vetores"
                                  ],
                                  "tips": "Visualize graficamente: múltiplos escalares ficam na mesma reta através da origem.",
                                  "learningObjective": "Reconhecer direções invariantes sob escalonamento.",
                                  "commonMistakes": [
                                    "Considerar v=0 como válido.",
                                    "Confundir direção com magnitude."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Apresentar a equação definidora Av = λv",
                                  "subSteps": [
                                    "Enuncie a equação: Para matriz A quadrada, v é autovetor se existe λ tal que Av = λv.",
                                    "Reescreva como (A - λI)v = 0, onde I é identidade.",
                                    "Explique que isso implica v é solução não-trivial do sistema homogêneo.",
                                    "Exemplo: Para A = [[2,0],[0,2]], Av = 2v para qualquer v ≠ 0, λ=2.",
                                    "Verifique com cálculo: Substitua e confira igualdade."
                                  ],
                                  "verification": "Escrever a equação para uma matriz dada e identificar λ e v corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Matrizes de exemplo"
                                  ],
                                  "tips": "Lembre-se: λ é o autovalor correspondente.",
                                  "learningObjective": "Entender a relação algébrica entre A, v e λ.",
                                  "commonMistakes": [
                                    "Esquecer v ≠ 0 na condição.",
                                    "Confundir λ com traço ou determinante."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a definição completa de autovetor",
                                  "subSteps": [
                                    "Defina formalmente: v é autovetor de A se v ≠ 0 e existe λ ∈ ℂ tal que Av = λv.",
                                    "Inclua que A é quadrada (n x n), v ∈ ℝ^n ou ℂ^n.",
                                    "Destaque propriedades: autovetores definem direções próprias da transformação.",
                                    "Exemplo em engenharia: Matriz de rigidez em estruturas.",
                                    "Pratique enunciando em voz alta ou por escrito."
                                  ],
                                  "verification": "Enunciar a definição completa e precisa, incluindo v ≠ 0 e λ.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de álgebra linear (cap. autovalores)"
                                  ],
                                  "tips": "Memorize: 'Não nulo e mapeado em seu múltiplo escalar'.",
                                  "learningObjective": "Dominar a definição formal exata.",
                                  "commonMistakes": [
                                    "Omitir v ≠ 0.",
                                    "Definir sem mencionar λ."
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise estrutural de uma viga simples, a matriz de rigidez A = [[4,-2],[-2,4]] tem autovetor v = [1,1]^T com λ=2, representando um modo de deformação simétrica onde Av = 2v.",
                              "finalVerifications": [
                                "Enuncie corretamente: 'v ≠ 0 tal que Av = λv para algum λ'.",
                                "Explique por que v=0 não é autovetor.",
                                "Identifique autovetor em uma matriz 2x2 simples.",
                                "Diferencie autovetor de autovalor.",
                                "Aplique a definição a um exemplo numérico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na inclusão de v ≠ 0 (obrigatório).",
                                "Correta menção à existência de λ escalar.",
                                "Uso de notação matricial padrão (Av = λv).",
                                "Exclusão de casos triviais na explicação.",
                                "Clareza na distinção entre autovetor e autovalor."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração em estruturas civis.",
                                "Computação: Implementação em software como ANSYS para análise modal.",
                                "Matemática Aplicada: Diagonalização de matrizes em otimização.",
                                "Engenharia Mecânica: Análise de estabilidade de edifícios."
                              ],
                              "realWorldApplication": "Na engenharia civil, autovetores da matriz de massa e rigidez identificam modos de vibração de pontes e edifícios, permitindo prever ressonâncias e evitar colapsos durante terremotos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Verificar se um vetor é autovetor",
                            "description": "Dado uma matriz A e um vetor v, computar Av e determinar se resulta em um escalar múltiplo de v, confirmando ou refutando se v é autovetor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Conceitual de Autovetor",
                                  "subSteps": [
                                    "Revise a definição: Um vetor v é autovetor de A se Av = λv para algum escalar λ ≠ 0.",
                                    "Identifique os componentes: matriz A (quadrada), vetor v (não nulo), produto Av.",
                                    "Diferencie autovetor de autovalor: autovetor é o vetor direção invariante, autovalor é o fator de escala.",
                                    "Estude exemplos simples para fixar o conceito.",
                                    "Anote em suas palavras o critério de verificação."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição e dê um exemplo simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notas de aula sobre álgebra linear",
                                    "Calculadora básica"
                                  ],
                                  "tips": [
                                    "Sempre verifique se v ≠ 0, pois o vetor nulo é trivialmente autovetor."
                                  ],
                                  "learningObjective": "Dominar o conceito teórico de autovetor e o critério matemático de verificação.",
                                  "commonMistakes": [
                                    "Confundir autovetor com autovalor",
                                    "Ignorar que λ pode ser negativo ou complexo",
                                    "Considerar v=0 como válido"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar os Dados: Matriz A e Vetor v",
                                  "subSteps": [
                                    "Obtenha ou defina uma matriz quadrada A (ex: 2x2 ou 3x3).",
                                    "Selecione um vetor coluna v não nulo com dimensões compatíveis.",
                                    "Verifique dimensões: se A é n×n, v é n×1.",
                                    "Escreva explicitamente os elementos de A e v.",
                                    "Confirme que os dados estão corretos por duplicação."
                                  ],
                                  "verification": "Liste A e v corretamente e confirme dimensões compatíveis.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software como MATLAB ou Python (opcional)",
                                    "Exemplos de matrizes de problemas de engenharia"
                                  ],
                                  "tips": [
                                    "Use matrizes simétricas para aplicações em engenharia civil, como rigidez estrutural."
                                  ],
                                  "learningObjective": "Preparar inputs corretos para o cálculo, evitando erros dimensionais.",
                                  "commonMistakes": [
                                    "Dimensões incompatíveis",
                                    "Usar vetor linha em vez de coluna",
                                    "Escolher v=0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o Produto Matriz-Vetor Av",
                                  "subSteps": [
                                    "Aplique a regra de multiplicação: cada elemento de Av é soma de a_ij * v_j.",
                                    "Calcule linha por linha: para i=1 a n, (Av)_i = soma_{j=1}^n a_ij v_j.",
                                    "Use calculadora ou software para precisão em matrizes maiores.",
                                    "Escreva o vetor resultante Av explicitamente.",
                                    "Duplique o cálculo para um elemento aleatório."
                                  ],
                                  "verification": "Compare Av computado com cálculo manual de pelo menos um elemento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Papel e lápis",
                                    "Software NumPy ou MATLAB"
                                  ],
                                  "tips": [
                                    "Organize em tabela para multiplicações paralelas e reduzir erros aritméticos."
                                  ],
                                  "learningObjective": "Executar com precisão o produto matriz-vetor.",
                                  "commonMistakes": [
                                    "Erro aritmético em somas",
                                    "Confundir índices i e j",
                                    "Esquecer normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Proporcionalidade e Concluir",
                                  "subSteps": [
                                    "Compare Av e v: verifique se existe λ tal que Av = λv componente a componente.",
                                    "Calcule λ candidato: λ = (Av)_1 / v_1 se v_1 ≠ 0, e valide para todos componentes.",
                                    "Se todos componentes satisfazem, confirme autovetor; senão, refute.",
                                    "Registre λ se aplicável e a conclusão (sim/não).",
                                    "Teste com variação: troque v e repita para prática."
                                  ],
                                  "verification": "Mostre que todos componentes de Av / v_i são iguais (se v_i ≠ 0).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para comparações",
                                    "Software para automação (opcional)"
                                  ],
                                  "tips": [
                                    "Se v tem zeros, foque em componentes não nulos e verifique consistência."
                                  ],
                                  "learningObjective": "Determinar corretamente se v é autovetor e identificar λ associado.",
                                  "commonMistakes": [
                                    "Aceitar λ diferente por componente",
                                    "Dividir por zero",
                                    "Ignorar arredondamentos numéricos"
                                  ]
                                }
                              ],
                              "practicalExample": "Matriz A = [[2, 0], [0, 3]], vetor v = [1, 0]. Compute Av = [2*1 + 0*0, 0*1 + 3*0] = [2, 0]. Verifique: [2, 0] = 2*[1, 0], sim, autovetor com λ=2. Agora teste v'=[1,1]: Av'=[2,3] ≠ λ[1,1] para qualquer λ único, não é autovetor.",
                              "finalVerifications": [
                                "Av foi computado corretamente componente a componente.",
                                "Foi verificada a existência de λ único satisfazendo Av = λv.",
                                "Conclusão correta: sim/não autovetor, com λ se aplicável.",
                                "Tratamento adequado de zeros em v.",
                                "Sem erros aritméticos significativos.",
                                "Explicação escrita da verificação."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de Av (100% correto).",
                                "Correta identificação de proporcionalidade e λ.",
                                "Clareza na documentação dos passos.",
                                "Tratamento de casos edge (v com zeros).",
                                "Tempo de execução dentro do estimado.",
                                "Compreensão conceitual demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise modal de vibrações em estruturas civis.",
                                "Computação: Implementação de algoritmos como QR para autovalores.",
                                "Engenharia Mecânica: Dinâmica de sistemas multi-graus de liberdade.",
                                "Matemática Aplicada: Diagonalização de matrizes de rigidez."
                              ],
                              "realWorldApplication": "Em engenharia civil, verificar autovetores em matrizes de rigidez permite identificar modos de vibração naturais de pontes ou edifícios, crucial para projetos resistentes a terremotos e ventos, usando software como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Interpretar geometricamente autovetor",
                            "description": "Explicar a interpretação geométrica de um autovetor como uma direção invariante (ou traço) sob a transformação linear representada por A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Conceito de Transformação Linear Geometricamente",
                                  "subSteps": [
                                    "Visualize uma matriz A como uma função que mapeia vetores do plano R² para si mesmo, alterando comprimentos e ângulos.",
                                    "Desenhe o plano unitário e aplique A a vários vetores basis (e1 e e2) para observar esticamentos, rotações ou cisalhamentos.",
                                    "Compare a imagem de A com o original, destacando como pontos se movem em direção a eixos principais.",
                                    "Experimente com matrizes simples, como escalas diagonais, para fixar a intuição visual.",
                                    "Anote as direções que parecem 'se comportar de forma especial' após a transformação."
                                  ],
                                  "verification": "Desenhar pelo menos 3 vetores antes e depois da aplicação de A e descrever as mudanças observadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado e lápis",
                                    "GeoGebra ou MATLAB para simulação visual",
                                    "Matriz de exemplo impressa"
                                  ],
                                  "tips": "Use cores diferentes para vetores originais e imagens para facilitar a visualização.",
                                  "learningObjective": "Desenvolver intuição geométrica sobre como matrizes lineares deformam o plano.",
                                  "commonMistakes": [
                                    "Focar apenas em magnitudes e ignorar direções.",
                                    "Confundir transformação com translação (não linear).",
                                    "Não escalar vetores unitários inicialmente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Direções Invariantes no Plano",
                                  "subSteps": [
                                    "Defina direção invariante como uma linha reta que, sob A, mapeia para si mesma (vetores na linha vão para vetores na mesma linha).",
                                    "Para um diagrama de transformação, trace linhas radiais e veja quais permanecem inalteradas em direção.",
                                    "Teste com vetores em diferentes ângulos e marque aqueles cuja direção não muda após A(v).",
                                    "Diferencie invariância direcional de preservação de comprimento (que depende do autovalor).",
                                    "Crie um esboço manual mostrando todas as direções testadas e destaque as invariantes."
                                  ],
                                  "verification": "Identificar e desenhar pelo menos duas direções invariantes em um diagrama de transformação dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e régua para traçar linhas",
                                    "Software de plotagem vetorial como Desmos",
                                    "Exemplos de matrizes não-diagonalizáveis"
                                  ],
                                  "tips": "Comece com matrizes simétricas para direções ortogonais claras.",
                                  "learningObjective": "Reconhecer geometricamente linhas que são preservadas em direção por uma transformação linear.",
                                  "commonMistakes": [
                                    "Confundir direção invariante com vetor nulo.",
                                    "Assumir que toda direção é invariante em escalas uniformes.",
                                    "Ignorar o sinal do autovalor na inversão de direção."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar Direções Invariantes com Autovetores",
                                  "subSteps": [
                                    "Lembre que autovetor v satisfaz A v = λ v, significando que v é mapeado para um múltiplo escalar na mesma direção.",
                                    "No diagrama, confirme que vetores ao longo da direção invariante satisfazem a equação escalar λ.",
                                    "Calcule λ para a direção identificada e verifique visualmente se o alongamento ou contração corresponde.",
                                    "Diferencie autovetor (vetor específico) de direção invariante (espaço de linha).",
                                    "Aplique a um exemplo: para A = [[3,1],[0,2]], encontre e visualize o autovetor."
                                  ],
                                  "verification": "Resolver Av = λv para um vetor na direção invariante e confirmar λ numericamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python/NumPy para eigenvalores",
                                    "Gráficos pré-computados de A",
                                    "Folha de exercícios com matrizes"
                                  ],
                                  "tips": "Normalize vetores para focar apenas na direção.",
                                  "learningObjective": "Conectar algebraicamente a definição de autovetor à sua interpretação geométrica como direção invariante.",
                                  "commonMistakes": [
                                    "Confundir autovalor com fator de escala em magnitude apenas.",
                                    "Não considerar autovetores complexos em rotações.",
                                    "Esquecer que λ pode ser negativo (inversão)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Interpretar o Papel do Autovetor em Transformações Complexas",
                                  "subSteps": [
                                    "Combine passos anteriores: aplique A a uma grade de vetores e destaque setas ao longo do autovetor.",
                                    "Explique como o autovetor define o 'eixo principal' de deformação da transformação.",
                                    "Compare múltiplos autovetores (para diagonalizáveis) como base de direções independentes invariantes.",
                                    "Discuta não-diagonalizáveis: apenas uma direção invariante real.",
                                    "Crie uma narrativa: 'O autovetor é o traço que a transformação segue fielmente.'"
                                  ],
                                  "verification": "Produzir um diagrama completo rotulado mostrando autovetor, direção invariante e fluxo de transformação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software como MATLAB ou Python (matplotlib)",
                                    "Templates de diagramas em PDF",
                                    "Vídeos tutoriais de eigenvisualização"
                                  ],
                                  "tips": "Use animações para ver o fluxo contínuo da transformação.",
                                  "learningObjective": "Integrar a interpretação geométrica completa de autovetores em qualquer transformação linear.",
                                  "commonMistakes": [
                                    "Generalizar um exemplo simples para todos os casos.",
                                    "Ignorar multiplicidade algébrica vs. geométrica.",
                                    "Não visualizar o plano inteiro além do autovetor."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz de deformação em uma viga de engenharia civil A = [[2, 1], [0, 1.5]], representando alongamento preferencial. O autovetor [1, 0] (direção x) é invariante: A[1,0] = [2,0] = 2*[1,0], esticando-se por fator 2 sem mudança de direção. Visualize: vetores horizontais permanecem horizontais, enquanto outros são 'puxados' para cima, modelando tensão uniaxial em estruturas.",
                              "finalVerifications": [
                                "Desenhar corretamente o diagrama de transformação destacando a direção do autovetor.",
                                "Explicar verbalmente: 'O autovetor aponta para onde a transformação preserva direção.'",
                                "Identificar autovetor em um novo diagrama sem cálculo algébrico.",
                                "Diferenciar direção invariante de preservação de comprimento.",
                                "Aplicar a interpretação a uma matriz de 2x2 dada.",
                                "Confirmar Av = λv visual e numericamente para um exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de direções invariantes (90% correto).",
                                "Clareza e rotulagem correta em diagramas visuais.",
                                "Explicação conceitual sem erros algébricos (ex: confundir v com Av).",
                                "Uso apropriado de autovalor para descrever escala direcional.",
                                "Capacidade de generalizar para matrizes não simétricas.",
                                "Integração de intuição geométrica com definição formal."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração em estruturas (autovetores de matriz de rigidez).",
                                "Computação: Análise de componentes principais (PCA) para redução dimensional.",
                                "Engenharia Mecânica: Análise modal de estabilidade dinâmica.",
                                "Matemática Aplicada: Diagonalização para simplificar sistemas diferenciais."
                              ],
                              "realWorldApplication": "Na engenharia civil, interpretar autovetores geometricamente permite analisar direções principais de deformação em vigas e lajes sob carga, identificando 'linhas de traço' onde a estrutura se deforma uniformemente sem torção, essencial para design seguro de pontes e edifícios contra vibrações sísmicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Autovalor",
                        "description": "Um autovalor λ é o escalar associado a um autovetor v na equação Av = λv, representando o fator de escala (alongamento ou contração) ao longo da direção do autovetor.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Definir formalmente autovalor",
                            "description": "Enunciar a definição de autovalor como o escalar λ ∈ ℝ (ou ℂ) que satisfaz Av = λv para algum v ≠ 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar multiplicação de matriz por vetor",
                                  "subSteps": [
                                    "Lembre-se da definição de uma matriz A de ordem n×n e vetor coluna v ∈ ℝⁿ.",
                                    "Compute Av para exemplos simples, como A = [[1,2],[3,4]] e v = [1,0]ᵀ.",
                                    "Identifique o resultado como uma combinação linear das colunas de A escaladas pelos componentes de v.",
                                    "Pratique com pelo menos três exemplos variados.",
                                    "Discuta o significado geométrico: Av como transformação linear aplicada a v."
                                  ],
                                  "verification": "Computar corretamente Av para duas matrizes 2×2 dadas sem erros aritméticos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Exemplos de matrizes pré-definidas"
                                  ],
                                  "tips": [
                                    "Verifique dimensões: Av resulta em vetor da mesma dimensão de v.",
                                    "Use notação de colunas para vetores."
                                  ],
                                  "learningObjective": "Compreender a operação fundamental Av como base para autovalores.",
                                  "commonMistakes": [
                                    "Confundir multiplicação matricial com escalar.",
                                    "Esquecer transposição em vetores linha."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o conceito de direção invariante sob transformação linear",
                                  "subSteps": [
                                    "Visualize transformações lineares que preservam direção de certos vetores (ex: alongamento sem rotação).",
                                    "Identifique vetores v ≠ 0 tais que Av é paralelo a v, ou seja, Av = k v para algum escalar k.",
                                    "Teste com exemplos: para A identidade, todo v é invariante com k=1.",
                                    "Diferencie de vetores nulos: enfatize v ≠ 0.",
                                    "Desenhe geometricamente em ℝ² para matrizes de escalonamento ou cisalhamento."
                                  ],
                                  "verification": "Explicar verbalmente por que Av paralelo a v implica direção invariante.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de visualização como GeoGebra ou MATLAB plot",
                                    "Exemplos gráficos de transformações"
                                  ],
                                  "tips": [
                                    "Pense em 'esticar' ao longo de eixos principais.",
                                    "Use setas para mostrar antes/depois da transformação."
                                  ],
                                  "learningObjective": "Entender intuitivamente autovalores como fatores de escala em direções invariantes.",
                                  "commonMistakes": [
                                    "Ignorar que k pode ser negativo (inversão de direção).",
                                    "Confundir com autovetores nulos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a equação do autovalor",
                                  "subSteps": [
                                    "Escreva a equação Av = λv, onde λ é o escalar (autovalor).",
                                    "Reorganize como (A - λI)v = 0, destacando não-trivialidade.",
                                    "Discuta o campo: λ ∈ ℝ para problemas reais, ou ℂ para gerais.",
                                    "Enuncie: λ é autovalor se existe v ≠ 0 satisfazendo a equação.",
                                    "Pratique reescrevendo três equações dadas na forma padrão."
                                  ],
                                  "verification": "Derivar corretamente (A - λI)v = 0 a partir de Av = λv.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quadro ou papel para derivações",
                                    "Tabela de identidades matriciais"
                                  ],
                                  "tips": [
                                    "I é a matriz identidade do mesmo ordem de A.",
                                    "λ pode ser complexo mesmo para A real."
                                  ],
                                  "learningObjective": "Dominar a notação matemática formal da definição.",
                                  "commonMistakes": [
                                    "Esquecer o I em (A - λI).",
                                    "Permitir v = 0 como autovetor."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Enunciar e verificar a definição completa",
                                  "subSteps": [
                                    "Compile a definição: 'Autovalor λ ∈ ℝ (ou ℂ) de A se ∃ v ≠ 0 tal que Av = λv'.",
                                    "Teste com exemplo: A = [[2,1],[0,2]], verifique λ=2 com v=[1,0]ᵀ.",
                                    "Discuta unicidade: múltiplos λ possíveis, mas foco na existência.",
                                    "Escreva a definição em palavras e símbolos três vezes.",
                                    "Autoavalie distinguindo autovalor de autovetor."
                                  ],
                                  "verification": "Enunciar a definição completa sem hesitação ou erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo de matriz com autovalores conhecidos",
                                    "Flashcards com definições"
                                  ],
                                  "tips": [
                                    "Memorize: escalar λ, vetor v ≠ 0, equação Av = λv.",
                                    "Pratique oralmente para fluência."
                                  ],
                                  "learningObjective": "Capacitar-se a definir formalmente autovalor em contextos acadêmicos.",
                                  "commonMistakes": [
                                    "Omitir v ≠ 0.",
                                    "Confundir domínio: λ sempre real?"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise estrutural de uma viga simples, considere a matriz de rigidez A = [[4, -2], [-2, 4]] (unidades kN/m). Um autovalor λ=2 satisfaz A v = 2v para v=[1,1]ᵀ, representando um modo de deformação uniforme sem rotação relativa.",
                              "finalVerifications": [
                                "Enunciar corretamente a definição formal incluindo v ≠ 0.",
                                "Explicar o papel de λ como fator de escala.",
                                "Derivar (A - λI)v = 0.",
                                "Distinguir autovalor de autovetor.",
                                "Aplicar a definição a um exemplo 2×2.",
                                "Mencionar campos ℝ e ℂ adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na equação Av = λv (100% correto).",
                                "Inclusão explícita de v ≠ 0.",
                                "Compreensão conceitual de direção invariante.",
                                "Uso correto de notação matemática.",
                                "Capacidade de verificar com exemplo numérico.",
                                "Fluência na enunciação oral/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração em estruturas (frequências naturais como autovalores).",
                                "Computação: Implementação de solvers de autovalores em Python (NumPy.linalg.eig).",
                                "Matemática Aplicada: Estabilidade de sistemas dinâmicos lineares.",
                                "Engenharia Mecânica: Análise de vibrações modais."
                              ],
                              "realWorldApplication": "Na engenharia civil, autovalores da matriz de rigidez/massa determinam frequências naturais de edifícios, essenciais para design sísmico e evitar ressonância em terremotos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Calcular autovalor dado A e v",
                            "description": "Para uma matriz A e autovetor v conhecido, resolver Av = λv para encontrar o autovalor λ correspondente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados: Matriz A e vetor autovetor v",
                                  "subSteps": [
                                    "Identifique a matriz quadrada A e o vetor coluna v fornecidos.",
                                    "Verifique se v é não-nulo (||v|| ≠ 0).",
                                    "Escolha uma representação numérica adequada (papel, calculadora ou software como Python/MATLAB).",
                                    "Anote dimensões: A é n×n, v é n×1.",
                                    "Opcionalmente, normalize v para ||v||=1 para simplificar cálculos."
                                  ],
                                  "verification": "A e v estão corretamente transcritos e v ≠ 0 confirmado por soma de quadrados das componentes > 0.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Matriz A",
                                    "Vetor v",
                                    "Papel e caneta ou software de álgebra linear (ex: NumPy)"
                                  ],
                                  "tips": "Sempre confirme dimensões para evitar erros de multiplicação.",
                                  "learningObjective": "Preparar dados de entrada de forma precisa para computação de autovalor.",
                                  "commonMistakes": [
                                    "Transcrever errado elementos de A ou v",
                                    "Usar vetor v nulo",
                                    "Confundir vetor linha e coluna"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o produto matriz-vetor Av",
                                  "subSteps": [
                                    "Aplique a fórmula de multiplicação: (Av)_i = soma_{j=1 a n} A_{ij} * v_j para cada i=1 a n.",
                                    "Calcule componente por componente, linha por linha de A.",
                                    "Registre o vetor resultante Av com precisão decimal adequada.",
                                    "Verifique aritmética básica somando/verificando um componente manualmente.",
                                    "Compare com cálculo alternativo se software disponível."
                                  ],
                                  "verification": "Recalcule um componente aleatório para confirmar igualdade exata ou dentro de tolerância 1e-6.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Matriz A",
                                    "Vetor v",
                                    "Calculadora ou software (ex: MATLAB, Python com NumPy)"
                                  ],
                                  "tips": "Prossiga linha por linha para evitar confusão; use parênteses em cálculos manuais.",
                                  "learningObjective": "Executar multiplicação matriz-vetor com precisão.",
                                  "commonMistakes": [
                                    "Confundir índices de linha/coluna",
                                    "Erros aritméticos em somas",
                                    "Esquecer de multiplicar todos os termos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair o autovalor λ da equação Av = λv",
                                  "subSteps": [
                                    "Identifique índices i onde v_i ≠ 0.",
                                    "Calcule λ = (Av)_i / v_i para pelo menos dois índices diferentes.",
                                    "Confirme que todos os λ calculados são iguais (consistência).",
                                    "Se v unitário, use λ = v^T Av (produto escalar).",
                                    "Registre λ com precisão adequada."
                                  ],
                                  "verification": "λ é idêntico (diferença < 1e-10) para todos i com v_i ≠ 0.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Vetor Av calculado",
                                    "Vetor v",
                                    "Calculadora"
                                  ],
                                  "tips": "Prefira componentes maiores de v para minimizar erro numérico.",
                                  "learningObjective": "Resolver a equação eigenvector para o escalar autovalor.",
                                  "commonMistakes": [
                                    "Dividir por v_i = 0",
                                    "Usar índice inconsistente",
                                    "Ignorar arredondamentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a validade da solução",
                                  "subSteps": [
                                    "Calcule o vetor λv componente por componente.",
                                    "Compare Av e λv elemento a elemento.",
                                    "Compute a norma do erro: ||Av - λv||_2 < 1e-10.",
                                    "Confirme que A é quadrada e v não-trivial.",
                                    "Documente o par (λ, v) como autovalor-autovetor."
                                  ],
                                  "verification": "||Av - λv|| ≈ 0 e consistência confirmada.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Av",
                                    "λ",
                                    "v",
                                    "Software para norma (opcional)"
                                  ],
                                  "tips": "Use tolerância numérica 1e-10 para flutuações de ponto flutuante.",
                                  "learningObjective": "Validar numericamente a relação autovalor-autovetor.",
                                  "commonMistakes": [
                                    "Pular verificação",
                                    "Tolerar erros grandes",
                                    "Erro em cálculo de λv"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[2, 1], [1, 2]] e v = [1, 1]^T. Calcule Av = [2*1 + 1*1, 1*1 + 2*1]^T = [3, 3]^T. Então λ = 3/1 = 3 (ou 3/1). Verifique: 3*[1,1]^T = [3,3]^T = Av. λ = 3 é o autovalor.",
                              "finalVerifications": [
                                "Av = λv exatamente ou com erro < 1e-10.",
                                "λ consistente em todos componentes não-nulos de v.",
                                "v é não-trivial (não o vetor zero).",
                                "Cálculos de Av sem erros aritméticos.",
                                "Dimensões de A e v compatíveis (quadrada n×n e n×1)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de Av (erro zero).",
                                "Correção na extração de λ (consistente).",
                                "Verificação completa com norma de erro.",
                                "Eficiência: tempo dentro do estimado.",
                                "Explicação clara do processo.",
                                "Identificação de erros potenciais evitados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Fundamento de autovalores.",
                                "Computação Numérica: Multiplicação matricial e estabilidade.",
                                "Física: Modos normais em vibrações estruturais.",
                                "Engenharia Civil: Análise modal de edifícios.",
                                "Programação: Implementação em Python/MATLAB."
                              ],
                              "realWorldApplication": "Na engenharia civil, calcula frequências naturais de vibração de estruturas (ex: pontes, edifícios) resolvendo autovalores da matriz [K - ω²M]u = 0, onde λ = ω², essencial para análise sísmica e design contra ressonância."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Interpretar o papel do autovalor",
                            "description": "Descrever como λ indica o fator de escala na direção do autovetor, incluindo casos de λ > 1 (expansão), 0 < λ < 1 (contração) e λ < 0 (inversão).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição conceitual de autovalor e autovetor",
                                  "subSteps": [
                                    "Relembre que um autovetor v satisfaz Av = λv, onde A é a matriz, v é o autovetor e λ o autovalor.",
                                    "Entenda que a transformação linear A alonga, contrai ou inverte o vetor v por um fator λ na sua direção.",
                                    "Visualize geometricamente: o autovetor mantém direção, mas magnitude é escalada por |λ|.",
                                    "Discuta o papel de λ como fator de escala intrínseco à direção do autovetor.",
                                    "Esboce um diagrama simples mostrando v e Av para um λ genérico."
                                  ],
                                  "verification": "Desenhe e rotule um diagrama mostrando v, Av e o fator λ; confirme que direção é preservada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora gráfica ou app de álgebra linear (ex: GeoGebra)"
                                  ],
                                  "tips": "Sempre normalize o autovetor para |v|=1 para isolar o efeito de λ.",
                                  "learningObjective": "Compreender que λ quantifica a escala na direção invariante do autovetor.",
                                  "commonMistakes": "Confundir autovetor com direção alterada; ignorar que λ pode ser complexo em contextos avançados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o caso λ > 1: Expansão na direção do autovetor",
                                  "subSteps": [
                                    "Calcule Av para um autovetor unitário v e λ=2, observando que ||Av|| = 2||v||.",
                                    "Interprete geometricamente: o vetor é esticado além do comprimento original.",
                                    "Aplique a uma matriz 2x2 diagonal simples, como diag(2,1), e plote v1=[1,0] antes/depois.",
                                    "Discuta implicações: amplificação de deformações em direções principais.",
                                    "Compare com transformação identidade (λ=1, sem mudança)."
                                  ],
                                  "verification": "Compute e plote Av para λ>1; meça o fator de escala exato.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem (Python/Matplotlib ou MATLAB)",
                                    "Matriz de exemplo impressa"
                                  ],
                                  "tips": "Use setas coloridas para visualizar expansão; teste com λ=3 para exagerar o efeito.",
                                  "learningObjective": "Identificar e descrever expansão como λ>1 indica alongamento direcional.",
                                  "commonMistakes": "Assumir expansão em todas direções; esquecer normalização inicial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar 0 < λ < 1: Contração e λ < 0: Inversão",
                                  "subSteps": [
                                    "Para 0<λ<1 (ex: λ=0.5), compute Av e note ||Av|| < ||v||, interpretando como encolhimento.",
                                    "Para λ<0 (ex: λ=-1), observe inversão (reflexão através da origem) com escala |λ|.",
                                    "Plote exemplos: diag(0.5,-2) com v1=[1,0], v2=[0,1]; destaque mudança de sinal.",
                                    "Compare os três casos em uma tabela: expansão, contração, inversão.",
                                    "Verifique com multiplicação matricial manual para matriz não-diagonal."
                                  ],
                                  "verification": "Crie tabela comparativa e plots mostrando os três comportamentos; explique cada um verbalmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Planilha Excel para cálculos manuais"
                                  ],
                                  "tips": "Para λ<0, pense em espelhos: inverte direção mas escala magnitude.",
                                  "learningObjective": "Diferenciar contração (0<λ<1) de inversão (λ<0) pelo sinal e magnitude de λ.",
                                  "commonMistakes": "Ignorar sinal negativo como mera escala; confundir contração com λ=0 (aniquilação)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar interpretação através de exemplo computacional",
                                  "subSteps": [
                                    "Escolha matriz de engenharia civil, ex: rigidez de viga com autovalores λ1=1.5, λ2=0.8, λ3=-1.2.",
                                    "Compute autovalores/autovetores numericamente e aplique transformação.",
                                    "Visualize efeitos em deformações modais: expansão em modo crítico, contração em estabilizado.",
                                    "Descreva verbalmente o papel de cada λ na resposta estrutural.",
                                    "Teste sensibilidade alterando λ e reavaliando."
                                  ],
                                  "verification": "Gere relatório curto com plots e descrições dos papéis de λ; sem erros conceituais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/NumPy/SciPy para eig",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use animações para mostrar iterações de potência destacando escalas.",
                                  "learningObjective": "Aplicar interpretação de λ em contexto computacional real.",
                                  "commonMistakes": "Não contextualizar com engenharia; erros numéricos em eigendecomposição."
                                }
                              ],
                              "practicalExample": "Considere a matriz de transformação de tensões em uma laje de concreto: A = [[2, 0], [0, 0.5]]. Para autovetor v=[1,0], λ=2 causa expansão (alongamento em direção principal sob carga). Para v=[0,1], λ=0.5 contrai (compressão estabilizada). Plotando, visualiza-se deformação anisotrópica.",
                              "finalVerifications": [
                                "Explica corretamente λ como fator de escala direcional em autovetor.",
                                "Identifica expansão (λ>1), contração (0<λ<1) e inversão (λ<0) com exemplos.",
                                "Visualiza geometricamente Av = λv para casos variados.",
                                "Aplica a matriz simples e descreve efeitos sem erros.",
                                "Discute implicações em estabilidade estrutural.",
                                "Diferencia λ=0 (direção nula) de outros casos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição geométrica do papel de λ (80%+ acerto).",
                                "Correta classificação de casos baseados em valor de λ.",
                                "Qualidade de visualizações/plots (clareza e legendas).",
                                "Profundidade na interpretação contextual (engenharia civil).",
                                "Ausência de equívocos comuns como ignorar sinal de λ.",
                                "Capacidade de sintetizar em relatório conciso."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração em estruturas (frequências ∝ √λ).",
                                "Computação: Algoritmos de decomposição espectral (eig em SciPy).",
                                "Matemática: Geometria linear e transformações afins.",
                                "Engenharia Mecânica: Análise de buckling (fatores críticos como autovalores)."
                              ],
                              "realWorldApplication": "Em análise modal de pontes, λ>1 indica modos de expansão instável sob vento (risco de ressonância); 0<λ<1 modos contraídos (estáveis); λ<0 sinaliza inversões em cargas assimétricas, guiando reforços computacionais para segurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Equação Definidora Av = λv",
                        "description": "A equação fundamental Av = λv, equivalente a (A - λI)v = 0, que formaliza a relação entre matriz A, autovalor λ e autovetor v.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Enunciar e reescrever a equação definidora",
                            "description": "Escrever a equação Av = λv e reescrevê-la na forma (A - λI)v = 0, explicando o significado de I como matriz identidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de matrizes e vetores",
                                  "subSteps": [
                                    "Defina matriz A como uma matriz quadrada n x n representando uma transformação linear.",
                                    "Explique vetor v como um vetor não nulo coluna n x 1.",
                                    "Introduza escalar λ como o autovalor associado.",
                                    "Discuta multiplicação matricial Av resultando em um escalar vezes v.",
                                    "Verifique compreensão com notação simbólica."
                                  ],
                                  "verification": "Escreva definições corretas de A, v e λ em um papel ou documento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, ou editor de texto como Notion ou Google Docs",
                                  "tips": "Use exemplos visuais como setas para transformação linear para intuitividade.",
                                  "learningObjective": "Compreender os componentes notacionais da equação definidora.",
                                  "commonMistakes": "Confundir v como linha em vez de coluna; ignorar que v é não nulo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar a equação definidora Av = λv",
                                  "subSteps": [
                                    "Escreva a equação Av = λv explicitamente.",
                                    "Interprete geometricamente: A estica/rotaciona v por fator λ na mesma direção.",
                                    "Diferencie de equações lineares comuns, enfatizando direção preservada.",
                                    "Pratique escrevendo para dimensões 2x2.",
                                    "Explique verbalmente o significado físico em contextos de engenharia."
                                  ],
                                  "verification": "Reescreva a equação três vezes com variações de notação e explique oralmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Caderno de exercícios, calculadora gráfica opcional",
                                  "tips": "Memorize como 'A de v é lambda vezes v' para fluência.",
                                  "learningObjective": "Enunciar corretamente a definição padrão de autovetor e autovalor.",
                                  "commonMistakes": "Escrever λAv = v em vez de Av = λv; esquecer que λ pode ser complexo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reescrever a equação na forma (A - λI)v = 0",
                                  "subSteps": [
                                    "Subtraia λv de ambos os lados: Av - λv = 0.",
                                    "Fatore v: (A - λI)v = 0, introduzindo I como identidade.",
                                    "Verifique algebricamente movendo termos.",
                                    "Escreva explicitamente para matriz 2x2.",
                                    "Confirme que solução não trivial requer det(A - λI) = 0."
                                  ],
                                  "verification": "Derive a forma rearranjada passo a passo e teste com números simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software como MATLAB ou Python (NumPy) para verificação numérica",
                                  "tips": "Pense em I como '1' matricial para analogia escalar.",
                                  "learningObjective": "Derivar a forma homogênea equivalente da equação definidora.",
                                  "commonMistakes": "Escrever A - Iλ em vez de A - λI; confundir ordem de subtração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar o significado da matriz identidade I",
                                  "subSteps": [
                                    "Defina I como matriz diagonal com 1s na diagonal principal.",
                                    "Mostre que λI é λ escalado em cada direção base.",
                                    "Ilustre com exemplo 2x2: I = [[1,0],[0,1]].",
                                    "Explique por que (A - λI) representa desvio da transformação por λ.",
                                    "Discuta uso computacional em solvers de autovalores."
                                  ],
                                  "verification": "Construa I para n=3 e compute λI, explicando em palavras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha Excel ou Jupyter Notebook para matrizes",
                                  "tips": "Visualize I como 'não muda nada', então λI escala uniformemente.",
                                  "learningObjective": "Compreender o papel algébrico e computacional de I na equação.",
                                  "commonMistakes": "Confundir I com matriz zero; esquecer que I é única por dimensão."
                                }
                              ],
                              "practicalExample": "Para A = [[2,1],[1,2]], assuma λ=3, v=[1,1]^T. Verifique Av = [3,3]^T = 3v. Reescreva: (A - 3I) = [[-1,1],[1,-1]], então (A-3I)v = [-1+1,1-1]^T = [0,0]^T.",
                              "finalVerifications": [
                                "Enuncie Av = λv sem erros de notação.",
                                "Derive corretamente (A - λI)v = 0 em menos de 1 minuto.",
                                "Explique I como matriz que satisfaz Iv = v para qualquer v.",
                                "Aplique a equação a uma matriz 2x2 fornecida.",
                                "Identifique quando a equação tem soluções não triviais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica (100% correto).",
                                "Clareza na explicação verbal do papel de cada símbolo.",
                                "Uso correto de notação matricial padrão.",
                                "Capacidade de generalizar para dimensões maiores.",
                                "Identificação de pré-condições (v ≠ 0).",
                                "Integração com contexto computacional em engenharia."
                              ],
                              "crossCurrularConnections": [
                                "Física: Modos normais de vibração em estruturas (matrizes de rigidez).",
                                "Computação: Algoritmos QR para autovalores em solvers numéricos.",
                                "Matemática: Sistemas homogêneos lineares e nulidade.",
                                "Engenharia: Análise de estabilidade em elementos finitos."
                              ],
                              "realWorldApplication": "Em engenharia civil, essa equação é usada em análise modal de edifícios para encontrar frequências naturais de vibração, ajudando a projetar estruturas resistentes a terremotos via software como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Verificar a equação para exemplos numéricos",
                            "description": "Dado A, λ e v, computar ambos os lados da equação Av = λv para validar se satisfaz a definição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o exemplo numérico com A, λ e v",
                                  "subSteps": [
                                    "Identifique a matriz A (ex: 2x2 ou 3x3) de um problema conhecido",
                                    "Selecione o autovalor λ fornecido ou calculado previamente",
                                    "Defina o autovetor v correspondente, normalizado se aplicável",
                                    "Anote todos os valores em formato matricial e vetorial claro",
                                    "Verifique dimensões: A é n x n, v é n x 1"
                                  ],
                                  "verification": "Lista de A, λ e v anotada corretamente sem erros de transcrição",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, calculadora ou software como MATLAB/Python/Octave",
                                  "tips": "Comece com matrizes 2x2 simples para prática rápida",
                                  "learningObjective": "Configurar dados de entrada precisos para verificação",
                                  "commonMistakes": "Confundir autovetor com autovalor ou dimensões erradas"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar o produto matricial Av",
                                  "subSteps": [
                                    "Aplique a regra de multiplicação matricial: cada elemento (Av)_i = soma A_{ij} * v_j",
                                    "Calcule linha por linha do vetor resultado",
                                    "Registre valores intermediários para rastreamento",
                                    "Arredonde se necessário, mas mantenha precisão decimal alta",
                                    "Valide com software se disponível para dupla checagem"
                                  ],
                                  "verification": "Vetor Av calculado coincide com resultado de ferramenta computacional",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora matricial, planilha Excel ou script Python (numpy.dot(A,v))",
                                  "tips": "Use multiplicação por partes para matrizes pequenas",
                                  "learningObjective": "Executar multiplicação matricial vetor corretamente",
                                  "commonMistakes": "Erros em índices (confundir linhas/colunas) ou sinais"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o produto escalar λv",
                                  "subSteps": [
                                    "Multiplique cada componente de v pelo escalar λ",
                                    "Mantenha a estrutura vetorial do resultado",
                                    "Compare dimensões: deve ser mesmo tamanho de v",
                                    "Anote o vetor λv explicitamente",
                                    "Verifique se λ é real ou complexo conforme contexto"
                                  ],
                                  "verification": "Cada elemento de λv é exatamente λ vezes o correspondente em v",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Papel e caneta ou calculadora simples",
                                  "tips": "Escalar é trivial; foque em precisão aritmética",
                                  "learningObjective": "Realizar multiplicação escalar-vetor sem erros",
                                  "commonMistakes": "Aplicar λ errado ou esquecer componentes zero"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Av e λv e validar a equação",
                                  "subSteps": [
                                    "Subtraia elemento a elemento: Av - λv deve ser vetor nulo (ou próximo de zero numericamente)",
                                    "Calcule norma euclidiana ||Av - λv|| < tolerância (ex: 1e-10)",
                                    "Interprete: se igual, confirma autovetor; senão, revise cálculos",
                                    "Documente conclusão com evidências numéricas",
                                    "Discuta implicações se não satisfizer (erro numérico ou não autovetor)"
                                  ],
                                  "verification": "Diferença entre Av e λv é numericamente zero e conclusão justificada",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora para norma, software para precisão",
                                  "tips": "Use tolerância para flutuações de ponto flutuante",
                                  "learningObjective": "Validar definição de autovetor via equação característica",
                                  "commonMistakes": "Ignorar erros de arredondamento ou declarar falso positivo"
                                }
                              ],
                              "practicalExample": "Dada A = [[2, 1], [1, 2]], λ = 3, v = [1, 1]^T. Compute Av = [[2*1 + 1*1], [1*1 + 2*1]] = [3, 3]^T. λv = [3*1, 3*1] = [3, 3]^T. Av = λv, confirmado.",
                              "finalVerifications": [
                                "Av e λv são vetores idênticos elemento a elemento",
                                "Cálculos de multiplicação sem erros aritméticos",
                                "Norma da diferença ||Av - λv|| < 1e-10",
                                "Conclusão correta sobre satisfação da equação",
                                "Documentação completa com valores intermediários",
                                "Tolerância numérica considerada adequadamente"
                              ],
                              "assessmentCriteria": [
                                "Precisão na multiplicação matricial (100% correto)",
                                "Correção no produto escalar-vetor",
                                "Método de comparação rigoroso (subtração/norma)",
                                "Interpretação física/matemática da validação",
                                "Uso adequado de ferramentas computacionais",
                                "Clareza na documentação e justificativa"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Fundamentos de produtos matriciais",
                                "Programação Numérica: Implementação em Python/MATLAB para verificação",
                                "Engenharia Estrutural: Modos de vibração em análise modal",
                                "Física: Sistemas dinâmicos e estabilidade",
                                "Estatística: Validação numérica e erros de propagação"
                              ],
                              "realWorldApplication": "Na engenharia civil, verifica se modos de vibração de estruturas (pontes, edifícios) são autovetores corretos, garantindo precisão em simulações de dinâmica para prevenção de colapsos ressonantes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.3",
                            "name": "Discutir condições necessárias",
                            "description": "Explicar as condições essenciais: A quadrada, v ≠ 0, e implicações se v = 0 (trivialidade).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Equação Definidora de Autovalores",
                                  "subSteps": [
                                    "Relembre a equação definidora: Av = λv, onde A é uma matriz, v é um vetor não nulo e λ é um escalar.",
                                    "Identifique os componentes: A (matriz), v (autovetor), λ (autovalor).",
                                    "Escreva a equação em forma matricial e vetorial para visualização.",
                                    "Discuta o significado geométrico: v é esticado por λ após multiplicação por A.",
                                    "Pratique reescrevendo a equação como (A - λI)v = 0."
                                  ],
                                  "verification": "Escreva corretamente a equação definidora e explique cada termo em uma frase curta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora matricial ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Use notação consistente para evitar confusão entre v e λ.",
                                  "learningObjective": "Compreender a estrutura fundamental da equação de autovalores.",
                                  "commonMistakes": "Confundir autovetor com autovalor ou esquecer o papel de λ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Condição de A Ser Quadrada",
                                  "subSteps": [
                                    "Explique por que A deve ter dimensões n x n (quadrada) para multiplicação Av resultar em um vetor do mesmo tamanho de v.",
                                    "Teste com uma matriz não quadrada (ex: 2x3) e observe incompatibilidade dimensional.",
                                    "Discuta como isso afeta o problema de autovalores em contextos de engenharia.",
                                    "Verifique dimensionalidade em exemplos simples de matrizes quadradas.",
                                    "Relacione com aplicações em engenharia civil, como matrizes de rigidez."
                                  ],
                                  "verification": "Demonstre com um exemplo numérico por que uma matriz retangular falha na equação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de álgebra linear (MATLAB, Python com NumPy)",
                                    "Exemplos de matrizes impressas"
                                  ],
                                  "tips": "Sempre confira dimensões antes de qualquer multiplicação matricial.",
                                  "learningObjective": "Justificar a necessidade de A quadrada para consistência vetorial.",
                                  "commonMistakes": "Ignorar dimensões e assumir compatibilidade em matrizes retangulares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Condição v ≠ 0 (Não-Trivialidade)",
                                  "subSteps": [
                                    "Defina solução trivial: v = 0 satisfaz Av = λv para qualquer λ, mas é inútil.",
                                    "Mostre matematicamente: A*0 = λ*0 = 0, logo sempre verdadeira.",
                                    "Explique por que buscamos soluções não-triviais em análise modal.",
                                    "Calcule autovalores para uma matriz simples, destacando vetores não-nulos.",
                                    "Discuta implicações em problemas de engenharia: vetores nulos não representam modos de vibração."
                                  ],
                                  "verification": "Resolva Av = λv para v=0 e explique por que é descartado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz de exemplo 2x2",
                                    "Software para cálculo de autovalores"
                                  ],
                                  "tips": "Lembre-se: trivialidade ignora o propósito físico dos autovetores.",
                                  "learningObjective": "Entender a importância da não-trivialidade para soluções significativas.",
                                  "commonMistakes": "Aceitar v=0 como autovetor válido sem questionar utilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Implicações das Condições e Trivialidade",
                                  "subSteps": [
                                    "Resuma condições: A quadrada + v ≠ 0 para autovalores propriamente ditos.",
                                    "Explore consequências se condições falharem: sem autovalores definidos.",
                                    "Aplique em contexto computacional: algoritmos assumem essas condições.",
                                    "Discuta normalização de autovetores para padronização.",
                                    "Conclua com importância em simulações de engenharia civil."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo condições e implicações de v=0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Resumo em folha",
                                    "Exemplo de matriz de engenharia"
                                  ],
                                  "tips": "Ligue teoria à prática para fixação.",
                                  "learningObjective": "Sintetizar condições necessárias e suas implicações.",
                                  "commonMistakes": "Subestimar impacto da trivialidade em análises reais."
                                }
                              ],
                              "practicalExample": "Em análise estrutural de uma viga, a matriz de rigidez A (quadrada 2x2) tem autovetor v ≠ 0 representando o modo de flexão fundamental; se v=0, ignora-se o modo trivial, focando em deformações reais.",
                              "finalVerifications": [
                                "Explicar verbalmente por que A deve ser quadrada.",
                                "Mostrar que v=0 satisfaz a equação mas é trivial.",
                                "Identificar condições em uma matriz de exemplo.",
                                "Discutir implicações em um problema de engenharia.",
                                "Reescrever equação como (A - λI)v = 0 com v ≠ 0.",
                                "Normalizar um autovetor simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na justificativa de A quadrada (dimensionalidade).",
                                "Clareza na distinção entre soluções trivial e não-trivial.",
                                "Correta derivação matemática das implicações.",
                                "Relevância de exemplos ao contexto de engenharia civil.",
                                "Completude do resumo das condições essenciais.",
                                "Uso correto de terminologia (autovalor, autovetor)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos de vibração em estruturas dinâmicas.",
                                "Computação: Implementação de QR algorithm para autovalores.",
                                "Matemática: Álgebra linear e determinantes.",
                                "Engenharia Mecânica: Análise de estabilidade de sistemas."
                              ],
                              "realWorldApplication": "Na análise modal de pontes em engenharia civil, condições garantem identificação de frequências naturais via autovalores de matrizes de massa/rigidez, prevendo falhas por ressonância."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.4",
                            "name": "Relacionar com problemas de engenharia civil",
                            "description": "Identificar como a definição é base para análise modal em estruturas civis, onde autovalores representam frequências naturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição matemática de autovalores e autovetores",
                                  "subSteps": [
                                    "Estudar a equação definidora Av = λv, onde A é a matriz de rigidez/massa, v é o autovetor e λ o autovalor.",
                                    "Identificar que autovetores representam modos de deformação e autovalores escalam a magnitude.",
                                    "Resolver um exemplo matricial simples 2x2 para visualizar o conceito.",
                                    "Discutir propriedades: autovalores reais para sistemas simétricos em engenharia.",
                                    "Explorar o significado físico: direção invariante sob transformação linear."
                                  ],
                                  "verification": "Resolver manualmente um sistema 2x2 e confirmar que Av = λv para os autovalores encontrados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Caderno, calculadora, apostila de álgebra linear ou MATLAB para verificação.",
                                  "tips": "Sempre normalize os autovetores para facilitar comparações.",
                                  "learningObjective": "Compreender a equação definidora como base matemática para problemas estruturais.",
                                  "commonMistakes": "Confundir autovalor com frequência diretamente sem considerar unidades ou fatores de escala."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir dinâmica de estruturas civis e vibrações livres",
                                  "subSteps": [
                                    "Explicar equação de movimento: M ü + K u = 0, onde M é massa, K rigidez, u deslocamentos.",
                                    "Assumir solução harmônica u = v sin(ωt), levando à equação generalizada de autovalores.",
                                    "Discutir importância em engenharia civil: edifícios, pontes sob vento ou sismos.",
                                    "Definir frequência natural ω_n = sqrt(λ), onde λ vem de (K - λ M) v = 0.",
                                    "Listar exemplos reais: torres, viadutos."
                                  ],
                                  "verification": "Derivar a equação de autovalores a partir da equação dinâmica e identificar correspondência com Av=λv.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Livro de dinâmica estrutural (ex: Chopra), vídeo tutorial sobre vibrações.",
                                  "tips": "Visualize com animações de modos de vibração para intuitividade.",
                                  "learningObjective": "Conectar equações diferenciais de vibração à forma matricial de autovalores.",
                                  "commonMistakes": "Ignorar a matriz de massa M, assumindo K v = λ v (apenas para sistemas simples)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar análise modal em estruturas civis",
                                  "subSteps": [
                                    "Definir análise modal: decompor resposta em modos naturais (autovetores).",
                                    "Descrever passos: calcular autovalores (frequências), autovetores (formas modais).",
                                    "Aplicar em modelo finito de elementos: discretização leva a matrizes K e M grandes.",
                                    "Interpretar: primeiros modos dominam resposta sísmica.",
                                    "Usar software para eigenvalores em exemplo discreto."
                                  ],
                                  "verification": "Montar matrizes K e M para uma estrutura 2-DOF e extrair modos usando solver.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software ANSYS, MATLAB ou Python (SciPy), modelo simples de viga.",
                                  "tips": "Comece com 1-DOF para validar, depois expanda.",
                                  "learningObjective": "Reconhecer análise modal como aplicação direta da definição de autovalores.",
                                  "commonMistakes": "Confundir forma modal (autovetor) com deslocamentos reais sob carga dinâmica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar autovalores às frequências naturais e validar",
                                  "subSteps": [
                                    "Estabelecer λ = ω², onde ω é frequência natural em rad/s.",
                                    "Converter para Hz: f = ω / (2π), relevante para normas de projeto.",
                                    "Analisar sensibilidade: rigidez alta aumenta λ (frequências altas).",
                                    "Verificar com exemplo: viga cantilever, comparar analítico vs. numérico.",
                                    "Discutir implicações: evitar ressonância com frequências de excitação externas."
                                  ],
                                  "verification": "Calcular frequências para um modelo e comparar com fórmula analítica, erro <5%.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabelas de frequências modais, software de simulação.",
                                  "tips": "Use unidades consistentes (SI) para evitar erros numéricos.",
                                  "learningObjective": "Identificar autovalores como base quantitativa para frequências em análise estrutural.",
                                  "commonMistakes": "Esquecer fator de escala entre λ e f (Hz vs. rad/s)."
                                }
                              ],
                              "practicalExample": "Em uma ponte pênsil como a Golden Gate, a análise modal usa autovalores da matriz [K - ω²M]v=0 para determinar frequências naturais (ex: 0.1 Hz para modo torsional), prevendo flutter aerodinâmico e guiando reforços.",
                              "finalVerifications": [
                                "Explicar verbalmente como Av=λv surge na equação de vibração livre.",
                                "Calcular autovalores para um sistema 2-DOF e interpretar como frequências.",
                                "Identificar o papel das formas modais em resposta sísmica.",
                                "Comparar frequências numéricas com analíticas para uma viga.",
                                "Discutir risco de ressonância em um edifício real.",
                                "Resolver equação generalizada (K - λM)v=0 manualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da relação λ = ω² (100% correta).",
                                "Correta interpretação física de autovetores como modos de deformação.",
                                "Uso adequado de software para eigenanálise com resultados validados.",
                                "Identificação de pelo menos 3 aplicações em engenharia civil.",
                                "Ausência de erros unitários ou de escala em cálculos.",
                                "Capacidade de relacionar a definição matemática a problemas reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e equações diferenciais.",
                                "Física: Dinâmica de vibrações e mecânica dos sólidos.",
                                "Computação: Métodos numéricos e elementos finitos (Python/MATLAB).",
                                "Engenharia Mecânica: Análise de máquinas rotativas.",
                                "Gestão de Projetos: Normas sísmicas (ex: NBR 15421)."
                              ],
                              "realWorldApplication": "Na análise sísmica de edifícios altos, autovalores determinam frequências naturais para espectros de resposta, permitindo dimensionar amortecedores e evitar colapsos como no terremoto de Lisboa (1755), otimizando projetos sustentáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Polinômio Característico",
                    "description": "Equação det(A - λI) = 0 para determinação dos autovalores de uma matriz.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Construção da Matriz A - λI",
                        "description": "Conceito fundamental para formar a matriz característica, subtraindo λ vezes a matriz identidade da matriz A.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Identificar a matriz identidade I",
                            "description": "Reconhecer e construir a matriz identidade I de ordem n, onde os elementos da diagonal principal são 1 e os demais são 0, essencial para a multiplicação por escalar λ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição da Matriz Identidade",
                                  "subSteps": [
                                    "Leia a definição: A matriz identidade I_n é uma matriz quadrada n x n com 1s na diagonal principal e 0s em todos os outros elementos.",
                                    "Estude a notação I_n e sua representação simbólica.",
                                    "Visualize exemplos para n=1 (escalar 1) e n=2 ([[1,0],[0,1]]).",
                                    "Memorize a propriedade fundamental: I_n * A = A * I_n = A para qualquer matriz A compatível.",
                                    "Anote as características únicas da diagonal principal."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição e propriedades para um par ou tutor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a um livro de álgebra linear ou site como Khan Academy"
                                  ],
                                  "tips": "Use diagramas para visualizar a diagonal principal destacada em negrito.",
                                  "learningObjective": "Definir precisamente a matriz identidade e suas propriedades multiplicativas básicas.",
                                  "commonMistakes": [
                                    "Confundir com matriz zero",
                                    "Colocar 1s fora da diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Matrizes Identidade para Ordens Pequenas",
                                  "subSteps": [
                                    "Construa I_2 manualmente: posicione 1s nas posições (1,1) e (2,2), 0s no resto.",
                                    "Construa I_3: 1s em (1,1), (2,2), (3,3); 0s em off-diagonal.",
                                    "Verifique simetria e quadratura da matriz.",
                                    "Repita para I_4, garantindo padrão consistente.",
                                    "Escreva as matrizes em formato de grade para clareza."
                                  ],
                                  "verification": "Mostre as matrizes construídas e confirme que multiplicam um vetor unitário por si mesmo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha quadriculada",
                                    "Calculadora ou software como MATLAB/Octave para verificação opcional"
                                  ],
                                  "tips": "Sempre comece preenchendo a diagonal principal primeiro, depois zeros.",
                                  "learningObjective": "Construir corretamente I_n para n=2,3,4 manualmente.",
                                  "commonMistakes": [
                                    "Erros de indexação, como colocar 1 em (1,2)",
                                    "Matriz não quadrada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Generalizar a Construção para Ordem n Arbitrária",
                                  "subSteps": [
                                    "Desenvolva uma regra geral: I_n[i,j] = 1 se i==j, senão 0.",
                                    "Escreva pseudocódigo para gerar I_n em loop: para i=1 a n, para j=1 a n, se i=j então 1 else 0.",
                                    "Aplique para n=5 sem desenhar a matriz completa, descrevendo posições.",
                                    "Discuta representação em software: np.eye(n) no NumPy.",
                                    "Teste compreensão construindo I_n para n=1 e n=6 verbalmente."
                                  ],
                                  "verification": "Gere I_5 e verifique multiplicação por vetor [1,0,0,0,0]^T resulta no mesmo vetor.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Python com NumPy instalado (opcional)"
                                  ],
                                  "tips": "Pense em termos de delta de Kronecker: δ_ij.",
                                  "learningObjective": "Generalizar a construção de I_n para qualquer n usando regras indexadas.",
                                  "commonMistakes": [
                                    "Ignorar que n deve ser inteiro positivo",
                                    "Confundir com matriz diagonal genérica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Contexto de Autovalores: Construir A - λI",
                                  "subSteps": [
                                    "Dado A (ex: 2x2) e λ, subtraia λI de A: cada diagonal de I multiplicada por λ e subtraída.",
                                    "Exemplo: Para A=[[2,1],[1,2]], λ=1, compute A - I = [[1,1],[1,1]].",
                                    "Verifique dimensionalidade: A e I devem ter mesma ordem.",
                                    "Repita para matriz 3x3 simples.",
                                    "Explique por que I é essencial aqui: neutraliza diagonal para polinômio característico."
                                  ],
                                  "verification": "Compute det(A - λI) para exemplo dado e confirme estrutura.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz de exemplo impressa",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "λI é diagonal com λs; subtração só afeta diagonal de A.",
                                  "learningObjective": "Usar I na construção de A - λI para análise de autovalores.",
                                  "commonMistakes": [
                                    "Subtrair λ de off-diagonal",
                                    "Usar ordem errada para I"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise estrutural de vigas (Engenharia Civil), para encontrar modos de vibração via autovalores, compute A - λI onde A é matriz de rigidez. Para n=3 (3 graus de liberdade), I_3 = [[1,0,0],[0,1,0],[0,0,1]]; subtraia λI da diagonal de A para resolver det(A - λI)=0.",
                              "finalVerifications": [
                                "Construa corretamente I_4 sem erros.",
                                "Explique regra geral para I_n[i,j].",
                                "Compute A - 2I para matriz 2x2 dada.",
                                "Verifique I_3 * [1,2,3]^T = [1,2,3]^T.",
                                "Descreva papel de I em autovalores.",
                                "Gere pseudocódigo para I_n."
                              ],
                              "assessmentCriteria": [
                                "Precisão na colocação de 1s e 0s (100% correto).",
                                "Compreensão demonstrada na generalização para n arbitrário.",
                                "Aplicação correta em A - λI sem erros dimensionais.",
                                "Explicações claras e concisas das propriedades.",
                                "Identificação e correção de erros comuns.",
                                "Uso eficiente de tempo nos passos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Função identity() em NumPy ou MATLAB para simulações numéricas.",
                                "Física: Matriz identidade em transformações lineares de coordenadas em mecânica.",
                                "Computação: Base para algoritmos de autovalores em análise finita de elementos.",
                                "Estatística: Em covariância, I representa variância unitária."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, matrizes identidade são usadas em solvers de elementos finitos para equações modais (vibrações de pontes), onde A - λI=0 determina frequências naturais, essencial para projeto sísmico seguro."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Multiplicar λ pela matriz identidade",
                            "description": "Realizar a multiplicação escalar λI, resultando em uma matriz diagonal com λ em todos os elementos da diagonal principal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura da Matriz Identidade",
                                  "subSteps": [
                                    "Defina a matriz identidade I_n como uma matriz quadrada n x n com 1s na diagonal principal e 0s em todas as outras posições.",
                                    "Escreva a matriz identidade para n=2: [[1, 0], [0, 1]] e para n=3: [[1, 0, 0], [0, 1, 0], [0, 0, 1]].",
                                    "Identifique as propriedades chave: I * A = A * I = A para qualquer matriz A compatível.",
                                    "Anote a notação padrão I para representar a identidade do tamanho apropriado ao contexto.",
                                    "Visualize graficamente como a identidade 'não altera' vetores no espaço."
                                  ],
                                  "verification": "Escreva corretamente I_3 e explique sua propriedade multiplicativa em uma frase.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Lembre-se: diagonal principal é da posição (1,1) até (n,n); todos os off-diagonal são zero.",
                                  "learningObjective": "Entender a definição e propriedades fundamentais da matriz identidade.",
                                  "commonMistakes": [
                                    "Confundir com matriz zero",
                                    "Colocar 1s fora da diagonal",
                                    "Esquecer o tamanho n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Regras de Multiplicação Escalar por Matriz",
                                  "subSteps": [
                                    "Lembre a regra: para escalar λ e matriz A = [a_ij], λA = [λ * a_ij] para cada elemento.",
                                    "Aplique a propriedade comutativa: λA = Aλ.",
                                    "Discuta que multiplicação escalar preserva estrutura (ex: diagonal permanece diagonal).",
                                    "Pratique com exemplo simples: λ=2, A=[[1,0],[0,1]] resulta em [[2,0],[0,2]].",
                                    "Note que zeros permanecem zeros, escalando apenas os não-zeros."
                                  ],
                                  "verification": "Multiplique manualmente λ=4 por I_2 e confirme o resultado.",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Papel e lápis"
                                  ],
                                  "tips": "Pense elemento por elemento: multiplique λ por cada entrada da matriz.",
                                  "learningObjective": "Dominar a operação de multiplicação escalar em matrizes.",
                                  "commonMistakes": [
                                    "Usar regra de multiplicação matricial em vez de escalar",
                                    "Alterar posições de elementos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a Multiplicação λ pela Matriz Identidade",
                                  "subSteps": [
                                    "Escreva I_n explicitamente para o tamanho dado (ex: n=3).",
                                    "Multiplique λ por cada elemento da diagonal principal: cada 1 vira λ.",
                                    "Confirme que todos os elementos off-diagonal (0s) permanecem 0 após λ*0=0.",
                                    "Construa a matriz resultante: diagonal com λs, zeros fora.",
                                    "Rotule como λI explicitamente."
                                  ],
                                  "verification": "Compute λI para λ=5 e n=3, escrevendo a matriz completa.",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis"
                                  ],
                                  "tips": "Use notação λI diretamente após construção para brevidade.",
                                  "learningObjective": "Realizar com precisão a operação λ * I.",
                                  "commonMistakes": [
                                    "Colocar λ fora da diagonal",
                                    "Multiplicar errado os zeros",
                                    "Confundir ordem de multiplicação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Interpretar o Resultado",
                                  "subSteps": [
                                    "Confirme que λI é uma matriz diagonal com λ repetido n vezes na diagonal.",
                                    "Verifique propriedades: (λI) * v = λv para autovetor v.",
                                    "Compare com definição de matriz diagonal: não-zeros só na diagonal.",
                                    "Discuta contexto: λI surge em A - λI para autovalores.",
                                    "Teste com multiplicação por vetor unitário para validar."
                                  ],
                                  "verification": "Mostre que λI_2 * [1,0]^T = [λ, 0]^T.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel",
                                    "Calculadora para vetores opcionais"
                                  ],
                                  "tips": "Sempre verifique pelo menos um produto matricial-vetor para confirmação.",
                                  "learningObjective": "Reconhecer e validar λI como matriz diagonal escalar.",
                                  "commonMistakes": [
                                    "Achar que é identidade escalada incorretamente",
                                    "Ignorar off-diagonais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma matriz 3x3 identidade I_3 = [[1,0,0],[0,1,0],[0,0,1]] e λ=2 (autovalor de rigidez em estrutura), compute 2I_3 = [[2,0,0],[0,2,0],[0,0,2]]. Isso representa escalonamento uniforme nos modos de vibração.",
                              "finalVerifications": [
                                "Defina corretamente I_n e compute λI_n para n=2 e n=3.",
                                "Explique por que λI é diagonal com λ na diagonal principal.",
                                "Verifique λI * e_1 = λ e_1, onde e_1 é vetor unitário base.",
                                "Identifique λI no contexto de A - λI = 0 para autovalores.",
                                "Resolva um exemplo numérico completo sem erros aritméticos.",
                                "Diferencie multiplicação escalar de matricial."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos cálculos de elementos da matriz.",
                                "Explicação clara da estrutura diagonal resultante.",
                                "Correta identificação de propriedades preservadas (diagonal, zeros off-diagonal).",
                                "Integração contextual com autovalores/autofunções.",
                                "Eficiência no tempo de execução (dentro de 40 minutos total).",
                                "Ausência de erros comuns como confusão escalar-matricial."
                              ],
                              "crossCurricularConnections": [
                                "Física: Autovalores em equações diferenciais para vibrações estruturais.",
                                "Programação: Implementar em Python com NumPy (np.eye(n)*lambda_).",
                                "Estatística: Matrizes de covariância escalares em modelos multivariados.",
                                "Engenharia Mecânica: Análise modal de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao resolver problemas de estabilidade estrutural via método dos elementos finitos, λI é subtraída da matriz de rigidez A para encontrar autovalores λ, determinando frequências naturais de vibração e evitando ressonância em pontes ou edifícios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Subtrair λI da matriz A",
                            "description": "Executar a subtração elemento a elemento entre a matriz A e λI para obter a matriz A - λI, base para o cálculo do determinante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a matriz A e construir a matriz identidade I",
                                  "subSteps": [
                                    "Determinar a ordem n da matriz A (número de linhas e colunas).",
                                    "Criar a matriz identidade I de ordem n, com 1s na diagonal principal (posições (1,1), (2,2), ..., (n,n)) e 0s em todas as outras posições.",
                                    "Verificar visualmente que I tem dimensões n x n e estrutura correta.",
                                    "Confirmar que A e I têm as mesmas dimensões.",
                                    "Anotar o valor escalar λ fornecido."
                                  ],
                                  "verification": "A matriz I possui exatamente 1s apenas na diagonal principal e 0s fora dela, com dimensões idênticas à de A.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Matriz A exemplo"
                                  ],
                                  "tips": "Sempre comece confirmando as dimensões para evitar erros de incompatibilidade.",
                                  "learningObjective": "Compreender a estrutura da matriz identidade e sua relação com a matriz A no contexto de autovalores.",
                                  "commonMistakes": [
                                    "Confundir ordem de A",
                                    "Colocar valores incorretos na diagonal de I (ex: usar elementos de A)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a matriz λI",
                                  "subSteps": [
                                    "Multiplicar cada elemento da diagonal principal de I por λ (resulta em λ nas posições (i,i)).",
                                    "Manter os elementos fora da diagonal como 0 (pois 0 * λ = 0).",
                                    "Escrever explicitamente a matriz λI linha por linha.",
                                    "Verificar que apenas a diagonal contém λ e o resto é zero.",
                                    "Comparar dimensões com A para confirmar compatibilidade."
                                  ],
                                  "verification": "A matriz λI tem λ em todas as posições da diagonal principal e 0s em todas as outras posições.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para multiplicações simples"
                                  ],
                                  "tips": "Lembre-se: λI é uma matriz diagonal com λ repetido n vezes na diagonal.",
                                  "learningObjective": "Dominar a multiplicação escalar por matriz identidade, essencial para operações lineares.",
                                  "commonMistakes": [
                                    "Multiplicar elementos off-diagonal por λ incorretamente",
                                    "Esquecer de multiplicar a diagonal por λ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a subtração elemento a elemento: A - λI",
                                  "subSteps": [
                                    "Para cada posição (i,j): calcular elemento resultante como A_{i,j} - (λI)_{i,j}.",
                                    "Na diagonal (i=j): subtrair λ de A_{i,i}.",
                                    "Fora da diagonal (i≠j): subtrair 0 de A_{i,j}, mantendo o valor original de A.",
                                    "Escrever a matriz resultante completa, linha por linha.",
                                    "Dobrar-checar todos os cálculos aritméticos."
                                  ],
                                  "verification": "Todos os elementos da diagonal da matriz resultante são A_{i,i} - λ, e elementos off-diagonal são idênticos aos de A.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado para alinhamento",
                                    "Calculadora"
                                  ],
                                  "tips": "Alinhe as matrizes verticalmente para subtrair coluna por coluna e evitar confusões.",
                                  "learningObjective": "Executar subtração de matrizes de forma precisa, focando em operações elemento a elemento.",
                                  "commonMistakes": [
                                    "Subtrair λ de elementos off-diagonal",
                                    "Erros de sinal na subtração (ex: somar em vez de subtrair)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar a matriz A - λI",
                                  "subSteps": [
                                    "Comparar a matriz resultante com A original: diagonal alterada, off-diagonal inalterada.",
                                    "Calcular o traço ou um elemento específico para validação cruzada.",
                                    "Discutir o papel de A - λI no polinômio característico (det(A - λI) = 0).",
                                    "Salvar ou registrar a matriz para próximos passos (ex: cálculo de determinante).",
                                    "Identificar se λ é um autovalor candidato testando det(A - λI) = 0 (opcional)."
                                  ],
                                  "verification": "A matriz A - λI está correta e pronta para uso no cálculo do determinante ou polinômio característico.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Software para verificação (ex: Python NumPy)",
                                    "Exemplo numérico"
                                  ],
                                  "tips": "Use um exemplo pequeno (2x2) primeiro para praticar antes de matrizes maiores.",
                                  "learningObjective": "Interpretar o resultado no contexto de autovalores e validar operações matriciais.",
                                  "commonMistakes": [
                                    "Ignorar verificação de dimensões ou sinais",
                                    "Confundir A - λI com λI - A"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada A = [[2, 1], [1, 2]] e λ = 3, primeiro I = [[1, 0], [0, 1]], então λI = [[3, 0], [0, 3]]. Subtraindo: A - λI = [[2-3, 1-0], [1-0, 2-3]] = [[-1, 1], [1, -1]]. Agora, det(A - λI) = (-1)(-1) - (1)(1) = 1 - 1 = 0, confirmando λ=3 como autovalor aproximado.",
                              "finalVerifications": [
                                "Dimensões da matriz resultante são n x n, iguais a A.",
                                "Elementos da diagonal principal são exatamente A_{i,i} - λ.",
                                "Elementos off-diagonal são idênticos aos de A.",
                                "Não há erros aritméticos em nenhuma subtração.",
                                "A matriz está corretamente formatada (linhas e colunas alinhadas).",
                                "Traço da matriz resultante é traço(A) - nλ."
                              ],
                              "assessmentCriteria": [
                                "Precisão em todos os cálculos elemento a elemento (100% correto).",
                                "Correta construção de λI (diagonal λ, off-diagonal 0).",
                                "Eficiência na execução (tempo dentro do estimado).",
                                "Verificação adequada de resultados.",
                                "Interpretação contextual correta para autovalores.",
                                "Ausência de erros comuns como inversão de sinal."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Base para diagonalização e decomposições espectrais.",
                                "Programação Computacional: Implementação em NumPy/Python ou MATLAB para matrizes grandes.",
                                "Engenharia Estrutural: Análise de vibrações em vigas/pontes via autovalores.",
                                "Física: Modos normais de oscilação em sistemas mecânicos."
                              ],
                              "realWorldApplication": "Em engenharia civil, a matriz A - λI é fundamental para calcular autovalores em análises modais de estruturas (ex: frequências naturais de vibração de pontes ou edifícios), permitindo prever estabilidade e evitar ressonâncias destrutivas em projetos computacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Cálculo do Determinante",
                        "description": "Determinação do determinante da matriz A - λI, que gera o polinômio em λ de grau igual à ordem da matriz.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Calcular determinante de matriz 2x2",
                            "description": "Aplicar a fórmula det(A - λI) = (a11 - λ)(a22 - λ) - a12 a21 para matrizes 2x2, expandindo em termos de λ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir a matriz A - λI",
                                  "subSteps": [
                                    "Identifique a matriz A 2x2: A = [[a11, a12], [a21, a22]]",
                                    "Construa a matriz identidade 2x2: I = [[1, 0], [0, 1]]",
                                    "Multiplique I por λ: λI = [[λ, 0], [0, λ]]",
                                    "Subtraia elemento a elemento: A - λI = [[a11 - λ, a12], [a21, a22 - λ]]",
                                    "Anote a matriz resultante claramente para evitar confusões"
                                  ],
                                  "verification": "Verifique se os elementos da diagonal principal são (a11 - λ) e (a22 - λ), e os off-diagonais permanecem inalterados",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de matriz A"
                                  ],
                                  "tips": "Use parênteses nos termos com λ para clareza visual",
                                  "learningObjective": "Compreender a formação da matriz característica A - λI para matrizes 2x2",
                                  "commonMistakes": [
                                    "Subtrair λ dos elementos off-diagonal",
                                    "Esquecer o sinal negativo na subtração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recordar e escrever a fórmula do determinante para matriz 2x2",
                                  "subSteps": [
                                    "Lembre-se da fórmula geral: det([[p, q], [r, s]]) = p*s - q*r",
                                    "Aplique à matriz A - λI: det(A - λI) = (a11 - λ)(a22 - λ) - a12*a21",
                                    "Escreva a expressão simbólica sem expandir ainda",
                                    "Confirme a fórmula com um exemplo numérico simples (λ=0)",
                                    "Identifique os termos que envolvem λ"
                                  ],
                                  "verification": "A fórmula escrita corresponde exatamente a (a11 - λ)(a22 - λ) - a12 a21",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de fórmulas de determinantes"
                                  ],
                                  "tips": "Memorize 'principal menos produto dos off-diagonais'",
                                  "learningObjective": "Dominar a aplicação direta da fórmula de determinante para 2x2 no contexto característico",
                                  "commonMistakes": [
                                    "Inverter a ordem do produto cruzado (a12 a21 em vez de a21 a12)",
                                    "Esquecer o sinal de subtração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a fórmula e expandir a expressão",
                                  "subSteps": [
                                    "Expanda o produto (a11 - λ)(a22 - λ) = a11 a22 - a11 λ - a22 λ + λ²",
                                    "Subtraia o termo a12 a21: λ² - (a11 + a22) λ + (a11 a22 - a12 a21)",
                                    "Identifique os coeficientes: λ² - traço(A) λ + det(A)",
                                    "Substitua valores simbólicos por numéricos em um exemplo para validar",
                                    "Escreva o polinômio característico final: det(A - λI) = 0"
                                  ],
                                  "verification": "A expansão resulta em um polinômio quadrático em λ com coeficiente líder +1",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para verificação numérica"
                                  ],
                                  "tips": "Distribua os termos sistematicamente: primeiro produto, depois somas e λ²",
                                  "learningObjective": "Executar a expansão algébrica correta para obter o polinômio em termos de λ",
                                  "commonMistakes": [
                                    "Erro no sinal do termo linear: deve ser - (a11 + a22) λ",
                                    "Confundir det(A) com traço(A)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar o resultado",
                                  "subSteps": [
                                    "Calcule traço(A) = a11 + a22 e det(A) = a11 a22 - a12 a21 separadamente",
                                    "Compare com a expansão: coef. de λ é -traço(A), constante é det(A)",
                                    "Teste com λ = 0: deve dar det(A)",
                                    "Resolva as raízes para autovalores em um exemplo simples",
                                    "Discuta o significado no contexto de autovalores"
                                  ],
                                  "verification": "Os autovalores encontrados satisfazem a equação característica",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software como MATLAB ou Python para validação opcional"
                                  ],
                                  "tips": "Sempre verifique com valores conhecidos, como matriz identidade",
                                  "learningObjective": "Validar o cálculo e conectar ao polinômio característico",
                                  "commonMistakes": [
                                    "Ignorar o sinal no polinômio (det(A - λI) vs det(λI - A))",
                                    "Não testar com λ=0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3, 1], [1, 2]]: A - λI = [[3-λ, 1], [1, 2-λ]]. det = (3-λ)(2-λ) - 1*1 = 6 -3λ -2λ + λ² -1 = λ² -5λ +5. Polinômio característico: λ² -5λ +5 =0, autovalores ≈ 4.79 e 0.21.",
                              "finalVerifications": [
                                "Matriz A - λI formada corretamente com λ apenas na diagonal",
                                "Fórmula de det aplicada sem inversão de termos",
                                "Expansão algébrica resulta em λ² - (tr(A))λ + det(A)",
                                "Verificação com λ=0 retorna det(A)",
                                "Coeficientes coincidem com traço e determinante de A",
                                "Raízes do polinômio são autovalores válidos"
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de A - λI (100% elementos corretos)",
                                "Correta aplicação e expansão da fórmula (sem erros algébricos)",
                                "Identificação exata dos coeficientes em termos de traço e det",
                                "Validação numérica coerente com o resultado simbólico",
                                "Interpretação contextual no polinômio característico",
                                "Clareza na apresentação do polinômio final"
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de vibrações e modos normais em estruturas",
                                "Informática: Implementação em algoritmos de autovalores (ex: NumPy)",
                                "Matemática Geral: Polinômios e equações quadráticas",
                                "Engenharia Mecânica: Estabilidade de sistemas dinâmicos"
                              ],
                              "realWorldApplication": "Na Engenharia Civil, calcula autovalores para análise de estabilidade de vigas e estruturas, identificando frequências de vibração críticas e modos de falha em projetos de pontes e edifícios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Calcular determinante de matriz 3x3",
                            "description": "Utilizar expansão por cofatores ou regra de Sarrus para det(A - λI) em matrizes 3x3, obtendo um polinômio cúbico em λ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir a matriz característica A - λI",
                                  "subSteps": [
                                    "Identifique a matriz A de ordem 3x3 fornecida no problema.",
                                    "Subtraia λ da diagonal principal: a11 - λ, a22 - λ, a33 - λ.",
                                    "Mantenha os elementos fora da diagonal inalterados.",
                                    "Escreva a matriz resultante explicitamente.",
                                    "Verifique se todos os elementos estão corretos comparando com A original."
                                  ],
                                  "verification": "A matriz A - λI está corretamente formada sem erros aritméticos na diagonal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A exemplo",
                                    "Papel e lápis",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Sempre rotule λ claramente para evitar confusão com constantes.",
                                  "learningObjective": "Compreender como formar a matriz característica para o polinômio característico.",
                                  "commonMistakes": [
                                    "Esquecer de subtrair λ apenas da diagonal",
                                    "Alterar elementos fora da diagonal",
                                    "Erros de sinal em -λ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o determinante usando a Regra de Sarrus",
                                  "subSteps": [
                                    "Repita a terceira coluna da matriz A - λI ao lado direito para formar as diagonais auxiliares.",
                                    "Some os produtos das diagonais principais (da esquerda para direita, descendentes).",
                                    "Subtraia os produtos das diagonais secundárias (da direita para esquerda, ascendentes).",
                                    "Expanda os produtos considerando os termos com λ.",
                                    "Simplifique a expressão algébrica resultante."
                                  ],
                                  "verification": "O determinante calculado coincide com o esperado para uma matriz numérica de teste (ex: λ=0).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz A - λI",
                                    "Papel quadriculado",
                                    "Lápis e borracha"
                                  ],
                                  "tips": "Visualize as diagonais como 'setas' para não perder termos.",
                                  "learningObjective": "Dominar a Regra de Sarrus para determinantes 3x3 eficientemente.",
                                  "commonMistakes": [
                                    "Não repetir corretamente a terceira coluna",
                                    "Erros nos sinais de subtração",
                                    "Confundir diagonais principais e secundárias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o determinante usando expansão por cofatores",
                                  "subSteps": [
                                    "Escolha uma linha ou coluna com mais zeros (preferencialmente a primeira linha).",
                                    "Calcule os cofatores Cij = (-1)^{i+j} * det(minor Mij) para cada elemento.",
                                    "Para minors 2x2, use a fórmula ad - bc.",
                                    "Multiplique cada cofator pelo elemento correspondente e some.",
                                    "Compare o resultado com o da Regra de Sarrus para validação."
                                  ],
                                  "verification": "Os dois métodos (Sarrus e cofatores) produzem a mesma expressão polinomial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz A - λI",
                                    "Tabela para cofatores",
                                    "Calculadora para minors"
                                  ],
                                  "tips": "Expanda pela linha com o maior número de zeros para simplificar.",
                                  "learningObjective": "Aplicar expansão por cofatores como método alternativo e verificador.",
                                  "commonMistakes": [
                                    "Sinal errado no (-1)^{i+j}",
                                    "Erro no cálculo de minors 2x2",
                                    "Soma incorreta dos termos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar e simplificar o polinômio característico",
                                  "subSteps": [
                                    "Colete todos os termos com λ^3, λ^2, λ e constante do determinante.",
                                    "Escreva na forma padrão: -λ^3 + aλ^2 + bλ + c = 0 (ou similar).",
                                    "Fatore se possível ou identifique coeficientes.",
                                    "Verifique o grau (deve ser 3) e o sinal líder (-1 para det(A-λI)).",
                                    "Teste com λ=0 para confirmar det(A)."
                                  ],
                                  "verification": "O polinômio é cúbico, monico (coef. λ^3 = -1 após normalização), e det(λ=0) = det(A).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Expressão do det",
                                    "Papel para expansão algébrica"
                                  ],
                                  "tips": "Use distribuição binomial para expandir produtos com λ.",
                                  "learningObjective": "Obter o polinômio característico pronto para encontrar autovalores.",
                                  "commonMistakes": [
                                    "Erros na coleta de termos semelhantes",
                                    "Sinal incorreto no polinômio",
                                    "Grau errado"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[2, 1, 0], [1, 3, 1], [0, 1, 2]], A - λI = [[2-λ, 1, 0], [1, 3-λ, 1], [0, 1, 2-λ]].\nUsando Sarrus: det = (2-λ)[(3-λ)(2-λ) - 1] -1[(1)(2-λ) - 0] +0 = -λ^3 + 7λ^2 - 12λ + 2.\nVerificação por cofatores na 1ª linha dá o mesmo.",
                              "finalVerifications": [
                                "Calculou corretamente det(A - λI) para pelo menos duas matrizes 3x3 diferentes.",
                                "Os dois métodos (Sarrus e cofatores) coincidem em resultados.",
                                "Identificou o polinômio cúbico com coeficientes corretos.",
                                "Verificou com λ=0 retornando det(A).",
                                "Explicou passos sem hesitação.",
                                "Aplicou a uma matriz do contexto de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão aritmética e algébrica nos cálculos (90% correto).",
                                "Escolha adequada de método baseado em simplicidade.",
                                "Expansão completa e simplificação do polinômio.",
                                "Validação cruzada entre métodos.",
                                "Clareza na apresentação dos passos.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Base para autovalores em sistemas lineares.",
                                "Programação: Implementar det() em Python/MATLAB para matrizes maiores.",
                                "Física: Modos de vibração em estruturas (equações diferenciais).",
                                "Engenharia Computacional: Pré-processamento para solvers numéricos.",
                                "Estatística: Análise de componentes principais (PCA)."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, o polinômio característico de matrizes de rigidez é usado para analisar modos de vibração e estabilidade de pontes e edifícios, prevendo frequências naturais para evitar ressonância em terremotos ou ventos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Propriedades do determinante para polinômios",
                            "description": "Aplicar propriedades como multilineariedade e alternância para simplificar o cálculo de det(A - λI) em casos gerais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar propriedades fundamentais do determinante: multilineariedade e alternância",
                                  "subSteps": [
                                    "Defina multilineariedade: o determinante é linear em cada linha/coluna quando as outras são fixas.",
                                    "Explique alternância: det muda de sinal ao trocar duas linhas/colunas.",
                                    "Estude exemplos básicos com matrizes constantes para ilustrar ambas propriedades.",
                                    "Discuta como essas propriedades se estendem a entradas lineares em λ.",
                                    "Pratique com det de matrizes 2x2 simples."
                                  ],
                                  "verification": "Resolva 3 exemplos manuais e confirme que multilineariedade e alternância produzem resultados consistentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, lápis, calculadora básica, notas de aula sobre determinantes.",
                                  "tips": "Visualize o determinante como volume de paralelepípedo para intuitivamente entender linearidade.",
                                  "learningObjective": "Compreender as propriedades multilineares e alternância do determinante como base para simplificações.",
                                  "commonMistakes": "Confundir multilineariedade com aditividade total; lembrar que é por linha individual."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar multilineariedade ao cálculo de det(A - λI)",
                                  "subSteps": [
                                    "Expanda A - λI linha por linha, expressando cada linha como combinação linear de vetores constantes e λ.",
                                    "Use multilineariedade para fatorar det(A - λI) = det(A) - λ * (soma de termos) + λ² * ...",
                                    "Para matrizes 2x2, compute explicitamente det(A - λI) e identifique coeficientes.",
                                    "Generalize para n x n, notando que resulta em polinômio de grau n em λ.",
                                    "Verifique com expansão cofatora simples em um caso 2x2."
                                  ],
                                  "verification": "Derive o polinômio característico para uma matriz 2x2 usando apenas multilineariedade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora gráfica ou software como MATLAB/Octave para verificação numérica.",
                                  "tips": "Trate λI como escalar múltiplo da identidade e distribua linha por linha.",
                                  "learningObjective": "Aplicar multilineariedade para expressar det(A - λI) como polinômio em λ.",
                                  "commonMistakes": "Esquecer o sinal alternado nos termos de λ^k; sempre rastreie o grau."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar alternância para simplificações em casos com dependências lineares",
                                  "subSteps": [
                                    "Identifique cenários onde linhas de A - λI se tornam linearmente dependentes (ex: autovalor λ).",
                                    "Use alternância para trocar linhas e introduzir fatores (λ - autovalor).",
                                    "Combine com multilineariedade para fatorar (λ - λ_i) do polinômio.",
                                    "Aplique em matriz 3x3 diagonalizável, simplificando det.",
                                    "Teste alternância trocando linhas propositalmente e ajustando sinal."
                                  ],
                                  "verification": "Simplifique det(A - λI) para matriz 3x3 onde uma linha é múltiplo de outra em λ específico.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Folha de exercícios com matrizes exemplo, Python/MATLAB para plotar polinômio.",
                                  "tips": "Alternância ajuda a revelar raízes; troque linhas para isolar fatores lineares.",
                                  "learningObjective": "Usar alternância combinada com multilineariedade para fatorar o polinômio característico.",
                                  "commonMistakes": "Perder o sinal (-1) ao trocar linhas pares/ímpares; conte trocas cuidadosamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar simplificação geral de det(A - λI) em casos de engenharia",
                                  "subSteps": [
                                    "Selecione matriz A de contexto estrutural (ex: rigidez de viga).",
                                    "Aplique propriedades para derivar polinômio sem expansão total.",
                                    "Compare resultado com computação direta (software).",
                                    "Analise coeficientes: traço como -coef de λ^{n-1}, det(A) como constante.",
                                    "Resolva para autovalores aproximados."
                                  ],
                                  "verification": "Obtenha polinômio correto para matriz 3x3 não-diagonal e encontre raízes principais.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software computacional (MATLAB, Python com NumPy), matrizes de exemplo em engenharia civil.",
                                  "tips": "Para matrizes esparsas (comuns em FE), propriedades aceleram sem computação full.",
                                  "learningObjective": "Simplificar det(A - λI) eficientemente em aplicações reais usando propriedades.",
                                  "commonMistakes": "Ignorar simetria de A em problemas estruturais; explore para mais simplificações."
                                }
                              ],
                              "practicalExample": "Para A = [[2,1],[1,2]], det(A - λI) = det([[2-λ,1],[1,2-λ]]). Pela multilineariedade na primeira linha: (2-λ)*det([[1],[2-λ]]) - 1*det([[1],[1]]). Expandindo totalmente: λ² - 4λ + 3 = (λ-1)(λ-3), revelando autovalores sem expansão bruta.",
                              "finalVerifications": [
                                "Derivação manual de det(A - λI) coincide com software para 2-3 matrizes teste.",
                                "Coeficientes do polinômio batem: grau n, coef λ^{n-1} = -tr(A), constante = det(A).",
                                "Fatoração inclui autovalores conhecidos corretamente.",
                                "Simplificação reduz passos computacionais em >50% vs expansão direta.",
                                "Aplicação em matriz assimétrica de engenharia produz polinômio coerente.",
                                "Verificação numérica: autovalores resolvem equação corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de multilineariedade (100% dos termos corretos).",
                                "Uso correto de alternância com sinais apropriados (sem erros de sinal).",
                                "Eficiência: simplificação evita expansão total desnecessária.",
                                "Generalização para n x n demonstrada logicamente.",
                                "Integração com contexto computacional (ex: código para verificação).",
                                "Análise de erros comuns evitados na derivação."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Extensão a decomposição espectral.",
                                "Programação Computacional: Implementação em NumPy/SciPy para autovalores.",
                                "Engenharia Estrutural: Análise de vibrações/modais em vigas.",
                                "Física: Osciladores acoplados e frequências naturais.",
                                "Estatística: Análise de componentes principais (PCA)."
                              ],
                              "realWorldApplication": "Em engenharia civil, simplificar det(K - ω²M) usando essas propriedades acelera análise modal de estruturas (ex: pontes, edifícios), reduzindo tempo computacional em simulações FEM para prever modos de vibração e estabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Equação Característica e Autovalores",
                        "description": "Estabelecimento da equação det(A - λI) = 0 e resolução para encontrar os autovalores λ.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Formar o polinômio característico p(λ)",
                            "description": "Escrever explicitamente p(λ) = det(A - λI) como um polinômio de grau n, com coeficientes dependentes dos elementos de A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito e Construir a Matriz A - λI",
                                  "subSteps": [
                                    "Defina o polinômio característico como p(λ) = det(A - λI), onde A é uma matriz n x n.",
                                    "Identifique a ordem n da matriz A e forme a matriz identidade I de mesmo tamanho.",
                                    "Subtraia λI de A: na diagonal principal, substitua a_{ii} por a_{ii} - λ; fora da diagonal, mantenha os elementos de A.",
                                    "Verifique visualmente se apenas a diagonal foi alterada com o termo -λ.",
                                    "Anote a matriz A - λI explicitamente."
                                  ],
                                  "verification": "Conferir se a matriz A - λI tem -λ na diagonal principal e elementos originais de A em todas as outras posições.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A de exemplo (papel ou software como MATLAB/Octave)",
                                    "Folha de papel ou editor de texto"
                                  ],
                                  "tips": "Sempre escreva λI separadamente para evitar confusão: λI tem λ na diagonal e zero fora.",
                                  "learningObjective": "Construir corretamente a matriz A - λI a partir de uma matriz quadrada A.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo em -λI",
                                    "Alterar elementos fora da diagonal",
                                    "Confundir com A + λI"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Determinante para Matrizes 2x2",
                                  "subSteps": [
                                    "Aplique a fórmula do determinante para 2x2: det = (a11 - λ)(a22 - λ) - a12 a21.",
                                    "Expanda o produto: λ² - (a11 + a22)λ + (a11 a22 - a12 a21).",
                                    "Identifique os coeficientes: grau 2, coeficiente líder 1, traço de A como soma das raízes.",
                                    "Simplifique e escreva p(λ) = λ² - (tr A)λ + det A.",
                                    "Teste com valores numéricos para validar."
                                  ],
                                  "verification": "O polinômio resultante é quadrático com coeficiente líder positivo 1 e raízes corretas ao resolver p(λ)=0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplo de matriz 2x2",
                                    "Calculadora ou software simbólico como SymPy"
                                  ],
                                  "tips": "Lembre-se: tr A = soma da diagonal, det A = produto diagonal menos produto off-diagonal.",
                                  "learningObjective": "Computar det(A - λI) e expressá-lo como polinômio para n=2.",
                                  "commonMistakes": [
                                    "Sinal errado no produto cruzado (deve ser subtração)",
                                    "Esquecer de expandir λ²",
                                    "Confundir ordem dos termos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Determinante para Matrizes 3x3 e Expandir",
                                  "subSteps": [
                                    "Escolha um método: expansão pela primeira linha ou regra de Sarrus para 3x3.",
                                    "Compute det(A - λI) termo a termo, tratando λ como variável.",
                                    "Colete termos por potências de λ: λ³, λ², λ¹, constante.",
                                    "Escreva p(λ) = λ³ - (tr A)λ² + ... com coeficientes simétricos.",
                                    "Verifique o sinal alternado: coeficiente líder (-1)^n = -1 para n=3."
                                  ],
                                  "verification": "O polinômio tem grau 3, coeficiente de λ³ é -1, e cálculo manual coincide com software.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz 3x3 exemplo",
                                    "Tabela para expansão de Laplace",
                                    "Software como MATLAB para det()"
                                  ],
                                  "tips": "Use expansão de Laplace para evitar erros na regra de Sarrus com variáveis.",
                                  "learningObjective": "Calcular det para n=3 e organizar em forma polinomial monômia.",
                                  "commonMistakes": [
                                    "Erros de sinal nos cofatores (regra (-1)^{i+j})",
                                    "Perder termos em expansões longas",
                                    "Confundir potências de λ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar para n x n e Escrever o Polinômio Explícito",
                                  "subSteps": [
                                    "Reconheça que p(λ) = ∑_{k=0}^n c_k λ^k, com c_n = (-1)^n.",
                                    "Identifique coeficientes via funções simétricas: c_{n-1} = (-1)^{n-1} tr A.",
                                    "Para n maior, discuta uso de software, mas entenda a estrutura.",
                                    "Escreva p(λ) explicitamente com todos coeficientes dependentes de A.",
                                    "Valide substituindo λ conhecido (ex: tr A como soma de autovalores)."
                                  ],
                                  "verification": "p(λ) é monômio de grau n com coeficientes corretos e independentes de ordem de cálculo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz genérica n x n",
                                    "Referência teórica (livro de álgebra linear)",
                                    "Software para polinomio característico"
                                  ],
                                  "tips": "Coeficientes são invariantes sob similaridade, úteis em aplicações.",
                                  "learningObjective": "Expressar p(λ) como polinômio de grau n com coeficientes em termos de A.",
                                  "commonMistakes": [
                                    "Ignorar o fator (-1)^n no coeficiente líder",
                                    "Confundir com polinômio minimal",
                                    "Não normalizar para monômio"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[2, 1], [1, 2]] (2x2), forme A - λI = [[2-λ, 1], [1, 2-λ]]. Então det = (2-λ)^2 - 1 = λ² - 4λ + 3. Verifique: tr A=4, det A=3.",
                              "finalVerifications": [
                                "O polinômio p(λ) tem exatamente grau n.",
                                "Coeficiente líder é (-1)^n.",
                                "Coeficiente de λ^{n-1} é (-1)^{n-1} vezes o traço de A.",
                                "As raízes de p(λ)=0 são os autovalores de A.",
                                "Cálculo coincide com output de software (ex: eig em MATLAB).",
                                "Todos coeficientes dependem corretamente dos elementos de A."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de A - λI (100% dos elementos corretos).",
                                "Cálculo exato do determinante sem erros aritméticos.",
                                "Expansão correta em polinômio monômio com termos ordenados.",
                                "Identificação precisa dos coeficientes principais (líder, traço).",
                                "Generalização conceitual para qualquer n.",
                                "Validação numérica ou simbólica fornecida."
                              ],
                              "crossCurricularConnections": [
                                "Física: Cálculo de modos normais de vibração em estruturas.",
                                "Computação: Implementação de algoritmos QR para autovalores.",
                                "Estatística: Análise de componentes principais (PCA).",
                                "Engenharia Mecânica: Análise de estabilidade de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Na engenharia civil, o polinômio característico é essencial para análise modal de edifícios e pontes, determinando frequências naturais de vibração para prever respostas a sismos e ventos, otimizando projetos contra ressonância."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Resolver a equação p(λ) = 0",
                            "description": "Encontrar as raízes do polinômio característico usando métodos analíticos para baixa ordem ou numéricos para alta ordem, identificando os autovalores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar e formular o polinômio característico p(λ)",
                                  "subSteps": [
                                    "Calcule o determinante de (A - λI) para obter p(λ) = det(A - λI).",
                                    "Expanda o polinômio explicitamente para matrizes de baixa ordem (n ≤ 4).",
                                    "Identifique o grau do polinômio e seus coeficientes principais (tr(A), det(A)).",
                                    "Verifique se o polinômio está na forma monômia padrão.",
                                    "Classifique como analítico (baixa ordem) ou numérico (alta ordem)."
                                  ],
                                  "verification": "Confirme que p(λ) está corretamente expandido comparando com fórmula conhecida para n=2 ou n=3.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz A do problema",
                                    "Papel e lápis ou software simbólico como SymPy/Python",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Sempre normalize para p(λ) = (-1)^n det(λI - A) para convenção positiva.",
                                  "learningObjective": "Formular precisamente o polinômio característico a partir da matriz.",
                                  "commonMistakes": [
                                    "Esquecer o sinal (-λ) na diagonal",
                                    "Erro no cálculo do determinante para n>2",
                                    "Não identificar o grau corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver analiticamente para polinômios de baixa ordem (n ≤ 4)",
                                  "subSteps": [
                                    "Para n=2: Use fórmula quadrática λ = [tr(A) ± sqrt(tr(A)^2 - 4 det(A))]/2.",
                                    "Para n=3: Aplique fórmula cúbica de Cardano ou fatoração racional.",
                                    "Para n=4: Reduza a quartica ou use Ferrari's method.",
                                    "Encontre todas as raízes reais e complexas.",
                                    "Simplifique raízes exatas quando possível."
                                  ],
                                  "verification": "Substitua as raízes encontradas em p(λ) e confirme que p(λ_i) ≈ 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabelas de fórmulas para equações cúbicas/quárticas",
                                    "Software como Mathematica ou Wolfram Alpha"
                                  ],
                                  "tips": "Comece testando raízes racionais com teorema das raízes racionais.",
                                  "learningObjective": "Aplicar métodos analíticos exatos para autovalores de baixa dimensionalidade.",
                                  "commonMistakes": [
                                    "Erro nos sinais da fórmula quadrática",
                                    "Ignorar raízes complexas conjugadas",
                                    "Não simplificar expressões radicais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar métodos numéricos para polinômios de alta ordem (n > 4)",
                                  "subSteps": [
                                    "Escolha método: Newton-Raphson, bissecção ou bibliotecas (eig em MATLAB/NumPy).",
                                    "Implemente iteração inicial com chute próximo a autovalores estimados (ex: Gershgorin).",
                                    "Calcule derivada p'(λ) para Newton: λ_{k+1} = λ_k - p(λ_k)/p'(λ_k).",
                                    "Monitore convergência até tolerância ε < 10^-6.",
                                    "Encontre todas as raízes usando deflação ou múltiplos chutes."
                                  ],
                                  "verification": "Verifique convergência e residual |p(λ_i)| < ε para cada raiz.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "Gráfico de p(λ) para visualização inicial"
                                  ],
                                  "tips": "Use múltiplos intervalos para bissecção em polinômios com múltiplas raízes reais.",
                                  "learningObjective": "Implementar e entender algoritmos numéricos para raízes de alta ordem.",
                                  "commonMistakes": [
                                    "Chute inicial ruim levando a não convergência",
                                    "Não deflar polinômio após raiz encontrada",
                                    "Ignorar raízes múltiplas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar autovalores e interpretar resultados",
                                  "subSteps": [
                                    "Para cada λ_i, resolva (A - λ_i I) v = 0 para autofunção v.",
                                    "Confirme que A v = λ_i v.",
                                    "Classifique autovalores (reais positivos/negativos, complexos).",
                                    "Analise multiplicidade algébrica vs geométrica.",
                                    "Documente lista final de autovalores ordenados."
                                  ],
                                  "verification": "Compute ||A v - λ v|| < ε para normalizar v.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software numérico para autofunções",
                                    "Matriz A original"
                                  ],
                                  "tips": "Ordene autovalores por módulo crescente para análise de estabilidade.",
                                  "learningObjective": "Validar autovalores no contexto de autofunções e aplicações.",
                                  "commonMistakes": [
                                    "Confundir autovalor com autofunção",
                                    "Não checar normalização",
                                    "Ignorar pares conjugados complexos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para matriz A = [[2,1],[1,2]] em análise de vibrações de viga: p(λ) = λ² - 4λ + 3 = 0 → raízes λ=3,1. Verifique: autofunções [1,1] e [1,-1].",
                              "finalVerifications": [
                                "Todas as raízes satisfazem p(λ_i) = 0 dentro de tolerância.",
                                "Número de autovalores distinto igual à dimensão da matriz.",
                                "Autofunções correspondentes são linearmente independentes.",
                                "Resultados coincidem com função eig() de software.",
                                "Interpretação física correta (ex: frequências naturais).",
                                "Documentação completa com código e gráficos."
                              ],
                              "assessmentCriteria": [
                                "Precisão das raízes (erro < 10^-5).",
                                "Escolha correta de método analítico/numérico.",
                                "Implementação sem erros de programação.",
                                "Verificações completas realizadas.",
                                "Interpretação contextual em Engenharia Civil.",
                                "Eficiência computacional para alta ordem."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e análise numérica.",
                                "Física: Dinâmica de vibrações e modos normais.",
                                "Computação: Programação científica e otimização.",
                                "Engenharia Mecânica: Análise modal de estruturas."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, resolver p(λ)=0 identifica frequências naturais de edifícios ou pontes, essencial para análise sísmica e prevenção de ressonância em projetos de estruturas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Aplicar em problemas de engenharia civil",
                            "description": "Utilizar o polinômio característico para determinar autovalores em matrizes de rigidez ou massa em análises estruturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema estrutural e extrair matrizes de rigidez e massa",
                                  "subSteps": [
                                    "Identifique o sistema estrutural (ex: viga ou treliça com graus de liberdade discretos).",
                                    "Monte a matriz de rigidez [K] usando métodos de elementos finitos ou montagem clássica.",
                                    "Monte a matriz de massa [M] distribuindo massas nos nós.",
                                    "Defina o problema de autovalores generalizado [K]φ = λ[M]φ ou padrão [K - λM]φ = 0.",
                                    "Verifique dimensões e simetria das matrizes."
                                  ],
                                  "verification": "Matrizes [K] e [M] são simétricas positivas definidas e do mesmo tamanho; problema de autovalores é válido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB/Python (NumPy/SciPy), papel e lápis para montagem manual, exemplo de estrutura 2DOF.",
                                  "tips": "Comece com sistemas pequenos (2-3 DOF) para validação manual.",
                                  "learningObjective": "Compreender como matrizes físicas se traduzem em problemas matemáticos de autovalores.",
                                  "commonMistakes": "Ignorar acoplamento entre DOF ou usar unidades inconsistentes nas massas/rigidez."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o polinômio característico",
                                  "subSteps": [
                                    "Formule a equação padrão: det([K] - λ[M]) = 0 para problemas generalizados, ou transforme para padrão via decomposição de Cholesky se [M] diagonal.",
                                    "Expanda o determinante para sistemas pequenos ou use software para computar o polinômio.",
                                    "Identifique os coeficientes do polinômio p(λ) = a_n λ^n + ... + a_0 = 0.",
                                    "Verifique se o polinômio é de grau igual ao número de DOF.",
                                    "Simplifique assumindo [M] = I se normalizada."
                                  ],
                                  "verification": "Polinômio p(λ) é monico de grau n, com coeficientes corretos validados por expansão manual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora simbólica (SymPy/MATLAB Symbolic), matrizes do Step 1.",
                                  "tips": "Para matrizes 2x2, expanda manualmente: λ² - tr(A)λ + det(A) = 0.",
                                  "learningObjective": "Dominar a formulação do polinômio a partir de matrizes estruturais.",
                                  "commonMistakes": "Confundir autovalores de [K] com [K-λM]; esquecer fatorização para generalizado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o polinômio para obter autovalores",
                                  "subSteps": [
                                    "Use método analítico para polinômios de grau ≤4 (fórmulas quadrática/cúbica/quártica).",
                                    "Para graus maiores, aplique métodos numéricos: Newton-Raphson ou eig() em software.",
                                    "Ordene autovalores: λ1 ≤ λ2 ≤ ... (frequências crescentes).",
                                    "Calcule frequências naturais ω_i = sqrt(λ_i) e períodos T_i = 2π/ω_i.",
                                    "Valide com critérios físicos (ex: modos rígidos λ=0)."
                                  ],
                                  "verification": "Autovalores positivos reais; soma dos autovalores = trace([M]^{-1}[K]).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software numérico (MATLAB eig(), Python scipy.linalg.eig), polinômio do Step 2.",
                                  "tips": "Sempre plote o polinômio para visualizar raízes reais positivas.",
                                  "learningObjective": "Aplicar resolução de polinômios em contexto de vibrações estruturais.",
                                  "commonMistakes": "Raízes complexas devido a erros em [K]/[M]; não ordenar autovalores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar autovalores e verificar análise estrutural",
                                  "subSteps": [
                                    "Associe λ_i a frequências modais e modifique de vibração.",
                                    "Compare com critérios de projeto (ex: evitar ressonância com ventos/sismos).",
                                    "Calcule autovetores φ_i para modos completos.",
                                    "Realize análise de sensibilidade variando massas/rigidez.",
                                    "Documente relatório com gráficos de modos."
                                  ],
                                  "verification": "Frequências físicas realistas (ex: 1-10 Hz para edifícios); modos ortogonais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software de visualização (MATLAB plotmode, ANSYS), autovalores do Step 3.",
                                  "tips": "Use animação de modos para intuição física.",
                                  "learningObjective": "Conectar autovalores matemáticos a insights de engenharia.",
                                  "commonMistakes": "Interpretar λ diretamente como frequência (esquecer sqrt); ignorar modos zero."
                                }
                              ],
                              "practicalExample": "Para uma viga de 2 DOF com [K] = [[200, -100], [-100, 100]] kN/m e [M] = [[2, 0], [0, 1]] kg, compute det(K - λM) = 0 → λ1=50, λ2=150 rad²/s² → f1=1.59 Hz, f2=3.87 Hz, verificando estabilidade vibracional.",
                              "finalVerifications": [
                                "Autovalores coincidem com eig() numérico (erro <1e-6).",
                                "Frequências modais crescem monotonicamente.",
                                "Modos de vibração são ortogonais: φ_i^T M φ_j = 0 (i≠j).",
                                "Análise resiste a cargas dinâmicas (ω_i > ω_excitacao).",
                                "Relatório inclui gráficos de modos e tabela de frequências.",
                                "Validação com estrutura similar em literatura."
                              ],
                              "assessmentCriteria": [
                                "Precisão na montagem de [K] e [M] (100% match com solução conhecida).",
                                "Correta formulação e resolução do polinômio (raízes exatas).",
                                "Interpretação física correta dos autovalores (frequências/estabilidade).",
                                "Uso adequado de software com validação manual.",
                                "Relatório claro com verificações e conclusões acionáveis.",
                                "Criatividade em análise de sensibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Vibrações e ondas (equações diferenciais).",
                                "Matemática: Álgebra linear avançada e polinômios.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Mecânica dos Materiais: Propriedades para [K] e [M]."
                              ],
                              "realWorldApplication": "Em projetos de pontes e edifícios, autovalores de [K] e [M] determinam frequências naturais para análise modal, evitando ressonância com terremotos ou ventos, como no Tacoma Narrows ou edifícios altos com amortecedores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Cálculo de Autovetores",
                    "description": "Resolução do sistema homogêneo (A - λI)v = 0 para obter autovetores associados a cada autovalor.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Formulação do Sistema Homogêneo",
                        "description": "Construção da equação característica (A - λI)v = 0, onde A é a matriz dada, λ é o autovalor conhecido e v é o autovetor a ser determinado, reconhecendo que se trata de um sistema linear homogêneo com soluções não-triviais no núcleo da matriz.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Construir a matriz defeituosa A - λI",
                            "description": "Dado uma matriz quadrada A e um autovalor λ, calcular λI (multiplicação escalar da matriz identidade pelo autovalor) e subtrair de A para obter a matriz (A - λI), verificando dimensões e elementos resultantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a matriz A e o autovalor λ",
                                  "subSteps": [
                                    "Leia o enunciado do problema e localize a matriz quadrada A.",
                                    "Identifique o autovalor λ fornecido.",
                                    "Confirme que A tem dimensões n x n.",
                                    "Anote A e λ em um local visível para referência futura.",
                                    "Verifique se λ é numérico e compatível com os elementos de A."
                                  ],
                                  "verification": "A matriz A e λ estão anotados corretamente, com dimensões de A confirmadas como quadrada.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Enunciado do problema",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Marque as dimensões de A imediatamente para evitar confusões posteriores.",
                                  "learningObjective": "Preparar com precisão os dados de entrada para o cálculo da matriz defeituosa.",
                                  "commonMistakes": [
                                    "Confundir o valor de λ com outro autovalor",
                                    "Interpretar incorretamente os elementos de A",
                                    "Ignorar se A não é quadrada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz identidade I de ordem n",
                                  "subSteps": [
                                    "Determine o tamanho n das linhas/colunas de A.",
                                    "Crie uma matriz n x n vazia.",
                                    "Preencha a diagonal principal (posições (1,1), (2,2), ..., (n,n)) com 1s.",
                                    "Preencha todos os outros elementos com 0s.",
                                    "Escreva a matriz I explicitamente."
                                  ],
                                  "verification": "A matriz I possui exatamente 1s na diagonal principal e 0s em todas as outras posições.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Matriz A anotada"
                                  ],
                                  "tips": "Visualize I como uma 'escada' de 1s na diagonal para rapidez.",
                                  "learningObjective": "Construir corretamente a matriz identidade compatível com A.",
                                  "commonMistakes": [
                                    "Usar tamanho errado de n",
                                    "Colocar 1s fora da diagonal",
                                    "Confundir ordem das linhas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a matriz λI",
                                  "subSteps": [
                                    "Multiplique cada elemento da diagonal de I por λ.",
                                    "Mantenha os elementos off-diagonal como 0.",
                                    "Calcule explicitamente cada entrada da diagonal: λ * 1 = λ.",
                                    "Verifique aritmeticamente cada multiplicação.",
                                    "Escreva a matriz λI completa."
                                  ],
                                  "verification": "λI tem λ em todas as posições da diagonal principal e 0s fora dela.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Matriz I construída",
                                    "Calculadora para λ complexo"
                                  ],
                                  "tips": "Lembre-se: multiplicação escalar afeta apenas a diagonal de I.",
                                  "learningObjective": "Aplicar corretamente a multiplicação escalar à matriz identidade.",
                                  "commonMistakes": [
                                    "Multiplicar λ por todos os elementos de I",
                                    "Erro de cálculo em λ (ex: sinal errado)",
                                    "Esquecer de manter 0s off-diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Subtrair λI de A elemento por elemento",
                                  "subSteps": [
                                    "Alinhe visualmente A e λI lado a lado.",
                                    "Para cada posição (i,j): compute A_{i,j} - (λI)_{i,j}.",
                                    "Calcule a diagonal: A_{i,i} - λ.",
                                    "Calcule off-diagonal: A_{i,j} - 0 = A_{i,j}.",
                                    "Registre a matriz resultante A - λI."
                                  ],
                                  "verification": "Cada elemento foi subtraído corretamente, resultando em matriz n x n.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Matrizes A, I e λI",
                                    "Calculadora"
                                  ],
                                  "tips": "Use uma tabela para alinhar e subtrair colunas paralelas.",
                                  "learningObjective": "Executar subtração de matrizes com precisão elemento por elemento.",
                                  "commonMistakes": [
                                    "Subtrair λ dos off-diagonal",
                                    "Inverter ordem (λI - A)",
                                    "Erros aritméticos em subtrações simples"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar a matriz defeituosa A - λI",
                                  "subSteps": [
                                    "Confirme dimensões: n x n.",
                                    "Verifique diagonal: cada A_{i,i} - λ.",
                                    "Confirme off-diagonal: idênticos a A.",
                                    "Cheque consistência aritmética em pelo menos 3 elementos aleatórios.",
                                    "Anote qualquer discrepância e corrija."
                                  ],
                                  "verification": "Todas as verificações de dimensões, diagonal e off-diagonal passam sem erros.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Matriz A - λI calculada",
                                    "Matriz original A"
                                  ],
                                  "tips": "Recalcule um elemento duvidoso comparando com A e λI.",
                                  "learningObjective": "Validar o resultado final para garantir acurácia.",
                                  "commonMistakes": [
                                    "Pular verificação",
                                    "Aceitar erros na diagonal",
                                    "Ignorar dimensões"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[2, 1], [1, 2]] (2x2) e λ = 3. I = [[1, 0], [0, 1]]. λI = [[3, 0], [0, 3]]. A - λI = [[2-3, 1-0], [1-0, 2-3]] = [[-1, 1], [1, -1]]. Verificação: diagonal -1 = 2-3, off-diagonal preservados.",
                              "finalVerifications": [
                                "Dimensões da matriz resultante são n x n, iguais a A.",
                                "Elementos da diagonal principal são exatamente A_{i,i} - λ.",
                                "Elementos off-diagonal são idênticos aos de A.",
                                "Não há erros aritméticos em subtrações (verificar 100% da diagonal).",
                                "Matriz é consistente para uso em sistema (A - λI)v = 0.",
                                "Se A simétrica, A - λI também o é."
                              ],
                              "assessmentCriteria": [
                                "Precisão total nos cálculos de todos os elementos.",
                                "Correta construção de I e λI como pré-requisitos.",
                                "Verificação explícita de dimensões e propriedades.",
                                "Apresentação clara e organizada da matriz final.",
                                "Explicação passo a passo do processo.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Fundamento para resolução de autovetores.",
                                "Programação Computacional: Implementação em NumPy/Python ou MATLAB.",
                                "Engenharia Civil: Análise modal de estruturas (vibrações).",
                                "Física: Cálculo de modos normais em sistemas dinâmicos.",
                                "Estatística: Análise de componentes principais (PCA)."
                              ],
                              "realWorldApplication": "Em engenharia civil, a matriz defeituosa A - λI é crucial para formular o sistema homogêneo (A - λI)v = 0 no cálculo de autovetores, aplicado na análise modal de estruturas como pontes e edifícios para determinar frequências naturais de vibração, modos de deformação e otimização de projetos contra ressonância sísmica."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Identificar soluções triviais e não-triviais",
                            "description": "Reconhecer que o vetor nulo v = 0 é sempre uma solução trivial do sistema homogêneo e compreender a necessidade de soluções não-triviais, associadas à singularidade de (A - λI) quando λ é autovalor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Sistema Homogêneo e a Solução Trivial",
                                  "subSteps": [
                                    "Revise a formulação do sistema homogêneo: (A - λI)v = 0, onde A é a matriz, λ é o autovalor candidato e v é o autovetor.",
                                    "Identifique que v = 0 (vetor nulo) sempre satisfaz a equação, pois qualquer matriz multiplicada por zero resulta em zero.",
                                    "Classifique v = 0 como solução trivial, explicando que ela não fornece informação útil sobre direções próprias.",
                                    "Discuta por que soluções triviais são insuficientes para caracterizar autovetores em aplicações práticas.",
                                    "Esboce um exemplo simples com matriz identidade para ilustrar."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que v=0 é sempre solução e por que é trivial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel, calculadora, livro-texto de álgebra linear (capítulo de autovalores).",
                                  "tips": "Sempre comece substituindo v=0 na equação para visualizar intuitivamente.",
                                  "learningObjective": "Reconhecer a existência universal da solução trivial no sistema homogêneo.",
                                  "commonMistakes": "Confundir solução trivial com autovetor nulo; lembrar que autovetores são definidos como não-nulos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Condição para Soluções Não-Triviais",
                                  "subSteps": [
                                    "Lembre que soluções não-triviais existem se o sistema tem infinitas soluções, i.e., não único.",
                                    "Estabeleça que isso ocorre quando det(A - λI) = 0, tornando a matriz singular.",
                                    "Explique o teorema: λ é autovalor iff det(A - λI) = 0, garantindo kernel não-trivial.",
                                    "Discuta o espaço nulo: dim(ker(A - λI)) > 0 para autovetores não-triviais.",
                                    "Compare com sistemas não-homogêneos onde singularidade leva a inconsistência ou infinitas soluções."
                                  ],
                                  "verification": "Calcule det(A - λI) para um λ conhecido e confirme se é zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software como MATLAB ou Python (NumPy) para cálculo de determinante, matriz de exemplo.",
                                  "tips": "Use propriedades de determinantes para simplificar cálculos em matrizes maiores.",
                                  "learningObjective": "Associar soluções não-triviais à singularidade da matriz (A - λI).",
                                  "commonMistakes": "Achar que det≠0 implica soluções não-triviais; singularidade é necessária e suficiente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Singularidade e Encontrar Soluções Não-Triviais",
                                  "subSteps": [
                                    "Para uma matriz dada e λ, compute A - λI.",
                                    "Calcule o determinante ou rank para confirmar singularidade (rank < n).",
                                    "Resolva o sistema reduzido (escalonamento de Gauss-Jordan) para encontrar base do kernel.",
                                    "Selecione autovetores não-triviais normalizando ou escalando soluções.",
                                    "Valide multiplicando (A - λI)v ≠ 0 só se v trivial."
                                  ],
                                  "verification": "Encontre pelo menos um autovetor não-trivial e verifique Av = λv.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora matricial, software GeoGebra ou Octave, exemplos impressos de matrizes.",
                                  "tips": "Priorize escalonamento para matrizes >2x2; evite divisão por zero diretamente.",
                                  "learningObjective": "Aplicar métodos numéricos para isolar soluções não-triviais.",
                                  "commonMistakes": "Esquecer de verificar se v é não-nulo após resolução; aceitar soluções escalares zero."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Contextualizar em Autovalores",
                                  "subSteps": [
                                    "Relacione soluções não-triviais ao significado geométrico: direções invariantes sob transformação A.",
                                    "Discuta multiplicidade algébrica vs geométrica via dim(kernel).",
                                    "Aplique em problemas de engenharia: modais de vibração onde autovetores são modos.",
                                    "Compare trivial vs não-trivial em termos de utilidade prática.",
                                    "Resuma: trivial sempre existe, não-trivial só para autovalores verdadeiros."
                                  ],
                                  "verification": "Descreva em um parágrafo como soluções não-triviais confirmam λ como autovalor.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Artigos ou vídeos sobre aplicações em engenharia civil (vibrações estruturais).",
                                  "tips": "Visualize com setas: transformação A alonga/rotaciona ao longo de autovetores.",
                                  "learningObjective": "Integrar conceito ao framework completo de autovalores/autofunções.",
                                  "commonMistakes": "Ignorar contexto: soluções triviais são matemáticas, mas irrelevantes fisicamente."
                                }
                              ],
                              "practicalExample": "Considere A = [[2,1],[1,2]], teste λ=3: A-3I = [[-1,1],[1,-1]], det=0 (singular). Solução trivial v=[0,0]. Não-trivial: escalone para v=[1,1]. Verifique: A[1,1]=[3,3]=3[1,1]. Para λ=1 (autovalor), v=[1,-1].",
                              "finalVerifications": [
                                "Explique por que v=0 é trivial e sempre solução.",
                                "Dado A e λ com det(A-λI)=0, encontre autovetor não-trivial.",
                                "Diferencie casos det=0 vs det≠0.",
                                "Verifique Av=λv para solução encontrada.",
                                "Discuta implicações se só trivial existir.",
                                "Identifique singularidade sem calcular det (via rank)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de v=0 como trivial (100%).",
                                "Correta associação de não-triviais a det(A-λI)=0 (90%+).",
                                "Habilidade em resolver sistema e isolar v≠0 (demonstrado em 2 exemplos).",
                                "Interpretação contextual em autovalores (escrita clara).",
                                "Ausência de erros comuns como aceitar v=0 como autovetor.",
                                "Eficiência em verificações (tempo < estimado)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração em estruturas (autovetores como formas modais).",
                                "Engenharia Mecânica: Análise de estabilidade (autovalores para buckling).",
                                "Computação: Algoritmos QR para autovalores em simulações FEM.",
                                "Estatística: Análise de componentes principais (PCA via autovetores)."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao analisar vibrações de pontes ou edifícios via método de elementos finitos, identificar autovetores não-triviais permite determinar frequências e modos de oscilação, prevendo falhas ressonantes e otimizando designs contra colapsos como no caso da Ponte de Tacoma Narrows."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Resolução do Sistema Linear Homogêneo",
                        "description": "Aplicação de métodos de eliminação para resolver (A - λI)v = 0, identificando o espaço nulo da matriz e expressando autovetores em termos de variáveis livres.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Realizar escalonamento gaussiano",
                            "description": "Formar a matriz aumentada [A - λI | 0], aplicar eliminação gaussiana com pivoteamento parcial para obter a forma escalonada reduzida, identificando pivôs e linhas nulas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir a Matriz Aumentada [A - λI | 0]",
                                  "subSteps": [
                                    "Obtenha a matriz A e o autovalor λ do problema.",
                                    "Calcule a matriz identidade I do mesmo tamanho de A.",
                                    "Multiplique I por λ para obter λI.",
                                    "Subtraia λI de A para formar A - λI.",
                                    "Anexe uma coluna de zeros à direita de A - λI para formar a matriz aumentada [A - λI | 0]."
                                  ],
                                  "verification": "Verifique se a matriz aumentada tem dimensões corretas (n x (n+1)) e se todos os elementos da última coluna são zero.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A e λ fornecidos",
                                    "Papel quadriculado ou software como MATLAB/Octave/Python (NumPy)",
                                    "Calculadora"
                                  ],
                                  "tips": "Use frações exatas para evitar erros de arredondamento; rotule claramente as linhas e colunas.",
                                  "learningObjective": "Compreender a formação do sistema linear homogêneo (A - λI)v = 0 em forma matricial aumentada.",
                                  "commonMistakes": [
                                    "Esquecer de subtrair λI corretamente",
                                    "Anexar coluna de zeros no lugar errado",
                                    "Confundir dimensões da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Pivoteamento Parcial e Eliminação Gaussiana para Forma Escalonada (REF)",
                                  "subSteps": [
                                    "Para cada coluna k de 1 a n-1: encontre o pivô máximo na coluna k abaixo da linha k.",
                                    "Troque a linha k com a linha do pivô máximo (pivoteamento parcial).",
                                    "Use a linha pivô para eliminar entradas abaixo do pivô em linhas subsequentes.",
                                    "Prossiga para a próxima coluna até obter forma triangular superior (REF).",
                                    "Registre os pivôs encontrados em cada coluna."
                                  ],
                                  "verification": "A matriz está em REF: zeros abaixo dos pivôs, pivôs como primeiros não-zero em suas linhas, linhas ordenadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz aumentada do Step 1",
                                    "Papel ou software",
                                    "Calculadora para divisões"
                                  ],
                                  "tips": "Sempre divida pela entrada pivô para normalizar; verifique se eliminou todos os elementos abaixo do pivô.",
                                  "learningObjective": "Dominar a eliminação gaussiana com pivoteamento para estabilizar numericamente o processo.",
                                  "commonMistakes": [
                                    "Pular pivoteamento, levando a divisões por números pequenos",
                                    "Erros de sinal em subtrações múltiplas",
                                    "Não prosseguir até todas as colunas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Eliminação para Forma Escalonada Reduzida (RREF)",
                                  "subSteps": [
                                    "Comece da última coluna com pivô e suba: normalize o pivô para 1 dividindo a linha inteira.",
                                    "Elimine entradas acima do pivô usando linhas subsequentes.",
                                    "Repita para cada pivô ascendente até todos os pivôs serem 1 e zeros acima/abaixo.",
                                    "Verifique que a matriz aumentada está em forma identidade ou equivalente reduzida.",
                                    "Mantenha a última coluna de zeros intacta."
                                  ],
                                  "verification": "Todos pivôs são 1, zeros em toda a coluna exceto no pivô; matriz em RREF canônica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz em REF do Step 2",
                                    "Software recomendado para verificação",
                                    "Papel"
                                  ],
                                  "tips": "Trabalhe de baixo para cima para evitar propagação de erros; use multiplicadores exatos.",
                                  "learningObjective": "Transformar REF em RREF para facilitar identificação do núcleo (espaço nulo).",
                                  "commonMistakes": [
                                    "Esquecer eliminação acima dos pivôs",
                                    "Alterar acidentalmente a coluna de zeros",
                                    "Não normalizar pivôs para 1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Pivôs, Linhas Nulas e Interpretar para Autovetores",
                                  "subSteps": [
                                    "Localize as posições dos pivôs (1's principais).",
                                    "Identifique linhas nulas (todas zeros exceto possivelmente na última coluna, que deve ser zero).",
                                    "Atribua variáveis livres às colunas sem pivô.",
                                    "Resolva o sistema para expressar autovetores em termos de parâmetros livres.",
                                    "Verifique consistência: última coluna deve ser zeros nas linhas nulas."
                                  ],
                                  "verification": "Lista de pivôs e variáveis livres correta; autovetores parametrizados geram soluções válidas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz em RREF do Step 3",
                                    "Folha para anotar variáveis livres"
                                  ],
                                  "tips": "O número de linhas nulas indica a dimensão geométrica do autespço; teste plugando valores.",
                                  "learningObjective": "Interpretar RREF para encontrar a base do espaço de autovetores associado a λ.",
                                  "commonMistakes": [
                                    "Confundir pivôs com variáveis livres",
                                    "Ignorar inconsistências na coluna zero",
                                    "Não parametrizar corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[2,1,0],[1,3,1],[0,1,2]] e λ=1: A-λI = [[1,1,0],[1,2,1],[0,1,1]], aumentada [[1,1,0|0],[1,2,1|0],[0,1,1|0]]. Após REF: pivôs em col 1 e 2. RREF leva a v = t[-1,1,0]^T + s[0,-1,1]^T (base do autespço).",
                              "finalVerifications": [
                                "Matriz final em RREF correta com pivôs unitários e zeros apropriados.",
                                "Coluna de zeros permanece zero em todas as linhas.",
                                "Pivôs identificados corretamente com suas posições.",
                                "Linhas nulas detectadas e sem inconsistências.",
                                "Autovetores parametrizados resolvem (A-λI)v=0.",
                                "Pivoteamento parcial foi usado onde necessário (max |entry|)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da matriz aumentada (100% correto).",
                                "Correta aplicação de pivoteamento e eliminação sem erros aritméticos.",
                                "RREF alcançada com todos pivôs normalizados.",
                                "Identificação precisa de pivôs, linhas nulas e variáveis livres.",
                                "Interpretação coerente para autovetores.",
                                "Eficiência temporal e ausência de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python (NumPy/SciPy) ou MATLAB para automação.",
                                "Física/Engenharia: Análise de vibrações modais em estruturas civis.",
                                "Estatística: Redução de dimensionalidade em dados multivariados.",
                                "Computação Científica: Pré-condicionadores em métodos iterativos."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para calcular autovetores em análise dinâmica de edifícios, determinando modos de vibração para design sísmico resistente e otimização de estruturas contra ressonância."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Determinar variáveis livres e pivotais",
                            "description": "A partir da forma escalonada, classificar variáveis como pivotais (dependentes) ou livres (parâmetros), e expressar as variáveis pivotais em função das livres para parametrizar o núcleo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a Matriz em Forma Escalonada e Identificar Posições Pivot",
                                  "subSteps": [
                                    "Examine a matriz aumentada do sistema homogêneo já reduzida à forma escalonada (REF).",
                                    "Localize as linhas não-nulas e identifique o pivô (primeiro elemento não-nulo) em cada uma delas.",
                                    "Registre as colunas que contêm os pivôs; essas são as colunas pivotais.",
                                    "Conte o número de pivôs para determinar o posto da matriz.",
                                    "Liste as colunas sem pivôs como candidatas a variáveis livres."
                                  ],
                                  "verification": "Confirme que as colunas pivotais estão corretamente anotadas e o número de pivôs equals o posto da matriz.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Matriz em REF impressa ou software como MATLAB/Octave/Python (NumPy), lápis e papel.",
                                  "tips": "Comece sempre pela primeira linha não-nula e desça; ignore linhas zero.",
                                  "learningObjective": "Dominar a identificação precisa de pivôs na REF para classificar colunas.",
                                  "commonMistakes": "Confundir elementos não-pivô em colunas pivotais com pivôs ou ignorar linhas zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar Variáveis como Pivotais ou Livres",
                                  "subSteps": [
                                    "Atribua às variáveis das colunas pivotais o status de 'pivotais' (dependentes).",
                                    "Atribua às variáveis das colunas livres o status de 'livres' (parâmetros independentes).",
                                    "Verifique que o número de variáveis livres é igual à dimensão do núcleo (n - posto).",
                                    "Rotule explicitamente cada variável (ex: x1 pivotal, x2 livre).",
                                    "Anote os parâmetros para as livres (ex: s, t)."
                                  ],
                                  "verification": "Crie uma tabela resumindo: variável | tipo | coluna | pivô?, com contagem correta de livres.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Papel para tabela, calculadora para contagens.",
                                  "tips": "Lembre-se: pivotais têm equações que as definem; livres são 'escolhidas livremente'.",
                                  "learningObjective": "Classificar corretamente variáveis para parametrizar soluções.",
                                  "commonMistakes": "Classificar erroneamente uma coluna pivot como livre devido a zeros acima do pivô."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expressar Variáveis Pivotais em Função das Variáveis Livres",
                                  "subSteps": [
                                    "Para cada equação da REF, isole a variável pivotal usando as livres como parâmetros.",
                                    "Substitua zeros e coeficientes adequadamente (ex: x1 + 2x2 = 0 → x1 = -2x2).",
                                    "Propague dependências de linhas superiores se houver (para RREF ideal).",
                                    "Escreva todas as expressões pivotais explicitamente.",
                                    "Defina livres como parâmetros (ex: x2 = s)."
                                  ],
                                  "verification": "Substitua as expressões de volta na matriz original e confirme que satisfaz A x = 0.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Software para verificação matricial, quadro branco.",
                                  "tips": "Trabalhe linha por linha de baixo para cima se não for RREF completa.",
                                  "learningObjective": "Resolver equações para obter dependências lineares corretas.",
                                  "commonMistakes": "Esquecer coeficientes negativos ou propagar erros de linhas anteriores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Parametrizar o Núcleo e Escrever a Solução Geral",
                                  "subSteps": [
                                    "Combine todas as expressões em um vetor solução: x = s * v1 + t * v2 + ...",
                                    "Identifique vetores base do núcleo correspondendo a cada parâmetro livre.",
                                    "Escreva a solução geral do sistema homogêneo.",
                                    "Verifiche linear independência dos vetores base.",
                                    "Opcional: Normalize ou simplifique os vetores."
                                  ],
                                  "verification": "A solução parametrizada satisfaz o sistema original e dim(núcleo) correto.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python/MATLAB para nullspace(), papel para vetores.",
                                  "tips": "Cada livre gera um vetor base com 1 na posição livre e valores opostos nas pivotais.",
                                  "learningObjective": "Construir a base parametrizada do núcleo para autovetores.",
                                  "commonMistakes": "Gerar vetores linearmente dependentes ou esquecer parâmetros múltiplos."
                                }
                              ],
                              "practicalExample": "Para a matriz REF [1 2 0 0; 0 0 1 0; 0 0 0 0], variáveis x1,x2,x3,x4. Pivôs: col1(x1), col3(x3). Livres: x2=s, x4=t. Solução: x1=-2s, x2=s, x3=0, x4=t. Núcleo base: [-2,1,0,0] e [0,0,0,1].",
                              "finalVerifications": [
                                "Número de variáveis livres equals n - posto.",
                                "Substituição na matriz original dá vetor zero.",
                                "Vetores base são linearmente independentes.",
                                "Expressões pivotais sem variáveis pivotais não resolvidas.",
                                "Solução cobre todo o núcleo (geral).",
                                "Coeficientes corretos sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pivôs (100% correto).",
                                "Classificação variáveis sem erros.",
                                "Expressões algébricas exatas e simplificadas.",
                                "Solução parametrizada completa e verificável.",
                                "Verificações finais demonstradas.",
                                "Eficiência nos passos (tempo dentro do estimado)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Base para autovalores e SVD.",
                                "Programação: Implementar Gauss-Jordan em Python/NumPy.",
                                "Física: Modos normais em vibrações estruturais.",
                                "Estatística: Espaços nulos em regressão linear."
                              ],
                              "realWorldApplication": "Em engenharia civil, parametrizar o núcleo permite encontrar autovetores para análise modal de estruturas (ex: torres ou pontes), identificando modos de deformação livre sob cargas dinâmicas como terremotos, essencial para software como SAP2000."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Gerar autovetores a partir de parâmetros livres",
                            "description": "Escolher valores específicos para variáveis livres (ex: 1 ou 0 conforme convenção) para obter vetores base do espaço nulo, gerando autovetores associados ao autovalor λ, considerando multiplicidade geométrica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar as variáveis livres na solução geral do sistema homogêneo",
                                  "subSteps": [
                                    "Resolva o sistema linear homogêneo (A - λI)x = 0 usando eliminação gaussiana ou método de redução de linhas.",
                                    "Escreva a solução geral na forma x = s * v1 + t * v2 + ... onde s, t são parâmetros livres.",
                                    "Liste explicitamente todas as variáveis livres e suas posições nos componentes do vetor x.",
                                    "Confirme o número de variáveis livres, que corresponde à dimensão do espaço nulo (multiplicidade geométrica).",
                                    "Anote a base preliminar do espaço nulo associada aos parâmetros."
                                  ],
                                  "verification": "Verifique se a solução geral satisfaz (A - λI)x = 0 para valores arbitrários dos parâmetros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz A - λI",
                                    "Papel quadriculado ou software como MATLAB/Octave",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Sempre reduza a matriz escalonada reduzida para identificar pivôs e variáveis livres claramente.",
                                  "learningObjective": "Compreender como as variáveis livres definem o espaço nulo e sua dimensão.",
                                  "commonMistakes": [
                                    "Confundir variáveis pivotais com livres",
                                    "Esquecer de parametrizar todas as variáveis livres",
                                    "Não verificar se a solução é geral"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher valores específicos para os parâmetros livres",
                                  "subSteps": [
                                    "Atribua valores convenionais aos parâmetros livres: tipicamente 1 para um parâmetro e 0 para os outros, criando vetores base.",
                                    "Para cada variável livre, gere um vetor correspondente setando-a em 1 e as demais em 0.",
                                    "Substitua os parâmetros na solução geral para obter vetores específicos.",
                                    "Rotule cada vetor como associado ao autovalor λ.",
                                    "Garanta que o número de vetores gere corresponda à multiplicidade geométrica."
                                  ],
                                  "verification": "Confirme que cada vetor resultante tem o parâmetro correspondente em 1 e os outros em 0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Solução geral anotada",
                                    "Folha de cálculo"
                                  ],
                                  "tips": "Use a convenção padrão: primeiro vetor com s=1, t=0; segundo com s=0, t=1, etc., para clareza.",
                                  "learningObjective": "Dominar a geração de uma base para o espaço nulo via atribuição de valores aos parâmetros.",
                                  "commonMistakes": [
                                    "Escolher valores que tornem os vetores linearmente dependentes",
                                    "Usar valores fracionários desnecessários",
                                    "Invertar a ordem dos parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar que os vetores gerados são autovetores",
                                  "subSteps": [
                                    "Para cada vetor v obtido, compute (A - λI)v e confirme que resulta no vetor nulo.",
                                    "Alternativamente, verifique Av = λv diretamente.",
                                    "Calcule a norma ou verifique linear independência somando combinações lineares.",
                                    "Documente os cálculos matriciais para cada vetor.",
                                    "Ajuste escalares se necessário para normalização (opcional, mas recomendado)."
                                  ],
                                  "verification": "Todos os vetores devem satisfazer Av = λv exata ou numericamente (erro < 10^-10).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz A original",
                                    "Software de álgebra linear como Python/NumPy ou MATLAB"
                                  ],
                                  "tips": "Use multiplicação matricial vetor para eficiência; evite cálculos manuais longos.",
                                  "learningObjective": "Validar matematicamente os autovetores gerados.",
                                  "commonMistakes": [
                                    "Erro de cálculo na multiplicação matricial",
                                    "Confundir autovalor com outro",
                                    "Não verificar o vetor nulo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar multiplicidade geométrica e linear independência",
                                  "subSteps": [
                                    "Conte o número de autovetores linearmente independentes gerados (deve igualar mg).",
                                    "Forme a matriz com colunas como autovetores e verifique posto igual a mg.",
                                    "Compare mg com multiplicidade algébrica (de raízes características).",
                                    "Discuta implicações se mg < ma (não diagonalizável).",
                                    "Escreva a base final de autovetores."
                                  ],
                                  "verification": "O conjunto de vetores deve ser linearmente independente e spanning o espaço nulo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de autovetores",
                                    "Calculadora para determinante ou row reduction"
                                  ],
                                  "tips": "Para independência, resolva c1 v1 + ... = 0 e confirme só solução trivial.",
                                  "learningObjective": "Relacionar autovetores à estrutura espectral da matriz.",
                                  "commonMistakes": [
                                    "Assumir independência sem verificar",
                                    "Confundir mg com ma",
                                    "Gerar vetores dependentes por escolha ruim de parâmetros"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 2, 0], [0, 1, 0], [0, 0, 2]] com λ=1 (ma=2). Sistema (A-I)x=0: x2 livre (t), x1= -2t, x3=0. Parâmetros: só um? Espere, mg=1 aqui. Melhor: A = [[3,1,0],[1,3,0],[0,0,2]], λ=3 (ma=2). (A-3I)=[[0,1,0],[1,0,0],[0,0,-1]], mas ajuste. Solução geral: x1=s, x2=s, x3=t? Use: para λ=0 em matriz com nullity 2, ex: solução x=[s, t, -s-t]^T. Vetores: v1=[1,0,-1]^T (s=1,t=0), v2=[0,1,-1]^T (s=0,t=1). Verifique Av=0v.",
                              "finalVerifications": [
                                "Gere corretamente vetores base do espaço nulo a partir de parâmetros livres.",
                                "Verifique Av = λv para todos autovetores.",
                                "Identifique corretamente a multiplicidade geométrica.",
                                "Confirme linear independência dos autovetores.",
                                "Explique o processo em palavras próprias.",
                                "Aplique a um exemplo novo sem ajuda."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de variáveis livres (100%).",
                                "Correção na geração de autovetores (Av=λv verificado).",
                                "Número correto de vetores independentes igual a mg.",
                                "Clareza na documentação e cálculos.",
                                "Tratamento de casos com mg < ma.",
                                "Eficiência no uso de convenções padrão."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração em estruturas (engenharia civil).",
                                "Programação: Implementação em Python/NumPy para análise numérica.",
                                "Estatística: Análise de componentes principais (PCA).",
                                "Engenharia Mecânica: Estabilidade de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em engenharia civil, gerar autovetores de matrizes de rigidez para análise modal de edifícios, identificando modos de vibração e frequências naturais para design sísmico seguro."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Verificação e Normalização de Autovetores",
                        "description": "Confirmação da correção dos autovetores calculados e aplicação de normalizações para padronização, garantindo propriedades como A v = λ v.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Verificar a propriedade do autovetor",
                            "description": "Multiplicar a matriz original A pelo autovetor v candidato e confirmar que o resultado é igual a λ v, computando numericamente e analisando resíduos para precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz A, autovalor λ e autovetor v candidato",
                                  "subSteps": [
                                    "Recupere a matriz original A do problema.",
                                    "Identifique o autovalor λ calculado anteriormente.",
                                    "Obtenha o autovetor v candidato normalizado ou não.",
                                    "Verifique as dimensões: A é n x n, v é n x 1.",
                                    "Carregue os dados em um ambiente computacional (ex: Python/NumPy)."
                                  ],
                                  "verification": "Confirme que A.shape == (n,n), v.shape == (n,) ou (n,1), e λ é escalar.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Matriz A",
                                    "Autovalor λ",
                                    "Autovetor v",
                                    "Python com NumPy ou MATLAB"
                                  ],
                                  "tips": "Use np.array() para garantir tipos numéricos precisos.",
                                  "learningObjective": "Garantir que todos os componentes estejam prontos e corretamente formatados para multiplicação matricial.",
                                  "commonMistakes": [
                                    "Dimensões incompatíveis",
                                    "Usar vetor coluna como linha",
                                    "Esquecer normalização prévia"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar o produto matricial A * v",
                                  "subSteps": [
                                    "Implemente a multiplicação A @ v ou np.dot(A, v).",
                                    "Armazene o resultado em uma variável, ex: Av.",
                                    "Exiba ou imprima o vetor Av para inspeção inicial.",
                                    "Verifique se o resultado tem as dimensões corretas (n x 1).",
                                    "Registre o tempo de computação se aplicável."
                                  ],
                                  "verification": "Av deve ser um vetor com mesmo tamanho de v; compare visualmente com λ v esperado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ambiente Python/NumPy ou MATLAB",
                                    "Código para multiplicação matricial"
                                  ],
                                  "tips": "Use precisão de ponto flutuante dupla (float64) para evitar erros de arredondamento.",
                                  "learningObjective": "Dominar a computação numérica de produtos matriciais-vetoriais.",
                                  "commonMistakes": [
                                    "Confundir multiplicação escalar com matricial",
                                    "Erro de sintaxe em @ ou dot",
                                    "Não converter para array"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o produto escalar λ * v",
                                  "subSteps": [
                                    "Multiplique o escalar λ pelo vetor v: λv = λ * v.",
                                    "Armazene em uma variável, ex: lambda_v.",
                                    "Exiba lambda_v para comparação.",
                                    "Confirme que é um vetor escalado uniformemente.",
                                    "Compare dimensões e tipo com Av."
                                  ],
                                  "verification": "lambda_v deve ter mesmo tamanho e ser proporcional a v.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Python/NumPy ou MATLAB"
                                  ],
                                  "tips": "Em NumPy, broadcasting cuida da multiplicação escalar-vetor automaticamente.",
                                  "learningObjective": "Entender a operação de escalamento vetorial e sua relação com autovalores.",
                                  "commonMistakes": [
                                    "Multiplicar elemento a elemento incorretamente",
                                    "Usar λ de outro autovalor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o resíduo r = A*v - λ*v",
                                  "subSteps": [
                                    "Subtraia: r = Av - lambda_v.",
                                    "Armazene o vetor resíduo r.",
                                    "Exiba componentes de r; idealmente próximos de zero.",
                                    "Verifique se todos elementos estão dentro de uma tolerância pequena (ex: 1e-10).",
                                    "Registre o resíduo máximo absoluto."
                                  ],
                                  "verification": "||r|| deve ser muito pequeno (ordem de 1e-12 ou menos para precisão numérica).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "NumPy para subtração vetorial",
                                    "Função np.max(np.abs(r))"
                                  ],
                                  "tips": "Use np.linalg.norm(r) para norma global, mas inspecione componentes individuais.",
                                  "learningObjective": "Quantificar numericamente a propriedade do autovetor via resíduo.",
                                  "commonMistakes": [
                                    "Subtrair na ordem errada",
                                    "Ignorar sinal do resíduo",
                                    "Tolerância muito laxa"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar a norma do resíduo e concluir sobre a precisão",
                                  "subSteps": [
                                    "Calcule normas: ||r||_2, ||r||_∞.",
                                    "Compare com tolerância: ex: tol = 1e-10 * ||A|| * ||v||.",
                                    "Interprete: se ||r|| < tol, v é autovetor válido.",
                                    "Documente o relatório de verificação.",
                                    "Ajuste se necessário (ex: reescalar v)."
                                  ],
                                  "verification": "Conclusão explícita: 'Autovetor confirmado' ou 'Não confirmado, erro: X'.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Funções np.linalg.norm()",
                                    "Critério de tolerância relativa"
                                  ],
                                  "tips": "Sempre use norma relativa para matrizes de diferentes escalas.",
                                  "learningObjective": "Avaliar precisão numérica e validar propriedades algébricas computacionalmente.",
                                  "commonMistakes": [
                                    "Tolerância absoluta em vez de relativa",
                                    "Ignorar condicionamento de A",
                                    "Concluir sem norma"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[2, 1], [1, 2]], λ = 3, v = [1, 1]^T: Av = [[3], [3]], λv = [[3], [3]], r = [0, 0], ||r||_2 = 0 < 1e-10. Confirma autovetor exato. Em Python: import numpy as np; A=np.array([[2,1],[1,2]]); v=np.array([1,1]); lam=3; Av=np.dot(A,v); lv=lam*v; r=Av-lv; print(np.linalg.norm(r)).",
                              "finalVerifications": [
                                "||A v - λ v||_2 < 1e-10 * ||A||_2 * ||v||_2",
                                "Todos componentes de r estão próximos de zero",
                                "Dimensões de Av e λv coincidem exatamente",
                                "λ é o autovalor correto associado",
                                "v não é vetor nulo",
                                "Relatório documentado com valores numéricos"
                              ],
                              "assessmentCriteria": [
                                "Correção na computação de Av e λv (100% match com solução esperada)",
                                "Cálculo preciso do resíduo e normas (erro < 1e-12)",
                                "Uso adequado de tolerância relativa",
                                "Interpretação correta da precisão numérica",
                                "Documentação clara com prints/códigos",
                                "Identificação e correção de erros comuns"
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica (NumPy/MATLAB para álgebra linear)",
                                "Análise Numérica (erros de arredondamento e condicionamento)",
                                "Engenharia Estrutural (modos de vibração em análise modal)",
                                "Física Computacional (sistemas dinâmicos lineares)"
                              ],
                              "realWorldApplication": "Em engenharia civil, verifica autovetores em análises modais de estruturas (ex: pontes, edifícios) para modos de vibração, garantindo precisão em simulações FEM (Finite Element Method) e evitando colapsos por erros numéricos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.3"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Normalizar autovetores",
                            "description": "Calcular a norma euclidiana do autovetor v, dividir v por sua norma para obter um autovetor unitário, e discutir convenções como normalização pela primeira componente não-nula.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de normalização de autovetores e fórmula da norma euclidiana",
                                  "subSteps": [
                                    "Revise a definição de autovetor: um vetor v tal que Av = λv para matriz A e escalar λ.",
                                    "Defina norma euclidiana ||v|| = sqrt(v1² + v2² + ... + vn²) para vetor v = [v1, v2, ..., vn].",
                                    "Explique que autovetor unitário u = v / ||v|| satisfaz ||u|| = 1.",
                                    "Discuta por que normalizar: facilita comparações, escalas e interpretações físicas.",
                                    "Identifique convenções alternativas: normalizar pela primeira componente não-nula (ex: u1 = 1 ou ±1)."
                                  ],
                                  "verification": "Escreva a fórmula da norma euclidiana e dê um exemplo simples de vetor normalizado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Lembre-se: norma é sempre positiva; use sqrt no final.",
                                  "learningObjective": "Compreender o propósito matemático e prático da normalização de autovetores.",
                                  "commonMistakes": [
                                    "Confundir norma L1 (soma absoluta) com L2 (euclidiana)",
                                    "Esquecer raiz quadrada na norma"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a norma euclidiana do autovetor dado",
                                  "subSteps": [
                                    "Anote o autovetor v explicitamente (ex: v = [3, 4]ᵀ).",
                                    "Calcule o quadrado da norma: ||v||² = 3² + 4² = 9 + 16 = 25.",
                                    "Extraia a raiz: ||v|| = sqrt(25) = 5.",
                                    "Generalize para vetores n-dimensionais: some vi² para i=1 a n, depois sqrt.",
                                    "Use software se disponível: norm(v, 2) no MATLAB."
                                  ],
                                  "verification": "Confirme que ||v|| > 0 (exceto vetor nulo, inválido para autovetores).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Exemplo de autovetor de problema anterior"
                                  ],
                                  "tips": "Para vetores grandes, calcule ||v||² primeiro para evitar erros de arredondamento.",
                                  "learningObjective": "Dominar o cálculo preciso da norma euclidiana de qualquer autovetor.",
                                  "commonMistakes": [
                                    "Arredondar prematuramente",
                                    "Usar norma errada (ex: máxima componente)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dividir o autovetor pela norma para obter o unitário",
                                  "subSteps": [
                                    "Calcule cada componente: ui = vi / ||v|| para i=1 a n.",
                                    "Exemplo: u = [3/5, 4/5]ᵀ = [0.6, 0.8]ᵀ.",
                                    "Mantenha precisão: use frações exatas se possível (3/5, 4/5).",
                                    "Implemente em software: u = v / norm(v).",
                                    "Salve o autovetor unitário u."
                                  ],
                                  "verification": "Recalcule ||u|| e confirme ≈1 (tolerância numérica 10^-10).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB"
                                  ],
                                  "tips": "Sempre divida pelo valor exato da norma para evitar propagação de erros.",
                                  "learningObjective": "Executar a normalização euclidiana com precisão.",
                                  "commonMistakes": [
                                    "Dividir pela norma ao quadrado",
                                    "Inverter ordem (||v|| / vi)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar normalização e discutir convenções alternativas",
                                  "subSteps": [
                                    "Verifique ||u|| = 1 computando sqrt(sum(ui²)).",
                                    "Discuta convenções: em engenharia, às vezes normaliza-se u1=1 ou fase para oscilações.",
                                    "Compare: normalização por primeira não-nula (ex: se v2≠0, u2=1).",
                                    "Explique trade-offs: euclidiana preserva 'comprimento'; componente fixa simplifica matriz modal.",
                                    "Documente escolha de normalização no relatório."
                                  ],
                                  "verification": "Escreva uma tabela comparando v, ||v||, u e convenções.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para tabela",
                                    "Referências de livros de álgebra linear"
                                  ],
                                  "tips": "Em contextos físicos (vibrações), prefira norma euclidiana para energia unitária.",
                                  "learningObjective": "Avaliar e justificar escolhas de normalização em contextos aplicados.",
                                  "commonMistakes": [
                                    "Ignorar sinal (autovetores definidos até escalar ±1)",
                                    "Não verificar numericamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado autovetor v = [3, -4, 0]ᵀ de uma matriz de rigidez em análise estrutural. ||v|| = sqrt(9+16+0)=5. Autovetor unitário u = [3/5, -4/5, 0]ᵀ = [0.6, -0.8, 0]ᵀ. Convenção alternativa: normalizar pela primeira componente: u' = [1, -4/3, 0]ᵀ.",
                              "finalVerifications": [
                                "||u|| = 1 dentro de tolerância numérica.",
                                "Au = λu com u normalizado.",
                                "Todas componentes calculadas corretamente.",
                                "Documentação inclui convenções discutidas.",
                                "Exemplo prático reproduzido sem erros.",
                                "Gráfico ou plot do vetor antes/depois (opcional)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da norma (erro < 0.1%).",
                                "Correta divisão componente a componente.",
                                "Verificação explícita de unitariedade.",
                                "Discussão clara de pelo menos duas convenções.",
                                "Exemplo prático relevante ao contexto de engenharia civil.",
                                "Tempo total respeitado e passos lógicos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Vetores unitários em mecânica (direções de forças normais).",
                                "Programação: Funções de normalização em NumPy/Python ou MATLAB.",
                                "Estatística: Normalização em PCA para componentes principais.",
                                "Engenharia de Software: Normalizar vetores em simulações FEM."
                              ],
                              "realWorldApplication": "Na análise modal de edifícios (engenharia civil), autovetores normalizados representam modos de vibração unitários, usados para calcular respostas sísmicas em softwares como SAP2000, garantindo escalas consistentes em massas e rigidez."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Tratar autovalores com multiplicidade",
                            "description": "Para autovalores com multiplicidade algébrica maior que 1, calcular a dimensão do núcleo (multiplicidade geométrica) e gerar múltiplos autovetores linearmente independentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar autovalor com multiplicidade algébrica e preparar A - λI",
                                  "subSteps": [
                                    "Revise o polinômio característico para confirmar multiplicidade algébrica m > 1 de λ",
                                    "Extraia a matriz A do contexto do problema",
                                    "Calcule a matriz nula A - λI subtraindo λ da diagonal e ajustando",
                                    "Simplifique entradas da matriz usando fatoração comum se possível",
                                    "Verifique dimensionalidade: deve ser n x n onde n é ordem da matriz"
                                  ],
                                  "verification": "Matriz A - λI está corretamente formada e m algébrica confirmada via polinômio ou fatoração",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Matriz A original",
                                    "Polinômio característico",
                                    "Software como Python (numpy) ou MATLAB",
                                    "Papel e calculadora"
                                  ],
                                  "tips": "Armazene λ e m em uma variável para referência rápida no software",
                                  "learningObjective": "Compreender a distinção inicial entre multiplicidade algébrica e geométrica",
                                  "commonMistakes": "Erro aritmético na subtração de λI; confundir m algébrica com geométrica prematuramente"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular multiplicidade geométrica (dimensão do núcleo de A - λI)",
                                  "subSteps": [
                                    "Aplique eliminação gaussiana ou use função de rank em software para encontrar rank(R) de A - λI",
                                    "Calcule nulidade g = n - rank(R), onde n é a dimensão",
                                    "Compare g com m: se g = m, prosseguir para autovetores; caso contrário, notar forma de Jordan",
                                    "Registre g como número de autovetores independentes necessários",
                                    "Valide com traço ou determinante se matriz pequena"
                                  ],
                                  "verification": "Nulidade g calculada corretamente e igual ao número esperado de autovetores independentes",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Matriz A - λI",
                                    "Software numpy.linalg.matrix_rank ou MATLAB rank()",
                                    "Papel para Gauss-Jordan manual"
                                  ],
                                  "tips": "Use precisão numérica alta em software para evitar erros de floating-point",
                                  "learningObjective": "Dominar cálculo de dimensão do núcleo para determinar diagonalizabilidade",
                                  "commonMistakes": "Erro no rank devido a pivôs zero não detectados; ignorar precisão numérica"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver (A - λI)v = 0 para gerar base de autovetores independentes",
                                  "subSteps": [
                                    "Configure o sistema aumentado [A - λI | 0] e identifique variáveis livres (g delas)",
                                    "Parametrize solução geral: expresse variáveis pivô em termos de livres",
                                    "Escolha valores padrão para livres (e.g., 1 para cada, zeros outros) para gerar g vetores",
                                    "Verifique cada v_i: compute (A - λI)v_i ≈ 0 e A v_i ≈ λ v_i",
                                    "Ajuste escala inicial se necessário para evitar zeros desnecessários"
                                  ],
                                  "verification": "g autovetores encontrados, cada satisfazendo ||(A - λI)v_i|| < ε (tolerância numérica)",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Matriz A - λI",
                                    "numpy.linalg.null_space ou MATLAB null()",
                                    "Solver de sistemas lineares"
                                  ],
                                  "tips": "Use null_space() em numpy para base automática e evite parametrização manual",
                                  "learningObjective": "Construir explicitamente uma base para o eigenspace",
                                  "commonMistakes": "Gerar vetores linearmente dependentes por escolha ruim de parâmetros livres; não verificar equação"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar independência linear e normalizar autovetores",
                                  "subSteps": [
                                    "Forme matriz V com colunas v_1 a v_g",
                                    "Compute rank(V) ou verifique se det(V^T V) ≠ 0 (para g ≤ n)",
                                    "Normalize cada v_i: v_i = v_i / ||v_i||_2",
                                    "Opcionalmente, ortogonalize via Gram-Schmidt se aplicável",
                                    "Salve conjunto final para uso em diagonalização"
                                  ],
                                  "verification": "rank(V) = g e cada ||v_i|| = 1; A V = V Λ (onde Λ diagonal com λ)",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Matriz V de autovetores",
                                    "numpy.linalg.qr ou norm()",
                                    "Verificador A V == V * diag(λ)"
                                  ],
                                  "tips": "Sempre verifique numericamente com tolerância 1e-10 para independência",
                                  "learningObjective": "Garantir base ortonormal para eigenspace e preparar para aplicações",
                                  "commonMistakes": "Esquecer normalização; assumir independência sem verificação"
                                }
                              ],
                              "practicalExample": "Para A = [[1, 0, 0], [0, 1, 0], [0, 0, 2]] (3x3), λ=1 tem m_alg=2. A - I = [[0,0,0],[0,0,0],[0,0,1]], rank=1, g=2. Base: v1=[1,0,0]^T, v2=[0,1,0]^T. Verifique: A v1 = [1,0,0]^T =1 v1, similar para v2. Normalize: já unitários. Em Python: import numpy as np; A=np.array([[1,0,0],[0,1,0],[0,0,2]]); eig=np.linalg.eig(A); null=np.linalg.null_space(A - 1*np.eye(3)).",
                              "finalVerifications": [
                                "Dimensão do núcleo g equals multiplicidade geométrica esperada",
                                "Todos autovetores satisfazem A v = λ v com erro < 1e-10",
                                "Conjunto {v1,...,vg} é linearmente independente (rank(V)=g)",
                                "Autovetores normalizados com norma euclidiana =1",
                                "Eigenspace span correto pelo menos dim g",
                                "Preparado para extensão a autovetores generalizados se g < m"
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de A - λI e rank/nulidade (90%+ acurácia numérica)",
                                "Correta geração de g autovetores independentes parametrizados",
                                "Verificação robusta de equações eigen e independência linear",
                                "Uso apropriado de software com validação manual",
                                "Tratamento de casos edge (e.g., g < m) identificado",
                                "Eficiência temporal e clareza na documentação dos vetores"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação com numpy.linalg.null_space e eig",
                                "Física: Modos de vibração em dinâmica de estruturas (frequências naturais)",
                                "Engenharia Mecânica: Análise modal de vigas e edifícios",
                                "Estatística: Componentes principais (PCA) via decomposição espectral"
                              ],
                              "realWorldApplication": "Na análise computacional de estruturas civis, como em métodos de elementos finitos (FEM), autovalores com multiplicidade representam frequências degeneradas em modos de vibração de edifícios; calcular autovetores independentes permite simular deformações modais múltiplas e otimizar design contra ressonância sísmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Propriedades dos Autovalores e Autovetores",
                    "description": "Propriedades como soma e produto dos autovalores, multiplicidade algébrica e geométrica, e ortogonalidade em matrizes simétricas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Soma e Produto dos Autovalores",
                        "description": "Propriedades fundamentais que relacionam a soma dos autovalores de uma matriz quadrada ao traço da matriz (soma dos elementos da diagonal principal) e o produto dos autovalores ao determinante da matriz, independentemente do cálculo explícito dos autovalores.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Calcular a soma dos autovalores usando o traço da matriz",
                            "description": "Dado uma matriz quadrada A, computar o traço tr(A) = ∑ a_ii e afirmar que este é igual à soma dos autovalores λ_i de A, aplicando em contextos como estabilidade de estruturas em engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Calcular o Traço de uma Matriz Quadrada",
                                  "subSteps": [
                                    "Defina o traço tr(A) como a soma dos elementos da diagonal principal de A.",
                                    "Identifique a diagonal principal em uma matriz quadrada exemplo, como A = [[2, 1], [3, 4]] onde tr(A) = 2 + 4 = 6.",
                                    "Calcule o traço para matrizes 2x2 e 3x3 fornecidas, anotando cada soma.",
                                    "Verifique a invariância do traço sob transposição: tr(A) = tr(A^T).",
                                    "Pratique com matrizes aleatórias geradas."
                                  ],
                                  "verification": "Forneça o traço correto para três matrizes de tamanhos variados sem erros de cálculo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Matrizes de exemplo impressas"
                                  ],
                                  "tips": "Sempre some apenas os elementos a_ii (i de 1 a n); ignore off-diagonais.",
                                  "learningObjective": "Dominar o cálculo preciso do traço como soma diagonal.",
                                  "commonMistakes": [
                                    "Somar todos os elementos da matriz",
                                    "Confundir com determinante",
                                    "Erros aritméticos em somas grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Autovalores e Seu Polinômio Característico",
                                  "subSteps": [
                                    "Lembre o autovalor λ satisfaz det(A - λI) = 0.",
                                    "Escreva o polinômio característico p(λ) = det(A - λI) = (-1)^n (λ^n - tr(A) λ^{n-1} + ... + (-1)^n det(A)).",
                                    "Identifique o coeficiente de λ^{n-1} como -tr(A), implicando soma λ_i = tr(A).",
                                    "Calcule autovalores para matrizes 2x2 simples.",
                                    "Some os autovalores e compare com tr(A)."
                                  ],
                                  "verification": "Derive o polinômio para uma 2x2 e confirme soma λ_i = tr(A).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha com fórmulas de álgebra linear",
                                    "Software simbólico como SymPy ou Mathematica"
                                  ],
                                  "tips": "Expanda det(A - λI) sistematicamente por cofatores da primeira linha.",
                                  "learningObjective": "Entender a relação algébrica entre traço e soma de raízes do polinômio.",
                                  "commonMistakes": [
                                    "Esquecer o sinal (-1)^n no polinômio",
                                    "Confundir soma com produto de autovalores",
                                    "Não considerar multiplicidades algébricas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar e Verificar a Igualdade tr(A) = Soma dos Autovalores",
                                  "subSteps": [
                                    "Prove usando o teorema de Vieta: soma raízes = -coeficiente de λ^{n-1} / leading coef.",
                                    "Verifique numericamente: encontre autovalores via software e some, comparando com tr(A).",
                                    "Teste com matriz diagonal (óbvio) e não-diagonalizável.",
                                    "Discuta multiplicidades: soma conta com repetições.",
                                    "Generalize para qualquer campo (ex: complexos)."
                                  ],
                                  "verification": "Prove para n=3 e verifique em duas matrizes com autovalores computados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Livro de álgebra linear (cap. autovalores)",
                                    "Python com NumPy para eigvals"
                                  ],
                                  "tips": "Use np.trace() e np.linalg.eigvals() para verificação rápida.",
                                  "learningObjective": "Estabelecer e validar a invariância tr(A) = ∑ λ_i.",
                                  "commonMistakes": [
                                    "Ignorar multiplicidades",
                                    "Confundir autovalores com autovetores",
                                    "Falhar em normalizar polinômio monico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Contexto de Estabilidade Estrutural em Engenharia Civil",
                                  "subSteps": [
                                    "Modele uma estrutura simples (ex: viga com matriz de rigidez K 2x2).",
                                    "Calcule tr(K) e autovalores (frequências quadradas).",
                                    "Interprete: soma λ_i indica rigidez total; valores negativos sinalizam instabilidade.",
                                    "Simule variação de parâmetros e observe impacto no traço.",
                                    "Relacione com análise modal em software como SAP2000."
                                  ],
                                  "verification": "Analise uma matriz de rigidez dada, confirmando soma λ_i = tr(K) e implicações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplo de matriz de rigidez de viga",
                                    "Software FEA básico ou Excel"
                                  ],
                                  "tips": "Em estruturas, autovalores zero ou negativos indicam modos rígidos/instáveis.",
                                  "learningObjective": "Aplicar propriedade em problemas reais de engenharia.",
                                  "commonMistakes": [
                                    "Não dimensionar unidades corretamente",
                                    "Interpretar traço como frequência direta",
                                    "Esquecer simetria da matriz de rigidez"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez de uma treliça 2D: K = [[100, -50], [-50, 100]] N/m. tr(K) = 200. Autovalores: 50 e 150, soma = 200. Isso confirma rigidez total de 200 N/m; o menor λ=50 indica modo mais flexível para monitoramento de vibrações.",
                              "finalVerifications": [
                                "Calcule tr(A) e ∑λ_i para matriz 3x3 arbitrária com precisão.",
                                "Explique prova via polinômio característico em 2 frases.",
                                "Identifique instabilidade se tr(K)<0 em matriz de rigidez.",
                                "Verifique numericamente com software para caso não-diagonal.",
                                "Discuta limitações (ex: autovalores complexos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de traço e autovalores (100% correto).",
                                "Compreensão conceitual da prova (explicação clara).",
                                "Aplicação correta em contexto engenharia (>80% acerto).",
                                "Identificação de erros comuns e correções.",
                                "Criatividade em extensões reais (ex: software).",
                                "Tempo de execução dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração em dinâmica estrutural.",
                                "Computação: Algoritmos QR para autovalores em solvers numéricos.",
                                "Matemática Aplicada: Teoria de controle (matrizes de estado).",
                                "Engenharia Mecânica: Análise de flambagem.",
                                "Estatística: Análise de componentes principais (PCA)."
                              ],
                              "realWorldApplication": "Na engenharia civil, ao analisar estabilidade de pontes ou edifícios via elementos finitos, o traço da matriz de rigidez global fornece a soma das frequências naturais quadradas, permitindo detecção rápida de modos instáveis sem computar todos os autovalores, otimizando projetos em software como ANSYS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Calcular o produto dos autovalores usando o determinante",
                            "description": "Para uma matriz quadrada A de ordem n, calcular det(A) e reconhecer que este é igual ao produto ∏ λ_i dos autovalores, útil para análise de volumes ou áreas em problemas de engenharia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a base teórica da propriedade det(A) = ∏ λ_i",
                                  "subSteps": [
                                    "Revise a definição de autovalores como raízes do polinômio característico p(λ) = det(A - λI) = 0",
                                    "Identifique que p(0) = det(A - 0·I) = det(A)",
                                    "Reconheça que, pelo teorema fundamental da álgebra, det(A) é o produto das raízes λ_i (considerando multiplicidades)",
                                    "Analise o caso de matrizes triangulares, onde det(A) é o produto dos elementos da diagonal, análogo aos autovalores nessa base",
                                    "Confirme com o teorema: para qualquer matriz diagonalizável, det(A) = ∏ λ_i"
                                  ],
                                  "verification": "Escreva uma explicação em 3-5 frases justificando por que det(A) = produto dos autovalores e cite o polinômio característico",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Folha de papel e calculadora",
                                    "Vídeo tutorial sobre polinômio característico"
                                  ],
                                  "tips": "Lembre-se: o sinal alternado no determinante não afeta o produto final das raízes",
                                  "learningObjective": "Dominar a fundamentação teórica que liga determinante ao produto dos autovalores",
                                  "commonMistakes": [
                                    "Confundir com a soma dos autovalores (traço da matriz)",
                                    "Ignorar multiplicidades algébricas dos autovalores",
                                    "Esquecer que vale para autovalores complexos também"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o determinante de uma matriz quadrada A",
                                  "subSteps": [
                                    "Identifique a ordem n da matriz A",
                                    "Aplique a fórmula de Leibniz para n≤3 ou expansão por cofatores para n maior",
                                    "Para 2x2: det(A) = ad - bc; para 3x3: use regra de Sarrus ou cofatores",
                                    "Verifique o cálculo com software como MATLAB ou Python (numpy.linalg.det)",
                                    "Registre o valor exato de det(A)"
                                  ],
                                  "verification": "Compare seu cálculo manual com o resultado de um software; deve coincidir em pelo menos 3 casas decimais",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz exemplo impressa",
                                    "Calculadora gráfica",
                                    "Python ou MATLAB com numpy"
                                  ],
                                  "tips": "Sempre verifique o sinal dos cofatores: (-1)^{i+j}",
                                  "learningObjective": "Executar com precisão o cálculo do determinante para matrizes de ordem até 3x3",
                                  "commonMistakes": [
                                    "Erro de sinal nos cofatores",
                                    "Confundir linhas com colunas na expansão",
                                    "Arredondamento prematuro em cálculos numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar os autovalores da matriz A",
                                  "subSteps": [
                                    "Construa a matriz A - λI e forme o polinômio característico det(A - λI)",
                                    "Resolva a equação polinomial para encontrar as raízes λ_i",
                                    "Para n=2 ou 3, resolva quadraticamente ou cubicamente; anote multiplicidades",
                                    "Use ferramentas numéricas (ex: numpy.linalg.eigvals) para validação",
                                    "Liste todos os autovalores: λ_1, λ_2, ..., λ_n"
                                  ],
                                  "verification": "Confirme que o produto manual ∏ λ_i coincide com det(A) calculado no passo anterior",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Solver de equações (Wolfram Alpha)",
                                    "Código Python para autovalores"
                                  ],
                                  "tips": "Para matrizes simétricas, autovalores são reais; normalize se necessário",
                                  "learningObjective": "Calcular autovalores e reconhecer suas multiplicidades corretamente",
                                  "commonMistakes": [
                                    "Erro na formação de A - λI (esquecer o sinal de λ)",
                                    "Perder raízes múltiplas",
                                    "Confundir autovalores com autovetores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e aplicar a propriedade em um exemplo prático",
                                  "subSteps": [
                                    "Calcule o produto ∏ λ_i dos autovalores encontrados",
                                    "Compare numericamente e simbolicamente com det(A)",
                                    "Analise o impacto: se det(A)=0, matriz singular (autovalor zero)",
                                    "Discuta implicações para volumes (det(A) como fator de escala)",
                                    "Documente o processo em um relatório curto"
                                  ],
                                  "verification": "Produza uma tabela comparando det(A) e ∏ λ_i com evidência de igualdade",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para tabela",
                                    "Matriz de exemplo específica"
                                  ],
                                  "tips": "Teste com matriz identidade: det=1, autovalores todos 1, produto=1",
                                  "learningObjective": "Aplicar e validar a propriedade em contextos concretos",
                                  "commonMistakes": [
                                    "Não considerar autovalores complexos conjugados",
                                    "Erro aritmético no produto",
                                    "Ignorar normalização de autovalores"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a matriz A = [[3, 1], [1, 3]] (típica em análise de estruturas): det(A) = 9 - 1 = 8. Polinômio característico: λ² - 6λ + 8 = 0 → λ=4, λ=2. Produto: 4*2=8, confirmando a propriedade. Em engenharia civil, modela rigidez de uma treliça 2D.",
                              "finalVerifications": [
                                "Calcule det(A) e ∏ λ_i para uma matriz 3x3 arbitrária e confirme igualdade exata",
                                "Explique verbalmente a prova via polinômio característico",
                                "Identifique corretamente quando det(A)=0 implica autovalor zero",
                                "Aplique em software e valide resultados manuais",
                                "Discuta um caso onde propriedade falha (nenhum, mas justifique universalidade)",
                                "Crie uma matriz com autovalores conhecidos e verifique det(A)"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de det(A) e autovalores (erro < 0.01%)",
                                "Compreensão teórica demonstrada em explicação clara",
                                "Correta consideração de multiplicidades e autovalores complexos",
                                "Eficiência no uso de ferramentas computacionais",
                                "Aplicação contextual em engenharia civil",
                                "Documentação completa com tabelas e justificativas"
                              ],
                              "crossCurricularConnections": [
                                "Física: Cálculo de determinantes em mecânica quântica para volumes de fase",
                                "Computação: Algoritmos QR para autovalores em simulações numéricas",
                                "Engenharia Mecânica: Análise de estabilidade em vibrações modais",
                                "Matemática Aplicada: Transformações lineares em otimização",
                                "Economia: Modelos input-output com matrizes de Leontief"
                              ],
                              "realWorldApplication": "Em engenharia civil, calcular det(A) via produto de autovalores acelera análises de deformações em estruturas (ex: pontes), onde |det(A)| representa fator de volume/distorsão sob carregamento, evitando computação full de autovalores em softwares como ANSYS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Aplicar soma e produto em problemas computacionais",
                            "description": "Resolver problemas numéricos onde se usa traço e determinante para inferir propriedades espectrais sem diagonalização completa, como em simulações de vibrações em estruturas civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de traço, determinante e propriedades espectrais",
                                  "subSteps": [
                                    "Defina traço de uma matriz como a soma dos elementos da diagonal principal e relacione-o à soma dos autovalores.",
                                    "Defina determinante como o produto dos autovalores e revise sua interpretação geométrica e algébrica.",
                                    "Estude teoremas chave: soma dos autovalores = traço(A), produto = det(A), para matrizes quadradas.",
                                    "Explore propriedades para matrizes simétricas, comuns em problemas de vibração (ortogonalidade dos autovetores).",
                                    "Pratique com matrizes 2x2 simples para verificar soma e produto manualmente."
                                  ],
                                  "verification": "Resolva 3 matrizes 2x2 e confirme que soma dos autovalores calculados equals traço e produto equals det.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de álgebra linear (ex: Strang), calculadora ou Python/NumPy para verificação.",
                                  "tips": "Use propriedades de invariância: traço e det não mudam sob similaridade.",
                                  "learningObjective": "Compreender matematicamente como traço e determinante capturam soma e produto dos autovalores.",
                                  "commonMistakes": "Confundir traço com norma ou determinante com inversa; esquecer que vale para autovalores complexos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar um problema de vibração em estruturas civis",
                                  "subSteps": [
                                    "Identifique equações de movimento: M ü + K u = 0, onde M é massa, K rigidez.",
                                    "Formule o problema generalizado de autovalores: K φ = λ M φ, ou padronize para A φ = λ φ com A = M^{-1/2} K M^{-1/2}.",
                                    "Monte matrizes M e K para um sistema simples (ex: viga com 2 DOFs).",
                                    "Extraia submatrizes relevantes para análise espectral sem diagonalização total.",
                                    "Discuta contexto civil: frequências naturais para evitar ressonância em pontes ou edifícios."
                                  ],
                                  "verification": "Escreva matrizes M e K para um sistema 2-DOF e verifique simetria positiva definida.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software como MATLAB/Python (SciPy), notas de dinâmica estrutural.",
                                  "tips": "Comece com sistemas pequenos (n=2-3) para insight intuitivo antes de grandes.",
                                  "learningObjective": "Modelar problemas reais de engenharia como problemas espectrais.",
                                  "commonMistakes": "Ignorar normalização de massa ou assumir M identidade prematuramente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar traço e determinante para inferir propriedades espectrais",
                                  "subSteps": [
                                    "Calcule traço(A) para estimar soma das frequências naturais (√λ_i).",
                                    "Calcule det(A) para produto das frequências ou λ_i.",
                                    "Inferir bounds: min λ ≤ traço/n ≤ max λ, ou use para validar simulações numéricas.",
                                    "Aplique em problema numérico: dado traço e det, estime espectro sem eig().",
                                    "Compare com diagonalização parcial ou aproximações (ex: Rayleigh quotient)."
                                  ],
                                  "verification": "Para matriz exemplo, compute soma/produto via traço/det e compare erro <5% com eig completa.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python/MATLAB com funções trace() e det(), planilha para cálculos manuais.",
                                  "tips": "Para grandes matrizes, use decomposição LD para det estável numericamente.",
                                  "learningObjective": "Usar invariantes espectrais para análise eficiente sem computação completa.",
                                  "commonMistakes": "Esquecer √ para frequências (ω=√λ); overflow em det para matrizes mal-condicionadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e estender para simulações computacionais reais",
                                  "subSteps": [
                                    "Implemente script para auto-extração de traço/det em modelo FEM simples.",
                                    "Teste sensibilidade: altere parâmetros (massa/rigidez) e observe mudanças em soma/produto.",
                                    "Integre em workflow: use para screening inicial antes de solver completo.",
                                    "Analise caso civil: edifício sujeito a vento, infira faixas de frequência crítica.",
                                    "Documente limitações: não dá autovetores, só propriedades globais."
                                  ],
                                  "verification": "Rode simulação em software, confirme inferências espectrais batem com resultados full.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "FEM software (ex: ANSYS free student, ou FEniCS Python), dados de estrutura real.",
                                  "tips": "Combine com power iteration para um λ dominante se necessário.",
                                  "learningObjective": "Aplicar técnica em pipeline computacional de engenharia.",
                                  "commonMistakes": "Generalizar soma/produto sem considerar multiplicidades algébricas."
                                }
                              ],
                              "practicalExample": "Considere uma viga de 2 DOFs com M = [[2,0],[0,1]] kg, K = [[3,-1],[-1,2]] kN/m. Traço(K M^{-1}) ≈ 2.5, det ≈ 2.0. Infira soma λ1+λ2=2.5, λ1 λ2=2.0 → λ ≈ 1.0 e 1.5 (frequências √λ ≈ 1.0 e 1.22 rad/s). Verifique sem eig: solucione char poly.",
                              "finalVerifications": [
                                "Soma inferida dos autovalores equals traço com precisão numérica.",
                                "Produto equals determinante, log-verificação para estabilidade.",
                                "Frequências estimadas batem com solver full em <1% erro.",
                                "Aplicação em modelo civil prevê faixa segura de excitação externa.",
                                "Script computacional roda sem crash para n=10 DOFs.",
                                "Documentação inclui limitações e extensões."
                              ],
                              "assessmentCriteria": [
                                "Precisão das inferências espectrais (erro <2%).",
                                "Correta modelagem de M/K para contexto civil.",
                                "Eficiência: tempo evitado vs diagonalização completa.",
                                "Validação cruzada com múltiplos métodos.",
                                "Clareza na explicação de propriedades usadas.",
                                "Criatividade em extensão para problemas reais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de vibrações e modos normais.",
                                "Computação: Métodos numéricos e análise matricial eficiente.",
                                "Matemática: Álgebra linear avançada e polinômios característicos.",
                                "Engenharia Mecânica: Análise modal em máquinas rotativas."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios altos, use traço/det para rápida estimativa de frequências naturais durante design inicial, evitando ressonância com ventos ou terremotos, otimizando tempo de simulação FEM sem computar todo espectro."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Multiplicidade Algébrica e Geométrica dos Autovalores",
                        "description": "A multiplicidade algébrica de um autovalor é a ordem da raiz correspondente no polinômio característico, enquanto a geométrica é a dimensão do autespaço associado; a matriz é diagonalizável se multiplicidades forem iguais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Determinar a multiplicidade algébrica de um autovalor",
                            "description": "Calcular o polinômio característico det(A - λI) = 0 e identificar a multiplicidade como a potência da fator (λ - λ_k) no polinômio, aplicando em matrizes de rigidez estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de multiplicidade algébrica de autovalores",
                                  "subSteps": [
                                    "Defina autovalor como solução de det(A - λI) = 0.",
                                    "Explique multiplicidade algébrica como a maior potência m tal que (λ - λ_k)^m divide o polinômio característico.",
                                    "Diferencie de multiplicidade geométrica (dimensão do autespaço).",
                                    "Discuta relevância em matrizes de rigidez para modos de vibração.",
                                    "Resuma com um diagrama conceitual."
                                  ],
                                  "verification": "Escreva uma definição precisa e um exemplo simples de polinômio (λ-2)^2(λ-3)=0 com multiplicidade 2 para λ=2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de álgebra linear",
                                    "Papel e caneta",
                                    "Acesso a Khan Academy ou vídeo introdutório"
                                  ],
                                  "tips": "Use analogia com raízes múltiplas em polinômios univariados para fixar o conceito.",
                                  "learningObjective": "Entender e articular a definição de multiplicidade algébrica no contexto de autovalores.",
                                  "commonMistakes": [
                                    "Confundir com multiplicidade geométrica",
                                    "Ignorar o polinômio completo e focar só em autovalores distintos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz A - λI e preparar cálculo do polinômio característico",
                                  "subSteps": [
                                    "Selecione uma matriz de rigidez estrutural A (ex: 2x2 ou 3x3).",
                                    "Forme a matriz simbólica A - λI substituindo diagonal por a_ii - λ.",
                                    "Verifique simetria e propriedades da matriz de rigidez (diagonal dominante).",
                                    "Escreva a expressão geral det(A - λI).",
                                    "Pratique com uma matriz 2x2 simples."
                                  ],
                                  "verification": "Construa A - λI para uma matriz exemplo e confirme visualmente os termos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Software como MATLAB ou Python (NumPy)",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Sempre anote λ como variável para evitar erros aritméticos iniciais.",
                                  "learningObjective": "Dominar a formação da matriz deslocada para cálculo do determinante.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo em -λI",
                                    "Confundir off-diagonal elements"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o polinômio característico det(A - λI)",
                                  "subSteps": [
                                    "Expanda o determinante usando cofatores ou regra de Sarrus para 3x3.",
                                    "Colete termos por potências de λ (λ^n, λ^{n-1}, ..., constante).",
                                    "Normalize para monico (coeficiente líder 1).",
                                    "Verifique cálculo com traço(A) = soma autovalores e det(A) = produto.",
                                    "Use software para validar resultado manual."
                                  ],
                                  "verification": "Obtenha polinômio correto e verifique propriedades básicas (grau = ordem da matriz).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software computacional (MATLAB eig ou sympy)",
                                    "Tabela de expansão de determinantes"
                                  ],
                                  "tips": "Para matrizes simétricas, espere polinômio real e autovalores reais.",
                                  "learningObjective": "Calcular precisamente o polinômio característico de matrizes pequenas.",
                                  "commonMistakes": [
                                    "Erros de sinal no determinante",
                                    "Não coletar termos corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Fatorar o polinômio e determinar a multiplicidade algébrica",
                                  "subSteps": [
                                    "Encontre raízes resolvendo det(A - λI)=0 numericamente ou exatamente.",
                                    "Fatore como produto (λ - λ_k)^{m_k} * outros fatores.",
                                    "Identifique m_k como expoente de (λ - λ_k).",
                                    "Confirme somando m_k = ordem da matriz.",
                                    "Aplique a uma matriz de rigidez real (ex: treliça simples)."
                                  ],
                                  "verification": "Escreva fatoração completa e liste multiplicidades para todos autovalores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Solver polinomial online ou Wolfram Alpha",
                                    "Exemplo de matriz de rigidez de beam ou truss"
                                  ],
                                  "tips": "Para multiplicidades >1, verifique se geométrica é menor ou igual.",
                                  "learningObjective": "Extrair multiplicidades algébricas da fatoração do polinômio.",
                                  "commonMistakes": [
                                    "Raízes aproximadas sem fatoração exata",
                                    "Contar expoente errado"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e verificar em contexto de engenharia civil",
                                  "subSteps": [
                                    "Monte matriz de rigidez K de uma estrutura simples (2 graus de liberdade).",
                                    "Calcule polinômio, encontre autovalores e multiplicidades.",
                                    "Interprete: multiplicidade indica degenerescência de modos.",
                                    "Compare com software FEA (ex: ANSYS).",
                                    "Documente relatório com passos."
                                  ],
                                  "verification": "Relatório com cálculo correto e interpretação física.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software FEA introdutório ou MATLAB Structural Toolbox",
                                    "Exemplos de livros de dinâmica estrutural"
                                  ],
                                  "tips": "Multiplicidades altas sinalizam simetrias na estrutura.",
                                  "learningObjective": "Aplicar conceito a problemas reais de rigidez estrutural.",
                                  "commonMistakes": [
                                    "Ignorar unidades ou contexto físico",
                                    "Matriz não positiva definida"
                                  ]
                                }
                              ],
                              "practicalExample": "Para matriz de rigidez de uma treliça 2D com 2 nós: K = [[2, -1], [-1, 1]], polinômio char = λ(λ-1), autovalores λ=0 (mult=1), λ=1 (mult=1). Se modificada para simétrica, pode ter mult=2 para λ=0 indicando mecanismo rígido.",
                              "finalVerifications": [
                                "Calcule corretamente polinômio para matriz 3x3 dada.",
                                "Identifique todas multiplicidades algébricas com fatoração.",
                                "Diferencie corretamente de multiplicidade geométrica em exemplo.",
                                "Aplique a matriz de rigidez e interprete resultados.",
                                "Valide com software e discuta discrepâncias.",
                                "Explique impacto em análise modal estrutural."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo do determinante (sem erros aritméticos).",
                                "Fatoração completa e identificação correta de expoentes.",
                                "Interpretação contextual em engenharia civil.",
                                "Uso adequado de ferramentas computacionais.",
                                "Clareza na documentação de passos.",
                                "Compreensão de propriedades (ex: soma multiplicidades = n)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos de vibração e frequências naturais em dinâmica estrutural.",
                                "Computação: Algoritmos numéricos QR para autovalores em software FEA.",
                                "Matemática: Teoria de polinômios e raízes múltiplas.",
                                "Engenharia Mecânica: Análise de estabilidade e buckling."
                              ],
                              "realWorldApplication": "Em engenharia civil, determinar multiplicidade algébrica de autovalores da matriz de rigidez permite identificar modos degenerados em estruturas (ex: pontes simétricas), otimizando análise modal para previsão de vibrações e prevenção de ressonância em edifícios altos ou viadutos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Determinar a multiplicidade geométrica via dimensão do autespaço",
                            "description": "Para um autovalor λ, resolver (A - λI)v = 0 e encontrar a dimensão do núcleo (número linearmente independentes de autovetores), comparando com a algébrica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o autovalor e sua multiplicidade algébrica",
                                  "subSteps": [
                                    "Revise o polinômio característico det(A - λI) = 0 para confirmar o autovalor λ.",
                                    "Determine a multiplicidade algébrica contando a repetição de λ como raiz.",
                                    "Anote a multiplicidade algébrica (m_a) para comparação posterior.",
                                    "Verifique se λ é autovalor usando traço ou produto dos autovalores se conhecido.",
                                    "Registre a matriz A original e λ em um local acessível."
                                  ],
                                  "verification": "Confirme que m_a está corretamente anotada e λ é raiz do polinômio.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A",
                                    "Papel e caneta ou software como MATLAB/Python"
                                  ],
                                  "tips": "Use fatoração para polinômios de baixa ordem; ferramentas computacionais aceleram para matrizes maiores.",
                                  "learningObjective": "Compreender a distinção inicial entre multiplicidades algébrica e geométrica.",
                                  "commonMistakes": [
                                    "Confundir multiplicidade algébrica com geométrica prematuramente",
                                    "Erro no cálculo do polinômio característico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz A - λI e preparar o sistema homogêneo",
                                  "subSteps": [
                                    "Subtraia λ da diagonal de A para formar B = A - λI.",
                                    "Escreva o sistema Bv = 0, onde v é o autovetor.",
                                    "Identifique as equações lineares resultantes.",
                                    "Verifique se B está correta multiplicando por um vetor teste simples.",
                                    "Organize o sistema em forma escalonada reduzida se possível manualmente."
                                  ],
                                  "verification": "Multiplique B por um vetor nulo conhecido (ex: [0,0,0]) para confirmar identidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Software de álgebra linear (ex: NumPy)"
                                  ],
                                  "tips": "Trabalhe com matrizes pequenas primeiro; use sympy para verificação simbólica.",
                                  "learningObjective": "Preparar o sistema para encontrar o núcleo de B.",
                                  "commonMistakes": [
                                    "Erro aritmético na subtração diagonal",
                                    "Esquecer de multiplicar por I"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o sistema (A - λI)v = 0 e encontrar base do autespaço",
                                  "subSteps": [
                                    "Aplique eliminação gaussiana na matriz aumentada [B | 0].",
                                    "Identifique variáveis livres e pivôs para parametrizar soluções.",
                                    "Escreva autovetores linearmente independentes como combinações das variáveis livres.",
                                    "Confirme linear independência testando se um é múltiplo do outro.",
                                    "Liste todos os autovetores independentes."
                                  ],
                                  "verification": "Verifique que cada autovetor satisfaz Bv = 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Python com NumPy/SciPy para null space"
                                  ],
                                  "tips": "Para matrizes maiores, use qr() ou svd() em software para base do núcleo.",
                                  "learningObjective": "Encontrar explicitamente o autespaço e seus geradores.",
                                  "commonMistakes": [
                                    "Não identificar todas variáveis livres",
                                    "Autovetores linearmente dependentes contados como independentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar a dimensão do autespaço e comparar multiplicidades",
                                  "subSteps": [
                                    "Conte o número de autovetores linearmente independentes (dimensão geométrica m_g).",
                                    "Compare m_g com m_a: m_g ≤ m_a sempre.",
                                    "Classifique: diagonalizável se m_g = m_a para todos λ.",
                                    "Registre m_g = dim(ker(A - λI)).",
                                    "Discuta implicações para diagonalização."
                                  ],
                                  "verification": "Confirme m_g ≤ m_a e teste diagonalização se aplicável.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de autovetores",
                                    "Software para rank(B)"
                                  ],
                                  "tips": "Dimensão do núcleo = n - rank(B), teorema da dimensão.",
                                  "learningObjective": "Calcular multiplicidade geométrica e interpretar geometricamente.",
                                  "commonMistakes": [
                                    "Confundir rank com nulidade",
                                    "Ignorar comparação m_g vs m_a"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[2,1,0],[0,2,0],[0,0,3]], λ=2 (m_a=2). B = [[0,1,0],[0,0,0],[0,0,1]]. Solução: v1 = [1,0,0]^T (apenas um independente), m_g=1 < 2, não diagonalizável.",
                              "finalVerifications": [
                                "Dimensão do autespaço calculada corretamente como número de variáveis livres.",
                                "Todos autovetores verificados em (A - λI)v = 0.",
                                "Comparação precisa entre m_g e m_a.",
                                "Base do autespaço listada e linearmente independente.",
                                "Implicações para diagonalização corretamente identificadas.",
                                "Rank(B) + nulidade(B) = n confirmado."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de B = A - λI (sem erros aritméticos).",
                                "Correta identificação de variáveis livres e base do núcleo.",
                                "Exatidão na contagem de m_g e comparação com m_a.",
                                "Verificação explícita de autovetores no sistema original.",
                                "Interpretação correta das multiplicidades (m_g ≤ m_a).",
                                "Uso eficiente de ferramentas computacionais quando aplicável."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos de vibração em estruturas (autovalores de rigidez/massa).",
                                "Programação: Implementação de eig() em Python/MATLAB para engenharia.",
                                "Estatística: Análise de componentes principais (PCA via autovalores).",
                                "Engenharia de Controle: Estabilidade de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em análise estrutural civil, determina se uma estrutura é diagonalizável para modos normais de vibração, essencial para simulações computacionais de terremotos e otimização de projetos de pontes/edifícios."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Verificar diagonalizabilidade da matriz",
                            "description": "Comparar multiplicidades algébrica e geométrica para todos autovalores e concluir se a matriz é diagonalizável, relevante para métodos numéricos em análise modal de edifícios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Determinar autovalores e multiplicidades algébricas",
                                  "subSteps": [
                                    "Calcule o polinômio característico det(A - λI) = 0.",
                                    "Resolva a equação polinomial para encontrar todos os autovalores distintos.",
                                    "Para cada autovalor λ_i, determine a multiplicidade algébrica como a multiplicidade da raiz λ_i no polinômio.",
                                    "Registre os pares (λ_i, m_a_i) onde m_a_i é a multiplicidade algébrica.",
                                    "Verifique se a soma das multiplicidades algébricas equals a dimensão da matriz."
                                  ],
                                  "verification": "Confirme que os autovalores e multiplicidades algébricas estão corretos comparando com cálculo manual ou software.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matriz A de exemplo",
                                    "Papel e calculadora",
                                    "Software como MATLAB ou Python (NumPy/SciPy)"
                                  ],
                                  "tips": "Fatore o polinômio completamente; use divisão sintética para raízes racionais.",
                                  "learningObjective": "Identificar corretamente autovalores e suas multiplicidades algébricas a partir do polinômio característico.",
                                  "commonMistakes": [
                                    "Confundir multiplicidade algébrica com geométrica prematuramente",
                                    "Erros em cálculos de determinante",
                                    "Esquecer autovalores complexos em matrizes reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular multiplicidades geométricas para cada autovalor",
                                  "subSteps": [
                                    "Para cada autovalor λ_i, construa a matriz B_i = A - λ_i I.",
                                    "Resolva o sistema homogêneo B_i v = 0 para encontrar a base do núcleo.",
                                    "Calcule a dimensão do núcleo de B_i, que é a multiplicidade geométrica m_g_i.",
                                    "Repita para todos autovalores distintos.",
                                    "Anote os pares (λ_i, m_g_i)."
                                  ],
                                  "verification": "Verifique a independência linear dos autovetores encontrados e confirme dim(ker(B_i)) = m_g_i.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Matriz A e autovalores do Step 1",
                                    "Calculadora matricial",
                                    "Software para row reduction (e.g., SymPy)"
                                  ],
                                  "tips": "Use eliminação gaussiana para encontrar o núcleo; normalize autovetores se necessário.",
                                  "learningObjective": "Computar com precisão a dimensão do eigenspace para cada autovalor.",
                                  "commonMistakes": [
                                    "Erro na subtração de λI",
                                    "Contar vetores linearmente dependentes como independentes",
                                    "Esquecer autovalores repetidos requerem verificação separada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar multiplicidades e concluir diagonalizabilidade",
                                  "subSteps": [
                                    "Para cada λ_i, compare m_g_i com m_a_i: verifique se m_g_i = m_a_i.",
                                    "Se m_g_i = m_a_i para TODOS os autovalores, conclua que a matriz É diagonalizável.",
                                    "Caso contrário (algum m_g_i < m_a_i), conclua que NÃO é diagonalizável.",
                                    "Justifique a conclusão com os valores numéricos.",
                                    "Opcional: tente construir a base de autovetores se diagonalizável."
                                  ],
                                  "verification": "A conclusão deve ser consistente com o teorema: diagonalizável iff m_g(λ) = m_a(λ) ∀λ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de multiplicidades do Steps 1 e 2"
                                  ],
                                  "tips": "Lembre: m_g ≤ m_a sempre; igualdade é a chave para diagonalizabilidade.",
                                  "learningObjective": "Aplicar o critério de diagonalizabilidade corretamente e justificar a conclusão.",
                                  "commonMistakes": [
                                    "Achar diagonalizável se apenas alguns λ satisfazem",
                                    "Confundir ordem das multiplicidades",
                                    "Ignorar autovalores com m_a=1 (sempre m_g=1)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz A = [[2, 1, 0], [0, 2, 0], [0, 0, 3]]. Polinômio característico: (λ-2)^2 (λ-3)=0. Autovalores: λ=2 (m_a=2), λ=3 (m_a=1). Para λ=2, ker(A-2I) tem dim=1 (m_g=1 <2). Para λ=3, m_g=1. Conclusão: NÃO diagonalizável.",
                              "finalVerifications": [
                                "Autovalores e m_a calculados corretamente.",
                                "m_g computada via dim(ker(A-λI)) para cada λ.",
                                "Comparação m_g == m_a para todos λ realizada.",
                                "Conclusão explícita e justificada.",
                                "Exemplo prático resolvido sem erros aritméticos.",
                                "Base de autovetores verificada se aplicável."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de polinômio característico (100%).",
                                "Correta determinação de dimensões de eigenspaces (90%).",
                                "Aplicação correta do teorema de diagonalizabilidade (100%).",
                                "Justificativa clara e lógica da conclusão.",
                                "Tratamento de autovalores múltiplos sem falhas.",
                                "Eficiência no uso de métodos computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise modal em vibrações (modos normais requerem diagonalização).",
                                "Computação: Algoritmos QR para eigensolvers numéricos.",
                                "Matemática Aplicada: Estabilidade em sistemas dinâmicos lineares.",
                                "Engenharia Mecânica: Simulações de estruturas via decomposição modal."
                              ],
                              "realWorldApplication": "Em análise modal de edifícios na Engenharia Civil, verifica-se se as matrizes de massa e rigidez são diagonalizáveis para decoupling das equações de movimento, permitindo calcular frequências e modos de vibração eficientemente em softwares como SAP2000 ou ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Ortogonalidade de Autovetores em Matrizes Simétricas",
                        "description": "Matrizes simétricas reais possuem autovalores reais e autovetores ortogonais para autovalores distintos, permitindo decomposição espectral ortogonal útil em otimização e análise de tensões.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Verificar se uma matriz é simétrica e identificar autovalores reais",
                            "description": "Confirmar A = A^T e, ao resolver o problema de autovalores, verificar que todos λ_i são reais, aplicando em matrizes de covariância ou rigidez simétricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar se a matriz é simétrica comparando com sua transposta",
                                  "subSteps": [
                                    "Obtenha a matriz A e compute sua transposta A^T manualmente ou usando software.",
                                    "Compare elemento por elemento: para todo i,j, verifique se A[i,j] = A[j,i].",
                                    "Registre qualquer discrepância encontrada.",
                                    "Confirme que A = A^T para todos os elementos.",
                                    "Documente o resultado em um relatório simples."
                                  ],
                                  "verification": "A matriz A é igual à sua transposta A^T em todos os elementos.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Matriz de exemplo (papel ou software como MATLAB/Python)",
                                    "Calculadora ou computador com NumPy/SciPy"
                                  ],
                                  "tips": "Comece comparando a diagonal principal (sempre simétrica) e foque nos elementos off-diagonal.",
                                  "learningObjective": "Dominar a definição e verificação prática de simetria em matrizes.",
                                  "commonMistakes": [
                                    "Confundir transposta com inversa",
                                    "Ignorar elementos zero ou negativos",
                                    "Erros de arredondamento em cálculos numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o problema de autovalores para matriz simétrica",
                                  "subSteps": [
                                    "Reescreva o problema como det(A - λI) = 0 para encontrar as raízes λ.",
                                    "Para matrizes 2x2 ou 3x3, resolva analiticamente o polinômio característico.",
                                    "Use métodos numéricos (ex: qr_algorithm em software) para matrizes maiores.",
                                    "Extraia todos os autovalores λ_i da solução.",
                                    "Armazene os valores em uma lista ou vetor para análise posterior."
                                  ],
                                  "verification": "Polinômio característico resolvido e lista de autovalores obtida.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Software de álgebra linear (MATLAB, Python com NumPy/Eigen)",
                                    "Papel e lápis para casos pequenos"
                                  ],
                                  "tips": "Para simétricas reais, teorema espectral garante autovalores reais; use isso como lembrete.",
                                  "learningObjective": "Aplicar o método de autovalores a matrizes simétricas de forma eficiente.",
                                  "commonMistakes": [
                                    "Esquecer de subtrair λI",
                                    "Erros no cálculo do determinante",
                                    "Confundir autovalores com autovetores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar se todos os autovalores são reais",
                                  "subSteps": [
                                    "Examine cada λ_i: confirme se é um número real (parte imaginária = 0).",
                                    "Para métodos numéricos, verifique tolerância de precisão (ex: Im(λ) < 1e-10).",
                                    "Compare com propriedades teóricas: matriz simétrica real implica λ reais.",
                                    "Se algum λ complexo, investigue se a simetria foi violada.",
                                    "Registre confirmação: 'Todos autovalores reais: Sim/Não'."
                                  ],
                                  "verification": "Todos λ_i têm parte imaginária zero dentro de tolerância numérica.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Resultados do Step 2",
                                    "Ferramentas de plotagem para visualizar espectro (opcional)"
                                  ],
                                  "tips": "Use funções built-in como eig() em MATLAB, que retorna reais para simétricas.",
                                  "learningObjective": "Reconhecer e validar a propriedade espectral de matrizes simétricas.",
                                  "commonMistakes": [
                                    "Aceitar pequenas imag part como zero sem tolerância",
                                    "Não verificar simetria antes",
                                    "Ignorar multiplicidades algébricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados no contexto de engenharia civil",
                                  "subSteps": [
                                    "Aplique a matriz exemplo (ex: rigidez) e discuta autovalores como frequências naturais.",
                                    "Verifique ortogonalidade de autovetores se relevante.",
                                    "Simule um cenário: 'Matriz de covariância em análise modal'.",
                                    "Conclua implicações: estabilidade estrutural se λ > 0.",
                                    "Gere um relatório final com gráficos de autovalores."
                                  ],
                                  "verification": "Relatório interpretativo completo com contexto aplicado.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Exemplo de matriz de rigidez/covariância",
                                    "Software de visualização (MATLAB plot)"
                                  ],
                                  "tips": "Ligue autovalores a modos de vibração para intuição física.",
                                  "learningObjective": "Conectar teoria de autovalores a aplicações práticas em engenharia.",
                                  "commonMistakes": [
                                    "Não contextualizar numericamente",
                                    "Ignorar sinais dos autovalores",
                                    "Sobrepor interpretação sem verificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez simétrica K = [[2, -1, 0], [-1, 2, -1], [0, -1, 1]] em uma estrutura de barras. Verifique K = K^T (sim), compute autovalores ≈ [0.5858, 1, 3.4142] todos reais, indicando modos de vibração estáveis.",
                              "finalVerifications": [
                                "Matriz A satisfaz A = A^T elemento por elemento.",
                                "Todos autovalores λ_i são reais (Im(λ_i) = 0).",
                                "Polinômio característico resolvido corretamente.",
                                "Autovalores interpretados no contexto (ex: rigidez positiva).",
                                "Relatório documenta passos e resultados.",
                                "Nenhuma discrepância numérica acima de tolerância."
                              ],
                              "assessmentCriteria": [
                                "Precisão na verificação de simetria (100% elementos corretos).",
                                "Correção no cálculo de autovalores (erro < 1e-6).",
                                "Validação explícita de realidade dos autovalores.",
                                "Interpretação contextual relevante para engenharia civil.",
                                "Relatório claro com verificações e gráficos.",
                                "Eficiência temporal e avoidance de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração em estruturas dinâmicas.",
                                "Estatística: Análise de componentes principais (PCA) com matrizes de covariância simétricas.",
                                "Computação: Algoritmos numéricos para decomposição espectral (QR, Lanczos).",
                                "Matemática Aplicada: Teorema espectral e ortogonalidade de autovetores."
                              ],
                              "realWorldApplication": "Em engenharia civil, verifica-se simetria e autovalores reais em matrizes de rigidez para análise modal de edifícios, garantindo estabilidade contra terremotos e predizendo frequências de ressonância para design seguro."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Demonstrar ortogonalidade entre autovetores distintos",
                            "description": "Para autovetores v_i e v_j com λ_i ≠ λ_j, mostrar que v_i^T v_j = 0 usando propriedades de simetria, computando numericamente em software como MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar propriedades fundamentais de matrizes simétricas e autovetores",
                                  "subSteps": [
                                    "Defina matriz simétrica: uma matriz A tal que A = A^T.",
                                    "Liste propriedades chave: autovalores reais, autovetores ortogonais para autovalores distintos, base ortonormal possível.",
                                    "Estabeleça notação: Av_i = λ_i v_i para autovetor v_i e autovalor λ_i.",
                                    "Explique por que a simetria garante autovalores reais.",
                                    "Diferencie de matrizes não simétricas, onde autovetores podem não ser ortogonais."
                                  ],
                                  "verification": "Escreva um resumo de 5 bullets com as propriedades principais e explique para um colega.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Livro de álgebra linear (ex: Strang)",
                                    "Folha de anotações",
                                    "Calculadora"
                                  ],
                                  "tips": "Use diagramas para visualizar autovetores em R^2.",
                                  "learningObjective": "Compreender as bases teóricas que sustentam a ortogonalidade em matrizes simétricas.",
                                  "commonMistakes": [
                                    "Assumir ortogonalidade sem simetria",
                                    "Confundir autovalores complexos com reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a prova analítica da ortogonalidade",
                                  "subSteps": [
                                    "Comece com v_i^T A v_j = v_i^T (λ_j v_j) = λ_j (v_i^T v_j).",
                                    "Use simetria: v_i^T A v_j = (A v_i)^T v_j = (λ_i v_i)^T v_j = λ_i (v_i^T v_j).",
                                    "Iguale as expressões: λ_j (v_i^T v_j) = λ_i (v_i^T v_j).",
                                    "Reorganize: (λ_i - λ_j) (v_i^T v_j) = 0.",
                                    "Conclua: como λ_i ≠ λ_j, então v_i^T v_j = 0."
                                  ],
                                  "verification": "Escreva a prova completa em papel, passo a passo, sem erros algébricos.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de matriz simétrica 2x2"
                                  ],
                                  "tips": "Anote cada transposição explicitamente para evitar confusão.",
                                  "learningObjective": "Dominar a derivação exata da ortogonalidade usando propriedades de simetria.",
                                  "commonMistakes": [
                                    "Esquecer a transposição em v_i^T A v_j",
                                    "Não especificar λ_i ≠ λ_j"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar exemplo numérico manualmente",
                                  "subSteps": [
                                    "Escolha matriz A = [[2, 1], [1, 2]]: verifique A = A^T.",
                                    "Calcule autovalores: det(A - λI) = 0 → λ1=3, λ2=1.",
                                    "Encontre autovetores: para λ1=3, v1=[1,1]^T; para λ2=1, v2=[1,-1]^T.",
                                    "Compute v1^T v2 = [1,1] [1,-1]^T = 1*1 + 1*(-1) = 0.",
                                    "Normalise se necessário e confirme ortogonalidade."
                                  ],
                                  "verification": "Mostre cálculos completos com produto escalar exatamente zero.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Matriz exemplo impressa"
                                  ],
                                  "tips": "Sempre normalize autovetores para ||v||=1 se comparando normas.",
                                  "learningObjective": "Aplicar a teoria em um exemplo concreto para validar a prova.",
                                  "commonMistakes": [
                                    "Erro em cálculo de autovalores",
                                    "Não verificar simetria da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e verificar numericamente em MATLAB",
                                  "subSteps": [
                                    "Abra MATLAB e defina A = [2 1; 1 2].",
                                    "Execute [V, D] = eig(A) para obter autovetores V e autovalores D.",
                                    "Extraia v1 = V(:,1), v2 = V(:,2); compute v1' * v2.",
                                    "Confirme resultado próximo a zero (tolerância numérica ~1e-15).",
                                    "Teste com matriz 3x3 maior para generalizar, ex: A = [4 1 0; 1 3 1; 0 1 2]."
                                  ],
                                  "verification": "Execute o código e capture screenshot do output mostrando v_i^T v_j ≈ 0.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "MATLAB ou Octave",
                                    "Script .m pronto"
                                  ],
                                  "tips": "Use format long para precisão; normalize com v1 = v1 / norm(v1).",
                                  "learningObjective": "Integrar computação numérica para validar teoria em cenários reais.",
                                  "commonMistakes": [
                                    "Índices errados em V(:,i)",
                                    "Ignorar erros de precisão flutuante"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez simétrica em uma estrutura 2D: A = [[2,1],[1,2]]. Seus autovetores v1=[0.707,0.707]^T (λ=3) e v2=[0.707,-0.707]^T (λ=1) satisfazem v1^T v2 = 0, demonstrando ortogonalidade usada em análise modal.",
                              "finalVerifications": [
                                "Prova analítica escrita corretamente sem lacunas.",
                                "Exemplo manual computado com v_i^T v_j = 0 exato.",
                                "Código MATLAB executado com output numérico ≈0 para dois exemplos.",
                                "Explicação verbal da importância da simetria.",
                                "Identificação correta de pelo menos um erro comum evitado.",
                                "Generalização para matrizes maiores confirmada."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na prova (100% dos passos corretos).",
                                "Correção do código MATLAB (roda sem erros, resultados precisos).",
                                "Profundidade dos substeps (todos detalhados e acionáveis).",
                                "Interpretação dos resultados numéricos vs. teóricos.",
                                "Conexão clara com contexto de engenharia civil.",
                                "Tempo respeitado e verificações autônomas."
                              ],
                              "crossCurricularConnections": [
                                "Programação numérica: Uso de eig() em MATLAB/Python para análise de dados.",
                                "Física: Modos normais de vibração em estruturas (ortogonalidade de funções modais).",
                                "Engenharia Mecânica: Análise de estabilidade e buckling.",
                                "Estatística: Análise de componentes principais (PCA) com matrizes de covariância simétricas.",
                                "Computação Científica: Decomposição espectral em simulações FEM."
                              ],
                              "realWorldApplication": "Na engenharia civil, matrizes de rigidez simétricas em elementos finitos (FEM) têm autovetores ortogonais representando modos de vibração independentes, permitindo superposição linear para prever respostas dinâmicas de pontes e edifícios sob sismos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Construir base ortonormal de autovetores",
                            "description": "Normalizar autovetores ortogonais de matriz simétrica para obter base ortonormal, aplicando em decomposição SVD aproximada para problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular autovalores e autovetores de matriz simétrica",
                                  "subSteps": [
                                    "Identifique a matriz simétrica A do problema de engenharia civil (ex.: matriz de rigidez).",
                                    "Resolva a equação característica det(A - λI) = 0 para encontrar autovalores λ.",
                                    "Para cada λ, resolva (A - λI)v = 0 para obter autovetores v associados.",
                                    "Armazene pares (λ_i, v_i) em ordem decrescente de λ.",
                                    "Confirme simetria de A (A = A^T)."
                                  ],
                                  "verification": "Autovetores satisfazem A v_i = λ_i v_i para cada i.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora científica ou software como MATLAB/Python (NumPy)",
                                    "Papel e lápis para matrizes pequenas",
                                    "Documentação da matriz do problema"
                                  ],
                                  "tips": "Use decomposição QR iterativa para matrizes grandes em software.",
                                  "learningObjective": "Dominar cálculo de autovalores/autovetores para matrizes simétricas reais.",
                                  "commonMistakes": "Esquecer de verificar simetria; normalizar prematuramente autovetores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar ortogonalidade dos autovetores",
                                  "subSteps": [
                                    "Calcule o produto escalar v_i · v_j para i ≠ j.",
                                    "Confirme que v_i · v_j = 0 para todos os pares ortogonais.",
                                    "Se não ortogonais (devido a erros numéricos), aplique processo de Gram-Schmidt.",
                                    "Documente os produtos escalares em uma tabela.",
                                    "Verifique linear independência (determinante da matriz de vetores ≠ 0)."
                                  ],
                                  "verification": "Todos produtos escalares entre autovetores distintos são aproximadamente zero (tolerância 10^-6).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software NumPy ou MATLAB para produtos escalares",
                                    "Planilha Excel para verificação manual"
                                  ],
                                  "tips": "Use tolerância numérica em computação para erros de arredondamento.",
                                  "learningObjective": "Compreender e validar propriedade de ortogonalidade em matrizes simétricas.",
                                  "commonMistakes": "Ignorar erros numéricos pequenos como não-zero; confundir com normalização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Normalizar cada autovetor para unidade",
                                  "subSteps": [
                                    "Para cada v_i, calcule a norma euclidiana ||v_i|| = sqrt(v_i · v_i).",
                                    "Divida v_i por sua norma: u_i = v_i / ||v_i||.",
                                    "Repita para todos autovetores.",
                                    "Verifique ||u_i|| = 1 para cada i.",
                                    "Arredonde componentes para precisão numérica consistente."
                                  ],
                                  "verification": "Norma de cada u_i é exatamente 1 (ou 1 ± 10^-10).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função norm() em NumPy/MATLAB",
                                    "Calculadora para casos 2D/3D"
                                  ],
                                  "tips": "Escolha sinal do autovetor consistentemente (ex.: primeiro componente positivo).",
                                  "learningObjective": "Aplicar normalização para obter vetores unitários ortogonais.",
                                  "commonMistakes": "Dividir pela norma errada; esquecer de normalizar todos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir matriz da base ortonormal Q",
                                  "subSteps": [
                                    "Forme matriz Q com colunas u_1, u_2, ..., u_n.",
                                    "Ordene colunas por autovalores decrescentes.",
                                    "Calcule Q^T Q e verifique identidade.",
                                    "Calcule Q Q^T para confirmar também identidade.",
                                    "Aplique em SVD aproximada: A ≈ Q Λ Q^T, onde Λ é diagonal."
                                  ],
                                  "verification": "Q^T Q = I e Q Q^T = I (matriz identidade).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software para multiplicação matricial (NumPy.linalg)",
                                    "Matriz de teste impressa"
                                  ],
                                  "tips": "Use ordem decrescente para modos dominantes em engenharia.",
                                  "learningObjective": "Montar e validar base ortonormal para diagonalização.",
                                  "commonMistakes": "Colunas erradas; inverter Q e Q^T na verificação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em decomposição SVD aproximada para engenharia civil",
                                  "subSteps": [
                                    "Aproxime A ≈ sum_{k=1}^m σ_k u_k v_k^T, mas para simétrica use Q.",
                                    "Selecione m primeiros modos para redução dimensional.",
                                    "Simule resposta (ex.: vibrações) com base reduzida.",
                                    "Compare erro de aproximação ||A - Q_m Λ_m Q_m^T||.",
                                    "Documente aplicação em problema real."
                                  ],
                                  "verification": "Erro de reconstrução < 5% para m modos selecionados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para SVD",
                                    "Dados de estrutura civil (ex.: treliça)"
                                  ],
                                  "tips": "Comece com m=2 para visualização em problemas 2D.",
                                  "learningObjective": "Integrar base ortonormal em soluções computacionais práticas.",
                                  "commonMistakes": "Usar todos modos desnecessariamente; ignorar truncamento para SVD."
                                }
                              ],
                              "practicalExample": "Para matriz de rigidez A = [[2,1],[1,2]] de uma treliça simples: autovalores λ=3,1; autovetores v1=[1,1], v2=[1,-1]. Normalize: u1=[1/sqrt(2),1/sqrt(2)], u2=[1/sqrt(2),-1/sqrt(2)]. Q = [[1/sqrt(2),1/sqrt(2)],[1/sqrt(2),-1/sqrt(2)]]. SVD approx com 1 modo: erro baixo para análise modal básica.",
                              "finalVerifications": [
                                "Q^T Q = I (ortonormalidade por colunas)",
                                "Q Q^T = I (ortonormalidade por linhas)",
                                "A Q = Q Λ (diagonalização verificada)",
                                "Normas unitárias de todas colunas de Q",
                                "Produtos escalares nulos entre colunas distintas",
                                "Erro SVD approx < tolerância especificada"
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de autovalores/autovetores (erro < 10^-6)",
                                "Correta normalização (norma =1 para todos vetores)",
                                "Verificação completa de ortogonalidade",
                                "Construção correta da matriz Q",
                                "Aplicação válida em SVD para engenharia civil",
                                "Documentação clara de passos e resultados"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Diagonalização e propriedades espectrais",
                                "Análise Numérica: Algoritmos QR e Gram-Schmidt",
                                "Engenharia Estrutural: Análise modal de vibrações",
                                "Programação Computacional: Implementação em Python/NumPy",
                                "Física: Modos normais em sistemas mecânicos"
                              ],
                              "realWorldApplication": "Em engenharia civil, bases ortonormais de autovetores da matriz de massa/rigidez definem modos de vibração de pontes ou edifícios, permitindo simulações eficientes de resposta sísmica via SVD truncada para redução de modelo em software como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Métodos Numéricos para Autovalores",
                    "description": "Técnicas computacionais como método da potência e algoritmo QR para cálculo aproximado de autovalores e autovetores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Método da Potência",
                        "description": "Técnica iterativa para aproximar o autovalor dominante (de maior módulo) e seu autovetor correspondente de uma matriz quadrada, utilizando multiplicações sucessivas por vetores iniciais e normalização.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Compreender o princípio iterativo do método da potência",
                            "description": "Explicar o processo de iteração que consiste em multiplicar um vetor inicial pela matriz, normalizá-lo e observar a convergência do fator de escala para o autovalor dominante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes fundamentais do Método da Potência",
                                  "subSteps": [
                                    "Selecionar uma matriz quadrada A com autovalor dominante |λ₁| > |λᵢ| para todo i ≠ 1.",
                                    "Escolher um vetor inicial x₀ não nulo e preferencialmente com componentes aleatórias.",
                                    "Definir o critério de parada, como tolerância ε = 10⁻⁶ para convergência dos fatores de escala.",
                                    "Explicar o papel da dominância do autovalor para garantir convergência.",
                                    "Verificar se a matriz satisfaz as condições do teorema de convergência."
                                  ],
                                  "verification": "Liste os componentes escolhidos e justifique por que a matriz tem autovalor dominante.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou software como Python/NumPy",
                                    "Matriz de exemplo 2x2 ou 3x3"
                                  ],
                                  "tips": "Comece com matrizes pequenas para visualização fácil da dominância.",
                                  "learningObjective": "Compreender os pré-requisitos matemáticos para aplicação do método.",
                                  "commonMistakes": [
                                    "Escolher vetor inicial nulo",
                                    "Ignorar a condição de dominância do autovalor",
                                    "Não definir tolerância clara"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a iteração básica: multiplicação e normalização",
                                  "subSteps": [
                                    "Computar o vetor intermediário yₖ = A × x_{k-1}.",
                                    "Calcular a norma euclidiana ||yₖ|| = √(∑ yₖⱼ²).",
                                    "Normalizar o vetor xₖ = yₖ / ||yₖ|| para obter vetor unitário.",
                                    "Registrar o fator de escala μₖ = ||yₖ||, que aproxima λ₁.",
                                    "Verificar se xₖ está unitário (||xₖ|| ≈ 1)."
                                  ],
                                  "verification": "Mostre os cálculos de y₁, x₁ e μ₁ para o vetor inicial e confirme normalização.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Planilha Excel ou Python (NumPy)",
                                    "Matriz e vetor impressos"
                                  ],
                                  "tips": "Use norma euclidiana para simplicidade; evite divisão por zero checando yₖ ≠ 0.",
                                  "learningObjective": "Dominar o cálculo de uma única iteração do processo iterativo.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar após multiplicação",
                                    "Usar norma errada (ex: norma 1 em vez de 2)",
                                    "Confundir μₖ com componente do vetor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar múltiplas iterações e monitorar os fatores de escala",
                                  "subSteps": [
                                    "Repetir o processo de iteração para k = 2, 3, ..., até N iterações ou convergência.",
                                    "Registrar a sequência de fatores μ₁, μ₂, ..., μₖ em uma tabela.",
                                    "Plotar ou tabular μₖ vs. k para visualizar a convergência.",
                                    "Comparar μₖ com μ_{k-1} e parar se |μₖ - μ_{k-1}| < ε.",
                                    "Observar como xₖ converge para a autofunção dominante."
                                  ],
                                  "verification": "Apresente tabela com pelo menos 5 iterações e mostre |μₖ - μ_{k-1}| decrescendo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem (Matplotlib ou Excel)",
                                    "Caderno para tabela",
                                    "Computador"
                                  ],
                                  "tips": "Inicie com 10 iterações fixas para observar padrão antes de critério adaptativo.",
                                  "learningObjective": "Observar empiricamente a convergência iterativa do método.",
                                  "commonMistakes": [
                                    "Parar prematuramente sem checar tolerância",
                                    "Não registrar μₖ corretamente",
                                    "Confundir convergência de μ com x"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a convergência e validar o autovalor dominante",
                                  "subSteps": [
                                    "Identificar λ₁ ≈ μₖ final (limite de μₖ quando k → ∞).",
                                    "Verificar se A × xₖ ≈ λ₁ × xₖ para o vetor final.",
                                    "Discutir taxa de convergência proporcional a |λ₂/λ₁|.",
                                    "Explicar por que o processo amplifica o componente dominante.",
                                    "Comparar com autovalor exato (se conhecido) para validação."
                                  ],
                                  "verification": "Confirme que ||A xₖ - μₖ xₖ|| < ε e explique o princípio iterativo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software numérico",
                                    "Matriz original",
                                    "Resultados das iterações"
                                  ],
                                  "tips": "Sempre normalize para evitar overflow numérico em matrizes grandes.",
                                  "learningObjective": "Explicar teoricamente o princípio iterativo e sua convergência.",
                                  "commonMistakes": [
                                    "Atribuir μₖ como autovetor",
                                    "Ignorar verificação residual",
                                    "Não relacionar com dominância"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz A = [[3, 1], [1, 3]] (autovalores exatos: 4 e 2, dominante λ₁=4). Vetor inicial x₀ = [1, 0]ᵀ. Iteração 1: y₁ = A x₀ = [3,1]ᵀ, ||y₁||≈3.162, x₁=[0.949,0.316]ᵀ, μ₁=3.162. Iteração 2: y₂≈[3.780,2.537]ᵀ, ||y₂||≈4.548? (continuar até μₖ→4 e xₖ→[0.707,0.707]ᵀ).",
                              "finalVerifications": [
                                "Explicar em palavras o ciclo: multiplicar → normalizar → fator de escala.",
                                "Demonstrar convergência numérica em exemplo com pelo menos 5 iterações.",
                                "Verificar residual ||A xₖ - μₖ xₖ|| < 10⁻⁴.",
                                "Identificar corretamente λ₁ como limite de μₖ.",
                                "Descrever condição de dominância necessária.",
                                "Aplicar a um exemplo em análise estrutural simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos iterativos (30%)",
                                "Clareza na explicação do princípio iterativo (25%)",
                                "Correta interpretação de convergência (20%)",
                                "Uso adequado de normalização e fatores de escala (15%)",
                                "Validação com verificação residual (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Fundamentos de autovalores e normas vetoriais.",
                                "Programação Computacional: Implementação iterativa em Python/MATLAB.",
                                "Física Aplicada: Análise modal de vibrações em estruturas.",
                                "Análise Numérica: Estudo de convergência de algoritmos iterativos."
                              ],
                              "realWorldApplication": "Em engenharia civil, o método da potência é usado para encontrar a frequência fundamental (autovalor dominante) em análises modais de edifícios e pontes, permitindo avaliar estabilidade sísmica e otimizar projetos estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Implementar o método da potência em código",
                            "description": "Desenvolver um algoritmo em linguagem de programação (ex.: MATLAB ou Python) para calcular iterações até convergência, incluindo critério de parada baseado em tolerância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar teoria e elaborar pseudocódigo do método da potência",
                                  "subSteps": [
                                    "Estude a teoria: o método da potência encontra o autovalor dominante iterando v_{k+1} = A v_k / ||A v_k|| até convergência.",
                                    "Defina parâmetros: matriz A, vetor inicial v0 aleatório ou unitário, tolerância ε (ex.: 1e-6), máximo de iterações N_max (ex.: 1000).",
                                    "Escreva pseudocódigo: inicializar, loop (multiplicar, normalizar, checar ||λ_{k+1} - λ_k|| < ε), output autovalor λ e autovetor v.",
                                    "Desenhe fluxograma simples para visualizar o loop.",
                                    "Identifique o autovalor dominante como Rayleigh quotient λ_k = v_k^T A v_k."
                                  ],
                                  "verification": "Pseudocódigo escrito e fluxograma desenhado; explique verbalmente o critério de convergência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Referência teórica do método da potência (livro ou PDF)"
                                  ],
                                  "tips": "Comece com uma matriz pequena 2x2 para testar mentalmente.",
                                  "learningObjective": "Compreender o algoritmo iterativo e seus componentes chave.",
                                  "commonMistakes": [
                                    "Confundir autovalor com autovetor",
                                    "Esquecer normalização do vetor",
                                    "Não definir critério de parada claro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de programação e preparar dados de teste",
                                  "subSteps": [
                                    "Instale/inicie Python com NumPy (pip install numpy se necessário).",
                                    "Crie um script novo (ex.: potencia.py).",
                                    "Defina uma matriz de teste A = [[3,1],[1,3]] (autovalor dominante ~4).",
                                    "Gere vetor inicial v0 aleatório unitário usando np.random.rand e normalização.",
                                    "Defina tolerância ε = 1e-6 e N_max = 1000."
                                  ],
                                  "verification": "Código roda sem erros e imprime A, v0 e parâmetros iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy library",
                                    "Editor como VS Code ou Jupyter Notebook"
                                  ],
                                  "tips": "Use np.linalg.norm para normalização L2.",
                                  "learningObjective": "Preparar ambiente e dados para implementação robusta.",
                                  "commonMistakes": [
                                    "Não importar numpy as np",
                                    "Vetor inicial zero (causa divisão por zero)",
                                    "Matriz não simétrica sem ajuste"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop principal de iterações",
                                  "subSteps": [
                                    "Inicie loop while com k=0, λ_prev = 0.",
                                    "Calcule v_new = A @ v (multiplicação matriz-vetor).",
                                    "Calcule λ_new = np.dot(v, A @ v) / np.dot(v, v) (Rayleigh).",
                                    "Normalize v = v_new / np.linalg.norm(v_new).",
                                    "Atualize λ_prev = λ_new e incremente k."
                                  ],
                                  "verification": "Loop executa 5 iterações manualmente; valores de λ convergem.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Script Python existente",
                                    "Documentação NumPy para @ e dot"
                                  ],
                                  "tips": "Use print(k, λ_new) para debug visual.",
                                  "learningObjective": "Codificar a iteração central do algoritmo.",
                                  "commonMistakes": [
                                    "Erro de índice em loop infinito",
                                    "Normalizar antes de Rayleigh",
                                    "Usar norma errada (L1 em vez de L2)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar critério de parada e tratamento de erros",
                                  "subSteps": [
                                    "Adicione condição de parada: if abs(λ_new - λ_prev) < ε or k > N_max: break.",
                                    "Inclua try-except para matriz singular ou norma zero.",
                                    "Registre histórico de λ em lista para plotar convergência.",
                                    "Retorne λ_final, v_final e número de iterações.",
                                    "Adicione função def power_method(A, tol=1e-6, max_iter=1000)."
                                  ],
                                  "verification": "Função retorna corretamente para matriz teste (λ ~4, converge em <20 iterações).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Script atualizado",
                                    "Matplotlib para plot opcional"
                                  ],
                                  "tips": "Teste com N_max baixo para forçar parada por iterações.",
                                  "learningObjective": "Garantir robustez e convergência controlada.",
                                  "commonMistakes": [
                                    "Condição de parada invertida (> em vez de <)",
                                    "Sem checagem de max_iter (loop infinito)",
                                    "Ignorar matrizes com autovalor dominante complexo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, validar e documentar o código",
                                  "subSteps": [
                                    "Teste com matriz conhecida: compare λ com np.linalg.eigvals(A).",
                                    "Rode para matriz maior (ex.: 5x5 simétrica positiva definida).",
                                    "Plote histórico de convergência com matplotlib.",
                                    "Adicione docstring e comentários no código.",
                                    "Valide autovetor: cheque ||A v - λ v|| < 1e-8."
                                  ],
                                  "verification": "Resultados coincidem com eigvals dentro de tolerância; plot mostra convergência.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "NumPy completo",
                                    "Matplotlib (pip install matplotlib)"
                                  ],
                                  "tips": "Use assert abs(lambda_calc - lambda_true) < tol para testes unitários.",
                                  "learningObjective": "Validar implementação e boas práticas de código.",
                                  "commonMistakes": [
                                    "Não comparar com solução exata",
                                    "Plot sem labels",
                                    "Documentação incompleta"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = np.array([[3, 1], [1, 3]]), v0 = [1, 0], ε=1e-6: Após 8 iterações, λ ≈ 4.0, v ≈ [0.707, 0.707]. Código: def power_method(A, ...); print(power_method(A)) deve retornar {'eigenvalue': 4.0, 'eigenvector': [0.7071, 0.7071], 'iterations': 8}.",
                              "finalVerifications": [
                                "Código converge para autovalor dominante exato dentro de ε.",
                                "Autovetor normalizado satisfaz ||A v - λ v|| < 1e-8.",
                                "Loop para em < N_max iterações para matrizes bem-condicionadas.",
                                "Função lida com vetores iniciais diferentes sem crash.",
                                "Histórico de λ mostra monotonia crescente para matriz simétrica.",
                                "Documentação inclui uso e limitações (ex.: assume autovalor dominante real e simples)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro em λ < 1e-5 vs. solução exata (40%).",
                                "Robustez: trata erros como norma zero ou max_iter (20%).",
                                "Eficiência: <50 iterações para matrizes 10x10 (15%).",
                                "Clareza: código comentado, função modular (15%).",
                                "Validação: testes com múltiplas matrizes e plot (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: compreensão de autovalores e normas vetoriais.",
                                "Programação Computacional: uso de NumPy para álgebra linear eficiente.",
                                "Análise Numérica: estudo de convergência e estabilidade numérica.",
                                "Engenharia Civil: aplicação em análise modal de vibrações estruturais.",
                                "Visualização de Dados: plotting de curvas de convergência com Matplotlib."
                              ],
                              "realWorldApplication": "Em engenharia civil, o método da potência é usado para extrair frequências naturais dominantes em análise modal de edifícios e pontes, otimizando simulações dinâmicas em software como ANSYS ou SAP2000, reduzindo tempo computacional para estruturas grandes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Analisar condições de convergência e aceleração",
                            "description": "Identificar requisitos como |λ1| > |λ2| ≥ ... e técnicas de aceleração como deflação ou inversão para autovalores menores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar as condições básicas de convergência do Método da Potência",
                                  "subSteps": [
                                    "Revise a definição do autovalor dominante: o autovalor λ1 com maior módulo |λ1|.",
                                    "Estude a condição principal: |λ1| > |λ2| ≥ |λ3| ≥ ... ≥ |λn|, onde λ2 é o segundo maior em módulo.",
                                    "Analise o impacto da multiplicidade: evite autovalores dominantes com multiplicidade algébrica >1.",
                                    "Examine o vetor inicial: escolha um vetor não ortogonal ao autovetor dominante.",
                                    "Verifique a matriz A: deve ser diagonalizável ou pelo menos ter componente dominante separada."
                                  ],
                                  "verification": "Liste corretamente as 3 condições principais e forneça um contraexemplo onde falha.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de métodos numéricos (ex: Burden & Faires), matrizes de exemplo 2x2 e 3x3, calculadora ou Python/MATLAB.",
                                  "tips": "Sempre normalize o vetor a cada iteração para evitar overflow numérico.",
                                  "learningObjective": "Compreender e enunciar precisamente as condições necessárias para convergência linear do método.",
                                  "commonMistakes": "Confundir módulo com valor absoluto real; ignorar multiplicidade de autovalores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e interpretar o ratio de convergência",
                                  "subSteps": [
                                    "Derive a taxa de convergência: erro ≈ (|λ2|/|λ1|)^k após k iterações.",
                                    "Calcule o ratio r = |λ2|/|λ1| para uma matriz dada.",
                                    "Interprete valores: r < 0.5 para convergência rápida; r próximo de 1 para lenta.",
                                    "Simule iterações manualmente para 5-10 passos e plote o erro.",
                                    "Compare com autovalores exatos computados via QR ou bibliotecas."
                                  ],
                                  "verification": "Para uma matriz 3x3, compute r e preveja número de iterações para erro <10^-6.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software como MATLAB/Octave ou Python (NumPy/SciPy), planilha para simulação manual.",
                                  "tips": "Use log do erro para visualizar linearidade na taxa de convergência.",
                                  "learningObjective": "Quantificar a velocidade de convergência e diagnosticar lentidão.",
                                  "commonMistakes": "Não normalizar vetores, levando a instabilidade; confundir r com razão de Rayleigh."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar técnicas de aceleração via deflação",
                                  "subSteps": [
                                    "Explique deflação simples: substitua A por A - λ1 u1 u1^T / (u1^T u1) após encontrar λ1.",
                                    "Implemente deflação para encontrar λ2: aplique potência na matriz deflacionada.",
                                    "Teste em matriz com |λ1| >> |λ2|: verifique isolamento do segundo autovalor.",
                                    "Considere deflação ortogonal para matrizes simétricas.",
                                    "Avalie estabilidade: monitore perda de precisão por subtração.",
                                    "verification: "
                                  ],
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código Python/MATLAB para deflação, matriz tridiagonal de exemplo.",
                                  "tips": "Use QR para autovalores exatos como benchmark.",
                                  "learningObjective": "Dominar deflação para sequencialmente extrair autovalores dominantes.",
                                  "commonMistakes": "Deflação sem normalização, causando acumulação de erros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar inversão e shifted inverse para autovalores menores",
                                  "subSteps": [
                                    "Entenda inversão: resolva (A - σI)x = b para maximizar 1/|λ - σ|.",
                                    "Escolha shift σ próximo ao autovalor alvo pequeno.",
                                    "Implemente shifted inverse power: itere com (A - σI)^{-1}.",
                                    "Compare convergência: rápido para autovalores isolados.",
                                    "Combine com deflação para espectro completo."
                                  ],
                                  "verification": "Encontre o menor autovalor de uma matriz positiva definida usando shift=0.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Solver linear (LU ou GMRES em SciPy), exemplos de matrizes de rigidez.",
                                  "tips": "Pré-condicione o sistema linear para aceleração.",
                                  "learningObjective": "Usar acelerações para autovalores não-dominantes.",
                                  "commonMistakes": "Shift ruim causando convergência para dominante; ignorar custo de inversão."
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez de uma viga A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]]. Autovalores exatos: ~5.618, 3, 0.382. |λ1|=5.618 > |λ2|=3 > |λ3|=0.382. Ratio r=3/5.618≈0.53 (lenta). Após 20 iterações potência converge a λ1. Deflação isola λ2. Inversão com σ=0 converge rápido a λ3.",
                              "finalVerifications": [
                                "Enuncie condições |λ1| > |λ2| e ratio r.",
                                "Compute r para matriz dada e preveja iterações.",
                                "Implemente deflação e verifique λ2 com erro <1%.",
                                "Use inversão para menor autovalor.",
                                "Discuta acelerações em contexto de vibrações estruturais.",
                                "Identifique falhas em matriz com autovalores próximos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de condições (90% correto).",
                                "Correção no cálculo de ratios e simulações (erro <5%).",
                                "Implementação funcional de deflação/inversão.",
                                "Interpretação qualitativa/quantitativa da convergência.",
                                "Uso de exemplos relevantes à engenharia civil.",
                                "Clareza em relatar erros comuns e soluções."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos de vibração em estruturas (autovalores como frequências).",
                                "Estatística: Análise de componentes principais (PCA via potência).",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Álgebra Linear: Propriedades espectrais de matrizes simétricas.",
                                "Otimização: Gradiente de potência como método iterativo."
                              ],
                              "realWorldApplication": "Em engenharia civil, analisar autovalores de matrizes de rigidez para frequências naturais de pontes ou edifícios, prevendo modos de falha por ressonância; acelerações permitem análise eficiente de grandes sistemas finitos sem diagonalização completa."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.4",
                            "name": "Calcular autovetores associados e validar resultados",
                            "description": "Obter o autovetor normalizado final e verificar a precisão comparando A*v ≈ λ*v, considerando erros numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obter o autovetor candidato e normalizá-lo",
                                  "subSteps": [
                                    "Extraia o vetor v_k da última iteração do Método da Potência.",
                                    "Calcule a norma euclidiana do vetor: ||v_k|| = sqrt(sum(v_i^2)).",
                                    "Divida cada componente do vetor pela norma para obter v normalizado.",
                                    "Armazene o autovetor normalizado como v.",
                                    "Confirme que a soma dos quadrados das componentes é aproximadamente 1."
                                  ],
                                  "verification": "Verifique se ||v|| ≈ 1 (erro < 10^-10).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Matriz A, vetor v_k final, calculadora ou software (Python com NumPy, MATLAB).",
                                  "tips": "Use funções de normalização prontas em bibliotecas para precisão numérica.",
                                  "learningObjective": "Dominar a normalização de vetores para representar autovetores unitários.",
                                  "commonMistakes": "Esquecer de usar a norma euclidiana (L2) em vez de L1 ou máxima."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o autovalor associado λ",
                                  "subSteps": [
                                    "Calcule λ como o valor de Rayleigh: λ = v^T * A * v / (v^T * v), mas como v é normalizado, simplifica para v^T * A * v.",
                                    "Use a aproximação final do método da potência: λ ≈ v_k^T * A * v_k.",
                                    "Registre λ com precisão de pelo menos 6 casas decimais.",
                                    "Compare com iterações anteriores para confirmar convergência."
                                  ],
                                  "verification": "λ deve ser estável nas últimas iterações (variação < 10^-8).",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Matriz A normalizada, vetor v, software para multiplicação matricial.",
                                  "tips": "Prefira o valor de Rayleigh para maior precisão em matrizes não simétricas.",
                                  "learningObjective": "Entender como extrair o autovalor dominante a partir do autovetor.",
                                  "commonMistakes": "Usar λ da primeira iteração em vez da última ou do Rayleigh."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar A*v e λ*v",
                                  "subSteps": [
                                    "Multiplique a matriz A pelo vetor v para obter o vetor residual r = A * v.",
                                    "Calcule o vetor escalonado s = λ * v.",
                                    "Armazene ambos os vetores com a mesma precisão numérica.",
                                    "Visualize graficamente os vetores para inspeção qualitativa.",
                                    "Registre as componentes em uma tabela comparativa."
                                  ],
                                  "verification": "Confirme dimensionalmente que r e s têm o mesmo tamanho e tipo.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Matriz A, vetor v, autovalor λ, software de álgebra linear.",
                                  "tips": "Evite loops manuais; use operações vetoriais para eficiência.",
                                  "learningObjective": "Executar operações matriciais precisas para verificação de autovalores.",
                                  "commonMistakes": "Erro de transposição: confundir A*v com v*A (não comutativo)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar precisão e analisar erros numéricos",
                                  "subSteps": [
                                    "Calcule o erro residual: e = ||A*v - λ*v|| / ||λ*v|| (norma relativa).",
                                    "Defina uma tolerância ε (ex: 10^-6) baseada no condicionamento de A.",
                                    "Interprete: se e < ε, valide; senão, analise causas (não convergência, precisão flutuante).",
                                    "Considere erros de arredondamento: use precisão dupla (double).",
                                    "Gere relatório com e, ε e conclusão."
                                  ],
                                  "verification": "Erro relativo e < tolerância definida.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Vetores r e s, software para normas e relatórios.",
                                  "tips": "Para matrizes grandes, use normas eficientes como norma-2.",
                                  "learningObjective": "Avaliar confiabilidade numérica de aproximações de autovetores.",
                                  "commonMistakes": "Ignorar normalização no denominador do erro relativo."
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez de uma viga 2D: A = [[4, -1], [-1, 4]]. Após iterações do Método da Potência, v ≈ [0.707, 0.707], λ ≈ 3. Aplicando: A*v ≈ [1.5, 1.5], λ*v ≈ [2.121, 2.121] (ajustado), erro relativo ≈ 10^-12, validado.",
                              "finalVerifications": [
                                "||v|| = 1 com precisão 10^-10.",
                                "Erro residual ||A*v - λ*v|| / ||λ*v|| < 10^-6.",
                                "λ coincide com valor de Rayleigh dentro de 10^-8.",
                                "Convergência confirmada nas últimas 3 iterações.",
                                "Relatório gerado sem erros de arredondamento evidentes.",
                                "Visualização gráfica mostra alinhamento de vetores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na normalização do autovetor (erro < 10^-10).",
                                "Correção no cálculo de λ via Rayleigh.",
                                "Exatidão no produto matricial A*v.",
                                "Cálculo correto do erro relativo.",
                                "Interpretação adequada de tolerâncias numéricas.",
                                "Relatório completo e bem estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Linear e Análise Numérica.",
                                "Programação: Implementação em Python/NumPy ou MATLAB.",
                                "Física: Mecânica Estrutural e Modos de Vibração.",
                                "Estatística: Análise de Erros e Tolerâncias."
                              ],
                              "realWorldApplication": "Em engenharia civil, validar autovetores na análise modal de edifícios para identificar o modo de vibração dominante, prevendo respostas a terremotos e otimizando projetos contra ressonância."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Algoritmo QR",
                        "description": "Método iterativo baseado na decomposição QR ortogonal para calcular todos os autovalores de matrizes simétricas ou não, convergindo para a forma diagonal ou triangular.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Entender a decomposição QR e suas propriedades",
                            "description": "Descrever a fatoração A = QR onde Q é ortogonal e R é triangular superior, e como A_{k+1} = R_k Q_k preserva autovalores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender matrizes ortogonais e triangulares superiores",
                                  "subSteps": [
                                    "Defina uma matriz ortogonal: Q tal que Q^T Q = I.",
                                    "Explique as propriedades: colunas unitárias e ortogonais entre si.",
                                    "Defina uma matriz triangular superior: todos elementos abaixo da diagonal principal são zero.",
                                    "Discuta por que essas matrizes são úteis em fatorações.",
                                    "Verifique com uma matriz 2x2 simples: construa Q e R manuais."
                                  ],
                                  "verification": "Construa uma matriz Q ortogonal 2x2 e confirme Q^T Q = I usando cálculo manual ou software.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Caderno, calculadora, software como MATLAB ou Python (NumPy).",
                                  "tips": "Lembre-se: ortogonalidade preserva normas, como rotações.",
                                  "learningObjective": "Identificar e verificar propriedades de matrizes ortogonais e triangulares.",
                                  "commonMistakes": "Confundir ortogonal com simétrica; esquecer que R pode ter negativos na diagonal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a decomposição QR básica: A = QR",
                                  "subSteps": [
                                    "Estude o processo de Gram-Schmidt para ortogonalizar colunas de A.",
                                    "Aplique Gram-Schmidt passo a passo em uma matriz A 3x3.",
                                    "Calcule Q (normalizando vetores ortogonais) e R (coeficientes).",
                                    "Verifique A = Q R multiplicando.",
                                    "Discuta estabilidade numérica e Householder como alternativa."
                                  ],
                                  "verification": "Decomponha uma matriz A aleatória 3x3 em QR e confirme ||A - QR|| < 1e-10.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software NumPy/Python ou MATLAB, exemplos de matrizes.",
                                  "tips": "Use projeções ortogonais: proj_u(v) = (u·v)/||u||^2 * u.",
                                  "learningObjective": "Executar e validar a decomposição QR para qualquer matriz quadrada.",
                                  "commonMistakes": "Não normalizar vetores em Gram-Schmidt, levando a Q não ortogonal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender o algoritmo QR iterativo e preservação de autovalores",
                                  "subSteps": [
                                    "Descreva a iteração: comece com A_0 = A, compute QR, defina A_1 = R Q.",
                                    "Prove que autovalores de A_{k+1} são os mesmos de A_k (similaridade).",
                                    "Explique convergência: diagonais de R_k aproximam autovalores.",
                                    "Simule 10 iterações em uma matriz com autovalores conhecidos.",
                                    "Analise por que converge mais rápido para autovalor dominante."
                                  ],
                                  "verification": "Execute QR em matriz com autovalores conhecidos e confirme que diagonais convergem para eles após iterações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python/MATLAB para iterações QR, matriz de teste.",
                                  "tips": "A_1 = R Q = Q (Q^T A Q) Q^T, similar a A por Q.",
                                  "learningObjective": "Explicar matematicamente a preservação de autovalores no algoritmo QR.",
                                  "commonMistakes": "Confundir ordem: é R Q, não Q R na iteração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar propriedades avançadas e aplicações",
                                  "subSteps": [
                                    "Discuta unicidade da decomposição QR (com diagonal R positiva).",
                                    "Analise sensibilidade a perturbações numéricas.",
                                    "Conecte a autovalores: deflação para múltiplos.",
                                    "Implemente shift para acelerar convergência (QR com shift).",
                                    "Resolva um problema: encontre autovalores de matriz estrutural simples."
                                  ],
                                  "verification": "Resuma em 1 parágrafo as propriedades chave e prove preservação com exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação NumPy/SciPy, artigos sobre QR algorithm.",
                                  "tips": "Para engenharia, QR é base para eigensolvers em vibrações estruturais.",
                                  "learningObjective": "Aplicar propriedades QR em contextos numéricos reais.",
                                  "commonMistakes": "Ignorar perda de ortogonalidade em computação finita; usar sem shifts."
                                }
                              ],
                              "practicalExample": "Considere A = [[4, 1], [1, 3]]. Decomposição QR: Q ≈ [[0.97, -0.24], [0.24, 0.97]], R ≈ [[4.12, 0.97], [0, 2.90]]. Iteração 1: A1 = R Q ≈ [[3.90, 1.46], [1.46, 3.10]]. Após iterações, diagonais convergem para autovalores ~4.0 e 3.0.",
                              "finalVerifications": [
                                "Decompor corretamente uma matriz 3x3 em QR.",
                                "Executar 5 iterações QR e listar autovalores aproximados.",
                                "Provar similaridade: trace(A_k) = trace(A_0).",
                                "Explicar por que Q ortogonal preserva espectro.",
                                "Identificar erros em decomposição inválida.",
                                "Aplicar em matriz não simétrica e discutir."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de Q ortogonal e R triangular.",
                                "Correta execução de Gram-Schmidt com verificação numérica.",
                                "Compreensão da similaridade A_{k+1} ~ A_k.",
                                "Análise de convergência com exemplo computacional.",
                                "Conexão clara com preservação de autovalores.",
                                "Uso correto de termos técnicos sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Civil: Análise modal de estruturas (vibrações).",
                                "Computação: Algoritmos numéricos lineares (LAPACK).",
                                "Física: Sistemas dinâmicos e estabilidade.",
                                "Matemática: Álgebra linear avançada e análise numérica."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, o algoritmo QR é usado em software como SAP2000 para calcular autovalores em análise dinâmica de edifícios, identificando frequências naturais de vibração para design sísmico seguro."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Implementar iterações básicas do algoritmo QR",
                            "description": "Codificar o loop de decomposição QR e recomposição RQ em software, aplicando a matrizes simétricas até convergência na diagonal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente de programação e matriz de teste simétrica",
                                  "subSteps": [
                                    "Instale bibliotecas necessárias: NumPy para manipulação de matrizes.",
                                    "Crie uma matriz simétrica 3x3 de teste, como A = [[4, 1, 1], [1, 3, 1], [1, 1, 2]], com autovalores conhecidos aproximadamente 1, 3, 5.",
                                    "Implemente funções auxiliares para normas euclidianas e produto matricial.",
                                    "Visualize a matriz inicial e compute autovalores reais com np.linalg.eigvals para referência.",
                                    "Defina tolerância de convergência (ex: 1e-10) e máximo de iterações (ex: 100)."
                                  ],
                                  "verification": "Matriz de teste criada e funções auxiliares testadas com saídas corretas comparadas a NumPy.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "Jupyter Notebook para visualização"
                                  ],
                                  "tips": "Use np.eye para identidade e np.dot para multiplicações; teste funções unitariamente.",
                                  "learningObjective": "Configurar um ambiente robusto para implementação numérica estável.",
                                  "commonMistakes": [
                                    "Usar np.linalg.qr prematuramente",
                                    "Escolher matriz não simétrica",
                                    "Ignorar tolerâncias numéricas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar reflexão Householder para zerar subdiagonal de uma coluna",
                                  "subSteps": [
                                    "Defina função householder_vector(x) que computa vetor Householder v para zerar elementos abaixo de x[0].",
                                    "Calcule norma da cauda ||x_tail|| e sinal para estabilidade numérica: sigma = sign(x[0]) * ||x_tail||.",
                                    "Construa v = x; v[0] += sigma; normalize v /= ||v||.",
                                    "Teste em vetor unitário: aplique Householder H = I - 2 v v^T e verifique que zera subcomponentes.",
                                    "Integre com matriz: aplique H à esquerda de A para zerar coluna k abaixo da diagonal."
                                  ],
                                  "verification": "Aplicação de Householder em vetor de teste resulta em vetor com apenas primeiro elemento não-zero.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "NumPy arrays",
                                    "Funções matemáticas: np.linalg.norm, np.sign"
                                  ],
                                  "tips": "Sempre use cópias de matrizes com np.copy() para evitar modificações in-place indesejadas.",
                                  "learningObjective": "Dominar transformações ortogonais elementares para estabilizar QR.",
                                  "commonMistakes": [
                                    "Esquecer normalização de v",
                                    "Sinal incorreto em sigma causando cancelamento numérico",
                                    "Aplicar H à direita em vez de esquerda"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar decomposição QR completa usando múltiplas reflexões Householder",
                                  "subSteps": [
                                    "Crie função qr_decomposition(A) que retorna Q e R.",
                                    "Para cada coluna k de 0 a n-2: compute Householder para subcoluna A[k+1:, k].",
                                    "Aplique H_k à esquerda de A[k:, k:] para zerar abaixo da diagonal.",
                                    "Aplique mesmo H_k à direita para manter simetria? Não: acumule Q como produto de H's.",
                                    "Extraia R da parte triangular superior de A modificada; reconstrua Q como produto de H's.",
                                    "Teste: verifique ||A - Q @ R|| < 1e-12."
                                  ],
                                  "verification": "Q é ortogonal (Q.T @ Q ≈ I) e A ≈ Q @ R com erro residual pequeno.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "NumPy para broadcasting e slicing de submatrizes"
                                  ],
                                  "tips": "Use loops eficientes e slicing A[k:, k:] para performance; armazene Householders para reconstruir Q.",
                                  "learningObjective": "Construir decomposição QR estável para matrizes densas.",
                                  "commonMistakes": [
                                    "Não aplicar Householder às colunas restantes",
                                    "Perder ortogonalidade por acumulação de erros",
                                    "Confundir Q e R na extração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar iteração única QR e loop de convergência",
                                  "subSteps": [
                                    "Defina função qr_iteration(A): compute Q, R = qr_decomposition(A); retorne R @ Q.",
                                    "No loop principal: while max_off_diagonal(A) > tol and it < max_it: A = qr_iteration(A).",
                                    "Compute off-diagonal max como max(|A[i,j]| for i != j).",
                                    "Registre eigenvalues como diagonal de A a cada 10 iterações.",
                                    "Pare e retorne A diagonalizada."
                                  ],
                                  "verification": "Após poucas iterações, off-diagonais diminuem; diagonal converge a autovalores reais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Listas para histórico de diagonais",
                                    "Matplotlib para plotar convergência opcional"
                                  ],
                                  "tips": "Monitore norma Frobenius das off-diagonais para critério mais robusto.",
                                  "learningObjective": "Realizar iterações deflacionadas implícitas para diagonalização.",
                                  "commonMistakes": [
                                    "Usar A = Q @ R em vez de R @ Q",
                                    "Loop infinito por tol inadequada",
                                    "Não shift para aceleração"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar implementação completa e analisar resultados",
                                  "subSteps": [
                                    "Execute algoritmo na matriz de teste e compare diagonal final com np.linalg.eigvals.",
                                    "Teste com matriz maior (4x4) simétrica aleatória.",
                                    "Meça número de iterações até convergência e tempo de execução.",
                                    "Visualize evolução da diagonal com plot.",
                                    "Implemente shift de Wilkinson opcional para aceleração."
                                  ],
                                  "verification": "Autovalores computados coincidem com referência dentro de 1e-8; convergência em <50 iterações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matplotlib para gráficos",
                                    "np.random para matrizes de teste"
                                  ],
                                  "tips": "Sempre compare com solver padrão para validação.",
                                  "learningObjective": "Validar implementação numérica e interpretar resultados.",
                                  "commonMistakes": [
                                    "Ignorar ordenação de autovalores",
                                    "Não testar escalabilidade",
                                    "Confundir autovetores"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a matriz simétrica A = [[4,1,1],[1,3,1],[1,1,2]], implemente o loop QR: após 10-20 iterações, A converge para diag([5.5, 2.5, 0.9]) aproximadamente, matching autovalores exatos.",
                              "finalVerifications": [
                                "Código executa sem erros numéricos (NaN/inf).",
                                "Q ortogonal: ||Q.T @ Q - I|| < 1e-12.",
                                "Convergência: off-diagonais < 1e-10 em <100 iterações.",
                                "Autovalores na diagonal batem com np.linalg.eigvals dentro de 1e-8.",
                                "Funciona para matrizes 3x3 e 4x4 simétricas.",
                                "Tempo de execução razoável (<1s para n=10)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica da decomposição QR (erro residual <1e-12).",
                                "Estabilidade: convergência consistente em múltiplos testes.",
                                "Eficiência: número de iterações otimizado (<50 para n=5).",
                                "Clareza do código: comentários, funções modulares.",
                                "Robustez: trata casos edge como matrizes já diagonais.",
                                "Documentação: inclui testes unitários e validações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise modal de vibrações em estruturas civis (frequências naturais).",
                                "Estatística: Principal Component Analysis (PCA) via diagonalização.",
                                "Engenharia Mecânica: Dinâmica de sistemas multi-graus de liberdade.",
                                "Matemática Pura: Teoria espectral de operadores simétricos."
                              ],
                              "realWorldApplication": "Na engenharia civil, o algoritmo QR é essencial para análise modal de edifícios e pontes, computando autovalores que representam frequências de vibração natural, auxiliando no design sísmico e prevenção de ressonâncias destrutivas."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Aplicar shifts de Wilkinson para aceleração",
                            "description": "Incorporar deslocamentos espectrais (shifts) para melhorar a convergência, especialmente para autovalores extremos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Algoritmo QR e Conceito de Shifts",
                                  "subSteps": [
                                    "Relembrar o processo básico do algoritmo QR iterativo para autovalores.",
                                    "Entender como shifts aceleram a deflação da matriz, aproximando o autovalor extremo.",
                                    "Estudar a importância de shifts para autovalores reais em matrizes simétricas.",
                                    "Analisar exemplos de convergência lenta sem shifts.",
                                    "Identificar quando shifts são cruciais (autovalores próximos)."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito como um shift modifica A_k = Q_k R_k + μI.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre QR",
                                    "Matriz simétrica de exemplo 3x3",
                                    "Software MATLAB ou Python (NumPy)"
                                  ],
                                  "tips": "Comece com matrizes pequenas para visualizar a deflação diagonal.",
                                  "learningObjective": "Compreender o papel dos shifts na aceleração da convergência QR.",
                                  "commonMistakes": [
                                    "Confundir shift com inversão da matriz",
                                    "Ignorar simetria da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Calcular Shift de Wilkinson",
                                  "subSteps": [
                                    "Estudar a fórmula do shift de Wilkinson: autovalor da submatriz 2x2 inferior direita mais próximo de a_{nn}.",
                                    "Derivar os autovalores da submatriz 2x2: raízes da equação quadrática.",
                                    "Implementar cálculo manual para uma matriz 3x3.",
                                    "Comparar com Rayleigh shift (a_{nn}) para entender superioridade.",
                                    "Verificar estabilidade numérica do shift."
                                  ],
                                  "verification": "Calcular corretamente o shift para uma matriz dada e justificar escolha.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Fórmulas derivadas de Wilkinson shift",
                                    "Calculadora ou papel para 2x2",
                                    "Código Python para automação"
                                  ],
                                  "tips": "Sempre priorize o autovalor mais próximo de a_{nn} para minimizar erro residual.",
                                  "learningObjective": "Dominar o cálculo preciso do shift de Wilkinson.",
                                  "commonMistakes": [
                                    "Escolher o autovalor errado da 2x2",
                                    "Não considerar proximidade com a_{nn}"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Shift de Wilkinson no Algoritmo QR",
                                  "subSteps": [
                                    "Modificar pseudocódigo QR: A_{k+1} = R_k Q_k + μ_k I, onde μ_k é Wilkinson shift.",
                                    "Implementar iterações com deflação de autovalores convergidos.",
                                    "Testar em matriz não-diagonal para observar aceleração.",
                                    "Monitorar resíduos |A_k v - λ v| para validar convergência.",
                                    "Ajustar tolerância (ex: 1e-10)."
                                  ],
                                  "verification": "Executar 10 iterações e mostrar diagonal convergindo mais rápido.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Pseudocódigo QR modificado",
                                    "Python/NumPy ou MATLAB",
                                    "Matriz de teste assimétrica simétrica"
                                  ],
                                  "tips": "Use QR Householder para eficiência em matrizes maiores.",
                                  "learningObjective": "Implementar QR acelerado com Wilkinson shift.",
                                  "commonMistakes": [
                                    "Esquecer de zerar shift após deflação",
                                    "Aplicar shift em matriz já deflacionada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Analisar em Contexto Estrutural",
                                  "subSteps": [
                                    "Selecionar matriz de autovalores de rigidez/massa em viga ou treliça.",
                                    "Executar QR sem e com shift, comparando iterações necessárias.",
                                    "Calcular frequências naturais (sqrt(autovalores)) para modos de vibração.",
                                    "Visualizar autofunções com plot.",
                                    "Documentar speedup (ex: 50% menos iterações)."
                                  ],
                                  "verification": "Relatório com tabelas de convergência e plots de modos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matriz exemplo de estrutura civil 4x4",
                                    "Software FEA básico ou código custom",
                                    "Gráficos Matplotlib"
                                  ],
                                  "tips": "Normalizar matriz massa para autovalores em rad²/s².",
                                  "learningObjective": "Aplicar shifts em problemas reais de engenharia civil.",
                                  "commonMistakes": [
                                    "Não verificar ortogonalidade das Qs",
                                    "Ignorar autovalores complexos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma treliça 2D com matriz de rigidez 4x4 não-diagonal, aplique QR com Wilkinson shift: submatriz 2x2 [[5.2, 0.1],[0.1,4.9]], shift ≈4.95 (próximo de 4.9). Após 8 iterações, autovalores convergem para [1.2, 3.4, 6.7, 10.1] vs 25 sem shift, acelerando análise modal.",
                              "finalVerifications": [
                                "Shift calculado coincide com autovalor 2x2 mais próximo de a_{nn}.",
                                "Número de iterações reduzido em pelo menos 40% vs QR sem shift.",
                                "Resíduos de autovalores < 1e-12.",
                                "Autofunções ortonormais (produto interno ≈0).",
                                "Frequências naturais físicas (positivas reais).",
                                "Diagonal da matriz final deflacionada corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo do shift de Wilkinson (erro <1%).",
                                "Correta integração no loop QR com deflação.",
                                "Análise quantitativa de convergência (gráficos/tabelas).",
                                "Aplicação contextual em engenharia civil válida.",
                                "Identificação e correção de erros numéricos.",
                                "Explicação clara de aceleração teórica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Estabilidade e convergência de iterativos.",
                                "Programação Computacional: Implementação eficiente em Python/MATLAB.",
                                "Física Estrutural: Modos de vibração e análise dinâmica.",
                                "Otimização: Técnicas de aceleração em algoritmos.",
                                "Engenharia de Software: Validação numérica de resultados."
                              ],
                              "realWorldApplication": "Na análise modal de edifícios altos ou pontes, shifts de Wilkinson aceleram o QR para matrizes grandes de rigidez (n>1000), reduzindo tempo de simulação de horas para minutos em software como SAP2000 ou ANSYS, essencial para projetos sísmicos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.4",
                            "name": "Extrair autovalores e autovetores do algoritmo QR",
                            "description": "Ler autovalores da diagonal final e computar autovetores via Q acumulado, validando com problemas de engenharia civil como vibrações estruturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e extrair autovalores da diagonal da matriz convergida",
                                  "subSteps": [
                                    "Revise as iterações do algoritmo QR até convergência, obtendo a matriz R_k ou H_k final (quase diagonal).",
                                    "Leia os elementos da diagonal principal de R_k: λ1 = R_k(1,1), λ2 = R_k(2,2), ..., λn = R_k(n,n).",
                                    "Registre os autovalores em ordem decrescente ou crescente, dependendo da aplicação.",
                                    "Verifique a tolerância de convergência (ex: |off-diagonal| < 10^-6).",
                                    "Anote os autovalores com precisão numérica adequada (ex: 4 casas decimais)."
                                  ],
                                  "verification": "Os autovalores extraídos coincidem com a diagonal da matriz final dentro da tolerância numérica.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Matriz final do QR (papel ou software como MATLAB/Python)",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Ordene os autovalores para facilitar comparações em problemas de vibração.",
                                  "learningObjective": "Compreender que os autovalores do algoritmo QR são revelados na diagonal da matriz triangular superior convergida.",
                                  "commonMistakes": [
                                    "Ignorar elementos subdiagonais pequenos que indicam falta de convergência",
                                    "Confundir R com Q na extração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz Q acumulada (produto dos fatores Q das iterações)",
                                  "subSteps": [
                                    "Inicie com Q_total = I (identidade n x n).",
                                    "Para cada iteração k de 1 a m: Q_total = Q_total * Q_k, onde Q_k é da decomposição QR_k.",
                                    "Multiplique as matrizes ortogonais sequencialmente, preservando a ortogonalidade.",
                                    "Verifique se det(Q_total) ≈ 1 ou -1 (ortogonalidade).",
                                    "Armazene Q_total como matriz de autovetores candidatos."
                                  ],
                                  "verification": "Q_total é ortogonal: Q_total * Q_total^T ≈ I, com norma de Frobenius do erro < 10^-5.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Lista de Q_k das iterações anteriores",
                                    "Software NumPy/MATLAB para multiplicação matricial"
                                  ],
                                  "tips": "Use computação numérica para evitar erros de arredondamento em multiplicações manuais.",
                                  "learningObjective": "Dominar o cálculo da matriz de autovetores como produto acumulado dos rotadores/refletores QR.",
                                  "commonMistakes": [
                                    "Multiplicar na ordem errada (Q_k * Q_total em vez de Q_total * Q_k)",
                                    "Esquecer normalização intermediária"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair e normalizar autovetores das colunas de Q_total",
                                  "subSteps": [
                                    "Os autovetores v_i são as colunas de Q_total: v1 = coluna 1, v2 = coluna 2, etc.",
                                    "Normalize cada v_i: v_i_norm = v_i / ||v_i||_2.",
                                    "Verifique ortonormalidade: v_i_norm^T * v_j_norm = δ_ij (1 se i=j, 0 caso contrário).",
                                    "Associe cada v_i_norm ao autovalor λ_i correspondente.",
                                    "Teste: A * v_i_norm ≈ λ_i * v_i_norm para a matriz original A."
                                  ],
                                  "verification": "Verificação de autovetor: ||A * v_i - λ_i * v_i|| / ||v_i|| < 10^-6 para todos i.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Matriz Q_total",
                                    "Matriz A original",
                                    "Software para norma euclidiana e produto matricial"
                                  ],
                                  "tips": "Sempre teste com a matriz original para validar extração.",
                                  "learningObjective": "Extrair autovetores diretamente das colunas de Q_total e garantir normalização.",
                                  "commonMistakes": [
                                    "Não normalizar vetores",
                                    "Associar autovetores errados aos autovalores (ordem das colunas)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar com problema de engenharia civil (ex: vibrações estruturais)",
                                  "subSteps": [
                                    "Escolha uma matriz de rigidez/massa de uma viga ou estrutura simples (ex: 2x2 para modo fundamental).",
                                    "Aplique extração QR à matriz e compare autovalores com frequências analíticas.",
                                    "Identifique modos de vibração via autovetores (ex: direção de deslocamento).",
                                    "Calcule erro relativo: |λ_num - λ_anal| / |λ_anal| < 1%.",
                                    "Interprete: autovalor maior = frequência mais alta, autovetor = forma modal."
                                  ],
                                  "verification": "Resultados numéricos coincidem com solução analítica ou experimental em 1-2% de erro.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Exemplo de matriz de vibração (ex: A = [[4,1],[1,3]] para viga)",
                                    "Referência analítica de autovalores"
                                  ],
                                  "tips": "Use problemas pequenos primeiro para depuração antes de escalar.",
                                  "learningObjective": "Aplicar extração QR a problemas reais de engenharia civil para análise modal.",
                                  "commonMistakes": [
                                    "Usar matriz não simétrica (QR assume simétrica para vibrações)",
                                    "Ignorar escalas físicas nos autovalores (Hz vs rad/s)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a matriz de rigidez de uma viga bi-suportada A = [[4, -2], [-2, 4]], após 5 iterações QR: diagonal final [6, 2] (autovalores λ1=6, λ2=2). Q_total = [[0.707, -0.707], [0.707, 0.707]]. Autovetores: v1=[0.707, 0.707]^T (modo simétrico), v2=[-0.707, 0.707]^T (modo antissimétrico). Verifique: A v1 ≈ 6 v1.",
                              "finalVerifications": [
                                "Autovalores lidos corretamente da diagonal final.",
                                "Q_total ortogonal com det ≈ ±1.",
                                "Autovetores normalizados e ortonormais.",
                                "Verificação residual ||A v - λ v|| pequena.",
                                "Aplicação válida a vibrações estruturais.",
                                "Erros numéricos abaixo de tolerância."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de autovalores (erro < 0.1%).",
                                "Correta construção de Q_total (ortogonalidade verificada).",
                                "Normalização e associação correta de autovetores.",
                                "Validação com teste matricial A v = λ v.",
                                "Interpretação contextual em engenharia civil.",
                                "Eficiência computacional (número de iterações razoável)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise modal de vibrações em estruturas.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Álgebra Linear: Propriedades de matrizes simétricas.",
                                "Engenharia Mecânica: Dinâmica de sistemas multi-graus de liberdade."
                              ],
                              "realWorldApplication": "Em engenharia civil, extrair autovalores/autovetores via QR permite análise modal de edifícios e pontes, identificando frequências naturais e modos de vibração para design sísmico e prevenção de ressonância."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.5",
                            "name": "Comparar eficiência com método da potência",
                            "description": "Avaliar complexidade computacional (O(n^3) por iteração) e cenários de aplicação em problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método da Potência e sua Complexidade Computacional",
                                  "subSteps": [
                                    "Descreva o algoritmo do Método da Potência: inicialize vetor u0, normalize, multiplique por A iterativamente até convergência.",
                                    "Calcule a complexidade por iteração: cada multiplicação matriz-vetor é O(n²), normalização O(n), tipicamente k iterações onde k depende da razão de autovalores.",
                                    "Discuta convergência: converge para autovalor dominante se |λ1| > |λi| para i>1.",
                                    "Implemente um exemplo simples em pseudocódigo ou Python para matriz 5x5.",
                                    "Meça tempo de execução para matrizes de tamanhos variados (n=10,50,100)."
                                  ],
                                  "verification": "Implementação converge ao autovalor dominante com erro < 1e-6 em <50 iterações para matriz de teste.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy, matriz de exemplo assimétrica com autovalor dominante claro (ex: [[3,1],[1,2]] expandida).",
                                  "tips": "Use normalização em cada passo para evitar overflow numérico.",
                                  "learningObjective": "Entender o custo O(n²) por iteração e limitações a um autovalor.",
                                  "commonMistakes": "Confundir O(n²) com O(n³); assumir convergência sem gap espectral suficiente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar o Algoritmo QR e sua Complexidade Computacional",
                                  "subSteps": [
                                    "Explique o Algoritmo QR: decomposição QR iterativa A_k = Q_k R_k, então A_{k+1} = R_k Q_k, converge para triangular superior.",
                                    "Detalhe complexidade: decomposição QR é O(n³) via Householder ou Givens, k iterações tipicamente O(n log n) para convergência.",
                                    "Descreva variantes (shifted QR para acelerar).",
                                    "Implemente pseudocódigo ou Python usando scipy.linalg.qr para matriz 5x5.",
                                    "Compare tempo para n=10,50,100."
                                  ],
                                  "verification": "Autovalores na diagonal após 20 iterações com precisão <1e-8.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python com NumPy/SciPy, matriz simétrica positiva definida (ex: matriz de rigidez simples).",
                                  "tips": "Use QR com shifts para problemas reais onde autovalores não são bem separados.",
                                  "learningObjective": "Compreender O(n³) por iteração mas convergência para todos autovalores.",
                                  "commonMistakes": "Ignorar custo da decomposição QR; esperar convergência cúbica sem shifts."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Complexidades e Taxas de Convergência",
                                  "subSteps": [
                                    "Tabele complexidades: Potência O(k n²), QR O(k n³) com k_QR << k_potência para múltiplos autovalores.",
                                    "Analise cenários: Potência melhor para autovalor dominante isolado; QR para espectro completo.",
                                    "Grafique tempo vs n para ambos (log-log plot).",
                                    "Discuta precisão: Potência sensível a ruído; QR mais robusto.",
                                    "Calcule break-even point: quando n pequeno e só 1 autovalor, Potência vence."
                                  ],
                                  "verification": "Gráfico mostra crossover em n~20-50 para problemas típicos; tabela resume diferenças.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha Excel ou Jupyter Notebook, dados de tempos de Step 1-2.",
                                  "tips": "Foquem em problemas reais: conte autovalores necessários antes de escolher.",
                                  "learningObjective": "Quantificar quando QR é mais eficiente apesar de O(n³).",
                                  "commonMistakes": "Comparar apples-to-oranges sem fixar precisão ou número de autovalores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Comparação a Cenários de Engenharia Civil",
                                  "subSteps": [
                                    "Identifique problemas: análise modal (frequências naturais) de vigas/estruturas, matriz de rigidez n~100-1000.",
                                    "Avalie: 1 modo dominante? Use Potência (ex: buckling crítico). Múltiplos modos? QR.",
                                    "Simule exemplo: matriz 20x20 de viga, compute tempos reais.",
                                    "Conclua guidelines: Potência para protótipos rápidos; QR para análise full.",
                                    "Documente trade-offs em relatório curto."
                                  ],
                                  "verification": "Relatório lista 3 cenários civis com método recomendado e justificativa.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Matriz de exemplo de engenharia (ex: tridiagonal para viga), MATLAB/ANSYS snippet.",
                                  "tips": "Em prática, use bibliotecas como Eigen ou LAPACK que otimizam QR.",
                                  "learningObjective": "Mapear eficiência a aplicações reais em estruturas.",
                                  "commonMistakes": "Generalizar sem considerar tamanho n ou simetria da matriz."
                                }
                              ],
                              "practicalExample": "Para uma matriz de rigidez 50x50 de uma ponte pênsil (n=50), Método da Potência leva 10s para 1º modo de vibração (frequência fundamental), mas 500s para top-5 modos via deflação. QR completo em 15s para todos os 50 autovalores com precisão 1e-10, ideal para análise sísmica completa.",
                              "finalVerifications": [
                                "Explicar corretamente O(n²) vs O(n³) por iteração.",
                                "Identificar 2 cenários onde Potência é superior.",
                                "Identificar 2 onde QR é essencial.",
                                "Simulação numérica confirma análise teórica.",
                                "Relatório resume trade-offs com gráfico de tempo vs n.",
                                "Discutir impacto de shifts no QR."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de complexidades (100% match com teoria).",
                                "Qualidade da comparação quantitativa (gráficos/tabelas claros).",
                                "Relevância de cenários civis (ligados a problemas reais como modais).",
                                "Correção em implementações numéricas (erro <1e-8).",
                                "Profundidade em trade-offs (convergência, robustez, escalabilidade).",
                                "Clareza no relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Linear (autovalores, decomposições).",
                                "Programação: Otimização numérica (NumPy, SciPy, profiling).",
                                "Física: Dinâmica das estruturas (modos de vibração).",
                                "Engenharia de Software: Escolha de algoritmos em simulações FEM."
                              ],
                              "realWorldApplication": "Em projeto de edifícios altos, análise modal rápida com Potência para modo fundamental (verificação inicial de ressonância eólica); QR para espectro completo em simulações sísmicas, otimizando design contra múltiplas frequências e evitando colapsos como em terremotos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.4",
                              "10.1.3.5.2.4"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.6",
                    "name": "Aplicações em Engenharia Civil",
                    "description": "Uso de autovalores em análise modal de estruturas, vibrações e estabilidade computacional.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.6.1",
                        "name": "Análise Modal de Estruturas",
                        "description": "Aplicação de autovalores e autofunções para determinar frequências naturais e modos de vibração em estruturas civis, como edifícios e pontes, utilizando a equação de autovalores da matriz de rigidez e massa.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.1.1",
                            "name": "Formular a matriz de autovalores para análise modal",
                            "description": "Construir as matrizes de massa [M] e rigidez [K] a partir do modelo finito de elementos de uma estrutura civil e formular o problema generalizado de autovalores [K]φ = ω²[M]φ para extrair frequências ω e modos φ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo de elementos finitos da estrutura",
                                  "subSteps": [
                                    "Identificar o tipo de estrutura civil (ex.: viga, treliça ou pórtico).",
                                    "Discretizar a estrutura em elementos finitos, definindo nós e elementos.",
                                    "Determinar os graus de liberdade (GL) por nó (ex.: translações e rotações).",
                                    "Especificar propriedades dos materiais (módulo de elasticidade E, seção transversal A, momento de inércia I) e comprimentos dos elementos.",
                                    "Definir condições de contorno (nós fixos ou livres)."
                                  ],
                                  "verification": "Verificar se o modelo possui nós numerados corretamente, elementos conectados e GL listados sem duplicatas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis ou software como MATLAB/ANSYS",
                                    "Dados da estrutura (geometria, materiais)"
                                  ],
                                  "tips": "Comece com estruturas simples (1D) para validar o entendimento antes de 2D/3D.",
                                  "learningObjective": "Compreender a discretização da estrutura em elementos finitos e definição de graus de liberdade.",
                                  "commonMistakes": [
                                    "Ignorar rotações em vigas (GL incorretos)",
                                    "Não numerar nós sequencialmente",
                                    "Esquecer condições de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de rigidez global [K]",
                                  "subSteps": [
                                    "Calcular a matriz de rigidez local [k] para cada elemento usando fórmulas padrão (ex.: para barra: k = (AE/L)[1 -1; -1 1]).",
                                    "Aplicar transformações de coordenadas se elementos não alinhados com eixos globais.",
                                    "Expandir [k] local para o tamanho total de GL usando vetor de conectividade.",
                                    "Montar [K] global somando contribuições de todos elementos nas posições corretas.",
                                    "Aplicar condições de contorno eliminando ou restringindo linhas/colunas de GL fixos."
                                  ],
                                  "verification": "Conferir se [K] é simétrica e positiva definida; testar rigidez com deslocamento unitário.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou MATLAB para montagem matricial",
                                    "Tabelas de matrizes elementares"
                                  ],
                                  "tips": "Use a técnica de montagem por sobreposição para evitar erros de indexação.",
                                  "learningObjective": "Dominar a montagem da matriz de rigidez global a partir de elementos finitos.",
                                  "commonMistakes": [
                                    "Erro no vetor de conectividade (GL errados)",
                                    "Não zerar off-diagonais após restrições",
                                    "Esquecer fatores de escala como AE/L"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz de massa global [M]",
                                  "subSteps": [
                                    "Escolher modelo de massa (consistente ou lumped).",
                                    "Calcular matriz de massa local [m] para cada elemento (ex.: lumped: m = (ρAL/2) diag[1 1] para barra).",
                                    "Expandir [m] local para GL total usando conectividade.",
                                    "Montar [M] global somando contribuições elementares.",
                                    "Aplicar mesmas restrições de contorno usadas em [K]."
                                  ],
                                  "verification": "Verificar se [M] é simétrica e diagonal dominante (para lumped); soma das linhas igual à massa total.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ou Python (NumPy)",
                                    "Propriedades de densidade ρ e seção"
                                  ],
                                  "tips": "Prefira massa lumped para iniciantes, pois simplifica para diagonal.",
                                  "learningObjective": "Construir corretamente a matriz de massa coerente com o modelo de rigidez.",
                                  "commonMistakes": [
                                    "Confundir massa consistente com lumped",
                                    "Não distribuir massa corretamente em nós compartilhados",
                                    "Ignorar densidade volumétrica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular o problema generalizado de autovalores",
                                  "subSteps": [
                                    "Escrever a equação dinâmica [M]{ü} + [K]{u} = 0 e assumir solução harmônica {u} = φ sin(ωt).",
                                    "Derivar a forma padrão [K]φ = ω² [M] φ.",
                                    "Identificar [K] e [M] como matrizes conhecidas, φ como autofunções (modos) e ω² como autovalores (frequências quadradas).",
                                    "Verificar dimensionalidade: ambas matrizes n x n, onde n = número de GL livres.",
                                    "Preparar para solução numérica (ex.: via eig em MATLAB: [φ, Λ] = eig(K, M))."
                                  ],
                                  "verification": "Confirmar que a equação resultante tem tamanho correto e é no formato generalizado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de álgebra linear (MATLAB eig)",
                                    "Documentação teórica de análise modal"
                                  ],
                                  "tips": "Lembre-se: ω é frequência natural (rad/s), φ normalizados para massa unitária.",
                                  "learningObjective": "Formular precisamente o problema de autovalores para análise modal.",
                                  "commonMistakes": [
                                    "Escrever [M]φ = ω² [K]φ (inverso)",
                                    "Confundir ω com f (Hz)",
                                    "Não reduzir para GL livres"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de 2 elementos finitos (2 nós livres, 3 GL: v1, θ1, v2), monte [K] 3x3 de Euler-Bernoulli, [M] lumped diagonal, e formule [K]φ = ω²[M]φ. Solução: eig(K,M) dá 2 frequências e modos de flexão.",
                              "finalVerifications": [
                                "[K] e [M] são simétricas e do mesmo tamanho?",
                                "Condições de contorno aplicadas corretamente em ambas matrizes?",
                                "Equação [K]φ = ω²[M]φ escrita com notação matricial precisa?",
                                "Frequências ω têm unidades corretas (rad/s)?",
                                "Modos φ ortogonais em relação a [M]?",
                                "Massa total preservada em [M]?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na montagem de [K] e [M] (erro <1%)",
                                "Correta formulação da equação generalizada",
                                "Explicação clara de ω e φ",
                                "Verificação de simetria e propriedades positivas",
                                "Aplicação correta de contornos",
                                "Eficiência computacional na implementação"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Linear (problemas generalizados de autovalores)",
                                "Física: Dinâmica das estruturas e vibrações livres",
                                "Programação: Implementação numérica em MATLAB/Python",
                                "Engenharia Mecânica: Análise de vibrações",
                                "Estatística: Análise de incertezas em modelos finitos"
                              ],
                              "realWorldApplication": "Na análise modal de pontes e edifícios para prever respostas a terremotos ou vento, identificando modos críticos de vibração para evitar ressonância e otimizar design estrutural."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.1.2",
                            "name": "Calcular frequências e modos naturais",
                            "description": "Implementar métodos numéricos, como o QR algorithm ou eig() no MATLAB, para resolver autovalores e autofunções, interpretando os autovalores como quadrados das frequências naturais e autofunções como modos de deformação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo estrutural e matrizes de rigidez e massa",
                                  "subSteps": [
                                    "Definir o sistema estrutural simples, como uma viga cantilever com 2 graus de liberdade (translação e rotação).",
                                    "Calcular e montar manualmente a matriz de rigidez [K] usando propriedades do elemento (EI, L).",
                                    "Montar a matriz de massa [M] consistente ou diagonalizada, considerando densidade e área transversal.",
                                    "Verificar simetria e propriedades positivas definidas das matrizes.",
                                    "Implementar as matrizes em script MATLAB como variáveis simbólicas ou numéricas."
                                  ],
                                  "verification": "Executar script MATLAB para exibir [K] e [M]; confirmar que são simétricas e det([K]) > 0.",
                                  "estimatedTime": "2 hours",
                                  "materials": "MATLAB instalado, documentação de elementos finitos (ex: livro de Bathe), calculadora.",
                                  "tips": "Comece com um sistema pequeno (2 DOF) para depuração fácil; use syms() para verificação simbólica.",
                                  "learningObjective": "Compreender como matrizes [K] e [M] representam o problema dinâmico da estrutura.",
                                  "commonMistakes": "Esquecer unidades consistentes (ex: rad/s vs Hz); inverter rigidez e massa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o solver de autovalores generalizado no MATLAB",
                                  "subSteps": [
                                    "Abrir MATLAB e carregar as matrizes [K] e [M] do script anterior.",
                                    "Usar o comando [V, D] = eig(K, M) para obter autovetores [V] e autovalores [D].",
                                    "Alternativamente, implementar QR algorithm manualmente para problema padrão (K*u = λ*M*u → resolver padrão).",
                                    "Ordenar autovalores crescentes usando sort() e reorganizar autovetores correspondentes.",
                                    "Armazenar resultados em variáveis: omega_quad = diag(D), phi = V."
                                  ],
                                  "verification": "Verificar cond(V'*M*V) ≈ I (ortonormalidade) e autovalores reais positivos.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": "MATLAB com toolbox de álgebra linear, tutorial eig() oficial MathWorks.",
                                  "tips": "Use eig(K,M) para problema generalizado; evite eig(K) se M não for identidade.",
                                  "learningObjective": "Dominar a implementação numérica de autovalores para problemas dinâmicos.",
                                  "commonMistakes": "Confundir eig(A,B) com eig(A); não ordenar modos (frequências bagunçadas)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar autovalores como frequências e autovetores como modos",
                                  "subSteps": [
                                    "Calcular frequências naturais: f_i = sqrt(diag(D))/(2*pi) em Hz; ω_i = sqrt(diag(D)) em rad/s.",
                                    "Normalizar autovetores φ_i para massa unitária: φ_i' * M * φ_i = 1.",
                                    "Plotar modos de deformação usando bar() ou plot() para deslocamentos nodais.",
                                    "Identificar modo fundamental (menor frequência) e modos superiores.",
                                    "Comparar com solução analítica para o sistema simples (ex: fórmula exata para viga)."
                                  ],
                                  "verification": "Frequências coincidem com analítico dentro de 5%; modos mostram deformação física plausível.",
                                  "estimatedTime": "2 hours",
                                  "materials": "MATLAB plotting functions, papel para esboço manual de modos.",
                                  "tips": "Sempre divida por 2π para Hz; plote múltiplos modos em subplots para comparação.",
                                  "learningObjective": "Interpretar resultados matemáticos no contexto físico de vibrações estruturais.",
                                  "commonMistakes": "Interpretar λ diretamente como frequência (é λ = ω²); normalização errada leva a amplitudes inconsistentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar resultados e analisar sensibilidade",
                                  "subSteps": [
                                    "Comparar com software comercial (ex: ANSYS export) ou solução analítica.",
                                    "Testar convergência variando malha (mais DOF) e observar mudança em frequências.",
                                    "Analisar sensibilidade: alterar E ou ρ e recomputar modos.",
                                    "Verificar ortogonalidade: φ_i' * M * φ_j = 0 para i ≠ j.",
                                    "Documentar relatório com plots, tabelas de f_i e conclusões."
                                  ],
                                  "verification": "Erro < 2% vs referência; ortogonalidade confirmada numericamente.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": "MATLAB, referência analítica (ex: tabela de frequências de vigas).",
                                  "tips": "Use cond() para checar il-condição; refine malha se modos não convergirem.",
                                  "learningObjective": "Avaliar confiabilidade de soluções numéricas em análise modal.",
                                  "commonMistakes": "Ignorar modos rígidos (f=0); não testar com malha fina."
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de aço (L=5m, EI=1e6 kNm², ρA=100 kg/m) com 2 elementos finitos (4 DOF), monte [K] 4x4 e [M] 4x4, compute eig(K,M), obtenha f1≈3.5 Hz (flexão fundamental) e plote modo com deslocamento máximo na ponta.",
                              "finalVerifications": [
                                "Autovalores positivos e ordenados crescentemente.",
                                "Autovetores ortonormais em relação a [M].",
                                "Frequências em Hz coincidem com solução analítica dentro de 5%.",
                                "Modos mostram deformações físicas intuitivas (ex: flexão sem rotação espúria).",
                                "Código MATLAB executa sem erros e reproduz resultados consistentemente.",
                                "Análise de sensibilidade confirma robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro <3% vs analítico.",
                                "Correta interpretação: λ → ω → f, φ como modos.",
                                "Implementação limpa: código comentado e eficiente.",
                                "Validação completa: ortogonalidade e convergência.",
                                "Visualização clara: plots de modos com legendas.",
                                "Relatório conciso: tabelas, conclusões e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores generalizados, QR algorithm).",
                                "Programação: MATLAB scripting e numerical computing.",
                                "Física: Dinâmica de vibrações e equação de movimento Mẍ + Kx=0.",
                                "Engenharia Mecânica: Análise de elementos finitos (FEM).",
                                "Estatística: Análise de sensibilidade e erro numérico."
                              ],
                              "realWorldApplication": "Na análise modal de edifícios altos para projeto sísmico (normas ABNT NBR 15421), calcula-se frequências e modos para combinar cargas modais em resposta a terremotos, evitando ressonância e otimizando reforços estruturais."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.1.3",
                            "name": "Interpretar resultados em projetos estruturais",
                            "description": "Analisar os primeiros modos dominantes para prever respostas dinâmicas a sismos ou ventos, validando com normas como ABNT NBR 15422, e ajustando o projeto para evitar ressonâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e analisar os primeiros modos dominantes",
                                  "subSteps": [
                                    "Executar análise modal no software de elementos finitos para obter frequências naturais e formas modais.",
                                    "Listar os primeiros 3-5 modos (translacionais, rotacionais e torcionais).",
                                    "Plotar e interpretar as formas modais, identificando deslocamentos dominantes em cada andar ou elemento.",
                                    "Calcular massas modais e coeficientes de participação modal.",
                                    "Comparar frequências com faixas típicas para o tipo de estrutura (ex.: edifícios baixos > 2 Hz)."
                                  ],
                                  "verification": "Verificar se as frequências e formas modais estão plotadas corretamente e massas modais somam >90% da massa total.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software de análise estrutural (SAP2000, ETABS ou ANSYS), modelo finito da estrutura.",
                                  "tips": "Comece pelos modos de menor frequência, pois dominam a resposta dinâmica.",
                                  "learningObjective": "Compreender a contribuição dos modos dominantes na dinâmica estrutural.",
                                  "commonMistakes": "Ignorar modos torcionais ou superestimar modos de alta frequência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Prever respostas dinâmicas a sismos ou ventos",
                                  "subSteps": [
                                    "Obter espectros de resposta para sismos (ABNT NBR 15421) ou ventos (NBR 6123).",
                                    "Combinar modos usando SRSS ou CQC para obter respostas modais (deslocamentos, acelerações).",
                                    "Calcular fatores de amplificação dinâmica (R_d) baseados nas frequências modais.",
                                    "Avaliar drifts inter-andar e acelerações de piso para conforto e segurança.",
                                    "Simular resposta temporal se dados de accelerograma estiverem disponíveis."
                                  ],
                                  "verification": "Comparar drifts com limites normativos (ex.: <0.02h para sismos) e plotar respostas modais.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Espectros normativos (ABNT NBR 15421/15422), accelerogramas de sismo, software de análise dinâmica.",
                                  "tips": "Use combinação CQC para estruturas com modos próximos; valide com SRSS para modos bem separados.",
                                  "learningObjective": "Aplicar modos modais para estimar respostas sob excitações dinâmicas.",
                                  "commonMistakes": "Não considerar coeficientes de participação ou usar combinação linear em vez de modal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar com normas técnicas como ABNT NBR 15422",
                                  "subSteps": [
                                    "Consultar NBR 15422 para requisitos de análise modal (massa efetiva >90%).",
                                    "Verificar se frequências fundamentais atendem critérios de regularidade estrutural.",
                                    "Calcular forças sísmicas equivalentes baseadas nos modos dominantes.",
                                    "Checar tensões e deformações contra limites de ductilidade e estados limites.",
                                    "Documentar conformidade em relatório com tabelas de modos e respostas."
                                  ],
                                  "verification": "Gerar relatório confirmando massa modal participativa >90% e drifts dentro dos limites da norma.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Norma ABNT NBR 15422 (PDF), planilhas Excel para cálculos auxiliares.",
                                  "tips": "Priorize modos que contribuem >5% da massa para economia computacional.",
                                  "learningObjective": "Garantir que a análise atenda padrões normativos brasileiros.",
                                  "commonMistakes": "Esquecer verificação de massa modal ou usar espectro inadequado para o solo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar o projeto para evitar ressonâncias",
                                  "subSteps": [
                                    "Identificar frequências próximas ao espectro de carga (ex.: pico sísmico).",
                                    "Propor modificações: aumentar rigidez (seções maiores), adicionar amortecedores ou mudar layout.",
                                    "Reanalisar o modelo modificado e comparar frequências pré/pós-ajuste.",
                                    "Verificar redução de drifts e acelerações em pelo menos 20%.",
                                    "Otimizar iterativamente até evitar ressonância (gap >20% na frequência)."
                                  ],
                                  "verification": "Frequências ajustadas com gap >20% do espectro e drifts reduzidos, confirmados por reanálise.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Software de modelagem, catálogos de seções estruturais, normas de dimensionamento.",
                                  "tips": "Use rigidez variável (ex.: contraventamentos) para sismos; massa para ventos.",
                                  "learningObjective": "Implementar ajustes práticos para mitigar riscos dinâmicos.",
                                  "commonMistakes": "Ajustes que criam novos modos torcionais ou aumentam massa sem necessidade."
                                }
                              ],
                              "practicalExample": "Em um edifício de 10 andares modelado no ETABS, identifique o 1º modo flexional em 1.2 Hz próximo ao pico sísmico de 1.0 Hz (NBR 15421). Calcule drifts de 0.025h, valide massa modal 92%, e ajuste aumentando rigidez das vigas em 30%, elevando frequência para 1.5 Hz e reduzindo drifts para 0.015h.",
                              "finalVerifications": [
                                "Massa modal participativa total >90%.",
                                "Frequências fundamentais com gap >20% do espectro de carga.",
                                "Drifts inter-andar < limites normativos (ex.: 0.02h SLS, 0.015h ULS).",
                                "Acelerações de piso < 0.15g para conforto humano.",
                                "Relatório documenta todos os modos dominantes e conformidades.",
                                "Reanálise pós-ajuste confirma ausência de ressonância."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de modos dominantes (frequências e formas corretas).",
                                "Correta aplicação de combinações modais (SRSS/CQC) e validação normativa.",
                                "Efetividade dos ajustes (redução quantificável de respostas dinâmicas).",
                                "Qualidade do relatório com plots, tabelas e justificativas.",
                                "Identificação e correção de potenciais ressonâncias.",
                                "Uso adequado de software e normas técnicas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aplicação de autovalores e autofunções em equações diferenciais.",
                                "Física: Princípios de dinâmica vibracional e teoria modal.",
                                "Programação: Scripts em Python/MATLAB para pós-processamento modal.",
                                "Gestão de Projetos: Integração de normas em ciclos de design iterativo."
                              ],
                              "realWorldApplication": "Em projetos de edifícios altos em zonas sísmicas como o Brasil (ex.: São Paulo), análise modal previne colapsos por ressonância, como visto no terremoto de Caruaru (2000), otimizando segurança e economia em estruturas como o Edifício Itália."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.6.2",
                        "name": "Análise de Vibrações em Estruturas",
                        "description": "Uso de autovalores para modelar vibrações livres e forçadas em sistemas multi-graus de liberdade, aplicados a vigas, lajes e torres em engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.2.1",
                            "name": "Modelar vibrações livres via problema de autovalores",
                            "description": "Derivar a equação Mẍ + Kx = 0, transformá-la em forma modal assumindo x = φ sin(ωt), e resolver o problema de autovalores para obter soluções analíticas e numéricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar a equação de movimento para vibrações livres",
                                  "subSteps": [
                                    "Relembrar as leis de Newton para sistemas multi-graus de liberdade (MDOF).",
                                    "Definir as matrizes de massa M e rigidez K para um sistema estrutural simples.",
                                    "Aplicar o princípio dos trabalhos virtuais ou Lagrange para obter Mẍ + Kx = 0.",
                                    "Verificar dimensionalmente a equação resultante.",
                                    "Discutir hipóteses: sem amortecimento, pequenas deformações lineares."
                                  ],
                                  "verification": "Equação derivada coincide com Mẍ + Kx = 0, com M e K simétricas positivas definidas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de dinâmica estrutural (ex: Chopra), papel e lápis, software simbólico como SymPy"
                                  ],
                                  "tips": "Comece com um sistema de 2 DOF para visualização intuitiva.",
                                  "learningObjective": "Compreender a origem física da equação governante de vibrações livres.",
                                  "commonMistakes": [
                                    "Confundir forças inerciais com elásticas",
                                    "Esquecer termos de acoplamento em M ou K"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Assumir forma modal e transformar a equação",
                                  "subSteps": [
                                    "Propor a solução harmônica x(t) = φ sin(ωt + θ), simplificando para sin(ωt).",
                                    "Calcular as derivadas temporais: ẋ = ω φ cos(ωt), ẍ = -ω² φ sin(ωt).",
                                    "Substituir na equação Mẍ + Kx = 0, resultando em (K - ω² M) φ sin(ωt) = 0.",
                                    "Concluir que sin(ωt) ≠ 0 implica (K - ω² M) φ = 0.",
                                    "Identificar isso como problema generalizado de autovalores."
                                  ],
                                  "verification": "Equação reduzida corretamente para (K - ω² M) φ = 0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou MATLAB/SymPy",
                                    "Exemplo de matrizes M e K de um sistema 2x2"
                                  ],
                                  "tips": "Use θ=0 para simplificar; generalize depois.",
                                  "learningObjective": "Dominar a separação variáveis espaciais e temporais em problemas dinâmicos.",
                                  "commonMistakes": [
                                    "Erro no sinal de ẍ (-ω²)",
                                    "Confundir φ vetorial com escalar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e resolver o problema de autovalores",
                                  "subSteps": [
                                    "Reescrever como K φ = ω² M φ (forma padrão).",
                                    "Para M=I (caso simples), resolver det(K - ω² I)=0 para autovalores ω².",
                                    "Calcular autofunções φ normalizadas (φ^T M φ =1).",
                                    "Construir solução geral: x(t) = Σ η_i(t) φ_i, com η_i = a_i sin(ω_i t + θ_i).",
                                    "Verificar ortogonalidade: φ_i^T M φ_j = 0 para i≠j."
                                  ],
                                  "verification": "Autovalores ω_i² positivos reais e autofunções ortogonais obtidas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de álgebra linear (MATLAB eig, Python scipy.linalg.eig)",
                                    "Exercícios de sistemas 2-3 DOF"
                                  ],
                                  "tips": "Normalizar com respeito a M para consistência.",
                                  "learningObjective": "Resolver problemas de autovalores generalizados analiticamente.",
                                  "commonMistakes": [
                                    "Não generalizar para M não-diagonal",
                                    "Autofunções não normalizadas levando a erros em modos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar soluções numéricas e validar",
                                  "subSteps": [
                                    "Codificar matrizes M e K para um sistema real (ex: viga com massas discretizadas).",
                                    "Usar função eig para obter [V, D] onde D=diag(ω²), V=φ.",
                                    "Simular resposta temporal x(t) para condições iniciais x(0), ẋ(0).",
                                    "Comparar com solução analítica para sistema pequeno.",
                                    "Plotar modos de vibração e verificar periodicidade."
                                  ],
                                  "verification": "Simulação numérica reproduz solução analítica com erro <1%.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Python (NumPy/SciPy/Matplotlib)",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use modeshapes animados para visualização.",
                                  "learningObjective": "Aplicar computacionalmente análise modal para validação.",
                                  "commonMistakes": [
                                    "Índices errados em loops de superposição modal",
                                    "Unidades inconsistentes em ω"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um edifício de 2 andares modelado como 2 massas ligadas por molas: M = diag(1000, 1200) kg, K = [2e5, -1e5; -1e5, 1.5e5] N/m. Derive Mẍ + Kx=0, resolva autovalores (ω1≈5.7 rad/s, ω2≈14.1 rad/s), e simule deslocamentos sob excitação inicial x(0)=[0.01,0] m.",
                              "finalVerifications": [
                                "Equação Mẍ + Kx=0 derivada corretamente de princípios físicos.",
                                "Forma modal x=φ sin(ωt) leva a problema de autovalores.",
                                "Autovalores e autofunções calculados analítica e numericamente coincidem.",
                                "Solução temporal geral construída e verificada por ortogonalidade.",
                                "Simulação numérica valida a análise modal.",
                                "Modos de vibração interpretados fisicamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da equação governante (20%)",
                                "Correta formulação e resolução do problema de autovalores (30%)",
                                "Implementação numérica sem erros de codificação (25%)",
                                "Validação comparativa analítica-numérica (15%)",
                                "Interpretação física dos modos e frequências (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear avançada (autovalores generalizados)",
                                "Física: Dinâmica clássica e oscilações harmônicas",
                                "Computação: Programação numérica e visualização (MATLAB/Python)",
                                "Engenharia Mecânica: Análise modal em máquinas rotativas"
                              ],
                              "realWorldApplication": "Análise de vibrações em pontes e edifícios durante terremotos, permitindo prever ressonâncias e otimizar projetos para evitar colapsos, como no caso da ponte Tacoma Narrows."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.2.2",
                            "name": "Simular vibrações forçadas com expansão modal",
                            "description": "Expandir a resposta forçada x(t) = Σ q_i(t) φ_i usando autofunções ortogonais, resolver equações modais desacopladas e superpor soluções para prever amplitudes em estruturas sob cargas dinâmicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema e obter a base modal",
                                  "subSteps": [
                                    "Defina o sistema estrutural com matrizes de massa [M] e rigidez [K].",
                                    "Resolva o problema de autovalores generalizado [K]φ = ω²[M]φ para obter frequências naturais ω_i e autofunções φ_i (primeiros N modos).",
                                    "Verifique a ortogonalidade: φ_i^T [M] φ_j = 0 e φ_i^T [K] φ_j = 0 para i ≠ j.",
                                    "Normalize as autofunções (ex: φ_i^T [M] φ_i = 1).",
                                    "Calcule massas modais m_i* = φ_i^T [M] φ_i."
                                  ],
                                  "verification": "As autofunções são ortogonais e normalizadas, com massas modais unitárias.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Matrizes [M] e [K] do modelo finito",
                                    "Software de álgebra linear (MATLAB, Python com SciPy)"
                                  ],
                                  "tips": "Use decomposição SVD para problemas não simétricos e selecione N=5-10 modos iniciais.",
                                  "learningObjective": "Compreender a extração da base modal para desacoplar o sistema.",
                                  "commonMistakes": "Ignorar a normalização, levando a escalas erradas nas massas modais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expandir a resposta forçada e a carga usando modos",
                                  "subSteps": [
                                    "Expanda o deslocamento: x(t) = Σ q_i(t) φ_i = [Φ] q(t), onde [Φ] contém φ_i.",
                                    "Expanda a força: F(t) = Σ Q_i(t) φ_i, com Q_i(t) = φ_i^T F(t) / m_i*.",
                                    "Premultiplique a equação de movimento [M]ẍ + [C]ẋ + [K]x = F(t) por φ_j^T.",
                                    "Use ortogonalidade para obter equações desacopladas.",
                                    "Inclua amortecimento modal: 2ζ_i ω_i para o i-ésimo modo."
                                  ],
                                  "verification": "As expansões modais reproduzem exatamente x e F para N modos suficientes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Autofunções [Φ]",
                                    "Função de carga F(t) conhecida (ex: harmônica)"
                                  ],
                                  "tips": "Para cargas localizadas, Q_i pode decair rapidamente com modos altos.",
                                  "learningObjective": "Aplicar expansão modal para transformar o problema acoplado em desacoplado.",
                                  "commonMistakes": "Esquecer de dividir por m_i* nas forças modais Q_i."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e resolver equações modais desacopladas",
                                  "subSteps": [
                                    "Escreva para cada modo i: m_i* ï.. + c_i* ï. + k_i* q_i = Q_i(t), com ω_i² = k_i*/m_i*, 2ζ_i ω_i = c_i*/m_i*.",
                                    "Para carga harmônica F(t)=F_0 cos(Ωt), resolva analiticamente q_i(t) = [Q_i(Ω)/(ω_i² - Ω² + i 2ζ_i ω_i Ω)] e^{iΩt} (forma complexa).",
                                    "Para cargas gerais, use integração numérica (Newmark, Runge-Kutta).",
                                    "Implemente em código para todos os modos.",
                                    "Calcule amplitudes estáticas e dinâmicas."
                                  ],
                                  "verification": "Cada q_i(t) satisfaz sua equação modal individual.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Equações modais derivadas",
                                    "Solver numérico (ode45 no MATLAB)"
                                  ],
                                  "tips": "Use forma complexa para harmônicos para evitar senos/cossenos manuais.",
                                  "learningObjective": "Resolver independentemente cada equação modal.",
                                  "commonMistakes": "Confundir frequências de excitação Ω com naturais ω_i em ressonância."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Superpor soluções modais e simular a resposta",
                                  "subSteps": [
                                    "Reconstrua x(t) = Σ φ_i q_i(t) para os N graus de liberdade.",
                                    "Plote deslocamentos, velocidades e acelerações no tempo e frequência.",
                                    "Analise convergência variando N (erros <1% com N=10).",
                                    "Compare com solução direta (full system) para validação.",
                                    "Identifique picos de amplitude perto de ressonâncias."
                                  ],
                                  "verification": "A resposta modal converge para a solução exata com N suficiente.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Soluções q_i(t)",
                                    "Ferramentas de plotagem (MATLAB plot, Python matplotlib)"
                                  ],
                                  "tips": "Monitore contribuição de cada modo; pare quando <1% do total.",
                                  "learningObjective": "Superpor modos para obter a resposta física completa.",
                                  "commonMistakes": "Usar poucos modos, subestimando amplitudes em baixas frequências."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e validar a simulação",
                                  "subSteps": [
                                    "Calcule fatores de amplificação |H(Ω)| = |x(Ω)/F(Ω)| por modo e total.",
                                    "Verifique conservação de energia ou equilíbrio dinâmico.",
                                    "Teste sensibilidade a ζ_i e Ω.",
                                    "Gere relatório com gráficos de resposta em frequência.",
                                    "Compare com dados experimentais ou analíticos simples."
                                  ],
                                  "verification": "Amplitudes em ressonância batem com teoria (1/(2ζ) para modo dominante).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Resultados de simulação",
                                    "Dados de referência (ex: viga Euler-Bernoulli)"
                                  ],
                                  "tips": "Use FFT para domínio de frequência e validar picos.",
                                  "learningObjective": "Interpretar resultados físicos da simulação modal.",
                                  "commonMistakes": "Ignorar amortecimento, prevendo amplitudes infinitas."
                                }
                              ],
                              "practicalExample": "Simule uma viga cantilever de 5m, seção 0.3x0.3m, E=30GPa, ρ=2500kg/m³, sob carga harmônica P(t)=10kN cos(2π*5t) na ponta, usando 6 primeiros modos. Plote deslocamento na ponta e verifique pico em ω1≈3.5Hz.",
                              "finalVerifications": [
                                "Resposta converge com N>5 modos (erro<2%).",
                                "Picos de amplitude ocorrem próximo às ω_i.",
                                "Fatores de amplificação dinâmica corretos (ex: >10 em ressonância).",
                                "Ortogonalidade preserva energia total.",
                                "Solução coincide com método direto para modelo pequeno.",
                                "Gráficos mostram decaimento modal correto."
                              ],
                              "assessmentCriteria": [
                                "Correta derivação de equações modais desacopladas (10pts).",
                                "Implementação numérica precisa e convergente (20pts).",
                                "Análise de amplitudes e ressonâncias (15pts).",
                                "Validação com convergência e referências (15pts).",
                                "Relatório com gráficos interpretativos (20pts).",
                                "Identificação de erros comuns evitados (10pts)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores, ortogonalidade).",
                                "Programação: Solvers numéricos e visualização (Python/MATLAB).",
                                "Física: Dinâmica e ondas em sólidos.",
                                "Engenharia Mecânica: Análise modal experimental.",
                                "Computação Científica: Elementos Finitos (geração de [M],[K])."
                              ],
                              "realWorldApplication": "Previsão de vibrações em pontes sob tráfego ou vento (ex: evitar ressonância como no Tacoma Narrows), edifícios sob terremotos ou máquinas em fundações, otimizando design para amplitudes seguras."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.2.3",
                            "name": "Aplicar em software de elementos finitos",
                            "description": "Utilizar ferramentas como ANSYS ou MATLAB para executar análise modal de vibrações em modelos 2D/3D de vigas ou pórticos, comparando resultados com métodos analíticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo geométrico da estrutura",
                                  "subSteps": [
                                    "Criar geometria 2D ou 3D da viga ou pórtico no módulo de design do ANSYS (DesignModeler ou SpaceClaim).",
                                    "Definir dimensões exatas: comprimento, seção transversal, apoios (ex: cantilever ou engastado-simples).",
                                    "Importar geometria de CAD se disponível ou desenhar primitivas (linhas/beams para 2D, sólidos para 3D).",
                                    "Verificar simetrias e simplificações para reduzir tempo computacional.",
                                    "Salvar e atualizar o modelo no Workbench."
                                  ],
                                  "verification": "Geometria visualmente correta e dimensões coincidem com especificações analíticas (±0.1%).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "ANSYS Workbench",
                                    "Computador com pelo menos 16GB RAM",
                                    "Especificações da estrutura (desenho técnico)"
                                  ],
                                  "tips": "Use beams para modelos 2D iniciais para simplicidade antes de 3D.",
                                  "learningObjective": "Dominar criação de geometrias precisas para análise estrutural em FEM.",
                                  "commonMistakes": "Ignorar unidades consistentes (mm vs m) ou falhar em definir apoios corretos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir materiais, malha e condições de contorno",
                                  "subSteps": [
                                    "Atribuir propriedades: módulo de elasticidade (E), densidade (ρ), seção transversal (A, I).",
                                    "Gerar malha: usar elementos beam (BEAM188) para 2D ou SOLID185 para 3D, com refinamento nos apoios.",
                                    "Aplicar condições de contorno: fixações (engastado), livres ou elásticas.",
                                    "Verificar qualidade da malha (skewness <0.9, convergência em testes preliminares).",
                                    "Atualizar projeto no Mechanical."
                                  ],
                                  "verification": "Malha gerada sem erros, número de elementos >1000 para convergência, propriedades listadas corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Biblioteca de materiais ANSYS",
                                    "Calculadora para propriedades seccionais"
                                  ],
                                  "tips": "Teste malhas grosseiras primeiro para validar setup antes de refinar.",
                                  "learningObjective": "Configurar realisticamente materiais e malhas para simulações dinâmicas.",
                                  "commonMistakes": "Malha muito grosseira causando não-convergência ou esquecimento de massa inercial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e executar a análise modal",
                                  "subSteps": [
                                    "Inserir 'Modal' analysis no Mechanical.",
                                    "Definir número de modos (ex: 6-10 primeiros).",
                                    "Ativar 'Pre-Stressed' se houver carregamentos iniciais, senão análise livre.",
                                    "Definir opções de extração (Block Lanczos para eficiência).",
                                    "Executar solve e monitorar convergência."
                                  ],
                                  "verification": "Análise completa sem warnings/erros, tabela de frequências gerada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Licença ANSYS Mechanical APDL (opcional para avançado)"
                                  ],
                                  "tips": "Aumente número de modos se estrutura complexa para capturar modos relevantes.",
                                  "learningObjective": "Executar extração de autovalores em software FEM para vibrações.",
                                  "commonMistakes": "Não especificar número suficiente de modos ou ignorar modos rígidos (frequência zero)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Pós-processamento e visualização dos resultados",
                                  "subSteps": [
                                    "Extrair frequências naturais e formas modais dos primeiros 3-5 modos.",
                                    "Animar formas modais para validar (ex: flexão vs torção).",
                                    "Exportar dados: frequências (Hz), vetores modais para MATLAB/Excel.",
                                    "Plotar gráficos de modo vs frequência.",
                                    "Salvar relatório com screenshots."
                                  ],
                                  "verification": "Formas modais animadas mostram deformações físicas esperadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB ou Excel para plots adicionais"
                                  ],
                                  "tips": "Use escala exagerada nas animações para visualizar deformações pequenas.",
                                  "learningObjective": "Interpretar e visualizar resultados modais de FEM.",
                                  "commonMistakes": "Confundir modos locais com globais ou escalas erradas em plots."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar resultados numéricos com analíticos",
                                  "subSteps": [
                                    "Calcular frequências analíticas: ω_n = (β_n L)^2 * sqrt(EI / μ L^4) para viga Euler-Bernoulli.",
                                    "Comparar % erro: |f_FEM - f_anal| / f_anal * 100 < 5%.",
                                    "Analisar formas modais qualitativamente (nós, antinós).",
                                    "Discutir discrepâncias (efeitos de cisalhamento, malha).",
                                    "Documentar em relatório com tabelas/gráficos."
                                  ],
                                  "verification": "Tabela de comparação mostra erro médio <3% para 3 primeiros modos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Fórmulas analíticas impressas",
                                    "MATLAB para cálculos simbólicos"
                                  ],
                                  "tips": "Use séries de Rayleigh-Ritz para validação intermediária se analítico complexo.",
                                  "learningObjective": "Validar simulações FEM contra soluções exatas.",
                                  "commonMistakes": "Erro em unidades (rad/s vs Hz) ou fórmulas analíticas incorretas."
                                }
                              ],
                              "practicalExample": "Análise modal de uma viga cantilever de aço: L=5m, seção 20cm x 30cm, E=200GPa, ρ=7800kg/m³. No ANSYS, modele com 200 elementos beam, extraia 5 modos. Analítico: f1≈15.8Hz (1º flexão). Compare erros e visualize 1º modo flexionante.",
                              "finalVerifications": [
                                "Frequências FEM dentro de 5% das analíticas para 3 primeiros modos.",
                                "Formas modais mostram deformações físicas corretas (flexão, torção).",
                                "Malha convergida (variação <2% ao refinar).",
                                "Relatório inclui tabelas, gráficos e animações exportadas.",
                                "Nenhum erro de solve ou warnings críticos.",
                                "Comparação discute fontes de erro (ex: hipóteses Euler vs Timoshenko)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da comparação FEM-analítico (erro <5%).",
                                "Qualidade e convergência da malha (orthogonalidade >0.2).",
                                "Correta interpretação de modos e frequências.",
                                "Documentação completa com visualizações claras.",
                                "Eficiência computacional (tempo solve <10min para modelo simples).",
                                "Análise de sensibilidade (variação malha/carregamento)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de autovalores e equações diferenciais (vibrações).",
                                "Física: Dinâmica de estruturas, teoria de ondas.",
                                "Programação: Scripts APDL/MATLAB para automação FEM.",
                                "Engenharia Mecânica: Análise de vibrações em máquinas.",
                                "Gestão de Projetos: Validação numérica em workflows de design."
                              ],
                              "realWorldApplication": "Em projetos de pontes e edifícios altos, análise modal FEM identifica frequências ressonantes para evitar falhas sísmicas ou eólicas, otimizando rigidez e amortecimento em estruturas como a Torre Burj Khalifa."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.6.3",
                        "name": "Estabilidade Computacional em Análises Estruturais",
                        "description": "Verificação da estabilidade numérica em simulações dinâmicas e não-lineares de estruturas usando autovalores para avaliar convergência e comportamento crítico.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.3.1",
                            "name": "Avaliar estabilidade via autovalores da matriz Jacobiana",
                            "description": "Em problemas não-lineares de estruturas, linearizar ao redor de um ponto equilíbrio, calcular autovalores da Jacobiana e determinar estabilidade (autovalores reais negativos indicam estabilidade).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o ponto de equilíbrio no sistema não-linear",
                                  "subSteps": [
                                    "Defina o sistema dinâmico não-linear como ẋ = f(x), onde x é o vetor de estado.",
                                    "Resolva f(x) = 0 para encontrar pontos de equilíbrio x*. Use métodos numéricos se analítico não for possível.",
                                    "Verifique se o ponto é isolado e relevante para o problema estrutural (ex.: configuração de equilíbrio de uma treliça).",
                                    "Documente as equações do modelo físico, como forças restauradoras não-lineares em estruturas.",
                                    "Teste perturbações pequenas ao redor de x* para confirmar equilíbrio aproximado."
                                  ],
                                  "verification": "Confirme que f(x*) ≈ 0 (erro < 1e-6) e plote trajetórias iniciais próximas que retornam a x*.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de cálculo simbólico (SymPy ou MATLAB), papel e lápis para esboços"
                                  ],
                                  "tips": "Comece com sistemas de baixa dimensão (2D) para intuição visual.",
                                  "learningObjective": "Formular e localizar pontos de equilíbrio em modelos não-lineares de estruturas.",
                                  "commonMistakes": [
                                    "Ignorar múltiplos equilíbrios; confundir equilíbrio estático com dinâmico."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e calcular a matriz Jacobiana no ponto de equilíbrio",
                                  "subSteps": [
                                    "Compute a Jacobiana J = ∂f/∂x avaliada em x*, onde cada elemento J_ij = ∂f_i/∂x_j.",
                                    "Use diferenciação analítica para termos não-lineares (ex.: sin(θ) → cos(θ) no equilíbrio).",
                                    "Implemente numericamente via diferenças finitas se analítico complexo: J_ij ≈ [f(x* + ε e_j) - f(x*)] / ε.",
                                    "Verifique simetria ou propriedades da matriz para problemas estruturais (ex.: Jacobiana Hessiana em otimizações).",
                                    "Armazene J como matriz numérica para próximos passos."
                                  ],
                                  "verification": "Compare derivadas analíticas e numéricas; norma da diferença < 1e-4.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB, calculadora simbólica"
                                  ],
                                  "tips": "Use funções automáticas de diferenciação em software para evitar erros manuais.",
                                  "learningObjective": "Linearizar sistemas não-lineares computando corretamente a Jacobiana em equilíbrio.",
                                  "commonMistakes": [
                                    "Avaliar J em ponto errado; erros de sinal em derivadas parciais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os autovalores da matriz Jacobiana",
                                  "subSteps": [
                                    "Aplique o método do polinômio característico: det(J - λI) = 0.",
                                    "Use solvers numéricos: eig() no MATLAB ou numpy.linalg.eig() no Python.",
                                    "Ordene autovalores por parte real (Re(λ)) e identifique os com maior parte real.",
                                    "Compute autovetores associados para modos de instabilidade se necessário.",
                                    "Valide com métodos alternativos (ex.: QR algorithm manual para matrizes pequenas)."
                                  ],
                                  "verification": "Verifique que J * v = λ v para autovetores principais; residual < 1e-8.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python/NumPy/SciPy, MATLAB, ou biblioteca LAPACK"
                                  ],
                                  "tips": "Para matrizes grandes, use decomposição SVD como aproximação para autovalores reais.",
                                  "learningObjective": "Extrair autovalores de forma precisa e eficiente da Jacobiana.",
                                  "commonMistakes": [
                                    "Confundir autovalores com autovetores; ignorar autovalores complexos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar autovalores e determinar estabilidade",
                                  "subSteps": [
                                    "Examine partes reais: se todos Re(λ) < 0, estável; se algum Re(λ) > 0, instável; Re(λ)=0, marginal.",
                                    "Classifique: atrator (estável), repulsor (instável), sela (híbrido).",
                                    "Interprete no contexto estrutural: Re(λ)>0 indica colapso buckling.",
                                    "Simule dinâmica linearizada ẏ = J y para visualizar trajetórias.",
                                    "Documente conclusões com gráficos de fase ou simulações."
                                  ],
                                  "verification": "Simulações mostram convergência/divergência consistente com análise.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de simulação (ODE solvers em SciPy/MATLAB), ferramentas de plotagem"
                                  ],
                                  "tips": "Foque no autovalor dominante (maior Re(λ)) para taxa de instabilidade.",
                                  "learningObjective": "Interpretar autovalores para julgar estabilidade em problemas de engenharia.",
                                  "commonMistakes": [
                                    "Esquecer parte imaginária (oscilações); generalizar linear para não-linear."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma treliça bi-dimensional com barras não-lineares sob carga axial. Equações: ẋ = v, v̇ = -k sin(θ) + P cos(θ), equilíbrio em θ=0. Jacobiana J = [[0,1],[-k cos(θ),0]] em θ=0 → J=[[0,1],[-k,0]]. Autovalores λ=±√(-k)i (estável oscilatório). Se P>k, Re(λ)>0 → instável (buckling).",
                              "finalVerifications": [
                                "Localiza corretamente pontos de equilíbrio numéricos/analíticos.",
                                "Computa Jacobiana com precisão verificada por múltiplos métodos.",
                                "Extrai e ordena autovalores corretamente.",
                                "Conclui estabilidade com justificativa baseada em Re(λ).",
                                "Simula dinâmica linearizada que confirma análise.",
                                "Aplica a um modelo estrutural realista sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (erro <1e-6).",
                                "Correta interpretação de estabilidade (100% acerto em casos teste).",
                                "Uso eficiente de ferramentas computacionais.",
                                "Documentação clara de passos e resultados.",
                                "Identificação de modos instáveis em exemplos estruturais.",
                                "Capacidade de estender a sistemas multi-DOF."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Polinômios característicos e decomposições.",
                                "Física/Mecânica: Dinâmica não-linear e bifurcações.",
                                "Controle de Sistemas: Análise de linearização para controlabilidade.",
                                "Otimização: Hessianas em problemas de estabilidade estrutural.",
                                "Programação Numérica: Solvers de autovalores e ODEs."
                              ],
                              "realWorldApplication": "Em engenharia civil, avalia estabilidade de pontes pênseis ou torres sob vento/vibrações não-lineares; previne colapsos como no Tacoma Narrows ao detectar Re(λ)>0 em modos flutter."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.3.2",
                            "name": "Detectar instabilidades em cargas críticas",
                            "description": "Aplicar análise de autovalores em buckling de colunas ou flambagem de placas, resolvendo [K + λKg]φ = 0 onde λ são cargas críticas de autovalores, prevendo colapso estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Estabilidade e Formulação do Problema de Autovalores",
                                  "subSteps": [
                                    "Estude os conceitos básicos de buckling em colunas (Euler) e flambagem em placas.",
                                    "Revise a equação generalizada de autovalores: [K + λKg]φ = 0, onde K é rigidez elástica, Kg é rigidez geométrica e λ é o multiplicador de carga crítica.",
                                    "Identifique que o menor autovalor positivo λ_cr indica a carga crítica de instabilidade.",
                                    "Analise modos de flambagem associados aos autovetores φ.",
                                    "Compare com soluções analíticas simples para validação conceitual."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a derivação da equação e interprete λ e φ em um diagrama simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Mecânica das Estruturas (ex: Hibbeler)",
                                    "Artigos sobre buckling Euler",
                                    "Vídeos tutoriais sobre análise de estabilidade"
                                  ],
                                  "tips": "Comece com casos 1D (coluna) antes de 2D (placa) para simplicidade.",
                                  "learningObjective": "Dominar a formulação matemática do problema de estabilidade via autovalores.",
                                  "commonMistakes": [
                                    "Confundir K (elástica) com Kg (geométrica)",
                                    "Ignorar sinal de λ (negativos indicam instabilidade imediata)",
                                    "Não normalizar autovetores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montar Matrizes de Rigidez K e Kg para Estruturas Simples",
                                  "subSteps": [
                                    "Discritize uma coluna ou placa usando elementos finitos (ex: barra para coluna, quadrilateral para placa).",
                                    "Calcule matriz K usando propriedades de material (E, A, I) e geometria.",
                                    "Formule Kg baseada nas tensões pré-cargas (N prévia) e derivadas geométricas.",
                                    "Monte o sistema global [K_global + λKg_global] via assembly de elementos.",
                                    "Verifique simetria e propriedades espectrais das matrizes."
                                  ],
                                  "verification": "Gere matrizes numéricas para um exemplo simples e confira com soluções analíticas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software MATLAB ou Python (NumPy)",
                                    "Planilhas Excel para montagem manual",
                                    "Tutoriais de Elementos Finitos (ex: Bathe)"
                                  ],
                                  "tips": "Use simetria para reduzir tamanho da matriz em estruturas regulares.",
                                  "learningObjective": "Construir corretamente as matrizes do problema eigenvalue para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Erros na assembly de elementos",
                                    "Fatorizar mal os esforços para Kg",
                                    "Unidades inconsistentes em K e Kg"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o Problema de Autovalores Numericamente",
                                  "subSteps": [
                                    "Implemente o solver eigenvalue em Python (scipy.linalg.eig) ou MATLAB (eigs).",
                                    "Aplique condições de contorno (ex: φ=0 em apoios) reduzindo o sistema.",
                                    "Extraia os N menores autovalores e autovetores.",
                                    "Escalone λ para cargas nominais (λ_cr * P_nominal).",
                                    "Plote modos de deformação para visualização."
                                  ],
                                  "verification": "Execute código para um caso conhecido e compare λ_cr com fórmula analítica (erro <5%).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com SciPy/NumPy",
                                    "MATLAB ou Octave",
                                    "Jupyter Notebook para prototipagem"
                                  ],
                                  "tips": "Use solvers para autovalores generalizados (eig genérico) em vez de padrão.",
                                  "learningObjective": "Implementar e executar análise de autovalores para detectar cargas críticas.",
                                  "commonMistakes": [
                                    "Não tratar autovalores complexos ou negativos",
                                    "Ignorar modos rígidos (λ=0)",
                                    "Solver não convergente por má condição das matrizes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Prever Instabilidades",
                                  "subSteps": [
                                    "Identifique o menor λ_cr >0 e calcule carga crítica P_cr = λ_cr * P_aplicada.",
                                    "Analise o modo φ_cr para forma de colapso esperada.",
                                    "Avalie fatores de segurança (P_design < P_cr / FS).",
                                    "Sensitividade: Varie parâmetros (E, seção) e reanalise.",
                                    "Valide com simulações não-lineares ou experimentos reportados."
                                  ],
                                  "verification": "Relatório com plots de modos e tabela de λ, justificando estabilidade da estrutura.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matplotlib/Paraview para visualização",
                                    "Relatórios de casos reais (ex: pontes colapsadas)"
                                  ],
                                  "tips": "Sempre cheque múltiplos modos para interações.",
                                  "learningObjective": "Interpretar autovalores para decisões de engenharia sobre colapso estrutural.",
                                  "commonMistakes": [
                                    "Interpretar λ maior como crítico (é o menor)",
                                    "Desconsiderar imperfeições reais",
                                    "Sobreestimar P_cr sem validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma coluna presa-livre de aço (A=10cm², I=100cm⁴, L=3m, E=200GPa), monte K e Kg com P axial nominal=100kN. Resolva [K + λKg]φ=0, obtenha λ_cr≈4.2, logo P_cr≈420kN. Plote modo sinusoidal confirmando teoria Euler.",
                              "finalVerifications": [
                                "Calcule λ_cr para coluna Euler com erro <2% vs analítico.",
                                "Interprete corretamente o primeiro modo de flambagem em plot.",
                                "Ajuste geometria e verifique variação proporcional de P_cr.",
                                "Explique impacto de apoios em λ_cr.",
                                "Compare com flambagem de placa simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na montagem de K e Kg (erro matricial <1%).",
                                "Correta implementação e convergência do solver eigenvalue.",
                                "Interpretação física precisa de λ e φ.",
                                "Análise de sensibilidade e fatores de segurança.",
                                "Relatório claro com visualizações e conclusões engenheirísticas.",
                                "Tempo de execução eficiente para malhas médias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Computacional: Solvers de autovalores (Álgebra Linear).",
                                "Física: Mecânica dos Sólidos e Teoria da Elasticidade.",
                                "Engenharia Mecânica: Vibrações e modos dinâmicos semelhantes.",
                                "Programação: NumPy/SciPy para análise numérica.",
                                "Gestão de Projetos: Avaliação de riscos em estruturas."
                              ],
                              "realWorldApplication": "Em projetos de edifícios altos, pontes pênseis ou torres eólicas, detectar λ_cr garante que cargas de vento ou peso próprio não causem buckling, prevenindo colapsos como o da Ponte Tacoma Narrows (embora torsional, similar em análise modal)."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Otimização e Programação Matemática",
                "description": "Técnicas de otimização e programação matemática aplicadas a problemas de engenharia civil.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Programação Linear",
                    "description": "Otimização de funções lineares sujeitas a restrições lineares, com formulação e resolução de problemas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1.1",
                        "name": "Formulação de Problemas de Programação Linear",
                        "description": "Processo de modelagem matemática de problemas de otimização em Engenharia Civil, definindo variáveis de decisão, função objetivo linear e restrições lineares de igualdade ou desigualdade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1.1",
                            "name": "Identificar variáveis de decisão",
                            "description": "Reconhecer e definir as variáveis contínuas ou inteiras que representam as quantidades a serem otimizadas, como quantidades de materiais em projetos de estruturas civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Variáveis de Decisão",
                                  "subSteps": [
                                    "Leia a definição de variáveis de decisão em programação linear: quantidades desconhecidas que representam escolhas a serem otimizadas.",
                                    "Identifique exemplos iniciais, como 'quantidade de cimento usada' em uma mistura de concreto.",
                                    "Diferencie variáveis de decisão de parâmetros fixos (dados conhecidos) e restrições.",
                                    "Anote as propriedades principais: não-negativas, contínuas ou inteiras.",
                                    "Revise um problema simples de otimização para mapear conceitos."
                                  ],
                                  "verification": "Explique em suas palavras o que são variáveis de decisão e dê um exemplo correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de programação linear ou PDF online; caderno e caneta.",
                                  "tips": "Use analogias cotidianas, como 'quantas fatias de pizza cada pessoa come' para fixar o conceito.",
                                  "learningObjective": "Dominar a definição e o papel das variáveis de decisão em problemas de PL.",
                                  "commonMistakes": "Confundir variáveis com objetivos (função objetivo) ou restrições."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Problema para Identificar Quantidades Otimizáveis",
                                  "subSteps": [
                                    "Leia o enunciado do problema várias vezes, destacando palavras como 'quantidade', 'número', 'volume' ou 'comprimento'.",
                                    "Liste todas as decisões que o tomador precisa fazer para otimizar (ex: quanto de cada material usar).",
                                    "Classifique as quantidades como controláveis pelo decisor (variáveis) vs. fixas (parâmetros).",
                                    "Crie um diagrama de fluxo ou tabela separando elementos do problema.",
                                    "Valide com perguntas: 'Isso varia para otimizar o custo/tempo?'."
                                  ],
                                  "verification": "Produza uma lista inicial de 3-5 quantidades potenciais de um problema dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplo de problema de engenharia civil impresso; software de diagramação como Draw.io.",
                                  "tips": "Procure verbos de ação no problema, como 'usar', 'alocar' ou 'produzir'.",
                                  "learningObjective": "Desenvolver habilidade para extrair variáveis potenciais de descrições verbais de problemas.",
                                  "commonMistakes": "Incluir constantes como variáveis ou ignorar variáveis implícitas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Notar as Variáveis Formalmente",
                                  "subSteps": [
                                    "Atribua símbolos matemáticos (ex: x1 para quantidade de aço, x2 para concreto).",
                                    "Especifique o domínio: x_i ≥ 0, contínua (real) ou inteira.",
                                    "Escreva definições claras: 'x1 = toneladas de cimento usadas'.",
                                    "Verifique unicidade: cada variável única e mensurável.",
                                    "Integre em uma formulação preliminar: objetivo e restrições."
                                  ],
                                  "verification": "Escreva notação formal para todas as variáveis identificadas em um problema exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de cálculo ou LaTeX para notação; calculadora.",
                                  "tips": "Use subscritos para clareza (x_{aço}, x_{concreto}) em problemas multivariáveis.",
                                  "learningObjective": "Capacitar a formalização precisa de variáveis de decisão.",
                                  "commonMistakes": "Notação ambígua ou esquecer não-negatividade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar as Variáveis Identificadas",
                                  "subSteps": [
                                    "Teste se as variáveis cobrem todas as decisões do problema.",
                                    "Simule valores extremos (zero, máximo) para checar viabilidade.",
                                    "Confirme tipo: contínua para volumes, inteira para unidades discretas.",
                                    "Compare com soluções modelo ou software de PL (ex: Excel Solver).",
                                    "Ajuste baseado em feedback: adicione/esclua variáveis."
                                  ],
                                  "verification": "Resolva um problema simples e confirme que as variáveis levam a uma solução ótima.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Excel com Solver ou Python (PuLP library); problema de teste.",
                                  "tips": "Sempre pergunte: 'Isso é ajustável para melhorar o objetivo?'",
                                  "learningObjective": "Garantir robustez na identificação através de validação prática.",
                                  "commonMistakes": "Sobredimensionar variáveis desnecessárias ou subestimar dependências."
                                }
                              ],
                              "practicalExample": "Em um projeto de fundação: x1 = metros cúbicos de concreto tipo A (contínuo), x2 = metros cúbicos de concreto tipo B (contínuo), x3 = número de estacas de aço (inteiro). Otimizar para minimizar custo sujeito a resistência mínima.",
                              "finalVerifications": [
                                "Lista todas as variáveis com definições claras e notação.",
                                "Classifica corretamente como contínuas/inteiras e não-negativas.",
                                "Integra variáveis em função objetivo e restrições sem erros.",
                                "Simulação com valores testa viabilidade.",
                                "Comparação com solução conhecida confirma completude.",
                                "Explicação oral demonstra compreensão conceitual."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação (90% das variáveis corretas).",
                                "Clareza e consistência na notação (sem ambiguidades).",
                                "Correta distinção entre contínuas/inteiras.",
                                "Completude: cobre todas decisões otimizáveis.",
                                "Validação prática via simulação ou software.",
                                "Ausência de erros comuns como inclusão de parâmetros fixos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e modelagem matemática.",
                                "Computação: Implementação em solvers como PuLP ou Gurobi.",
                                "Economia: Otimização de custos e alocação de recursos.",
                                "Gestão de Projetos: Planejamento de recursos em engenharia."
                              ],
                              "realWorldApplication": "Em estruturas civis, identificar variáveis como quantidades de aço e concreto permite otimizar custos em pontes ou edifícios, reduzindo desperdícios em até 20% via software de PL em firmas como Odebrecht ou AECOM."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.1.2",
                            "name": "Definir função objetivo linear",
                            "description": "Construir a expressão linear que representa o objetivo de maximização (ex.: lucro) ou minimização (ex.: custo de construção), utilizando coeficientes baseados em dados reais de engenharia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o problema e identificar o objetivo principal",
                                  "subSteps": [
                                    "Leia a descrição do problema de engenharia civil, como otimização de custos em uma obra.",
                                    "Identifique se o objetivo é maximização (ex.: maximizar durabilidade) ou minimização (ex.: minimizar custos).",
                                    "Extraia dados relevantes, como preços de materiais ou retornos esperados.",
                                    "Registre o objetivo em termos claros, como 'Minimizar custo total de construção'.",
                                    "Confirme que o objetivo é quantificável e linear."
                                  ],
                                  "verification": "Escreva uma declaração clara do objetivo e valide com um colega ou professor se atende aos critérios de linearidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Descrição do problema",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Sempre pergunte: 'O que queremos otimizar e por quê?' para evitar ambiguidades.",
                                  "learningObjective": "Compreender e articular o objetivo do problema de programação linear.",
                                  "commonMistakes": [
                                    "Confundir maximização com minimização",
                                    "Ignorar restrições iniciais do problema",
                                    "Definir objetivos não lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir as variáveis de decisão",
                                  "subSteps": [
                                    "Liste todas as decisões quantificáveis, como quantidades de materiais (ex.: x1 = toneladas de cimento, x2 = kg de aço).",
                                    "Garanta que as variáveis sejam não-negativas (x ≥ 0) para contextos reais de engenharia.",
                                    "Nomeie cada variável de forma descritiva e única.",
                                    "Verifique se as variáveis cobrem todos os aspectos do objetivo.",
                                    "Documente as unidades de medida para cada variável."
                                  ],
                                  "verification": "Crie uma tabela com variáveis, descrições e unidades; confira se são independentes e relevantes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Descrição do problema"
                                  ],
                                  "tips": "Use notação padrão: x1, x2... para simplicidade em formulações futuras.",
                                  "learningObjective": "Selecionar e notacionalizar variáveis de decisão de forma precisa e contextual.",
                                  "commonMistakes": [
                                    "Definir variáveis redundantes",
                                    "Omitir variáveis essenciais",
                                    "Esquecer restrições de não-negatividade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar os coeficientes baseados em dados reais",
                                  "subSteps": [
                                    "Colete dados reais de engenharia civil, como custo por unidade de material de fornecedores.",
                                    "Calcule os coeficientes para cada variável (ex.: c1 = R$ 500/ton de cimento).",
                                    "Some contribuições lineares para o objetivo (ex.: custo total = 500x1 + 2000x2).",
                                    "Valide os coeficientes com fontes confiáveis ou simulações.",
                                    "Ajuste para cenários reais, considerando inflação ou variações regionais."
                                  ],
                                  "verification": "Compare coeficientes calculados com dados de mercado; erro < 5% indica precisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabelas de preços de materiais (ex.: SINAPI para Brasil)",
                                    "Calculadora ou Excel"
                                  ],
                                  "tips": "Use dados atualizados; pesquise em sites como IBGE ou associações de engenharia.",
                                  "learningObjective": "Extrair e quantificar coeficientes lineares de dados empíricos de engenharia.",
                                  "commonMistakes": [
                                    "Usar dados fictícios em vez de reais",
                                    "Incluir termos não-lineares",
                                    "Erros de unidade nos coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e validar a função objetivo linear",
                                  "subSteps": [
                                    "Escreva a expressão: Max/Min Z = c1 x1 + c2 x2 + ... + cn xn.",
                                    "Substitua coeficientes e variáveis identificadas.",
                                    "Verifique linearidade: apenas somas de produtos constantes por variáveis.",
                                    "Teste com valores hipotéticos para confirmar sentido (ex.: aumento de x1 aumenta Z?).",
                                    "Documente a função final com explicação."
                                  ],
                                  "verification": "Resolva manualmente para um ponto e confirme se otimiza o objetivo declarado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de equações (ex.: LaTeX ou Word)",
                                    "Exemplo de problema resolvido"
                                  ],
                                  "tips": "Leia a função em voz alta para detectar erros lógicos.",
                                  "learningObjective": "Construir uma expressão matemática linear completa e validada.",
                                  "commonMistakes": [
                                    "Incluir constantes fora do contexto",
                                    "Esquecer o Max/Min",
                                    "Violar linearidade acidentalmente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma obra de laje de concreto: Minimizar Z = 500 x1 + 2000 x2, onde x1 = toneladas de cimento (R$500/ton), x2 = kg de aço (R$2/kg), baseado em cotações reais do SINAPI 2023.",
                              "finalVerifications": [
                                "A função é estritamente linear (sem potências ou produtos de variáveis).",
                                "Coeficientes derivam de dados reais de engenharia civil.",
                                "Objetivo (Max/Min) alinha com o problema descrito.",
                                "Variáveis cobrem todos os componentes do objetivo.",
                                "Teste numérico: Z muda monotonicamente com variáveis.",
                                "Unidades são consistentes (ex.: todos em Reais)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do objetivo (100% alinhado ao problema).",
                                "Correção das variáveis e coeficientes (erro < 10% em dados reais).",
                                "Linearidade comprovada na expressão final.",
                                "Uso de dados empíricos de engenharia (citação de fontes).",
                                "Clareza na documentação e validação.",
                                "Capacidade de testar e justificar a formulação."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise de custos e benefícios em projetos.",
                                "Estatística: Coleta e validação de dados reais.",
                                "Programação: Implementação em solvers como Excel Solver ou Python (PuLP).",
                                "Matemática Aplicada: Álgebra linear básica.",
                                "Gestão de Projetos: Otimização de recursos em engenharia."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, como minimizar custos de fundações em edifícios, onde funções objetivo lineares guiam alocação de concreto e aço, economizando até 15% em orçamentos reais, conforme cases da ABCP (Associação Brasileira de Cimento Portland)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.1.3",
                            "name": "Estabelecer restrições lineares",
                            "description": "Formular desigualdades ou igualdades lineares que capturam limitações físicas, como disponibilidade de recursos, normas de segurança ou balanços de massa em problemas de transporte ou alocação de recursos civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Restrições Lineares",
                                  "subSteps": [
                                    "Definir restrição linear como uma igualdade ou desigualdade do tipo ax + by + ... ≤ c, onde a, b, c são constantes e x, y variáveis de decisão.",
                                    "Diferenciar restrições de igualdade (ex: balanços exatos) de desigualdade (ex: limites de recursos).",
                                    "Identificar componentes: coeficientes, variáveis e lado direito (constante).",
                                    "Reconhecer restrições não-negativas (x ≥ 0).",
                                    "Estudar exemplos simples de disponibilidade de recursos."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a definição e componentes de uma restrição linear com um exemplo próprio.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de Programação Linear (capítulo de formulação)",
                                    "Vídeos introdutórios no YouTube sobre PL",
                                    "Folha de papel e caneta para anotações"
                                  ],
                                  "tips": "Sempre verifique se a expressão é linear: sem produtos de variáveis ou funções não-lineares.",
                                  "learningObjective": "Dominar a definição e estrutura matemática de restrições lineares.",
                                  "commonMistakes": [
                                    "Incluir termos quadráticos como x²",
                                    "Confundir variáveis de decisão com constantes",
                                    "Esquecer restrições de não-negatividade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Restrições em Problemas de Engenharia Civil",
                                  "subSteps": [
                                    "Analisar um problema descritivo: leia cenários de transporte ou alocação de recursos.",
                                    "Mapear limitações físicas: recursos disponíveis, normas de segurança, balanços de massa.",
                                    "Classificar restrições: por tipo de recurso (ex: concreto, mão de obra) ou norma (ex: carga máxima).",
                                    "Listar todas as limitações relevantes no problema.",
                                    "Priorizar restrições tecnicamente viáveis e lineares."
                                  ],
                                  "verification": "Listar pelo menos 4 restrições potenciais de um problema de alocação de recursos em construção civil fornecido.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Casos de estudo em Engenharia Civil (ex: otimização de mix de concreto)",
                                    "Planilha Excel para listar restrições",
                                    "Artigos sobre problemas de PL em obras civis"
                                  ],
                                  "tips": "Pergunte: 'Quais são os limites físicos ou regulatórios que impedem soluções ilimitadas?'",
                                  "learningObjective": "Desenvolver habilidade para detectar restrições em contextos reais de engenharia.",
                                  "commonMistakes": [
                                    "Ignorar restrições implícitas como não-negatividade",
                                    "Confundir limitações com objetivos",
                                    "Sobrestimar recursos disponíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Restrições Lineares a Partir de Descrições Verbais",
                                  "subSteps": [
                                    "Traduzir frases verbais em expressões matemáticas: ex: 'no máximo 100 toneladas de aço' → 2x + y ≤ 100.",
                                    "Definir variáveis claramente antes de formular.",
                                    "Garantir linearidade: usar somas ponderadas de variáveis.",
                                    "Incluir unidades consistentes nos coeficientes.",
                                    "Escrever múltiplas restrições interdependentes."
                                  ],
                                  "verification": "Formular 5 restrições lineares corretas para um problema completo de alocação de recursos civis.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exercícios resolvidos de PL em Engenharia Civil",
                                    "Software como LINGO ou Excel Solver para teste inicial",
                                    "Modelo de template para formulação"
                                  ],
                                  "tips": "Use tabelas para mapear recursos vs. variáveis antes de escrever as equações.",
                                  "learningObjective": "Converter descrições qualitativas em modelos matemáticos precisos e lineares.",
                                  "commonMistakes": [
                                    "Usar desigualdades erradas (≥ em vez de ≤ para limites superiores)",
                                    "Erros em coeficientes por unidade inconsistente",
                                    "Omitir variáveis relevantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar Restrições Formulares",
                                  "subSteps": [
                                    "Verificar linearidade e consistência matemática das restrições.",
                                    "Testar com valores extremos: soluções factíveis e infactíveis.",
                                    "Confrontar com o problema original: todas limitações cobertas?",
                                    "Ajustar com base em normas de segurança ou balanços reais.",
                                    "Documentar justificativa para cada restrição."
                                  ],
                                  "verification": "Validar um conjunto de restrições em um problema simulado, identificando e corrigindo erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Solver online (ex: Simplex method applet)",
                                    "Casos reais de otimização em transporte civil",
                                    "Checklist de validação"
                                  ],
                                  "tips": "Simule cenários: 'Se x=0, y deve satisfazer?' para testar.",
                                  "learningObjective": "Garantir que as restrições sejam corretas, completas e aplicáveis.",
                                  "commonMistakes": [
                                    "Aceitar restrições redundantes",
                                    "Não testar factibilidade básica",
                                    "Ignorar interdependências entre restrições"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de pavimentação rodoviária, com x km de asfalto tipo A e y km tipo B: restrição de asfalto disponível 'Total de asfalto ≤ 5000 toneladas, com 2 ton/km para A e 3 ton/km para B' → 2x + 3y ≤ 5000; restrição de segurança 'Carga por km ≥ 10 ton' → x + y ≥ 10.",
                              "finalVerifications": [
                                "Formulação correta de 5 restrições lineares a partir de um problema de alocação de recursos civis.",
                                "Identificação precisa de limitações físicas em cenários de engenharia.",
                                "Validação de factibilidade com testes numéricos simples.",
                                "Explicação clara da justificativa para cada restrição.",
                                "Ausência de termos não-lineares em todas as formulações.",
                                "Cobertura completa de normas de segurança e balanços de massa."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática e linearidade das restrições (sem erros algébricos).",
                                "Relevância e completude: todas limitações do problema capturadas.",
                                "Consistência de unidades e coeficientes realistas.",
                                "Clareza na definição de variáveis e justificativas.",
                                "Capacidade de validação e correção de erros.",
                                "Criatividade na aplicação a contextos civis reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Linear e Sistemas de Inequações.",
                                "Física: Balanços de Massa e Conservação de Recursos.",
                                "Economia: Otimização de Custos e Alocação Eficiente.",
                                "Gestão de Projetos: Planejamento de Recursos em Obras Civis.",
                                "Informática: Implementação em Solvers Computacionais."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, usado para otimizar alocação de materiais em construções de pontes ou rodovias, respeitando limites de orçamento, suprimentos e normas de segurança, como no planejamento de transporte de agregados ou mix de concreto em grandes obras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.1.2",
                        "name": "Interpretação Geométrica da Programação Linear",
                        "description": "Análise visual do problema em 2D ou 3D, identificando o poliedro factível, vértices e o ponto ótimo através do método gráfico.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.2.1",
                            "name": "Plotar região factível",
                            "description": "Desenhar o conjunto de soluções factíveis como um polígono convexo a partir das restrições lineares, destacando interseções e vértices em contextos como otimização de misturas de concreto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o problema e configurar o gráfico cartesiano",
                                  "subSteps": [
                                    "Identifique as variáveis de decisão (ex: x = proporção de cimento, y = proporção de areia).",
                                    "Desenhe os eixos x e y com escalas apropriadas baseadas nos limites das restrições.",
                                    "Marque os pontos de origem (0,0) e defina uma grade para facilitar a plotagem.",
                                    "Liste todas as restrições lineares do problema, incluindo não-negatividade (x ≥ 0, y ≥ 0).",
                                    "Escolha uma escala que acomode todas as interseções potenciais."
                                  ],
                                  "verification": "Confirme que os eixos estão rotulados corretamente com variáveis e unidades, e todas restrições estão listadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de graficação (GeoGebra, Desmos, Excel)",
                                    "Lápis, régua, calculadora"
                                  ],
                                  "tips": "Use uma escala 1:1 para simplicidade inicial; amplie se necessário para problemas com restrições apertadas.",
                                  "learningObjective": "Compreender as variáveis e preparar visualmente o espaço de soluções.",
                                  "commonMistakes": [
                                    "Escala inadequada que corta interseções",
                                    "Omitir restrições de não-negatividade",
                                    "Rótulos errados nos eixos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Plotar as linhas de restrição (equações lineares)",
                                  "subSteps": [
                                    "Para cada restrição, converta a desigualdade em igualdade (ex: ax + by = c).",
                                    "Calcule os interceptos x (y=0) e y (x=0) para cada linha.",
                                    "Trace a reta ligando os interceptos usando régua.",
                                    "Repita para todas as restrições, usando cores diferentes para distinguir.",
                                    "Verifique cálculos aritméticos dos interceptos."
                                  ],
                                  "verification": "Cada linha deve passar pelos interceptos calculados corretamente; teste com um ponto conhecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software",
                                    "Calculadora para interceptos"
                                  ],
                                  "tips": "Rotule cada linha com sua equação para referência rápida.",
                                  "learningObjective": "Graficar precisamente as fronteiras das restrições lineares.",
                                  "commonMistakes": [
                                    "Erro no cálculo de interceptos",
                                    "Linhas paralelas plotadas como convergentes",
                                    "Confundir coeficientes a/b"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar e sombrear a região factível para cada restrição",
                                  "subSteps": [
                                    "Para cada linha, teste um ponto de teste (ex: origem (0,0)) na desigualdade original.",
                                    "Se o ponto satisfaz, sombreie o lado incluindo o ponto; caso contrário, o outro lado.",
                                    "A região factível é a interseção de todas as meias-razes sombreadas.",
                                    "Sombreie levemente cada região individual primeiro, depois refine a interseção.",
                                    "Inclua as restrições de não-negatividade (primeiro quadrante)."
                                  ],
                                  "verification": "Todo ponto sombreado final deve satisfazer todas as desigualdades originais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel milimetrado",
                                    "Marcadores para sombreamento"
                                  ],
                                  "tips": "Use hachuras diferentes para cada restrição para visualizar sobreposições.",
                                  "learningObjective": "Identificar o lado correto de cada desigualdade e sua interseção.",
                                  "commonMistakes": [
                                    "Escolher lado errado do teste de ponto",
                                    "Ignorar sombreamento em restrições de não-negatividade",
                                    "Sombrear fora da interseção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar vértices, delinear o polígono e destacar características",
                                  "subSteps": [
                                    "Encontre pontos de interseção entre linhas adjacentes resolvendo sistemas 2x2.",
                                    "Liste todos os vértices da região (cantos do polígono convexo).",
                                    "Conecte os vértices em ordem para delinear o polígono factível.",
                                    "Destaque vértices com círculos ou labels.",
                                    "Verifique se o polígono é convexo e contém apenas pontos factíveis."
                                  ],
                                  "verification": "Todos vértices calculados satisfazem todas restrições; polígono fechado sem lacunas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou software para resolver interseções",
                                    "Marcadores para destaque"
                                  ],
                                  "tips": "Ordene vértices no sentido horário ou anti-horário para delinear facilmente.",
                                  "learningObjective": "Reconhecer a estrutura poligonal convexa da região factível.",
                                  "commonMistakes": [
                                    "Omitir vértices de interseção",
                                    "Incluir vértices não-factíveis",
                                    "Polígono não convexo por conexão errada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em otimização de misturas de concreto: x (kg de cimento), y (kg de areia). Restrições: x + 2y ≤ 100 (custo), 3x + y ≤ 150 (resistência), x ≥ 0, y ≥ 0. Plote as retas, sombreie a interseção (polígono com vértices (0,0), (0,50), (25,37.5), (50,0)) e destaque vértices para análise de misturas viáveis.",
                              "finalVerifications": [
                                "Região factível é um polígono convexo fechado no primeiro quadrante?",
                                "Todos vértices identificados e calculados corretamente?",
                                "Cada linha de restrição plotada com interceptos precisos?",
                                "Sombreamento cobre apenas pontos que satisfazem todas desigualdades?",
                                "Vértices destacados e listados com coordenadas?",
                                "Gráfico inclui labels claros para eixos, linhas e vértices?"
                              ],
                              "assessmentCriteria": [
                                "Precisão das linhas de restrição (±5% nos interceptos)",
                                "Correção do lado sombreado para cada desigualdade (teste de 3 pontos aleatórios)",
                                "Identificação completa e exata de todos vértices (erro <1 unidade)",
                                "Delineamento claro do polígono convexo sem erros de conexão",
                                "Clareza visual: labels, cores e sombreamento distintos",
                                "Verificação de factibilidade em pelo menos 2 pontos internos e vértices"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Resolução de sistemas de equações para vértices",
                                "Geometria Analítica: Polígonos convexos e interseções lineares",
                                "Engenharia de Materiais: Otimização de proporções em misturas",
                                "Computação Gráfica: Visualização de regiões em software CAD",
                                "Economia: Fronteiras de eficiência em alocação de recursos"
                              ],
                              "realWorldApplication": "Na engenharia civil, plotar a região factível permite visualizar combinações viáveis de cimento, areia e agregados sob restrições de custo, resistência e disponibilidade, auxiliando na seleção de misturas ótimas para fundações ou pavimentos antes de testes computacionais ou experimentais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2.2",
                            "name": "Avaliar soluções nos vértices",
                            "description": "Calcular o valor da função objetivo nos pontos extremos da região factível e identificar o ótimo localizando o vértice com o melhor valor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os vértices da região factível",
                                  "subSteps": [
                                    "Grafique todas as restrições de desigualdade no plano cartesiano, convertendo-as em equações de retas.",
                                    "Determine os pontos de interseção entre as retas das restrições e os eixos coordenados.",
                                    "Teste cada ponto de interseção para verificar se satisfaz todas as restrições (região sombreada).",
                                    "Liste todos os vértices extremos da poliedro convexo formado pela região factível.",
                                    "Confirme que não há vértices adicionais nas bordas ou origens."
                                  ],
                                  "verification": "Verifique se a lista de vértices coincide com os cantos da região sombreada no gráfico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel milimetrado, lápis, régua, calculadora",
                                  "tips": "Use cores diferentes para cada restrição para facilitar a visualização das interseções.",
                                  "learningObjective": "Compreender a formação geométrica da região factível e seus pontos extremos.",
                                  "commonMistakes": "Incluir pontos fora da região factível ou esquecer interseções com eixos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o valor da função objetivo em cada vértice",
                                  "subSteps": [
                                    "Escreva a função objetivo Z = c1*x + c2*y explicitamente.",
                                    "Substitua as coordenadas (x,y) de cada vértice na função Z.",
                                    "Realize os cálculos aritméticos com precisão para cada substituição.",
                                    "Registre o valor de Z ao lado de cada vértice em uma tabela organizada.",
                                    "Dobre-verifique os cálculos substituindo novamente um vértice aleatório."
                                  ],
                                  "verification": "Confira os valores de Z calculados comparando com uma segunda computação manual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora, tabela impressa ou planilha simples",
                                  "tips": "Crie uma tabela com colunas: Vértice (x,y), Z, para facilitar a organização.",
                                  "learningObjective": "Aplicar a função objetivo linear aos pontos extremos de forma precisa.",
                                  "commonMistakes": "Erro de sinal nos coeficientes ou aritmética básica nos cálculos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar valores e identificar o vértice ótimo",
                                  "subSteps": [
                                    "Ordene os valores de Z da tabela em ordem crescente ou decrescente, dependendo se é minimização ou maximização.",
                                    "Selecione o maior valor de Z para maximização ou o menor para minimização.",
                                    "Anote o vértice correspondente como solução ótima.",
                                    "Verifique se o vértice ótimo está dentro da região factível.",
                                    "Registre a solução ótima como (x*, y*) com Z*."
                                  ],
                                  "verification": "O vértice selecionado tem o valor extremo correto entre todos os calculados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Tabela de valores de Z",
                                  "tips": "Lembre-se: para maximizar, busque o Z máximo; para minimizar, o Z mínimo.",
                                  "learningObjective": "Reconhecer o teorema fundamental da programação linear na prática geométrica.",
                                  "commonMistakes": "Confundir maximização com minimização ou ignorar empates em valores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar a solução ótima",
                                  "subSteps": [
                                    "Substitua (x*, y*) nas restrições originais para confirmar factibilidade.",
                                    "Interprete o valor Z* no contexto do problema (ex: custo mínimo ou lucro máximo).",
                                    "Discuta possíveis sensibilidades, como mudança em coeficientes.",
                                    "Documente a solução completa com gráfico anotado e tabela.",
                                    "Resuma os insights geométricos observados."
                                  ],
                                  "verification": "Solução satisfaz todas restrições e otimiza Z corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Gráfico anotado, tabela final",
                                  "tips": "Sempre volte ao problema original para contextualizar o resultado.",
                                  "learningObjective": "Integrar avaliação geométrica com interpretação prática da otimização.",
                                  "commonMistakes": "Não verificar factibilidade ou ignorar o contexto do problema."
                                }
                              ],
                              "practicalExample": "Problema: Maximize Z = 3x + 4y sujeito a x + y ≤ 10, 2x + y ≤ 12, x ≥ 0, y ≥ 0. Vértices: (0,0) Z=0; (0,10) Z=40; (2,8) Z=44; (6,0) Z=18. Ótimo em (2,8) com Z=44.",
                              "finalVerifications": [
                                "Todos os vértices da região factível foram identificados corretamente.",
                                "Cálculos de Z em cada vértice estão precisos e sem erros aritméticos.",
                                "Vértice ótimo selecionado possui o valor extremo correto (máx/mín).",
                                "Solução é factível e satisfaz todas as restrições.",
                                "Gráfico e tabela documentam o processo visualmente.",
                                "Interpretação liga o resultado ao problema original."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de vértices (100% corretos).",
                                "Exatidão nos cálculos da função objetivo (erro <1%).",
                                "Correta seleção do vértice ótimo com justificativa.",
                                "Clareza na documentação gráfica e tabular.",
                                "Profundidade na interpretação contextual.",
                                "Eficiência no tempo e uso de recursos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Sistemas de desigualdades e soluções geométricas.",
                                "Computação: Implementação em solvers como Simplex ou Python (SciPy).",
                                "Economia: Otimização de recursos limitados em projetos.",
                                "Estatística: Análise de sensibilidade em cenários incertos."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, otimizar a mistura de cimento e agregados para minimizar custo sujeito a requisitos de resistência, avaliando combinações nos vértices da região factível para selecionar a proporção ideal de materiais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1.3"
                            ]
                          },
                          {
                            "id": "10.1.4.1.1.2.3",
                            "name": "Analisar dualidade geométrica",
                            "description": "Interpretar o problema dual geometricamente, relacionando sombras e separadores hiperplanos para problemas de alocação de mão de obra em obras civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar o problema primal geometricamente",
                                  "subSteps": [
                                    "Identifique as variáveis de decisão do problema primal de alocação de mão de obra (ex.: número de trabalhadores por tarefa).",
                                    "Desenhe o espaço de soluções viáveis plotando as restrições como retas ou hiperplanos em 2D para simplicidade.",
                                    "Localize os vértices do politopo viável e identifique a função objetivo como linhas de nível.",
                                    "Determine a solução ótima primal graficamente.",
                                    "Anote as restrições de mão de obra disponíveis (ex.: horas totais por tipo de trabalhador)."
                                  ],
                                  "verification": "Verifique se o gráfico mostra corretamente o politopo viável e a solução ótima no vértice correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora, software como GeoGebra ou Desmos.",
                                  "tips": "Comece com problemas em 2 variáveis para visualização clara antes de generalizar.",
                                  "learningObjective": "Compreender a geometria do problema primal em programação linear.",
                                  "commonMistakes": "Confundir restrições de desigualdade com igualdades; ignorar não-negatividade das variáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o problema dual",
                                  "subSteps": [
                                    "Escreva a função objetivo dual maximizando o produto das sombras (variáveis dual) pelas disponibilidades de recursos.",
                                    "Defina as restrições dual baseadas nos coeficientes das variáveis primais (uma por variável primal).",
                                    "Identifique as sombras como variáveis dual associadas a cada restrição primal de mão de obra.",
                                    "Verifique a transposição da matriz de coeficientes de restrições.",
                                    "Simplifique para o caso 2D, onde restrições dual são perpendiculares às primais."
                                  ],
                                  "verification": "Confirme que a formulação dual satisfaz o teorema de dualidade forte (objetivos iguais na ótica).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel, tabela de coeficientes do primal, software de otimização como Excel Solver.",
                                  "tips": "Use a regra mnemônica: 'primal min c x s.t. A x >= b; dual max b y s.t. A^T y <= c'.",
                                  "learningObjective": "Formular corretamente o problema dual a partir do primal.",
                                  "commonMistakes": "Inverter os sinais das desigualdades; errar a transposição da matriz A."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar sombras e separadores hiperplanos geometricamente",
                                  "subSteps": [
                                    "Visualize as sombras como gradientes ou normais aos hiperplanos de suporte das restrições primais.",
                                    "Desenhe o hiperplano separador dual que toca o ponto ótimo primal e separa-o do semi-espaço inviável.",
                                    "Relacione o valor da sombra à inclinação da reta de suporte (preço marginal do recurso).",
                                    "Analise como hiperplanos dual 'tocam' os vértices primais ótimos.",
                                    "Calcule numericamente uma sombra e valide graficamente sua interpretação."
                                  ],
                                  "verification": "O hiperplano dual deve suportar o ponto ótimo primal e coincidir com a direção da função objetivo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Gráfico do primal impresso, régua, software de plotagem vetorial como MATLAB ou Python Matplotlib.",
                                  "tips": "Pense nas sombras como 'forças de suporte' que empurram o politopo para a ótica.",
                                  "learningObjective": "Visualizar a dualidade como separadores hiperplanos e sombras marginais.",
                                  "commonMistakes": "Confundir direção do gradiente dual com primal; ignorar dualidade complementar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar análise dual a alocação de mão de obra em obras civis",
                                  "subSteps": [
                                    "Monte um exemplo: 2 tarefas (escavação, alvenaria), 2 trabalhadores (operários, supervisores), com disponibilidades.",
                                    "Resolva primal e dual, identificando sombras para horas de cada trabalhador.",
                                    "Interprete: sombra indica custo adicional por hora extra de mão de obra.",
                                    "Analise sensibilidade: como varia a ótica com mudança em disponibilidades.",
                                    "Discuta implicações para planejamento de canteiro de obras."
                                  ],
                                  "verification": "Sombras dual explicam corretamente a variação na solução ótima primal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplo numérico impresso, solver linear (Lingo, PuLP Python), gráficos comparativos.",
                                  "tips": "Use exemplos reais de obras: ex., 100h operários, 50h supervisores para 2 frentes.",
                                  "learningObjective": "Aplicar dualidade geométrica a problemas reais de engenharia civil.",
                                  "commonMistakes": "Não considerar não-negatividade das sombras; superestimar impacto de restrições não-binding."
                                }
                              ],
                              "practicalExample": "Em uma obra civil com duas tarefas: escavação (exige 3 operários e 1 supervisor por unidade) e alvenaria (2 operários e 2 supervisores). Disponíveis: 120h operários, 40h supervisores. Custo: R$10/escavação, R$15/alvenaria. Primal minimiza custo. Dual revela sombra de R$4/h para operários (escasso) e R$0 para supervisores (sobra), visualizado como hiperplano tocando o vértice ótimo.",
                              "finalVerifications": [
                                "Pode desenhar corretamente o politopo primal e seu hiperplano dual suportar.",
                                "Calcula sombras e interpreta como preços marginais de mão de obra.",
                                "Verifica dualidade forte numericamente e graficamente.",
                                "Identifica restrições binding e não-binding via geometria.",
                                "Aplica sensibilidade alterando disponibilidades e observa mudanças geométricas.",
                                "Explica relação sombras-hiperplanos em termos de separação ótima."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação primal-dual (100% coeficientes corretos).",
                                "Qualidade dos desenhos geométricos (hiperplanos alinhados corretamente).",
                                "Interpretação correta de sombras como valores marginais.",
                                "Análise de sensibilidade com variação de 10-20% em recursos.",
                                "Aplicação contextualizada a engenharia civil (alocação mão de obra).",
                                "Uso de terminologia precisa (ex.: 'separador hiperplano', 'sombra')."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Sombras como preços sombra em teoria de recursos escassos.",
                                "Gestão de Projetos: Otimização de alocação em cronogramas de obras (PERT/CPM).",
                                "Computação: Implementação em solvers como Simplex para visualização 3D.",
                                "Matemática Aplicada: Geometria convexa e teoria de separação de hiperplanos."
                              ],
                              "realWorldApplication": "Em canteiros de obras civis, analisa dualidade para priorizar contratação de mão de obra escassa (ex.: operários vs. supervisores), ajustando alocações em tempo real para minimizar atrasos e custos, prevendo impactos de greves ou faltas via sensibilidade de sombras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.1.3",
                        "name": "Resolução Algorítmica: Método Simplex",
                        "description": "Algoritmo iterativo para encontrar a solução ótima em problemas de dimensão superior, utilizando tabelas simplex e pivoteamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.3.1",
                            "name": "Montar tabela simplex inicial",
                            "description": "Converter o problema padrão em forma tabular, introduzindo variáveis de folga e artificial para restrições de desigualdade e igualdade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Padronizar o problema de programação linear",
                                  "subSteps": [
                                    "Identifique a função objetivo (maximizar ou minimizar) e escreva-a explicitamente.",
                                    "Liste todas as restrições de desigualdade e igualdade.",
                                    "Converta restrições ≥ para ≤ multiplicando por -1.",
                                    "Adicione restrições de não-negatividade para todas as variáveis de decisão (x_i ≥ 0).",
                                    "Escreva o problema na forma padrão: max Z = c x sujeito a A x ≤ b, x ≥ 0 (ou forma de igualdades)."
                                  ],
                                  "verification": "O problema está escrito com todas restrições em forma ≤ ou =, função objetivo clara e não-negatividade explícita.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de planilha (Excel/Google Sheets)",
                                    "Exemplo de problema de otimização"
                                  ],
                                  "tips": "Use maximização padrão; para minimização, multiplique por -1 e maximize.",
                                  "learningObjective": "Compreender e transformar qualquer problema LP em forma padrão para aplicação do método simplex.",
                                  "commonMistakes": [
                                    "Esquecer de converter restrições ≥",
                                    "Ignorar não-negatividade das variáveis",
                                    "Confundir maximização com minimização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir variáveis de folga e artificiais",
                                  "subSteps": [
                                    "Para cada restrição ≤, adicione uma variável de folga s_i ≥ 0 para formar igualdade (ex: ax ≤ b → ax + s_i = b).",
                                    "Para restrições =, adicione uma variável artificial a_i ≥ 0 (ex: ax = b → ax + a_i = b).",
                                    "Para restrições ≥ (após conversão), use folga negativa ou artificial conforme necessário.",
                                    "Rotule as variáveis: decisões (x), folgas (s), artificiais (a).",
                                    "Escreva a nova função objetivo: para artificiais, adicione -M a_i (M grande) para minimizar seu uso."
                                  ],
                                  "verification": "Todas restrições convertidas em igualdades com variáveis auxiliares corretamente introduzidas e rotuladas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Tabela de referência de variáveis auxiliares"
                                  ],
                                  "tips": "Folgas só para ≤; artificiais garantem base inicial factível.",
                                  "learningObjective": "Selecionar e introduzir corretamente variáveis auxiliares para formar sistema de igualdades.",
                                  "commonMistakes": [
                                    "Usar folga em restrição =",
                                    "Esquecer termo -M para artificiais na Z",
                                    "Não rotular variáveis claramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever o sistema de equações em forma matricial",
                                  "subSteps": [
                                    "Escreva todas as equações de restrições com coeficientes, variáveis e RHS (lado direito).",
                                    "Inclua a equação da função objetivo Z - c x = 0 (substitua Z=0 inicialmente).",
                                    "Ordene as equações: restrições primeiro, depois Z.",
                                    "Identifique coeficientes da matriz A (incluindo identidade para básicas).",
                                    "Verifique se o número de variáveis básicas = número de restrições."
                                  ],
                                  "verification": "Sistema de m+1 equações (m restrições + Z) escrito corretamente com todos coeficientes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha ou software como MATLAB/Octave para matriz",
                                    "Papel para esboço"
                                  ],
                                  "tips": "Mantenha ordem consistente: colunas para x1, x2, ..., s1, ..., a1, ..., b (RHS).",
                                  "learningObjective": "Representar o problema LP como sistema linear padrão para tabulação.",
                                  "commonMistakes": [
                                    "Erro nos coeficientes ao adicionar folgas/artificiais",
                                    "Esquecer equação Z",
                                    "RHS incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e verificar a tabela simplex inicial",
                                  "subSteps": [
                                    "Crie colunas: variáveis de decisão, folgas, artificiais, RHS, e linha Z.",
                                    "Preencha a matriz com coeficientes das equações.",
                                    "Marque variáveis básicas (folgas/artificiais) com identidade na base.",
                                    "Preencha linha Z com -c para variáveis não básicas, 0 para básicas.",
                                    "Verifique soma das linhas básicas reproduz linha Z e factibilidade (todos RHS ≥ 0)."
                                  ],
                                  "verification": "Tabela completa com base inicial factível (todos básicos ≥0 no RHS) e linha Z correta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela",
                                    "Ferramenta de otimização como Solver"
                                  ],
                                  "tips": "Use negrito ou destaque para colunas básicas.",
                                  "learningObjective": "Construir tabela simplex pronta para iterações.",
                                  "commonMistakes": [
                                    "Colocar coeficientes errados na linha Z",
                                    "Não verificar factibilidade inicial",
                                    "Confundir ordem das colunas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar a tabela inicial para iteração simplex",
                                  "subSteps": [
                                    "Confirme que variáveis básicas formam identidade na matriz.",
                                    "Verifique que todos valores no RHS são não-negativos.",
                                    "Calcule custos reduzidos (linha Z) para identificar variável entrante.",
                                    "Identifique pivô potencial (coluna com menor custo reduzido negativo).",
                                    "Simule uma iteração manual para testar consistência."
                                  ],
                                  "verification": "Tabela validada com base factível e pronta para primeira iteração simplex.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora ou software",
                                    "Tabela montada do step anterior"
                                  ],
                                  "tips": "Se houver artificiais com valor >0 após fase I, problema infactível.",
                                  "learningObjective": "Garantir que a tabela inicial atenda pré-condições do algoritmo simplex.",
                                  "commonMistakes": [
                                    "Ignorar artificiais positivas no RHS",
                                    "Custo reduzido incorreto na linha Z",
                                    "Não simular pivô"
                                  ]
                                }
                              ],
                              "practicalExample": "Problema: Maximize Z = 40x1 + 30x2 sujeito a  x1 + x2 ≤ 10, 2x1 + x2 ≤ 12, x1 + 2x2 ≤ 12, x1,x2 ≥ 0 (otimização de mistura de concreto: x1=kg cimento tipo1, x2=kg tipo2). Introduza s1,s2,s3. Equações: x1+x2+s1=10; 2x1+x2+s2=12; x1+2x2+s3=12; Z-40x1-30x2=0. Tabela: colunas x1,x2,s1,s2,s3,RHS; linhas restrições e Z.",
                              "finalVerifications": [
                                "Todas restrições convertidas corretamente em igualdades com folgas/artificiais.",
                                "Linha Z possui coeficientes -c nas não básicas e 0 nas básicas.",
                                "Todos valores RHS ≥ 0 (factibilidade inicial).",
                                "Matriz básica é identidade unitária.",
                                "Número de colunas = variáveis + RHS; linhas = restrições + Z.",
                                "Custos reduzidos calculados corretamente para identificar entrante.",
                                "Tabela reproduz o problema original ao somar linhas básicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na introdução de variáveis auxiliares (100% corretas).",
                                "Correção dos coeficientes em todas as linhas e colunas.",
                                "Factibilidade da base inicial verificada.",
                                "Clareza e organização da tabela (rótulos, formatação).",
                                "Capacidade de simular próxima iteração sem erros.",
                                "Tempo de montagem dentro do estimado.",
                                "Explicação verbal da conversão coerente."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Representação matricial e operações em sistemas lineares.",
                                "Computação: Implementação em planilhas ou linguagens como Python (SciPy.linprog).",
                                "Estatística: Modelagem de otimização em análise de dados e regressão.",
                                "Engenharia de Produção: Aplicações em planejamento de recursos e supply chain.",
                                "Economia: Modelos de otimização linear em alocação de recursos limitados."
                              ],
                              "realWorldApplication": "Em engenharia civil, montar tabela simplex inicial é essencial para otimizar projetos como alocação de materiais em obras (ex: minimizar custo de concreto sujeito a resistências e volumes), planejamento de cronogramas de construção com restrições de mão de obra e equipamentos, ou dimensionamento de estruturas com múltiplas cargas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1.3"
                            ]
                          },
                          {
                            "id": "10.1.4.1.1.3.2",
                            "name": "Executar iterações de pivoteamento",
                            "description": "Aplicar regras de seleção de linha e coluna para pivotar, avançando de base factível básica para básica ótima, verificando critério de otimalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar o critério de otimalidade",
                                  "subSteps": [
                                    "Examine a linha Z (função objetivo) no tableau atual.",
                                    "Identifique os coeficientes das variáveis não básicas na linha Z.",
                                    "Verifique se todos os coeficientes são não negativos (para maximização).",
                                    "Se todos forem ≥ 0, a solução é ótima; caso contrário, prossiga.",
                                    "Registre o status: ótima ou não ótima."
                                  ],
                                  "verification": "Confirme que todos coeficientes na linha Z para variáveis não básicas são ≥ 0; liste quaisquer negativos encontrados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tableau simplex atual impresso ou digital",
                                    "Lápis e papel para anotações"
                                  ],
                                  "tips": "Sempre comece pela linha Z; ignore variáveis básicas (devem ser zero).",
                                  "learningObjective": "Compreender e aplicar o critério de otimalidade para decidir se uma iteração é necessária.",
                                  "commonMistakes": [
                                    "Confundir variáveis básicas com não básicas",
                                    "Ignorar o sinal da função objetivo (max vs min)",
                                    "Não verificar todos os coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar a coluna de entrada (variável entrante)",
                                  "subSteps": [
                                    "Na linha Z, identifique os coeficientes negativos das variáveis não básicas.",
                                    "Escolha o coeficiente mais negativo (maior magnitude absoluta para min; mais negativo para max).",
                                    "Marque essa coluna como coluna pivot (variável entrante).",
                                    "Registre o nome da variável que entrará na base.",
                                    "Confirme que é uma variável não básica."
                                  ],
                                  "verification": "A coluna selecionada corresponde ao coeficiente mais negativo na linha Z; anote o valor e variável.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tableau simplex",
                                    "Calculadora para comparar magnitudes"
                                  ],
                                  "tips": "Em caso de empate, escolha arbitrariamente ou pela menor índice para consistência.",
                                  "learningObjective": "Aplicar a regra de seleção de coluna para maximizar o ganho na função objetivo.",
                                  "commonMistakes": [
                                    "Selecionar coeficiente positivo",
                                    "Escolher variável básica",
                                    "Usar magnitude errada (não absoluta)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar a linha de saída (variável saindo)",
                                  "subSteps": [
                                    "Na coluna pivot selecionada, examine os elementos das linhas de restrições (excluindo linha Z).",
                                    "Calcule as razões: elemento da coluna b / elemento da coluna pivot (apenas para elementos positivos no denominador).",
                                    "Identifique a menor razão positiva.",
                                    "Marque a linha correspondente como linha pivot (variável saindo).",
                                    "Registre a razão mínima e a variável."
                                  ],
                                  "verification": "Liste todas as razões calculadas; confirme a menor positiva e linha selecionada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tableau simplex",
                                    "Calculadora"
                                  ],
                                  "tips": "Ignore razões negativas ou zero; denominador deve ser >0.",
                                  "learningObjective": "Aplicar a regra de razão mínima para manter factibilidade.",
                                  "commonMistakes": [
                                    "Incluir razões negativas",
                                    "Dividir por zero ou negativo",
                                    "Esquecer de verificar positividade do denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar o pivoteamento",
                                  "subSteps": [
                                    "Identifique o elemento pivot (interseção linha e coluna pivot).",
                                    "Divida toda a linha pivot pelo elemento pivot para torná-lo 1.",
                                    "Para cada outra linha (incluindo Z), subtraia múltiplo da linha pivot para zerar o elemento na coluna pivot.",
                                    "Atualize todos os coeficientes nas linhas afetadas.",
                                    "Verifique se coluna pivot agora tem 1 na linha pivot e 0s elsewhere."
                                  ],
                                  "verification": "Confirme: elemento pivot =1, resto da coluna pivot =0; calcule novos valores b para factibilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tableau simplex em planilha ou papel quadriculado",
                                    "Calculadora"
                                  ],
                                  "tips": "Trabalhe linha por linha; use operações elementares da matriz.",
                                  "learningObjective": "Realizar transformações gaussianas para atualizar o tableau simplex.",
                                  "commonMistakes": [
                                    "Erros aritméticos em divisões/subtrações",
                                    "Não zerar corretamente a linha Z",
                                    "Alterar errado o vetor b"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar a nova base e preparar próxima iteração",
                                  "subSteps": [
                                    "Leia a nova solução básica factível do vetor b atualizado.",
                                    "Confirme que variáveis básicas correspondem às colunas com identidade unitária.",
                                    "Verifique se a nova linha Z tem o coeficiente da ex-variável saindo como zero.",
                                    "Avalie se o critério de otimalidade é satisfeito agora.",
                                    "Documente a iteração completa e avance se necessário."
                                  ],
                                  "verification": "Nova solução básica factível listada; tableau atualizado sem erros aritméticos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tableau atualizado",
                                    "Folha de registro de iterações"
                                  ],
                                  "tips": "Sempre valide factibilidade: b ≥0 e base identidade.",
                                  "learningObjective": "Interpretar o tableau pós-pivoteamento e decidir continuidade.",
                                  "commonMistakes": [
                                    "Ler solução errada do b",
                                    "Não detectar unboundedness ou degeneracy",
                                    "Ignorar verificação de identidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o problema: Max Z=3x1+5x2 s.t. x1+x2<=4, 2x1+x2<=12, x1,x2>=0. Tableau inicial: Linha Z: -3|-5|0|0|0; Rest1:1|1|1|0|4; Rest2:2|1|0|1|12. Iteração 1: Coluna pivot x2 (mais neg -5), razões 4/1=4 e 12/1=12 → linha1 pivot. Pivote: Nova linha1:1|1|1|0|4 → divide por1. Atualize outras. Resultado: Nova Z com ganhos positivos, prossiga.",
                              "finalVerifications": [
                                "Tableau final tem todos coeficientes Z ≥0 para maximização.",
                                "Solução básica ótima identificada corretamente do vetor b.",
                                "Todas iterações mantêm factibilidade (b≥0).",
                                "Nenhuma degenerescência ou unboundedness detectada.",
                                "Valor Z ótimo calculado e comparado manualmente.",
                                "Base ótima listada com variáveis entrantes/saindo por iteração."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção de pivot (coluna e linha) em todas iterações.",
                                "Cálculos aritméticos corretos no pivoteamento (erro <1%).",
                                "Manutenção consistente de factibilidade em cada step.",
                                "Interpretação correta do critério de otimalidade.",
                                "Eficiência: completa em ≤1 hora para problema médio.",
                                "Documentação clara de razões, pivots e soluções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (operações gaussianas).",
                                "Programação: Implementar Simplex em Python (biblioteca PuLP ou scipy.optimize).",
                                "Engenharia Civil: Otimização de alocação de recursos em obras (ex: mistura de concreto).",
                                "Estatística: Sensibilidade e análise pós-ótima.",
                                "Economia: Modelagem de custos em projetos de infraestrutura."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para otimizar portfólios de projetos, alocação de mão-de-obra e materiais em canteiros de obra, minimizando custos sob restrições de tempo e recursos, como no planejamento de misturas de concreto ou escalonamento de equipamentos pesados."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.1.3.3",
                            "name": "Interpretar solução simplex em MATLAB",
                            "description": "Implementar e resolver problemas de programação linear usando a função linprog do MATLAB, analisando resultados em cenários de engenharia civil como planejamento de cronogramas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Executar linprog e capturar saídas essenciais",
                                  "subSteps": [
                                    "Definir coeficientes do problema: função objetivo (f), restrições de desigualdade (A, b), igualdade (Aeq, beq), limites (lb, ub).",
                                    "Chamar a função linprog(f, A, b, Aeq, beq, lb, ub, options) com options para ativar saída detalhada (ex: options = optimoptions('linprog','Display','iter')).",
                                    "Capturar retornos: x (solução), fval (valor objetivo), exitflag (status), output (informações iterativas), lambda (multiplicadores).",
                                    "Examinar output.iterations para número de pivôs simplex realizados.",
                                    "Salvar saídas em variáveis para análise subsequente."
                                  ],
                                  "verification": "Verifique se todas as saídas (x, fval, exitflag, output, lambda) foram geradas sem erros e output.iterations > 0.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "MATLAB instalado com Optimization Toolbox",
                                    "Documentação linprog (doc linprog)",
                                    "Exemplo de problema de PL pronto"
                                  ],
                                  "tips": "Use 'Display','iter' para ver progresso simplex; teste com problemas pequenos primeiro.",
                                  "learningObjective": "Compreender como invocar linprog e interpretar saídas iniciais do solver simplex.",
                                  "commonMistakes": [
                                    "Esquecer options para saída detalhada",
                                    "Definir incorretamente A/b (sinais errados em restrições)",
                                    "Ignorar exitflag antes de prosseguir"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar variáveis de decisão e solução ótima",
                                  "subSteps": [
                                    "Analisar vetor x: identificar variáveis básicas (x_i > 0 ou no limite ativo) vs. não básicas (x_i = 0).",
                                    "Comparar x com lb/ub para detectar variáveis no limite.",
                                    "Calcular folgas para restrições: slack = b - A*x para desigualdades.",
                                    "Verificar primal feasibility: todas slacks >= 0 e restrições iguais satisfeitas.",
                                    "Plotar x em gráfico para visualização (bar(x) ou scatter)."
                                  ],
                                  "verification": "Confirme que x satisfaz todas restrições (compute A*x <= b, etc.) e identifique pelo menos 80% das variáveis básicas corretamente.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "MATLAB",
                                    "Problema de exemplo com solução conhecida",
                                    "Funções auxiliares como bar() e sum()"
                                  ],
                                  "tips": "Use find(x > 0) para listar básicas; sempre normalize unidades de x para contexto físico.",
                                  "learningObjective": "Identificar e interpretar o significado físico das variáveis na solução simplex ótima.",
                                  "commonMistakes": [
                                    "Confundir variáveis básicas com não-negativas",
                                    "Não verificar feasibility após solução",
                                    "Ignorar limites lb/ub"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar valor objetivo, duals e sensibilidade",
                                  "subSteps": [
                                    "Examinar fval: calcular manualmente f'*x para validar.",
                                    "Interpretar lambda.ineqlin (preços sombra para desigualdades): valores >0 indicam restrições ativas vinculantes.",
                                    "Analisar lambda.eqnonlin e lambda.upper/lower para sensibilidade.",
                                    "Estimar faixa de variabilidade: para coeficientes c_i, use reduced costs (disponíveis em output se verbose).",
                                    "Discutir impacto: 'aumentar b_j em 1 unidade melhora fval em lambda_j'."
                                  ],
                                  "verification": "Valide fval manualmente e explique pelo menos 2 preços sombra em termos do problema.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "MATLAB",
                                    "Tabela de duals anotada",
                                    "Documentação sobre lambda em linprog"
                                  ],
                                  "tips": "Preços sombra só para restrições ativas; use abs(lambda) < 1e-6 para considerar zero.",
                                  "learningObjective": "Compreender duals e sensibilidade na interpretação simplex para decisões gerenciais.",
                                  "commonMistakes": [
                                    "Interpretar lambda sem verificar ativas",
                                    "Confundir primal/dual",
                                    "Não validar fval"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contextualizar solução em engenharia civil e validar status",
                                  "subSteps": [
                                    "Mapear x para cronograma: ex. x1=horas de escavação, x2=betonagem, etc.",
                                    "Verificar exitflag: 1=ótimo, 0=iter max, -2=inviável, etc.",
                                    "Analisar output: tempo CPU, iterações simplex, algoritmo usado (simplex confirm via 'Algorithm','dual-simplex').",
                                    "Simular mudança: re-otimizar com b alterado e comparar.",
                                    "Documentar relatório: solução, insights, recomendações para obra."
                                  ],
                                  "verification": "Gere relatório escrito explicando solução em termos de cronograma e valide exitflag=1.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "MATLAB",
                                    "Caso de estudo engenharia civil (cronograma obra)",
                                    "Template de relatório"
                                  ],
                                  "tips": "Sempre confirme 'Algorithm','interior-point' vs simplex; use dual-simplex para PL.",
                                  "learningObjective": "Aplicar interpretação simplex a cenários reais de planejamento em engenharia civil.",
                                  "commonMistakes": [
                                    "Ignorar exitflag !=1",
                                    "Não contextualizar numericamente",
                                    "Sobrepor simplex com outros solvers"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um cronograma de construção de edifício: minimizar custo total (f = [50, 60] para horas de escavação e estrutura) s.a. escavação <= 100h (b1), estrutura <= 120h (b2), total >= 150h. Solução x=[100,50], fval=8000, lambda.ineqlin=[20,0] indica que aumentar escavação em 1h economiza 20 unidades de custo.",
                              "finalVerifications": [
                                "Explicar corretamente exitflag e output.iterations para um problema dado.",
                                "Identificar todas variáveis básicas e folgas zero.",
                                "Calcular e validar fval e pelo menos um preço sombra.",
                                "Simular mudança em b e prever impacto via lambda.",
                                "Contextualizar solução em cronograma civil com unidades reais.",
                                "Gerar relatório com gráfico de x e insights acionáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de x e feasibility (90% correto).",
                                "Correta análise de duals/lambda e sensibilidade (com exemplos numéricos).",
                                "Validação completa de status (exitflag, output).",
                                "Profundidade contextual em engenharia civil (relevância prática).",
                                "Clareza em relatório e visualizações (gráficos, tabelas).",
                                "Eficiência: solução em <2x iterações esperadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Linear (sistemas Ax=b no tableau simplex).",
                                "Programação: Scripting MATLAB e otimização numérica.",
                                "Gestão de Projetos: Planejamento CPM/PERT com restrições.",
                                "Economia: Otimização de recursos escassos em obras.",
                                "Estatística: Análise de sensibilidade e intervalos de confiança."
                              ],
                              "realWorldApplication": "No planejamento de cronogramas de obras civis, como alocação ótima de mão-de-obra e equipamentos em projetos de pontes ou edifícios, minimizando custos e atrasos sob restrições de prazos e recursos limitados, permitindo ajustes rápidos baseados em preços sombra."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.3.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.1.3.4",
                            "name": "Tratar degenerescência e ciclagem",
                            "description": "Identificar e resolver casos de degenerescência no simplex, aplicando regra de Bland para evitar ciclagem infinita em problemas mal condicionados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Degenerescência e Ciclagem no Método Simplex",
                                  "subSteps": [
                                    "Defina degenerescência: situação em que uma ou mais variáveis básicas são zero na tabela simplex.",
                                    "Explique ciclagem: loop infinito causado por pivôs que não alteram o valor da função objetivo.",
                                    "Discuta impactos: atraso na convergência ou não convergência em problemas mal condicionados.",
                                    "Revise tableau simplex padrão e identifique posições básicas e não básicas.",
                                    "Estude exemplos teóricos de tableaux degenerados."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos e identifique degenerescência em um tableau exemplo fornecido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Programação Linear (ex: Hillier), vídeo tutorial sobre simplex, papel e caneta para anotações.",
                                  "tips": "Use diagramas visuais para representar o tableau e destacar variáveis zero básicas.",
                                  "learningObjective": "Dominar definições e causas de degenerescência e ciclagem.",
                                  "commonMistakes": "Confundir degenerescência com inviabilidade ou confundir ciclagem com oscilação finita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar Degenerescência em Tabelas Simplex",
                                  "subSteps": [
                                    "Construa ou analise um tableau simplex inicial de um problema LP.",
                                    "Identifique variáveis básicas com valor zero na coluna de solução básica.",
                                    "Calcule razões de Bland para colunas de entrada elegíveis (menor índice).",
                                    "Verifique múltiplas linhas com razão zero mínima.",
                                    "Registre o tableau degenerado e anote potenciais ciclos."
                                  ],
                                  "verification": "Marque corretamente todas as variáveis básicas zero em um tableau dado e liste razões zero.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software como Excel ou Python (SciPy.linprog), planilha com tableau exemplo, calculadora.",
                                  "tips": "Sempre numere colunas e linhas para aplicar índices de Bland facilmente.",
                                  "learningObjective": "Habilidade para diagnosticar degenerescência em qualquer tableau.",
                                  "commonMistakes": "Ignorar variáveis não básicas ou calcular razões incorretamente em linhas zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Regra de Bland para Evitar Ciclagem",
                                  "subSteps": [
                                    "Selecione variável de entrada: menor índice entre coeficientes negativos na função objetivo.",
                                    "Selecione variável de saída: menor índice entre linhas com razão mínima (incluindo zeros).",
                                    "Execute pivô conforme Bland e atualize o tableau.",
                                    "Repita iterações monitorando se o objetivo progride ou estabiliza.",
                                    "Compare com pivoteamento padrão para demonstrar prevenção de ciclo."
                                  ],
                                  "verification": "Execute 3 pivôs com Bland em um tableau degenerado e confirme ausência de loop.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Implementação manual em papel ou código Python/MATLAB para simplex, exemplos de problemas LP degenerados.",
                                  "tips": "Implemente uma função auxiliar para índices mínimos para automatizar seleção.",
                                  "learningObjective": "Implementar regra de Bland corretamente em cenários degenerados.",
                                  "commonMistakes": "Escolher variável de maior índice ou ignorar zeros em razões múltiplas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver Problema Completo com Degenerescência e Validar Solução",
                                  "subSteps": [
                                    "Escolha um problema LP conhecido por degenerescência (ex: max z = 3x1 + x2 s.t. restrições levando a zero básico).",
                                    "Aplique simplex com Bland do início ao fim.",
                                    "Verifique otimalidade: todos coeficientes objetivo não negativos.",
                                    "Teste perturbação léxica como alternativa e compare.",
                                    "Documente passos e solução final."
                                  ],
                                  "verification": "Obtenha solução ótima sem ciclagem e valide com solver padrão.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Problema exemplo impresso, solver online (ex: NEOS), notebook para registro.",
                                  "tips": "Salve tableaux intermediários para backtracking se ciclo ocorrer.",
                                  "learningObjective": "Resolver problemas reais mal condicionados com confiança.",
                                  "commonMistakes": "Parar prematuramente achando otimalidade falsa devido a degenerescência."
                                }
                              ],
                              "practicalExample": "Problema LP: Max z = 3x1 + x2 s.t. x1 <= 1, x2 <= 1, x1 + x2 <= 1.5 (degenerado). Tableau inicial tem xb2=0. Aplique Bland: entrada x1 (índice 1), saída xb3 (menor índice com razão 1). Pivôs subsequentes evitam ciclo, alcançando z=3 em (1,0.5).",
                              "finalVerifications": [
                                "Todas variáveis básicas no tableau final são positivas ou zero sem ciclos detectados.",
                                "Função objetivo não oscila em iterações repetidas.",
                                "Solução satisfaz todas restrições originais e otimalidade.",
                                "Regra de Bland aplicada corretamente em pelo menos 2 pivôs degenerados.",
                                "Comparação com método padrão confirma prevenção de ciclagem.",
                                "Documentação inclui todos tableaux intermediários."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de degenerescência (100% das variáveis zero identificadas).",
                                "Correta aplicação da regra de Bland em seleções de pivô (índices mínimos).",
                                "Número de iterações <= esperado para problema degenerado.",
                                "Solução final ótima e factível.",
                                "Explicação clara de como Bland evita ciclagem.",
                                "Tratamento de edge cases como múltiplas razões zero."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementar simplex em Python com NumPy para automação.",
                                "Análise Numérica: Perturbação e estabilidade em métodos iterativos.",
                                "Engenharia Civil: Otimização de estruturas com restrições degeneradas em alocação de materiais.",
                                "Estatística: Regressão linear com multicolinearidade análoga a degenerescência."
                              ],
                              "realWorldApplication": "Em engenharia civil, otimizar mix de concreto em projetos com restrições redundantes (degenerescência), evitando loops em solvers para planejamento eficiente de recursos em barragens ou pontes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Método Simplex",
                    "description": "Algoritmo iterativo para encontrar a solução ótima em problemas de programação linear.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Forma Canônica e Padrão do Problema de Programação Linear",
                        "description": "Representação padrão do problema de programação linear (PL) para aplicação do Método Simplex, incluindo conversão de desigualdades em igualdades com variáveis de folga e normalização do objetivo de maximização.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Formular um problema de PL em forma padrão",
                            "description": "Converter um problema de PL geral com desigualdades ≤, ≥ e = em forma padrão com apenas igualdades e variáveis não-negativas, introduzindo variáveis de folga, excedente e artificial quando necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o problema de programação linear original",
                                  "subSteps": [
                                    "Identifique a função objetivo (maximizar ou minimizar) e reescreva-a explicitamente.",
                                    "Liste todas as restrições, classificando-as como ≤, ≥ ou =.",
                                    "Anote todas as variáveis de decisão e confirme suas restrições de não-negatividade.",
                                    "Verifique se há restrições implícitas ou variáveis livres, convertendo-as se necessário.",
                                    "Esboce o problema em formato geral para referência."
                                  ],
                                  "verification": "Confira se todas as componentes (objetivo, restrições, variáveis) estão listadas corretamente sem omissões.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de texto; tabela para organizar restrições.",
                                  "tips": "Use cores diferentes para destacar tipos de restrições (azul para ≤, vermelho para ≥, verde para =).",
                                  "learningObjective": "Compreender a estrutura completa do problema de PL geral.",
                                  "commonMistakes": "Ignorar variáveis livres ou restrições de sinal implícitas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Padronizar a função objetivo",
                                  "subSteps": [
                                    "Se for minimização, multiplique por -1 para convertê-la em maximização.",
                                    "Escreva a função objetivo como Max Z = c1 x1 + ... + cn xn.",
                                    "Mantenha as variáveis de decisão originais sem alterações.",
                                    "Confirme que Z é a variável a ser maximizada.",
                                    "Anote a nova função objetivo ao lado da original."
                                  ],
                                  "verification": "A função deve estar no formato Max Z com coeficientes corretos; teste substituindo valores simples.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta; calculadora para verificação rápida.",
                                  "tips": "Lembre-se: min f(x) = - max -f(x); inverta apenas os coeficientes.",
                                  "learningObjective": "Transformar qualquer função objetivo em forma padrão de maximização.",
                                  "commonMistakes": "Esquecer de inverter o sinal ao converter minimização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Converter restrições ≤ e introduzir variáveis de folga",
                                  "subSteps": [
                                    "Para cada restrições ≤: adicione uma variável de folga si >= 0 para formar igualdade.",
                                    "Exemplo: ax + by <= c torna-se ax + by + si = c.",
                                    "Atribua um índice único para cada variável de folga (s1, s2, etc.).",
                                    "Verifique o sinal: folga sempre positiva no lado esquerdo.",
                                    "Liste todas as novas igualdades resultantes."
                                  ],
                                  "verification": "Substitua valores viáveis originais e confirme que as igualdades se mantêm.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado para alinhar coeficientes; tabela de restrições.",
                                  "tips": "Folga representa 'quanto falta para atingir o limite'; sempre >=0.",
                                  "learningObjective": "Aplicar variáveis de folga corretamente para restrições ≤.",
                                  "commonMistakes": "Colocar folga no lado errado ou esquecer >=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Converter restrições ≥ e = usando variáveis de excedente e artificiais",
                                  "subSteps": [
                                    "Para ≥: introduza variável de excedente ei >=0: ax + by - ei = c.",
                                    "Para =: mantenha como está, mas planeje artificial ai >=0: ax + by + ai = c.",
                                    "Para restrições ≥ ou = sem base óbvia, adicione artificial ai >=0 à direita.",
                                    "Garanta todas as variáveis (decisão, folga, excedente, artificial) >=0.",
                                    "Reescreva todas as restrições como igualdades."
                                  ],
                                  "verification": "Confirme que todas restrições são = e sem negativos nos coeficientes de variáveis básicas iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta; matriz inicial para visualizar coeficientes.",
                                  "tips": "Excedente subtrai do excesso; artificial só para fase 1 do simplex.",
                                  "learningObjective": "Manipular restrições ≥ e = para forma padrão com auxiliares.",
                                  "commonMistakes": "Confundir sinal de excedente (deve ser subtraído) ou omitir artificiais em ≥/=."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Escrever e verificar o problema em forma padrão completa",
                                  "subSteps": [
                                    "Compile função objetivo e todas as igualdades em um sistema unificado.",
                                    "Liste todas as variáveis e suas restrições >=0.",
                                    "Formate como: Max Z = ... s.t. A x = b, x >=0.",
                                    "Realize uma verificação cruzada com pontos factíveis originais.",
                                    "Prepare para tabela simplex se aplicável."
                                  ],
                                  "verification": "O problema deve ter apenas =, todas vars >=0, e preservar factibilidade original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de texto ou software como MATLAB/Excel para formatação.",
                                  "tips": "Numerar linhas da matriz A para facilitar implementação computacional.",
                                  "learningObjective": "Finalizar e validar a formulação em forma padrão.",
                                  "commonMistakes": "Esquecer de listar novas variáveis na seção de não-negatividade."
                                }
                              ],
                              "practicalExample": "Problema original: Max Z = 3x1 + 5x2 s.t. 2x1 + 3x2 ≤ 12; x1 + 4x2 ≥ 6; x1 + x2 = 5; x1,x2 ≥ 0. Forma padrão: Max Z = 3x1 + 5x2 s.t. 2x1 + 3x2 + s1 = 12; x1 + 4x2 - s2 + a1 = 6; x1 + x2 + a2 = 5; todas vars ≥ 0.",
                              "finalVerifications": [
                                "Todas restrições convertidas para igualdades com coeficientes corretos.",
                                "Função objetivo em maximização sem alterações indevidas.",
                                "Variáveis de folga/excedente/artificiais introduzidas apenas onde necessário.",
                                "Todas variáveis listadas com >=0.",
                                "Factibilidade preservada: pontos originais satisfazem novas igualdades.",
                                "Matriz A tem dimensões corretas (m restrições, n+m vars)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tipos de restrições (100% corretas).",
                                "Correto uso de folga (+), excedente (-) e artificiais (+).",
                                "Ausência de erros de sinal ou omissões de variáveis.",
                                "Validação com pelo menos um ponto factível.",
                                "Clareza na apresentação da forma padrão final.",
                                "Preparação adequada para método simplex (base inicial viável com artificiais)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Representação matricial da forma padrão (A x = b).",
                                "Programação Computacional: Implementação em Python (PuLP) ou Excel Solver.",
                                "Engenharia Civil: Otimização de recursos em projetos de construção.",
                                "Estatística: Sensibilidade e análise pós-otimização."
                              ],
                              "realWorldApplication": "Em engenharia civil, formular problemas de otimização para alocação mínima de materiais em estruturas (ex.: minimizar custo de concreto sujeito a resistências ≥ requeridas e volumes = especificados), permitindo uso eficiente do Método Simplex em softwares como LINGO ou GAMS para projetos reais de pontes e edifícios."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Construir a tabela inicial Simplex",
                            "description": "Montar a tabela Simplex inicial a partir da forma padrão, identificando a função objetivo, coeficientes das restrições e coluna do vetor b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Converter o problema para a forma padrão",
                                  "subSteps": [
                                    "Escreva a função objetivo de maximização como z = c1 x1 + c2 x2 + ...",
                                    "Converta desigualdades ≤ em igualdades introduzindo variáveis de folga si ≥ 0 para cada restrição",
                                    "Garanta que todas as variáveis sejam ≥ 0 e o lado direito b ≥ 0",
                                    "Identifique o número total de variáveis (originais + folgas) e o número de restrições m",
                                    "Anote a matriz de coeficientes A das restrições originais"
                                  ],
                                  "verification": "Confirme que todas restrições estão como Ax + s = b, com s ≥ 0 e x ≥ 0",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplo de problema de programação linear"
                                  ],
                                  "tips": "Sempre verifique se b ≥ 0; se não, multiplique a restrição por -1 e ajuste",
                                  "learningObjective": "Entender a transformação para forma padrão com variáveis de folga",
                                  "commonMistakes": [
                                    "Esquecer de adicionar variáveis de folga",
                                    "Não converter ≥ para ≤ com folga negativa",
                                    "Ignorar x ≥ 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir variáveis básicas e estrutura das colunas",
                                  "subSteps": [
                                    "Liste todas as variáveis: x1, x2, ..., xm (folgas como básicas iniciais)",
                                    "Crie colunas para: Basis, x1, x2, ..., xn, s1, s2, ..., sm, b (RHS)",
                                    "Atribua as folgas s1 a sm como variáveis básicas iniciais",
                                    "Prepare a matriz identidade I_m para as colunas das folgas",
                                    "Defina o número de linhas: 1 (objetivo) + m (restrições)"
                                  ],
                                  "verification": "Verifique se há m variáveis básicas (folgas) e colunas totais n + m + 2 (basis + b)",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para contagem de variáveis"
                                  ],
                                  "tips": "Use abreviações como x1, s1 para economizar espaço na tabela",
                                  "learningObjective": "Identificar corretamente variáveis básicas e layout da tabela",
                                  "commonMistakes": [
                                    "Confundir ordem das colunas",
                                    "Esquecer coluna Basis",
                                    "Não incluir todas as folgas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preencher a linha da função objetivo",
                                  "subSteps": [
                                    "Na primeira linha, Basis = z, RHS = 0",
                                    "Coloque -c1, -c2, ..., -cn nas colunas x1 a xn (para maximização)",
                                    "Coloque 0 nas colunas das folgas s1 a sm",
                                    "As folgas não entram na base da objetivo inicialmente",
                                    "Confirme que a linha representa -z + c x = 0"
                                  ],
                                  "verification": "A soma dos coeficientes da objetivo multiplicados pelas variáveis deve igualar -z",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo resolvido de tabela Simplex"
                                  ],
                                  "tips": "Lembre-se: para maximização, use coeficientes negativos na linha z",
                                  "learningObjective": "Montar corretamente a linha da função objetivo no tableau",
                                  "commonMistakes": [
                                    "Usar +c em vez de -c",
                                    "Colocar valores nas colunas de folga",
                                    "Esquecer o sinal negativo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Preencher as linhas das restrições e finalizar a tabela",
                                  "subSteps": [
                                    "Para cada restrição i=1 a m: Basis = si, preencha coeficientes de A na linha i para x1..xn",
                                    "Coloque 1 na coluna si correspondente (identidade)",
                                    "0 nas outras colunas de folga",
                                    "Coluna b: valores do vetor b na RHS",
                                    "Verifique se as colunas das básicas formam identidade"
                                  ],
                                  "verification": "Confirme que a tabela é factível inicial (b ≥ 0 e básicas formam I)",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software como Excel para protótipo opcional"
                                  ],
                                  "tips": "Copie os coeficientes de A com cuidado; use régua para alinhar",
                                  "learningObjective": "Construir a matriz de restrições com base identidade para básicas",
                                  "commonMistakes": [
                                    "Erro de transposição em A",
                                    "Colocar 1 errado nas folgas",
                                    "b com sinal errado"
                                  ]
                                }
                              ],
                              "practicalExample": "Problema: Max z = 3x1 + 4x2 s.t. 2x1 + x2 <= 6 (s1), x1 + 2x2 <= 4 (s2), x1,x2>=0.\nTabela inicial:\nBasis | x1 | x2 | s1 | s2 | b\nz    | -3 | -4 |  0 |  0 | 0\ns1   |  2 |  1 |  1 |  0 | 6\ns2   |  1 |  2 |  0 |  1 | 4",
                              "finalVerifications": [
                                "Linha z tem coeficientes -c nas variáveis de decisão e 0 nas folgas",
                                "Colunas das folgas básicas formam matriz identidade",
                                "Valores b ≥ 0 em todas as restrições",
                                "Número de linhas = 1 + número de restrições",
                                "Coluna Basis lista z e as folgas corretamente",
                                "Nenhum coeficiente transposto incorretamente"
                              ],
                              "assessmentCriteria": [
                                "Correção na identificação de variáveis básicas e não básicas (100%)",
                                "Precisão nos coeficientes da função objetivo (-c para max)",
                                "Matriz de restrições com identidade nas básicas",
                                "Coluna RHS com valores b corretos e ≥0",
                                "Layout da tabela completo e legível",
                                "Verificação de factibilidade inicial"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Manipulação de matrizes e vetores",
                                "Programação Computacional: Implementação em Python (SciPy) ou MATLAB",
                                "Engenharia de Produção: Otimização de recursos limitados",
                                "Estatística: Sensibilidade em coeficientes",
                                "Economia: Modelagem de problemas de maximização de lucro"
                              ],
                              "realWorldApplication": "Em Engenharia Civil, otimizar a mistura de concreto minimizando custos (max lucro) sujeito a restrições de resistência e volume disponível, gerando a tabela inicial para iterar o Simplex e encontrar alocação ótima de materiais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Identificar variáveis básicas e não básicas",
                            "description": "Determinar as variáveis básicas (folgas iniciais) e não básicas na solução básica factível inicial da tabela Simplex.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de variáveis básicas e não básicas no método Simplex",
                                  "subSteps": [
                                    "Defina variáveis básicas como aquelas que formam uma base da matriz de coeficientes, correspondendo a colunas linearmente independentes (geralmente identidade unitária na tabela).",
                                    "Defina variáveis não básicas como as restantes, fixadas em zero na solução básica.",
                                    "Explique o papel das variáveis de folga na forma padrão: elas tornam a solução inicial factível.",
                                    "Diferencie solução básica factível (SBF) de não factível: todas básicas >=0.",
                                    "Revise a estrutura da tabela Simplex: linhas de restrições, coluna RHS (b), colunas de variáveis."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as definições e forneça um exemplo simples de base.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de papel, quadro branco ou software como Excel/LINGO para tabela.",
                                  "tips": "Lembre-se: número de básicas = número de restrições (m básicas em n+m variáveis).",
                                  "learningObjective": "Dominar definições fundamentais para identificação correta.",
                                  "commonMistakes": "Confundir folgas com variáveis de decisão; ignorar não-negatividade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter o problema de programação linear para forma padrão e adicionar folgas",
                                  "subSteps": [
                                    "Escreva o problema na forma canônica: max Z = c x, Ax <= b, x>=0.",
                                    "Adicione variáveis de folga s_i >=0 para cada restrição <=: Ax + s = b.",
                                    "Inclua equação Z - c x = 0.",
                                    "Verifique se o problema está na forma padrão com m equações e n+m variáveis.",
                                    "Confirme que as folgas iniciais são s_i = b_i >0 para factibilidade."
                                  ],
                                  "verification": "Mostre a forma padrão escrita com folgas explicitadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Problema de LP exemplo impresso ou digital.",
                                  "tips": "Sempre assuma b>=0 para SBF inicial; caso contrário, use fase 1.",
                                  "learningObjective": "Preparar o problema corretamente para tabela Simplex.",
                                  "commonMistakes": "Esquecer de adicionar folgas ou tratar >=/=/ adequadamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a tabela Simplex inicial e identificar as colunas básicas",
                                  "subSteps": [
                                    "Monte a tabela: colunas para Z, variáveis de decisão, folgas, RHS.",
                                    "Posicione coeficientes: linha Z com -c e 1 para Z; restrições com A e I (identidade para folgas).",
                                    "Identifique colunas unitárias (um 1 e zeros): essas são as básicas iniciais (folgas).",
                                    "Leia valores básicos do RHS nas linhas correspondentes às básicas.",
                                    "Liste não básicas: colunas sem base (variáveis de decisão e Z)."
                                  ],
                                  "verification": "Apresente a tabela completa com básicas marcadas (ex: asterisco nas colunas).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha Excel ou papel quadriculado para tabela.",
                                  "tips": "Use notação B para matriz básica; verifique det(B)=1 para identidade.",
                                  "learningObjective": "Construir tabela e reconhecer bases pela identidade.",
                                  "commonMistakes": "Erro na transcrição de coeficientes; confundir ordem das linhas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e listar variáveis básicas e não básicas na SBF inicial",
                                  "subSteps": [
                                    "Liste básicas: nomes (ex: s1, s2) e valores (RHS das suas linhas).",
                                    "Liste não básicas: todas as outras (x1=0, x2=0, etc.).",
                                    "Confirme factibilidade: todas básicas >=0.",
                                    "Calcule Z inicial: somatório c_b * b (folgas têm c=0, Z=0).",
                                    "Documente em formato: Básicas: [lista]; Não básicas: [lista]."
                                  ],
                                  "verification": "Forneça lista final e Z inicial correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela construída do step anterior.",
                                  "tips": "Básicas formam solução x_B = B^{-1} b; inicialmente I^{-1} b = b.",
                                  "learningObjective": "Extrair e validar a SBF inicial com precisão.",
                                  "commonMistakes": "Incluir Z como básica; listar valores errados do RHS."
                                }
                              ],
                              "practicalExample": "Problema: Max Z = 3x1 + 5x2 s.t. 2x1 + 3x2 <= 12 (s1), x1 + 2x2 <= 8 (s2), x1,x2>=0. Tabela inicial: Básicas: s1=12, s2=8; Não básicas: x1=0, x2=0, Z=0.",
                              "finalVerifications": [
                                "Número de básicas equals número de restrições.",
                                "Colunas básicas formam identidade unitária.",
                                "Todos valores básicos (RHS) são >=0.",
                                "Z inicial calculado corretamente (0 para folgas).",
                                "Lista completa de não básicas inclui todas variáveis restantes.",
                                "Solução factível confirmada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de básicas (100% corretas).",
                                "Correta construção da tabela inicial sem erros de coeficientes.",
                                "Explicação clara de conceitos (definições verbais).",
                                "Verificação de factibilidade explícita.",
                                "Lista formatada e completa de básicas/não básicas.",
                                "Tempo de execução eficiente (dentro do estimado)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes, bases).",
                                "Programação: Implementação em Python (SciPy.linprog) ou Excel Solver.",
                                "Estatística: Otimização em regressão e modelos probabilísticos.",
                                "Engenharia Civil: Alocação de recursos em projetos de construção."
                              ],
                              "realWorldApplication": "Em engenharia civil, otimizar mistura de concreto (max resistência s.t. custos/reduzindo materiais): identificar básicas iniciais (folgas de restrições de custo) para iterar Simplex até alocação ótima de cimento/areia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Operações de Pivoteamento na Tabela Simplex",
                        "description": "Processo de seleção da variável entrante e saindo por meio do teste de razão e pivoteamento gaussiano para gerar novas soluções básicas factíveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Aplicar o critério de entrada de variável",
                            "description": "Selecionar a variável entrante com base no coeficiente mais negativo na linha da função objetivo (para maximização), indicando potencial de melhoria.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Confirmar a necessidade de pivoteamento examinando a linha da função objetivo",
                                  "subSteps": [
                                    "Revise a tabela Simplex atual para garantir que está na forma padrão.",
                                    "Localize a linha da função objetivo (Z-row), geralmente na última linha.",
                                    "Verifique se há pelo menos um coeficiente negativo nos elementos das variáveis não básicas na Z-row, indicando que a solução não é ótima para maximização.",
                                    "Liste todas as variáveis não básicas presentes na tabela."
                                  ],
                                  "verification": "Lista confirmada de coeficientes negativos na Z-row para variáveis não básicas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela Simplex em papel ou software como Excel/Google Sheets",
                                    "Calculadora ou software de otimização (opcional)"
                                  ],
                                  "tips": "Lembre-se: para problemas de maximização, coeficientes negativos indicam potencial de aumento no valor da função objetivo.",
                                  "learningObjective": "Entender quando aplicar o critério de entrada e identificar a Z-row corretamente.",
                                  "commonMistakes": [
                                    "Confundir maximização com minimização (critério oposto).",
                                    "Incluir coeficientes de variáveis básicas (que devem ser zero).",
                                    "Ignorar a verificação de otimalidade inicial."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e listar os coeficientes das variáveis não básicas na Z-row",
                                  "subSteps": [
                                    "Identifique todas as colunas correspondentes a variáveis não básicas (sem base na coluna 'Basis').",
                                    "Anote os valores dos coeficientes cj - zj na interseção dessas colunas com a Z-row.",
                                    "Registre apenas os valores numéricos relevantes, ignorando RHS e Basis.",
                                    "Compare visualmente os valores para localizar negativos."
                                  ],
                                  "verification": "Lista completa e precisa dos coeficientes das variáveis não básicas anotada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela Simplex",
                                    "Folha de rascunho para anotações"
                                  ],
                                  "tips": "Use destaque ou sublinhado para separar variáveis básicas de não básicas.",
                                  "learningObjective": "Diferenciar variáveis básicas e não básicas e extrair coeficientes corretamente.",
                                  "commonMistakes": [
                                    "Incluir acidentalmente coeficientes de variáveis básicas (zero).",
                                    "Ler valores errados da linha errada (ex: confundir com b-vector).",
                                    "Esquecer variáveis slack ou artificiais não básicas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar o coeficiente mais negativo e a variável correspondente",
                                  "subSteps": [
                                    "Compare todos os coeficientes negativos listados do Step 2.",
                                    "Identifique o valor absoluto mais alto entre os negativos (o menor número, ex: -10 < -3).",
                                    "Em caso de empate, escolha uma por convenção (ex: menor índice de variável).",
                                    "Anote a coluna (variável) com esse coeficiente como candidata a entrante."
                                  ],
                                  "verification": "Coeficiente mais negativo selecionado corretamente com justificativa numérica.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Lista de coeficientes do Step 2",
                                    "Calculadora para comparações numéricas"
                                  ],
                                  "tips": "Pense no critério como 'maior potencial de melhoria por unidade': mais negativo = maior ganho.",
                                  "learningObjective": "Aplicar comparação numérica para maximizar melhoria na função objetivo.",
                                  "commonMistakes": [
                                    "Escolher o menos negativo por engano.",
                                    "Ignorar empates e não especificar critério de desempate.",
                                    "Confundir sinal: escolher positivo em maximização."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e declarar a variável entrante",
                                  "subSteps": [
                                    "Confirme que a variável selecionada é não básica e seu coeficiente é o mais negativo.",
                                    "Justifique a escolha: 'Variável X entra pois seu cj-zj = -Y é o mais negativo, aumentando Z em Y por unidade.'",
                                    "Prepare a tabela para o próximo passo (critério de saída).",
                                    "Documente a decisão para auditoria."
                                  ],
                                  "verification": "Declaração clara da variável entrante com justificativa escrita.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela Simplex atualizada com anotação",
                                    "Template de relatório de pivoteamento"
                                  ],
                                  "tips": "Sempre verbalize ou escreva a justificativa para reforçar o raciocínio.",
                                  "learningObjective": "Formalizar a decisão de entrada com base no critério teórico.",
                                  "commonMistakes": [
                                    "Declarar variável errada sem rever comparação.",
                                    "Pular justificativa, assumindo intuitivamente.",
                                    "Proceder sem confirmar não-otimalidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere esta tabela Simplex para maximizar Z = 5x1 + 3x2 s.a. x1 + 2x2 <= 4, 3x1 + x2 <= 6:\n\n| Basis | x1  | x2  | s1 | s2 | b   |\n|-------|-----|-----|----|----|-----|\n| s1    | 1   | 2   | 1  | 0  | 4   |\n| s2    | 3   | 1   | 0  | 1  | 6   |\n| Z     | -5  | -3  | 0  | 0  | 0   |\n\nCoeficientes na Z-row: x1(-5), x2(-3). Mais negativo: -5 → Variável entrante: x1.",
                              "finalVerifications": [
                                "Coeficiente mais negativo identificado corretamente na Z-row.",
                                "Variável não básica correspondente selecionada sem erros.",
                                "Justificativa escrita menciona 'potencial de melhoria' ou 'aumento em Z'.",
                                "Solução não ótima confirmada antes da seleção.",
                                "Nenhum coeficiente de variável básica considerado.",
                                "Em caso de empate, critério de desempate aplicado.",
                                "Preparação para critério de saída iniciada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da Z-row (100% correta).",
                                "Correta comparação numérica de coeficientes (sem erros de sinal ou valor).",
                                "Justificativa teórica explícita e concisa.",
                                "Tempo de execução dentro do estimado com acurácia.",
                                "Ausência de erros comuns documentados.",
                                "Capacidade de lidar com empates ou tabelas maiores.",
                                "Integração com passos subsequentes do Simplex."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Interpretação de coeficientes reduzidos como direções de melhoria.",
                                "Programação: Implementação do critério em loops de solvers como SciPy.linprog ou PuLP.",
                                "Estatística: Análise de sensibilidade em otimizações estocásticas.",
                                "Engenharia de Produção: Seleção de gargalos em fluxos de construção civil.",
                                "Economia: Maximização de utilidade sob restrições orçamentárias."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao otimizar a alocação de recursos em projetos de construção (ex: minimizar custos de mistura de concreto maximizando resistência), o critério seleciona a próxima 'ajuste' na solução, como priorizar redução de cimento caro versus agregados, iterando até a alocação ótima de materiais sob restrições de volume e custo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Realizar o teste de razão mínima",
                            "description": "Calcular as razões mínimas b_i / a_{i,p} para determinar a variável básica saindo, garantindo que a nova solução permaneça factível.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a coluna de entrada e linhas qualificadas",
                                  "subSteps": [
                                    "Confirme a coluna pivot p (variável entrando) selecionada previamente pelo teste de otimalidade.",
                                    "Examine todos os coeficientes a_{i,p} na coluna p para linhas i = 1 até m (restrições).",
                                    "Selecione apenas as linhas onde a_{i,p} > 0 (coeficientes positivos).",
                                    "Liste os valores b_i correspondentes para essas linhas qualificadas.",
                                    "Registre as linhas não qualificadas (a_{i,p} ≤ 0) para exclusão do cálculo."
                                  ],
                                  "verification": "Lista de linhas qualificadas com a_{i,p} > 0 e valores b_i anotados corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela Simplex atual",
                                    "Papel e caneta ou planilha Excel"
                                  ],
                                  "tips": "Sempre ignore linhas com a_{i,p} ≤ 0 para evitar razões negativas ou indefinidas que violam factibilidade.",
                                  "learningObjective": "Compreender quais linhas participam do teste de razão mínima para manter a factibilidade.",
                                  "commonMistakes": [
                                    "Incluir linhas com a_{i,p} ≤ 0",
                                    "Confundir coluna de entrada com linha objetivo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as razões b_i / a_{i,p} para linhas qualificadas",
                                  "subSteps": [
                                    "Para cada linha i qualificada, divida b_i por a_{i,p}.",
                                    "Use precisão decimal adequada (geralmente 2-4 casas).",
                                    "Anote cada razão ao lado da linha correspondente.",
                                    "Verifique cálculos aritméticos com uma segunda passada.",
                                    "Ordene as razões em uma tabela auxiliar se houver muitas linhas."
                                  ],
                                  "verification": "Todas as razões calculadas e anotadas com valores numéricos corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/Excel",
                                    "Tabela auxiliar para razões"
                                  ],
                                  "tips": "Prefira frações exatas antes de decimalizar para evitar erros de arredondamento.",
                                  "learningObjective": "Executar divisões precisas para gerar candidatos à variável saindo.",
                                  "commonMistakes": [
                                    "Dividir incorretamente (ex: inverter numerador/denominador)",
                                    "Arredondar prematuramente levando a erros de comparação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar razões e selecionar a mínima",
                                  "subSteps": [
                                    "Compare todas as razões calculadas numericamente.",
                                    "Identifique a menor razão positiva (θ_min).",
                                    "Registre o índice i* da linha com θ_min (em caso de empate, escolha a menor i).",
                                    "Marque a posição (i*, p) como elemento pivot.",
                                    "Confirme que todas b_i / a_{i,p} ≥ θ_min para as outras linhas."
                                  ],
                                  "verification": "Índice i* e θ_min claramente identificados e corretos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Lista de razões ordenada",
                                    "Marcador para tabela Simplex"
                                  ],
                                  "tips": "Em empates, priorize a primeira ocorrência para simplicidade e consistência.",
                                  "learningObjective": "Selecionar a variável básica saindo que minimiza o passo e preserva não-negatividade.",
                                  "commonMistakes": [
                                    "Selecionar razão maior como mínima",
                                    "Ignorar empates ou escolher incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar factibilidade da nova solução básica",
                                  "subSteps": [
                                    "Confirme que após pivoteamento, todos b_j novos ≥ 0.",
                                    "Simule o pivoteamento na linha i* para validar.",
                                    "Verifique ausência de degenerescência (θ_min > 0).",
                                    "Atualize a tabela indicando a variável saindo.",
                                    "Documente o motivo da escolha para auditoria."
                                  ],
                                  "verification": "Declaração de factibilidade confirmada com b ≥ 0 pós-pivoteamento.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Cópia da tabela para simulação",
                                    "Software de Simplex opcional"
                                  ],
                                  "tips": "Se θ_min = 0, há degenerescência; prossiga com cautela ou use regra anti-ciclagem.",
                                  "learningObjective": "Garantir que o pivoteamento mantém a solução factível (BFS válida).",
                                  "commonMistakes": [
                                    "Não verificar pós-pivoteamento",
                                    "Prosseguir com θ_min = 0 sem notar degenerescência"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere tabela Simplex: Linha 1: b1=10, a1p=2; Linha 2: b2=20, a2p=5; Linha 3: b3=15, a3p=0. Linhas qualificadas: 1 e 2. Razões: 10/2=5, 20/5=4. Mínima: 4 (linha 2 sai). Pivot em (2,p).",
                              "finalVerifications": [
                                "Todas linhas com a_{i,p} > 0 identificadas corretamente.",
                                "Razões b_i / a_{i,p} calculadas com precisão.",
                                "Linha i* com razão mínima selecionada adequadamente.",
                                "Elemento pivot (i*,p) marcado.",
                                "Factibilidade confirmada (nova solução básica não-negativa).",
                                "Documentação completa do processo."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos cálculos de razões.",
                                "Correta exclusão de linhas não qualificadas.",
                                "Seleção inequívoca da razão mínima.",
                                "Verificação explícita de factibilidade.",
                                "Clareza na documentação e justificativas.",
                                "Tratamento adequado de casos edge (empate, zero)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações com frações e desigualdades lineares.",
                                "Programação: Implementação em loops para automação do teste em código Python.",
                                "Estatística: Analogia com testes de significância e razões de verossimilhança.",
                                "Engenharia Civil: Otimização de recursos em planejamento de obras."
                              ],
                              "realWorldApplication": "No planejamento de projetos civis, como alocação ótima de materiais em estruturas, o teste de razão mínima previne sobrecargas em restrições (ex: limite de concreto), garantindo soluções factíveis e eficientes em softwares de otimização."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Executar o pivoteamento gaussiano",
                            "description": "Realizar as operações elementares de linha na tabela Simplex para tornar o pivô unitário e zerar os demais elementos da coluna pivô.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a linha e coluna pivô e normalizar a linha pivô",
                                  "subSteps": [
                                    "Confirme a posição do elemento pivô (linha i, coluna j) na tabela Simplex.",
                                    "Divida todos os elementos da linha pivô pelo valor do pivô para torná-lo 1.",
                                    "Atualize o rótulo da variável básica da linha pivô para a variável de entrada.",
                                    "Verifique se todos os coeficientes da linha foram divididos corretamente, incluindo o RHS.",
                                    "Registre os valores normalizados em uma tabela auxiliar para conferência."
                                  ],
                                  "verification": "O elemento na posição pivô é exatamente 1 e todos os outros elementos da linha foram ajustados proporcionalmente.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Tabela Simplex em planilha Excel ou papel quadriculado",
                                    "Calculadora científica",
                                    "Folha de rascunho"
                                  ],
                                  "tips": "Use frações exatas quando possível para evitar erros de arredondamento decimal.",
                                  "learningObjective": "Dominar a normalização da linha pivô para unitarizar o pivô.",
                                  "commonMistakes": [
                                    "Esquecer de dividir o RHS ou rótulos",
                                    "Dividir apenas o pivô sem ajustar a linha inteira",
                                    "Arredondar prematuramente causando imprecisão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Eliminar elementos acima do pivô na coluna pivô",
                                  "subSteps": [
                                    "Para cada linha k acima da linha pivô (k < i), identifique o elemento a_{k j} na coluna pivô.",
                                    "Calcule o multiplicador m_k = a_{k j} / 1 (já unitário).",
                                    "Subtraia m_k vezes a linha pivô normalizada da linha k inteira.",
                                    "Atualize todos os coeficientes, incluindo RHS e coeficientes de Z.",
                                    "Confira que o elemento na coluna pivô da linha k agora é zero."
                                  ],
                                  "verification": "Todos os elementos acima do pivô na coluna j são zero.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Planilha Excel com fórmulas auxiliares para subtrações",
                                    "Calculadora",
                                    "Tabela copiada para testes"
                                  ],
                                  "tips": "Trabalhe linha por linha para evitar confusão; use cor para destacar a coluna pivô.",
                                  "learningObjective": "Aplicar operações de eliminação superior corretamente na tabela Simplex.",
                                  "commonMistakes": [
                                    "Usar multiplicador incorreto (não dividir pelo pivô unitário)",
                                    "Subtrair em vez de adicionar quando necessário",
                                    "Esquecer de atualizar a linha Z"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Eliminar elementos abaixo do pivô na coluna pivô",
                                  "subSteps": [
                                    "Para cada linha k abaixo da linha pivô (k > i), identifique o elemento a_{k j}.",
                                    "Calcule o multiplicador m_k = a_{k j} / 1.",
                                    "Subtraia m_k vezes a linha pivô da linha k inteira.",
                                    "Atualize RHS, coeficientes de restrições e linha Z.",
                                    "Verifique zero no elemento da coluna pivô para todas linhas abaixo."
                                  ],
                                  "verification": "Todos os elementos abaixo do pivô na coluna j são zero.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Mesmos da etapa anterior",
                                    "Software como MATLAB ou Python (opcional para automação)"
                                  ],
                                  "tips": "Mantenha consistência no sinal das operações; teste com um valor conhecido.",
                                  "learningObjective": "Executar eliminação inferior preservando a estrutura da tabela Simplex.",
                                  "commonMistakes": [
                                    "Inverter sinal da subtração",
                                    "Não atualizar todos os coeficientes da linha",
                                    "Confundir linhas durante cálculos múltiplos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e finalizar a tabela pós-pivoteamento",
                                  "subSteps": [
                                    "Inspecione a coluna pivô: deve ter 1 apenas na linha pivô e 0s elsewhere.",
                                    "Confira conservação de valores: some RHS ou teste equações originais.",
                                    "Atualize rótulos de variáveis básicas na nova tabela.",
                                    "Compare com tabela original para validar transformações.",
                                    "Documente o pivô usado e nova base factível."
                                  ],
                                  "verification": "Coluna pivô é unitária e a solução básica factível é preservada.",
                                  "estimatedTime": "5-10 minutos",
                                  "materials": [
                                    "Tabela final vs. original",
                                    "Checklist de verificação"
                                  ],
                                  "tips": "Use uma segunda pessoa ou software para validação cruzada.",
                                  "learningObjective": "Validar a integridade da tabela após pivoteamento gaussiano.",
                                  "commonMistakes": [
                                    "Ignorar discrepâncias no RHS",
                                    "Esquecer de rotular nova base",
                                    "Não detectar erros propagados"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma tabela Simplex 3x5 (2 restrições):\nLinha Z: [1, -3, -2, 0, 0, 0]\nLinha 1 (s1): [0, 2, 1, 1, 0, 4]\nLinha 2 (s2): [0, 1, 3, 0, 1, 9]\nPivô: linha 1, coluna x1 (valor 2).\n1. Normalize linha 1: divida por 2 → [0, 1, 0.5, 0.5, 0, 2]\n2. Eliminar acima (Z): m= -3, Z nova = Z - (-3)*linha1 → [1, 0, -0.5, -1.5, 0, 6]\n3. Eliminar abaixo (linha2): m=1, linha2 nova = linha2 -1*linha1 → [0, 0, 2.5, -0.5, 1, 7]\nResultado: coluna x1 unitária.",
                              "finalVerifications": [
                                "Elemento pivô é precisamente 1.",
                                "Todos os outros elementos da coluna pivô são zero.",
                                "Nova solução básica é factível (RHS ≥ 0).",
                                "Rótulos de variáveis básicas atualizados corretamente.",
                                "Coeficientes da função objetivo ajustados sem erros aritméticos.",
                                "Equações originais satisfeitas pela nova base."
                              ],
                              "assessmentCriteria": [
                                "Precisão aritmética em todas as operações (erro < 0.01).",
                                "Sequência correta: normalização antes de eliminação.",
                                "Atualização completa de todas as linhas e colunas afetadas.",
                                "Verificação independente da coluna pivô unitária.",
                                "Documentação clara dos multiplicadores usados.",
                                "Tempo de execução eficiente sem perda de acurácia."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Eliminação gaussiana em sistemas lineares.",
                                "Programação Computacional: Implementação do Simplex em Python ou MATLAB.",
                                "Engenharia Civil: Otimização de recursos em estruturas (ex: minimizar custo de vigas).",
                                "Estatística: Modelos de regressão linear e otimização quadrática.",
                                "Economia: Alocação ótima de recursos limitados em projetos."
                              ],
                              "realWorldApplication": "Em engenharia civil, o pivoteamento gaussiano no Simplex otimiza a mistura de concreto minimizando custos sujeitos a restrições de resistência e volume, como em fundações de pontes onde se maximiza durabilidade com orçamento fixo."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.1",
                              "10.1.4.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Critérios de Otimalidade e Fases do Algoritmo",
                        "description": "Condições para parada do algoritmo, detecção de soluções ótimas e tratamento de problemas infactíveis ou ilimitados usando Fase 1 e Fase 2.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Verificar o critério de otimalidade",
                            "description": "Analisar a linha da função objetivo para confirmar se todos os coeficientes das variáveis não básicas são não-negativos (maximização), indicando solução ótima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a linha da função objetivo na tableau do Simplex",
                                  "subSteps": [
                                    "Examine a tableau atual gerada pelo método Simplex.",
                                    "Localize a última linha, conhecida como linha Z ou linha da função objetivo.",
                                    "Confirme que esta linha representa os coeficientes reduzidos das variáveis (c_j - z_j).",
                                    "Anote a posição das variáveis básicas e não básicas na tableau.",
                                    "Verifique se a tableau está na forma padrão para maximização."
                                  ],
                                  "verification": "A linha Z está corretamente identificada e seus coeficientes são visíveis sem ambiguidades.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Tableau impressa ou digital do problema Simplex, lápis e papel.",
                                  "tips": "Sempre comece pela parte inferior da tableau para evitar confusão com linhas de restrições.",
                                  "learningObjective": "Compreender a estrutura da tableau e o papel da linha Z no algoritmo Simplex.",
                                  "commonMistakes": "Confundir a linha Z com linhas de restrições ou folgas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as variáveis não básicas",
                                  "subSteps": [
                                    "Liste todas as colunas da tableau correspondentes às variáveis originais e de folga.",
                                    "Determine quais variáveis têm coluna de identidade unitária (base) e exclua-as.",
                                    "Registre as variáveis restantes como não básicas (colunas sem identidade unitária).",
                                    "Confirme que as variáveis básicas estão com valor zero nas não básicas.",
                                    "Marque visualmente as colunas não básicas na tableau."
                                  ],
                                  "verification": "Lista completa e precisa de variáveis não básicas sem inclusão de básicas.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Tableau anotada, highlighter para marcar colunas.",
                                  "tips": "Use cores diferentes para básicas e não básicas para visualização rápida.",
                                  "learningObjective": "Distinguir variáveis básicas de não básicas na tableau.",
                                  "commonMistakes": "Incluir variáveis básicas como não básicas por erro de identificação da base."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar os coeficientes das variáveis não básicas na linha Z",
                                  "subSteps": [
                                    "Vá para a linha Z e foque apenas nas posições das variáveis não básicas.",
                                    "Registre o valor de cada coeficiente (c_j - z_j) para essas variáveis.",
                                    "Verifique se todos os coeficientes são ≥ 0 (para problemas de maximização).",
                                    "Se algum for negativo, anote qual variável indica potencial melhoria.",
                                    "Calcule ou confirme os valores se necessário, revisando pivots anteriores."
                                  ],
                                  "verification": "Todos os coeficientes relevantes estão listados com seus sinais corretos.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Calculadora para verificação numérica, tableau.",
                                  "tips": "Procure o menor coeficiente negativo se houver, mas foque no critério geral.",
                                  "learningObjective": "Analisar sinais dos coeficientes reduzidos para avaliar otimalidade.",
                                  "commonMistakes": "Ignorar o sinal de variáveis básicas ou considerar constantes da linha Z."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o critério de otimalidade e concluir",
                                  "subSteps": [
                                    "Confirme: se todos coeficientes não básicos na linha Z ≥ 0, a solução é ótima.",
                                    "Se houver coeficiente < 0, a solução não é ótima; sugira próximo pivot.",
                                    "Calcule o valor atual da função objetivo Z para a solução básica.",
                                    "Documente a conclusão: ótima ou não, com justificativa.",
                                    "Salve a tableau final se ótima."
                                  ],
                                  "verification": "Conclusão explícita com base no critério, apoiada por evidências numéricas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel para documentação, software de otimização opcional.",
                                  "tips": "Lembre-se: critério é para maximização; inverta para minimização (todos ≤ 0).",
                                  "learningObjective": "Aplicar o teorema de otimalidade do Simplex de forma conclusiva.",
                                  "commonMistakes": "Concluir otimalidade apesar de coeficientes negativos."
                                }
                              ],
                              "practicalExample": "Considere o problema Max Z = 3x1 + 5x2, s.t. x1 + x2 ≤ 4, 2x1 + x2 ≤ 5, x1,x2 ≥ 0. Na tableau final: linha Z = [0, 0, 1, 0, 0 | 12]. Variáveis não básicas: x2 e s2 com coeficientes 0 e 0 (≥0), logo ótima com Z=12.",
                              "finalVerifications": [
                                "Todos coeficientes não básicos na linha Z são ≥ 0.",
                                "Variáveis básicas identificadas corretamente.",
                                "Valor de Z calculado e consistente.",
                                "Nenhum coeficiente negativo ignorado.",
                                "Conclusão de otimalidade justificada.",
                                "Tableau livre de erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da linha Z e variáveis não básicas (100%).",
                                "Correta análise de sinais dos coeficientes (90-100%).",
                                "Conclusão lógica baseada no critério (100%).",
                                "Documentação clara com justificativas.",
                                "Ausência de erros comuns como confusão básica/não básica.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (bases e vetores).",
                                "Programação: Implementação em Python (biblioteca PuLP ou SciPy).",
                                "Estatística: Otimização em regressão e modelos probabilísticos.",
                                "Engenharia Civil: Alocação de recursos em projetos de construção."
                              ],
                              "realWorldApplication": "Em engenharia civil, verificar otimalidade no Simplex otimiza alocação de materiais em obras, como minimizar custos de concreto e aço sob restrições de peso e volume, garantindo soluções economicamente viáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Implementar a Fase 1 para factibilidade",
                            "description": "Usar variáveis artificiais e minimizar a soma delas para encontrar uma solução básica factível inicial em problemas não factíveis a partir da origem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a necessidade de Fase 1 e introduzir variáveis artificiais",
                                  "subSteps": [
                                    "Analise as restrições do problema linear para verificar se a origem (todas variáveis = 0) satisfaz todas elas.",
                                    "Identifique restrições do tipo >= b (com b > 0) ou = b que não permitem uma base óbvia sem artificiais.",
                                    "Adicione uma variável artificial ai >= 0 para cada restrição que precisa, convertendo >= b para = b - ai.",
                                    "Defina o objetivo da Fase 1: minimizar w = soma de todas ai."
                                  ],
                                  "verification": "Confirme que todas restrições problemáticas têm uma artificial associada e o objetivo w está corretamente definido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel ou software de planilha (Excel/Google Sheets), descrição do problema LP.",
                                  "tips": "Comece sempre pela origem para testar factibilidade básica; anote quantas artificiais são necessárias.",
                                  "learningObjective": "Reconhecer quando a Fase 1 é requerida e preparar corretamente as variáveis artificiais.",
                                  "commonMistakes": "Esquecer de adicionar artificiais apenas para restrições >= ou = que violam na origem; confundir com folgas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o tableau inicial da Fase 1",
                                  "subSteps": [
                                    "Escreva o sistema de equações padrão incluindo folgas para <= e artificiais para as outras.",
                                    "Monte o tableau com colunas para variáveis originais, folgas, artificiais, RHS e linha w = -soma ai (ou use Big M).",
                                    "Identifique a base inicial: artificiais nas posições básicas para suas restrições.",
                                    "Calcule os valores iniciais do RHS e verifique se são não-negativos."
                                  ],
                                  "verification": "O tableau tem linha w com coeficientes corretos (-1 para artificiais) e base inicial factível.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de otimização como MATLAB, Python (PuLP ou SciPy), ou tableau manual em papel.",
                                  "tips": "Use convenção de tableau padrão: coeficientes de w na parte superior; pivoteie se necessário para base inicial.",
                                  "learningObjective": "Montar um tableau factível inicial para minimização de artificiais.",
                                  "commonMistakes": "Colocar coeficientes errados na linha w (deve ser soma ai, não as variáveis originais); RHS negativo na base inicial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações do algoritmo Simplex na Fase 1",
                                  "subSteps": [
                                    "Selecione a coluna pivot com o coeficiente mais negativo na linha w (regra de entrada).",
                                    "Calcule razões mínimas no RHS para linhas básicas (regra de saída).",
                                    "Realize a operação de pivotagem: normalize a linha pivot e elimine nas outras linhas.",
                                    "Repita até que todos coeficientes na linha w sejam >= 0 ou detecte ciclo/unbounded."
                                  ],
                                  "verification": "Monitore w a cada iteração; pare quando w=0 (ótimo) ou impossível reduzir mais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora ou software para operações matriciais; histórico de iterações.",
                                  "tips": "Registre cada tableau pós-pivotagem; use método anti-ciclo se necessário (perturbations).",
                                  "learningObjective": "Aplicar regras de pivotagem para minimizar soma de artificiais iterativamente.",
                                  "commonMistakes": "Escolher errado a coluna de entrada (não a mais negativa); erro em cálculos de eliminação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar factibilidade e preparar transição para Fase 2",
                                  "subSteps": [
                                    "Confirme se w* = 0; se sim, solução básica factível encontrada.",
                                    "Se alguma artificial ainda básica com valor >0, problema infactível.",
                                    "Remova colunas de artificiais do tableau; ajuste linha objetivo original z removendo impacto das artificiais.",
                                    "Restaure coeficientes originais de z nas variáveis não-artificiais e prossiga."
                                  ],
                                  "verification": "w=0, nenhuma artificial básica positiva, tableau pronto para Fase 2 com z correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tableau final da Fase 1.",
                                  "tips": "Se w>0, declare infactível imediatamente; backup do tableau antes de remover artificiais.",
                                  "learningObjective": "Interpretar resultado da Fase 1 e transitar suavemente para otimização original.",
                                  "commonMistakes": "Não remover artificiais completamente; esquecer de restaurar coeficientes de z."
                                }
                              ],
                              "practicalExample": "Considere Max z = 3x1 + 5x2 s.t. x1 + x2 >= 3, 2x1 + 3x2 >= 5, x1,x2 >=0. Origem viola ambas. Introduza a1,a2: x1+x2 -a1=3, 2x1+3x2 -a2=5. Min w=a1+a2. Após iterações: entra x2 em primeira, depois x1; w=0 em (x1=1, x2=2), factível para Fase 2.",
                              "finalVerifications": [
                                "Soma de variáveis artificiais é exatamente zero.",
                                "Nenhuma variável artificial permanece básica com valor positivo.",
                                "Tableau final tem base factível para restrições originais.",
                                "Linha objetivo original z foi restaurada corretamente.",
                                "Todas iterações foram registradas sem erros aritméticos.",
                                "Problema foi declarado infactível se w*>0."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de restrições que requerem artificiais (100% corretas).",
                                "Construção correta do tableau inicial com base factível (sem RHS negativos).",
                                "Execução de pivotagens sem erros matemáticos e convergência para ótimo.",
                                "Interpretação correta do resultado (factível/infictível) e transição para Fase 2.",
                                "Documentação completa de steps e iterações.",
                                "Eficiência: mínimo de iterações via escolhas ótimas de pivot."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (operações em matrizes do tableau).",
                                "Programação: Implementação em Python (bibliotecas como PuLP ou linprog).",
                                "Estatística: Otimização em modelos de regressão com restrições.",
                                "Engenharia Civil: Planejamento de recursos em obras com mínimos de materiais."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, como alocação mínima de concreto e aço em vigas (restrições >= para resistência), usa Fase 1 para encontrar configurações iniciais factíveis antes de otimizar custos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1",
                              "10.1.4.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Detectar unboundedness e degenerescência",
                            "description": "Identificar casos de solução ilimitada (razão mínima inexistente) e degenerescência (razão zero), propondo estratégias de resolução como regra de Bland.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Teóricos de Unboundedness e Degenerescência",
                                  "subSteps": [
                                    "Defina unboundedness como o caso em que não existe razão mínima finita no pivoteamento, indicando solução ilimitada.",
                                    "Defina degenerescência como o caso em que a razão mínima é zero, levando a ciclos no algoritmo simplex.",
                                    "Revise a tabela simplex padrão e identifique as colunas de coeficientes de custo reduzido (cj - zj) positivos para direção de melhoria.",
                                    "Estude exemplos teóricos de problemas LP com variáveis ilimitadas ou restrições redundantes.",
                                    "Compare com casos normais de otimalidade para diferenciar os sintomas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as definições e forneça um exemplo simples de cada caso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de otimização (cap. Simplex), slides de aula sobre Método Simplex, tabela simplex em branco.",
                                  "tips": "Use diagramas geométricos para visualizar unboundedness como regiões não limitadas no espaço de soluções.",
                                  "learningObjective": "Dominar as definições precisas e condições de ocorrência de unboundedness e degenerescência no simplex.",
                                  "commonMistakes": "Confundir unboundedness com infeasibilidade; ignorar que degenerescência pode causar loops infinitos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar Unboundedness Durante o Pivoteamento",
                                  "subSteps": [
                                    "Execute o pivoteamento: calcule razões b_i / a_{i,p} para coluna pivotante p com c_p - z_p > 0.",
                                    "Identifique se todos os a_{i,p} ≤ 0 na coluna pivotante (nenhuma razão positiva finita).",
                                    "Confirme que a direção de melhoria permite movimento ilimitado sem violar restrições.",
                                    "Registre o tableau atual e anote 'Unbounded' no status.",
                                    "Teste sensibilidade alterando ligeiramente coeficientes para validar."
                                  ],
                                  "verification": "Apresente um tableau onde unboundedness ocorre e mostre cálculos de razões ausentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de otimização (ex: Excel Solver ou Python PuLP), planilha para tableaux manuais.",
                                  "tips": "Sempre verifique a coluna inteira; um único a_{i,p} > 0 pode criar uma razão finita.",
                                  "learningObjective": "Identificar proceduralmente o sinal de solução ilimitada no algoritmo simplex.",
                                  "commonMistakes": "Parar prematuramente sem verificar todos os elementos da coluna pivotante."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Degenerescência e Aplicar Regra de Bland",
                                  "subSteps": [
                                    "Calcule razões e selecione a mínima; verifique se ela é zero (degenerescência básica).",
                                    "Identifique pivôs múltiplos com razão zero na mesma linha.",
                                    "Aplique a Regra de Bland: escolha a variável entrante com o menor índice entre candidatas.",
                                    "Para variável saindo, selecione a com menor índice entre razões zero.",
                                    "Execute pivoteamento e monitore ciclos; repita até resolução ou detecção de loop."
                                  ],
                                  "verification": "Simule 2-3 iterações em um tableau degenerado e mostre resolução sem ciclo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Exemplos de problemas degenerados impressos, simulador online de simplex (ex: simplexmethod.com).",
                                  "tips": "Numere variáveis consistentemente; Bland prioriza índices baixos para evitar ciclos.",
                                  "learningObjective": "Diagnosticar degenerescência e implementar anti-ciclagem via Regra de Bland.",
                                  "commonMistakes": "Escolher pivôs por maior coeficiente ao invés de índice, causando loops infinitos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Detecções e Propor Estratégias Gerais de Resolução",
                                  "subSteps": [
                                    "Valide detecção rodando solver computacional e comparando output.",
                                    "Para unboundedness, sugira adicionar restrições reais ou reformular o modelo.",
                                    "Para degenerescência, aplique perturbação epsilon em b_i ou use simplex de duas fases.",
                                    "Documente o caso em relatório: tableau final, diagnóstico e solução proposta.",
                                    "Teste em problema similar para generalização."
                                  ],
                                  "verification": "Gere relatório com tableaux, diagnóstico correto e estratégia proposta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Solver Python (SciPy.linprog), template de relatório.",
                                  "tips": "Sempre rode solver numérico como sanity check após detecção manual.",
                                  "learningObjective": "Consolidar detecção com verificação e estratégias práticas de mitigação.",
                                  "commonMistakes": "Não propor reformulações concretas, deixando o problema sem solução acionável."
                                }
                              ],
                              "practicalExample": "Considere o problema LP: Max Z = 3x1 + 5x2, s.a. x1 ≤ 4, 2x2 ≤ 12, 3x1 + 2x2 ≤ 18, x1,x2 ≥ 0. No simplex, na iteração 2, coluna x2 tem coeficientes [2, 0, 3/2] com razões [6, ∞, 12/3=4], mas altere para todos ≤0 simulando unboundedness. Para degenerescência: razões [0,2,4] com mínimo 0 em linha 1.",
                              "finalVerifications": [
                                "Identifica corretamente unboundedness em tableau com coluna pivotante toda ≤0.",
                                "Detecta degenerescência quando razão mínima=0 e aplica Bland sem ciclo.",
                                "Explica impacto: unboundedness invalida otimalidade finita; degenerescência causa loops.",
                                "Propõe reformulações válidas para ambos casos.",
                                "Valida com solver computacional matching diagnóstico manual.",
                                "Documenta tableaux completos com anotações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% correto em 3 exemplos variados.",
                                "Profundidade de substeps: todos cálculos mostrados sem erros aritméticos.",
                                "Aplicação de Bland: resolve degenerescência sem ciclos em ≤5 iterações.",
                                "Estratégias propostas: acionáveis e contextuais à engenharia civil.",
                                "Verificação computacional: resultados coincidem com manual.",
                                "Relatório claro: estrutura lógica, diagramas inclusos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar simplex em Python para automação de detecção.",
                                "Estatística: Ligar degenerescência a multicolinearidade em regressão linear.",
                                "Engenharia de Software: Anti-ciclagem similar a algoritmos de grafos (BFS com índices).",
                                "Economia: Unboundedness em modelos de equilíbrio de mercado não regulado."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, como otimização de traçado de estradas (Max distância com restrições de custo/orçamento), detectar unboundedness evita planos irrealistas de expansão infinita; degenerescência surge em redes redundantes de tubulações, resolvida por Bland para alocação eficiente de materiais sem loops computacionais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Programação Não Linear",
                    "description": "Técnicas para minimizar ou maximizar funções não lineares com restrições.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Fundamentos da Programação Não Linear",
                        "description": "Conceitos básicos para formulação e compreensão de problemas de minimização ou maximização de funções não lineares, incluindo classificação de problemas e condições de otimalidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Formular problemas de programação não linear",
                            "description": "Identificar e expressar matematicamente um problema de otimização com função objetivo não linear e restrições, diferenciando entre problemas convexos e não convexos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Otimização e Diferenças entre Linear e Não Linear",
                                  "subSteps": [
                                    "Estude a definição de problema de otimização: minimizar/maximizar função objetivo sujeita a restrições.",
                                    "Compare programação linear (função objetivo e restrições lineares) com não linear (pelo menos uma não linear).",
                                    "Identifique exemplos simples de funções não lineares, como quadráticas ou exponenciais.",
                                    "Revise notação matemática padrão: min f(x) s.a. g(x) ≤ 0, h(x) = 0.",
                                    "Pratique convertendo problemas lineares em não lineares adicionando termos quadráticos."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças chave e forneça um exemplo simples de cada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Otimização (ex: Nocedal & Wright)",
                                    "Notas de aula sobre programação linear",
                                    "Calculadora ou software como MATLAB"
                                  ],
                                  "tips": "Use diagramas para visualizar diferenças entre linear e não linear.",
                                  "learningObjective": "Compreender os conceitos básicos e notação de problemas de otimização não linear.",
                                  "commonMistakes": [
                                    "Confundir restrições de igualdade com desigualdade",
                                    "Ignorar a não linearidade nas restrições"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Extrair Componentes de um Problema Real",
                                  "subSteps": [
                                    "Escolha um problema de engenharia civil, como otimização de seção transversal de uma viga.",
                                    "Identifique variáveis de decisão (ex: largura, altura da viga).",
                                    "Defina a função objetivo (ex: minimizar custo ou peso, que pode incluir termos não lineares como área^2).",
                                    "Liste restrições (ex: resistência ≥ carga, com relações não lineares como tensão = força/área).",
                                    "Documente todos os componentes em uma tabela: variáveis, objetivo, restrições."
                                  ],
                                  "verification": "Crie uma tabela completa com componentes identificados para um problema dado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de problemas de engenharia civil",
                                    "Papel e lápis ou Excel para tabelas",
                                    "Referências de mecânica dos materiais"
                                  ],
                                  "tips": "Comece com problemas familiares para facilitar a identificação.",
                                  "learningObjective": "Extrair precisamente os elementos chave de um problema de otimização não linear.",
                                  "commonMistakes": [
                                    "Omitir variáveis dependentes",
                                    "Classificar erroneamente uma restrição como linear"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Matematicamente o Problema Não Linear",
                                  "subSteps": [
                                    "Escreva a função objetivo em forma matemática explícita, incluindo termos não lineares.",
                                    "Formule restrições como desigualdades e igualdades não lineares.",
                                    "Defina o domínio das variáveis (ex: x > 0).",
                                    "Verifique a consistência: confirme que pelo menos um termo é não linear.",
                                    "Escreva o problema completo no formato padrão: min f(x) s.a. restrições."
                                  ],
                                  "verification": "Escreva a formulação matemática completa e revise com um colega ou software.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "LaTeX ou editor de equações (ex: Overleaf)",
                                    "Software de otimização como Python com SciPy",
                                    "Exemplos resolvidos de PN"
                                  ],
                                  "tips": "Use símbolos claros e defina todos os parâmetros.",
                                  "learningObjective": "Expressar um problema de otimização não linear de forma matemática precisa.",
                                  "commonMistakes": [
                                    "Erros de notação em somatórios ou produtos",
                                    "Esquecer bounds nas variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Problemas Convexos de Não Convexos",
                                  "subSteps": [
                                    "Revise definições: função convexa (linha entre pontos na função), conjunto convexo.",
                                    "Teste convexidade da função objetivo e restrições usando Hessiana ou gráficos.",
                                    "Classifique o problema: convexo se objetivo e restrições convexas (desigualdades) ou lineares (igualdades).",
                                    "Identifique problemas não convexos (ex: funções com máximos locais).",
                                    "Discuta implicações: convexos têm solução única global; não convexos requerem métodos heurísticos."
                                  ],
                                  "verification": "Classifique 3 problemas exemplo como convexo/não convexo e justifique com teste de Hessiana.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Cálculo multivariável (notas sobre Hessiana)",
                                    "Python/MATLAB para plotar funções e Hessiana",
                                    "Tabela de verificação de convexidade"
                                  ],
                                  "tips": "Plote funções 2D para visualizar convexidade intuitivamente.",
                                  "learningObjective": "Distinguir e justificar a convexidade em problemas de programação não linear.",
                                  "commonMistakes": [
                                    "Confundir convexidade local com global",
                                    "Ignorar convexidade das restrições"
                                  ]
                                }
                              ],
                              "practicalExample": "Em engenharia civil, formular o problema de minimizar o custo de uma viga retangular sujeita a carga: min C = k1 * w * h + k2 * (w*h)^1.5 (termo não linear para fabricação), s.a. σ = P/(w*h) ≤ σ_max (restrição não linear), w>0, h>0. Classificar como não convexo devido ao expoente 1.5 na objetivo.",
                              "finalVerifications": [
                                "Formulação matemática está correta e completa.",
                                "Identifica corretamente termos não lineares.",
                                "Classificação de convexidade justificada com teste apropriado.",
                                "Problema é acionável em software de otimização.",
                                "Todos componentes (variáveis, objetivo, restrições) definidos.",
                                "Exemplo prático de engenharia civil incluído."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (sem erros de símbolos).",
                                "Identificação correta de não linearidades (objetivo e/ou restrições).",
                                "Justificativa sólida para convexidade/não convexidade.",
                                "Clareza e completude da formulação.",
                                "Relevância ao contexto de engenharia civil.",
                                "Capacidade de aplicar em exemplo real."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Hessiana para convexidade.",
                                "Álgebra Linear: Representação matricial de restrições.",
                                "Programação Computacional: Implementação em Python/SciPy.",
                                "Mecânica dos Materiais: Modelos não lineares em estruturas.",
                                "Estatística: Sensibilidade em otimização não convexa."
                              ],
                              "realWorldApplication": "Na engenharia civil, usado para otimizar designs de estruturas como pontes ou edifícios, minimizando custos com restrições não lineares de resistência e deformação, permitindo soluções eficientes e seguras em projetos reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Classificar tipos de funções não lineares",
                            "description": "Reconhecer funções convexas, côncavas e quasiconvexas, e analisar condições de otimalidade local e global usando derivadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender definições de funções convexas, côncavas e quasiconvexas",
                                  "subSteps": [
                                    "Estude a definição formal de função convexa: f(λx + (1-λ)y) ≤ λf(x) + (1-λ)f(y) para λ ∈ [0,1].",
                                    "Aprenda a definição de função côncava como o negativo de uma convexa.",
                                    "Explore quasiconvexidade: subnível sets são convexos.",
                                    "Compare com exemplos gráficos simples como parábolas.",
                                    "Identifique diferenças entre convexidade estrita e não estrita."
                                  ],
                                  "verification": "Resuma as definições em suas próprias palavras e forneça um contraexemplo para cada tipo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de otimização (ex: Boyd & Vandenberghe), papel e lápis para esboços gráficos.",
                                  "tips": "Visualize com gráficos 2D para intuição inicial.",
                                  "learningObjective": "Definir precisamente convexas, côncavas e quasiconvexas e distingui-las.",
                                  "commonMistakes": "Confundir convexidade com monotonicidade ou linearidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar testes de convexidade usando derivadas",
                                  "subSteps": [
                                    "Revise derivada segunda: para univariada, f''(x) ≥ 0 implica convexa.",
                                    "Para funções multivariadas, verifique matriz Hessiana positiva semidefinida.",
                                    "Pratique cálculo de Hessiana para funções polinomiais quadráticas.",
                                    "Teste condições suficientes e necessárias para côncavas (Hessiana negativa semidefinida).",
                                    "Discuta limitações: teste local não garante global."
                                  ],
                                  "verification": "Calcule a Hessiana de f(x,y)=x²+y² e confirme positiva semidefinida.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (ex: SymPy ou MATLAB), exemplos de funções anotados.",
                                  "tips": "Comece com funções univariadas para construir confiança.",
                                  "learningObjective": "Usar derivadas para testar convexidade localmente.",
                                  "commonMistakes": "Ignorar autovalores negativos na Hessiana."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar condições de otimalidade local e global",
                                  "subSteps": [
                                    "Estude otimalidade local: ∇f(x*) = 0 e Hessiana positiva semidefinida para mínimo local.",
                                    "Para convexas: qualquer ponto estacionário é global.",
                                    "Compare com não-convexas: múltiplos mínimos locais possíveis.",
                                    "Analise quasiconvexas: condições de primeira ordem suficientes.",
                                    "Pratique identificando se mínimo local é global baseado em convexidade."
                                  ],
                                  "verification": "Para f(x)=x^4 - 2x^2, encontre pontos críticos e classifique usando testes.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de plotagem (ex: Desmos ou Python Matplotlib), tabela de condições de otimalidade.",
                                  "tips": "Use plotagens para validar cálculos analíticos.",
                                  "learningObjective": "Determinar se um ótimo local é global via propriedades de convexidade.",
                                  "commonMistakes": "Assumir que ∇f=0 sempre implica mínimo global."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar classificação e análise integrada de funções",
                                  "subSteps": [
                                    "Classifique 5 funções dadas: ex. f(x)=e^x (convexa), f(x)=log(x) (côncava).",
                                    "Para cada uma, compute derivadas e verifique otimalidade.",
                                    "Resolva problema: minimize f(x)=x^2 + sin(x) e discuta convexidade.",
                                    "Crie sua própria função e classifique-a.",
                                    "Avalie cenários de engenharia simples com restrições."
                                  ],
                                  "verification": "Submeta relatório com classificações corretas e análises para 5 funções.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Folha de exercícios, Jupyter Notebook para computação numérica.",
                                  "tips": "Varie dimensões: 1D para rapidez, 2D para complexidade.",
                                  "learningObjective": "Classificar funções e analisar otimalidade de forma autônoma.",
                                  "commonMistakes": "Não considerar domínio (ex: log(x) só para x>0)."
                                }
                              ],
                              "practicalExample": "Classifique f(x,y) = x² + y² + xy. Calcule Hessiana: [[2,1],[1,2]], autovalores positivos → convexa. Ponto (0,0) é mínimo global pois ∇f=0 e convexa.",
                              "finalVerifications": [
                                "Definição correta de convexa/côncava/quasiconvexa sem erros.",
                                "Hessiana computada corretamente para pelo menos 3 funções.",
                                "Identificação precisa de mínimo local vs global em exemplos.",
                                "Classificação de 5 funções variadas com justificativa.",
                                "Explicação de por que convexidade garante otimalidade global.",
                                "Contraexemplo para limitação de testes locais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e testes (40%).",
                                "Correção nos cálculos de derivadas/Hessiana (30%).",
                                "Análise integrada de otimalidade (20%).",
                                "Clareza e completude das justificativas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: uso de derivadas e Hessiana.",
                                "Programação Computacional: implementação em Python/MATLAB para verificação numérica.",
                                "Engenharia Civil: otimização de estruturas (ex: minimizar peso sujeito a resistências).",
                                "Estatística: regressão não linear e validação de modelos convexos."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, classificar funções convexas otimiza o design de vigas e lajes, garantindo mínimos globais em problemas de programação não linear para minimizar custos de material sob restrições de carga, usando solvers como IPOPT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Aplicar condições de otimalidade",
                            "description": "Verificar pontos estacionários usando gradiente nulo e testar a Hessiana para determinar mínimos, máximos ou pontos de sela.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Computar o Gradiente da Função Objetivo",
                                  "subSteps": [
                                    "Identifique a função objetivo f(x, y) ou multivariável.",
                                    "Calcule as derivadas parciais ∂f/∂x, ∂f/∂y, etc.",
                                    "Escreva a expressão vetorial do gradiente ∇f.",
                                    "Verifique simplificações algébricas para clareza.",
                                    "Anote o domínio da função se aplicável."
                                  ],
                                  "verification": "Confirme que ∇f está corretamente derivado comparando com exemplos conhecidos ou software simbólico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora gráfica",
                                    "Software como SymPy ou MATLAB"
                                  ],
                                  "tips": "Use notação vetorial consistente para evitar confusões em dimensões altas.",
                                  "learningObjective": "Dominar o cálculo de gradientes para funções não lineares.",
                                  "commonMistakes": [
                                    "Esquecer derivadas parciais cruzadas",
                                    "Erros de sinal em derivadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Encontrar Pontos Estacionários Resolvendo ∇f = 0",
                                  "subSteps": [
                                    "Defina o sistema de equações ∇f(x) = 0.",
                                    "Aplique métodos analíticos como substituição ou eliminação.",
                                    "Para funções complexas, use métodos numéricos iniciais (ex: Newton-Raphson).",
                                    "Liste todos os pontos candidatos no domínio.",
                                    "Valide soluções substituindo de volta nas equações."
                                  ],
                                  "verification": "Substitua os pontos encontrados no gradiente e confirme que todos os componentes são zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Solver numérico como Python/NumPy",
                                    "Gráficos da função para visualização"
                                  ],
                                  "tips": "Comece com suposições simples sobre soluções para guiar o cálculo.",
                                  "learningObjective": "Resolver sistemas não lineares para identificar candidatos a ótimos.",
                                  "commonMistakes": [
                                    "Ignorar soluções múltiplas",
                                    "Erros numéricos em aproximações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Matriz Hessiana no Ponto Estacionário",
                                  "subSteps": [
                                    "Compute as segundas derivadas parciais: ∂²f/∂x², ∂²f/∂x∂y, etc.",
                                    "Forme a matriz Hessiana H simétrica 2x2 ou nx n.",
                                    "Avalie H no ponto estacionário específico.",
                                    "Verifique simetria e propriedades positivas/negativas iniciais.",
                                    "Use software para validação em casos multivariáveis."
                                  ],
                                  "verification": "Confirme que H é simétrica e derivadas são corretas via diferenciação implícita ou software.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de álgebra simbólica",
                                    "Planilha para matrizes"
                                  ],
                                  "tips": "Mantenha derivadas em forma simbólica o máximo possível antes de numerizar.",
                                  "learningObjective": "Construir e avaliar a Hessiana para análise de curvatura.",
                                  "commonMistakes": [
                                    "Confundir ordem de derivadas mistas",
                                    "Avaliar H em ponto errado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Condições de Otimalidade com a Hessiana",
                                  "subSteps": [
                                    "Para 2D: Verifique det(H) > 0 e traço(H) para mínimo/máximo.",
                                    "Calcule determinantes principais (D1 = H11, D2 = det(H)).",
                                    "Classifique: Todos Di > 0 → mínimo local; alternados → sela; Todos Di < 0 → máximo.",
                                    "Para nD: Verifique definitude positiva/negativa/semi via autovalores.",
                                    "Documente a classificação para cada ponto."
                                  ],
                                  "verification": "Compare classificação com gráfico da função ou valores de f próximos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora para determinantes",
                                    "Python/MATLAB para autovalores",
                                    "Gráficos 3D da função"
                                  ],
                                  "tips": "Use teste de Sylvester para determinantes principais em ordem.",
                                  "learningObjective": "Aplicar teste da Hessiana para classificar pontos críticos.",
                                  "commonMistakes": [
                                    "Erros no sinal dos determinantes",
                                    "Ignorar casos indecididos (det(H)=0)"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimize o custo de uma viga em ponte: f(x,y) = 2x² + 3xy + y² - 10x - 5y. Encontre ∇f=0 em (2,1), compute H=[[4,3],[3,2]], det(H)=-2<0 → ponto de sela.",
                              "finalVerifications": [
                                "Todos pontos estacionários identificados corretamente.",
                                "Hessiana calculada e avaliada sem erros algébricos.",
                                "Classificação consistente com análise gráfica ou numérica.",
                                "Relatório inclui interpretação de mínimo/máximo/sela.",
                                "Soluções validadas numericamente em pelo menos um ponto.",
                                "Documentação completa com equações e conclusões."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de gradiente e Hessiana (90% correto).",
                                "Correta resolução de ∇f=0 e lista de candidatos.",
                                "Aplicação precisa do teste da Hessiana (classificação certa).",
                                "Interpretação clara das implicações para otimização.",
                                "Uso eficiente de ferramentas computacionais.",
                                "Relatório estruturado e sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Multivariável: Derivadas parciais e integrais.",
                                "Álgebra Linear: Autovalores e definitude de matrizes.",
                                "Programação Computacional: Implementação em Python/MATLAB.",
                                "Estatística: Otimização em regressão não linear."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, otimizar dimensões de estruturas (ex: treliças) minimizando custo/peso sujeito a restrições, usando esses testes para validar soluções numéricas em software como ANSYS ou custom solvers."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Métodos de Otimização Não Restrita",
                        "description": "Técnicas iterativas para resolver problemas sem restrições, baseadas em gradientes e aproximações de segunda ordem.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Implementar método do gradiente descendente",
                            "description": "Desenvolver algoritmo para minimizar funções não lineares usando direção anti-gradiente, com passos de aprendizado fixo ou adaptativo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos Teóricos do Gradiente Descendente",
                                  "subSteps": [
                                    "Estude a definição do método: minimização iterativa seguindo a direção oposta ao gradiente.",
                                    "Revise fórmulas básicas: x_{k+1} = x_k - α * ∇f(x_k), onde α é o tamanho do passo.",
                                    "Entenda variantes: passo fixo vs. adaptativo (ex: backtracking line search).",
                                    "Analise condições de convergência para funções convexas e não lineares.",
                                    "Resolva exemplos manuais simples em 1D e 2D."
                                  ],
                                  "verification": "Responda corretamente a um quiz com 5 perguntas sobre teoria e derive o gradiente de f(x) = x² manualmente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Otimização Não Linear (cap. Gradiente)",
                                    "Notebook Jupyter",
                                    "Vídeos Khan Academy sobre gradientes"
                                  ],
                                  "tips": "Visualize o gradiente como uma seta apontando para o aumento mais íngreme da função.",
                                  "learningObjective": "Dominar a teoria matemática do gradiente descendente e suas condições de uso.",
                                  "commonMistakes": [
                                    "Confundir gradiente com derivada escalar",
                                    "Ignorar não-convexidade levando a mínimos locais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Função Objetivo e Implementar Cálculo do Gradiente",
                                  "subSteps": [
                                    "Escolha uma função não linear teste, ex: f(x,y) = x² + y² + sin(x*y).",
                                    "Implemente a função objetivo em Python usando NumPy.",
                                    "Calcule analiticamente o gradiente ∇f = [∂f/∂x, ∂f/∂y].",
                                    "Codifique a função gradiente numericamente com diferenças finitas para validação.",
                                    "Teste com pontos conhecidos e compare resultados analíticos vs. numéricos."
                                  ],
                                  "verification": "Execute testes unitários: gradiente em (0,0) deve ser [0,0] para f(x,y)=x²+y².",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python 3",
                                    "NumPy",
                                    "Jupyter Notebook",
                                    "SymPy para derivadas simbólicas"
                                  ],
                                  "tips": "Use vectorização NumPy para eficiência em dimensões altas.",
                                  "learningObjective": "Implementar funções de custo e gradiente de forma precisa e eficiente.",
                                  "commonMistakes": [
                                    "Erros em derivadas parciais",
                                    "Não tratar casos de gradiente nulo prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Loop Principal do Algoritmo",
                                  "subSteps": [
                                    "Defina parâmetros iniciais: x0, α (passo fixo), tolerância ε, máximo iterações.",
                                    "Codifique o loop: while ||∇f|| > ε: x = x - α * ∇f(x); registre histórico.",
                                    "Adicione variante adaptativa: implemente line search simples (backtracking).",
                                    "Inclua logs: plote histórico de f(x) e ||∇f|| vs. iterações.",
                                    "Trate exceções: divergência (aumentar α se necessário)."
                                  ],
                                  "verification": "O código executa 100 iterações sem erros e reduz f(x) em pelo menos 90%.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "NumPy",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Comece com α pequeno (0.01) para evitar overshooting.",
                                  "learningObjective": "Construir o núcleo iterativo do algoritmo com controle de convergência.",
                                  "commonMistakes": [
                                    "Passo α muito grande causando divergência",
                                    "Loop infinito por tolerância inadequada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Validar e Analisar a Implementação",
                                  "subSteps": [
                                    "Teste com função quadrática conhecida: mínimo em (0,0).",
                                    "Aplique a função Rosenbrock (não linear): valide convergência.",
                                    "Compare passo fixo vs. adaptativo em métricas (iterações, precisão).",
                                    "Gere relatório: plots de trajetórias, tempo de CPU.",
                                    "Otimize código: vetorize para nD."
                                  ],
                                  "verification": "Algoritmo encontra mínimo com erro < 1e-6 em < 1000 iterações para testes padrão.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matplotlib",
                                    "SciPy.optimize para benchmark",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use %timeit para medir performance.",
                                  "learningObjective": "Validar robustez e performance do algoritmo implementado.",
                                  "commonMistakes": [
                                    "Não benchmarkar contra solvers prontos",
                                    "Ignorar escala da função"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o gradiente descendente para minimizar f(x,y) = (1 - x)² + 100(y - x²)² (função de Rosenbrock), iniciando em x0=(0,0), com α=0.001 fixo e adaptativo via backtracking. Plote a trajetória e confirme convergência para (1,1).",
                              "finalVerifications": [
                                "O algoritmo converge para o mínimo conhecido com erro < 1e-6.",
                                "Plots mostram redução monotônica de f(x) e gradiente.",
                                "Implementação funciona em 1D, 2D e nD.",
                                "Variante adaptativa requer menos iterações que fixa.",
                                "Código é modular e reutilizável.",
                                "Testes unitários passam para gradiente e iterações."
                              ],
                              "assessmentCriteria": [
                                "Precisão da convergência (erro final < 1e-5).",
                                "Eficiência computacional (iterações < 2000).",
                                "Robustez a diferentes inicializações e funções.",
                                "Qualidade do código (comentado, vetorizado).",
                                "Análise comparativa fixo vs. adaptativo.",
                                "Visualizações claras e informativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e análise de funções multivariáveis.",
                                "Programação: Vetorização NumPy e otimização de código.",
                                "Engenharia Civil: Otimização de parâmetros em modelos finitos de estruturas.",
                                "Física: Simulação de dinâmica de partículas descendentes.",
                                "Machine Learning: Base para treinamento de redes neurais."
                              ],
                              "realWorldApplication": "Na engenharia civil, otimiza o dimensionamento de vigas e lajes minimizando custos de material sob restrições de deformação e resistência, integrando em softwares como ANSYS ou MATLAB para soluções computacionais eficientes."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Usar método de Newton",
                            "description": "Aplicar aproximação quadrática com Hessiana invertida para convergência quadrática em problemas suaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos Matemáticos do Método de Newton",
                                  "subSteps": [
                                    "Revise o conceito de função objetivo f(x) suave e diferenciável duas vezes.",
                                    "Identifique o gradiente ∇f(x) como direção de descida mais íngreme.",
                                    "Explique a Hessiana H(x) = ∇²f(x) como aproximação quadrática local da função.",
                                    "Entenda a aproximação quadrática: f(x + d) ≈ f(x) + ∇f(x)^T d + (1/2) d^T H(x) d.",
                                    "Discuta condições para convergência quadrática: H positiva definida."
                                  ],
                                  "verification": "Resuma verbalmente ou por escrito os papéis do gradiente e Hessiana, com equações corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de otimização (ex: Nocedal & Wright), caderno para anotações, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Visualize a parábola de aproximação quadrática para intuír a curvatura local.",
                                  "learningObjective": "Dominar a base teórica da aproximação quadrática usada pelo método de Newton.",
                                  "commonMistakes": "Confundir Hessiana com gradiente; ignorar requisitos de suavidade da função."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Iteração do Algoritmo de Newton",
                                  "subSteps": [
                                    "Estabeleça a iteração: x_{k+1} = x_k - H(x_k)^{-1} ∇f(x_k).",
                                    "Resolva o sistema linear H(x_k) d_k = -∇f(x_k) para direção d_k.",
                                    "Discuta a necessidade de line search ou trust region se H não for positiva definida.",
                                    "Analise localmente a redução quadrática: ||x_{k+1} - x*|| ≈ constante * ||x_k - x*||².",
                                    "Escreva pseudocódigo básico do algoritmo."
                                  ],
                                  "verification": "Derive corretamente a iteração em papel e verifique com um exemplo unidimensional simples.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis, software de álgebra simbólica (MATLAB ou Python com SymPy).",
                                  "tips": "Comece com f(x) = x²/2 para ver convergência em uma iteração.",
                                  "learningObjective": "Derivar e justificar a fórmula de atualização do método de Newton.",
                                  "commonMistakes": "Esquecer o sinal negativo na direção de descida; assumir H sempre invertível."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Método de Newton em Código",
                                  "subSteps": [
                                    "Defina a função objetivo f(x), gradiente e Hessiana analiticamente.",
                                    "Implemente solver de sistema linear (ex: np.linalg.solve em Python).",
                                    "Escreva loop iterativo com critério de parada (tol=1e-6 em norma do gradiente).",
                                    "Adicione modificador para Hessiana (ex: adicionar identidade se não PD).",
                                    "Teste com função benchmark como Rosenbrock."
                                  ],
                                  "verification": "Execute código e confirme que gradiente final é próximo de zero.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com NumPy/SciPy, Jupyter Notebook, função de teste pré-definida.",
                                  "tips": "Use autograd (ex: JAX ou PyTorch) para derivadas automáticas se analíticas forem complexas.",
                                  "learningObjective": "Codificar funcionalmente o algoritmo para problemas multivariados.",
                                  "commonMistakes": "Erro numérico em inversão direta (use solver); loop infinito sem tolerância."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Analisar Convergência em Problema de Engenharia Civil",
                                  "subSteps": [
                                    "Escolha problema: minimizar peso de treliça sujeito a restrições de tensão.",
                                    "Formule f(x) como função de seções transversais x.",
                                    "Execute método de Newton e registre histórico de ||∇f|| e iterações.",
                                    "Compare com gradiente descendente para destacar convergência quadrática.",
                                    "Avalie sensibilidade a inicialização."
                                  ],
                                  "verification": "Plote curvas de convergência mostrando redução quadrática.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código Python anterior, dados de treliça (ex: truss10 dataset).",
                                  "tips": "Monitore cond number da Hessiana para diagnosticar problemas.",
                                  "learningObjective": "Aplicar método em contexto real e validar propriedades de convergência.",
                                  "commonMistakes": "Ignorar não-PD da Hessiana em problemas reais; inicialização ruim."
                                }
                              ],
                              "practicalExample": "Otimizar dimensões de uma viga cantilever para minimizar deflexão sob carga, onde f(x) = deflexão(x1,largura; x2,altura), usando Newton para convergir rapidamente de inicial grosseira.",
                              "finalVerifications": [
                                "Gradiente final ||∇f(x*)|| < 1e-8.",
                                "Hessiana em x* positiva definida (autovalores > 0).",
                                "Número de iterações < 10 para problema suave.",
                                "Solução satisfaz restrições físicas (ex: tensões < limite).",
                                "Código roda sem erros numéricos.",
                                "Histórico mostra ||∇f_{k+1}|| / ||∇f_k||² ≈ constante."
                              ],
                              "assessmentCriteria": [
                                "Correção da derivação da iteração (100% precisão matemática).",
                                "Implementação computacional convergente e eficiente.",
                                "Análise qualitativa/quantitativa de convergência quadrática.",
                                "Aplicação contextualizada em engenharia civil.",
                                "Tratamento robusto de casos não-PD.",
                                "Documentação clara do código e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Avançado: Derivadas parciais e séries de Taylor.",
                                "Programação Numérica: Solvers lineares e controle de erros.",
                                "Mecânica dos Sólidos: Formulação de funções objetivo em estruturas.",
                                "Estatística: Análise de sensibilidade e confiança em mínimos."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para otimizar projetos estruturais como pontes ou edifícios, minimizando custo/peso enquanto satisfaz normas de segurança, acelerando iterações em software como ANSYS ou custom solvers."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Aplicar métodos quasi-Newton (BFGS)",
                            "description": "Implementar atualização aproximada da Hessiana sem inversão explícita, comparando convergência com Newton.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Métodos Newton e Quasi-Newton",
                                  "subSteps": [
                                    "Estude o método de Newton clássico para otimização não linear, focando na aproximação quadrática da função objetivo via Hessiana.",
                                    "Entenda as limitações do Newton: custo computacional alto devido à inversão da Hessiana e necessidade de segundas derivadas.",
                                    "Aprenda os princípios de métodos quasi-Newton: uso de aproximações de baixa ordem da Hessiana atualizadas iterativamente.",
                                    "Identifique famílias quasi-Newton como DFP e BFGS, destacando a simetria e positividade definida preservadas.",
                                    "Resolva exercícios analíticos simples para visualizar atualizações de matrizes."
                                  ],
                                  "verification": "Responda corretamente a um quiz com 5 perguntas sobre diferenças entre Newton e quasi-Newton, com pelo menos 90% de acerto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Numerical Optimization' de Nocedal e Wright (cap. 6)",
                                    "Slides ou vídeo sobre métodos quasi-Newton (Khan Academy ou MIT OCW)",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Desenhe diagramas das atualizações matriciais para fixar conceitos visuais.",
                                  "learningObjective": "Compreender as bases teóricas que motivam o BFGS como alternativa eficiente ao Newton.",
                                  "commonMistakes": [
                                    "Confundir BFGS com gradiente conjugado",
                                    "Ignorar requisitos de positividade definida na Hessiana aproximada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Entender a Fórmula de Atualização BFGS",
                                  "subSteps": [
                                    "Derive a fórmula BFGS: B_{k+1} = B_k - (B_k s_k s_k^T B_k)/(s_k^T B_k s_k) + (y_k y_k^T)/(y_k^T s_k), onde s_k = x_{k+1} - x_k e y_k = ∇f(x_{k+1}) - ∇f(x_k).",
                                    "Explique as propriedades: preserva simetria, positividade definida se iniciada corretamente, e superlinear convergência.",
                                    "Implemente uma função auxiliar em Python para calcular a atualização BFGS manualmente em 2D.",
                                    "Compare com DFP em um exemplo numérico pequeno para ver diferenças.",
                                    "Analise estabilidade numérica e condições para inicialização (ex: B_0 = I)."
                                  ],
                                  "verification": "Implemente e teste a atualização BFGS em um problema toy 2D, verificando simetria e positividade com np.allclose e eigenvalues > 0.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy e SciPy",
                                    "Artigo original de Broyden, Fletcher, Goldfarb, Shanno",
                                    "Caderno para derivações matemáticas"
                                  ],
                                  "tips": "Use sympy para derivar simbolicamente e evitar erros algébricos.",
                                  "learningObjective": "Dominar a mecânica exata da atualização BFGS e suas garantias teóricas.",
                                  "commonMistakes": [
                                    "Erro na definição de y_k ou s_k",
                                    "Não verificar positividade definida após update"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Algoritmo BFGS Completo",
                                  "subSteps": [
                                    "Escreva o loop principal: inicialize B_0, compute direção p_k = -B_k^{-1} g_k (usando solve), line search para α_k, atualize x, g, B.",
                                    "Inclua critérios de parada: ||g|| < tol, max_iter, ou stagnation.",
                                    "Teste em função benchmark como Rosenbrock ou Himmelblau.",
                                    "Otimize para eficiência: evite inversão explícita usando Cholesky ou solve.",
                                    "Adicione logging de iterações, norma do gradiente e tempo."
                                  ],
                                  "verification": "Código converge para mínimo conhecido em <50 iterações para Rosenbrock, com erro <1e-6.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python/NumPy/SciPy/Matplotlib",
                                    "Funções de teste de otimização (scipy.optimize.rosen)",
                                    "GitHub para versionamento"
                                  ],
                                  "tips": "Use backtracking line search simples para robustez.",
                                  "learningObjective": "Construir uma implementação funcional e eficiente de BFGS do zero.",
                                  "commonMistakes": [
                                    "Inversão explícita da Hessiana (lenta)",
                                    "Line search inadequada causando não-monotonicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Convergência BFGS vs. Newton",
                                  "subSteps": [
                                    "Implemente método Newton puro para comparação (Hessiana exata via autograd ou hessian).",
                                    "Execute ambos em 3 problemas: quadrático, não-convexo e high-dim (ex: least-squares em engenharia).",
                                    "Plote curvas de convergência: iterações vs. ||g||, tempo CPU.",
                                    "Analise métricas: iterações, tempo, precisão final.",
                                    "Discuta trade-offs em contextos de engenharia civil (ex: otimização de estruturas)."
                                  ],
                                  "verification": "Relatório com plots mostrando BFGS mais eficiente em iterações/tempo para problemas não-quadráticos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Jupyter Notebook com plots Matplotlib",
                                    "Autograd ou JAX para derivadas automáticas",
                                    "Dados de benchmark (ex: truss optimization dataset)"
                                  ],
                                  "tips": "Normalize eixos log para curvas de convergência.",
                                  "learningObjective": "Avaliar empiricamente as vantagens do BFGS sobre Newton.",
                                  "commonMistakes": [
                                    "Comparação em problemas onde Newton é ótimo (quadráticos)",
                                    "Ignorar custo de segundas derivadas no Newton"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimize o dimensionamento de uma treliça simples em engenharia civil: minimize peso sujeito a restrições de tensão, usando BFGS para atualizar Hessiana aproximada sem computar Hessiana exata cara a cada iteração.",
                              "finalVerifications": [
                                "Código BFGS converge superlinearmente em benchmarks padrão.",
                                "Atualizações preservam simetria e positividade definida (verificado numericamente).",
                                "Comparação mostra BFGS superior em tempo para dims >10.",
                                "Implementação lida com line search robusto sem falhas.",
                                "Relatório inclui plots e métricas quantitativas.",
                                "Aplicação em problema civil real converge a solução viável."
                              ],
                              "assessmentCriteria": [
                                "Correção teórica da implementação BFGS (100% match com fórmulas).",
                                "Eficiência computacional: tempo < Newton em 80% dos testes.",
                                "Robustez: converge em 5/5 benchmarks sem crashes.",
                                "Qualidade de visualizações e análise comparativa.",
                                "Clareza do código: comentado, modular, reprodutível.",
                                "Integração com contexto civil: exemplo relevante."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Análise de erros e estabilidade matricial.",
                                "Programação Científica: Uso de NumPy/SciPy para álgebra linear.",
                                "Engenharia Estrutural: Otimização de treliças e vigas.",
                                "Estatística: Confiança em mínimos locais via hessianas.",
                                "Física Computacional: Simulações dinâmicas otimizadas."
                              ],
                              "realWorldApplication": "Em engenharia civil, BFGS otimiza projetos de pontes e edifícios minimizando custos/materiais sob restrições, evitando o custo proibitivo de Hessianas exatas em modelos FEM de alta dimensão."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Métodos de Otimização com Restrições",
                        "description": "Abordagens para lidar com restrições de igualdade e desigualdade em problemas não lineares, incluindo multiplicadores de Lagrange.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Formular multiplicadores de Lagrange",
                            "description": "Construir função Lagrangiana e resolver sistema de equações para condições de otimalidade de Karush-Kuhn-Tucker (KKT).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o problema de otimização e suas componentes",
                                  "subSteps": [
                                    "Defina a função objetivo f(x) a ser minimizada ou maximizada.",
                                    "Liste todas as restrições de igualdade g_i(x) = 0 e desigualdade h_j(x) ≤ 0.",
                                    "Identifique as variáveis de decisão x e seus domínios.",
                                    "Classifique as restrições como ativas ou inativas preliminarmente.",
                                    "Esboce o problema graficamente se possível (para 2 variáveis)."
                                  ],
                                  "verification": "Verifique se todas as componentes (objetivo, restrições) estão corretamente listadas e classificadas em um documento ou caderno.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, software de edição de texto (ex: LaTeX ou Word), calculadora.",
                                  "tips": "Sempre normalize as restrições para o formato padrão h(x) ≤ 0.",
                                  "learningObjective": "Compreender a estrutura completa de um problema de otimização não linear com restrições.",
                                  "commonMistakes": "Esquecer variáveis slack para desigualdades ou confundir igualdades com desigualdades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a função Lagrangiana",
                                  "subSteps": [
                                    "Introduza multiplicadores λ_i para restrições de igualdade: L = f(x) + Σ λ_i g_i(x).",
                                    "Para desigualdades, introduza μ_j ≥ 0: L += Σ μ_j h_j(x).",
                                    "Inclua multiplicadores complementares: μ_j h_j(x) = 0 para cada j.",
                                    "Escreva a Lagrangiana completa L(x, λ, μ).",
                                    "Verifique dimensionalidade: número de λ igual ao de g, μ ao de h."
                                  ],
                                  "verification": "Confirme que a expressão da Lagrangiana inclui todos os termos corretos e multiplicadores apropriados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, caneta, editor matemático (ex: MathType ou Overleaf).",
                                  "tips": "Use notação consistente: λ para igualdades, μ para desigualdades.",
                                  "learningObjective": "Formular corretamente a função Lagrangiana para problemas com restrições mistas.",
                                  "commonMistakes": "Omitir os sinais corretos nos termos das restrições ou esquecer condições de complementaridade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as condições de otimalidade KKT",
                                  "subSteps": [
                                    "Estabeleça ∇L = 0: ∇f + Σ λ_i ∇g_i + Σ μ_j ∇h_j = 0.",
                                    "Inclua primal feasibility: g_i(x*) = 0 e h_j(x*) ≤ 0.",
                                    "Dual feasibility: μ_j ≥ 0.",
                                    "Complementarity slackness: μ_j h_j(x*) = 0.",
                                    "Escreva o sistema completo de equações não lineares."
                                  ],
                                  "verification": "Liste todas as 4 condições KKT e verifique se o número de equações iguala o número de variáveis (x, λ, μ).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora simbólica (ex: SymPy ou Mathematica), papel.",
                                  "tips": "Comece com gradientes parciais para cada componente.",
                                  "learningObjective": "Derivar e compreender as condições necessárias de otimalidade KKT.",
                                  "commonMistakes": "Confundir os sinais nos gradientes ou ignorar a viabilidade primal/dual."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o sistema de equações KKT",
                                  "subSteps": [
                                    "Substitua suposições sobre quais desigualdades são ativas (μ_j > 0 ou =0).",
                                    "Resolva analiticamente para problemas simples ou numericamente (ex: fsolve no MATLAB).",
                                    "Verifique se a solução satisfaz todas as KKT.",
                                    "Calcule o valor da função objetivo na solução.",
                                    "Teste sensibilidade variando suposições de ativas."
                                  ],
                                  "verification": "A solução encontrada satisfaz todas as condições KKT e o multiplicador μ ≥ 0.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software numérico (MATLAB, Python com SciPy), computador.",
                                  "tips": "Para problemas pequenos, resolva à mão; senão, use solvers iterativos.",
                                  "learningObjective": "Aplicar métodos para resolver sistemas KKT e validar soluções.",
                                  "commonMistakes": "Não verificar complementaridade ou assumir incorretamente quais restrições são ativas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e multiplicadores",
                                  "subSteps": [
                                    "Analise o sinal dos λ: indica direção da restrição na otimalidade.",
                                    "Para μ > 0, restrição ativa; interprete economicamente (sombra price).",
                                    "Compare com solução sem restrições.",
                                    "Discuta unicidade e convexidade assumida.",
                                    "Documente insights para o problema de engenharia."
                                  ],
                                  "verification": "Explique o significado de cada multiplicador em contexto e valide numericamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gráficos (ex: plot no Python), relatório escrito.",
                                  "tips": "Multiplicadores representam taxas marginais de melhoria ao relaxar restrições.",
                                  "learningObjective": "Interpretar multiplicadores de Lagrange no contexto de engenharia.",
                                  "commonMistakes": "Ignorar interpretação prática dos valores dos multiplicadores."
                                }
                              ],
                              "practicalExample": "Otimize o custo de uma viga em concreto armado: min c1*x1 + c2*x2 s.a. x1 + x2 >= L (restrição de comprimento), x1 <= A, x2 <= B (desigualdades de área máxima). Formule L, derive KKT e resolva para encontrar multiplicadores que indicam sensibilidade ao comprimento L.",
                              "finalVerifications": [
                                "Lagrangiana inclui todos os termos corretos com multiplicadores apropriados.",
                                "Todas as condições KKT (estacionariedade, primal/dual feasibility, complementaridade) são satisfeitas.",
                                "Solução numérica converge e multiplicadores μ ≥ 0.",
                                "Verificação gráfica ou analítica confirma otimalidade local.",
                                "Interpretação dos multiplicadores alinha com contexto do problema.",
                                "Teste de sensibilidade mostra comportamento esperado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação da Lagrangiana (100% dos termos corretos).",
                                "Correta derivação de todas as condições KKT (sem erros de sinal ou omissões).",
                                "Solução válida do sistema com verificação completa.",
                                "Interpretação qualitativa e quantitativa dos multiplicadores.",
                                "Eficiência no uso de ferramentas computacionais.",
                                "Clareza na documentação e submissão de passos intermediários."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Vetorial: Gradientes e derivadas parciais.",
                                "Programação Numérica: Solvers não lineares em Python/MATLAB.",
                                "Engenharia Civil: Otimização de estruturas e materiais.",
                                "Economia: Interpretação de preços sombra em alocação de recursos.",
                                "Estatística: Análise de sensibilidade e incertezas."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, como otimizar o dimensionamento de vigas ou fundações sob restrições de custo, resistência e normas de segurança, onde multiplicadores de Lagrange quantificam o impacto marginal de relaxar restrições (ex: custo extra por unidade de resistência adicional), auxiliando decisões em software como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Implementar método de penalidade",
                            "description": "Transformar problema restrito em não restrito adicionando termos de penalidade quadráticos para violações de restrições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o Problema de Otimização Restrito Original",
                                  "subSteps": [
                                    "Identifique a função objetivo f(x) a ser minimizada.",
                                    "Liste todas as restrições de igualdade h_j(x) = 0 e desigualdade g_i(x) ≤ 0.",
                                    "Defina os limites das variáveis de decisão x ∈ [l, u].",
                                    "Escreva a formulação matemática completa do problema.",
                                    "Verifique a viabilidade inicial com um ponto teste."
                                  ],
                                  "verification": "Capacidade de escrever corretamente a formulação matemática e identificar pelo menos um ponto viável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notebook Jupyter ou editor de texto",
                                    "Documentação de problemas de otimização em Engenharia Civil"
                                  ],
                                  "tips": "Use notação padrão: min f(x) s.t. h(x)=0, g(x)≤0 para clareza.",
                                  "learningObjective": "Compreender e representar precisamente um problema de otimização com restrições.",
                                  "commonMistakes": [
                                    "Confundir restrições de igualdade com desigualdade",
                                    "Ignorar limites de variáveis",
                                    "Não verificar viabilidade inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Função de Penalidade Quadrática",
                                  "subSteps": [
                                    "Para restrições de igualdade h_j(x)=0, defina penalidade ρ/2 * [h_j(x)]^2.",
                                    "Para restrições de desigualdade g_i(x)≤0, defina penalidade ρ/2 * [max(0, g_i(x))]^2.",
                                    "Escolha o multiplicador inicial de penalidade ρ (ex: ρ=1).",
                                    "Escreva a expressão combinada da penalidade P(x).",
                                    "Teste a função penalidade em um ponto viável e inviável."
                                  ],
                                  "verification": "A função penalidade retorna 0 em pontos viáveis e valor positivo em inviáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Notebook Jupyter",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Use max(0, g(x)) para desigualdades para evitar penalizar soluções factíveis.",
                                  "learningObjective": "Construir corretamente os termos de penalidade para diferentes tipos de restrições.",
                                  "commonMistakes": [
                                    "Usar g_i(x)^2 em vez de [max(0,g_i(x))]^2 para desigualdades",
                                    "Esquecer o fator 1/2 nos termos quadráticos",
                                    "Escolher ρ muito pequeno inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o Problema Não Restrito Penalizado",
                                  "subSteps": [
                                    "Combine a função objetivo com a penalidade: P_ρ(x) = f(x) + ∑ penalidades.",
                                    "Implemente P_ρ(x) como uma função computacional em código.",
                                    "Compute gradiente analítico ou numérico de P_ρ(x).",
                                    "Teste P_ρ em pontos conhecidos para validar a implementação.",
                                    "Aumente ρ iterativamente (ex: ρ ← 10ρ) para sequências de penalidade."
                                  ],
                                  "verification": "P_ρ(x) é suave, diferenciável e penaliza corretamente violações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy e SciPy",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Implemente gradiente para aceleradores como BFGS; evite gradiente descendente puro se possível.",
                                  "learningObjective": "Transformar problema restrito em não restrito usando penalidade quadrática.",
                                  "commonMistakes": [
                                    "Não somar todos os termos de penalidade",
                                    "Erro no cálculo do max(0,g)",
                                    "Ignorar gradiente na implementação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Executar o Algoritmo de Minimização",
                                  "subSteps": [
                                    "Escolha um minimizador não restrito (ex: minimize de SciPy com método='BFGS').",
                                    "Execute minimização para ρ inicial e monitore convergência.",
                                    "Aumente ρ em loops até violações < ε (ex: 1e-6).",
                                    "Registre soluções x_k e valores f(x_k) para cada ρ.",
                                    "Plote curvas de convergência e violações vs. iterações."
                                  ],
                                  "verification": "O algoritmo converge para uma solução com violações próximas de zero.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Python com SciPy.optimize",
                                    "Matplotlib para plots",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use opções de tolerância baixa (ftol=1e-9) e monitore ||grad|| < 1e-6.",
                                  "learningObjective": "Aplicar solvers numéricos ao problema penalizado e gerenciar sequência de ρ.",
                                  "commonMistakes": [
                                    "ρ crescendo muito rápido causando ill-conditioning",
                                    "Não checar se minimizador convergiu",
                                    "Ignorar avisos de singularidade na Hessiana"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar a Solução",
                                  "subSteps": [
                                    "Compare solução penalizada com solução exata (se conhecida) ou Lagrange.",
                                    "Meça violações totais ∑|h| + ∑max(0,g).",
                                    "Avalie sensibilidade variando ρ final.",
                                    "Analise tempo computacional e precisão.",
                                    "Documente limitações do método (ex: para problemas não convexos)."
                                  ],
                                  "verification": "Solução final satisfaz restrições dentro de tolerância e objetivo próximo ao ótimo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com SciPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Para problemas civis, valide com normas como ABNT para estruturas.",
                                  "learningObjective": "Avaliar robustez e precisão do método de penalidade.",
                                  "commonMistakes": [
                                    "Aceitar soluções com violações altas",
                                    "Não comparar com benchmarks",
                                    "Subestimar ill-conditioning para ρ grande"
                                  ]
                                }
                              ],
                              "practicalExample": "Minimize f(x,y) = x² + y² sujeito a x + y = 1 (igualdade). Solução exata: x=y=0.5, f=0.5. Com penalidade: P_ρ(x,y) = x² + y² + (ρ/2)(x+y-1)². Para ρ=100, minimizar P_ρ converge para ≈(0.5,0.5). Em contexto civil: otimizar áreas de seções transversais de treliça minimizando volume s.t. tensões ≤ limite.",
                              "finalVerifications": [
                                "Violações de restrições < 1e-6 na solução final.",
                                "Gradiente de P_ρ na solução ≈ 0.",
                                "Solução converge ao aumentar ρ.",
                                "Valor objetivo próximo à solução restrita ótima.",
                                "Número de iterações razoável (<1000).",
                                "Matriz Hessiana positiva definida na solução."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da função penalidade (100%).",
                                "Implementação numérica sem erros de código (90%).",
                                "Convergência demonstrada com múltiplos ρ (80%).",
                                "Análise de violações e precisão (70%).",
                                "Documentação clara com plots e comparações (60%).",
                                "Eficiência computacional otimizada (50%)."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Derivadas e gradientes para minimização.",
                                "Programação Computacional: Implementação em Python/SciPy.",
                                "Álgebra Linear: Análise de Hessiana e condicionamento.",
                                "Engenharia de Software: Modularidade no código de otimização.",
                                "Estatística: Análise de sensibilidade e intervalos de confiança."
                              ],
                              "realWorldApplication": "Na engenharia civil, otimizar dimensionamento de estruturas como pontes ou edifícios, minimizando custo de material sujeito a restrições de segurança (tensões, deformações), usando métodos de penalidade em solvers computacionais para designs eficientes e conformes a normas como Eurocode ou ABNT."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Aplicar método de barreira",
                            "description": "Usar funções de barreira logarítmica para desigualdades, ajustando parâmetros para aproximação da solução ótima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema de otimização e construir a função de barreira",
                                  "subSteps": [
                                    "Identificar a função objetivo f(x) e as restrições de desigualdade g_i(x) ≤ 0 e igualdades h_j(x) = 0.",
                                    "Escrever a função de barreira logarítmica: L_μ(x) = f(x) - μ ∑ log(-g_i(x)) para restrições de desigualdade.",
                                    "Incorporar restrições de igualdade se necessário, usando multiplicadores de Lagrange.",
                                    "Verificar que o domínio da barreira é factível (g_i(x) < 0).",
                                    "Escolher valor inicial alto para o parâmetro de barreira μ (ex: μ=10)."
                                  ],
                                  "verification": "Função L_μ(x) escrita corretamente e derivadas parciais computadas sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta para derivações",
                                    "Software como Python (NumPy/SciPy) ou MATLAB para prototipagem"
                                  ],
                                  "tips": "Sempre verifique o sinal das restrições para evitar log de números positivos.",
                                  "learningObjective": "Compreender como transformar restrições em penalidades logarítmicas suaves.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo em log(-g_i(x))",
                                    "Ignorar restrições de igualdade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar parâmetros e selecionar ponto inicial estritamente factível",
                                  "subSteps": [
                                    "Escolher um ponto inicial x^0 tal que g_i(x^0) < 0 para todas desigualdades.",
                                    "Definir sequência de μ_k decrescente (ex: μ_{k+1} = 0.1 μ_k).",
                                    "Configurar tolerâncias para gradiente e restrições (ex: 10^-6).",
                                    "Implementar função para avaliar L_μ(x) e suas derivadas (gradiente e Hessiana).",
                                    "Testar avaliação inicial da função de barreira."
                                  ],
                                  "verification": "Ponto inicial gera valores finitos para L_μ(x^0) e gradiente computado corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código (Python/Jupyter Notebook)",
                                    "Bibliotecas NumPy, SciPy para derivadas numéricas"
                                  ],
                                  "tips": "Use métodos simples como gradiente conjugado para minimizações iniciais se Hessiana for complexa.",
                                  "learningObjective": "Garantir factibilidade inicial para evitar singularidades na barreira.",
                                  "commonMistakes": [
                                    "Escolher x^0 na fronteira (g_i=0)",
                                    "Sequência de μ decaindo muito rápido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações centrais: minimizar funções de barreira sucessivas",
                                  "subSteps": [
                                    "Para cada μ_k, minimizar L_μ_k(x) a partir do mínimo anterior x^{k-1} usando método de Newton.",
                                    "Atualizar x^k = argmin L_μ_k(x), resolvendo sistemas lineares com Hessiana H = ∇²L_μ.",
                                    "Diminuir μ_k e repetir até critério de parada (||∇L_μ|| < ε ou violações pequenas).",
                                    "Monitorar dual feasibility: multiplicadores λ_i ≈ μ / -g_i(x).",
                                    "Ajustar passos se Hessiana não positiva definida (modificação de Levenberg-Marquardt)."
                                  ],
                                  "verification": "Cada minimização converge (queda em L_μ observada) e violações g_i(x^k) → 0.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de otimização (SciPy.optimize, CVXPY para teste)",
                                    "Computador para simulações numéricas"
                                  ],
                                  "tips": "Reutilize o ponto anterior como quente start para aceleração.",
                                  "learningObjective": "Aplicar otimizadores locais para aproximar soluções centrais.",
                                  "commonMistakes": [
                                    "Não atualizar μ adequadamente",
                                    "Ignorar ill-conditioning da Hessiana perto da fronteira"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar convergência, recuperar multiplicadores e validar solução",
                                  "subSteps": [
                                    "Confirmar primal feasibility: max g_i(x*) ≤ ε.",
                                    "Recuperar multiplicadores de Lagrange: λ_i* = μ / -g_i(x*) para desigualdades ativas.",
                                    "Verificar dual feasibility e complementaridade: λ_i* g_i(x*) ≈ 0.",
                                    "Comparar f(x*) com soluções conhecidas ou bounds.",
                                    "Analisar sensibilidade variando μ final."
                                  ],
                                  "verification": "Solução x* satisfaz KKT com tolerância < 10^-4.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilhas ou scripts para análise de resíduos KKT"
                                  ],
                                  "tips": "Use resíduos KKT para diagnosticar falhas de convergência.",
                                  "learningObjective": "Interpretar condições de otimalidade na solução limite.",
                                  "commonMistakes": [
                                    "Aceitar solução sem checar factibilidade",
                                    "Multiplicadores com sinal errado"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimizar o custo de uma viga de concreto armado: minimizar C = a*w + b*h sujeito a restrições de momento fletor M ≤ σ*w*h²/6 e cisalhamento V ≤ τ*w*h, onde w e h são largura e altura. Aplicar barreira para encontrar dimensões ótimas.",
                              "finalVerifications": [
                                "Solução x* é factível (todas g_i(x*) ≤ 0).",
                                "Gradiente da Lagrangian ≈ 0 (otimalidade primal-dual).",
                                "Multiplicadores recuperados são não-negativos para desigualdades.",
                                "Função objetivo converge monotonicamente.",
                                "Resíduos KKT abaixo de tolerância pré-definida.",
                                "Solução estável a pequenas perturbações em dados."
                              ],
                              "assessmentCriteria": [
                                "Correta formulação da função de barreira logarítmica.",
                                "Convergência numérica eficiente (menos de 20 iterações principais).",
                                "Recuperação precisa de multiplicadores dual (>90% acurácia).",
                                "Implementação numérica livre de erros (testes unitários passados).",
                                "Análise de sensibilidade demonstrada.",
                                "Solução alinhada com otimalidade teórica (gap duality pequeno)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Resolução de sistemas com Hessiana e decomposição Cholesky.",
                                "Programação Computacional: Implementação em Python/SciPy para métodos numéricos.",
                                "Cálculo: Derivadas de ordem superior e condições de segunda ordem.",
                                "Engenharia Estrutural: Aplicação em dimensionamento otimizado de elementos.",
                                "Estatística: Análise de incertezas em parâmetros de otimização."
                              ],
                              "realWorldApplication": "No projeto de estruturas civis, como pontes ou edifícios, o método de barreira otimiza o uso de materiais minimizando custos sob restrições de segurança (normas ABNT NBR), permitindo designs eficientes e sustentáveis em softwares como ANSYS ou custom solvers."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.4",
                            "name": "Resolver problemas em Engenharia Civil",
                            "description": "Aplicar PNL para otimizar estruturas, como dimensionamento de vigas com restrições de resistência e custo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema de otimização em PNL",
                                  "subSteps": [
                                    "Identificar variáveis de decisão (ex: largura b, altura h da viga).",
                                    "Definir função objetivo (ex: minimizar custo C = k * b * h).",
                                    "Estabelecer restrições de desigualdade (ex: tensão de flexão ≤ σ_adm, deflexão ≤ δ_max) e igualdade se aplicável.",
                                    "Expressar todas as funções em termos matemáticos não lineares.",
                                    "Verificar convexidade ou não linearidades do problema."
                                  ],
                                  "verification": "Modelo matemático escrito e balanceado, com todas restrições explicitadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Folha de papel ou editor LaTeX, normas técnicas (ABNT NBR 6118), calculadora.",
                                  "tips": "Comece com um diagrama esquemático da estrutura para visualizar cargas e restrições.",
                                  "learningObjective": "Capacitar a modelagem precisa de problemas reais em forma padrão de PNL.",
                                  "commonMistakes": "Esquecer restrições de fabricação (ex: b ≥ 0.1m) ou linearizar prematuramente funções não lineares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e entender método de otimização com restrições",
                                  "subSteps": [
                                    "Revisar métodos para PNL com restrições (ex: multiplicadores de Lagrange, penalização, barreira interior).",
                                    "Escolher método adequado (ex: gradiente projetado para restrições simples).",
                                    "Derivar condições de otimalidade de Karush-Kuhn-Tucker (KKT).",
                                    "Implementar pseudocódigo do algoritmo.",
                                    "Testar algoritmo em problema toy simples."
                                  ],
                                  "verification": "Pseudocódigo funcional em problema teste converge para solução conhecida.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Livro 'Numerical Optimization' de Nocedal & Wright, Jupyter Notebook.",
                                  "tips": "Priorize métodos que lidam bem com não convexidade, como Sequential Quadratic Programming (SQP).",
                                  "learningObjective": "Compreender e selecionar algoritmos apropriados para restrições não lineares.",
                                  "commonMistakes": "Ignorar viabilidade inicial (escolher ponto factível) ou assumir convexidade sem prova."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e resolver numericamente",
                                  "subSteps": [
                                    "Configurar ambiente de programação (Python com SciPy.optimize ou MATLAB fmincon).",
                                    "Codificar função objetivo e restrições como funções vetoriais.",
                                    "Definir opções do solver (tolerâncias, máximo iterações).",
                                    "Executar otimização com ponto inicial factível.",
                                    "Registrar histórico de convergência (iterações, valores de Lagrange)."
                                  ],
                                  "verification": "Código roda sem erros e retorna solução com resíduos de KKT < 1e-6.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python (SciPy, NumPy), MATLAB ou similar; dados da estrutura (L=5m, q=10kN/m).",
                                  "tips": "Use escalonamento de variáveis para melhorar numérica (ex: normalizar b,h em [0,1]).",
                                  "learningObjective": "Desenvolver proficiência em solvers numéricos para PNL aplicada.",
                                  "commonMistakes": "Funções objetivo/restritivas com gradientes incorretos ou não diferenciáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar resultados e análise de sensibilidade",
                                  "subSteps": [
                                    "Verificar se solução satisfaz todas restrições ativamente.",
                                    "Calcular custo otimizado e comparar com design heurístico.",
                                    "Realizar análise de sensibilidade (variações em cargas ou materiais).",
                                    "Interpretar multiplicadores de Lagrange para priorizar restrições.",
                                    "Documentar relatório com gráficos de convergência."
                                  ],
                                  "verification": "Relatório gerado com validação completa e insights acionáveis.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Gráficos (Matplotlib), software de simulação estrutural (ex: SAP2000 para verificação).",
                                  "tips": "Sempre valide com método analítico aproximado para problemas pequenos.",
                                  "learningObjective": "Avaliar robustez da solução e extrair insights engenheirísticos.",
                                  "commonMistakes": "Aceitar soluções locais sem múltiplos iniciais ou análise de sensibilidade."
                                }
                              ],
                              "practicalExample": "Otimizar dimensionamento de viga reta de concreto armado (L=5m, carga q=10kN/m): minimizar C=1000*b*h (R$/m), s.a. M_max = qL²/8 ≤ σ*b*h²/6 (σ=20MPa), δ_max = 5qL⁴/(384EI) ≤ L/250 (E=25GPa, I=b h³/12), b,h ≥0.2m.",
                              "finalVerifications": [
                                "Todas restrições satisfeitas com folga >0 ou ativas com multiplicadores positivos.",
                                "Função objetivo converge monotonicamente no histórico.",
                                "Solução sensível a ±10% nas cargas mantém viabilidade.",
                                "Verificação independente via software FEA (Finite Element Analysis).",
                                "Custo otimizado ≤80% do design manual inicial.",
                                "Gradientes de KKT zerados numericamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução (erro relativo <1%).",
                                "Eficiência computacional (iterações <50).",
                                "Correta formulação matemática (todas não linearidades capturadas).",
                                "Análise de sensibilidade abrangente.",
                                "Relatório claro com visualizações.",
                                "Tratamento robusto de não convexidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e análise numérica.",
                                "Programação: Desenvolvimento de solvers em Python/MATLAB.",
                                "Mecânica dos Materiais: Teoria de vigas e critérios de dimensionamento.",
                                "Gestão de Projetos: Otimização custo-benefício em engenharia."
                              ],
                              "realWorldApplication": "Dimensionamento otimizado de vigas em pontes, edifícios e lajes, reduzindo custos em 15-30% enquanto atende normas de segurança (ex: projetos de viadutos urbanos ou estruturas sísmicas)."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.2",
                              "10.1.4.3.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Métodos de Gradiente",
                    "description": "Algoritmos baseados em derivadas para otimização contínua, como gradiente descendente.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Fundamentos do Gradiente em Otimização",
                        "description": "Conceitos básicos do gradiente como direção de maior aumento da função objetivo e sua negação para descida em problemas de otimização contínua.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Calcular o gradiente de uma função escalar multivariável",
                            "description": "Derivar parcialmente funções contínuas diferenciáveis e formar o vetor gradiente, aplicando em exemplos de engenharia civil como minimização de custos estruturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de derivadas parciais e gradiente",
                                  "subSteps": [
                                    "Revise a definição de derivada parcial para funções de múltiplas variáveis: ∂f/∂x mantém outras variáveis constantes.",
                                    "Estude o vetor gradiente ∇f = (∂f/∂x₁, ∂f/∂x₂, ..., ∂f/∂xₙ) como direção de maior aumento da função.",
                                    "Identifique propriedades: magnitude indica taxa de mudança, direção aponta para o ascenso mais íngreme.",
                                    "Pratique com função simples f(x,y) = x² + y²: calcule ∂f/∂x = 2x e ∂f/∂y = 2y.",
                                    "Discuta interpretação geométrica: gradiente é perpendicular às curvas de nível."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que o gradiente representa e calcule para f(x,y)=x²+y² em (1,1).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Cálculo Multivariável (ex: Stewart)",
                                    "Vídeo tutorial sobre derivadas parciais (Khan Academy)",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Visualize com gráficos 3D usando ferramentas como GeoGebra para curvas de nível.",
                                  "learningObjective": "Compreender conceitualmente derivadas parciais e o vetor gradiente como ferramenta de otimização.",
                                  "commonMistakes": [
                                    "Confundir derivada total com parcial",
                                    "Esquecer de tratar variáveis como constantes nas parciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e representar a função escalar multivariável",
                                  "subSteps": [
                                    "Escolha uma função f: ℝⁿ → ℝ contínua e diferenciável, ex: custo C(x,y) = x² + 2xy + y² para dimensões de viga.",
                                    "Liste todas as variáveis independentes (x₁, x₂, ..., xₙ) e seu domínio físico (ex: x>0, y>0).",
                                    "Esboce o domínio e curvas de nível para visualização intuitiva.",
                                    "Verifique diferenciabilidade: funções polinomiais ou exponenciais suaves são ideais.",
                                    "Documente a função em notação vetorial: f(⃑) onde ⃑ = (x₁,...,xₙ)."
                                  ],
                                  "verification": "Escreva a função com variáveis identificadas e domínio, confirmando diferenciabilidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (GeoGebra ou MATLAB)",
                                    "Papel milimetrado para esboços"
                                  ],
                                  "tips": "Comece com 2 variáveis para simplicidade antes de multivariáveis.",
                                  "learningObjective": "Preparar a função para cálculo do gradiente, garantindo contexto de engenharia civil.",
                                  "commonMistakes": [
                                    "Ignorar restrições de domínio realistas",
                                    "Usar funções não diferenciáveis como |x|"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as derivadas parciais individuais",
                                  "subSteps": [
                                    "Para cada variável x_i, compute ∂f/∂x_i tratando outras como constantes.",
                                    "Aplique regras de derivação: potência (n x^{n-1}), produto, cadeia, etc.",
                                    "Exemplo: para C(x,y)=x² + 2xy + y², ∂C/∂x = 2x + 2y, ∂C/∂y = 2x + 2y.",
                                    "Registre cada parcial com simplificação algébrica completa.",
                                    "Verifique numericamente: avalie em ponto específico e compare com definição limite."
                                  ],
                                  "verification": "Liste todas as parciais corretas e avalie em um ponto teste, como (1,1).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora simbólica (Wolfram Alpha para verificação)",
                                    "Folha de fórmulas de derivação"
                                  ],
                                  "tips": "Use notação Leibniz ∂/∂x para clareza; pratique cadeia para funções compostas.",
                                  "learningObjective": "Dominar o cálculo preciso de derivadas parciais para qualquer função escalar.",
                                  "commonMistakes": [
                                    "Derivar todas as variáveis simultaneamente",
                                    "Erros em regra da cadeia ou produto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar o vetor gradiente e interpretá-lo",
                                  "subSteps": [
                                    "Monte ∇f = [∂f/∂x₁, ∂f/∂x₂, ..., ∂f/∂xₙ]ᵀ como vetor coluna.",
                                    "Avalie em ponto específico: ex ∇C(1,1) = [4, 4]ᵀ.",
                                    "Interprete: direção para minimizar custo (oposto ao gradiente) em otimização.",
                                    "Calcule magnitude ||∇f|| = √(∑ (∂f/∂x_i)²) para taxa de variação.",
                                    "Aplique em contexto: use para iterar em método de gradiente descendente simples."
                                  ],
                                  "verification": "Escreva o vetor gradiente completo e sua avaliação em ponto, com interpretação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/MATLAB para vetorização",
                                    "Exemplo de código para gradiente numérico"
                                  ],
                                  "tips": "Sempre normalize o gradiente para direção unitária em aplicações.",
                                  "learningObjective": "Construir e interpretar o gradiente como base para algoritmos de otimização.",
                                  "commonMistakes": [
                                    "Esquecer transposto ou ordem das componentes",
                                    "Confundir gradiente com Hessiana"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em exemplo de engenharia civil",
                                  "subSteps": [
                                    "Defina função custo: C(x,y) = 100x + 50y + x²/10 + y²/10 para viga (x largura, y altura).",
                                    "Calcule ∇C = [100 + x/5, 50 + y/5].",
                                    "Encontre ponto crítico: resolva ∇C=0 → x=-500 (inviável), discuta restrições.",
                                    "Simule iteração: comece em (10,10), atualize x_new = x - 0.01 * ∂C/∂x.",
                                    "Compare com solução analítica ou numérica para validação."
                                  ],
                                  "verification": "Produza gradiente para exemplo e uma iteração de descendente, mostrando redução de custo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Jupyter Notebook com NumPy para simulação",
                                    "Artigo sobre otimização em estruturas"
                                  ],
                                  "tips": "Inclua learning rate pequeno para estabilidade; plote convergência.",
                                  "learningObjective": "Integrar cálculo de gradiente em problema real de minimização de custos estruturais.",
                                  "commonMistakes": [
                                    "Ignorar constraints não-negatividade",
                                    "Passos de aprendizado muito grandes causando divergência"
                                  ]
                                }
                              ],
                              "practicalExample": "Em projeto de viga de concreto, minimize C(x,y) = 100x + 50y + (x² + y²)/10, onde x é largura (m), y altura (m). ∇C = [100 + x/5, 50 + y/5]. Em (10,10), ∇C ≈ [102, 52]; direção descendente reduz custo de 2450 para 2430 em uma iteração.",
                              "finalVerifications": [
                                "Calcula corretamente ∇f para f(x,y)=x²y + sin(xy) em (1, π/2).",
                                "Identifica direção de minimização como -∇f.",
                                "Aplica gradiente em função de 3 variáveis com acurácia.",
                                "Verifica numericamente parciais via diferenças finitas.",
                                "Interpreta magnitude e direção em contexto de engenharia.",
                                "Simula uma iteração de gradiente descendente convergente."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica nas derivadas parciais (sem erros de cálculo).",
                                "Correta formação e avaliação do vetor gradiente.",
                                "Interpretação física correta no contexto de otimização.",
                                "Uso apropriado de ferramentas computacionais para verificação.",
                                "Aplicação bem-sucedida em exemplo real de engenharia civil.",
                                "Clareza na documentação de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial e Integral I/II: Base teórica de derivadas.",
                                "Álgebra Linear: Vetores e operações matriciais para gradientes.",
                                "Programação Computacional: Implementação numérica em Python/MATLAB.",
                                "Física/Engenharia Mecânica: Gradientes em campos escalares como potencial.",
                                "Estatística: Gradientes em regressão logística/multivariada."
                              ],
                              "realWorldApplication": "Na engenharia civil, o gradiente otimiza custos de estruturas minimizando funções de material/volume sob cargas, como em design de vigas/pilares via métodos de gradiente descendente em software como ANSYS ou algoritmos personalizados, reduzindo desperdício em até 20%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Interpretar a direção de descida negativa do gradiente",
                            "description": "Compreender geometricamente como o vetor -∇f aponta para a direção de menor aumento da função, ilustrando com superfícies de nível e exemplos unidimensionais/multidimensionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Gradiente em Funções Univariadas",
                                  "subSteps": [
                                    "Defina a derivada como taxa de variação instantânea de f(x).",
                                    "Identifique que f'(x) > 0 indica aumento e f'(x) < 0 indica diminuição.",
                                    "Calcule a derivada em pontos específicos de uma função exemplo como f(x) = x².",
                                    "Desenhe o gráfico de f(x) e marque a direção de subida/descida baseada na derivada.",
                                    "Explique por que -f'(x) aponta para a descida mais íngreme."
                                  ],
                                  "verification": "Desenhe o gráfico de f(x) = x², marque pontos com derivadas positivas e negativas, e indique vetores de descida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou software como Desmos para gráficos"
                                  ],
                                  "tips": "Sempre relacione a derivada ao sinal da inclinação da tangente.",
                                  "learningObjective": "Compreender o gradiente unidimensional como direção de maior aumento e sua negação como descida.",
                                  "commonMistakes": [
                                    "Confundir o sinal da derivada com a direção de aumento",
                                    "Ignorar o valor absoluto da inclinação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Superfícies e Curvas de Nível em 2D",
                                  "subSteps": [
                                    "Desenhe curvas de nível para f(x,y) = x² + y² (paraboloide).",
                                    "Explique que curvas de nível conectam pontos de valor constante de f.",
                                    "Calcule o gradiente ∇f = (∂f/∂x, ∂f/∂y) em um ponto.",
                                    "Trace o vetor ∇f perpendicular às curvas de nível, apontando para fora (aumento).",
                                    "Visualize como ∇f é normal à tangente das curvas de nível."
                                  ],
                                  "verification": "Desenhe curvas de nível de f(x,y) = x² + y² e marque ∇f em (1,1), confirmando perpendicularidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software GeoGebra ou MATLAB para plotar curvas de nível"
                                  ],
                                  "tips": "Use setas grossas para vetores gradiente para melhor visualização.",
                                  "learningObjective": "Visualizar geometricamente o gradiente como perpendicular às curvas de nível.",
                                  "commonMistakes": [
                                    "Desenhar gradiente paralelo às curvas de nível",
                                    "Confundir direção de aumento com constância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a Direção de Descida Negativa do Gradiente",
                                  "subSteps": [
                                    "Compare ∇f (direção de maior aumento) com -∇f (direção de maior diminuição).",
                                    "Em curvas de nível, mostre -∇f apontando para dentro, rumo a valores menores.",
                                    "Aplique em exemplo 2D: minimize f(x,y) = x² + y² partindo de (2,2).",
                                    "Discuta magnitude: ||∇f|| indica inclinação da descida.",
                                    "Estenda para 3D: imagine superfícies e vetores normais apontando downhill."
                                  ],
                                  "verification": "Em um diagrama de curvas de nível, trace -∇f de um ponto e mostre movimento para menor f.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GeoGebra ou Python/Matplotlib para animações",
                                    "Papel para esboços manuais"
                                  ],
                                  "tips": "Pense em ∇f como 'subida mais íngreme' e -∇f como 'descida mais íngreme'.",
                                  "learningObjective": "Reconhecer -∇f como vetor direção de descida máxima em otimização.",
                                  "commonMistakes": [
                                    "Inverter direções de ∇f e -∇f",
                                    "Ignorar a perpendicularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Exemplos Multidimensionais e Otimização",
                                  "subSteps": [
                                    "Resolva numericamente um passo de gradiente descendente: x_{k+1} = x_k - α ∇f(x_k).",
                                    "Exemplo em engenharia: minimize energia potencial em estrutura com f(x,y) representando deformações.",
                                    "Compare 1D vs 2D: mostre convergência para mínimo.",
                                    "Visualize trajetórias de descida em superfícies 3D.",
                                    "Discuta limitações: tamanho de passo α."
                                  ],
                                  "verification": "Implemente 3 iterações de gradiente descendente em f(x,y) = x² + y² e plote a trajetória.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Comece com α pequeno (ex: 0.1) para evitar overshooting.",
                                  "learningObjective": "Aplicar interpretação geométrica em cenários de otimização prática.",
                                  "commonMistakes": [
                                    "Escolha errada de α levando a divergência",
                                    "Confundir mínimo local vs global"
                                  ]
                                }
                              ],
                              "practicalExample": "Em projeto de fundação de ponte (Engenharia Civil), minimize a função custo f(x,y) = (custo_material_x)^2 + (custo_aterro_y)^2 usando gradiente descendente: partindo de estimativa inicial (10m, 5m), -∇f guia ajustes para fundação ótima, reduzindo custos em 15%.",
                              "finalVerifications": [
                                "Explicar verbalmente por que -∇f é perpendicular às curvas de nível e aponta para descida.",
                                "Desenhar corretamente ∇f e -∇f em curvas de nível de f(x,y) = x² + 2y².",
                                "Calcular -∇f em ponto dado e descrever direção de movimento.",
                                "Simular 2 passos de descida e verificar redução de f.",
                                "Identificar erros comuns em diagramas fornecidos.",
                                "Relacionar a aplicações em otimização estrutural."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da direção de ∇f vs -∇f (90% correto).",
                                "Qualidade dos diagramas de curvas de nível e vetores (clareza visual).",
                                "Correção nos cálculos de gradiente e passos de descida.",
                                "Profundidade na explicação geométrica (uso de perpendicularidade).",
                                "Criatividade em exemplos aplicados à engenharia civil.",
                                "Completude das verificações e avoidance de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Física: Campos vetoriais e forças conservativas (∇V como força).",
                                "Machine Learning: Gradiente descendente em treinamento de redes neurais.",
                                "Geometria Analítica: Vetores normais a superfícies implícitas.",
                                "Programação Computacional: Implementação numérica em Python/MATLAB.",
                                "Economia: Otimização de custos em modelos lineares/multivariados."
                              ],
                              "realWorldApplication": "Na otimização de projetos civis, como dimensionamento de vigas em pontes, -∇f guia algoritmos para minimizar peso/ custo sob restrições, economizando materiais e tempo em simulações FEM (Finite Element Method)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Identificar condições de convergência local",
                            "description": "Reconhecer pontos críticos onde ∇f = 0 como mínimos locais, máximos ou selas, usando testes de Hessian para validação em problemas de otimização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Pontos Críticos em Otimização",
                                  "subSteps": [
                                    "Revise a definição de gradiente ∇f para funções multivariáveis.",
                                    "Identifique que pontos críticos ocorrem onde ∇f(x*) = 0.",
                                    "Diferencie entre condições de primeira ordem (gradiente zero) e segunda ordem (Hessian).",
                                    "Estude exemplos unidimensionais para intuitar (f'' > 0 min, f'' < 0 max).",
                                    "Anote fórmulas chave em um caderno de referência."
                                  ],
                                  "verification": "Liste corretamente 3 exemplos de pontos críticos e explique por que ∇f = 0 é necessário mas insuficiente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de cálculo multivariável, caderno, calculadora simbólica (ex: Wolfram Alpha).",
                                  "tips": "Visualize o gradiente como vetor direção de maior aumento; zero indica 'plano'.",
                                  "learningObjective": "Dominar o conceito de pontos críticos como pré-requisito para análise local.",
                                  "commonMistakes": "Confundir gradiente zero com mínimo global; ignorar domínio da função."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e Interpretar a Matriz Hessian",
                                  "subSteps": [
                                    "Compute as segundas derivadas parciais: H_ij = ∂²f / ∂x_i ∂x_j.",
                                    "Construa a matriz Hessian H(x) para uma função f dada.",
                                    "Verifique simetria da Hessian (propriedade sempre verdadeira para f C²).",
                                    "Calcule Hessian em um ponto crítico específico usando álgebra.",
                                    "Use software para validar cálculos manuais."
                                  ],
                                  "verification": "Construa corretamente a Hessian para f(x,y) = x² + y² + xy em (0,0) e confirme simetria.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de álgebra simbólica (MATLAB/SymPy), papel quadriculado.",
                                  "tips": "Lembre: Hessian aproxima f por quadrática localmente via Taylor.",
                                  "learningObjective": "Habilitar computação precisa da Hessian em problemas de otimização.",
                                  "commonMistakes": "Erros em derivadas mistas (ordem não importa); esquecer avaliação no ponto crítico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Testes do Hessian para Classificação",
                                  "subSteps": [
                                    "Teste definitude: positiva definida (todos autovalores >0 → min local).",
                                    "Negativa definida (todos <0 → max local); indefinida (mistos → sela).",
                                    "Para 2D: use det(H)>0 e trace(H)>0 para min; det>0 trace<0 para max; det<0 para sela.",
                                    "Calcule autovalores ou use critérios principais para dimensões maiores.",
                                    "Classifique 2-3 pontos críticos de uma função exemplo."
                                  ],
                                  "verification": "Classifique corretamente o ponto (0,0) para f(x,y)=x² - y² como sela.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Calculadora matricial, Python/NumPy para autovalores.",
                                  "tips": "Comece com 2D para prática; software acelera autovalores.",
                                  "learningObjective": "Aplicar testes de segunda ordem para determinar convergência local.",
                                  "commonMistakes": "Ignorar caso det(H)=0 (inconclusivo); confundir trace com determinante."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Condições em Problemas de Engenharia",
                                  "subSteps": [
                                    "Selecione função de otimização civil (ex: minimizar peso de treliça).",
                                    "Encontre ∇f=0 numericamente se analítico difícil.",
                                    "Avalie Hessian e classifique convergência.",
                                    "Compare com gráfico 3D ou contorno para confirmação visual.",
                                    "Documente relatório com classificações e implicações."
                                  ],
                                  "verification": "Produza relatório classificando convergência em exemplo civil com evidências.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/Octave para plot e autovalores, dados de exemplo estrutural.",
                                  "tips": "Integre com métodos numéricos se analítico falhar.",
                                  "learningObjective": "Integrar análise teórica em contextos computacionais reais.",
                                  "commonMistakes": "Não considerar restrições; superestimar precisão numérica."
                                }
                              ],
                              "practicalExample": "Em otimização de seção transversal de viga: f(x,y) = x² + 2xy + 3y² (custo/peso). Ponto crítico (0,0) tem H = [[2,2],[2,6]], det=4>0, trace=8>0 → mínimo local, confirmando convergência para design ótimo.",
                              "finalVerifications": [
                                "Classifica corretamente 5 pontos críticos usando Hessian.",
                                "Explica verbalmente diferenças entre min local, max e sela.",
                                "Computa autovalores de Hessian 2x2 e 3x3 sem erros.",
                                "Identifica inconclusivo quando det(H)=0.",
                                "Aplica em função não-quadrática com precisão.",
                                "Valida com gráfico de nível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de ∇f=0 (100%).",
                                "Correta montagem e avaliação de Hessian (90%+).",
                                "Classificação coerente com testes (todos corretos).",
                                "Uso apropriado de ferramentas computacionais.",
                                "Interpretação contextual em engenharia.",
                                "Relatório claro com justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores e definitude quadrática.",
                                "Cálculo III: derivadas parciais e Taylor multivariável.",
                                "Programação: implementação em Python/MATLAB para otimização.",
                                "Estatística: análise de variância em mínimos quadrados."
                              ],
                              "realWorldApplication": "Em engenharia civil, identifica convergência local em otimização de estruturas (ex: minimizar material em pontes sob carga), evitando designs instáveis em pontos de sela e garantindo mínimos locais viáveis computacionalmente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Algoritmo de Gradiente Descendente",
                        "description": "Implementação iterativa do método de gradiente descendente para minimizar funções contínuas diferenciáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Implementar o algoritmo básico de gradiente descendente",
                            "description": "Codificar em pseudocódigo ou MATLAB o loop iterativo x_{k+1} = x_k - α ∇f(x_k), escolhendo taxa de aprendizado α fixa e critérios de parada como tolerância em norma do gradiente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função objetivo f(x) e seu gradiente ∇f(x)",
                                  "subSteps": [
                                    "Escolha uma função de teste simples, como f(x) = x²/2 para uma variável ou f(x,y) = x² + y² para duas variáveis.",
                                    "Calcule analiticamente o gradiente: para f(x) = x²/2, ∇f(x) = x; para f(x,y), ∇f = [2x, 2y].",
                                    "Escreva as expressões em pseudocódigo ou MATLAB, usando funções anônimas ou definidas.",
                                    "Verifique o gradiente em pontos conhecidos, como x=1, ∇f=1.",
                                    "Documente a função e gradiente com comentários explicativos."
                                  ],
                                  "verification": "Execute o gradiente em pontos conhecidos e confirme valores analíticos (ex: ∇f(1)=1).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou MATLAB",
                                    "Papel e caneta para cálculos analíticos"
                                  ],
                                  "tips": "Comece com funções convexas e separáveis para simplicidade.",
                                  "learningObjective": "Compreender e codificar corretamente a função objetivo e seu gradiente.",
                                  "commonMistakes": [
                                    "Erro no sinal do gradiente",
                                    "Confundir derivada parcial em multivariável",
                                    "Não normalizar variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar parâmetros iniciais do algoritmo",
                                  "subSteps": [
                                    "Defina o ponto inicial x0, como [1; 1] para bivariável.",
                                    "Escolha α fixa (taxa de aprendizado), teste valores como 0.1 ou 0.01.",
                                    "Defina critérios iniciais: tolerância tol=1e-6 na norma do gradiente, iterações máximas max_iter=1000.",
                                    "Crie variáveis para rastrear histórico: iterações, valores de f, normas de gradiente.",
                                    "Implemente uma função para calcular a norma do gradiente ||∇f||."
                                  ],
                                  "verification": "Imprima parâmetros iniciais e confirme que x0 gera gradiente não-zero.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "MATLAB ou pseudocódigo editor"
                                  ],
                                  "tips": "Use α pequena para evitar divergência; teste com diferentes x0.",
                                  "learningObjective": "Selecionar e codificar parâmetros que garantam convergência estável.",
                                  "commonMistakes": [
                                    "α muito grande causando overshooting",
                                    "tol muito rigorosa levando a loops infinitos",
                                    "Esquecer max_iter"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop iterativo principal",
                                  "subSteps": [
                                    "Inicialize x = x0, k=0.",
                                    "Dentro do loop: calcule ∇f(x_k), atualize x_{k+1} = x_k - α * ∇f(x_k).",
                                    "Armazene histórico: x_history(k+1) = x; f_history(k+1) = f(x); grad_norm(k+1) = norm(∇f).",
                                    "Incrementar k e imprimir status a cada 10 iterações.",
                                    "Estruture como um while loop com condição temporária (ex: k < 10)."
                                  ],
                                  "verification": "Execute 10 iterações manualmente e verifique se x diminui corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "MATLAB para testes interativos"
                                  ],
                                  "tips": "Use vetores/colunas consistentes em MATLAB para evitar erros dimensionais.",
                                  "learningObjective": "Codificar a atualização iterativa do gradiente descendente.",
                                  "commonMistakes": [
                                    "Sinal errado na atualização (deve ser subtração)",
                                    "Não atualizar x corretamente",
                                    "Loop infinito sem print de debug"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar critérios de parada e finalizar o algoritmo",
                                  "subSteps": [
                                    "Modifique o loop para while (k < max_iter && norm_grad > tol).",
                                    "Após o loop, verifique motivo de parada: convergência ou max_iter atingida.",
                                    "Retorne x_final, f_final, número de iterações, históricos.",
                                    "Adicione plot: trajetórias de x_history e f_history vs iterações.",
                                    "Teste com o exemplo: confirme convergência para [0,0] em f(x,y)=x²+y²."
                                  ],
                                  "verification": "O algoritmo para com norm_grad < tol e x próximo do mínimo conhecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MATLAB para plotting (plot, semilogy)"
                                  ],
                                  "tips": "Use norm(gradient, 2) para norma euclidiana.",
                                  "learningObjective": "Implementar parada robusta e visualizar convergência.",
                                  "commonMistakes": [
                                    "Condição de parada no lugar errado",
                                    "Norma errada (L1 vs L2)",
                                    "Plot não revela divergência"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar a implementação completa",
                                  "subSteps": [
                                    "Execute com diferentes α e x0, observe convergência.",
                                    "Compare com mínimo analítico (ex: 0 para funções quadráticas).",
                                    "Adicione tratamento de erro: se divergência, avise.",
                                    "Otimize: vetorize cálculos para eficiência.",
                                    "Documente o código completo como função reutilizável."
                                  ],
                                  "verification": "Testes unitários passam: convergência em <100 iterações para casos padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vários scripts MATLAB de teste"
                                  ],
                                  "tips": "Monitore f_history decrescente; se aumentar, reduza α.",
                                  "learningObjective": "Validar e refinar o algoritmo para robustez.",
                                  "commonMistakes": [
                                    "Ignorar divergência",
                                    "Não testar multivariável",
                                    "Código não reutilizável"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente para minimizar f(x,y) = x² + 10*sin(y) + y²/10, com x0=[2; π/2], α=0.1, tol=1e-4. O algoritmo deve convergir para um mínimo local próximo de [0, 0], simulando otimização de custo em projeto de fundação (x=desvio lateral, y=profundidade).",
                              "finalVerifications": [
                                "Norma do gradiente final < tolerância especificada.",
                                "Valor da função diminui monotonicamente no histórico.",
                                "Número de iterações < max_iter para casos de teste.",
                                "Solução final coincide com mínimo analítico em funções quadráticas.",
                                "Plots mostram convergência suave sem oscilações.",
                                "Código executa sem erros em MATLAB ou pseudocódigo.",
                                "Histórico permite reproduzir trajetórias."
                              ],
                              "assessmentCriteria": [
                                "Correção da atualização iterativa (peso 25%).",
                                "Implementação precisa dos critérios de parada (20%).",
                                "Escolha adequada de parâmetros iniciais e testes (20%).",
                                "Visualização e histórico de convergência (15%).",
                                "Robustez a diferentes funções e inicializações (10%).",
                                "Clareza e documentação do código (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e otimização não-linear.",
                                "Programação: Loops, vetores e funções em MATLAB/Python.",
                                "Engenharia Civil: Otimização de estruturas e projetos.",
                                "Machine Learning: Base para redes neurais e regressão.",
                                "Física: Simulação de dinâmicas descendentes."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usado para otimizar dimensões de vigas/pontes minimizando custo/peso sob cargas, ajustando parâmetros via gradiente descendente em modelos finitos, reduzindo tempo de projeto em 30-50%."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Escolher e ajustar a taxa de aprendizado α",
                            "description": "Aplicar busca linear (backtracking) ou testar valores de α para evitar overshooting ou lentidão, demonstrando em funções quadráticas e não-lineares como Rosenbrock.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o impacto da taxa de aprendizado α no Gradiente Descendente",
                                  "subSteps": [
                                    "Definir α como o tamanho do passo na direção oposta ao gradiente.",
                                    "Analisar overshooting: α muito grande causa oscilações e divergência.",
                                    "Analisar lentidão: α muito pequeno resulta em convergência excessivamente lenta.",
                                    "Visualizar em função 1D f(x) = x², plotando trajetórias para α=1.0, 0.1 e 0.01.",
                                    "Comparar número de iterações e erro final para diferentes α."
                                  ],
                                  "verification": "Gerar e interpretar gráficos de convergência mostrando overshooting e lentidão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Jupyter Notebook",
                                    "Função f(x)=x²"
                                  ],
                                  "tips": "Use animações de gradiente descendente para visualização intuitiva.",
                                  "learningObjective": "Identificar qualitativamente os efeitos de valores inadequados de α.",
                                  "commonMistakes": [
                                    "Ignorar escala da função, levando a α inadequado",
                                    "Confundir α com norma do gradiente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Testar valores de α manualmente em função quadrática multivariada",
                                  "subSteps": [
                                    "Implementar gradiente descendente para f(x,y) = x² + 2y².",
                                    "Testar α fixos: 0.01 (lento), 0.1 (ideal), 1.0 (overshooting).",
                                    "Medir métricas: iterações até ||grad|| < 0.01, valor final da função.",
                                    "Plotar curvas de convergência e trajetórias no plano (x,y).",
                                    "Documentar tabela comparativa de desempenho."
                                  ],
                                  "verification": "Tabela e gráficos mostrando convergência ótima para α=0.1 em <50 iterações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python/NumPy/SciPy",
                                    "Matplotlib para plots 2D",
                                    "Código base de GD"
                                  ],
                                  "tips": "Normalize variáveis se escalas diferirem para α mais estável.",
                                  "learningObjective": "Selecionar α por experimentação manual em funções quadráticas.",
                                  "commonMistakes": [
                                    "Não inicializar em ponto longe do mínimo",
                                    "Parar iterações prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar busca linear com backtracking para ajuste automático de α",
                                  "subSteps": [
                                    "Explicar algoritmo: iniciar com α=1.0, reduzir por β=0.5 até Armijo condition: f(x - α∇f) ≤ f(x) - cα||∇f||² (c=0.0001).",
                                    "Codificar função line_search_backtracking(x, grad, f).",
                                    "Integrar ao GD e testar em f(x,y)=x² + 2y².",
                                    "Comparar com α fixo: medir iterações e robustez a inicializações.",
                                    "Analisar logs de reduções de α por iteração."
                                  ],
                                  "verification": "Código converge independentemente de inicialização, com logs mostrando backtracking.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python/NumPy",
                                    "Código GD anterior",
                                    "Documentação Armijo"
                                  ],
                                  "tips": "Escolha β=0.5 e c=1e-4 para equilíbrio entre velocidade e precisão.",
                                  "learningObjective": "Aplicar backtracking para α adaptativo e robusto.",
                                  "commonMistakes": [
                                    "c muito pequeno causando muitas reduções",
                                    "Esquecer verificação de gradiente zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e avaliar em função não-linear Rosenbrock",
                                  "subSteps": [
                                    "Definir Rosenbrock: f(x,y)=(1-x)² + 100(y-x²)², mínimo em (1,1).",
                                    "Implementar GD com α fixo e backtracking, de [-2,-2].",
                                    "Comparar: iterações, trajetórias, sensibilidade a α inicial.",
                                    "Otimizar hiperparâmetros β e c para Rosenbrock.",
                                    "Avaliar em 3 sementes aleatórias para robustez."
                                  ],
                                  "verification": "Backtracking converge em <200 iterações; α fixo falha ou é lento.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python/NumPy/Matplotlib",
                                    "Função Rosenbrock",
                                    "Sementes randômicas"
                                  ],
                                  "tips": "Use log-scale para plots de erro devido a planaltos na Rosenbrock.",
                                  "learningObjective": "Demonstrar superioridade de métodos adaptativos em não-lineares.",
                                  "commonMistakes": [
                                    "Não plotar em escala log para trajetórias longas",
                                    "Ignorar planaltos locais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em otimização de seção transversal de viga (f(A,B)=custo quadrático em área A e inércia B), use backtracking para α, convergindo rápido de inicializações ruins sem overshooting em restrições não-lineares.",
                              "finalVerifications": [
                                "GD com backtracking converge Rosenbrock em <200 iterações de múltiplas inicializações.",
                                "Identificar e corrigir overshooting em α=1.0 via gráficos.",
                                "Tabela comparativa mostra backtracking usa 20-50% menos iterações que α fixo.",
                                "Código modular com line_search reutilizável.",
                                "Explicar Armijo condition em palavras próprias.",
                                "Aplicar a função quadrática customizada com sucesso."
                              ],
                              "assessmentCriteria": [
                                "Robustez: Convergência consistente em 80% das execuções aleatórias.",
                                "Eficiência: <300 iterações totais para Rosenbrock.",
                                "Precisão: Erro final <1e-4 no mínimo conhecido.",
                                "Código limpo: Funções modulares, comentários e visualizações.",
                                "Análise: Relatório com gráficos, tabelas e insights sobre α.",
                                "Compreensão: Explicação correta de backtracking vs. fixo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Condições de Wolfe/Armijo em otimização não-convexa.",
                                "Programação: Implementação numérica estável e debugging de loops.",
                                "Engenharia Civil: Otimização em dimensionamento estrutural e análise finita.",
                                "Física: Modelagem de minimização de energia potencial.",
                                "Estatística: Análise de sensibilidade e hiperparâmetros."
                              ],
                              "realWorldApplication": "Em softwares de engenharia civil como SAP2000 ou ANSYS, ajustar α em solvers de gradiente para otimizar projetos de pontes/pavilhões, reduzindo tempo de simulação de horas para minutos e evitando divergências em modelos reais com não-linearidades."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Analisar convergência do gradiente descendente",
                            "description": "Estudar taxas de convergência linear para funções convexas e quadráticas, relacionando com condicionamento da Hessiana e impacto em problemas de engenharia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Convergência no Gradiente Descendente",
                                  "subSteps": [
                                    "Estude a definição de convergência em métodos iterativos, focando em critérios como ||x_{k+1} - x*|| <= rho ||x_k - x*|| com rho < 1.",
                                    "Revise o algoritmo de GD: x_{k+1} = x_k - alpha ∇f(x_k).",
                                    "Analise condições para convergência global em funções convexas diferenciáveis.",
                                    "Derive a taxa de convergência linear: f(x_k) - f* <= C (1 - mu/L)^k, onde mu é forte convexidade e L é Lipschitz.",
                                    "Implemente um exemplo simples em Python para visualizar iterações."
                                  ],
                                  "verification": "Implemente GD em uma função convexa simples e confirme que o erro diminui monotonicamente em log-plot.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Numerical Optimization' de Nocedal & Wright (Cap. 2)",
                                    "Jupyter Notebook",
                                    "Biblioteca NumPy e Matplotlib"
                                  ],
                                  "tips": "Use step sizes fixos pequenos inicialmente para garantir estabilidade.",
                                  "learningObjective": "Compreender os critérios matemáticos básicos de convergência linear no GD.",
                                  "commonMistakes": [
                                    "Confundir convergência linear com quadrática",
                                    "Ignorar a necessidade de Lipschitz contínuo do gradiente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Convergência em Funções Quadráticas",
                                  "subSteps": [
                                    "Considere f(x) = (1/2) x^T A x - b^T x, onde A é Hessiana positiva definida.",
                                    "Derive a iteração exata: x_{k+1} = (I - alpha A) x_k + alpha b.",
                                    "Calcule o fator de convergência rho = max |1 - alpha lambda_i|, minimizado em alpha = 2/(lambda_min + lambda_max).",
                                    "Simule numericamente para matrizes A com diferentes cond(A).",
                                    "Plote curvas de convergência para cond(A) = 10, 100, 1000."
                                  ],
                                  "verification": "Gere plots mostrando que rho aumenta com cond(A), confirmando lentidão em matrizes mal condicionadas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Artigo 'Gradient Descent Convergence' (Boyd)",
                                    "Python com SciPy para autovalores",
                                    "Exemplos de matrizes Toeplitz"
                                  ],
                                  "tips": "Escolha autovalores extremos para ilustrar o gargalo de convergência.",
                                  "learningObjective": "Dominar a análise exata de convergência para quadráticas via autovalores da Hessiana.",
                                  "commonMistakes": [
                                    "Esquecer normalização para rho < 1",
                                    "Usar alpha ótimo sem derivar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Impacto do Condicionamento da Hessiana",
                                  "subSteps": [
                                    "Defina cond(A) = lambda_max / lambda_min e relacione com rho ≈ 1 - 2 / cond(A).",
                                    "Prove que número de iterações ~ (cond(A)/2) log(1/eps) para erro eps.",
                                    "Compare GD com métodos preconditionados como conjugate gradient.",
                                    "Analise numericamente em problemas de minimos quadrados: min ||Ax - b||^2.",
                                    "Discuta trade-offs computacionais em alto condicionamento."
                                  ],
                                  "verification": "Calcule analiticamente e numericamente iterações necessárias para cond(A)=1000 vs 10, com discrepância <5%.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Notas de curso de Otimização Numérica",
                                    "MATLAB ou Python para SVD",
                                    "Problemas de teste de NIST"
                                  ],
                                  "tips": "Use matrizes de Galerkin para simular Hessianas reais de PDEs em eng. civil.",
                                  "learningObjective": "Relacionar condicionamento da Hessiana diretamente com taxa de convergência prática.",
                                  "commonMistakes": [
                                    "Confundir cond(Hessiana) com cond(jacobiana)",
                                    "Ignorar autovalores próximos de zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Análise em Problemas de Engenharia e Funções Convexas Gerais",
                                  "subSteps": [
                                    "Estenda resultados quadráticos para convexas fortes via majoração quadrática.",
                                    "Discuta impacto em problemas de eng. civil: otimização de estruturas sob cargas.",
                                    "Simule GD em função convexa não-quadrática, como Huber loss em regressão robusta.",
                                    "Avalie sensibilidade a ruído e não-exatidão do gradiente.",
                                    "Proponha melhorias: GD com momentum ou adaptive steps."
                                  ],
                                  "verification": "Resolva um problema de otimização estrutural simples e relate taxa observada vs teórica.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software FEniCS para simulações estruturais",
                                    "Exemplo: viga em flexão minimizando peso",
                                    "Paper 'Optimization in Civil Eng'"
                                  ],
                                  "tips": "Comece com problemas 2D para visualização rápida.",
                                  "learningObjective": "Integrar teoria de convergência com aplicações reais em engenharia civil.",
                                  "commonMistakes": [
                                    "Superestimar convergência em não-convexas",
                                    "Não considerar custo por iteração"
                                  ]
                                }
                              ],
                              "practicalExample": "Em projeto de uma ponte, minimize o peso da estrutura sujeito a restrições de tensão usando GD sobre a função objetivo quadrática aproximada pela Hessiana do modelo finito de elementos. Analise como cond(H) alto devido a elementos alongados causa lentidão, resolvida por preconditioning.",
                              "finalVerifications": [
                                "Derivar rho ótimo para quadrática e plotar vs cond(A).",
                                "Explicar verbalmente por que GD é lento em problemas mal condicionados.",
                                "Implementar GD em código e medir iterações para eps=1e-6 em 3 casos.",
                                "Relacionar teoria com exemplo de eng. civil.",
                                "Propor 2 estratégias para acelerar convergência.",
                                "Calcular bound teórico de erro para função convexa genérica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de taxas de convergência (90%+ correto).",
                                "Qualidade de simulações numéricas e plots interpretativos.",
                                "Correta interpretação do papel do condicionamento da Hessiana.",
                                "Relevância das conexões com aplicações em engenharia civil.",
                                "Profundidade nos sub-steps e avoidance de erros comuns.",
                                "Clareza na verificação final e critérios de parada."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Autovalores e decomposição espectral da Hessiana.",
                                "Análise Numérica: Estabilidade e erro em métodos iterativos.",
                                "Programação Computacional: Implementação eficiente em Python/NumPy.",
                                "Engenharia Computacional: Modelagem FEM e otimização estrutural.",
                                "Estatística: Regressão e minimos quadrados em análise de dados experimentais."
                              ],
                              "realWorldApplication": "Na engenharia civil, analisar convergência do GD é crucial para otimizar designs de edifícios altos ou barragens, onde Hessianas mal condicionadas de modelos FEM demandam aceleração para simulações viáveis em tempo real durante iterações de projeto."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Variantes Avançadas dos Métodos de Gradiente",
                        "description": "Melhorias nos métodos de gradiente para acelerar convergência e lidar com problemas reais em otimização.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Implementar gradiente descendente com momento",
                            "description": "Incorporar velocidade v_{k+1} = β v_k - α ∇f(x_k) para suavizar oscilações, configurando hiperparâmetro β e aplicando em minimização de energia em estruturas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Teórico do Gradiente Descendente com Momento",
                                  "subSteps": [
                                    "Revise o gradiente descendente padrão: x_{k+1} = x_k - α ∇f(x_k).",
                                    "Introduza a velocidade de momento: v_{k+1} = β v_k - α ∇f(x_k).",
                                    "Explique como o termo β v_k adiciona 'inércia' para suavizar oscilações em vales estreitos.",
                                    "Discuta o papel dos hiperparâmetros α (taxa de aprendizado) e β (fator de momento, tipicamente 0.9).",
                                    "Compare com GD vanilla através de gráficos conceituais."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando a fórmula e seus benefícios.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de otimização",
                                    "Artigo sobre SGD with Momentum (Goodfellow et al.)",
                                    "Ferramenta de desenho como Draw.io para diagramas"
                                  ],
                                  "tips": "Pense no momento como uma bola rolando em um vale: o momentum a impede de oscilar excessivamente.",
                                  "learningObjective": "Entender matematicamente como o momento acelera a convergência e reduz oscilações.",
                                  "commonMistakes": [
                                    "Confundir o sinal da atualização de v (deve ser -α ∇f)",
                                    "Escolher β muito alto (>0.99), causando overshooting",
                                    "Ignorar inicialização de v_0 = 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Hiperparâmetros e Inicializar Variáveis",
                                  "subSteps": [
                                    "Defina a função objetivo f(x), seu gradiente ∇f(x) e domínio (ex: minimização de energia E(x) = 1/2 x^T H x - b^T x).",
                                    "Escolha α inicial (ex: 0.01) via line search ou heurística.",
                                    "Selecione β = 0.9 como padrão para momentum.",
                                    "Inicialize x_0, v_0 = 0 e critérios de parada (ex: ||∇f|| < 1e-6 ou k_max=1000).",
                                    "Teste sensibilidade com valores variados de α e β."
                                  ],
                                  "verification": "Crie uma tabela com 3 conjuntos de hiperparâmetros e preveja comportamentos esperados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou Jupyter Notebook para testes preliminares",
                                    "Documentação NumPy/SciPy"
                                  ],
                                  "tips": "Use β próximo de 1 para momentum forte, mas ajuste α para baixo conforme.",
                                  "learningObjective": "Dominar a escolha e impacto de hiperparâmetros no desempenho do algoritmo.",
                                  "commonMistakes": [
                                    "Não normalizar ∇f, levando a α inadequada",
                                    "Ignorar escala da função (use gradiente normalizado)",
                                    "Definir v_0 ≠ 0 sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Algoritmo em Código Python",
                                  "subSteps": [
                                    "Escreva função para ∇f(x) específica ao problema.",
                                    "Implemente loop principal: atualize v, x = x + v (note: v inclui o sinal negativo).",
                                    "Adicione logging de ||∇f||, x_k e custo f(x_k) por iteração.",
                                    "Inclua visualização: plote trajetórias x_k e f(x_k) vs iterações.",
                                    "Compare com GD vanilla no mesmo problema."
                                  ],
                                  "verification": "Execute o código e confirme que v acumula corretamente sem NaNs.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python 3 com NumPy, Matplotlib",
                                    "Jupyter Notebook",
                                    "Editor como VS Code"
                                  ],
                                  "tips": "Use vetores NumPy para eficiência; evite loops Python puros.",
                                  "learningObjective": "Codificar o algoritmo de forma robusta e debugável.",
                                  "commonMistakes": [
                                    "Erro no update: x += v em vez de x = x + v",
                                    "Não resetar v_0 por run",
                                    "Plot errados: confunda GD vs momentum"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar à Minimização de Energia em Estruturas Civis",
                                  "subSteps": [
                                    "Modele energia potencial de uma estrutura simples (ex: truss 2D com E(x) quadrática).",
                                    "Defina ∇E(x) analiticamente ou via autograd (SymPy/NumPy).",
                                    "Execute algoritmo para otimizar posições nodais minimizando E.",
                                    "Analise convergência: iterações até precisão vs GD vanilla.",
                                    "Valide solução contra analítica ou FEM software."
                                  ],
                                  "verification": "Obtenha redução de E > 90% em <200 iterações, com oscilações < GD.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código do Step 3",
                                    "Exemplo de truss: matriz rigidez H e vetor carga b",
                                    "Software FEM como FEniCS (opcional)"
                                  ],
                                  "tips": "Comece com problema quadrático convexo para validação fácil.",
                                  "learningObjective": "Aplicar o método a contexto de engenharia civil realista.",
                                  "commonMistakes": [
                                    "Modelo físico incorreto (ex: H não positiva definida)",
                                    "Parâmetros não escalados para unidades de energia",
                                    "Ignorar restrições de projeto"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar, Otimizar e Documentar",
                                  "subSteps": [
                                    "Compare métricas: iterações, tempo CPU, precisão final.",
                                    "Ajuste hiperparâmetros para melhor performance.",
                                    "Teste sensibilidade a ruído em ∇f (simule dados reais).",
                                    "Documente código com comentários e relatório de resultados.",
                                    "Proponha extensões (ex: Nesterov momentum)."
                                  ],
                                  "verification": "Gere relatório PDF com plots e tabelas comprovando superioridade do momentum.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código anterior",
                                    "LaTeX ou Markdown para relatório",
                                    "Git para versionamento"
                                  ],
                                  "tips": "Use profiling (timeit) para medir eficiência.",
                                  "learningObjective": "Avaliar criticamente e refinar implementações de otimização.",
                                  "commonMistakes": [
                                    "Overfitting hiperparâmetros a um caso",
                                    "Não reportar variância sobre múltiplas runs",
                                    "Esquecer baseline GD"
                                  ]
                                },
                                {
                                  "practicalExample": "Implemente GD com momentum para minimizar E(x) = 0.5*[3,2;2,6]*x^2 - [1;2]*x, representando energia de um truss 2D simples. Inicial: x0=[0,0], α=0.1, β=0.9. Espere convergência em ~20 iterações vs 50+ para GD vanilla, com trajetória mais suave."
                                },
                                {
                                  "finalVerifications": [
                                    "O algoritmo converge 2-5x mais rápido que GD vanilla em funções com vales estreitos.",
                                    "Trajetória x_k mostra momentum 'empurrando' através de platôs.",
                                    "Solução final satisfaz ||∇f(x*)|| < 1e-6.",
                                    "Hiperparâmetros β≈0.9 e α ajustada levam a oscilações mínimas.",
                                    "Código roda sem erros para dim(x)>10."
                                  ],
                                  "assessmentCriteria": [
                                    "Correção matemática da atualização v e x (20%).",
                                    "Eficiência computacional e clareza de código (20%).",
                                    "Análise comparativa com GD vanilla (20%).",
                                    "Aplicação válida ao modelo de energia estrutural (20%).",
                                    "Relatório com visualizações e insights (20%)."
                                  ],
                                  "crossCurricularConnections": [
                                    "Programação Numérica (implementação vetorizada NumPy).",
                                    "Física Computacional (dinâmica de partículas análoga ao momentum).",
                                    "Machine Learning (otimizadores como Adam/SGD).",
                                    "Engenharia de Software (testes unitários e logging).",
                                    "Análise Numérica (condicionamento de H e estabilidade)."
                                  ],
                                  "realWorldApplication": "Em engenharia civil, otimiza configurações de treliças e vigas para minimizar energia potencial e consumo de material em pontes e edifícios, acelerando simulações FEM e designs sustentáveis."
                                }
                              ]
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Aplicar gradiente descendente estocástico (SGD)",
                            "description": "Usar subamostras de gradientes em dados grandes, como em ajuste de curvas ou redes neurais para previsão de cargas em engenharia civil, analisando variância e convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Gradiente Descendente Estocástico (SGD)",
                                  "subSteps": [
                                    "Revisar o Gradiente Descendente (GD) clássico e sua limitação em datasets grandes.",
                                    "Explicar o conceito de subamostragem aleatória de dados para calcular gradientes.",
                                    "Derivar a fórmula matemática do SGD: θ = θ - η * ∇J(θ; x^(i), y^(i)), onde i é aleatório.",
                                    "Discutir variância nos gradientes estocásticos e impacto na convergência.",
                                    "Comparar com mini-batch SGD para balancear ruído e eficiência."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando SGD vs GD, incluindo equações, e validar com um colega ou autoavaliação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de otimização (ex: Boyd & Vandenberghe)",
                                    "Jupyter Notebook",
                                    "NumPy e Matplotlib"
                                  ],
                                  "tips": "Use diagramas para visualizar o 'zigzag' da trajetória SGD vs linha reta do GD.",
                                  "learningObjective": "Dominar os princípios teóricos do SGD e suas vantagens em dados volumosos de engenharia civil.",
                                  "commonMistakes": [
                                    "Ignorar a aleatoriedade na escolha de amostras",
                                    "Confundir learning rate com tamanho de batch",
                                    "Subestimar a variância como 'erro' em vez de feature"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente e Implementar SGD Básico",
                                  "subSteps": [
                                    "Instalar bibliotecas: NumPy, Pandas, Scikit-learn e Matplotlib.",
                                    "Gerar ou carregar um dataset sintético de regressão (ex: cargas vs tempo em estruturas).",
                                    "Implementar função de perda (MSE) e gradiente analítico para regressão linear.",
                                    "Codificar o loop de SGD com amostragem aleatória e learning rate adaptável.",
                                    "Plotar curvas de perda e parâmetros ao longo das iterações."
                                  ],
                                  "verification": "Executar o código e confirmar que a perda converge para <0.01 em 1000 epochs.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python 3.x",
                                    "Jupyter Notebook",
                                    "Dataset sintético CSV"
                                  ],
                                  "tips": "Use np.random.choice() para amostragem eficiente; fixe seed para reprodutibilidade.",
                                  "learningObjective": "Implementar SGD do zero em Python para um problema de otimização simples.",
                                  "commonMistakes": [
                                    "Learning rate fixo muito alto causando divergência",
                                    "Não normalizar dados levando a gradientes explosivos",
                                    "Esquecer de embaralhar dados entre epochs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar SGD em Problema de Previsão de Cargas em Engenharia Civil",
                                  "subSteps": [
                                    "Carregar dataset real ou simulado de cargas em vigas/pontes (ex: sensores IoT).",
                                    "Preparar dados: split train/test, normalização, feature engineering (ex: tempo, material).",
                                    "Treinar modelo de rede neural simples com SGD para previsão de cargas.",
                                    "Ajustar hiperparâmetros: learning rate, momentum, batch size.",
                                    "Avaliar com métricas: MSE, MAE em conjunto de teste."
                                  ],
                                  "verification": "Obter MSE < 5% do valor médio das cargas no teste; plotar previsões vs reais.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Dataset de cargas (ex: UCI ou simulado)",
                                    "TensorFlow/Keras ou PyTorch",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Comece com mini-batches (32-128) para reduzir variância; use scheduler para decay de LR.",
                                  "learningObjective": "Aplicar SGD em contexto prático de engenharia civil para previsão.",
                                  "commonMistakes": [
                                    "Overfitting sem validação cruzada",
                                    "Batch size inadequado para dataset desbalanceado",
                                    "Ignorar escalas diferentes nas features"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Variância, Convergência e Otimizar",
                                  "subSteps": [
                                    "Executar múltiplas runs com seeds diferentes e calcular variância dos gradientes.",
                                    "Plotar trajetórias de convergência e analisar taxa de convergência (1/T).",
                                    "Implementar variantes: SGD com momentum ou Nesterov.",
                                    "Comparar performance com GD batch completo.",
                                    "Documentar trade-offs: velocidade vs precisão."
                                  ],
                                  "verification": "Relatório com gráficos mostrando convergência estável e variância <10% entre runs.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código anterior",
                                    "Seaborn para plots avançados",
                                    "Relatório Markdown"
                                  ],
                                  "tips": "Monitore gradiente norm para early stopping; use logging para múltiplas métricas.",
                                  "learningObjective": "Analisar e otimizar SGD para robustez em aplicações reais.",
                                  "commonMistakes": [
                                    "Atribuir variância apenas a ruído sem analisar amostragem",
                                    "Não comparar com baselines",
                                    "Parar cedo sem verificar platô de convergência"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de monitoramento de pontes, use SGD para treinar uma rede neural em 1 milhão de medições de sensores de carga (peso de veículos vs deformação). Subamostre 1% dos dados por iteração para prever cargas futuras, reduzindo tempo de treinamento de horas para minutos, com análise de variância para validar estabilidade.",
                              "finalVerifications": [
                                "Loss converge monotonicamente em <500 epochs com variância <5%.",
                                "Previsões no teste têm erro médio <3% das cargas reais.",
                                "Tempo de treinamento <10% do GD batch em dataset >10k amostras.",
                                "Gradientes normais estabilizam sem explosão/divergência.",
                                "Múltiplas runs (5+) mostram consistência em parâmetros finais.",
                                "Comparação com baseline (GD) demonstra speedup >5x."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo (MSE/MAE abaixo de threshold).",
                                "Eficiência computacional (tempo/iteração).",
                                "Análise qualitativa de variância e convergência via plots.",
                                "Correção da implementação (gradientes exatos).",
                                "Relatório completo com interpretações.",
                                "Adaptabilidade a hiperparâmetros."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e distribuições de gradientes.",
                                "Programação: Otimização numérica em Python/ML frameworks.",
                                "Engenharia de Software: Debugging de loops de treinamento.",
                                "Física/Mecânica: Modelagem de cargas dinâmicas em estruturas.",
                                "Machine Learning: Extensão a redes neurais profundas."
                              ],
                              "realWorldApplication": "Previsão de cargas em estruturas civis como pontes e edifícios usando dados de sensores IoT, permitindo manutenção preditiva, otimização de design e redução de custos em projetos de infraestrutura urbana sustentável."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Aplicações em Engenharia Civil",
                    "description": "Uso de otimização em projetos estruturais, alocação de recursos e planejamento.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Otimização em Projetos Estruturais",
                        "description": "Aplicação de técnicas de otimização para minimizar custos, peso ou maximizar rigidez em estruturas civis como vigas, colunas e lajes.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Formular problemas de otimização em dimensionamento de vigas",
                            "description": "Definir variáveis de decisão (seções transversais, materiais), função objetivo (minimizar volume ou custo) e restrições (resistência, deformação) para vigas sob carregamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o problema estrutural da viga",
                                  "subSteps": [
                                    "Identificar o tipo de viga e condições de apoio (simplesmente apoiada, contínua, engastada)",
                                    "Determinar os carregamentos atuantes (cargas pontuais, distribuídas, momentos fletores)",
                                    "Listar propriedades dos materiais disponíveis (módulo de elasticidade E, tensão admissível σ_adm)",
                                    "Definir critérios de projeto iniciais (deformação máxima δ_max, frequência de vibração mínima)",
                                    "Desenhar o esquema gráfico da viga com dimensões e forças"
                                  ],
                                  "verification": "Esquema da viga desenhado corretamente com todos os carregamentos e apoios anotados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel milimetrado ou software de desenho (AutoCAD Sketch)",
                                    "Tabelas de propriedades de aço e concreto (NBR 6118)",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Sempre inicie com um diagrama de corpo livre para visualizar forças internas.",
                                  "learningObjective": "Compreender as condições de contorno e carregamento do problema estrutural.",
                                  "commonMistakes": [
                                    "Ignorar carregamentos combinados",
                                    "Esquecer efeitos de auto-peso da viga",
                                    "Não considerar normas técnicas aplicáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir variáveis de decisão",
                                  "subSteps": [
                                    "Identificar dimensões da seção transversal (ex: largura b, altura h para seção retangular)",
                                    "Incluir variáveis como espessura de armadura ou tipo de material se aplicável",
                                    "Estabelecer limites inferiores e superiores realistas (ex: 0.1m ≤ b ≤ 0.5m, 0.2m ≤ h ≤ 1.0m)",
                                    "Expressar variáveis em notação matemática (x1 = b, x2 = h)",
                                    "Verificar independência e relevância das variáveis"
                                  ],
                                  "verification": "Lista de variáveis com domínios definidos e justificativa de escolha.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de cálculo (Excel ou papel)",
                                    "Normas de fabricação de perfis metálicos (AISC ou NBR)",
                                    "Livro de estruturas metálicas"
                                  ],
                                  "tips": "Escolha variáveis contínuas para otimização suave; discretize se necessário para fabricação.",
                                  "learningObjective": "Selecionar variáveis que influenciem diretamente o dimensionamento.",
                                  "commonMistakes": [
                                    "Definir variáveis dependentes",
                                    "Ignorar limites práticos de fabricação",
                                    "Incluir variáveis irrelevantes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a função objetivo",
                                  "subSteps": [
                                    "Escolher o critério de otimização (minimizar volume V = b * h * L ou custo C = ρ * V)",
                                    "Expressar a função em termos das variáveis de decisão (f(x) = x1 * x2 * L)",
                                    "Verificar se é função de minimização ou maximização",
                                    "Simplificar expressões matemáticas quando possível",
                                    "Calcular valor inicial para referência"
                                  ],
                                  "verification": "Função objetivo escrita corretamente e calculada para valores iniciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (MATLAB Symbolic)",
                                    "Tabelas de densidade de materiais (aço: 7850 kg/m³)"
                                  ],
                                  "tips": "Priorize minimização de custo sobre volume se dados de preços estiverem disponíveis.",
                                  "learningObjective": "Construir uma função objetivo alinhada aos objetivos de projeto econômico.",
                                  "commonMistakes": [
                                    "Confundir minimização com maximização",
                                    "Omitir constantes como comprimento L",
                                    "Usar variáveis erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e formular restrições",
                                  "subSteps": [
                                    "Calcular momentos fletores e cortantes máximos (M_max, V_max)",
                                    "Formular restrições de resistência (σ = M*y/I ≤ σ_adm)",
                                    "Incluir restrições de deformação (δ = PL³/48EI ≤ δ_max)",
                                    "Adicionar restrições geométricas e de fabricação (h/b ≥ 2)",
                                    "Classificar restrições como igualdades ou desigualdades"
                                  ],
                                  "verification": "Todas as restrições expressas matematicamente com limites numéricos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Fórmulas de mecânica dos materiais (Timoshenko)",
                                    "Software de cálculo estrutural (SAP2000 trial)",
                                    "Normas ABNT NBR 8800"
                                  ],
                                  "tips": "Use fatores de segurança nas restrições para conformidade com normas.",
                                  "learningObjective": "Incorporar todas as condições de viabilidade física e normativa.",
                                  "commonMistakes": [
                                    "Esquecer restrição de cisalhamento",
                                    "Usar fórmulas erradas para deformação",
                                    "Definir restrições muito frouxas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Escrever a formulação completa do problema",
                                  "subSteps": [
                                    "Reunir variáveis, função objetivo e restrições em formato padrão",
                                    "Escrever o problema como: min f(x) s.a. g_i(x) ≤ 0, h_j(x) = 0",
                                    "Verificar consistência dimensional e unidades",
                                    "Testar com valores iniciais se todas restrições são satisfeitas",
                                    "Documentar suposições e referências"
                                  ],
                                  "verification": "Formulação completa pronta para implementação em solver de otimização.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto (LaTeX ou Word)",
                                    "Template de programação matemática"
                                  ],
                                  "tips": "Use notação padrão de otimização para facilitar codificação posterior.",
                                  "learningObjective": "Sintetizar o problema em uma estrutura pronta para resolução numérica.",
                                  "commonMistakes": [
                                    "Inconsistência de unidades (kN vs N)",
                                    "Omitir alguma restrição identificada",
                                    "Erros de transcrição"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga simplesmente apoiada de L=4m com carga uniforme q=20 kN/m em concreto (E=25 GPa, σ_adm=15 MPa), defina x1=b (largura), x2=h (altura). Minimize V=x1*x2*4 sujeito a M_max*x2/(2*x1*x2³/12) ≤15e6 Pa e δ_max= L/360=11.1mm, com 0.2≤x1≤0.6m, 0.3≤x2≤1.0m.",
                              "finalVerifications": [
                                "Variáveis de decisão definidas com domínios realistas.",
                                "Função objetivo minimiza volume ou custo corretamente.",
                                "Restrições de resistência, deformação e geometria incluídas.",
                                "Formulação compatível com solvers como fmincon (MATLAB).",
                                "Teste inicial: ponto factível encontrado.",
                                "Documentação clara com unidades e suposições."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática das expressões (fórmulas de flexão e deformação).",
                                "Clareza e precisão na definição de termos e variáveis.",
                                "Completude: todas restrições relevantes presentes.",
                                "Realismo: limites alinhados a normas e práticas de engenharia.",
                                "Estrutura padronizada para otimização.",
                                "Viabilidade: existência de solução inicial factível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Programação não-linear e cálculo variacional.",
                                "Física: Mecânica dos sólidos e teoria da elasticidade.",
                                "Computação: Implementação em Python (SciPy.optimize) ou MATLAB.",
                                "Economia: Análise custo-benefício em materiais.",
                                "Gestão de Projetos: Otimização sob restrições orçamentárias."
                              ],
                              "realWorldApplication": "Em projetos de lajes e vigas de edifícios residenciais ou pontes, permitindo redução de até 20% no consumo de aço ou concreto, otimizando custos e sustentabilidade em obras civis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Aplicar programação linear em otimização estrutural",
                            "description": "Resolver problemas lineares de otimização de treliças usando solvers como Simplex ou interior-point, interpretando resultados em termos de forças e deslocamentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar a treliça e definir o problema de otimização",
                                  "subSteps": [
                                    "Identifique a geometria da treliça: nós, barras e condições de apoio.",
                                    "Defina as cargas aplicadas e os materiais (módulo de elasticidade E).",
                                    "Estabeleça variáveis de decisão: áreas de seção transversal (A_i) para cada barra.",
                                    "Defina o objetivo: minimizar o peso total (soma de A_i * comprimento * densidade).",
                                    "Liste restrições iniciais: equilíbrio de forças nos nós e limites de tensão."
                                  ],
                                  "verification": "Desenhe o diagrama da treliça com variáveis anotadas e liste objetivo/restruições em um documento.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Papel e lápis ou software de desenho (ex: SketchUp, AutoCAD)",
                                    "Referências de mecânica estrutural"
                                  ],
                                  "tips": "Comece com uma treliça simples (2-4 barras) para praticar.",
                                  "learningObjective": "Compreender a representação física do problema como base para otimização.",
                                  "commonMistakes": [
                                    "Ignorar condições de apoio levando a graus de liberdade extras.",
                                    "Esquecer unidades consistentes (ex: kN vs N)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o modelo matemático de programação linear",
                                  "subSteps": [
                                    "Escreva a função objetivo linear: min ∑ (ρ * L_i * A_i), onde ρ é densidade, L_i comprimento.",
                                    "Derive restrições de equilíbrio: ∑ F_x = 0 e ∑ F_y = 0 em cada nó, expressas em termos de A_i.",
                                    "Inclua restrições de deslocamentos: usando rigidez das barras (k_i = E*A_i/L_i).",
                                    "Adicione bounds: A_i ≥ A_min > 0 e limites de tensão σ_max.",
                                    "Verifique linearidade: todas restrições e objetivo devem ser lineares em A_i."
                                  ],
                                  "verification": "Escreva o modelo LP completo em forma padrão (min c^T x s.t. Ax ≤ b, x ≥ 0).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Planilha Excel ou LaTeX para equações",
                                    "Livro de otimização (ex: 'Linear Programming' de Vanderbei)"
                                  ],
                                  "tips": "Use matrizes de rigidez elementar para sistematizar restrições.",
                                  "learningObjective": "Traduzir o problema físico em um modelo LP padrão.",
                                  "commonMistakes": [
                                    "Não linearizar corretamente deslocamentos (usar aproximações pequenas).",
                                    "Omitir restrições de não-negatividade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o modelo em um solver computacional",
                                  "subSteps": [
                                    "Instale um solver: PuLP ou linprog no Python, ou MATLAB Optimization Toolbox.",
                                    "Defina variáveis: LpVariable para cada A_i com bounds.",
                                    "Codifique a função objetivo e adicione restrições via matrizes ou loops.",
                                    "Configure o solver: método Simplex ou interior-point.",
                                    "Execute o código e capture status de solução."
                                  ],
                                  "verification": "Execute o código e obtenha status 'Optimal' sem erros.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Python com bibliotecas PuLP, NumPy",
                                    "Jupyter Notebook",
                                    "Exemplo de código de treliça"
                                  ],
                                  "tips": "Teste com dados sintéticos simples antes do problema real.",
                                  "learningObjective": "Implementar LP programaticamente para problemas estruturais.",
                                  "commonMistakes": [
                                    "Erros de indexação em matrizes de equilíbrio.",
                                    "Escala numérica ruim causando falha no solver."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o problema e interpretar resultados",
                                  "subSteps": [
                                    "Extraia valores ótimos: A_i*, forças internas N_i = k_i * δ_i.",
                                    "Calcule deslocamentos: resolva sistema K u = F com K baseado em A_i*.",
                                    "Verifique violações: tensões σ_i = N_i / A_i* ≤ σ_max.",
                                    "Analise dual: sombras de restrições para sensibilidade.",
                                    "Visualize: plote treliça deformada e diagrama de forças."
                                  ],
                                  "verification": "Gere relatório com A_i*, forças, deslocamentos e checks de viabilidade.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Bibliotecas Matplotlib/Seaborn para plots",
                                    "Software FEA como ANSYS para validação opcional"
                                  ],
                                  "tips": "Compare com solução analítica para treliças pequenas.",
                                  "learningObjective": "Interpretar saídas do solver em contexto estrutural.",
                                  "commonMistakes": [
                                    "Confundir forças primárias com secundárias.",
                                    "Ignorar singularidade na matriz de rigidez."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e realizar análise de sensibilidade",
                                  "subSteps": [
                                    "Valide com método alternativo: FEA ou analítico.",
                                    "Teste sensibilidade: varie cargas ou E e re-solve.",
                                    "Avalie robustez: perturbe parâmetros e cheque estabilidade.",
                                    "Documente insights: quais barras são críticas?",
                                    "Sugira melhorias: adicionar não-linearidades se necessário."
                                  ],
                                  "verification": "Relatório de validação com erros <5% e gráficos de sensibilidade.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Código reutilizável do Step 3",
                                    "Ferramentas de plotagem"
                                  ],
                                  "tips": "Use loops para múltiplos cenários de sensibilidade.",
                                  "learningObjective": "Garantir confiabilidade da solução ótima.",
                                  "commonMistakes": [
                                    "Sobreestimar precisão sem validação externa.",
                                    "Não considerar incertezas em cargas."
                                  ]
                                }
                              ],
                              "practicalExample": "Otimize uma treliça de 2 barras (30° e 60° sob carga vertical de 10kN na junta livre): minimize peso sujeito a σ ≤ 200MPa, E=200GPa, L=1m cada. Solução: A1≈0.0005m², A2≈0.0003m², forças N1=8.66kN compressão, N2=5kN tração, deslocamento vertical≈1mm.",
                              "finalVerifications": [
                                "Modelo LP resolve com status ótimo e viável.",
                                "Restrições satisfeitas (tensões, equilíbrio, bounds).",
                                "Interpretação correta: forças e deslocamentos coerentes com física.",
                                "Validação cruzada com FEA ou analítico (erro <5%).",
                                "Análise de sensibilidade identifica variáveis críticas.",
                                "Código reproduzível e documentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação LP (linearidade, completude: 30%).",
                                "Implementação correta no solver (sem erros numéricos: 25%).",
                                "Interpretação física dos resultados (forças/deslocamentos: 20%).",
                                "Validação e sensibilidade (robustez: 15%).",
                                "Clareza do relatório e visualizações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Mecânica dos Sólidos: derivação de rigidez e equilíbrio.",
                                "Programação Computacional: uso de Python/PuLP para modelagem.",
                                "Álgebra Linear: matrizes de equilíbrio e rigidez.",
                                "Estatística: análise de sensibilidade e Monte Carlo.",
                                "Gestão de Projetos: otimização custo-peso em construções."
                              ],
                              "realWorldApplication": "Otimização de treliças em pontes (ex: ponte estaiada), torres de transmissão elétrica ou telhados de estádios, reduzindo material em 20-30% enquanto mantém segurança, como no projeto da Ponte de Øresund."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Usar métodos não-lineares para otimização de seções compostas",
                            "description": "Implementar gradiente descendente ou algoritmos genéticos para otimizar seções de concreto armado, considerando não-linearidades em materiais e geometria.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o problema de otimização não-linear para seções compostas",
                                  "subSteps": [
                                    "Identificar variáveis de otimização: dimensões da seção (largura, altura, espessura de aço), proporção de armadura e geometria composta.",
                                    "Definir função objetivo: minimizar peso, custo ou volume, incorporando não-linearidades materiais como curva tensão-deformação do concreto.",
                                    "Estabelecer restrições: limites de resistência, deformação, estabilidade e normas de concreto armado (ex: NBR 6118), incluindo não-linearidades geométricas.",
                                    "Incorporar modelos constitutivos não-lineares: lei de Hooke modificada para aço e modelo de dano para concreto.",
                                    "Validar o modelo analiticamente com um caso simples linearizado."
                                  ],
                                  "verification": "Modelo matemático documentado em equações e pseudocódigo, com pelo menos uma verificação analítica manual.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python ou MATLAB com bibliotecas NumPy/SciPy",
                                    "Referências: NBR 6118, livros de otimização estrutural",
                                    "Planilha para prototipagem inicial"
                                  ],
                                  "tips": "Use diagramas esquemáticos da seção para visualizar variáveis e restrições antes de codificar.",
                                  "learningObjective": "Formular precisamente problemas de otimização não-linear em seções compostas de concreto armado.",
                                  "commonMistakes": [
                                    "Negligenciar não-linearidades no concreto esmagado",
                                    "Definir restrições sem considerar interações material-geometria",
                                    "Escolher variáveis excessivamente acopladas sem sensibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o modelo computacional do problema",
                                  "subSteps": [
                                    "Codificar a função objetivo e gradientes analíticos ou numéricos para não-linearidades.",
                                    "Implementar funções de restrições com penalidades para violações não-lineares.",
                                    "Criar rotina de avaliação de seção: calcular esforços internos via integração numérica considerando geometria composta.",
                                    "Testar o modelo com dados de entrada conhecidos e comparar com soluções analíticas.",
                                    "Adicionar visualizações: plots de seção otimizada e curvas tensão-deformação."
                                  ],
                                  "verification": "Testes unitários passam para 5 casos de benchmark, com erros < 1%.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Ambiente de programação (Jupyter Notebook)",
                                    "Bibliotecas: SciPy para integração, Matplotlib para plots",
                                    "Dados de propriedades: E_concreto=25GPa, fy_aço=500MPa"
                                  ],
                                  "tips": "Implemente gradientes numéricos finitos inicialmente para depuração rápida.",
                                  "learningObjective": "Desenvolver código robusto para simular comportamentos não-lineares em seções estruturais.",
                                  "commonMistakes": [
                                    "Erros de indexação em arrays multidimensionais da geometria",
                                    "Não tratar singularidades em não-linearidades geométricas",
                                    "Ignorar precisão numérica em integrações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e codificar algoritmo de otimização não-linear",
                                  "subSteps": [
                                    "Escolher algoritmo: gradiente descendente conjugado para problemas suaves ou algoritmo genético para multimodalidade.",
                                    "Implementar inicialização: pontos iniciais factíveis baseados em projeto preliminar.",
                                    "Codificar loop de otimização: atualizações de variáveis, verificação de convergência (tol=1e-6) e callbacks para logging.",
                                    "Integrar penalidades ou barreiras para restrições não-lineares ativas.",
                                    "Executar tuning de hiperparâmetros: learning rate para GD ou população/mutação para GA."
                                  ],
                                  "verification": "Algoritmo executa sem erros e converge em <100 iterações para caso teste.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Bibliotecas: SciPy.optimize para GD, DEAP para GA",
                                    "Hardware com GPU opcional para aceleração",
                                    "Scripts de benchmark de algoritmos"
                                  ],
                                  "tips": "Compare GD vs GA em um mini-problema para justificar escolha.",
                                  "learningObjective": "Aplicar e customizar solvers não-lineares para otimização estrutural.",
                                  "commonMistakes": [
                                    "Taxa de aprendizado muito alta causando divergência",
                                    "População genética pequena levando a convergência prematura",
                                    "Não normalizar variáveis de escalas díspares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar otimização, analisar resultados e validar",
                                  "subSteps": [
                                    "Rodar otimização completa para caso real: viga sob flexão com cargas variáveis.",
                                    "Analisar sensibilidade: variar parâmetros materiais e observar impacto na solução.",
                                    "Comparar com métodos lineares: quantificar ganhos de não-linearidade.",
                                    "Validar contra normas: verificar fatores de segurança e ductilidade.",
                                    "Documentar relatório: métricas de performance, plots de convergência e seção final."
                                  ],
                                  "verification": "Solução otimizada reduz objetivo em >15% vs inicial, todas restrições satisfeitas.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Ferramentas de análise: Post-processador para esforços",
                                    "Normas técnicas impressas/PDF",
                                    "Software FEA como ANSYS para validação opcional"
                                  ],
                                  "tips": "Salve checkpoints a cada 10 iterações para recuperação de crashes.",
                                  "learningObjective": "Interpretar e validar resultados de otimização em contexto estrutural real.",
                                  "commonMistakes": [
                                    "Sobre-otimização ignorando incertezas de fabricação",
                                    "Não reportar intervalos de confiança",
                                    "Comparações inválidas sem normalização"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimizar seção transversal de viga composta aço-concreto (altura 500mm, largura variável, armadura 2%) para momento fletor de 200kNm, minimizando peso com não-linearidades do concreto (fck=30MPa) e geometria trapezoidal, usando gradiente descendente: solução final reduz peso em 22% vs projeto uniforme.",
                              "finalVerifications": [
                                "Função objetivo minimizada com convergência estável (gradiente <1e-6).",
                                "Todas restrições não-lineares satisfeitas (resistência >1.4*fator segurança).",
                                "Seção otimizada visualmente coerente e fabricável.",
                                "Análise de sensibilidade mostra robustez a ±10% em propriedades materiais.",
                                "Comparação com solver comercial (ex: MATLAB fmincon) dentro de 5%.",
                                "Relatório documenta código, inputs/outputs e plots."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo não-linear (erro <2% em benchmarks).",
                                "Eficiência algorítmica (convergência em <200 avaliações).",
                                "Qualidade da solução (redução objetivo >20% vs baseline).",
                                "Robustez a variações (teste Monte Carlo passa).",
                                "Clareza da documentação e visualizações.",
                                "Correta incorporação de normas de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-convexa e análise numérica.",
                                "Programação: Bibliotecas de otimização e computação científica.",
                                "Materiais: Mecânica não-linear de concretos e compósitos.",
                                "Engenharia de Software: Testes unitários e versionamento.",
                                "Estatística: Análise de sensibilidade e incertezas."
                              ],
                              "realWorldApplication": "Otimização de seções em pontes estaiadas ou edifícios altos, reduzindo consumo de cimento (até 25%) e emissões de CO2, enquanto atende normas sísmicas e acelera projetos em firmas como Odebrecht ou AECOM."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Otimização na Alocação de Recursos",
                        "description": "Técnicas de programação matemática para alocar eficientemente mão de obra, materiais e equipamentos em canteiros de obra.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Modelar alocação de recursos com programação inteira",
                            "description": "Formular modelos de programação linear inteira mista (MILP) para atribuir trabalhadores e máquinas a tarefas, minimizando tempo total ou custo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o problema e coletar dados de entrada",
                                  "subSteps": [
                                    "Analise o cenário de alocação: identifique tarefas, trabalhadores disponíveis, máquinas e restrições como tempo de setup ou compatibilidades.",
                                    "Colete dados quantitativos: número de tarefas (T), trabalhadores (W), máquinas (M), tempos de execução por combinação (t_wmt), custos (c_wmt).",
                                    "Defina o objetivo: minimizar tempo total de makespan ou custo total.",
                                    "Crie uma tabela ou matriz de dados para visualizar as entradas.",
                                    "Documente suposições, como tarefas não preemptivas e uma tarefa por vez por recurso."
                                  ],
                                  "verification": "Verifique se há uma tabela completa de dados com todas as entradas identificadas e suposições listadas em um documento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Papel e caneta para diagrama",
                                    "Exemplo de problema de alocação em PDF"
                                  ],
                                  "tips": "Comece com um problema pequeno (3 tarefas, 2 trabalhadores, 2 máquinas) para praticar.",
                                  "learningObjective": "Identificar e quantificar todos os elementos do problema de alocação de recursos.",
                                  "commonMistakes": [
                                    "Ignorar restrições reais como incompatibilidades entre trabalhador e máquina.",
                                    "Não definir claramente o horizonte temporal ou capacidades."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir variáveis de decisão e parâmetros do modelo MILP",
                                  "subSteps": [
                                    "Defina variáveis binárias x_wmt = 1 se trabalhador w e máquina m alocados à tarefa t, 0 caso contrário.",
                                    "Introduza variáveis auxiliares: y_wt = 1 se trabalhador w alocado à tarefa t; z_mt para máquinas.",
                                    "Defina variáveis contínuas para tempos de início/fim se necessário (s_t para start time de tarefa t).",
                                    "Liste parâmetros: conjuntos W, M, T; tempos t_wmt, custos c_wmt.",
                                    "Escreva a notação matemática formal para todas as variáveis."
                                  ],
                                  "verification": "Confirme que todas as variáveis estão declaradas com domínio (binário/inteiro/contínuo) e notação consistente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Editor de texto como LaTeX ou Overleaf para fórmulas",
                                    "Documentação de solvers como PuLP ou Gurobi"
                                  ],
                                  "tips": "Use índices duplos ou triplos para variáveis de alocação para capturar combinações.",
                                  "learningObjective": "Formular variáveis de decisão adequadas para modelar alocações discretas em MILP.",
                                  "commonMistakes": [
                                    "Usar variáveis contínuas em vez de binárias para alocações 0-1.",
                                    "Esquecer variáveis auxiliares para agregações."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular restrições do modelo",
                                  "subSteps": [
                                    "Restrição de cobertura: cada tarefa deve ter exatamente um trabalhador e uma máquina (∑_w x_wmt = 1 ∀ t; ∑_m x_wmt = 1 ∀ t).",
                                    "Restrição de capacidade: cada trabalhador/máquina alocado a no máximo uma tarefa por vez (∑_t x_wmt ≤ 1 ∀ w,m se sequencial).",
                                    "Restrições de precedência: s_j ≥ s_i + t_wmi se i precede j.",
                                    "Restrições de compatibilidade: x_wmt = 0 para pares incompatíveis.",
                                    "Adicione big-M para linearizar se necessário e defina makespan C ≥ s_t + duração_t ∀ t."
                                  ],
                                  "verification": "Teste as restrições manualmente em um problema pequeno para garantir viabilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Solver de otimização gratuito como CBC via Python PuLP",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Priorize restrições de cobertura primeiro, depois capacidades e precedências.",
                                  "learningObjective": "Traduzir restrições qualitativas do problema em desigualdades lineares MILP.",
                                  "commonMistakes": [
                                    "Restrições de soma erradas (ex: ≥1 em vez de =1).",
                                    "Não linearizar corretamente precedências com big-M."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir função objetivo e implementar o modelo",
                                  "subSteps": [
                                    "Escreva o objetivo: min C (makespan) ou min ∑ c_wmt x_wmt (custo).",
                                    "Implemente o modelo em software: use PuLP em Python para definir variáveis, restrições e objetivo.",
                                    "Configure o solver (CBC ou Gurobi) e resolva o modelo.",
                                    "Analise a saída: valores de variáveis, valor ótimo, tempo de CPU.",
                                    "Sensitividade: varie um parâmetro e re-resolva para entender impactos."
                                  ],
                                  "verification": "O modelo roda sem erros e produz uma solução factível com valor objetivo finito.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com bibliotecas PuLP e pandas",
                                    "Instalador de solver CBC",
                                    "Exemplo de código MILP pronto"
                                  ],
                                  "tips": "Ative logs do solver para debuggar infeasabilidades.",
                                  "learningObjective": "Implementar e otimizar um modelo MILP completo para alocação.",
                                  "commonMistakes": [
                                    "Erro de indexação no código.",
                                    "Objetivo não alinhado com variáveis definidas."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar, interpretar e refinar o modelo",
                                  "subSteps": [
                                    "Valide a solução: verifique se todas restrições são satisfeitas e alocações fazem sentido.",
                                    "Interprete resultados: identifique gargalos (ex: trabalhador sobrecarregado).",
                                    "Teste cenários: adicione/ remova recursos e compare soluções.",
                                    "Refine o modelo: adicione restrições reais omitidas ou relaxe para LP.",
                                    "Documente o relatório final com solução ótima e insights."
                                  ],
                                  "verification": "Gere um relatório com solução validada, gráficos de Gantt e análise de sensibilidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Biblioteca matplotlib para gráficos de alocação",
                                    "Template de relatório em Word/Google Docs"
                                  ],
                                  "tips": "Use diagramas de Gantt para visualizar alocações temporais.",
                                  "learningObjective": "Avaliar criticamente e melhorar modelos MILP baseados em resultados.",
                                  "commonMistakes": [
                                    "Aceitar soluções infactíveis sem verificação.",
                                    "Ignorar tempo de computação em problemas grandes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um canteiro de obras com 5 tarefas de construção (fundação, estrutura, acabamento, etc.), 3 trabalhadores (pedreiro, eletricista, ajudante) e 2 máquinas (guindaste, betoneira). Formule MILP para minimizar makespan, considerando tempos como 4h para pedreiro+guindaste na fundação, restrições de precedência (fundação antes de estrutura) e incompatibilidades (eletricista não usa betoneira). Solução ótima: makespan de 12h com alocações específicas.",
                              "finalVerifications": [
                                "Capacidade de formular corretamente variáveis binárias e restrições de cobertura para um problema dado.",
                                "Implementação de MILP em PuLP que resolve sem erros e valida solução.",
                                "Interpretação de resultados com identificação de gargalos e makespan ótimo.",
                                "Adaptação do modelo para variações como mudança de objetivo (custo vs tempo).",
                                "Geração de relatório com gráficos de Gantt e análise de sensibilidade.",
                                "Resolução de um problema novo em menos de 30 minutos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: fórmulas corretas e lineares (30%)",
                                "Implementação funcional: código roda e otimiza (25%)",
                                "Validação e interpretação: solução factível e insights (20%)",
                                "Detalhe nos subpassos: cobertura completa de restrições reais (15%)",
                                "Eficiência: tempo de resolução <5min para problemas médios (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação Linear (relaxação MILP para bounds iniciais)",
                                "Engenharia de Produção (job-shop scheduling)",
                                "Gestão de Projetos (CPM com recursos limitados)",
                                "Ciência de Dados (otimização em Python com PuLP)",
                                "Economia (alocação eficiente de recursos escassos)"
                              ],
                              "realWorldApplication": "Em projetos de construção civil, otimizar alocação de equipes e equipamentos em canteiros de obras para reduzir atrasos e custos, como no software Primavera P6 ou ferramentas personalizadas em grandes empreiteiras como Odebrecht ou construtoras de metrô."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Resolver problemas de transporte em suprimentos de materiais",
                            "description": "Aplicar o método de transporte ou solvers para otimizar rotas e quantidades de materiais de fornecedores para múltiplos canteiros, reduzindo custos logísticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema de Transporte e sua Formulação Matemática",
                                  "subSteps": [
                                    "Estude a definição do problema de transporte: minimizar custos de envio de suprimentos de múltiplos fornecedores para múltiplos destinos (canteiros).",
                                    "Identifique componentes chave: fontes (fornecedores com oferta), sinks (canteiros com demanda), custos unitários de transporte.",
                                    "Aprenda a formulação LP: variáveis x_ij (quantidade de fornecedor i para canteiro j), função objetivo min ∑ c_ij x_ij, restrições de oferta ∑ x_ij ≤ oferta_i, demanda ∑ x_i j = demanda_j.",
                                    "Revise balanceamento: total oferta = total demanda para problema balanceado.",
                                    "Explore variantes: problema desbalanceado e capacitated."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a formulação LP para um exemplo simples com 2 fornecedores e 2 canteiros.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Otimização ou slides sobre Programação Linear",
                                    "Vídeo tutorial sobre Problema de Transporte (Khan Academy ou YouTube)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": [
                                    "Comece com exemplos pequenos para visualizar fluxos.",
                                    "Desenhe tabelas de custo para intuitividade.",
                                    "Use notação padrão: i para fontes, j para sinks."
                                  ],
                                  "learningObjective": "Dominar a formulação matemática do problema de transporte e identificar restrições chave.",
                                  "commonMistakes": [
                                    "Confundir oferta com demanda.",
                                    "Esquecer restrições de não-negatividade.",
                                    "Ignorar balanceamento inicial."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar um Problema Real de Suprimentos em Engenharia Civil",
                                  "subSteps": [
                                    "Colete dados reais: liste 3 fornecedores de cimento (ofertas: 100t, 150t, 200t), 3 canteiros (demandas: 120t, 180t, 150t), matriz de custos (ex: R$10/t, R$15/t etc.).",
                                    "Construa a tabela de transporte: fontes na linha, sinks na coluna, custos nas células.",
                                    "Formule o modelo LP completo: defina variáveis, objetivo, restrições.",
                                    "Verifique balanceamento e ajuste se necessário (adicionar fonte/sink fictícia).",
                                    "Documente suposições: capacidades de caminhões, distâncias aproximadas."
                                  ],
                                  "verification": "Crie uma tabela de transporte balanceada e escreva as equações LP em um documento.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Dados fictícios/real de projetos civis (pesquise online)",
                                    "Template de tabela de transporte"
                                  ],
                                  "tips": [
                                    "Use dados realistas de distâncias entre cidades para custos.",
                                    "Sempre some ofertas e demandas para checar.",
                                    "Salve o modelo para reutilização."
                                  ],
                                  "learningObjective": "Capacidade de traduzir cenário de engenharia civil em modelo matemático acionável.",
                                  "commonMistakes": [
                                    "Dados inconsistentes (oferta ≠ demanda).",
                                    "Custos errados por unidade.",
                                    "Variáveis não indexadas corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Métodos Iniciais de Solução Manual",
                                  "subSteps": [
                                    "Aplique o Método do Canto Noroeste para solução inicial básica viável.",
                                    "Calcule alocações passo a passo: comece canto superior esquerdo, atenda mínimo(oferta/demanda), zere linha/coluna esgotada.",
                                    "Use Critério de Stepping Stone para melhorar: identifique ciclos, calcule custos de fechamento/entrada.",
                                    "Itere até otimalidade: custo total não melhora mais.",
                                    "Calcule custo total da solução inicial e otimizada."
                                  ],
                                  "verification": "Resolva manualmente o exemplo do Step 2 e compare custo inicial vs. final.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Papel quadriculado ou planilha para tabelas",
                                    "Calculadora",
                                    "Guia passo-a-passo do método (PDF online)"
                                  ],
                                  "tips": [
                                    "Marque células básicas com X para rastrear.",
                                    "Teste ciclos em vazio para validar.",
                                    "Pratique com 2x2 primeiro."
                                  ],
                                  "learningObjective": "Executar soluções manuais para entender mecânica do algoritmo.",
                                  "commonMistakes": [
                                    "Erro em ciclos de stepping stone.",
                                    "Não zerar linhas/colunas corretamente.",
                                    "Cálculo errado de delta (custo de melhoria)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Usar Solvers Computacionais para Otimização Eficiente",
                                  "subSteps": [
                                    "Configure Solver no Excel: insira dados na planilha, defina células de decisão, restrições, otimize.",
                                    "Implemente em Python com PuLP: instale biblioteca, defina problema LpProblem, variáveis LpVariable, restrições, resolva com CBC solver.",
                                    "Compare resultados manual vs. solver para validação.",
                                    "Gere relatório: alocações ótimas, custo mínimo, fluxos.",
                                    "Teste cenários: altere demandas/custos e re-resolva."
                                  ],
                                  "verification": "Obtenha solução ótima idêntica ao manual via Excel/Python e exporte relatório.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Microsoft Excel com Solver add-in",
                                    "Python + PuLP + Jupyter Notebook",
                                    "Dataset do Step 2"
                                  ],
                                  "tips": [
                                    "Ative Solver no Excel via Arquivo > Opções.",
                                    "Use dicts em PuLP para matrizes.",
                                    "Sempre cheque status 'Optimal'."
                                  ],
                                  "learningObjective": "Aplicar ferramentas computacionais para problemas maiores e escaláveis.",
                                  "commonMistakes": [
                                    "Restrições mal configuradas no solver.",
                                    "Unidades inconsistentes.",
                                    "Não linearizar problema capacitated."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Sensibilidade e Aplicar em Contexto Real",
                                  "subSteps": [
                                    "Realize análise de sensibilidade: varie ±10% em custos/demandas, observe mudanças em alocações.",
                                    "Interprete shadow prices: custo marginal de aumentar demanda.",
                                    "Otimize rotas considerando múltiplos produtos ou veículos.",
                                    "Simule cenário de engenharia: reduza custos logísticos em 15%.",
                                    "Documente lições: quando usar manual vs. solver."
                                  ],
                                  "verification": "Gere relatório de sensibilidade mostrando impacto em custo total.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Solver com relatório de sensibilidade",
                                    "Gráficos em Excel/Python (Matplotlib)"
                                  ],
                                  "tips": [
                                    "Foque em variáveis críticas como combustível.",
                                    "Use gráficos para visualizar trade-offs.",
                                    "Considere sustentabilidade (CO2)."
                                  ],
                                  "learningObjective": "Avaliar robustez da solução e conectar à prática civil.",
                                  "commonMistakes": [
                                    "Ignorar shadow prices.",
                                    "Sobreestimar escalabilidade manual.",
                                    "Não considerar incertezas reais."
                                  ]
                                }
                              ],
                              "practicalExample": "Três fornecedores de aço (A: 200t em SP, B: 300t em RJ, C: 250t em MG) para três canteiros (X: 250t em Campinas, Y: 300t em São José dos Campos, Z: 200t em Ribeirão Preto). Custos: A-X R$5/t, A-Y R$8/t, etc. Solução ótima: alocações específicas reduzindo custo total de R$3.500 para R$2.800.",
                              "finalVerifications": [
                                "Formula corretamente modelo LP para novo dataset.",
                                "Implementa solução via solver com custo mínimo exato.",
                                "Explica stepping stone para melhoria em tabela.",
                                "Analisa sensibilidade e recomenda ajustes.",
                                "Aplica a cenário civil com relatório completo.",
                                "Compara manual vs. computacional sem discrepâncias."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação LP (100% restrições corretas).",
                                "Custo ótimo mínimo alcançado (±1% tolerância).",
                                "Solução viável: respeita ofertas/demandas.",
                                "Relatório claro com interpretações e gráficos.",
                                "Análise de sensibilidade com insights acionáveis.",
                                "Eficiência: tempo de resolução para problema 5x5 <10min."
                              ],
                              "crossCurricularConnections": [
                                "Programação Linear (Matemática Aplicada).",
                                "Gestão de Logística e Cadeia de Suprimentos.",
                                "Programação em Python/R para Otimização.",
                                "Gestão de Projetos em Engenharia Civil.",
                                "Análise de Dados e Sensibilidade."
                              ],
                              "realWorldApplication": "Em grandes obras civis como rodovias ou conjuntos habitacionais, otimiza suprimentos de concreto, aço e areia de pedreiras/fornecedores para canteiros distantes, reduzindo custos logísticos em 10-20%, atrasos e emissões de CO2, integrando com ERP de construção."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Implementar heurísticas para alocação dinâmica de recursos",
                            "description": "Desenvolver algoritmos como simulated annealing para lidar com incertezas em demandas de recursos durante a execução de obras civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de heurísticas e Simulated Annealing",
                                  "subSteps": [
                                    "Estudar o conceito de heurísticas em problemas de otimização combinatorial.",
                                    "Aprender os princípios do Simulated Annealing: inicialização, vizinhança, temperatura inicial e schedule de resfriamento.",
                                    "Analisar a analogia física do recozimento metálico aplicada ao algoritmo.",
                                    "Revisar pseudocódigo básico de Simulated Annealing.",
                                    "Identificar quando usar SA em problemas NP-difíceis como alocação de recursos."
                                  ],
                                  "verification": "Explicar oralmente ou por escrito os componentes principais do SA e sua motivação para alocação dinâmica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação oficial de Simulated Annealing (Wikipedia ou artigos acadêmicos)",
                                    "Vídeos tutoriais no YouTube sobre SA",
                                    "Pseudocódigos em PDF"
                                  ],
                                  "tips": "Use a analogia do metal quente para visualizar como o algoritmo aceita soluções piores inicialmente.",
                                  "learningObjective": "Dominar os conceitos teóricos do Simulated Annealing para aplicação em otimização.",
                                  "commonMistakes": [
                                    "Confundir SA com busca exaustiva.",
                                    "Escolher schedule de resfriamento inadequado sem justificativa.",
                                    "Ignorar a probabilidade de aceitação de soluções ruins."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o problema de alocação dinâmica de recursos em obras civis",
                                  "subSteps": [
                                    "Definir variáveis: recursos (máquinas, mão de obra), tarefas, demandas incertas (distribuições probabilísticas).",
                                    "Formular a função objetivo: minimizar custos, atrasos ou ociosidade considerando incertezas.",
                                    "Estruturar o espaço de soluções: alocações como vetores ou matrizes.",
                                    "Definir operadores de vizinhança: trocas de recursos entre tarefas ou realocações.",
                                    "Incorporar restrições: disponibilidade limitada, janelas de tempo dinâmicas."
                                  ],
                                  "verification": "Criar um diagrama ou documento descrevendo o modelo matemático e um exemplo pequeno resolvido manualmente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de modelagem como Draw.io ou papel e lápis",
                                    "Exemplos de problemas de alocação em engenharia civil (artigos IEEE)",
                                    "Python com NumPy para prototipagem rápida"
                                  ],
                                  "tips": "Comece com um problema pequeno (3 tarefas, 2 recursos) para validar o modelo antes de escalar.",
                                  "learningObjective": "Construir um modelo realista de alocação dinâmica adaptado a incertezas em obras civis.",
                                  "commonMistakes": [
                                    "Não modelar incertezas adequadamente (usar valores fixos).",
                                    "Definir vizinhanças muito restritivas que limitam a exploração.",
                                    "Ignorar viabilidade das soluções geradas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o algoritmo Simulated Annealing em código",
                                  "subSteps": [
                                    "Configurar ambiente: instalar bibliotecas (NumPy, SciPy para probabilidades).",
                                    "Codificar função de avaliação da solução (custo total com incertezas simuladas).",
                                    "Implementar gerador de vizinhanças e loop principal com schedule de resfriamento geométrico.",
                                    "Adicionar simulação de demandas incertas (ex: distribuições normais ou Poisson).",
                                    "Incluir logging para rastrear temperatura, melhor solução e iterações."
                                  ],
                                  "verification": "Executar o código em um caso teste simples e verificar se produz saídas coerentes sem erros.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: NumPy, Matplotlib para visualizações",
                                    "Editor de código como VS Code ou Jupyter Notebook"
                                  ],
                                  "tips": "Teste cada função isoladamente (unit tests) antes de integrar no loop principal.",
                                  "learningObjective": "Desenvolver uma implementação funcional e eficiente do SA para o problema específico.",
                                  "commonMistakes": [
                                    "Bug no cálculo de probabilidades (exp(-delta/T)).",
                                    "Resfriamento muito rápido levando a convergência prematura.",
                                    "Falta de randomização adequada nas vizinhanças."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, validar e otimizar a implementação",
                                  "subSteps": [
                                    "Gerar datasets sintéticos de obras civis com demandas variáveis.",
                                    "Executar múltiplas runs e analisar métricas: tempo de CPU, qualidade da solução (gap ótimo).",
                                    "Comparar com baselines (greedy ou random).",
                                    "Ajustar hiperparâmetros: temperatura inicial, fator de resfriamento, número de iterações.",
                                    "Visualizar resultados: gráficos de convergência e alocações finais."
                                  ],
                                  "verification": "Produzir relatório com tabelas/gráficos mostrando melhoria >20% sobre baseline em cenários incertos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Jupyter Notebook para experimentos",
                                    "Matplotlib/Seaborn para plots",
                                    "Datasets de exemplo (gerados ou públicos de construção)"
                                  ],
                                  "tips": "Use seeds fixas para reprodutibilidade e rode 10+ execuções por configuração.",
                                  "learningObjective": "Avaliar e refinar o algoritmo para robustez em cenários reais de engenharia civil.",
                                  "commonMistakes": [
                                    "Não testar com incertezas extremas.",
                                    "Sobreajustar hiperparâmetros sem validação cruzada.",
                                    "Ignorar tempo de execução em instâncias grandes."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e documentar a solução para uso prático",
                                  "subSteps": [
                                    "Criar interface simples (função ou script) para inputs de projetos reais.",
                                    "Documentar código com comentários e README (parâmetros, limitações).",
                                    "Simular caso real: alocação em obra com 10+ tarefas e recursos limitados.",
                                    "Discutir extensões: multi-objetivo ou paralelização.",
                                    "Preparar apresentação dos resultados."
                                  ],
                                  "verification": "Demonstrar a solução rodando em um cenário completo e gerar relatório final.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "GitHub para versionamento",
                                    "Templates de relatório LaTeX ou Markdown"
                                  ],
                                  "tips": "Pense em modularidade para reutilizar em outros problemas de otimização civil.",
                                  "learningObjective": "Produzir uma solução pronta para prototipagem em projetos de engenharia.",
                                  "commonMistakes": [
                                    "Código não legível ou sem documentação.",
                                    "Não considerar escalabilidade para obras grandes.",
                                    "Omitir discussão de limitações do SA."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma obra de construção de um viaduto urbano, com 15 tarefas sequenciais e recursos como 5 guindastes e 20 operários, demandas variam 20-50% devido a chuvas imprevisíveis. Implemente SA para realocar recursos a cada turno, minimizando atrasos e custos de ociosidade, simulando 100 cenários incertos.",
                              "finalVerifications": [
                                "O algoritmo converge para soluções viáveis em <5 minutos para instâncias médias.",
                                "Melhoria média de 25% na função objetivo comparado a heurística gulosa.",
                                "Solução lida corretamente com 30% de variação nas demandas simuladas.",
                                "Código executa sem erros e logs rastreiam evoluções.",
                                "Visualizações mostram trajetórias de convergência estáveis.",
                                "Solução respeita todas as restrições de capacidade e tempo."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem: representação fiel de incertezas em recursos civis (nota 1-10).",
                                "Eficiência computacional: tempo de execução e escalabilidade (benchmark).",
                                "Qualidade da solução: gap ótimo médio em testes múltiplos.",
                                "Robustez: performance em cenários de alta incerteza.",
                                "Clareza do código e documentação: legibilidade e completude.",
                                "Inovação: ajustes personalizados ao SA para o contexto civil."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização estocástica e programação não linear.",
                                "Informática: Algoritmos meta-heurísticos e programação numérica.",
                                "Gestão de Projetos: Planejamento dinâmico e controle de recursos (PMI).",
                                "Estatística: Modelagem probabilística de demandas e simulações Monte Carlo.",
                                "Engenharia de Software: Testes unitários e validação de algoritmos."
                              ],
                              "realWorldApplication": "Em canteiros de obras civis como barragens ou metrôs, onde atrasos por clima ou falhas alteram demandas, o SA permite realocações automáticas de equipamentos e equipes, reduzindo custos em 15-30% e evitando paradas, integrando-se a softwares como MS Project ou ERP de construção."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Otimização no Planejamento de Projetos",
                        "description": "Uso de otimização para agendamento, sequenciamento de atividades e gerenciamento de riscos em projetos de engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Otimizar cronogramas com o método do caminho crítico",
                            "description": "Integrar programação matemática ao CPM/PERT para minimizar duração total do projeto, considerando dependências e recursos limitados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos do Método do Caminho Crítico (CPM) e PERT",
                                  "subSteps": [
                                    "Estudar definições de atividades, eventos, dependências (FS, SS, FF, SF) e durações estimadas.",
                                    "Diferenciar CPM (durações determinísticas) de PERT (durações probabilísticas com otimismo, mais provável e pessimista).",
                                    "Aprender conceitos chave: folga total (TF), folga livre (FL), caminho crítico (zero folga).",
                                    "Revisar exemplos simples de redes AON (Activity on Node) e AOA (Activity on Arrow).",
                                    "Exercitar cálculo manual de durações esperadas em PERT."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito os conceitos de folga e caminho crítico com um exemplo de 3 atividades.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de gestão de projetos (PMBOK), vídeo tutoriais sobre CPM/PERT, papel e caneta para diagramas"
                                  ],
                                  "tips": "Comece com redes pequenas para fixar conceitos antes de projetos complexos.",
                                  "learningObjective": "Dominar terminologia e diferenças entre CPM e PERT para modelagem de projetos.",
                                  "commonMistakes": [
                                    "Confundir folga total com folga livre",
                                    "Ignorar tipos de dependências além de FS",
                                    "Usar durações fixas em PERT sem probabilidades"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o diagrama de rede e listar atividades com dependências",
                                  "subSteps": [
                                    "Listar todas as atividades do projeto, suas durações e predecessoras/sucessoras.",
                                    "Desenhar o grafo de rede usando convenções AON, marcando durações nos nós.",
                                    "Identificar loops ou dependências paralelas incorretas e corrigi-las.",
                                    "Calcular número de caminhos possíveis e listar dependências críticas iniciais.",
                                    "Validar o diagrama com checklist: início/fim únicos, sem ciclos."
                                  ],
                                  "verification": "Produzir um diagrama de rede completo e sem erros para um projeto de 8-10 atividades.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software como MS Project ou draw.io, planilha Excel para lista de atividades"
                                  ],
                                  "tips": "Use setas coloridas para diferentes tipos de dependências para visualização clara.",
                                  "learningObjective": "Modelar graficamente qualquer projeto com dependências precisas.",
                                  "commonMistakes": [
                                    "Criar ciclos na rede",
                                    "Esquecer dependências paralelas",
                                    "Não numerar eventos corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o caminho crítico via passes forward e backward",
                                  "subSteps": [
                                    "Executar forward pass: calcular ES (Early Start) e EF (Early Finish) para cada atividade.",
                                    "Executar backward pass: calcular LS (Late Start) e LF (Late Finish) a partir do fim do projeto.",
                                    "Determinar folgas e identificar atividades no caminho crítico (folga = 0).",
                                    "Calcular duração total do projeto e listar atividades críticas.",
                                    "Simular variações de duração para observar impacto no caminho crítico."
                                  ],
                                  "verification": "Calcular corretamente ES, EF, LS, LF e caminho crítico para o diagrama do passo 2.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Planilha Excel com fórmulas para passes, calculadora"
                                  ],
                                  "tips": "Sempre comece forward do início (ES=0) e backward do fim (LF=duração total).",
                                  "learningObjective": "Aplicar algoritmo CPM para determinar duração mínima e caminho crítico.",
                                  "commonMistakes": [
                                    "Erro aritmético em forward pass propagando para backward",
                                    "Confundir ES com LS",
                                    "Ignorar múltiplos caminhos críticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar cronograma considerando recursos limitados via programação matemática",
                                  "subSteps": [
                                    "Identificar restrições de recursos (ex: mão de obra limitada por dia).",
                                    "Formular modelo LP/IP: minimizar duração total, variáveis de início de atividades, restrições de dependências e recursos.",
                                    "Implementar em solver (Excel Solver, PuLP em Python ou LINGO).",
                                    "Analisar solução: novo caminho crítico, alocação ótima de recursos.",
                                    "Avaliar trade-offs: custo vs. tempo (crashing de atividades)."
                                  ],
                                  "verification": "Resolver um modelo otimizado e comparar duração original vs. otimizada (redução ≥10%).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Excel com Solver add-in, Python + PuLP library, exemplos de modelos LP para projetos"
                                  ],
                                  "tips": "Comece com modelo simples sem recursos, adicione restrições gradualmente.",
                                  "learningObjective": "Integrar CPM com programação matemática para otimização realista.",
                                  "commonMistakes": [
                                    "Violar restrições de dependências no modelo",
                                    "Usar variáveis contínuas onde inteiras são necessárias",
                                    "Não linearizar restrições de recursos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e refinar o cronograma otimizado",
                                  "subSteps": [
                                    "Simular cenários what-if (atrasos, crashing) e recalcular caminho crítico.",
                                    "Calcular índices de eficiência: uso de recursos, redução de tempo.",
                                    "Documentar relatório: Gantt otimizado, riscos no caminho crítico.",
                                    "Testar sensibilidade a variações de durações/recursos.",
                                    "Propor melhorias iterativas baseadas em resultados."
                                  ],
                                  "verification": "Gerar relatório completo com cronograma otimizado e análise de sensibilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MS Project para Gantt, planilhas para simulações"
                                  ],
                                  "tips": "Priorize crashing em atividades com custo por dia baixo no caminho crítico.",
                                  "learningObjective": "Refinar cronogramas para robustez prática em engenharia civil.",
                                  "commonMistakes": [
                                    "Ignorar custos de crashing",
                                    "Não considerar riscos probabilísticos",
                                    "Sobre-otimizar ignorando viabilidade prática"
                                  ]
                                }
                              ],
                              "practicalExample": "Projeto de construção de uma ponte pequena: Atividades - A: Estudo de solo (5 dias), B: Projeto estrutural (10 dias, dep. A), C: Aquisição materiais (7 dias, dep. A), D: Fundação (15 dias, dep. B,C), E: Estrutura metálica (20 dias, dep. D), F: Asfalto e acabamento (8 dias, dep. E). Recursos: 2 equipes de fundação (máx 3/dia). Otimizar para minimizar de 45 para 38 dias usando LP com restrições de equipes.",
                              "finalVerifications": [
                                "Identificar corretamente o caminho crítico original e otimizado.",
                                "Formular e resolver modelo LP/IP válido com redução de duração.",
                                "Calcular folgas corretas para todas atividades.",
                                "Simular atraso de 2 dias em atividade crítica e ajustar.",
                                "Gerar Gantt chart com alocação de recursos.",
                                "Explicar trade-offs custo-tempo em relatório."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de ES/EF/LS/LF (erro <5%).",
                                "Correção do modelo de otimização (solução factível e ótima).",
                                "Profundidade na análise de recursos e sensibilidade.",
                                "Clareza no diagrama de rede e relatório final.",
                                "Criatividade em conexões com programação matemática.",
                                "Tempo de execução dentro do estimado com qualidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e Programação Linear/Inteira.",
                                "Gestão de Projetos: PMBOK e ferramentas como MS Project.",
                                "Informática: Programação em Python (PuLP) e simulações.",
                                "Economia: Análise custo-benefício e alocação de recursos escassos.",
                                "Engenharia de Produção: Controle de gargalos e lean construction."
                              ],
                              "realWorldApplication": "Em obras civis como construção de rodovias ou edifícios, onde atrasos custam milhões; otimiza alocação de guindastes/equipes limitadas, reduzindo prazos em 15-20% e evitando multas contratuais, como no caso do metrô de São Paulo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Aplicar programação dinâmica em sequenciamento de atividades",
                            "description": "Formular e resolver problemas de sequenciamento de tarefas em construções lineares (ex. pontes) usando programação dinâmica para minimizar atrasos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema de sequenciamento de atividades",
                                  "subSteps": [
                                    "Identificar as atividades específicas da construção linear, como preparação do terreno, fundação, montagem de pilares, colocação do deck e acabamentos.",
                                    "Determinar o tempo de processamento p_j para cada atividade com base em estimativas realistas de engenharia.",
                                    "Definir os prazos (deadlines) d_j para cada atividade, considerando cronogramas contratuais.",
                                    "Estabelecer dependências lineares mínimas (ex: fundação precede pilares) e modelar como grafo de precedências.",
                                    "Definir a função objetivo: minimizar a soma dos atrasos totais ∑ T_j, onde T_j = max(0, C_j - d_j) e C_j é o tempo de conclusão da tarefa j."
                                  ],
                                  "verification": "Lista completa de tarefas com p_j, d_j e dependências documentada; função objetivo explicitamente escrita.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Papel e lápis para diagrama de precedências",
                                    "Referências de cronogramas de projetos de pontes"
                                  ],
                                  "tips": [
                                    "Use tempos realistas baseados em projetos semelhantes.",
                                    "Visualize dependências como um fluxograma linear."
                                  ],
                                  "learningObjective": "Modelar problemas reais de planejamento de projetos em termos matemáticos acionáveis para otimização.",
                                  "commonMistakes": [
                                    "Omitir dependências críticas entre tarefas.",
                                    "Confundir tempo de processamento com tempo de conclusão.",
                                    "Definir prazos irrealistas sem contexto contratual."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir estados, recursão e condições da Programação Dinâmica",
                                  "subSteps": [
                                    "Definir o estado dp[S][t]: menor tardiness total para o subconjunto S de tarefas agendadas, terminando exatamente no tempo t (para n pequeno, |S| <= 5).",
                                    "Estabelecer recursão: dp[S ∪ {j}][t + p_j] = min(dp[S ∪ {j}][t + p_j], dp[S][t] + max(0, t + p_j - d_j)) para j ∉ S e respeitando precedências.",
                                    "Definir condições base: dp[∅][0] = 0; infinito caso contrário.",
                                    "Considerar discretização de tempo até T_max = sum p_j + max d_j.",
                                    "Incorporar precedências verificando se todas predecessoras de j estão em S."
                                  ],
                                  "verification": "Pseudocódigo da recursão escrito e validado com um caso trivial (1 tarefa).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Editor de código (Python/Jupyter)",
                                    "Notas de teoria de DP em otimização",
                                    "Calculadora para validação manual"
                                  ],
                                  "tips": [
                                    "Use bitmasks para representar S se n<=20.",
                                    "Teste recursão com subconjuntos pequenos primeiro."
                                  ],
                                  "learningObjective": "Construir uma recursão DP correta que capture o trade-off entre ordem de tarefas e atrasos.",
                                  "commonMistakes": [
                                    "Não tratar precedências, levando a sequências inválidas.",
                                    "Erro no cálculo de tardiness (usar C_j incorreto).",
                                    "Condições base mal definidas causando loops infinitos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a tabela DP bottom-up",
                                  "subSteps": [
                                    "Inicializar tabela dp[2^n][T_max+1] com infinito, exceto dp[0][0] = 0.",
                                    "Iterar sobre todos subconjuntos S em ordem crescente de tamanho.",
                                    "Para cada S e t válido, tentar adicionar cada j ∉ S válida por precedências, atualizando dp[S ∪ {j}][t + p_j].",
                                    "Otimizar com memoização se top-down for preferido.",
                                    "Implementar em código, usando arrays multidimensionais ou dicionário."
                                  ],
                                  "verification": "Tabela preenchida corretamente para um exemplo com 3 tarefas; valores finitos apenas para estados alcançáveis.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com NumPy para tabelas",
                                    "Jupyter Notebook para depuração passo a passo",
                                    "Exemplo de dados de teste"
                                  ],
                                  "tips": [
                                    "Use ordem de subconjuntos por tamanho para evitar dependências circulares.",
                                    "Imprima tabela intermediária para debug."
                                  ],
                                  "learningObjective": "Implementar DP bottom-up de forma eficiente e livre de erros para problemas combinatórios.",
                                  "commonMistakes": [
                                    "Atualização fora de ordem, usando valores não computados.",
                                    "Overflow em tempos grandes; use T_max razoável.",
                                    "Ignorar limites de array para bitmasks."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair solução ótima, backtrack e analisar",
                                  "subSteps": [
                                    "Encontrar o mínimo global: min over t dp[(1<<n)-1][t].",
                                    "Backtrack: partir do S completo e t ótimo, rastrear predecessores para reconstruir sequência.",
                                    "Calcular tempos de conclusão C_j, T_j e validar tardiness total.",
                                    "Analisar sensibilidade: variar um d_j e reexecutar.",
                                    "Documentar a sequência ótima e razões (ex: tarefas curtas com prazos apertados primeiro)."
                                  ],
                                  "verification": "Sequência reconstruída leva ao valor ótimo na tabela; todos T_j calculados corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python existente",
                                    "Gráfico Gantt para visualizar sequência"
                                  ],
                                  "tips": [
                                    "Armazene prev[S][t] durante preenchimento para backtrack fácil.",
                                    "Compare com heurística EDD (earliest deadline first)."
                                  ],
                                  "learningObjective": "Interpretar soluções DP e extrair insights práticos para engenharia.",
                                  "commonMistakes": [
                                    "Backtrack falha por não rastrear predecessores.",
                                    "Validação incorreta de dependências na sequência final."
                                  ]
                                }
                              ],
                              "practicalExample": "Para construção de uma ponte simples: Tarefas - Fundação (p=5 dias, d=10), Pilares (p=4, d=12), Deck (p=6, d=20), Pintura (p=2, d=22). Dependência: Fundação antes de Pilares e Deck. DP encontra ordem ótima: Fundação (C=5,T=0), Pintura (C=7,T=0), Pilares (C=11,T=0), Deck (C=17,T=0), total tardiness=0. Ordem ruim (ex: Deck primeiro) daria total=9 dias.",
                              "finalVerifications": [
                                "Formulação correta do problema para novo cenário de 4-5 tarefas.",
                                "Implementação DP roda sem erros e encontra ótimo para n=4.",
                                "Backtrack reconstrói sequência válida respeitando precedências.",
                                "Cálculo manual de tardiness coincide com DP para caso pequeno.",
                                "Análise sensibilidade identifica tarefas críticas.",
                                "Explicação verbal da ordem ótima em termos de engenharia."
                              ],
                              "assessmentCriteria": [
                                "Correção na modelagem e parâmetros do problema (20%)",
                                "Precisão da definição de estados e recursão DP (25%)",
                                "Implementação bottom-up funcional e eficiente (25%)",
                                "Backtrack e validação da solução ótima (15%)",
                                "Análise prática e sensibilidade (10%)",
                                "Clareza na documentação e código comentado (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Estruturas de dados para subconjuntos (bitmasks, memoização).",
                                "Gestão de Projetos: Integração com métodos CPM/PERT para planejamento híbrido.",
                                "Matemática Aplicada: Otimização combinatória e análise de complexidade.",
                                "Economia Empresarial: Modelagem de custos de atrasos e penalidades contratuais.",
                                "Engenharia de Software: Desenvolvimento de solvers customizados para otimização."
                              ],
                              "realWorldApplication": "Na construção de pontes e rodovias, essa técnica otimiza sequências de atividades para evitar atrasos caros, reduzindo penalidades contratuais (até 1% do valor/dia) e ociosidade de equipamentos. Ferramentas como Oracle Primavera ou MS Project usam conceitos semelhantes em módulos de otimização, aplicados em projetos como a Ponte Rio-Niterói."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Usar Monte Carlo em otimização estocástica de planejamento",
                            "description": "Combinar simulação Monte Carlo com otimização para avaliar riscos e otimizar buffers de tempo em cronogramas de projetos civis incertos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o Cronograma do Projeto com Incertezas Estocásticas",
                                  "subSteps": [
                                    "Identificar todas as tarefas principais, suas dependências e predecessoras usando um diagrama de rede (PERT/CPM).",
                                    "Atribuir distribuições de probabilidade realistas às durações das tarefas (ex: triangular para escavação com min=15, mode=20, max=30 dias; lognormal para cura de concreto).",
                                    "Definir parâmetros iniciais de buffers de tempo em pontos críticos do cronograma.",
                                    "Codificar o modelo em Python usando NetworkX para grafo de dependências e NumPy para distribuições.",
                                    "Validar o modelo determinístico base (sem incertezas) contra um cronograma conhecido."
                                  ],
                                  "verification": "Gerar e visualizar o diagrama de rede com durações médias e confirmar que o caminho crítico está correto.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python 3+, bibliotecas: networkx, numpy, matplotlib; dados históricos de projetos civis.",
                                  "tips": "Baseie distribuições em dados reais de projetos semelhantes para maior precisão.",
                                  "learningObjective": "Representar incertezas em cronogramas de projetos civis de forma probabilística.",
                                  "commonMistakes": "Ignorar dependências lógicas ou usar distribuições uniformes inadequadas para tarefas assimétricas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a Simulação Monte Carlo para Geração de Cenários",
                                  "subSteps": [
                                    "Configurar o número de iterações (ex: 10.000 simulações) para convergência estatística.",
                                    "Implementar função para amostrar durações de cada tarefa conforme suas distribuições.",
                                    "Simular o forward pass no grafo de rede para calcular datas de término por simulação.",
                                    "Registrar métricas chave: tempo total do projeto, uso de buffers e probabilidade de atraso.",
                                    "Visualizar resultados com histogramas e curvas de densidade de tempos de término."
                                  ],
                                  "verification": "Executar simulação e confirmar que a distribuição de tempos converge (teste de estabilidade variando seeds).",
                                  "estimatedTime": "6 horas",
                                  "materials": "Python 3+, bibliotecas: numpy, scipy.stats, matplotlib, networkx.",
                                  "tips": "Use paralelização com joblib para acelerar simulações grandes.",
                                  "learningObjective": "Executar simulações Monte Carlo para quantificar riscos em cronogramas incertos.",
                                  "commonMistakes": "Número insuficiente de iterações levando a variância alta; não tratar dependências corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Riscos e Quantificar Necessidades de Buffers",
                                  "subSteps": [
                                    "Calcular estatísticas da simulação: percentis (P50, P90, P95) do tempo total e identificadores de gargalos.",
                                    "Avaliar impacto de buffers atuais: % de simulações que excedem prazo desejado.",
                                    "Identificar tarefas de alto risco (alta variância ou contribuição ao caminho crítico).",
                                    "Gerar relatório de sensibilidade: varrer parâmetros para ver efeitos em riscos.",
                                    "Visualizar tornado plots para priorizar tarefas incertas."
                                  ],
                                  "verification": "Produzir tabela de percentis e gráfico de risco mostrando redução necessária em probabilidade de atraso.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python 3+, bibliotecas: pandas, matplotlib, seaborn.",
                                  "tips": "Foque em P90/P95 para projetos civis onde atrasos são caros.",
                                  "learningObjective": "Interpretar saídas de Monte Carlo para decisões baseadas em risco.",
                                  "commonMistakes": "Confundir média com mediana em distribuições assimétricas; ignorar correlações entre tarefas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e Resolver Otimização Estocástica Integrada",
                                  "subSteps": [
                                    "Definir modelo de otimização: minimizar custo total de buffers sujeito a restrições de chance (ex: P(término ≤ prazo) ≥ 95%).",
                                    "Usar resultados MC para aproximar distribuições e integrar em solver (ex: via cenários amostrados).",
                                    "Implementar em Python com PuLP ou SciPy.optimize para alocação ótima de buffers.",
                                    "Executar otimização e comparar com baseline (buffers fixos).",
                                    "Refinar modelo incorporando custos de buffers (ex: overhead de recursos)."
                                  ],
                                  "verification": "Solução ótima reduz buffers totais em pelo menos 10% enquanto mantém risco ≤5%.",
                                  "estimatedTime": "8 horas",
                                  "materials": "Python 3+, bibliotecas: pulp, scipy.optimize, numpy.",
                                  "tips": "Comece com otimização de dois estágios para simplicidade antes de estocástica completa.",
                                  "learningObjective": "Combinar Monte Carlo com programação matemática para otimização robusta.",
                                  "commonMistakes": "Violar restrições de chance por aproximação ruim de cenários; não penalizar buffers excessivos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar, Iterar e Documentar a Solução Otimizada",
                                  "subSteps": [
                                    "Reexecutar Monte Carlo na solução otimizada para verificar conformidade com restrições.",
                                    "Realizar análise de sensibilidade a mudanças em distribuições ou prazos.",
                                    "Documentar cronograma final com buffers, riscos residuais e recomendações.",
                                    "Testar em cenário realista alternativo para robustez.",
                                    "Preparar relatório executivo com visualizações chave."
                                  ],
                                  "verification": "Nova simulação confirma P95 ≤ prazo alvo e buffers viáveis.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python 3+, Jupyter Notebook para documentação.",
                                  "tips": "Automatize validação com asserts no código.",
                                  "learningObjective": "Garantir robustez e comunicabilidade de soluções estocásticas.",
                                  "commonMistakes": "Não validar pós-otimização; sobrecarregar relatório com dados brutos."
                                }
                              ],
                              "practicalExample": "Em um projeto de construção de uma ponte rodoviária de 500m, tarefas como fundações (triangular: 30-45-60 dias), montagem de vigas (lognormal: μ=20, σ=5 dias). Simule 10k cenários MC para estimar P95=180 dias. Otimize buffers em nós críticos para minimizar custo total mantendo risco de atraso <5%, resultando em +12 dias no caminho crítico vs. baseline guloso.",
                              "finalVerifications": [
                                "Simulação Monte Carlo converge com <1% variância em percentis chave.",
                                "Otimização satisfaz restrições de chance (ex: P95 ≤ prazo alvo).",
                                "Buffers otimizados são menores que heurística conservadora em 15-20%.",
                                "Análise de sensibilidade cobre ±20% em durações principais.",
                                "Relatório inclui visualizações claras e código reproduzível.",
                                "Solução roda em <5min para 10k iterações."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem de incertezas e dependências (30%).",
                                "Eficiência e estabilidade da simulação Monte Carlo (20%).",
                                "Correção matemática da formulação de otimização estocástica (25%).",
                                "Qualidade da análise de resultados e visualizações (15%).",
                                "Robustez via validação e sensibilidade (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística (distribuições, percentis).",
                                "Programação Computacional (Python, simulação numérica).",
                                "Gestão de Projetos (CPM/PERT, buffers de risco).",
                                "Engenharia de Produção (otimização robusta).",
                                "Análise de Dados (visualização, sensibilidade)."
                              ],
                              "realWorldApplication": "Em projetos civis como construção de barragens ou linhas de metrô (ex: obras da Odebrecht ou Metro de SP), onde incertezas climáticas/geotécnicas causam overruns de 20-50%, a integração MC-otimização otimiza buffers, reduzindo custos em milhões e aumentando confiança em prazos contratuais."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.4",
                            "name": "Implementar redes neurais para previsão em planejamento otimizado",
                            "description": "Treinar redes neurais artificiais para prever durações de atividades e integrar com otimizadores para planejamento adaptativo em obras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e Preparação de Dados Históricos de Atividades",
                                  "subSteps": [
                                    "Identifique fontes de dados históricos de projetos de obras civis, como planilhas de duração de atividades (fundação, estrutura, acabamento).",
                                    "Limpe os dados removendo outliers e valores ausentes, normalizando variáveis como tamanho da obra, tipo de solo e condições climáticas.",
                                    "Realize feature engineering: crie features como duração média por tipo de atividade, dependências e fatores de risco.",
                                    "Divida o dataset em treino (70%), validação (15%) e teste (15%).",
                                    "Salve os dados preparados em formato CSV ou HDF5 para uso eficiente."
                                  ],
                                  "verification": "Dataset preparado com pelo menos 1000 amostras, sem NaNs e com estatísticas descritivas validadas (média, desvio padrão).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python 3.8+, bibliotecas pandas, numpy, scikit-learn",
                                    "Dataset histórico de projetos civis (ex: Kaggle ou dados simulados)"
                                  ],
                                  "tips": "Use visualizações com matplotlib/seaborn para detectar anomalias antes da limpeza.",
                                  "learningObjective": "Dominar preparação de dados para previsão temporal em contextos de engenharia civil.",
                                  "commonMistakes": [
                                    "Ignorar multicolinearidade entre features",
                                    "Não balancear classes de atividades de risco alto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construção da Arquitetura da Rede Neural",
                                  "subSteps": [
                                    "Escolha o tipo de rede: LSTM ou GRU para sequências temporais de atividades.",
                                    "Defina camadas: input (features), 2-3 camadas ocultas (64-128 neurônios), output (duração prevista).",
                                    "Configure funções: ativação ReLU/tanh, loss MSE, otimizador Adam.",
                                    "Implemente dropout (0.2-0.3) e batch normalization para regularização.",
                                    "Compile o modelo com callbacks para logging."
                                  ],
                                  "verification": "Modelo compilado sem erros e summary exibido confirmando arquitetura (ex: model.summary()).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "TensorFlow/Keras 2.10+, Jupyter Notebook",
                                    "Documentação Keras para RNNs"
                                  ],
                                  "tips": "Comece com arquitetura simples e adicione complexidade iterativamente.",
                                  "learningObjective": "Construir redes neurais adequadas para previsão de durações sequenciais.",
                                  "commonMistakes": [
                                    "Overfitting por falta de dropout",
                                    "Escolha errada de loss para regressão (usar categorical em vez de MSE)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Treinamento e Otimização do Modelo de Previsão",
                                  "subSteps": [
                                    "Treine o modelo por 50-100 épocas com early stopping baseado em validação.",
                                    "Ajuste hiperparâmetros usando GridSearch ou Keras Tuner (learning rate, batch size).",
                                    "Avalie métricas: MAE, RMSE, R² no conjunto de teste.",
                                    "Salve o melhor modelo e gere previsões para validação cruzada.",
                                    "Visualize curvas de perda e previsões vs reais."
                                  ],
                                  "verification": "MAE < 5% do valor médio de duração no teste; curvas de perda convergentes.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "GPU recomendada (Colab ou local)",
                                    "Keras Tuner para hyperparameter tuning"
                                  ],
                                  "tips": "Monitore GPU usage para evitar timeouts em treinamentos longos.",
                                  "learningObjective": "Treinar e otimizar redes para precisão em previsões de engenharia.",
                                  "commonMistakes": [
                                    "Treinar sem validação, levando a overfitting",
                                    "Ignorar scaling de targets (use MinMaxScaler)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração com Otimizador de Planejamento e Validação",
                                  "subSteps": [
                                    "Gere previsões de duração para um grafo de atividades (PERT/CPM).",
                                    "Integre previsões como restrições em um otimizador (ex: PuLP para LP ou DEAP para algorítmico genético).",
                                    "Otimize o cronograma total minimizando tempo ou custo com durações previstas.",
                                    "Simule cenários adaptativos (ex: atrasos em atividades críticas).",
                                    "Compare plano otimizado com baseline (médias históricas)."
                                  ],
                                  "verification": "Planejamento otimizado executado com redução de pelo menos 10% no tempo total; logs de otimização sem erros.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Bibliotecas PuLP/OR-Tools para otimização, NetworkX para grafos de projetos"
                                  ],
                                  "tips": "Use funções wrapper para previsões da NN dentro do modelo de otimização.",
                                  "learningObjective": "Integrar ML com programação matemática para planejamento adaptativo.",
                                  "commonMistakes": [
                                    "Não tratar incertezas nas previsões (adicione intervalos de confiança)",
                                    "Grafos de atividades com ciclos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliação Final e Refinamento do Sistema",
                                  "subSteps": [
                                    "Teste end-to-end em dataset de obra real simulada.",
                                    "Calcule KPIs: acurácia de previsão, eficiência do plano, robustez a variações.",
                                    "Refine modelo com feedback loop (re-treine com novos dados).",
                                    "Documente pipeline completo em script Python reproduzível.",
                                    "Prepare deployment (ex: Flask API para previsões)."
                                  ],
                                  "verification": "Sistema end-to-end gera plano otimizado validado em 3 cenários diferentes.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Streamlit ou Flask para demo",
                                    "Relatório em Jupyter"
                                  ],
                                  "tips": "Automatize com funções modulares para reutilização em outros projetos.",
                                  "learningObjective": "Validar e iterar sistemas híbridos ML-otimização.",
                                  "commonMistakes": [
                                    "Focar só em precisão, ignorar latência computacional",
                                    "Não versionar modelos com MLflow"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de construção de ponte rodoviária, treine uma LSTM com dados de 200 obras passadas para prever duração de pilares (baseado em altura, rio, clima). Integre previsões em um modelo PuLP que otimiza o cronograma total, reduzindo de 18 para 15 meses ao priorizar atividades paralelas.",
                              "finalVerifications": [
                                "Modelo prevê durações com MAE < 3 dias em atividades de 30 dias médios.",
                                "Integração gera cronograma otimizado 12-20% mais eficiente que baselines.",
                                "Sistema roda em < 5 minutos para projetos com 100 atividades.",
                                "Robustez testada: variações de 20% em inputs alteram plano < 10%.",
                                "Código reproduzível e documentado passa em linting e testes unitários.",
                                "Visualizações mostram previsões alinhadas com reais em scatter plot."
                              ],
                              "assessmentCriteria": [
                                "Precisão das previsões (MAE/RMSE abaixo de thresholds).",
                                "Eficiência do otimizador (redução mensurável em tempo/custo).",
                                "Qualidade do código (modular, comentado, versionado).",
                                "Tratamento de edge cases (projetos grandes, dados escassos).",
                                "Interpretação de resultados (análise de importância de features).",
                                "Escalabilidade para projetos reais (tempo de execução)."
                              ],
                              "crossCurricularConnections": [
                                "Machine Learning: Redes recorrentes para séries temporais.",
                                "Estatística: Validação cruzada e métricas de regressão.",
                                "Programação Matemática: Modelos de otimização linear/inteira.",
                                "Gerenciamento de Projetos: Técnicas PERT/CPM adaptativas.",
                                "Engenharia de Software: Pipelines MLops para deployment."
                              ],
                              "realWorldApplication": "Em construtoras como Odebrecht ou construtoras de infraestrutura, integra-se a ferramentas como MS Project ou Primavera para bidding preciso, reduzindo overruns em 15-25% e melhorando competitividade em licitações públicas."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Solução de Equações Não-Lineares e Ajuste de Curvas",
                "description": "Métodos numéricos para resolver equações não-lineares e ajustar curvas a conjuntos de dados.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Método da Bisseção",
                    "description": "Algoritmo iterativo para encontrar raízes de equações não-lineares em intervalos onde a função muda de sinal.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Princípios Fundamentais do Método da Bisseção",
                        "description": "Fundamentos teóricos do método, baseados no Teorema do Valor Intermediário, que garante a existência de pelo menos uma raiz em um intervalo [a, b] onde a função contínua f muda de sinal, ou seja, f(a) * f(b) < 0.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Compreender o Teorema do Valor Intermediário",
                            "description": "Explicar o teorema que afirma que se f é contínua em [a, b] e f(a) e f(b) têm sinais opostos, existe pelo menos um c em (a, b) tal que f(c) = 0, justificando a aplicação do método da bisseção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o conceito de função contínua",
                                  "subSteps": [
                                    "Defina continuidade em um ponto e em um intervalo.",
                                    "Identifique exemplos de funções contínuas (polinômios, seno) e descontínuas (função degrau).",
                                    "Verifique continuidade em [a, b] usando limites e valores da função.",
                                    "Pratique graficando funções contínuas em intervalos fechados.",
                                    "Discuta por que a continuidade é essencial para o teorema."
                                  ],
                                  "verification": "Liste 3 funções contínuas e 2 descontínuas em [a,b], justificando cada uma.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora gráfica",
                                    "Software GeoGebra ou Desmos"
                                  ],
                                  "tips": "Lembre-se: contínua significa 'sem saltos ou buracos' no gráfico.",
                                  "learningObjective": "Dominar a definição e verificação de continuidade em intervalos fechados.",
                                  "commonMistakes": [
                                    "Confundir continuidade com derivabilidade",
                                    "Ignorar pontos isolados de descontinuidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar as condições iniciais do teorema",
                                  "subSteps": [
                                    "Explique o intervalo fechado [a, b] e por que é importante.",
                                    "Verifique f(a) e f(b) com sinais opostos: f(a) * f(b) < 0.",
                                    "Calcule f(a) e f(b) para funções dadas e confirme a condição.",
                                    "Discuta o que acontece se f(a) e f(b) tiverem o mesmo sinal.",
                                    "Pratique com 3 exemplos numéricos simples."
                                  ],
                                  "verification": "Para uma função dada, confirme se f(a)*f(b)<0 e identifique o sinal de cada.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Folha de exercícios",
                                    "Calculadora"
                                  ],
                                  "tips": "Use o produto f(a)*f(b) para testar sinais opostos rapidamente.",
                                  "learningObjective": "Identificar corretamente as hipóteses do teorema.",
                                  "commonMistakes": [
                                    "Assumir sinais opostos sem calcular",
                                    "Usar [a,b) em vez de [a,b]"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Enunciar e interpretar o Teorema do Valor Intermediário",
                                  "subSteps": [
                                    "Enuncie precisamente: Se f contínua em [a,b] e f(a)*f(b)<0, existe c em (a,b) tal que f(c)=0.",
                                    "Interprete geometricamente: a curva cruza o eixo x.",
                                    "Discuta unicidade: pelo menos um c, pode haver mais.",
                                    "Compare com Teorema do Valor Médio.",
                                    "Escreva o teorema em suas próprias palavras."
                                  ],
                                  "verification": "Escreva o enunciado completo e explique intuitivamente com um desenho.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel para diagramas",
                                    "Livro-texto de cálculo"
                                  ],
                                  "tips": "Pense na função como uma 'montanha-russa' que deve cruzar o zero.",
                                  "learningObjective": "Enunciar e compreender a garantia de existência de raiz.",
                                  "commonMistakes": [
                                    "Omitir 'contínua' ou 'sinais opostos'",
                                    "Confundir com existência única"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conectar o teorema ao método da bisseção",
                                  "subSteps": [
                                    "Explique como IVT justifica o primeiro passo da bisseção: raiz no intervalo.",
                                    "Simule um passo: escolha midpoint m, verifique sinais em [a,m] ou [m,b].",
                                    "Aplique IVT recursivamente para convergência.",
                                    "Resolva um exemplo numérico com 3 iterações.",
                                    "Discuta limitações e garantias de convergência."
                                  ],
                                  "verification": "Aplique bisseção em um exemplo e justifique cada intervalo com IVT.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para simulação",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre verifique f(a)*f(m)<0 ou f(m)*f(b)<0 após bisseção.",
                                  "learningObjective": "Justificar o método da bisseção usando IVT.",
                                  "commonMistakes": [
                                    "Não verificar continuidade no subintervalo",
                                    "Parar sem precisão desejada"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere f(x) = x³ - x - 2 em [1, 2]. f(1) = -2 < 0, f(2) = 4 > 0, f contínua (polinômio). Pelo IVT, existe c em (1,2) com f(c)=0. Bisseção: m=1.5, f(1.5)≈ -0.875 <0, raiz em [1.5,2].",
                              "finalVerifications": [
                                "Enuncie o IVT corretamente sem erros.",
                                "Identifique hipóteses faltantes em cenários dados.",
                                "Aplique IVT para justificar bisseção em um exemplo novo.",
                                "Diferencie IVT de teoremas similares.",
                                "Explique intuitivamente por que o teorema é verdadeiro.",
                                "Resolva um problema completo de bisseção com justificativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado do teorema (100%).",
                                "Correta identificação de continuidade e sinais opostos (90%).",
                                "Justificativa clara da bisseção via IVT (85%).",
                                "Uso de exemplos concretos e gráficos (80%).",
                                "Compreensão de limitações e contraexemplos (75%).",
                                "Conexão com aplicações computacionais (70%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar bisseção em Python para raízes numéricas.",
                                "Física: Encontrar pontos de equilíbrio em estruturas civis (ex: deformação zero).",
                                "Geometria Computacional: Verificar interseções em modelagem 3D.",
                                "Estatística: Intervalos de confiança para raízes em regressão não-linear."
                              ],
                              "realWorldApplication": "Em engenharia civil, o IVT justifica métodos numéricos como bisseção para resolver equações não-lineares em análise estrutural, como encontrar cargas críticas onde o deslocamento é zero em vigas ou encontrar alturas de reservatórios onde a pressão hidrostática equilibra forças."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Identificar intervalos bracket",
                            "description": "Dado uma equação não-linear f(x) = 0, localizar um intervalo inicial [a, b] onde f(a) * f(b) < 0, verificando a mudança de sinal por avaliação direta da função.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de intervalo bracket e o Teorema do Valor Intermediário",
                                  "subSteps": [
                                    "Estude o Teorema do Valor Intermediário: se f é contínua em [a, b] e f(a) e f(b) têm sinais opostos, existe c em (a, b) tal que f(c) = 0.",
                                    "Identifique que f(a) * f(b) < 0 garante mudança de sinal.",
                                    "Revise propriedades da função f(x): domínio, continuidade e comportamento assintótico.",
                                    "Analise gráficos ou tabelas da função para prever regiões de raízes.",
                                    "Pratique com funções simples como f(x) = x^2 - 2 para visualizar mudanças de sinal."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o teorema e dê um exemplo onde f(a)*f(b) < 0 indica uma raiz.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de análise numérica",
                                    "Gráficos da função f(x)",
                                    "Calculadora gráfica ou software como Desmos"
                                  ],
                                  "tips": "Sempre confirme continuidade da função no intervalo escolhido.",
                                  "learningObjective": "Entender a base teórica para garantir existência de raízes por mudança de sinal.",
                                  "commonMistakes": [
                                    "Ignorar continuidade da função",
                                    "Confundir mudança de sinal com f(a) + f(b) < 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar valores iniciais candidatos para a e b",
                                  "subSteps": [
                                    "Escolha a baseado em limite inferior estimado da raiz (ex: de gráficos ou conhecimento físico).",
                                    "Escolha b > a baseado em limite superior estimado.",
                                    "Priorize intervalos pequenos iniciais para eficiência computacional.",
                                    "Use conhecimento do problema de engenharia para guiar escolhas (ex: valores físicos realistas).",
                                    "Teste múltiplos pares iniciais se necessário."
                                  ],
                                  "verification": "Liste 3 pares [a, b] candidatos com justificativa para cada um.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráfico da função",
                                    "Papel e lápis para esboços",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)"
                                  ],
                                  "tips": "Comece com intervalos amplos e refine visualmente.",
                                  "learningObjective": "Selecionar intervalos iniciais informados pelo comportamento da função.",
                                  "commonMistakes": [
                                    "Escolher a e b muito próximos sem mudança de sinal",
                                    "Ignorar limites físicos do problema"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar f(a) e f(b) diretamente",
                                  "subSteps": [
                                    "Calcule f(a) com precisão usando calculadora ou software.",
                                    "Calcule f(b) da mesma forma.",
                                    "Registre os valores exatos ou com precisão decimal adequada (ex: 4 casas).",
                                    "Verifique se há erros de cálculo cruzando com gráfico.",
                                    "Anote sinais de f(a) e f(b)."
                                  ],
                                  "verification": "Mostre cálculos de f(a) e f(b) com valores numéricos corretos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software computacional (Python/Excel)",
                                    "Função f(x) definida"
                                  ],
                                  "tips": "Use expressões simbólicas se possível para evitar erros numéricos.",
                                  "learningObjective": "Executar avaliações precisas da função nos extremos do intervalo.",
                                  "commonMistakes": [
                                    "Erros aritméticos em cálculos",
                                    "Arredondamento prematuro afetando sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a condição de bracket e ajustar se necessário",
                                  "subSteps": [
                                    "Compute o produto f(a) * f(b).",
                                    "Confirme se < 0 (mudança de sinal).",
                                    "Se não, expanda ou mova o intervalo (ex: teste [a-Δ, b] ou [a, b+Δ]).",
                                    "Repita avaliações até satisfazer a condição.",
                                    "Documente todos os intervalos testados."
                                  ],
                                  "verification": "Apresente o intervalo final [a, b] com f(a)*f(b) < 0 comprovado numericamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha de cálculos",
                                    "Software para iterações rápidas"
                                  ],
                                  "tips": "Automatize com loop simples em Python para testes múltiplos.",
                                  "learningObjective": "Confirmar e refinar o bracket até atender a condição essencial.",
                                  "commonMistakes": [
                                    "Parar em intervalo sem mudança de sinal",
                                    "Escolher intervalos muito largos desnecessariamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x^3 - 2x - 5 = 0 (equação de deformação em vigas civis), teste [1, 2]: f(1) = -6 < 0, f(2) = -1 < 0 (sem bracket). Ajuste para [2, 3]: f(2) = -1 < 0, f(3) = 16 > 0, f(2)*f(3) = -16 < 0 (bracket válido).",
                              "finalVerifications": [
                                "Intervalo [a, b] com a < b e f contínua.",
                                "f(a) e f(b) calculados corretamente.",
                                "f(a) * f(b) < 0 comprovado.",
                                "Justificativa para escolha inicial e ajustes.",
                                "Gráfico ou tabela confirmando mudança de sinal.",
                                "Sem raízes múltiplas óbvias no intervalo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de f(a) e f(b) (erro < 0.01).",
                                "Eficiência na seleção e ajuste do intervalo (≤ 3 tentativas).",
                                "Compreensão teórica demonstrada na explicação.",
                                "Uso adequado de ferramentas computacionais.",
                                "Documentação clara de passos e justificativas.",
                                "Identificação correta de bracket sem falsos positivos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica e Teorema do Valor Intermediário.",
                                "Programação: Implementação em Python/MATLAB para avaliações automáticas.",
                                "Física/Engenharia: Modelagem de equações de equilíbrio estrutural.",
                                "Estatística: Análise de sensibilidade a erros numéricos."
                              ],
                              "realWorldApplication": "Em engenharia civil, identificar brackets para equações não-lineares em análise de estruturas (ex: calcular ponto de colapso de vigas via f(x) = carga - resistência(x) = 0), garantindo soluções numéricas confiáveis no método da bisseção para projetos seguros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Verificar condições de continuidade e mudança de sinal",
                            "description": "Analisar se a função é contínua no intervalo proposto e confirmar f(a) * f(b) < 0, identificando possíveis múltiplas raízes ou inadequações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a continuidade da função no intervalo [a, b]",
                                  "subSteps": [
                                    "Identifique o tipo de função (ex: polinômio, racional, trigonométrica) e seus domínios naturais.",
                                    "Liste possíveis pontos de descontinuidade dentro de [a, b], como divisões por zero ou limites indefinidos.",
                                    "Verifique se a função é definida e contínua em todos os pontos de [a, b], usando limites laterais se necessário.",
                                    "Confirme continuidade em a e b separadamente, calculando lim x->a f(x) = f(a) e lim x->b f(x) = f(b).",
                                    "Documente a justificativa: 'Polinômio é contínuo em todo R' ou 'Verificar polos'.",
                                    "Se houver descontinuidade, declare inadequação para o método da bisseção."
                                  ],
                                  "verification": "A função é declarada contínua em [a, b] com justificativa explícita e sem pontos de descontinuidade identificados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Função f(x) e intervalo [a, b]",
                                    "Calculadora gráfica ou software como MATLAB/GeoGebra",
                                    "Papel e lápis para esboço"
                                  ],
                                  "tips": "Lembre-se: funções elementares são contínuas onde definidas; foque em exceções como logaritmos ou racionais.",
                                  "learningObjective": "Compreender e aplicar o conceito de continuidade em intervalos fechados para validar pré-condições numéricas.",
                                  "commonMistakes": [
                                    "Ignorar descontinuidades assintóticas",
                                    "Confundir domínio com continuidade",
                                    "Não verificar endpoints separadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os valores da função nos extremos f(a) e f(b)",
                                  "subSteps": [
                                    "Substitua x = a na função f(x) e compute f(a) com precisão numérica.",
                                    "Substitua x = b na função f(x) e compute f(b) com precisão numérica.",
                                    "Registre os valores exatos ou aproximados (mínimo 4 casas decimais).",
                                    "Esboce um gráfico aproximado da função em [a, b] para visualizar sinais.",
                                    "Verifique cálculos com ferramenta computacional para confirmação."
                                  ],
                                  "verification": "Valores f(a) e f(b) calculados corretamente e registrados com precisão, confirmados por gráfico ou software.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora ou software (MATLAB, Python)",
                                    "Função f(x) e valores a, b"
                                  ],
                                  "tips": "Use parênteses corretos em expressões compostas para evitar erros aritméticos.",
                                  "learningObjective": "Executar avaliações precisas de funções em pontos específicos para análise de sinal.",
                                  "commonMistakes": [
                                    "Erros de cálculo algébrico simples",
                                    "Arredondamento prematuro",
                                    "Confundir f(a) com f(b)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a mudança de sinal: f(a) * f(b) < 0",
                                  "subSteps": [
                                    "Multiplique f(a) por f(b) e compare o resultado com zero.",
                                    "Confirme que os sinais de f(a) e f(b) são opostos (um positivo, outro negativo).",
                                    "Se f(a) * f(b) >= 0, identifique a inadequação (sem mudança de sinal).",
                                    "Registre a conclusão: 'Condição satisfeita' ou 'Não satisfeita devido a [razão]'.",
                                    "Discuta implicações: teorema do valor intermediário garante pelo menos uma raiz se ambas condições ok."
                                  ],
                                  "verification": "Produto f(a)*f(b) calculado corretamente e condição de mudança de sinal explicitamente confirmada ou refutada.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Valores f(a) e f(b) do step anterior",
                                    "Calculadora"
                                  ],
                                  "tips": "Sinais opostos implicam produto negativo; zero indica possível raiz em endpoint (reavalie intervalo).",
                                  "learningObjective": "Aplicar critério de mudança de sinal como pré-condição para métodos de isolamento de raízes.",
                                  "commonMistakes": [
                                    "Interpretar f(a)*f(b)=0 como mudança de sinal",
                                    "Ignorar zeros em endpoints",
                                    "Erro no sinal do produto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar múltiplas raízes ou inadequações potenciais",
                                  "subSteps": [
                                    "Analise o gráfico ou derivada para múltiplas curvas em [a, b] (possíveis raízes pares cancelando mudança de sinal).",
                                    "Verifique se f(a)=0 ou f(b)=0 (raiz já encontrada, método desnecessário).",
                                    "Teste pontos intermediários se suspeita de múltiplas raízes (ex: f((a+b)/2)).",
                                    "Recomende ajustes: novo intervalo se condições falharem.",
                                    "Conclua com declaração final de aplicabilidade do método da bisseção.",
                                    "Documente riscos: 'Garante pelo menos uma raiz, mas pode haver mais'."
                                  ],
                                  "verification": "Possíveis inadequações (múltiplas raízes, zeros em bordas) identificadas e recomendadas ações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráfico da função",
                                    "Software para derivadas ou pontos intermediários"
                                  ],
                                  "tips": "Para polinômios ímpares ou funções estritamente crescentes, risco baixo de múltiplas raízes.",
                                  "learningObjective": "Reconhecer limitações do teorema de Bolzano e cenários de múltiplas raízes em métodos numéricos.",
                                  "commonMistakes": [
                                    "Assumir unicidade de raiz sem análise",
                                    "Não testar midpoint para múltiplas",
                                    "Ignorar f(a)=0 como raiz trivial"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x^3 - 2x - 5 em [2, 3]: 1) Contínua (polinômio). 2) f(2) ≈ -3 <0, f(3)=16>0. 3) Produto ≈ -48 <0. 4) Derivada f'(x)=3x^2-2 tem mínimo local, mas mudança de sinal confirma pelo menos uma raiz real.",
                              "finalVerifications": [
                                "Continuidade confirmada com justificativa no intervalo [a,b].",
                                "f(a) e f(b) calculados corretamente com sinais opostos.",
                                "Produto f(a)*f(b) < 0 explicitamente verificado.",
                                "Possíveis múltiplas raízes ou inadequações discutidas.",
                                "Conclusão clara sobre aplicabilidade do método da bisseção.",
                                "Gráfico ou testes intermediários suportam análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção nos cálculos de f(a), f(b) e produto (100% exato).",
                                "Justificativa conceitual sólida para continuidade (domínio + exceções).",
                                "Identificação correta de mudança de sinal e implicações do teorema.",
                                "Análise profunda de inadequações/múltiplas raízes com evidências.",
                                "Clareza e estrutura na documentação (passos lógicos).",
                                "Uso adequado de ferramentas computacionais para verificação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Pura: Teorema do Valor Intermediário e propriedades de funções contínuas.",
                                "Programação: Implementar funções de verificação em Python/MATLAB para automação.",
                                "Física/Engenharia: Aplicar em equações de equilíbrio estático onde forças mudam sinal.",
                                "Estatística: Análise de intervalos de confiança em roots de funções de regressão."
                              ],
                              "realWorldApplication": "Em engenharia civil, verifica-se continuidade e mudança de sinal em equações não-lineares para cargas em vigas ou pilares (ex: f(x)=0 onde x é deformação, garantindo isolamento de pontos de falha antes de iterações numéricas no método da bisseção)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Algoritmo Iterativo do Método da Bisseção",
                        "description": "Descrição passo a passo do algoritmo iterativo que bisecta repetidamente o intervalo [a, b] até satisfazer um critério de parada, como tolerância no erro ou número máximo de iterações.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Calcular o ponto médio e atualizar o intervalo",
                            "description": "Em cada iteração, computar c = (a + b)/2, avaliar f(c) e substituir o intervalo: se f(a)*f(c) < 0 então b = c, senão a = c, reduzindo o comprimento pela metade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular o ponto médio c entre os limites atuais a e b",
                                  "subSteps": [
                                    "Identifique os valores atuais dos limites inferior a e superior b do intervalo.",
                                    "Some os valores: soma = a + b.",
                                    "Divida a soma por 2: c = soma / 2.",
                                    "Registre o valor de c com precisão adequada (ex: 4 casas decimais).",
                                    "Verifique se c está estritamente entre a e b."
                                  ],
                                  "verification": "Confirme que c = (a + b)/2 calculado manualmente ou com calculadora corresponde exatamente ao esperado.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Calculadora ou software de cálculo",
                                    "Papel e lápis para anotações",
                                    "Definição da função f e intervalo inicial"
                                  ],
                                  "tips": "Use aritmética de ponto flutuante com precisão consistente para evitar erros de arredondamento.",
                                  "learningObjective": "Dominar o cálculo preciso do ponto médio como base para iterações numéricas.",
                                  "commonMistakes": [
                                    "Arredondar prematuramente",
                                    "Confundir a com b",
                                    "Usar média geométrica em vez de aritmética"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar a função f no ponto médio c",
                                  "subSteps": [
                                    "Substitua x = c na função f(x).",
                                    "Calcule f(c) passo a passo, respeitando a ordem de operações.",
                                    "Registre o sinal de f(c) (positivo, negativo ou zero).",
                                    "Compare o sinal de f(c) com os sinais conhecidos de f(a) e f(b).",
                                    "Anote f(c) com a mesma precisão usada para a e b."
                                  ],
                                  "verification": "Calcule f(c) independentemente e confirme se o resultado bate com uma segunda avaliação.",
                                  "estimatedTime": "7 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou simbólica",
                                    "Gráfico da função f para visualização",
                                    "Folha de rascunho"
                                  ],
                                  "tips": "Se f for complexa, quebre em termos intermediários para facilitar depuração.",
                                  "learningObjective": "Aplicar avaliação funcional precisa em pontos intermediários para análise de sinais.",
                                  "commonMistakes": [
                                    "Erro de substituição em polinômios",
                                    "Ignorar o sinal de f(c)",
                                    "Confundir f(c) com c"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atualizar o intervalo baseado no teste de sinal f(a)*f(c) < 0",
                                  "subSteps": [
                                    "Calcule o produto p = f(a) * f(c).",
                                    "Verifique a condição: se p < 0, defina novo b = c (raiz no [a, c]).",
                                    "Senão (p >= 0), defina novo a = c (raiz no [c, b]).",
                                    "Calcule o novo comprimento do intervalo: |b - a|_novo.",
                                    "Confirme que o novo comprimento é aproximadamente metade do anterior."
                                  ],
                                  "verification": "Simule a iteração completa e verifique se a raiz está preservada no novo intervalo (mudança de sinal mantida).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de iterações em planilha",
                                    "Software como Python ou MATLAB para validação",
                                    "Critério de parada definido"
                                  ],
                                  "tips": "Sempre verifique sinais antes de atualizar para garantir convergência.",
                                  "learningObjective": "Implementar logicamente a bisseção para reduzir o intervalo garantindo isolamento da raiz.",
                                  "commonMistakes": [
                                    "Inverter a condição if",
                                    "Não atualizar corretamente a ou b",
                                    "Esquecer de halved o comprimento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a redução do intervalo e preparar próxima iteração",
                                  "subSteps": [
                                    "Meça comprimento antigo: len_antiga = b - a.",
                                    "Meça novo: len_nova = novo_b - novo_a.",
                                    "Confirme len_nova ≈ len_antiga / 2 (erro < 1%).",
                                    "Registre o novo [a, b] e conte a iteração.",
                                    "Decida se continua (ex: len > tolerância)."
                                  ],
                                  "verification": "Compare comprimentos antes/depois e valide que a função muda sinal nos novos limites.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Planilha para tracking de iterações",
                                    "Critérios de convergência documentados"
                                  ],
                                  "tips": "Monitore numericamente para detectar estagnação precoce.",
                                  "learningObjective": "Garantir propriedades de convergência do método da bisseção em cada passo.",
                                  "commonMistakes": [
                                    "Não halved devido a erro de precisão",
                                    "Perder track dos limites",
                                    "Parar iteração cedo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x^2 - 2 (raiz ≈1.414) em [1, 2]: c=(1+2)/2=1.5, f(1.5)=0.25>0, f(1)=-1<0, f(1)*f(1.5)<0 então b=1.5. Novo [1,1.5], comprimento de 1 para 0.5.",
                              "finalVerifications": [
                                "Ponto médio c calculado como (a+b)/2 com precisão.",
                                "f(c) avaliado corretamente com sinal identificado.",
                                "Condição f(a)*f(c)<0 aplicada para atualizar intervalo.",
                                "Novo intervalo halved e preserva mudança de sinal.",
                                "Sem erros numéricos propagados.",
                                "Preparado para próxima iteração."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de c e f(c) (erro < 10^-4).",
                                "Correta implementação da lógica condicional de bisseção.",
                                "Redução consistente do comprimento do intervalo pela metade.",
                                "Manutenção da propriedade de mudança de sinal nos limites.",
                                "Documentação clara de valores em cada iteração.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica e teorema do valor intermediário.",
                                "Programação: Implementação em loops while para automação.",
                                "Física/Engenharia: Solução de equações em modelagem estrutural.",
                                "Estatística: Controle de erro e convergência em métodos iterativos."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para encontrar cargas críticas em vigas onde equações não-lineares como equilíbrio de momentos surgem, permitindo iterações rápidas para dimensionamento seguro de estruturas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Definir critérios de parada",
                            "description": "Estabelecer condições de convergência como |b - a| < ε (tolerância espacial), |f(c)| < ε (tolerância funcional) ou número máximo de iterações N_max para evitar loops infinitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os tipos de critérios de parada no Método da Bisseção",
                                  "subSteps": [
                                    "Estude a tolerância espacial: |b - a| < ε, que verifica se o intervalo de incerteza é suficientemente pequeno.",
                                    "Analise a tolerância funcional: |f(c)| < ε, que garante que o valor da função no ponto médio é próximo de zero.",
                                    "Revise o critério de número máximo de iterações: N ≤ N_max, para prevenir loops infinitos em casos de convergência lenta.",
                                    "Compare vantagens e desvantagens de cada critério em contextos numéricos.",
                                    "Identifique quando combinar critérios para robustez."
                                  ],
                                  "verification": "Liste e explique os três critérios principais com fórmulas corretas em um resumo escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de métodos numéricos, notas de aula, calculadora científica.",
                                  "tips": "Use diagramas de fluxo para visualizar como cada critério interrompe o loop iterativo.",
                                  "learningObjective": "Identificar e diferenciar os critérios de parada comuns no Método da Bisseção.",
                                  "commonMistakes": "Confundir tolerância espacial com funcional; ignorar que ε deve ser adaptado à precisão desejada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o problema para selecionar critérios adequados",
                                  "subSteps": [
                                    "Examine a função f(x) e o intervalo inicial [a, b] para avaliar a sensibilidade e comportamento esperado.",
                                    "Determine a precisão requerida baseada no contexto de engenharia civil (ex.: precisão de 10^-6 para cargas estruturais).",
                                    "Avalie riscos de não-convergência ou oscilação para escolher entre critérios espaciais, funcionais ou híbridos.",
                                    "Considere o custo computacional: prefira critérios que evitem iterações excessivas.",
                                    "Documente a justificativa da escolha em um relatório curto."
                                  ],
                                  "verification": "Crie uma tabela comparando critérios viáveis para o problema específico, justificando a seleção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráfica da função f(x) (software como Desmos ou MATLAB), papel para esboços.",
                                  "tips": "Teste preliminarmente f(a) e f(b) para confirmar mudança de sinal e viabilidade.",
                                  "learningObjective": "Selecionar critérios de parada alinhados às características do problema de engenharia.",
                                  "commonMistakes": "Escolher ε muito pequeno levando a iterações desnecessárias; ignorar o contexto físico do problema."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir valores numéricos para ε e N_max",
                                  "subSteps": [
                                    "Selecione ε baseado na precisão de máquina (ex.: 1e-10) e requisitos da aplicação (ex.: 1e-6 para engenharia).",
                                    "Defina N_max como log2((b-a)/ε) + margem de segurança (ex.: 100 iterações).",
                                    "Valide ε com testes de sensibilidade em funções semelhantes.",
                                    "Escreva os critérios em pseudocódigo: if |b-a| < ε or |f(c)| < ε or n > N_max then stop.",
                                    "Ajuste valores iterativamente com base em simulações rápidas."
                                  ],
                                  "verification": "Apresente valores finais de ε e N_max com justificativa matemática e numérica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora ou Python/Jupyter para cálculos rápidos, tabela de precisões padrão.",
                                  "tips": "Use ε relativo para funções com grande escala: ε * max(|a|,|b|,|f(c)|) < 1.",
                                  "learningObjective": "Estabelecer parâmetros quantitativos precisos e justificáveis para os critérios.",
                                  "commonMistakes": "Definir N_max muito baixo causando parada prematura; usar ε fixo sem considerar escala da função."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar critérios ao algoritmo e verificar implementação",
                                  "subSteps": [
                                    "Inclua os critérios no loop while do pseudocódigo do Método da Bisseção.",
                                    "Implemente em código (Python/MATLAB) com saídas de log para rastrear iterações e critérios ativados.",
                                    "Execute testes com funções conhecidas para confirmar parada correta.",
                                    "Analise logs para identificar qual critério foi acionado e por quê.",
                                    "Refine critérios com base nos resultados dos testes."
                                  ],
                                  "verification": "Execute o código e demonstre que o algoritmo para corretamente em pelo menos dois cenários.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ambiente de programação (Python com NumPy, MATLAB), funções de teste pré-definidas.",
                                  "tips": "Adicione prints condicionais para depuração: 'Parada por tolerância espacial'.",
                                  "learningObjective": "Implementar e validar critérios de parada em um algoritmo iterativo completo.",
                                  "commonMistakes": "Esquecer de resetar contadores de iterações; erro lógico no OR dos critérios."
                                }
                              ],
                              "practicalExample": "Para resolver f(x) = e^x - 3x^2 (equilíbrio em pórtico de engenharia civil) no intervalo [0,1], defina ε = 1e-6 (espacial e funcional) e N_max = 50. O algoritmo para na iteração 18 por |b-a| < ε, com raiz aproximada x ≈ 0.619.",
                              "finalVerifications": [
                                "O algoritmo para quando pelo menos um critério é satisfeito.",
                                "A raiz encontrada satisfaz |f(x)| < ε.",
                                "Número de iterações ≤ N_max em testes.",
                                "Intervalo final [a,b] tem largura < ε.",
                                "Resultados consistentes em múltiplas execuções com sementes iniciais variadas.",
                                "Documentação inclui justificativa de ε e N_max."
                              ],
                              "assessmentCriteria": [
                                "Correta identificação e explicação de todos os critérios de parada (peso 25%).",
                                "Seleção e justificativa adequada de ε e N_max para o contexto (peso 25%).",
                                "Implementação sem erros lógicos no pseudocódigo/código (peso 20%).",
                                "Testes demonstram convergência robusta (peso 15%).",
                                "Análise de sensibilidade e refinamentos (peso 10%).",
                                "Clareza na documentação e exemplos (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de loops condicionais e controle de erros.",
                                "Estatística: Conceitos de tolerância e precisão numérica.",
                                "Física/Engenharia: Aplicação em modelos de estruturas civis não-lineares.",
                                "Matemática: Análise de convergência e limites.",
                                "Computação Científica: Otimização de algoritmos iterativos."
                              ],
                              "realWorldApplication": "Em simulações de engenharia civil, como análise não-linear de vigas ou fundações sob cargas dinâmicas, critérios de parada garantem soluções precisas sem sobrecarga computacional, permitindo iterações rápidas em softwares como ANSYS ou SAP2000 para projetos seguros e econômicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Executar iterações manualmente",
                            "description": "Aplicar o algoritmo manualmente para 5-10 iterações em uma equação exemplo, como f(x) = x^3 - x - 2 = 0 no intervalo [1, 2], registrando a, b, c e f(c) em cada passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o problema e verificar condições iniciais",
                                  "subSteps": [
                                    "Defina a função f(x) = x³ - x - 2 e o intervalo inicial [a, b] = [1, 2].",
                                    "Calcule f(a) = f(1) = 1 - 1 - 2 = -2.",
                                    "Calcule f(b) = f(2) = 8 - 2 - 2 = 4.",
                                    "Verifique se f(a) * f(b) < 0 (-2 * 4 = -8 < 0), confirmando existência de raiz no intervalo.",
                                    "Crie uma tabela inicial com colunas: Iteração, a, b, c, f(c), Novo Intervalo."
                                  ],
                                  "verification": "f(a) e f(b) calculados corretamente com sinais opostos e tabela inicial pronta.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta ou lápis",
                                    "Calculadora"
                                  ],
                                  "tips": "Mantenha pelo menos 4 casas decimais nos cálculos para precisão.",
                                  "learningObjective": "Garantir que as condições do teorema do valor intermediário sejam atendidas.",
                                  "commonMistakes": [
                                    "Erro no sinal de f(a) ou f(b)",
                                    "Intervalo sem mudança de sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar as iterações 1 a 5 manualmente",
                                  "subSteps": [
                                    "Para cada iteração: Calcule c = (a + b) / 2.",
                                    "Calcule f(c) usando a fórmula f(x) = x³ - x - 2.",
                                    "Se f(c) = 0, pare (raiz exata); senão, se f(a) * f(c) < 0, atualize b = c, senão a = c.",
                                    "Registre na tabela: iteração, valores de a, b, c, f(c) e novo [a, b].",
                                    "Repita o processo para completar 5 iterações, verificando sinais em cada passo."
                                  ],
                                  "verification": "Tabela preenchida corretamente para 5 iterações com decisões de intervalo lógicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta ou lápis",
                                    "Calculadora"
                                  ],
                                  "tips": "Use parênteses nos cálculos de potências para evitar erros aritméticos.",
                                  "learningObjective": "Dominar o procedimento iterativo central do método da bisseção.",
                                  "commonMistakes": [
                                    "Erro na atualização do intervalo (confundir f(a)*f(c))",
                                    "Arredondamento prematuro em c ou f(c)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar as iterações 6 a 10 e monitorar convergência",
                                  "subSteps": [
                                    "Continue do último intervalo da iteração 5: calcule novo c = (a + b)/2.",
                                    "Repita os cálculos de f(c), decisão de intervalo e registro para iterações 6-10.",
                                    "Observe o comprimento do intervalo (b - a) reduzindo pela metade a cada passo.",
                                    "Monitore se |b - a| < tolerância (ex: 0.001) para possível parada antecipada.",
                                    "Preencha a tabela completamente até 10 iterações."
                                  ],
                                  "verification": "Tabela completa com 10 iterações, intervalo final reduzido significativamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta ou lápis",
                                    "Calculadora"
                                  ],
                                  "tips": "Verifique cálculos anteriores antes de prosseguir para evitar propagação de erros.",
                                  "learningObjective": "Aplicar iterações múltiplas e observar a convergência linear do método.",
                                  "commonMistakes": [
                                    "Perder o rastreamento do intervalo correto",
                                    "Cálculos inconsistentes de f(c)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e verificar precisão",
                                  "subSteps": [
                                    "Calcule a raiz aproximada como c da última iteração ou (a + b)/2 final.",
                                    "Verifique f na raiz aproximada: deve ser próximo de zero.",
                                    "Calcule o erro estimado: |b - a|/2 da última iteração.",
                                    "Compare com valores conhecidos (raiz ≈ 1.5214) e discuta precisão.",
                                    "Resuma o processo em uma frase: número de iterações para dada precisão."
                                  ],
                                  "verification": "Raiz final correta (≈1.52), erro estimado calculado e análise escrita.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta ou lápis",
                                    "Calculadora"
                                  ],
                                  "tips": "A raiz real é solução de x³ - x - 2 = 0 ≈ 1.5213797.",
                                  "learningObjective": "Avaliar a eficácia e limitações do método da bisseção.",
                                  "commonMistakes": [
                                    "Ignorar verificação final de f(raiz)",
                                    "Não estimar erro de aproximação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x³ - x - 2 = 0 em [1,2]: Iteração 1: c=1.5, f(1.5)≈-0.125<0 → [1.5,2]; Iteração 2: c=1.75, f(1.75)≈1.609>0 → [1.5,1.75]; continue até iteração 10, raiz ≈1.521, intervalo <0.001.",
                              "finalVerifications": [
                                "Tabela completa com 10 iterações, colunas a, b, c, f(c) preenchidas.",
                                "Sinais opostos mantidos em f(a) e f(b) em todas as iterações.",
                                "Raiz aproximada converge para ≈1.521 com |f(raiz)| < 0.01.",
                                "Comprimento do intervalo reduzido para < 0.001.",
                                "Cálculos aritméticos verificados sem erros.",
                                "Análise de convergência documentada."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de f(x) e c (erro < 0.001 por iteração).",
                                "Tabela organizada e completa com todos os registros.",
                                "Decisões corretas de atualização de intervalo baseadas em sinais.",
                                "Estimativa de erro e raiz final precisa.",
                                "Explicação clara do processo iterativo.",
                                "Identificação de padrões de convergência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teorema do Valor Intermediário e análise numérica.",
                                "Programação: Codificar o algoritmo em Python para automação.",
                                "Física/Engenharia: Solução de equações em estática de estruturas.",
                                "Estatística: Avaliação de erro de truncamento e precisão numérica.",
                                "Computação Científica: Comparação com métodos como Newton-Raphson."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, aplica-se para resolver equações não-lineares em análise de estruturas (ex: encontrar deslocamentos em vigas sob carga não-linear), dimensionamento hidráulico (equações de fluxo) ou estabilidade de solos, onde raízes reais representam estados críticos de equilíbrio."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Implementação Computacional e Análise de Convergência",
                        "description": "Implementação do método em pseudocódigo ou linguagem de programação, com análise do erro e taxa de convergência linear, onde o erro é reduzido por fator 1/2 por iteração.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Escrever pseudocódigo do método",
                            "description": "Elaborar pseudocódigo completo incluindo entrada de a, b, ε, N_max, loop iterativo com bisseção e saída da raiz aproximada e número de iterações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir parâmetros de entrada e função objetivo",
                                  "subSteps": [
                                    "Identifique as entradas necessárias: intervalos a e b, tolerância ε, número máximo de iterações N_max.",
                                    "Defina a função f(x) a ser resolvida, garantindo que f(a) e f(b) tenham sinais opostos.",
                                    "Escreva o cabeçalho do pseudocódigo com declaração de variáveis (a, b, ε, N_max, f).",
                                    "Inclua comentários explicando o propósito de cada parâmetro.",
                                    "Teste conceitualmente se f(a)*f(b) < 0 para validar o intervalo inicial."
                                  ],
                                  "verification": "Verifique se todas as entradas estão declaradas corretamente e se há um comentário sobre a condição f(a)*f(b) < 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou editor de texto simples; referência ao algoritmo da bisseção.",
                                  "tips": "Use notação clara como 'FUNÇÃO f(x)' para diferenciar a função das variáveis.",
                                  "learningObjective": "Compreender e documentar as entradas essenciais para o método da bisseção.",
                                  "commonMistakes": "Esquecer de declarar ε ou N_max; não mencionar a função f(x)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar verificações iniciais e inicialização",
                                  "subSteps": [
                                    "Adicione verificação: SE f(a)*f(b) >= 0, então retorne erro ou mensagem de falha.",
                                    "Inicialize contador de iterações: iter = 0.",
                                    "Calcule o comprimento inicial do intervalo: width = b - a.",
                                    "Registre valores iniciais de f(a) e f(b).",
                                    "Adicione comentário explicando por que essas verificações são críticas para convergência."
                                  ],
                                  "verification": "Execute mentalmente com valores exemplo; confirme se erro é detectado quando sinais iguais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora para testar f(a) e f(b); pseudocódigo parcial do step 1.",
                                  "tips": "Use 'SE' e 'ENTÃO' em maiúsculas para estruturas condicionais no pseudocódigo.",
                                  "learningObjective": "Garantir pré-condições para validade do método e inicializar variáveis corretamente.",
                                  "commonMistakes": "Ignorar verificação de sinais opostos; inicializar iter incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever o loop iterativo principal de bisseção",
                                  "subSteps": [
                                    "Inicie loop ENQUANTO (iter < N_max E (b - a) > ε):",
                                    "Calcule ponto médio: c = (a + b) / 2.",
                                    "Avalie f(c); atualize intervalos baseado em sinais: SE f(a)*f(c) < 0, b = c; SENÃO a = c.",
                                    "Incremente iter = iter + 1.",
                                    "Opcionalmente, registre aproximação atual e erro."
                                  ],
                                  "verification": "Simule 2-3 iterações manualmente para confirmar redução do intervalo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel para simular iterações; tabela de exemplo com valores numéricos.",
                                  "tips": "Estruture o loop com indentação clara para mostrar escopo.",
                                  "learningObjective": "Implementar a lógica core da bisseção que garante convergência linear.",
                                  "commonMistakes": "Erro na atualização de intervalos (ex: trocar a e b incorretamente); esquecer incremento de iter."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar com saída dos resultados",
                                  "subSteps": [
                                    "Após o loop, defina raiz aproximada: root = (a + b) / 2.",
                                    "Calcule número de iterações usadas: iter.",
                                    "Saída: RETORNE root e iter; inclua mensagem se max iterações atingidas.",
                                    "Adicione verificação final de precisão: erro = |f(root)| < ε.",
                                    "Inclua comentários sobre pós-condições e análise de convergência."
                                  ],
                                  "verification": "Confirme se saída inclui root, iter e lida com parada por ε ou N_max.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Pseudocódigo completo dos steps anteriores; exemplo numérico para validar saída.",
                                  "tips": "Use 'RETORNE' para clareza; mencione convergência O(log(1/ε)).",
                                  "learningObjective": "Produzir saídas precisas e informativas para análise posterior.",
                                  "commonMistakes": "Não retornar iter; assumir convergência sem verificar erro final."
                                }
                              ],
                              "practicalExample": "Para f(x) = x^2 - 2 em [1, 2] (raiz ≈1.414), entradas: a=1, b=2, ε=0.001, N_max=50. Pseudocódigo gera root≈1.414 após ~10 iterações, com |f(root)|<ε.",
                              "finalVerifications": [
                                "Pseudocódigo inclui todas entradas: a, b, ε, N_max e função f.",
                                "Verificação inicial de f(a)*f(b) < 0 está presente.",
                                "Loop reduz intervalo corretamente até (b-a) ≤ ε ou N_max.",
                                "Saída retorna root aproximada e número de iterações.",
                                "Comentários explicam lógica e convergência.",
                                "Simulação manual confirma pelo menos 3 iterações corretas."
                              ],
                              "assessmentCriteria": [
                                "Precisão lógica: atualizações de a/b no loop corretas (100%).",
                                "Completude: todos elementos (entradas, loop, saída) presentes (100%).",
                                "Clareza: títulos, comentários e indentação legíveis (90%).",
                                "Robustez: trata casos de falha (sinais iguais, N_max atingido).",
                                "Eficiência: convergência garantida sem loops infinitos.",
                                "Validação: erro final |f(root)| ≤ ε demonstrado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Teorema do Valor Intermediário.",
                                "Programação: Estruturas de controle (loops, condicionais) em pseudocódigo.",
                                "Engenharia Civil: Modelagem de equações não-lineares em estruturas (ex: equilíbrio de vigas).",
                                "Física: Solução de problemas de estática com raízes não-lineares."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usado para encontrar cargas críticas em fundações onde equações como f(P) = resistência - carga(P) = 0; garante precisão em simulações sem derivadas, otimizando projetos de pontes e edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Implementar em linguagem de programação",
                            "description": "Codificar o método em MATLAB ou Python para resolver f(x) = 0, testando com exemplos de engenharia civil como equilíbrio de vigas, e plotar convergência do erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e preparar o ambiente de programação",
                                  "subSteps": [
                                    "Escolha a linguagem: Python (recomendado) ou MATLAB.",
                                    "Instale bibliotecas necessárias: NumPy e Matplotlib para Python.",
                                    "Defina a função f(x) baseada em exemplo de engenharia civil, como equilíbrio de viga: f(x) = x^3 - 6x^2 + 11x - 6 (modela posição de equilíbrio em viga com cargas variáveis).",
                                    "Selecione intervalo inicial [a, b] onde f(a)*f(b) < 0, ex: [0, 3].",
                                    "Defina tolerância de erro (ex: 1e-6) e máximo de iterações (ex: 100)."
                                  ],
                                  "verification": "Função f(x) definida e testada manualmente em pontos a e b, confirmando mudança de sinal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python 3+ com NumPy e Matplotlib; ou MATLAB; editor como Jupyter Notebook ou VS Code.",
                                  "tips": "Use Jupyter Notebook para visualização interativa de testes iniciais.",
                                  "learningObjective": "Compreender e configurar o problema não-linear específico de engenharia civil para aplicação do método da Bisseção.",
                                  "commonMistakes": "Escolher intervalo sem mudança de sinal; ignorar importação de bibliotecas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o algoritmo principal do método da Bisseção",
                                  "subSteps": [
                                    "Crie uma função bissection(f, a, b, tol, max_iter) que inicialize listas para erros e iterações.",
                                    "Implemente o loop: calcule c = (a + b)/2; verifique f(c) == 0 ou |b-a| < tol.",
                                    "Atualize intervalos: se f(a)*f(c) < 0, b = c; senão a = c; armazene erro = |f(c)|.",
                                    "Registre histórico de erros e pontos médios em listas.",
                                    "Retorne raiz aproximada, número de iterações e histórico de erros."
                                  ],
                                  "verification": "Execute função com valores de teste simples (ex: f(x)=x^2-2, [1,2]) e confirme raiz ≈1.414 com erro < tol.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ambiente de programação preparado no Step 1; documentação do método da Bisseção.",
                                  "tips": "Use print ou logging para debugar iterações durante desenvolvimento.",
                                  "learningObjective": "Codificar corretamente o algoritmo iterativo da Bisseção com controle de convergência.",
                                  "commonMistakes": "Loop infinito sem max_iter; erro na atualização de intervalos (não preservar mudança de sinal)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar com exemplo de engenharia civil",
                                  "subSteps": [
                                    "Aplique a função bissection à f(x) de equilíbrio de viga no intervalo [0,3].",
                                    "Execute e capture raiz, iterações e histórico de erros.",
                                    "Valide resultado: compare com solução analítica conhecida (raiz ≈0.5858 para esta f(x)).",
                                    "Teste sensibilidade variando tol e max_iter.",
                                    "Documente saída: imprima raiz, iterações e últimos erros."
                                  ],
                                  "verification": "Código produz raiz correta dentro de tol, com convergência em <50 iterações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código do Step 2; calculadora para validação manual.",
                                  "tips": "Salve histórico de erros em array para plotting posterior.",
                                  "learningObjective": "Aplicar implementação a problema real de engenharia civil e validar precisão.",
                                  "commonMistakes": "Função f(x) com coeficientes errados; intervalo inválido levando a não-convergência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar convergência do erro e analisar resultados",
                                  "subSteps": [
                                    "Use Matplotlib (Python) ou plot (MATLAB) para gráfico semilogarítmico: eixo x=iterações, y=log(|erro|).",
                                    "Plote curva de erro decrescendo linearmente (característica da Bisseção).",
                                    "Adicione linha de tolerância e marque iteração final.",
                                    "Analise: discuta taxa de convergência (dobro do intervalo por iteração) e adequação para engenharia.",
                                    "Exporte gráfico como PNG e inclua no relatório."
                                  ],
                                  "verification": "Gráfico gerado mostra erro reduzindo monotonicamente até tol; salvo em arquivo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Bibliotecas de plotting; histórico de erros do Step 3.",
                                  "tips": "Use plt.semilogy() para escala log; label e legend para clareza.",
                                  "learningObjective": "Visualizar e interpretar convergência numérica para análise crítica.",
                                  "commonMistakes": "Escala errada no plot (não log); histórico de erros vazio."
                                }
                              ],
                              "practicalExample": "Para uma viga simplesmente apoiada de comprimento L=5m com carga distribuída não-linear q(x)=x^2 + 2x (kN/m), resolva f(x)=∫q(x)dx - reação = x^3/3 + x^2 - R*x =0 para posição x de equilíbrio máximo, no intervalo [0,4]. Implemente em Python, obtenha x≈1.32m, e plote erro caindo de 10^-1 para 10^-7 em 25 iterações.",
                              "finalVerifications": [
                                "Código executa sem erros e converge para raiz correta em todos testes.",
                                "Histórico de erros captura todas iterações com redução consistente.",
                                "Gráfico de convergência mostra declínio log-linear do erro.",
                                "Validação com exemplo de viga confirma aplicação prática (erro <1e-6).",
                                "Relatório inclui código comentado, plots e análise de iterações.",
                                "Testes de sensibilidade (tol variada) funcionam corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Raiz dentro de 1% da solução conhecida.",
                                "Eficiência: Convergência em ≤40 iterações para tol=1e-6.",
                                "Clareza do código: Comentários, funções modulares e nomes descritivos.",
                                "Visualização: Gráfico informativo com labels, scales adequados e exportado.",
                                "Análise: Interpretação correta de convergência e limitações do método.",
                                "Aplicação contextual: Integração fiel ao exemplo de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica e métodos iterativos.",
                                "Ciência da Computação: Programação científica e visualização de dados.",
                                "Física/Estática: Modelagem de equilíbrio estrutural em vigas.",
                                "Estatística: Análise de erro e tolerâncias em simulações."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para simular deslocamentos não-lineares em estruturas (ex: vigas pré-esforçadas, fundações sob carga variável), análise de estabilidade de barragens e otimização de seções transversais em pontes, integrando-se a softwares como ANSYS ou custom scripts para predição precisa de falhas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.2",
                              "10.1.5.1.2.3"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Analisar erro e estimar iterações necessárias",
                            "description": "Calcular o erro máximo após n iterações como |x* - c_n| ≤ (b - a)/2^n e estimar n ≥ log_2((b - a)/ε) para uma precisão ε desejada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Erro Máximo no Método da Bisseção",
                                  "subSteps": [
                                    "Revise o método da bisseção: intervalo inicial [a, b] contém a raiz x*, e c_n é a aproximação na iteração n.",
                                    "Entenda que o erro máximo |x* - c_n| é no máximo metade do comprimento do intervalo atual.",
                                    "Memorize a fórmula: após n iterações, comprimento do intervalo é (b - a)/2^n, logo erro ≤ (b - a)/2^n.",
                                    "Discuta por que o erro é 'máximo' e conservador, assumindo pior caso.",
                                    "Compare com outros métodos para contextualizar a convergência linear."
                                  ],
                                  "verification": "Explique a fórmula em suas próprias palavras e dê um exemplo numérico simples.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Notas sobre método da bisseção",
                                    "Calculadora científica",
                                    "Gráfico do intervalo halving"
                                  ],
                                  "tips": "Visualize o processo como cortar um bolo ao meio repetidamente; o pedaço restante contém a raiz.",
                                  "learningObjective": "Dominar o significado e a origem da bound de erro (b - a)/2^n.",
                                  "commonMistakes": "Confundir erro absoluto com relativo; ignorar que é uma upper bound, não exato."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Provar a Fórmula do Erro Máximo",
                                  "subSteps": [
                                    "Comece com intervalo inicial L_0 = b - a.",
                                    "Mostre que após 1ª iteração, L_1 = L_0 / 2.",
                                    "Generalize por indução: assuma L_{k} = L_0 / 2^k, prove para k+1.",
                                    "Conclua que |x* - c_n| ≤ L_n / 2 = (b - a)/2^{n+1}, mas padronize para ≤ (b - a)/2^n.",
                                    "Teste com um intervalo pequeno para validar."
                                  ],
                                  "verification": "Escreva a prova por indução em papel e verifique com um colega ou professor.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software simbólico como SymPy (opcional)",
                                    "Referência de análise numérica"
                                  ],
                                  "tips": "Use notação recursiva: b_{n+1} - a_{n+1} = (b_n - a_n)/2.",
                                  "learningObjective": "Provar rigorosamente a bound de erro para ganhar confiança na fórmula.",
                                  "commonMistakes": "Erro no passo da indução base; confundir c_n com midpoint exato da raiz."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar o Número de Iterações para Precisão ε Desejada",
                                  "subSteps": [
                                    "Defina o requisito: erro ≤ ε, então (b - a)/2^n ≤ ε.",
                                    "Reorganize: 2^n ≥ (b - a)/ε.",
                                    "Aplique logaritmo base 2: n ≥ log_2((b - a)/ε).",
                                    "Calcule numericamente usando log2 ou ln(x)/ln(2), e arredonde para cima (ceil).",
                                    "Implemente uma função simples em Python ou Excel para automação."
                                  ],
                                  "verification": "Para [a,b]=[1,2], ε=0.01, compute n e confirme 2^n ≥ 100.",
                                  "estimatedTime": "35 minutes",
                                  "materials": [
                                    "Calculadora com log",
                                    "Python ou MATLAB",
                                    "Tabela de logaritmos"
                                  ],
                                  "tips": "Lembre: log_2(x) = log10(x)/log10(2) ≈ log10(x)/0.3010 para cálculos manuais.",
                                  "learningObjective": "Resolver para n e aplicar logaritmos em contextos numéricos.",
                                  "commonMistakes": "Esquecer ceil(n); usar log natural sem converter; inverter (b-a)/ε."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Análise de Erro em Implementação Computacional",
                                  "subSteps": [
                                    "Escolha uma equação não-linear, e.g., f(x) = x^3 - x - 2 = 0 em [1,2].",
                                    "Implemente bisseção em código, rastreando erro bound a cada iteração.",
                                    "Estime n para ε=10^{-4}, rode o código e compare iterações reais vs. estimadas.",
                                    "Analise convergência plotando erro vs. n.",
                                    "Otimize parando quando bound ≤ ε."
                                  ],
                                  "verification": "Código roda corretamente, estima n=14 para ε=10^{-4}, e para no passo certo.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Editor de código",
                                    "Exemplo de função f(x)"
                                  ],
                                  "tips": "Use print statements para logar (b-a)/2^n a cada passo.",
                                  "learningObjective": "Integrar teoria de erro com prática computacional para análise de convergência.",
                                  "commonMistakes": "Implementar bisseção errada (e.g., sem f(c)*f(b)<0); ignorar overflow em 2^n."
                                }
                              ],
                              "practicalExample": "Para f(x) = x^2 - 2 = 0 em [1, 2] (raiz √2 ≈1.414), com ε=0.01: (b-a)=1, log2(1/0.01)=log2(100)≈6.64, n≥7. Após 7 iterações, erro ≤1/128≈0.0078<0.01. Código Python confirma c_7≈1.414 e para corretamente.",
                              "finalVerifications": [
                                "Calcular corretamente erro bound após n=5 para [0,1]: ≤1/32=0.03125.",
                                "Estimar n=20 para ε=10^{-6} em intervalo de comprimento 1.",
                                "Provar por indução a fórmula em 3 linhas.",
                                "Implementar função que retorna n estimado dado a,b,ε.",
                                "Comparar estimativa vs. iterações reais em exemplo, com diferença ≤2.",
                                "Plotar log(errore) vs. n linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da bound de erro (100% correto).",
                                "Cálculo exato de n com ceil(log2((b-a)/ε)) e exemplo numérico.",
                                "Código funcional com rastreio de erro e parada por bound.",
                                "Interpretação: explicar por que estimativa é conservadora.",
                                "Análise: identificar quando bound é loose (raiz perto de endpoint).",
                                "Clareza na documentação do exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propriedades de logaritmos e indução matemática.",
                                "Programação: Controle de loops, funções e análise de complexidade O(n).",
                                "Estatística: Conceitos de precisão e tolerância em simulações Monte Carlo.",
                                "Física/Engenharia: Análise de convergência em métodos iterativos para PDEs."
                              ],
                              "realWorldApplication": "Na engenharia civil, ao resolver equações não-lineares para deformações em estruturas sob carga (e.g., equilíbrio de vigas curvas), estimar iterações no método da bisseção otimiza simulações FEM, evitando desperdício computacional em projetos de pontes ou edifícios, garantindo precisão ε=10^{-6} para segurança estrutural."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.4",
                            "name": "Comparar convergência com outros métodos",
                            "description": "Discutir a robustez do método da bisseção (garantia de convergência lenta, linear) versus métodos como Newton-Raphson (mais rápidos mas dependentes de derivada).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a convergência do método da bisseção",
                                  "subSteps": [
                                    "Relembrar o algoritmo da bisseção: intervalo [a,b] onde f(a)*f(b)<0, midpoint c=(a+b)/2.",
                                    "Explicar a garantia de convergência linear: erro reduzido pela metade a cada iteração.",
                                    "Derivar a taxa de convergência: |x_n - raiz| <= (b-a)/2^n.",
                                    "Discutir limitações: convergência lenta para raízes múltiplas.",
                                    "Implementar uma simulação simples em código para visualizar iterações."
                                  ],
                                  "verification": "Gerar gráfico ou tabela mostrando redução linear do erro ao longo de 20 iterações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/Matplotlib ou MATLAB; equação de teste f(x)=x^3 - x - 2.",
                                  "tips": "Use intervalos iniciais amplos para demonstrar robustez independentemente da derivada.",
                                  "learningObjective": "Compreender matematicamente a robustez e lentidão da bisseção.",
                                  "commonMistakes": "Confundir convergência linear com quadrática; ignorar necessidade de sinal oposto nos extremos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar convergência de métodos alternativos como Newton-Raphson",
                                  "subSteps": [
                                    "Descrever Newton-Raphson: x_{n+1} = x_n - f(x_n)/f'(x_n).",
                                    "Explicar convergência quadrática sob condições (derivada não-zero na raiz).",
                                    "Discutir dependências: requer boa aproximação inicial e derivada computável.",
                                    "Comparar teoricamente: bisseção sempre converge se intervalo válido; Newton pode divergir.",
                                    "Calcular manualmente 5 iterações para uma equação simples."
                                  ],
                                  "verification": "Tabela comparativa de erros por iteração para bisseção vs. Newton em mesmo problema.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Papel e calculadora; código Python para automação; referência teórica (livro de numérico).",
                                  "tips": "Escolha funções com derivada suave para destacar velocidade do Newton.",
                                  "learningObjective": "Identificar vantagens (velocidade) e riscos (divergência) do Newton-Raphson.",
                                  "commonMistakes": "Assumir convergência quadrática sempre; esquecer de testar múltiplos iniciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar simulações comparativas numéricas",
                                  "subSteps": [
                                    "Codificar funções para bisseção, Newton-Raphson e método da secante.",
                                    "Testar em 3 equações não-lineares com diferentes comportamentos (raiz simples, múltipla).",
                                    "Medir métricas: número de iterações, tempo de CPU, erro final.",
                                    "Gerar gráficos de convergência: log(erros) vs. iterações.",
                                    "Variar condições iniciais para bisseção (robusta) vs. Newton (sensível)."
                                  ],
                                  "verification": "Relatório com tabelas e gráficos mostrando bisseção converge em todos casos, Newton falha em alguns.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": "Python (SciPy para benchmark), Jupyter Notebook; dataset de funções teste.",
                                  "tips": "Use tolerância 1e-10; plote curvas de erro para visual intuitivo.",
                                  "learningObjective": "Aplicar implementações para quantificar diferenças empíricas de convergência.",
                                  "commonMistakes": "Não normalizar intervalos iniciais; ignorar overhead computacional da derivada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar robustez e discutir trade-offs",
                                  "subSteps": [
                                    "Resumir prós da bisseção: robusta, sem derivadas, garantida.",
                                    "Resumir contras: lenta (O(n) iterações para precisão).",
                                    "Comparar com Newton/secante: rápida mas frágil a inicial ruim.",
                                    "Recomendar uso híbrido: bisseção para localização, Newton para refinamento.",
                                    "Redigir relatório comparativo com conclusões."
                                  ],
                                  "verification": "Documento de 1 página com tabela de trade-offs e recomendação contextual.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de texto; resultados das simulações anteriores.",
                                  "tips": "Foque em cenários de engenharia: funções black-box sem derivada analítica.",
                                  "learningObjective": "Desenvolver raciocínio crítico para seleção de métodos.",
                                  "commonMistakes": "Superestimar velocidade sem considerar casos de falha do Newton."
                                }
                              ],
                              "practicalExample": "Para f(x) = e^x - 3x^2 (equação de equilíbrio em vigas civis), aplique bisseção em [0,2] (20 iterações para 1e-6 erro) vs. Newton com x0=1 (3 iterações, mas diverge se x0=0.1); gráfico mostra bisseção estável, Newton 10x mais rápida quando converge.",
                              "finalVerifications": [
                                "Tabelas/gráficos comparam iterações e erros para ≥3 funções.",
                                "Relatório discute robustez da bisseção vs. sensibilidade do Newton.",
                                "Recomendação contextual para problemas de engenharia civil.",
                                "Simulações testam múltiplos iniciais, mostrando falhas do Newton.",
                                "Taxas de convergência derivadas corretamente (linear vs. quadrática)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação teórica de convergência (30%)",
                                "Qualidade das simulações numéricas e visualizações (25%)",
                                "Análise equilibrada de prós/contras (20%)",
                                "Clareza no relatório comparativo (15%)",
                                "Aplicação correta a exemplos reais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB reforça computação científica.",
                                "Estatística: Análise de sensibilidade a condições iniciais como variância.",
                                "Física/Engenharia: Modelagem de equações não-lineares em estruturas civis.",
                                "Matemática Aplicada: Teoria de erros e otimização numérica."
                              ],
                              "realWorldApplication": "Em engenharia civil, para resolver equações de equilíbrio em treliças ou fluxo em tubulações (sem derivada conhecida), bisseção garante solução robusta; Newton acelera protótipos, mas híbrido previne falhas em software de análise estrutural como ANSYS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Método de Newton-Raphson",
                    "description": "Método iterativo que utiliza a derivada para aproximar raízes de equações não-lineares com convergência quadrática.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Formulação Matemática do Método de Newton-Raphson",
                        "description": "Definição da fórmula iterativa x_{n+1} = x_n - f(x_n)/f'(x_n), interpretação geométrica como interseção da tangente com o eixo x e requisitos para a função f e sua derivada f'.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Derivar a fórmula iterativa do método",
                            "description": "Explicar passo a passo a origem da iteração utilizando a aproximação linear de Taylor de primeira ordem para f(x) ≈ f(x_n) + f'(x_n)(x - x_n) = 0, resolvendo para x.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar a Expansão de Taylor de Primeira Ordem",
                                  "subSteps": [
                                    "Estude a definição da expansão de Taylor para uma função f(x) diferenciável ao redor de um ponto x_n.",
                                    "Escreva a fórmula geral: f(x) ≈ f(x_n) + f'(x_n)(x - x_n).",
                                    "Explique que isso é a aproximação linear local da função.",
                                    "Verifique com um exemplo simples, como f(x) = sin(x) em x_n = 0.",
                                    "Discuta a precisão: boa perto de x_n, pior distante."
                                  ],
                                  "verification": "Escreva a fórmula de Taylor de 1ª ordem corretamente e aplique a um exemplo básico.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Livro de Cálculo I",
                                    "Folha de papel e caneta",
                                    "Calculadora gráfica"
                                  ],
                                  "tips": "Visualize graficamente: a reta tangente aproxima a curva.",
                                  "learningObjective": "Compreender a base teórica da aproximação linear via Taylor.",
                                  "commonMistakes": "Confundir com Taylor de 2ª ordem (inclui f''(x)/2)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a Aproximação de Taylor à Função f(x)",
                                  "subSteps": [
                                    "Parta da equação f(x) = 0, onde x é a raiz desconhecida.",
                                    "Aproxime f(x) ≈ f(x_n) + f'(x_n)(x - x_n) ao redor da iteração atual x_n.",
                                    "Substitua x pela próxima iteração x_{n+1}.",
                                    "Escreva explicitamente: f(x_{n+1}) ≈ f(x_n) + f'(x_n)(x_{n+1} - x_n).",
                                    "Confirme que isso lineariza a equação não-linear."
                                  ],
                                  "verification": "Escreva a aproximação de Taylor aplicada a f(x_{n+1}) corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software como GeoGebra para plotar aproximações"
                                  ],
                                  "tips": "Pense na reta tangente cruzando o eixo x como nova estimativa.",
                                  "learningObjective": "Aplicar corretamente a expansão de Taylor para linearizar f(x).",
                                  "commonMistakes": "Esquecer o termo (x - x_n) ou usar f'(x) em vez de f'(x_n)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a Aproximação Igual a Zero e Resolver para x_{n+1}",
                                  "subSteps": [
                                    "Como buscamos raiz, defina a aproximação linear igual a zero: f(x_n) + f'(x_n)(x_{n+1} - x_n) = 0.",
                                    "Isole o termo com x_{n+1}: f'(x_n)(x_{n+1} - x_n) = -f(x_n).",
                                    "Divida ambos os lados por f'(x_n): x_{n+1} - x_n = -f(x_n) / f'(x_n).",
                                    "Some x_n: x_{n+1} = x_n - f(x_n) / f'(x_n).",
                                    "Verifique algebricamente se a derivação está correta."
                                  ],
                                  "verification": "Derive e escreva a fórmula x_{n+1} = x_n - f(x_n)/f'(x_n) passo a passo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lousa ou papel para álgebra",
                                    "Exemplos de funções não-lineares"
                                  ],
                                  "tips": "Assuma f'(x_n) ≠ 0 para evitar divisão por zero.",
                                  "learningObjective": "Resolver a equação linear aproximada para obter a iteração seguinte.",
                                  "commonMistakes": "Sinal errado no numerador (deve ser -f(x_n)) ou inverter fração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Formalizar a Fórmula Iterativa do Newton-Raphson",
                                  "subSteps": [
                                    "Reconheça que x_{n+1} = x_n - f(x_n)/f'(x_n) é a fórmula iterativa.",
                                    "Explique a intuição: corrigir x_n pela razão 'erro/f'(x_n)'.",
                                    "Discuta convergência: quadrática perto da raiz se f'' existe.",
                                    "Escreva o algoritmo geral: inicializar x_0, iterar até |f(x)| < tol.",
                                    "Teste com uma função simples para validar."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a origem iterativa e escreva o pseudocódigo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python ou MATLAB para simular iterações",
                                    "Gráfico de convergência"
                                  ],
                                  "tips": "Compare com método da bisseção para destacar eficiência.",
                                  "learningObjective": "Formalizar e compreender a interpretação iterativa do método.",
                                  "commonMistakes": "Confundir com secante (não usa derivada) ou falsi posição."
                                }
                              ],
                              "practicalExample": "Para f(x) = x² - 2 = 0 (raiz √2 ≈ 1.414), x_0 = 1. f'(x)=2x. Então x_1 = 1 - (1-2)/2(1) = 1 - (-1)/2 = 1.5. x_2 = 1.5 - (2.25-2)/3 ≈ 1.4167. Convergência rápida!",
                              "finalVerifications": [
                                "Deriva corretamente a fórmula x_{n+1} = x_n - f(x_n)/f'(x_n) a partir de Taylor.",
                                "Explica a aproximação linear e por que ela leva à iteração.",
                                "Identifica condições como f'(x_n) ≠ 0.",
                                "Aplica a um exemplo numérico e verifica convergência.",
                                "Discute limitações, como divergência se chute inicial ruim.",
                                "Escreva o pseudocódigo completo do método."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação (sem erros de sinal ou álgebra).",
                                "Compreensão conceitual da linearização via Taylor.",
                                "Capacidade de aplicar a exemplo prático com cálculos corretos.",
                                "Explicação clara da intuição iterativa.",
                                "Identificação de erros comuns e condições de uso.",
                                "Qualidade dos subpassos e verificações em cada step."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Expansões de Taylor e derivadas.",
                                "Programação Numérica: Implementação em Python/MATLAB.",
                                "Física: Aproximações em oscilações ou trajetórias.",
                                "Estatística: Ajuste de curvas não-lineares."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usado para resolver equações não-lineares em análise estrutural, como equilíbrio de vigas curvas ou deformações em solos, onde se itera para encontrar deslocamentos que satisfazem f(u) = 0."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Aplicar iteração manual inicial",
                            "description": "Dado f(x) e um chute inicial x_0, calcular x_1 e x_2 manualmente, computando f(x_n) e f'(x_n), e discutir a redução do erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a função f(x), sua derivada f'(x) e o chute inicial x₀",
                                  "subSteps": [
                                    "Escolha ou identifique a equação não-linear f(x) = 0 a ser resolvida.",
                                    "Calcule analiticamente a derivada f'(x).",
                                    "Selecione um chute inicial x₀ razoável baseado em análise gráfica ou domínio físico.",
                                    "Verifique se f'(x₀) ≠ 0 para garantir convergência local.",
                                    "Anote todos os valores em uma tabela organizada."
                                  ],
                                  "verification": "Confirme que f(x), f'(x) e x₀ estão corretamente definidos e anotados sem erros aritméticos iniciais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica",
                                    "Gráfica da função (opcional)"
                                  ],
                                  "tips": "Visualize a função graficamente para escolher x₀ próximo da raiz real.",
                                  "learningObjective": "Compreender os componentes necessários para iniciar o método de Newton-Raphson.",
                                  "commonMistakes": [
                                    "Escolher x₀ onde f'(x₀) = 0",
                                    "Erros na derivação de f'(x)",
                                    "Chute inicial muito distante da raiz"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a primeira iteração: x₁ = x₀ - f(x₀)/f'(x₀)",
                                  "subSteps": [
                                    "Compute f(x₀) substituindo x₀ na função f(x).",
                                    "Compute f'(x₀) substituindo x₀ na derivada.",
                                    "Calcule o quociente f(x₀)/f'(x₀).",
                                    "Subtraia o quociente de x₀ para obter x₁.",
                                    "Registre f(x₀), f'(x₀) e x₁ em uma tabela de iterações."
                                  ],
                                  "verification": "Verifique se x₁ difere significativamente de x₀ e se os cálculos intermediários batem com recomputação manual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de iterações em papel"
                                  ],
                                  "tips": "Mantenha precisão decimal consistente (ex: 4 casas) para evitar erros de arredondamento acumulados.",
                                  "learningObjective": "Executar com precisão a fórmula de iteração para a primeira aproximação.",
                                  "commonMistakes": [
                                    "Dividir por f'(x₀) incorreto",
                                    "Sinal errado na subtração",
                                    "Arredondamento prematuro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a segunda iteração: x₂ = x₁ - f(x₁)/f'(x₁)",
                                  "subSteps": [
                                    "Compute f(x₁) usando o novo valor x₁.",
                                    "Compute f'(x₁) com x₁.",
                                    "Calcule f(x₁)/f'(x₁).",
                                    "Aplique a fórmula para obter x₂.",
                                    "Atualize a tabela com f(x₁), f'(x₁) e x₂."
                                  ],
                                  "verification": "Confirme que |x₂ - x₁| < |x₁ - x₀|, indicando redução de erro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela atualizada"
                                  ],
                                  "tips": "Compare x₂ com x₁ visualmente para observar convergência.",
                                  "learningObjective": "Aplicar iterativamente a fórmula e registrar progressos.",
                                  "commonMistakes": [
                                    "Usar x₀ em vez de x₁ nos cálculos",
                                    "Perder precisão em casas decimais",
                                    "Esquecer de atualizar a derivada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir e analisar a redução do erro nas iterações",
                                  "subSteps": [
                                    "Calcule os erros absolutos: e₁ = |x₁ - x₀|, e₂ = |x₂ - x₁|.",
                                    "Compare e₂ com e₁ (deve ser menor, tipicamente quadrático).",
                                    "Discuta razões para convergência ou divergência observada.",
                                    "Estime a raiz aproximada como x₂ e compare com valor conhecido (se disponível).",
                                    "Registre insights sobre comportamento do método."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que o erro reduziu e prediga x₃.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela completa",
                                    "Gráfica opcional"
                                  ],
                                  "tips": "Use a propriedade quadrática: erro novo ≈ (f''/2f') * erro² para qualitativo.",
                                  "learningObjective": "Interpretar a convergência e redução de erro no método.",
                                  "commonMistakes": [
                                    "Confundir erro absoluto com relativo",
                                    "Ignorar sinal dos erros",
                                    "Não relacionar com teoria quadrática"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x² - 2 = 0 (raiz √2 ≈ 1.4142), f'(x) = 2x, x₀ = 1.0: f(1)= -1, f'(1)=2, x₁=1 - (-1)/2=1.5; f(1.5)=0.25, f'(1.5)=3, x₂=1.5-0.25/3≈1.4167. Erros: |1.5-1|=0.5, |1.4167-1.5|≈0.0833 (redução significativa).",
                              "finalVerifications": [
                                "Tabela de iterações completa com x₀, x₁, x₂, f(x_n) e f'(x_n) corretos.",
                                "Cálculos manuais validados por recomputação independente.",
                                "Análise qualitativa da redução de erro demonstrada.",
                                "x₂ aproximado à raiz real dentro de 5% de erro.",
                                "Discussão sobre condições de convergência identificadas.",
                                "Tabela organizada e legível."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de f(x_n) e f'(x_n) (sem erros aritméticos).",
                                "Correta aplicação da fórmula de iteração em ambas as steps.",
                                "Análise adequada da redução de erro (quantitativa e qualitativa).",
                                "Escolha lógica de x₀ e verificação de f'(x) ≠ 0.",
                                "Clareza na tabela e documentação.",
                                "Profundidade na discussão de convergência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial e análise de convergência.",
                                "Programação: Implementação em Python/MATLAB para automação.",
                                "Física: Modelagem de equilíbrio em estruturas (ex: deformação não-linear).",
                                "Estatística: Ajuste de curvas em dados experimentais.",
                                "Engenharia de Software: Validação numérica em simulações."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, aplica-se para resolver equações não-lineares em análise de estruturas, como encontrar deslocamentos em vigas com grandes deformações ou pontos de flambagem em colunas, onde iterações manuais iniciais validam implementações computacionais em softwares como ANSYS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Interpretar geometricamente o método",
                            "description": "Visualizar o processo como traçar a reta tangente à curva f(x) no ponto x_n e encontrar sua interseção com o eixo x, ilustrando aceleração da convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Desenhar a curva f(x) e identificar o ponto inicial x_n",
                                  "subSteps": [
                                    "Escolha uma função não-linear f(x) com raiz conhecida, como f(x) = x² - 2.",
                                    "Plote a curva f(x) em um sistema de coordenadas, marcando o eixo x e y claramente.",
                                    "Selecione e marque um ponto inicial x_n aproximado na curva, indicando f(x_n).",
                                    "Rotule o ponto (x_n, f(x_n)) e observe se f(x_n) ≠ 0.",
                                    "Verifique se a curva cruza o eixo x próximo ao ponto inicial."
                                  ],
                                  "verification": "Confirme que o gráfico da curva está preciso e o ponto x_n está corretamente rotulado com coordenadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de graficação (Desmos/GeoGebra)",
                                    "Lápis e régua",
                                    "Calculadora para valores de f(x)"
                                  ],
                                  "tips": "Use uma escala apropriada para visualizar bem a região próxima à raiz; amplie se necessário.",
                                  "learningObjective": "Compreender a representação gráfica da equação f(x) = 0 e a importância do ponto inicial.",
                                  "commonMistakes": [
                                    "Escolher x_n onde f'(x_n) ≈ 0, causando problemas de convergência",
                                    "Plotar incorretamente a curva, invertendo eixos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a reta tangente à curva no ponto x_n",
                                  "subSteps": [
                                    "Calcule a derivada f'(x_n) no ponto x_n.",
                                    "Determine o coeficiente angular m = f'(x_n).",
                                    "Escreva a equação da reta tangente: y - f(x_n) = m(x - x_n).",
                                    "Trace a reta tangente a partir do ponto (x_n, f(x_n)) com inclinação m.",
                                    "Verifique se a tangente toca a curva apenas em x_n (propriedade local)."
                                  ],
                                  "verification": "A reta deve passar exatamente por (x_n, f(x_n)) e ter inclinação igual a f'(x_n); teste com um ponto próximo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (Wolfram Alpha)",
                                    "Gráfico do Step 1",
                                    "Régua para traçar linha reta"
                                  ],
                                  "tips": "Lembre-se: a tangente aproxima linearmente a curva localmente; evite confundir com secante.",
                                  "learningObjective": "Aplicar o conceito de derivada como inclinação da tangente para linearizar a função não-linear.",
                                  "commonMistakes": [
                                    "Confundir derivada com valor da função",
                                    "Usar secante em vez de tangente (média em vez de instantânea)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Encontrar a interseção da tangente com o eixo x para obter x_{n+1}",
                                  "subSteps": [
                                    "Defina y = 0 na equação da tangente: 0 - f(x_n) = m(x - x_n).",
                                    "Resolva para x: x_{n+1} = x_n - f(x_n)/f'(x_n).",
                                    "Marque o ponto de interseção (x_{n+1}, 0) no gráfico.",
                                    "Compare distâncias |x_{n+1} - raiz| vs |x_n - raiz| para notar melhoria.",
                                    "Rotule a seta de x_n para x_{n+1} indicando o passo do método."
                                  ],
                                  "verification": "Calcule x_{n+1} algebricamente e confirme que coincide com a interseção gráfica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico atualizado",
                                    "Calculadora para resolver a equação linear"
                                  ],
                                  "tips": "A interseção com eixo x (raiz da aproximação linear) é a base da iteração quadrática.",
                                  "learningObjective": "Interpretar geometricamente a fórmula de Newton-Raphson como zero da tangente.",
                                  "commonMistakes": [
                                    "Erro aritmético na resolução: esquecer sinal negativo",
                                    "Ignorar se f'(x_n) = 0 (divisão por zero)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar múltiplas iterações para ilustrar aceleração da convergência",
                                  "subSteps": [
                                    "Repita os Steps 2-3 a partir de x_{n+1} para obter x_{n+2}.",
                                    "Trace a nova tangente e interseção, marcando 2-3 iterações.",
                                    "Observe como as tangentes subsequentes ficam mais horizontais e próximas da raiz.",
                                    "Meça e compare erros: e_{n+1} ≈ e_n² (convergência quadrática).",
                                    "Anote como o processo 'acelera' em direção à raiz."
                                  ],
                                  "verification": "Após 3 iterações, x_final deve estar dentro de 0.01 da raiz verdadeira; gráfico mostra zoom na raiz.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de graficação para animação opcional",
                                    "Folha de cálculos para rastrear iterações"
                                  ],
                                  "tips": "Use cores diferentes para cada tangente para visualizar melhor a sequência.",
                                  "learningObjective": "Demonstrar visualmente por que Newton-Raphson converge mais rápido que métodos lineares.",
                                  "commonMistakes": [
                                    "Parar cedo sem múltiplas iterações",
                                    "Não notar a quadratura do erro devido a escala inadequada"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x³ - 2x + 1 (equação de equilíbrio em uma treliça não-linear), inicie com x_0 = 0. Plote a curva, tangente inicial y ≈ 1 + x (m=1), interseção x_1 ≈ -1. Repita: converge rapidamente para raízes ≈ -1.618 e 0.618, simulando pontos de instabilidade estrutural.",
                              "finalVerifications": [
                                "Esboço completo mostra curva, tangentes e interseções convergindo à raiz.",
                                "Fórmula x_{n+1} = x_n - f(x_n)/f'(x_n) é derivada corretamente do gráfico.",
                                "Explicação verbal liga geometria à aceleração quadrática.",
                                "Identifica condições onde visualmente falha (ex: tangente horizontal).",
                                "Compara com método da bissecção (mais lento, sem tangentes)."
                              ],
                              "assessmentCriteria": [
                                "Precisão gráfica: tangentes corretas em pelo menos 3 iterações (80% exatidão).",
                                "Compreensão conceitual: explica linearização local e convergência quadrática.",
                                "Correção algébrica: x_{n+1} matches gráfico em 4 casas decimais.",
                                "Criatividade: usa exemplo relevante a engenharia civil.",
                                "Clareza: rótulos, escalas e legendas no esboço.",
                                "Análise: discute erros e aceleração quantitativamente."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: uso de derivadas como taxas de variação.",
                                "Geometria Analítica: equações de retas e interseções.",
                                "Programação Computacional: plotagem dinâmica em Python/MATLAB.",
                                "Física Aplicada: aproximações lineares em dinâmica não-linear.",
                                "Visualização de Dados: gráficos para insight numérico."
                              ],
                              "realWorldApplication": "Em engenharia civil, interpreta geometricamente iterações de Newton-Raphson para resolver equações não-lineares de deformação em vigas ou buckling em colunas, acelerando simulações em software como ANSYS para design otimizado de estruturas sob cargas reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Análise de Convergência e Erros",
                        "description": "Estudo da convergência quadrática sob condições ideais, ordem de convergência e análise de erros absolutos e relativos, incluindo critérios de parada.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Explicar convergência quadrática",
                            "description": "Demonstrar que o erro e_{n+1} ≈ (f''(ξ)/2 f'(x_n)) e_n², justificando a ordem 2 de convergência quando f'(r) ≠ 0 e f'' contínua próximo da raiz r.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Newton-Raphson e Definição de Erro",
                                  "subSteps": [
                                    "Relembrar a iteração do método: x_{n+1} = x_n - f(x_n)/f'(x_n)",
                                    "Definir o erro e_n = x_n - r, onde r é a raiz exata f(r)=0",
                                    "Explicar assintoticamente: lim_{n→∞} e_{n+1}/e_n^p = C ≠ 0 para ordem p",
                                    "Discutir por que p=1 para método da bisseção e p=2 esperado para Newton",
                                    "Calcular manualmente e_n para as primeiras iterações de um exemplo simples"
                                  ],
                                  "verification": "Capacidade de escrever a fórmula de iteração e definir e_n corretamente em um quadro ou papel",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora científica, software como Python ou MATLAB para iterações iniciais",
                                  "tips": "Comece com um chute inicial próximo da raiz para observar erros pequenos rapidamente",
                                  "learningObjective": "Compreender a base conceitual do erro e ordem de convergência no método de Newton-Raphson",
                                  "commonMistakes": "Confundir e_n com |f(x_n)|; assumir convergência sem condições iniciais adequadas"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Expansão de Taylor para f(x_n) ao Redor da Raiz r",
                                  "subSteps": [
                                    "Escrever a expansão de Taylor: f(x_n) = f(r) + f'(r)e_n + (f''(ξ)/2)e_n² para algum ξ entre r e x_n",
                                    "Simplificar sabendo que f(r)=0: f(x_n) ≈ f'(r)e_n + (f''(ξ)/2)e_n²",
                                    "Derivar similarmente para f'(x_n): f'(x_n) ≈ f'(r) + f''(η)e_n para η entre r e x_n",
                                    "Verificar continuidade de f'' próximo a r como hipótese",
                                    "Calcular numericamente os termos de Taylor para f(x)=x²-2 em x_n próximo de √2"
                                  ],
                                  "verification": "Derivação correta da expansão de Taylor com resto de Lagrange em um exemplo",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, tabela de derivadas, software simbólico como SymPy",
                                  "tips": "Use ξ e η genéricos para enfatizar aproximação local; ignore termos o(e_n²) inicialmente",
                                  "learningObjective": "Dominar a expansão de Taylor multivariável aplicada a funções e derivadas",
                                  "commonMistakes": "Esquecer o resto de Lagrange ou assumir f'' constante sem justificativa"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Relação Assintótica do Erro e_{n+1} ≈ C e_n²",
                                  "subSteps": [
                                    "Substituir expansões na iteração: e_{n+1} = e_n - f(x_n)/f'(x_n)",
                                    "Aproximar: f(x_n)/f'(x_n) ≈ [f'(r)e_n + (f''(ξ)/2)e_n²] / [f'(r) + f''(η)e_n]",
                                    "Expandir o denominador: 1/f'(x_n) ≈ (1/f'(r)) [1 - (f''(η)/f'(r)) e_n + o(e_n)]",
                                    "Multiplicar e simplificar: e_{n+1} ≈ (f''(ξ)/(2 f'(r))) e_n² + o(e_n²)",
                                    "Confirmar com cálculo numérico: plotar log|e_{n+1}| vs log|e_n| para inclinação ≈2"
                                  ],
                                  "verification": "Obter a fórmula e_{n+1} ≈ (f''(ξ)/2 f'(r)) e_n² em derivação algébrica",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou Python para plotar erros, quadro branco",
                                  "tips": "Divida em frações e use aproximações binomiais para termos pequenos",
                                  "learningObjective": "Derivar analiticamente a relação quadrática do erro",
                                  "commonMistakes": "Negligenciar f'(x_n) ≈ f'(r); erro em sinal ou fator 1/2 na Taylor"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar Ordem 2 e Condições de Convergência Quadrática",
                                  "subSteps": [
                                    "Mostrar lim_{n→∞} e_{n+1}/e_n² = f''(r)/(2 f'(r)) = C ≠ 0, finito",
                                    "Enfatizar condições: f'(r) ≠ 0, f'' contínua em vizinhança de r, x_0 suficientemente próximo",
                                    "Discutir o que acontece se f'(r)=0 (ordem reduzida)",
                                    "Comparar com método da secante (p=1.618) via tabela de erros",
                                    "Testar em software: iterar até e_n < 10^{-10} e medir razão e_{n+1}/e_n²"
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito as condições e limite assintótico",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código Python/MATLAB pronto para análise de erros, gráficos de convergência",
                                  "tips": "Use raízes simples como teste; monitore se C é constante nas últimas iterações",
                                  "learningObjective": "Justificar rigorosamente a convergência quadrática e suas hipóteses",
                                  "commonMistakes": "Afirmar convergência global sem chute inicial bom; confundir com ordem linear"
                                }
                              ],
                              "practicalExample": "Para f(x) = x³ - 2x - 5 com raiz r≈2.0946, inicie x_0=2. Use Python para calcular iterações: observe e_1≈0.0946, e_2≈8.9e-4, e_3≈4e-7, confirmando e_{n+1}/e_n² ≈ 0.45 constante.",
                              "finalVerifications": [
                                "Derivar corretamente e_{n+1} ≈ (f''(ξ)/(2 f'(x_n))) e_n²",
                                "Identificar condições f'(r)≠0 e f'' contínua",
                                "Calcular C numericamente para um exemplo e verificar ≈ f''(r)/(2 f'(r))",
                                "Plotar log-log de erros mostrando inclinação 2",
                                "Explicar por que Newton é quadrático vs. linear em outros métodos",
                                "Discutir falha se f'(r)=0 com contraexemplo"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor e simplificação algébrica (40%)",
                                "Correta identificação e justificativa das condições de convergência (20%)",
                                "Análise numérica com exemplos e gráficos coerentes (20%)",
                                "Clareza na explicação oral/escrita da ordem 2 (10%)",
                                "Tratamento de erros comuns e limitações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Teorema do Resto de Taylor",
                                "Programação Computacional: Implementação e análise de erros em Python/MATLAB",
                                "Cálculo Diferencial: Expansões de Taylor e continuidade de derivadas",
                                "Física/Engenharia: Modelagem não-linear em estruturas civis"
                              ],
                              "realWorldApplication": "Em engenharia civil, resolve equações não-lineares para equilíbrio de estruturas (ex: deformações em vigas sob carga), onde convergência quadrática acelera simulações em software como ANSYS, reduzindo tempo de projeto de pontes ou barragens."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Identificar condições de convergência",
                            "description": "Listar requisitos como chute inicial próximo da raiz, f'(x) ≠ 0 na vizinhança, monotonicidade de f e analisar dependência no chute inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as condições teóricas básicas de convergência do Método de Newton-Raphson",
                                  "subSteps": [
                                    "Defina convergência local quadrática e explique que ela requer f contínua, f' diferenciável e f'(x*) ≠ 0, onde x* é a raiz simples.",
                                    "Liste as condições iniciais: função f duas vezes diferenciável na vizinhança da raiz.",
                                    "Discuta o teorema de convergência: se x0 está suficientemente próximo de x*, então a sequência converge quadráticamente.",
                                    "Identifique que f'' existe e é contínua para garantir Lipschitz de f'."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras das condições básicas sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de métodos numéricos (ex: Burden & Faires)",
                                    "Notas de aula sobre Newton-Raphson"
                                  ],
                                  "tips": "Comece pelo teorema principal para contextualizar as condições locais.",
                                  "learningObjective": "Compreender as premissas matemáticas fundamentais para convergência quadrática.",
                                  "commonMistakes": [
                                    "Confundir convergência quadrática com linear.",
                                    "Ignorar a necessidade de f' não nula na raiz."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a condição f'(x) ≠ 0 na vizinhança da raiz",
                                  "subSteps": [
                                    "Explique por que f'(x*) ≠ 0 garante raiz simples e evita singularidades na iteração x_{n+1} = x_n - f(x_n)/f'(x_n).",
                                    "Verifique graficamente: plote f e f' para uma função exemplo e identifique intervalos onde f' ≠ 0.",
                                    "Discuta o que acontece se f'(x) = 0: iterações param ou divergem.",
                                    "Teste numericamente: compute f' em pontos próximos à raiz estimada.",
                                    "Conclua que f' deve ser bounded away from zero na bacia de atração."
                                  ],
                                  "verification": "Para uma função dada, confirme se f' ≠ 0 em [a,b] contendo a raiz.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software como MATLAB ou Python (SymPy/NumPy)",
                                    "Calculadora gráfica"
                                  ],
                                  "tips": "Use o teste de derivada para confirmar não nulidade.",
                                  "learningObjective": "Identificar e validar a condição de derivada não nula como pré-requisito essencial.",
                                  "commonMistakes": [
                                    "Assumir f' ≠ 0 globalmente sem checar vizinhança.",
                                    "Confundir com f(x*) = 0."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar a importância do chute inicial próximo da raiz",
                                  "subSteps": [
                                    "Defina bacia de atração: conjunto de x0 que converge para x*.",
                                    "Teste com exemplos: para f(x) = x^2 - 2, compare x0=1.5 (converge) vs x0=10 (diverge).",
                                    "Analise dependência: meça erro |x1 - x*| em função de |x0 - x*|.",
                                    "Discuta heurísticas para bom chute: gráficos, bounds ou métodos auxiliares como bissecção.",
                                    "Sintetize: chute ruim leva a overflow, ciclos ou divergência."
                                  ],
                                  "verification": "Selecione e justifique um chute inicial bom para uma equação não-linear dada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou MATLAB para simulações",
                                    "Papel e lápis para gráficos manuais"
                                  ],
                                  "tips": "Sempre plote f(x) primeiro para visualizar raízes e derivadas.",
                                  "learningObjective": "Compreender e quantificar a sensibilidade ao chute inicial.",
                                  "commonMistakes": [
                                    "Escolher chute arbitrário sem análise gráfica.",
                                    "Subestimar o raio da bacia de atração."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar a monotonicidade de f e sintetizar todas as condições",
                                  "subSteps": [
                                    "Explique monotonicidade: f crescente ou decrescente na vizinhança acelera convergência.",
                                    "Verifique sinal de f': se f' > 0 ou f' < 0 consistentemente, favorece convergência.",
                                    "Integre condições: f'(x) ≠ 0 + chute próximo + monotonicidade ≈ convergência garantida localmente.",
                                    "Analise trade-offs: funções não monótonas podem convergir mas mais lentamente.",
                                    "Crie checklist: 1. f'≠0? 2. x0 próximo? 3. Monótona? 4. Dependência testada?"
                                  ],
                                  "verification": "Aplique checklist completo a uma nova função e preveja convergência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de checklist personalizada",
                                    "Exemplos de funções não-lineares"
                                  ],
                                  "tips": "Use intervalos pequenos para checar monotonicidade local.",
                                  "learningObjective": "Sintetizar todas as condições em uma análise integrada de convergência.",
                                  "commonMistakes": [
                                    "Ignorar monotonicidade em funções com múltiplas raízes.",
                                    "Não testar dependência com múltiplos chutes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em engenharia civil, resolva f(x) = x^3 - 3x^2 + 2x - 0.5 = 0 para encontrar deformação crítica em uma viga sob carga não-linear. Verifique: f'(x) = 3x^2 - 6x + 2 ≠ 0 (discriminante negativo, sempre positivo); chute x0=0.3 próximo da raiz ~0.25; f monótona crescente (f'>0); teste chutes x0=0.2 (converge em 4 iterações) vs x0=2 (diverge).",
                              "finalVerifications": [
                                "Liste corretamente as quatro condições principais sem erros.",
                                "Explique verbalmente o impacto de um chute inicial ruim com exemplo numérico.",
                                "Aplique checklist a uma função desconhecida e justifique previsão de convergência.",
                                "Identifique f'≠0 em vizinhança para pelo menos duas funções teste.",
                                "Discuta monotonicidade corretamente para funções convexas e côncavas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na enunciação de f'(x*) ≠ 0 e sua implicação em raízes simples (30%).",
                                "Análise qualitativa e quantitativa da dependência no chute inicial (25%).",
                                "Correta identificação de monotonicidade via f' e seu papel (20%).",
                                "Síntese integrada das condições em checklist acionável (15%).",
                                "Uso de exemplos concretos com verificações numéricas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Análise Numérica e Teoremas de Ponto Fixo.",
                                "Programação: Implementação de solvers em Python/MATLAB com análise de sensibilidade.",
                                "Física: Modelagem de equações não-lineares em dinâmica estrutural.",
                                "Estatística: Análise de erros e confiança em aproximações numéricas."
                              ],
                              "realWorldApplication": "Na engenharia civil, identificar condições de convergência no Método de Newton-Raphson é crucial para soluções confiáveis de equações não-lineares em análise de estruturas, como cálculo de deslocamentos em vigas curvas ou equilíbrio em fundações sob cargas sísmicas, evitando falhas computacionais que poderiam levar a dimensionamentos inseguros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Definir critérios de parada",
                            "description": "Implementar testes como |x_{n+1} - x_n| < ε, |f(x_{n+1})| < ε ou máximo de iterações, discutindo trade-offs entre precisão e eficiência computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Tipos de Critérios de Parada",
                                  "subSteps": [
                                    "Estude o critério de diferença entre iterações: |x_{n+1} - x_n| < ε (absoluto) ou |x_{n+1} - x_n| / |x_n| < ε (relativo).",
                                    "Analise o critério baseado no resíduo da função: |f(x_{n+1})| < ε.",
                                    "Revise o critério de máximo de iterações para evitar loops infinitos.",
                                    "Discuta quando cada critério é mais apropriado (ex.: relativo para valores grandes).",
                                    "Compare com soluções analíticas para validar compreensão."
                                  ],
                                  "verification": "Resuma em um parágrafo os três critérios principais e seus propósitos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de métodos numéricos, notas de aula sobre Newton-Raphson, calculadora.",
                                  "tips": "Use diagramas de fluxo para visualizar quando cada critério é acionado.",
                                  "learningObjective": "Identificar e diferenciar critérios de parada comuns em métodos iterativos.",
                                  "commonMistakes": "Confundir critério absoluto com relativo; ignorar normalização para escalas variáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Justificar Critérios para um Problema Específico",
                                  "subSteps": [
                                    "Escolha ε baseado na precisão necessária (ex.: 1e-6 para engenharia).",
                                    "Justifique uso de diferença absoluta vs. relativa com base na magnitude esperada da solução.",
                                    "Decida se usar resíduo da função para problemas onde f(x) é mais estável.",
                                    "Defina máximo de iterações (ex.: 100) considerando eficiência computacional.",
                                    "Documente trade-offs iniciais em uma tabela simples."
                                  ],
                                  "verification": "Crie uma tabela justificando escolhas de ε e critérios para um exemplo dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou planilha Excel para tabela de justificativas.",
                                  "tips": "Considere o contexto físico: precisão excessiva aumenta tempo sem ganho real.",
                                  "learningObjective": "Selecionar critérios otimizados para precisão e eficiência em contextos reais.",
                                  "commonMistakes": "Escolher ε muito pequeno sem considerar custo computacional; omitir máximo de iterações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Critérios no Algoritmo de Newton-Raphson",
                                  "subSteps": [
                                    "Modifique o loop do algoritmo adicionando if |x_new - x_old| < ε: break.",
                                    "Inclua verificação |f(x_new)| < ε como condição alternativa.",
                                    "Adicione contador de iterações e break se > max_iter.",
                                    "Implemente em pseudocódigo ou código (Python/MATLAB).",
                                    "Teste com chute inicial para garantir parada correta."
                                  ],
                                  "verification": "Execute o código com um exemplo e confirme que para nas condições certas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (Python com NumPy ou MATLAB), exemplo de função não-linear.",
                                  "tips": "Use print statements para logar valores de ε e iterações durante testes.",
                                  "learningObjective": "Integrar múltiplos critérios de parada em um algoritmo iterativo funcional.",
                                  "commonMistakes": "Erro de sintaxe no loop (ex.: esquecer atualização de x_old); usar < em vez de <=."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar os Critérios Implementados",
                                  "subSteps": [
                                    "Teste com diferentes ε (1e-3, 1e-6, 1e-9) e meça iterações e tempo.",
                                    "Varie chute inicial para verificar robustez da convergência.",
                                    "Compare solução numérica com valor exato ou analítico.",
                                    "Registre casos de não-convergência e ajuste max_iter.",
                                    "Gere gráfico de x_n vs. n para visualizar convergência."
                                  ],
                                  "verification": "Produza relatório com tabelas de testes mostrando parada correta e precisão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Matplotlib ou similar), dados de teste.",
                                  "tips": "Automatize testes em loop para múltiplos ε para eficiência.",
                                  "learningObjective": "Validar empiricamente a efetividade dos critérios em cenários variados.",
                                  "commonMistakes": "Ignorar divergência (ex.: oscilações); não testar com chutes ruins."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Trade-offs entre Precisão e Eficiência",
                                  "subSteps": [
                                    "Calcule tempo computacional vs. ε em testes.",
                                    "Discuta impactos: ε pequeno = mais iterações, mas precisão alta; risco de overflow.",
                                    "Avalie custo-benefício para aplicações em engenharia civil (ex.: tempo real vs. precisão).",
                                    "Proponha heurísticas para escolha automática de ε.",
                                    "Escreva conclusões sobre melhores práticas."
                                  ],
                                  "verification": "Elabore um ensaio curto (200 palavras) resumindo trade-offs observados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Resultados dos testes anteriores, processador de texto.",
                                  "tips": "Use métricas como FLOPs (operações de ponto flutuante) para quantificar eficiência.",
                                  "learningObjective": "Avaliar e otimizar trade-offs para decisões informadas em computação científica.",
                                  "commonMistakes": "Focar só em precisão ignorando tempo; generalizar de um exemplo isolado."
                                }
                              ],
                              "practicalExample": "Implemente Newton-Raphson para resolver f(x) = e^x - 3x^2 (modelo simplificado de equilíbrio em viga não-linear), com ε=1e-6, critério relativo |Δx|/|x| < ε OU |f(x)| < 1e-8, max_iter=50. Chute inicial x0=1. Verifique convergência em ~8 iterações para x≈0.619.",
                              "finalVerifications": [
                                "O algoritmo para corretamente quando pelo menos um critério é satisfeito.",
                                "Número de iterações ≤ max_iter em casos convergentes.",
                                "Erro absoluto final < ε em relação a solução conhecida.",
                                "Nenhum loop infinito ou divergência detectada em testes.",
                                "Logs mostram valores de Δx, f(x) e iterações antes da parada.",
                                "Solução é estável para variações de ±10% no chute inicial."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação de todos os critérios sem erros lógicos.",
                                "Justificativa clara e contextualizada para escolhas de ε e max_iter.",
                                "Análise quantitativa de trade-offs com dados de testes.",
                                "Validação com múltiplos cenários, incluindo não-convergência.",
                                "Explicação precisa de impactos na eficiência computacional.",
                                "Uso adequado de conceitos matemáticos (ex.: norma relativa)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de loops condicionais e controle de erros.",
                                "Análise Numérica: Teoria de convergência e análise de erros.",
                                "Otimização: Balanceamento de precisão vs. custo em algoritmos iterativos.",
                                "Engenharia Computacional: Aplicação em simulações FEM para estruturas."
                              ],
                              "realWorldApplication": "Na engenharia civil, critérios de parada são essenciais em análises não-lineares de estruturas, como cálculo de deslocamentos em pontes sob cargas dinâmicas ou flambagem de colunas, garantindo soluções precisas sem desperdício computacional em softwares como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Implementação Computacional e Aplicações",
                        "description": "Desenvolvimento de algoritmos em pseudocódigo ou linguagens como MATLAB/Python, tratamento de erros e exemplos em problemas de engenharia civil não-lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Escrever pseudocódigo do algoritmo",
                            "description": "Estruturar o loop iterativo com entrada de f, f', x0, tolerância ε e N_max, incluindo verificação de f'(x_n) ≈ 0 e saída com raiz aproximada ou mensagem de falha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir entradas, saídas e inicializações",
                                  "subSteps": [
                                    "Identifique as entradas necessárias: função f, derivada f', chute inicial x0, tolerância ε e número máximo de iterações N_max.",
                                    "Especifique as saídas possíveis: raiz aproximada ou mensagens de falha (derivada ≈0 ou iterações excedidas).",
                                    "Inicialize variáveis: defina x_n = x0 e contador n = 0.",
                                    "Escreva a seção de 'Input' e 'Initialize' no pseudocódigo.",
                                    "Adicione comentários explicando o propósito de cada entrada."
                                  ],
                                  "verification": "Verifique se todas as entradas estão listadas corretamente e variáveis inicializadas sem erros de sintaxe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples; referência ao algoritmo Newton-Raphson.",
                                  "tips": "Use notação clara como 'Input: f, fprime, x0, epsilon, Nmax' para facilitar leitura.",
                                  "learningObjective": "Compreender e documentar corretamente os parâmetros de entrada e estado inicial do algoritmo.",
                                  "commonMistakes": "Esquecer de incluir f' ou confundir ε com critério de precisão absoluta em f(x)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar o loop iterativo principal",
                                  "subSteps": [
                                    "Inicie um loop WHILE com condição n < N_max.",
                                    "Dentro do loop, calcule a iteração: x_{n+1} = x_n - f(x_n) / f'(x_n).",
                                    "Atualize x_n = x_{n+1} e incremente n = n + 1.",
                                    "Adicione estrutura para saída do loop após atualizações.",
                                    "Inclua comentários para cada linha do cálculo."
                                  ],
                                  "verification": "Simule uma iteração manualmente para confirmar que o cálculo de x_{n+1} está correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de pseudocódigo; calculadora para testes manuais.",
                                  "tips": "Use indentação consistente para destacar o corpo do loop e evitar confusão com blocos aninhados.",
                                  "learningObjective": "Implementar a fórmula iterativa central do método Newton-Raphson em pseudocódigo.",
                                  "commonMistakes": "Esquecer de atualizar x_n após o cálculo ou inverter a ordem de f/f'."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar verificações de convergência e falhas",
                                  "subSteps": [
                                    "Antes do cálculo iterativo, verifique se |f'(x_n)| < δ (use um pequeno δ, ex: 1e-10); se sim, saia com 'Falha: derivada ≈0'.",
                                    "Após calcular x_{n+1}, verifique se |x_{n+1} - x_n| < ε; se sim, saia com 'Raiz: x_{n+1}'.",
                                    "Adicione verificação fora do loop para 'Falha: N_max atingido' usando ELSE do WHILE.",
                                    "Posicione as verificações logicamente dentro do loop.",
                                    "Teste logicamente o fluxo com cenários de sucesso e falha."
                                  ],
                                  "verification": "Trace o fluxo com valores de exemplo: convergência rápida, falha por derivada zero e exaustão de iterações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Referência ao pseudocódigo padrão Newton-Raphson; fluxograma opcional.",
                                  "tips": "Defina δ explicitamente no início para clareza; use abs() para valores absolutos.",
                                  "learningObjective": "Incorporar condições de parada robustas para garantir convergência ou detecção de falhas.",
                                  "commonMistakes": "Colocar verificação de ε antes da primeira iteração ou ignorar ELSE do loop."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar e validar o pseudocódigo completo",
                                  "subSteps": [
                                    "Revise o pseudocódigo inteiro para consistência de variáveis e indentação.",
                                    "Adicione cabeçalho com título 'Pseudocódigo Método Newton-Raphson' e descrição breve.",
                                    "Simule execução completa com um exemplo numérico simples.",
                                    "Corrija qualquer incoerência lógica ou sintática.",
                                    "Documente suposições, como f e f' serem funções fornecidas."
                                  ],
                                  "verification": "O pseudocódigo roda sem loops infinitos em simulação e cobre todos os casos de saída.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Pseudocódigo draft; exemplo numérico pronto.",
                                  "tips": "Leia em voz alta para detectar falhas lógicas; use setas para fluxos condicionais.",
                                  "learningObjective": "Produzir um pseudocódigo polido, legível e funcionalmente correto.",
                                  "commonMistakes": "Variáveis não inicializadas ou saídas sem formatação clara."
                                }
                              ],
                              "practicalExample": "Para f(x) = x² - 2 (raiz √2 ≈1.414), f'(x)=2x, x0=1, ε=0.001, N_max=10, δ=1e-10. O pseudocódigo itera até |x_{n+1}-x_n|<0.001, output 'Raiz: 1.4142' após ~4 iterações.",
                              "finalVerifications": [
                                "Todas as entradas (f, f', x0, ε, N_max, δ) estão declaradas?",
                                "Loop WHILE inclui verificação f'≈0, critério de convergência e atualização correta?",
                                "Saídas corretas para convergência, derivada zero e N_max excedido?",
                                "Variáveis atualizadas logicamente sem sobrescrita prematura?",
                                "Comentários explicam cada seção majoritária?",
                                "Indentação consistente e sintaxe pseudocódigo padrão?"
                              ],
                              "assessmentCriteria": [
                                "Precisão da fórmula iterativa x_{n+1} = x_n - f(x_n)/f'(x_n) (obrigatório).",
                                "Cobertura completa de condições de falha (f'≈0 e N_max).",
                                "Critério de convergência baseado em |Δx| < ε.",
                                "Estrutura legível com inicializações, loop e saídas claras.",
                                "Uso apropriado de controle de fluxo (WHILE, IF, ELSE).",
                                "Ausência de erros lógicos detectáveis por simulação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial (derivadas) e análise numérica.",
                                "Programação: Estruturas de controle (loops, condicionais) em pseudocódigo.",
                                "Engenharia Civil: Modelagem de equações não-lineares em estruturas (ex: flambagem de colunas).",
                                "Física: Equilíbrios não-lineares em mecânica de materiais."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usado para resolver equações não-lineares em análise de estruturas, como calcular deformações em vigas sob cargas não-lineares ou pontos de equilíbrio em sistemas de cabos, otimizando projetos de pontes e edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Implementar em ambiente computacional",
                            "description": "Codificar o método em MATLAB ou Python para uma equação não-linear exemplo, plotando iterações e verificando convergência com tabela de erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e definir funções matemáticas",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias: numpy para cálculos numéricos e matplotlib para plotagem.",
                                    "Definir a função não-linear f(x), por exemplo, f(x) = x^3 - 2x - 5.",
                                    "Definir a derivada analítica f'(x), por exemplo, f'(x) = 3x^2 - 2.",
                                    "Escolher chute inicial x0 e critérios de parada (tolerância e máximo de iterações).",
                                    "Criar listas vazias para armazenar histórico de iterações e erros."
                                  ],
                                  "verification": "Executar definições sem erros de sintaxe e imprimir f(x0) e f'(x0) para confirmação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy e Matplotlib instalados; editor como Jupyter Notebook ou VS Code.",
                                  "tips": "Use funções lambda para f e df para simplicidade em protótipos.",
                                  "learningObjective": "Compreender e codificar representações matemáticas precisas em código.",
                                  "commonMistakes": "Erros na derivada analítica levando a não convergência; esquecer importações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o loop de iteração do Método de Newton-Raphson",
                                  "subSteps": [
                                    "Inicializar x_atual = x0 e iter = 0.",
                                    "Iniciar loop while: calcular f(x_atual) e df(x_atual).",
                                    "Atualizar x_novo = x_atual - f(x_atual)/df(x_atual).",
                                    "Calcular erro absoluto |x_novo - x_atual| e append histórico.",
                                    "Incrementar iter e verificar critérios de parada (erro < tol ou iter > max_iter)."
                                  ],
                                  "verification": "Rodar loop com x0=1 e verificar se gera pelo menos 5 iterações convergindo para ~2.0946.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código do Step 1; calculadora para validar manualmente 1-2 iterações.",
                                  "tips": "Adicione print no loop para debug visual das iterações.",
                                  "learningObjective": "Dominar a lógica iterativa do algoritmo e controle de convergência.",
                                  "commonMistakes": "Divisão por zero se df(x)=0; loop infinito sem max_iter."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar tabela de erros e plotagem das iterações",
                                  "subSteps": [
                                    "Criar array numpy com histórico de x e erros.",
                                    "Usar pandas para formatar tabela: colunas Iteração, x_n, Erro Absoluto.",
                                    "Plotar gráfico: eixo x=iterações, y1=x_n, y2=erro logarítmico.",
                                    "Adicionar linha horizontal para raiz aproximada e labels/título.",
                                    "Exibir/salvar tabela e gráfico."
                                  ],
                                  "verification": "Tabela mostra erros decrescendo; gráfico converge quadraticamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Pandas para tabelas; histórico do Step 2.",
                                  "tips": "Use plt.semilogy para erro log para visualizar convergência quadrática.",
                                  "learningObjective": "Visualizar e analisar numericamente o comportamento do método.",
                                  "commonMistakes": "Escala errada no plot ocultando convergência; erros de indexação no histórico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar implementação e testar robustez",
                                  "subSteps": [
                                    "Testar com diferentes x0 (ex: 0, 3) e observar convergência/bacia de atração.",
                                    "Comparar com solução analítica ou fsolve do SciPy.",
                                    "Analisar taxa de convergência via log(erros) plot.",
                                    "Documentar código com comentários e função reutilizável.",
                                    "Exportar resultados para relatório (PNG da tabela/gráfico)."
                                  ],
                                  "verification": "Código converge para múltiplos x0; erro final < 1e-6 em <20 iterações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "SciPy para validação; múltiplos x0.",
                                  "tips": "Encapsule em def newton_raphson(f, df, x0, tol=1e-6, max_iter=50).",
                                  "learningObjective": "Avaliar confiabilidade e preparar para aplicações reais.",
                                  "commonMistakes": "Não testar x0 ruins causando divergência; ignorar precisão numérica."
                                }
                              ],
                              "practicalExample": "Implemente em Python para f(x) = x^3 - 2x - 5 = 0 com x0=1. O código deve outputar tabela: Iter | x | Erro\n1 | 2.5 | 1.5\n... final x≈2.0945514815423265, erro<1e-10. Plote x vs iter e log(erro) mostrando convergência quadrática.",
                              "finalVerifications": [
                                "Código executa sem erros e converge em <20 iterações.",
                                "Tabela exibe erros decrescendo monotonicamente.",
                                "Gráfico mostra aproximação à raiz e erro caindo quadraticamente.",
                                "Testes com 3 x0 diferentes confirmam robustez.",
                                "Função f(x_final) ≈ 0 dentro de tolerância.",
                                "Documentação inclui comentários em funções críticas."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro final < 1e-8.",
                                "Eficiência: Máximo 30 iterações para convergência.",
                                "Visualização: Plots claros com labels, legendas e escalas adequadas.",
                                "Robustez: Trata df(x)=0 e max_iter.",
                                "Código limpo: Função modular, comentários e PEP8.",
                                "Análise: Interpreta taxa de convergência corretamente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial (derivadas) e análise numérica.",
                                "Programação: Estruturas de loop, funções e bibliotecas científicas.",
                                "Engenharia Civil: Modelagem de não-linearidades em estruturas/vigas.",
                                "Estatística: Análise de erros e validação numérica."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usado para resolver equações não-lineares em análise de estruturas (ex: equilíbrio não-linear de vigas), ajuste de curvas em ensaios geotécnicos ou otimização hidráulica em reservatórios, onde iterações rápidas evitam simulações caras."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Aplicar a problemas de engenharia civil",
                            "description": "Resolver equação não-linear de equilíbrio em estruturas (ex. viga com não-linearidade material) ou ajuste de curvas experimentais, comparando com soluções exatas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema de engenharia civil como equação não-linear",
                                  "subSteps": [
                                    "Identifique o problema específico, como equilíbrio de uma viga com não-linearidade material (ex: lei de Hooke não-linear σ = E ε^3).",
                                    "Defina as variáveis: carga P, comprimento L, módulo E, seção transversal A, e derive a equação f(δ) = 0 onde δ é a deflexão.",
                                    "Escreva explicitamente a função f(x) e sua derivada f'(x) para o Método de Newton-Raphson.",
                                    "Para ajuste de curvas, colete dados experimentais de deformação vs. carga e defina o resíduo r(θ) = dados - modelo(θ).",
                                    "Documente suposições e condições de contorno (ex: viga engastada)."
                                  ],
                                  "verification": "Verifique se f(x) e f'(x) estão corretas calculando manualmente para um x inicial e comparando com teoria.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel e caneta, livro de mecânica das estruturas, software de simbólico como SymPy (opcional).",
                                  "tips": "Comece com um modelo simples para evitar complexidade inicial.",
                                  "learningObjective": "Capacitar o aluno a traduzir problemas físicos reais em equações não-lineares matemáticas.",
                                  "commonMistakes": "Esquecer unidades consistentes ou derivar incorretamente f'(x)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o algoritmo de Newton-Raphson em código",
                                  "subSteps": [
                                    "Escreva uma função Python que recebe f, f_prime, x0 (chute inicial), tolerância ε e itmax (máx iterações).",
                                    "Implemente o loop: x_new = x_old - f(x_old)/f'(x_old), cheque |x_new - x_old| < ε ou iterações excedidas.",
                                    "Adicione tratamento de erros: div-by-zero, não-convergência, imprimir histórico de iterações.",
                                    "Teste com equação simples como f(x) = x^2 - 2 (raiz √2).",
                                    "Otimize com NumPy para vetores se aplicável a múltiplas raízes."
                                  ],
                                  "verification": "Execute com f(x)=x^2-2, confirme convergência para ≈1.414 em <10 iterações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python com NumPy e Matplotlib, Jupyter Notebook.",
                                  "tips": "Use print statements para debugar o loop de iterações.",
                                  "learningObjective": "Desenvolver proficiência em codificar iterativos numéricos robustos.",
                                  "commonMistakes": "Chute inicial ruim levando a divergência; não checar tolerância corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o método ao problema de viga com não-linearidade material",
                                  "subSteps": [
                                    "Defina f(δ) = (E A / L) * δ^3 - P para viga simples (equilíbrio não-linear).",
                                    "Escolha x0 = 0.1 * L (chute razoável), ε=1e-6, itmax=50.",
                                    "Execute o código e plote histórico de δ vs. iteração.",
                                    "Para ajuste de curvas: minimize resíduo com dados simulados/experimentais de carga-deflexão.",
                                    "Salve resultados: raiz final, número de iterações, tempo de CPU."
                                  ],
                                  "verification": "Confirme que solução física faz sentido (ex: δ aumenta com P, converge rapidamente).",
                                  "estimatedTime": "1 hora",
                                  "materials": "Código do Step 2, dados experimentais fictícios ou reais de ensaios de tração.",
                                  "tips": "Plote f(x) para visualizar atração da raiz.",
                                  "learningObjective": "Aplicar numéricamente soluções a modelos estruturais não-lineares.",
                                  "commonMistakes": "Não-linearidade mal modelada levando a raízes não-físicas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com soluções exatas e validar resultados",
                                  "subSteps": [
                                    "Derive ou encontre solução exata (ex: para cubica, use fórmula de Cardano ou aproximação linear).",
                                    "Calcule erro relativo |x_num - x_exata| / |x_exata| e convergência quadrática.",
                                    "Para ajuste de curvas, compute R^2 e resíduo médio quadrático (RMS).",
                                    "Realize análise de sensibilidade: varie x0, ε, parâmetros materiais.",
                                    "Gere relatório com gráficos: solução numérica vs. exata, curvas experimentais."
                                  ],
                                  "verification": "Erro < 0.1% e ordem de convergência ≈2 confirmada pelo log-log plot.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Matplotlib para plots, SciPy para soluções exatas opcionais.",
                                  "tips": "Use múltiplos x0 para testar robustez da bacia de atração.",
                                  "learningObjective": "Avaliar precisão e confiabilidade de métodos numéricos em contextos reais.",
                                  "commonMistakes": "Comparar com solução errada ou ignorar erros de arredondamento."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explorar extensões e aplicações adicionais",
                                  "subSteps": [
                                    "Aplique a outro problema: pórtico com grandes deslocamentos ou ajuste de curvas de fadiga.",
                                    "Implemente acelerações: linha de secante ou modificações para f'≈0.",
                                    "Integre com FEA simples (ex: via código ou ANSYS input).",
                                    "Discuta limitações: singularidades, múltiplas raízes.",
                                    "Prepare apresentação com código fonte e resultados."
                                  ],
                                  "verification": "Código roda sem erros em 2+ problemas e relatório cobre limitações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código anterior, referências de FEA básica.",
                                  "tips": "Salve código modular para reutilização.",
                                  "learningObjective": "Generalizar o método para portfólio de problemas civis.",
                                  "commonMistakes": "Sobre-generalizar sem validar novos casos."
                                }
                              ],
                              "practicalExample": "Em uma viga de concreto engastada de L=5m, A=0.1m², E=30GPa sob P=100kN com σ= E ε^{1.5}, resolver δ tal que f(δ)=(E A /L) δ^{1.5} * (3/2) - P =0. Newton-Raphson converge de δ0=0.01m para δ≈0.023m em 5 iterações, vs. exata ≈0.0228m (erro 1%).",
                              "finalVerifications": [
                                "Código converge para todos testes com <20 iterações e erro <1e-5.",
                                "Resultados físicos coerentes (ex: δ proporcional a P^{2/3}).",
                                "Gráficos mostram convergência quadrática.",
                                "Análise de sensibilidade documentada.",
                                "Relatório inclui código fonte e discussões de erros.",
                                "Aplicação a ajuste de curvas com R^2 >0.99."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução numérica (erro relativo <0.1%).",
                                "Eficiência computacional (iterações <15, tempo <1s).",
                                "Robustez a variações de parâmetros e x0.",
                                "Qualidade de visualizações e documentação.",
                                "Correta derivação de f e f' para problemas civis.",
                                "Identificação e mitigação de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica e cálculo diferencial.",
                                "Física: Mecânica dos sólidos e não-linearidades materiais.",
                                "Programação: Desenvolvimento de algoritmos iterativos em Python.",
                                "Estatística: Ajuste de curvas e validação experimental.",
                                "Gestão de Projetos: Análise de sensibilidade em engenharia."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios altos, onde não-linearidades materiais (plastificação) ou geométricas afetam o equilíbrio; usado em softwares como SAP2000 para prever colapsos, otimizando designs seguros e econômicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Método da Secante",
                    "description": "Variante do Newton-Raphson que aproxima a derivada por uma diferença finita para resolver equações não-lineares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Fundamentos do Método da Secante",
                        "description": "Introdução ao método da secante como variante do método de Newton-Raphson, que substitui a derivada analítica por uma aproximação via diferença finita entre duas iterações sucessivas, ideal para equações não-lineares f(x) = 0 sem derivada explícita.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Diferenciar Método da Secante do Newton-Raphson",
                            "description": "Comparar as fórmulas iterativas, destacando que o secante usa (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1})) em vez da derivada f'(x_n), e identificar cenários onde o secante é preferível, como ausência de derivada analítica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Newton-Raphson",
                                  "subSteps": [
                                    "Estude a fórmula iterativa: x_{n+1} = x_n - f(x_n) / f'(x_n)",
                                    "Entenda que requer a derivada analítica f'(x)",
                                    "Implemente um exemplo simples em uma planilha ou código para visualizar iterações",
                                    "Observe a convergência quadrática sob condições ideais",
                                    "Registre o número de iterações para uma função teste como f(x) = x^2 - 2"
                                  ],
                                  "verification": "Capacidade de escrever e explicar a fórmula corretamente, com um exemplo resolvido manualmente em 3 iterações",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de cálculo (Excel ou Google Sheets)",
                                    "Calculadora",
                                    "Referência teórica de métodos numéricos"
                                  ],
                                  "tips": "Comece com uma função simples onde a derivada é conhecida para construir confiança",
                                  "learningObjective": "Compreender os fundamentos e requisitos do método de Newton-Raphson",
                                  "commonMistakes": [
                                    "Confundir a ordem da subtração na fórmula",
                                    "Esquecer de calcular a derivada corretamente",
                                    "Não verificar se f'(x_n) ≠ 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Método da Secante",
                                  "subSteps": [
                                    "Aprenda a fórmula: x_{n+1} = x_n - f(x_n) * (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1}))",
                                    "Note que usa dois pontos iniciais x_0 e x_1, sem derivada explícita",
                                    "Aproxime a derivada por diferença finita: (f(x_n) - f(x_{n-1})) / (x_n - x_{n-1})",
                                    "Implemente o algoritmo passo a passo para a mesma função f(x) = x^2 - 2",
                                    "Compare visualmente a aproximação da reta secante com a tangente de Newton"
                                  ],
                                  "verification": "Implementar a fórmula em código ou planilha e obter raiz aproximada em 5 iterações",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha eletrônica",
                                    "Editor de código simples (Python ou MATLAB)",
                                    "Gráficos de funções"
                                  ],
                                  "tips": "Escolha x_0 e x_1 próximos da raiz para melhor convergência inicial",
                                  "learningObjective": "Dominar a formulação e mecanismo de aproximação do método da secante",
                                  "commonMistakes": [
                                    "Dividir por zero se f(x_n) = f(x_{n-1})",
                                    "Confundir índices n e n-1",
                                    "Usar apenas um chute inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Fórmulas Iterativas",
                                  "subSteps": [
                                    "Escreva lado a lado as fórmulas de Newton e Secante, destacando f'(x_n) vs. diferença finita",
                                    "Analise similaridades: ambos são métodos de ponto fixo baseados em inversa linear local",
                                    "Discuta diferenças: Secante evita computação de derivada, mas requer dois pontos iniciais",
                                    "Calcule numericamente para f(x) = e^x - 3x^2, contando iterações e precisão",
                                    "Crie uma tabela comparativa de iterações, erros e tempo computacional"
                                  ],
                                  "verification": "Produzir uma tabela comparativa com pelo menos 3 funções teste mostrando diferenças chave",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha para tabelas",
                                    "Software de plotagem (Desmos ou Python Matplotlib)"
                                  ],
                                  "tips": "Use tolerância de erro 10^-6 para parar iterações e comparar eficiência",
                                  "learningObjective": "Identificar e explicar diferenças precisas nas fórmulas e mecanismos",
                                  "commonMistakes": [
                                    "Ignorar a necessidade de dois chutes no secante",
                                    "Achar que secante é sempre mais lento sem testar",
                                    "Não normalizar erros adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Cenários de Preferência do Secante",
                                  "subSteps": [
                                    "Liste vantagens: Não precisa derivada analítica (útil em funções black-box)",
                                    "Discuta desvantagens: Convergência superlinear (ordem ~1.618) vs. quadrática de Newton",
                                    "Teste cenários: Função sem derivada fechada, como piecewise ou experimental",
                                    "Avalie em engenharia civil: Modelos não-lineares de estruturas sem derivadas explícitas",
                                    "Conclua com critérios: Prefira secante se derivada cara ou inexistente"
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito 3 cenários onde secante é superior, com justificativa",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Casos de estudo de engenharia",
                                    "Documentação de software numérico (SciPy)"
                                  ],
                                  "tips": "Considere custo computacional: derivadas numéricas podem ser imprecisas",
                                  "learningObjective": "Avaliar contextos práticos para escolha entre métodos",
                                  "commonMistakes": [
                                    "Superestimar velocidade do secante sem dados",
                                    "Ignorar sensibilidade a chutes iniciais",
                                    "Confundir com método da falsa posição"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva f(x) = x^3 - 2x - 5 = 0 (raiz ~2.094). Newton: chutes x0=2, derivada f'(x)=3x^2-2, 4 iterações para 10^-6. Secante: x0=2, x1=3, 5 iterações. Compare tabelas de iterações e note ausência de derivada no secante.",
                              "finalVerifications": [
                                "Explicar diferença chave na fórmula sem consultar notas",
                                "Implementar ambos métodos em código para nova função e comparar resultados",
                                "Identificar corretamente 2 cenários onde secante é preferível",
                                "Criar tabela comparativa de convergência para f(x)=sen(x)-x/2",
                                "Discutir limitações como divisão por zero no secante",
                                "Verificar ordem de convergência teórica para cada método"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das fórmulas (100% correto)",
                                "Qualidade da tabela comparativa (clareza e completude)",
                                "Correta identificação de pelo menos 3 vantagens/desvantagens",
                                "Efetividade no exemplo prático (erro <10^-5)",
                                "Profundidade na análise de cenários reais",
                                "Criatividade em conexões interdisciplinares"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python (bibliotecas SciPy/NumPy)",
                                "Engenharia Civil: Análise não-linear de vigas e estruturas",
                                "Cálculo Numérico: Aproximações de derivadas em otimização",
                                "Física: Solução de equações de equilíbrio dinâmico",
                                "Estatística: Ajuste de curvas experimentais sem derivadas analíticas"
                              ],
                              "realWorldApplication": "Em engenharia civil, o método da secante é usado em softwares como SAP2000 para resolver equações não-lineares de deformação em fundações ou pontes, onde modelos empíricos não possuem derivadas analíticas fáceis, economizando tempo de computação em simulações de grandes estruturas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Identificar Condições Iniciais para o Método",
                            "description": "Selecionar dois pontos iniciais x_0 e x_1 próximos da raiz, verificando que f(x_0) * f(x_1) < 0 para garantir mudança de sinal, e discutir tolerâncias para critério de parada (ex: |x_{n+1} - x_n| < ε).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Teorema de Bolzano para Garantia de Raiz",
                                  "subSteps": [
                                    "Estude o Teorema de Bolzano: se f é contínua em [a,b] e f(a)*f(b)<0, existe pelo menos uma raiz em (a,b).",
                                    "Analise por que a mudança de sinal é crucial para métodos de bisseção e secante.",
                                    "Grafique uma função exemplo como f(x)=x^3 - x para visualizar intervalos com mudança de sinal.",
                                    "Discuta limitações: a função deve ser contínua; singularidades invalidam.",
                                    "Resuma em suas palavras a importância para convergência do método da secante."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o teorema e dê um contraexemplo onde não há mudança de sinal mas existe raiz.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Cálculo Numérico, software de graficação (Desmos ou GeoGebra), papel e lápis.",
                                  "tips": "Sempre verifique continuidade plotando a função primeiro.",
                                  "learningObjective": "Entender a base teórica que garante a existência de uma raiz no intervalo inicial.",
                                  "commonMistakes": "Ignorar descontinuidades na função ou assumir mudança de sinal sem calcular f(x0) e f(x1)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar Pontos Iniciais x0 e x1 Próximos da Raiz Estimada",
                                  "subSteps": [
                                    "Estime a raiz aproximada usando inspeção gráfica ou método analítico grosseiro.",
                                    "Escolha x0 e x1 no mesmo lado da raiz estimada, mas próximos (distância < 10% do intervalo esperado).",
                                    "Calcule f(x0) e f(x1) numericamente com precisão de pelo menos 4 casas decimais.",
                                    "Ajuste os pontos iterativamente se necessário, testando pares vizinhos.",
                                    "Documente a escolha com justificativa baseada em gráfico ou tabela de valores."
                                  ],
                                  "verification": "Apresente gráfico ou tabela mostrando x0, x1 próximos da raiz e cálculos de f(x0), f(x1).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora científica, planilha Excel ou Python (NumPy para avaliação de funções), gráfico da função.",
                                  "tips": "Comece com um intervalo amplo e refine visualmente para eficiência.",
                                  "learningObjective": "Selecionar pontos iniciais otimizados para convergência rápida no método da secante.",
                                  "commonMistakes": "Escolher pontos muito distantes, levando a convergência lenta ou divergência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a Condição de Mudança de Sinal f(x0) * f(x1) < 0",
                                  "subSteps": [
                                    "Compute f(x0) e f(x1) com precisão alta.",
                                    "Multiplique os valores e confirme se o produto é negativo.",
                                    "Se positivo, ajuste x0 ou x1 para o outro lado da raiz estimada e recalcule.",
                                    "Registre o sinal de cada f(xi) em uma tabela para rastreamento.",
                                    "Confirme com gráfico que os pontos straddlam a raiz."
                                  ],
                                  "verification": "Mostre cálculos exatos: f(x0) = ?, f(x1) = ?, produto = ? < 0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora ou script Python simples: def f(x): return x**2 - 2",
                                  "tips": "Use sinal (+/-) em vez de valores absolutos para verificação rápida.",
                                  "learningObjective": "Aplicar corretamente o teste de mudança de sinal para validar o intervalo inicial.",
                                  "commonMistakes": "Erro de sinal aritmético ou confundir com f(x0)*f(x1) > 0 (mesmo sinal)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Critérios de Parada e Tolerâncias Adequadas",
                                  "subSteps": [
                                    "Escolha ε (tolerância) baseada na precisão necessária: 10^-6 para engenharia geral.",
                                    "Defina critério |x_{n+1} - x_n| < ε para convergência da secante.",
                                    "Considere critério alternativo |f(x_n)| < δ para precisão na função.",
                                    "Estabeleça máximo de iterações (ex: 50) para evitar loops infinitos.",
                                    "Justifique escolhas com exemplos de precisão em problemas de engenharia civil."
                                  ],
                                  "verification": "Escreva os critérios em pseudocódigo e teste com valores numéricos simulados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel para pseudocódigo, exemplos de problemas numéricos de livros.",
                                  "tips": "Tolerâncias muito pequenas causam iterações excessivas; teste com ε=10^-3 primeiro.",
                                  "learningObjective": "Configurar parâmetros de parada que garantam precisão sem ineficiência computacional.",
                                  "commonMistakes": "Escolher ε muito pequeno sem hardware adequado ou ignorar máximo de iterações."
                                }
                              ],
                              "practicalExample": "Para f(x) = x^3 - 2x - 5 = 0 (raiz ≈2.094), selecione x0=2 (f(2)=-1), x1=3 (f(3)=16), produto=-16<0. Use ε=10^-6 e max_iter=20. A secante converge rapidamente para a raiz.",
                              "finalVerifications": [
                                "x0 e x1 estão próximos da raiz estimada (distância <0.5 unidades)?",
                                "f(x0)*f(x1) < 0 confirmado com cálculos precisos?",
                                "Gráfico mostra straddling da raiz?",
                                "Critérios de parada definidos com ε apropriado e max_iter?",
                                "Justificativa teórica (Bolzano) documentada?",
                                "Teste simulado de uma iteração inicial funciona?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção de x0/x1: 30% (proximidade e mudança de sinal)",
                                "Compreensão teórica: 25% (explicação de Bolzano e limitações)",
                                "Definição de tolerâncias: 20% (adequação ao contexto de engenharia)",
                                "Documentação e verificações: 15% (tabelas, gráficos claros)",
                                "Exemplo prático executado: 10% (convergência demonstrada)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com NumPy para automação.",
                                "Análise Gráfica: Usar ferramentas de visualização como Matplotlib.",
                                "Estatística: Relacionar com ajuste de curvas não-lineares.",
                                "Física: Aplicar em equações de equilíbrio de estruturas."
                              ],
                              "realWorldApplication": "Em engenharia civil, identificar condições iniciais para calcular deformações não-lineares em vigas sob grandes cargas, garantindo precisão em simulações de estruturas como pontes ou edifícios altos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Reconhecer Limitações do Método da Secante",
                            "description": "Analisar casos de falha, como quando f(x_n) ≈ f(x_{n-1}) levando a divisão por zero, e comparar com métodos de bissecção para intervalos garantidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Fórmula e Dependências do Método da Secante",
                                  "subSteps": [
                                    "Examine a fórmula iterativa: x_{n+1} = x_n - f(x_n) * (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1}))",
                                    "Identifique os termos no denominador: f(x_n) - f(x_{n-1})",
                                    "Discuta a suposição implícita de que f(x_n) ≠ f(x_{n-1})",
                                    "Revise requisitos iniciais: dois pontos iniciais x_0 e x_1 com f(x_0) ≠ f(x_1)",
                                    "Analise a ordem de convergência aproximada (superlinear, ~1.618)"
                                  ],
                                  "verification": "Escreva a fórmula completa e circule o denominador potencialmente problemático.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora gráfica",
                                    "Referência ao pseudocódigo do método da secante"
                                  ],
                                  "tips": "Sempre verifique os valores iniciais antes de iniciar iterações.",
                                  "learningObjective": "Compreender matematicamente onde o método pode falhar devido à estrutura da fórmula.",
                                  "commonMistakes": [
                                    "Ignorar a diferença nos valores da função nos pontos iniciais",
                                    "Confundir com método de Newton, que usa derivada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Casos Críticos de Falha",
                                  "subSteps": [
                                    "Defina o caso principal: quando f(x_n) ≈ f(x_{n-1}), levando a denominador próximo de zero",
                                    "Explore cenários: função com derivada zero local (plataforma), pontos iniciais ruins",
                                    "Classifique falhas: divergência lenta, oscilação ou parada abrupta",
                                    "Registre condições: |f(x_n) - f(x_{n-1})| < ε (tolerância numérica)",
                                    "Discuta impacto em precisão numérica finita"
                                  ],
                                  "verification": "Liste 3 cenários específicos onde o denominador é zero ou muito pequeno.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para testes rápidos",
                                    "Gráficos de funções exemplo (ex: f(x) = x^3 - x)"
                                  ],
                                  "tips": "Use plots para visualizar quando f(x) é plana entre iterações.",
                                  "learningObjective": "Reconhecer padrões que causam falhas matemáticas no método.",
                                  "commonMistakes": [
                                    "Atribuir falha apenas a raízes múltiplas, ignorando valores de função iguais",
                                    "Não considerar erros de arredondamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular e Analisar Exemplos Numéricos de Falha",
                                  "subSteps": [
                                    "Selecione f(x) = sin(x) - x/2 com x0=1, x1=1.0001 (f próximas)",
                                    "Execute 5 iterações manualmente ou via código, observe denominador",
                                    "Compare com perturbação: altere x1 ligeiramente e veja sensibilidade",
                                    "Registre número de iterações até falha vs. sucesso",
                                    "Documente saídas: NaN ou overflow"
                                  ],
                                  "verification": "Produza tabela com iterações mostrando falha explícita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software Python (NumPy) ou MATLAB",
                                    "Notebook Jupyter para simulação"
                                  ],
                                  "tips": "Implemente uma verificação if abs(f(xn) - f(xnm1)) < 1e-10: abortar.",
                                  "learningObjective": "Aplicar conhecimento teórico em simulações práticas de falha.",
                                  "commonMistakes": [
                                    "Escolher pontos iniciais que sempre convergem, mascarando limitações",
                                    "Ignorar mensagens de erro numéricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Método da Bissecção e Conclusões",
                                  "subSteps": [
                                    "Revise bissecção: requer intervalo [a,b] com f(a)f(b)<0, convergência linear garantida",
                                    "Aplique bissecção ao mesmo exemplo da secante falha",
                                    "Compare: garantias (bissecção sempre converge no intervalo), velocidade (secante mais rápida quando funciona)",
                                    "Discuta híbridos: secante com fallback para bissecção",
                                    "Defina regras: use bissecção para robustez, secante para velocidade"
                                  ],
                                  "verification": "Crie tabela comparativa: convergência, requisitos, exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código fonte de ambos métodos",
                                    "Gráficos de convergência (eixo: iterações vs. erro)"
                                  ],
                                  "tips": "Sempre bracket a raiz primeiro com bissecção antes de secante.",
                                  "learningObjective": "Avaliar trade-offs e escolher método apropriado por caso.",
                                  "commonMistakes": [
                                    "Superestimar velocidade da secante sem testar falhas",
                                    "Confundir garantias: bissecção não precisa de derivadas implícitas"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao resolver f(x) = x^3 - 2x + 1 = 0 com x0 = 0.5, x1 = 0.5001 (f(x0) ≈ f(x1) ≈ 0.375), a iteração 1 resulta em denominador ~1e-5, propagando erros e divergindo após 3 passos; bissecção em [-2,1] converge em 15 iterações.",
                              "finalVerifications": [
                                "Explicar verbalmente causa raiz da divisão por zero",
                                "Simular falha em código e abortar corretamente",
                                "Comparar 2 exemplos: um falha secante (sucesso bissecção)",
                                "Listar 3 vantagens da bissecção sobre secante",
                                "Propor estratégia híbrida para software de engenharia"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do denominador como fonte de falha (100%)",
                                "Qualidade de exemplos numéricos com tabelas/gráficos (80%)",
                                "Profundidade na comparação com bissecção (90%)",
                                "Clareza em regras de uso contextual (85%)",
                                "Criatividade em aplicações reais de engenharia civil (75%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/MATLAB com tratamento de erros",
                                "Análise de Dados: Sensibilidade numérica em ajustes de curvas experimentais",
                                "Engenharia Computacional: Robustez em solvers de FEA (Finite Element Analysis)",
                                "Estatística: Análise de incerteza em aproximações iterativas",
                                "Física Aplicada: Modelagem não-linear de estruturas civis sob carga"
                              ],
                              "realWorldApplication": "Em engenharia civil, ao calcular deslocamentos não-lineares em vigas sob grandes deflexões (equação f(u) = EI u''' - P(u) = 0), falhas na secante por plataformas na carga podem causar crashes em software; optar por bissecção garante convergência segura para projetos de pontes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Fórmula Iterativa e Algoritmo",
                        "description": "Derivação e aplicação da fórmula de iteração do método da secante: x_{n+1} = x_n - f(x_n) * (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1})), incluindo pseudocódigo para implementação computacional.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Derivar a Fórmula do Método da Secante",
                            "description": "Partir da reta secante interpolando f(x_{n-1}) e f(x_n), encontrar interseção com eixo x via fórmula de Lagrange de ordem 1, resultando em x_{n+1} = [x_{n-1} f(x_n) - x_n f(x_{n-1})] / [f(x_n) - f(x_{n-1})].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito da Reta Secante",
                                  "subSteps": [
                                    "Defina os pontos iniciais x_{n-1} e x_n com seus valores de função f(x_{n-1}) e f(x_n).",
                                    "Visualize graficamente a reta que passa por esses dois pontos no plano cartesiano.",
                                    "Explique que a reta secante aproxima a função f(x) localmente entre os pontos.",
                                    "Discuta por que essa reta intersecta o eixo x próximo à raiz da função.",
                                    "Esboce um gráfico simples à mão ou em software para ilustrar."
                                  ],
                                  "verification": "Desenhe ou descreva corretamente o gráfico da reta secante passando pelos pontos e aproximando a curva.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis ou software de graficação como Desmos/GeoGebra",
                                    "Função exemplo f(x) = x² - 2"
                                  ],
                                  "tips": "Escolha pontos próximos à raiz estimada para melhor visualização.",
                                  "learningObjective": "Entender geometricamente a base do método da secante como interpolação linear.",
                                  "commonMistakes": "Confundir secante com tangente (que usa derivada); secante usa dois pontos finitos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Equação da Reta Secante via Interpolação de Lagrange Ordem 1",
                                  "subSteps": [
                                    "Lembre a fórmula geral de Lagrange para dois pontos: P_1(x) = f(x_{n-1}) * (x - x_n)/(x_{n-1} - x_n) + f(x_n) * (x - x_{n-1})/(x_n - x_{n-1}).",
                                    "Substitua os índices para clareza: P(x) = y_{n-1} * (x - x_n)/(x_{n-1} - x_n) + y_n * (x - x_{n-1})/(x_n - x_{n-1}), onde y_i = f(x_i).",
                                    "Simplifique os denominadores reconhecendo que (x_{n-1} - x_n) = - (x_n - x_{n-1}).",
                                    "Verifique que P(x_{n-1}) = f(x_{n-1}) e P(x_n) = f(x_n).",
                                    "Expanda a expressão para forma y = mx + b."
                                  ],
                                  "verification": "Confirme que a equação interpolada passa exatamente pelos dois pontos dados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de cálculo ou caderno",
                                    "Calculadora simbólica opcional como Wolfram Alpha para verificação"
                                  ],
                                  "tips": "Mantenha os símbolos genéricos antes de simplificar numericamente.",
                                  "learningObjective": "Aplicar polinômio de Lagrange de grau 1 para interpolar dois pontos.",
                                  "commonMistakes": "Erros nos sinais dos denominadores; sempre verifique interpolação nos pontos originais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Encontrar a Interseção da Reta Secante com o Eixo X",
                                  "subSteps": [
                                    "Defina f(x_{n+1}) = 0 na equação da reta: P(x_{n+1}) = 0.",
                                    "Substitua na fórmula de Lagrange: 0 = f(x_{n-1}) * (x_{n+1} - x_n)/(x_{n-1} - x_n) + f(x_n) * (x_{n+1} - x_{n-1})/(x_n - x_{n-1}).",
                                    "Multiplique ambos os lados pelo denominador comum (x_{n-1} - x_n)(x_n - x_{n-1}) para eliminar frações.",
                                    "Colete termos com x_{n+1} em um lado e resolva para x_{n+1}.",
                                    "Simplifique passo a passo, cancelando fatores comuns."
                                  ],
                                  "verification": "A equação resolvida deve dar x_{n+1} isolado sem resíduos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Caderno para álgebra",
                                    "Ferramenta simbólica para checagem"
                                  ],
                                  "tips": "Trabalhe com y_{n-1} e y_n para evitar confusão com f().",
                                  "learningObjective": "Resolver linearmente para a raiz aproximada da interpolação.",
                                  "commonMistakes": "Esquecer de multiplicar pelo denominador comum, levando a equações incorretas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simplificar para a Fórmula Iterativa Final do Método da Secante",
                                  "subSteps": [
                                    "Da equação resolvida, isole x_{n+1} = [x_{n-1} f(x_n) - x_n f(x_{n-1})] / [f(x_n) - f(x_{n-1})].",
                                    "Verifique a derivação expandindo e reconduzindo à forma inicial.",
                                    "Compare com a fórmula padrão do método da secante em referências.",
                                    "Teste numericamente com valores exemplo para validar.",
                                    "Discuta a condição de f(x_n) ≠ f(x_{n-1}) para evitar divisão por zero."
                                  ],
                                  "verification": "A fórmula final deve coincidir exatamente com x_{n+1} = [x_{n-1} f(x_n) - x_n f(x_{n-1})] / [f(x_n) - f(x_{n-1})].",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplo numérico pronto",
                                    "Software como MATLAB/Python para teste rápido"
                                  ],
                                  "tips": "Fatore o numerador como x_{n-1} y_n - x_n y_{n-1} para clareza.",
                                  "learningObjective": "Obter e validar a fórmula iterativa clássica do método.",
                                  "commonMistakes": "Inverter sinais no numerador; sempre teste com números."
                                }
                              ],
                              "practicalExample": "Para f(x) = x² - 2, com x0 = 1 (f(1)= -1), x1=2 (f(2)=2), derive x2 = [1*2 - 2*(-1)] / [2 - (-1)] = (2 + 2)/3 = 4/3 ≈1.333, próximo à raiz √2≈1.414.",
                              "finalVerifications": [
                                "A fórmula derivada bate com a padrão do método da secante.",
                                "Teste numérico com função conhecida converge à raiz.",
                                "Gráfico mostra interseção da secante próxima à raiz real.",
                                "Condições de parada (divisão por zero) identificadas.",
                                "Explicação oral ou escrita cobre todos os passos sem erros.",
                                "Implementação simples em pseudocódigo funciona."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica em cada etapa da derivação (sem erros de sinal ou fator).",
                                "Compreensão conceitual: ligação entre geometria, Lagrange e iteração.",
                                "Validação numérica com pelo menos um exemplo concreto.",
                                "Identificação de limitações (ex: pontos colineares com raiz).",
                                "Clareza na apresentação da fórmula final e simplificações.",
                                "Uso correto de notação matemática (índices, f(x_i))."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Numérico: Base para métodos de Newton e quasi-Newton.",
                                "Programação: Implementação em loops iterativos (Python/MATLAB).",
                                "Geometria Analítica: Equações de retas e interseções.",
                                "Engenharia Civil: Solução de equações não-lineares em estruturas (ex: equilíbrio de vigas).",
                                "Álgebra Linear: Interpolação polinomial como base para regressão."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usado para resolver equações não-lineares em análise estrutural, como encontrar deformações em vigas sob cargas não-lineares ou pontos de equilíbrio em sistemas hidráulicos, onde métodos analíticos falham."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Implementar Algoritmo em Pseudocódigo",
                            "description": "Escrever pseudocódigo completo com entradas (f, x0, x1, tol, max_iter), loop iterativo até convergência ou máximo de iterações, e saída da raiz aproximada e número de iterações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir entradas, função f e inicializações",
                                  "subSteps": [
                                    "Especificar a função f(x) a ser avaliada (ex: f(x) = x^3 - 2x - 5).",
                                    "Declarar as entradas: função f, valores iniciais x0 e x1, tolerância tol e máximo de iterações max_iter.",
                                    "Inicializar variáveis auxiliares: iter = 0.",
                                    "Verificar se x0 ≠ x1 e f(x0) ≠ f(x1) para evitar divisão por zero inicial."
                                  ],
                                  "verification": "Verificar se todas as entradas estão declaradas corretamente e variáveis inicializadas no pseudocódigo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto ou papel/caneta, calculadora para testes manuais.",
                                  "tips": "Use notação clara como 'f(x)' para facilitar leitura; documente o propósito de cada entrada.",
                                  "learningObjective": "Compreender e declarar corretamente os parâmetros necessários para o método da secante.",
                                  "commonMistakes": "Esquecer de declarar tol ou max_iter; não inicializar iter = 0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a fórmula iterativa da secante",
                                  "subSteps": [
                                    "Calcular f(x0) e f(x1) dentro do contexto do loop.",
                                    "Aplicar a fórmula: x_novo = x1 - f(x1) * (x1 - x0) / (f(x1) - f(x0)).",
                                    "Atualizar os valores: x0 ← x1, x1 ← x_novo.",
                                    "Verificar se f(x1) - f(x0) ≠ 0 para evitar divisão por zero."
                                  ],
                                  "verification": "Simular uma iteração manualmente com valores de exemplo para confirmar que a fórmula produz o próximo x correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto, exemplos numéricos de funções não-lineares.",
                                  "tips": "Nomeie variáveis temporárias como 'x2' ou 'x_novo' para clareza antes de atualizar.",
                                  "learningObjective": "Dominar a derivação e implementação precisa da fórmula do método da secante.",
                                  "commonMistakes": "Inverter os termos na fórmula; esquecer de calcular f(x0) e f(x1) a cada iteração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estruturar o loop iterativo com condições de parada",
                                  "subSteps": [
                                    "Iniciar loop WHILE: iter < max_iter E |x1 - x0| > tol.",
                                    "Colocar os cálculos da iteração (passo 2) dentro do loop.",
                                    "Incrementar iter = iter + 1 ao final de cada iteração.",
                                    "Adicionar verificação opcional para estagnação ou divergência."
                                  ],
                                  "verification": "Traçar o fluxo do loop com 2-3 iterações manuais para garantir que para quando converge ou atinge max_iter.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto, papel para diagrama de fluxo.",
                                  "tips": "Use indentação consistente para destacar o corpo do loop; priorize convergência por diferença entre x's.",
                                  "learningObjective": "Construir um loop robusto que itere até convergência ou limite de iterações.",
                                  "commonMistakes": "Usar condição errada como |f(x1)| > tol em vez de |x1 - x0|; esquecer incremento de iter."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar com saídas e tratamento de exceções",
                                  "subSteps": [
                                    "Após o loop, OUTPUT: raiz aproximada = x1, número de iterações = iter.",
                                    "Adicionar condicional: SE iter == max_iter E |x1 - x0| > tol, avisar 'Não convergiu'.",
                                    "Incluir tratamento para divisão por zero: IF f(x1) == f(x0), parar e avisar.",
                                    "Documentar o pseudocódigo com comentários."
                                  ],
                                  "verification": "Executar pseudocódigo mentalmente com exemplo conhecido para confirmar saídas corretas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto.",
                                  "tips": "Sempre inclua mensagens de erro para depuração; formate OUTPUT claramente.",
                                  "learningObjective": "Garantir que o algoritmo produza saídas úteis e gerencie falhas graciosamente.",
                                  "commonMistakes": "Não tratar divisão por zero; OUTPUT incorreto como x0 em vez de x1."
                                }
                              ],
                              "practicalExample": "Para f(x) = x^3 - 2x - 5 = 0 (equação de equilíbrio em viga), x0=2, x1=3, tol=0.001, max_iter=50:\n\nINPUT f, x0, x1, tol, max_iter\niter ← 0\nWHILE iter < max_iter AND |x1 - x0| > tol DO\n  fx0 ← f(x0)\n  fx1 ← f(x1)\n  IF fx1 == fx0 THEN\n    OUTPUT \"Divisão por zero!\"\n    STOP\n  END IF\n  x2 ← x1 - fx1 * (x1 - x0) / (fx1 - fx0)\n  x0 ← x1\n  x1 ← x2\n  iter ← iter + 1\nEND WHILE\nIF |x1 - x0| > tol THEN\n  OUTPUT \"Não convergiu em\", max_iter, \"iterações\"\nEND IF\nOUTPUT \"Raiz ≈\", x1, \"em\", iter, \"iterações\"",
                              "finalVerifications": [
                                "Pseudocódigo declara todas as entradas: f, x0, x1, tol, max_iter.",
                                "Fórmula da secante está correta e dentro do loop.",
                                "Condições de parada: |x1 - x0| <= tol OU iter >= max_iter.",
                                "Incremento de iter ocorre a cada iteração.",
                                "Saídas incluem raiz aproximada (x1) e número de iterações.",
                                "Tratamento básico para divisão por zero.",
                                "Comentários explicam seções principais."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da fórmula iterativa (peso 30%).",
                                "Estrutura lógica do loop e condições de parada (peso 25%).",
                                "Clareza e legibilidade do pseudocódigo (peso 20%).",
                                "Tratamento de erros como divisão por zero (peso 15%).",
                                "Precisão das saídas e verificações finais (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica e métodos iterativos.",
                                "Programação: Estruturas de controle (loops, condicionais) e pseudocódigo.",
                                "Engenharia Civil: Modelagem de equações não-lineares em estruturas e solos.",
                                "Física: Solução de problemas de equilíbrio não-linear."
                              ],
                              "realWorldApplication": "Em engenharia civil, o pseudocódigo do método da secante é usado para resolver equações não-lineares em análises estruturais, como determinar deformações críticas em vigas sob cargas não-lineares, estabilidade de taludes ou ajuste de curvas de recalque em fundações, otimizando projetos sem depender de solvers proprietários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Análise de Convergência e Aplicações",
                        "description": "Estudo da ordem de convergência superlinear (φ ≈ 1.618, número de ouro), erro assintótico e aplicações em problemas de engenharia civil, como equilíbrio de estruturas não-lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Analisar Ordem de Convergência",
                            "description": "Demonstrar que o erro satisfaz e_{n+1} ≈ (1 - φ^{-2}) e_n e_{n-1}, com φ = (1 + √5)/2, e comparar velocidade com Newton-Raphson (quadrático).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Erro e Ordem de Convergência",
                                  "subSteps": [
                                    "Defina o erro assintótico e_n = |x_n - x^*| para uma raiz x^*.",
                                    "Explique a ordem de convergência p onde e_{n+1} ≈ C e_n^p.",
                                    "Discuta diferenças entre convergência linear, quadrática e superlinear.",
                                    "Introduza o método da secante: x_{n+1} = x_n - f(x_n) (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1})).",
                                    "Liste pré-requisitos: expansão de Taylor e análise assintótica."
                                  ],
                                  "verification": "Escreva definições precisas e derive a iteração da secante sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora, notas de aula sobre métodos numéricos.",
                                  "tips": "Use notação consistente para erros (e_n) e raízes (x^*).",
                                  "learningObjective": "Compreender os fundamentos teóricos de erros e ordens de convergência.",
                                  "commonMistakes": "Confundir e_n com o erro absoluto da função f(x_n); ignorar o caráter superlinear da secante."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Relação Assintótica de Erro para o Método da Secante",
                                  "subSteps": [
                                    "Aplique expansão de Taylor para f(x_n), f(x_{n-1}) em torno de x^*.",
                                    "Expresse x_{n+1} - x^* em termos de e_n e e_{n-1}.",
                                    "Mostre que e_{n+1} ≈ - (f''(x^*)/ (2 f'(x^*))) e_n e_{n-1}.",
                                    "Identifique a constante C = 1 - φ^{-2}, onde φ = (1 + √5)/2 é a razão áurea.",
                                    "Prove que a ordem é a raiz positiva de p^2 - p - 1 = 0, ou seja, p = φ ≈ 1.618."
                                  ],
                                  "verification": "Derive a fórmula e_{n+1} ≈ (1 - φ^{-2}) e_n e_{n-1} e verifique com literatura.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel, caneta, software simbólico como SymPy ou Mathematica para Taylor.",
                                  "tips": "Assuma f'(x^*) ≠ 0 e f''(x^*) existe; normalize a constante.",
                                  "learningObjective": "Derivar analiticamente a ordem de convergência superlinear da secante.",
                                  "commonMistakes": "Erros em coeficientes de Taylor; esquecer o sinal negativo que cancela."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Valores Numéricos e Propriedades da Constante",
                                  "subSteps": [
                                    "Calcule φ = (1 + √5)/2 ≈ 1.618034.",
                                    "Compute φ^{-2} ≈ 0.381966 e 1 - φ^{-2} ≈ 0.618034.",
                                    "Discuta implicações: convergência mais lenta que quadrática mas sem derivadas.",
                                    "Compare taxas: para erros pequenos, secante é φ-ordem vs. 2 para Newton.",
                                    "Plote log-log de erros para visualizar."
                                  ],
                                  "verification": "Confirme cálculos numéricos com precisão de 6 casas decimais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora científica, Python/MATLAB para computar φ e potências.",
                                  "tips": "Lembre que φ satisfaz φ^2 = φ + 1, facilitando cálculos.",
                                  "learningObjective": "Quantificar a constante de proporcionalidade e propriedades da razão áurea.",
                                  "commonMistakes": "Erro no cálculo de φ^{-2} (use φ^{-1} = φ - 1); confundir com constante de Newton."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Velocidade de Convergência com Método de Newton-Raphson",
                                  "subSteps": [
                                    "Revise Newton: e_{n+1} ≈ |f''(x^*)/(2 f'(x^*))| e_n^2 (ordem 2).",
                                    "Compare assintoticamente: secante requer mais iterações mas não precisa f'.",
                                    "Simule numericamente uma equação não-linear (ex: f(x) = x^3 - 2x - 5).",
                                    "Conte iterações até precisão 10^{-10} para ambos métodos.",
                                    "Conclua vantagens/desvantagens em contextos computacionais."
                                  ],
                                  "verification": "Tabela comparativa mostra Newton convergindo em menos passos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Python ou MATLAB para simulação, planilha para tabela de erros.",
                                  "tips": "Inicialize com pontos próximos para convergência rápida.",
                                  "learningObjective": "Analisar trade-offs entre precisão teórica e requisitos computacionais.",
                                  "commonMistakes": "Pontos iniciais ruins causando divergência; ignorar custo de derivadas."
                                }
                              ],
                              "practicalExample": "Resolva f(x) = e^x - 3x^2 numericamente com secante (x0=0, x1=1). Calcule e_n para n=1 a 10, verifique e_{n+1} / (e_n e_{n-1}) → 0.618, e compare com Newton iniciando em x0=1, mostrando Newton atinge 10^{-12} em 5 iterações vs. 8 para secante.",
                              "finalVerifications": [
                                "Derivação da fórmula e_{n+1} ≈ (1 - φ^{-2}) e_n e_{n-1} está correta.",
                                "Valor de φ e constante computados com precisão.",
                                "Simulação numérica confirma a relação assintótica.",
                                "Comparação com Newton destaca ordem quadrática vs. φ-ordem.",
                                "Gráfico de log(e_n) vs. n mostra inclinação consistente com ordem φ.",
                                "Identificadas vantagens da secante (sem derivadas) em aplicações reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da derivação de Taylor (20%)",
                                "Correção nos cálculos numéricos de φ e constante (20%)",
                                "Qualidade da simulação e tabela de erros (20%)",
                                "Profundidade da comparação com Newton-Raphson (20%)",
                                "Clareza em gráficos e conclusões (10%)",
                                "Identificação de erros comuns e tips práticos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de séries de Taylor e equações características.",
                                "Programação: Implementação numérica em Python/MATLAB para validação.",
                                "Física/Engenharia: Modelagem não-linear em estruturas civis (ex: equilíbrio de vigas).",
                                "Estatística: Análise de eficiência algorítmica e complexidade.",
                                "Computação Científica: Otimização de solvers em software de engenharia (ANSYS)."
                              ],
                              "realWorldApplication": "Em engenharia civil, analisar convergência da secante para resolver equações não-lineares em análise de estruturas (ex: deformações em cabos ou solos), onde derivadas analíticas são difíceis, permitindo implementação robusta em softwares como SAP2000 para simulações precisas e eficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Implementar em Código e Testar",
                            "description": "Codificar o método em MATLAB ou Python (usando bibliografia como Chapra & Canale), testar em f(x) = x^3 - 2x - 5 = 0 com x0=0, x1=3, e plotar convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ambiente de Programação e Definir a Função Problema",
                                  "subSteps": [
                                    "Instalar ou abrir o ambiente Python com bibliotecas NumPy e Matplotlib (ou MATLAB).",
                                    "Definir a função f(x) = x^3 - 2x - 5.",
                                    "Definir a derivada numérica ou preparar para cálculo de secante: f'(x) ≈ [f(x1) - f(x0)] / (x1 - x0).",
                                    "Estabelecer valores iniciais x0 = 0, x1 = 3 e tolerância (ex: 1e-6).",
                                    "Criar função auxiliar para calcular f(x)."
                                  ],
                                  "verification": "Função f(x) é executada corretamente e retorna valores esperados, como f(0) = -5 e f(3) ≈ 16.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python (Jupyter Notebook ou IDE como VS Code) com NumPy e Matplotlib instalados; ou MATLAB; Referência: Chapra & Canale.",
                                  "tips": "Use def para funções em Python para reutilização; teste f(x) isoladamente antes de integrar.",
                                  "learningObjective": "Configurar ambiente computacional e modelar equação não-linear com precisão.",
                                  "commonMistakes": "Esquecer importações (numpy, matplotlib); erro de sintaxe em definição de f(x)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Algoritmo do Método da Secante",
                                  "subSteps": [
                                    "Codificar a iteração: x2 = x1 - f(x1) * (x1 - x0) / (f(x1) - f(x0)).",
                                    "Criar loop while com critério de parada: |x2 - x1| < tolerância ou máximo de iterações (ex: 100).",
                                    "Armazenar histórico de x0, x1, x2, f(x) e erros em listas para análise.",
                                    "Atualizar x0 = x1, x1 = x2 a cada iteração.",
                                    "Adicionar tratamento de erro para divisão por zero ou não-convergência."
                                  ],
                                  "verification": "Executar loop manualmente para 2-3 iterações e confirmar valores aproximados (ex: primeira x2 ≈ 1.666).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de código; pseudocódigo do método da secante de Chapra & Canale (Cap. 6).",
                                  "tips": "Use listas append() para histórico; defina max_iter para evitar loops infinitos.",
                                  "learningObjective": "Traduzir fórmula matemática do método da secante em código iterativo funcional.",
                                  "commonMistakes": "Confundir ordem de x0/x1 na atualização; não tratar f(x1)==f(x0)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o Teste com Valores Iniciais e Registrar Resultados",
                                  "subSteps": [
                                    "Chamar a função secante com x0=0, x1=3.",
                                    "Imprimir tabela de iterações: iteração, x0, x1, x2, |x2-x1|, f(x2).",
                                    "Verificar convergência para raiz ≈ 2.0946.",
                                    "Salvar resultados em variáveis para plotagem.",
                                    "Testar sensibilidade alterando tolerância ou iniciais."
                                  ],
                                  "verification": "Código converge em <20 iterações com erro <1e-6; raiz final matches valor conhecido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo ambiente do Step 1; calculadora para validar raiz analítica aproximada.",
                                  "tips": "Use print formatado ou pandas para tabela legível; log erros relativos.",
                                  "learningObjective": "Executar simulação numérica e validar precisão do método.",
                                  "commonMistakes": "Tolerância muito baixa causando não-convergência; ignorar máximo de iterações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar Gráfico de Convergência e Analisar",
                                  "subSteps": [
                                    "Plotar histórico de |x_{n+1} - x_n| vs iterações (escala log).",
                                    "Plotar f(x) com raiz marcada e pontos iniciais.",
                                    "Adicionar linha de tendência para ordem de convergência (≈1.618 para secante).",
                                    "Exportar gráfico como PNG/PDF.",
                                    "Documentar observações: iterações totais, erro final."
                                  ],
                                  "verification": "Gráfico mostra convergência exponencial; eixo y log confirma ordem superlinear.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matplotlib (Python) ou plot() (MATLAB).",
                                  "tips": "Use plt.semilogy() para escala log; label e legend para clareza.",
                                  "learningObjective": "Visualizar e interpretar comportamento de convergência numérica.",
                                  "commonMistakes": "Escala errada no plot; não marcar raiz verdadeira."
                                }
                              ],
                              "practicalExample": "Em Python:\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\ndef f(x): return x**3 - 2*x - 5\ndef secante(x0, x1, tol=1e-6, max_iter=100):\n    hist_x = [x0, x1]\n    hist_err = []\n    for i in range(max_iter):\n        f0, f1 = f(x0), f(x1)\n        if abs(f1 - f0) < 1e-12: break\n        x2 = x1 - f1 * (x1 - x0) / (f1 - f0)\n        err = abs(x2 - x1)\n        hist_x.append(x2)\n        hist_err.append(err)\n        if err < tol: break\n        x0, x1 = x1, x2\n    plt.semilogy(hist_err)\n    plt.xlabel('Iterações')\n    plt.ylabel('Erro |Δx|')\n    plt.show()\n    return x2\nraiz = secante(0, 3)\nprint(f'Raiz: {raiz:.6f}')  # ≈2.094551\n```",
                              "finalVerifications": [
                                "Código executa sem erros e converge para raiz ≈2.0946 em <20 iterações.",
                                "Tabela de iterações impressa corretamente com erros decrescentes.",
                                "Gráfico de convergência em escala log mostra decaimento superlinear.",
                                "Raiz final satisfaz f(x) ≈ 0 (erro absoluto <1e-6).",
                                "Código comentado e reutilizável para outras funções.",
                                "Teste com iniciais diferentes confirma robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro final <1e-6 e convergência em ≤15 iterações.",
                                "Correção algorítmica: Fórmula da secante implementada sem desvios.",
                                "Visualização: Plots claros, legendas e escalas adequadas.",
                                "Eficiência: Tratamento de casos degenerados (divisão zero).",
                                "Documentação: Código comentado e saída interpretável.",
                                "Flexibilidade: Função parametrizada para f(x), x0, x1."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica e ordem de convergência (Cálculo Numérico).",
                                "Programação: Estruturas de loop, funções e bibliotecas científicas.",
                                "Engenharia de Software: Boas práticas de codificação e depuração.",
                                "Física/Hidráulica: Equações não-lineares em fluxo em tubulações.",
                                "Estatística: Ajuste de curvas e validação de modelos."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, o método da secante resolve equações não-lineares em análise de estruturas (ex: equilíbrio não-linear de vigas), dimensionamento hidráulico (equação de Hazen-Williams iterativa) e otimização de fundações, onde MATLAB/Python automatizam soluções precisas e plots de convergência validam estabilidade numérica em projetos reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Aplicar em Problema de Engenharia Civil",
                            "description": "Resolver equação não-linear de deformação em vigas (ex: f(x) = EI x''' - q = 0 aproximada), interpretando resultados e validando com tolerância ε=10^{-6}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o Problema de Deformação em Vigas",
                                  "subSteps": [
                                    "Identificar o tipo de viga (ex: bi-apoiada ou cantilever) e condições de contorno.",
                                    "Definir a equação diferencial da viga: EI * d⁴w/dx⁴ = q(x), onde w é a deformação.",
                                    "Aproximar para equação não-linear f(x) = EI * x''' - q = 0, assumindo discretização ou simplificação.",
                                    "Estabelecer parâmetros: EI (rigidez), q (carga), domínio x ∈ [0, L].",
                                    "Definir tolerância inicial ε = 10^{-6} e intervalos iniciais x0, x1."
                                  ],
                                  "verification": "Equação f(x) escrita corretamente e parâmetros definidos em um documento ou código.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel, calculadora, software como MATLAB/Python (opcional).",
                                  "tips": "Desenhe um diagrama esquemático da viga para visualizar cargas e apoios.",
                                  "learningObjective": "Compreender a modelagem matemática de deformações em vigas como equações não-lineares.",
                                  "commonMistakes": "Confundir derivadas (x''' vs x⁴) ou ignorar unidades consistentes (N, m)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método da Secante",
                                  "subSteps": [
                                    "Definir função f(x) = EI * terceira_derivada_aproximada(x) - q(x).",
                                    "Implementar fórmula da secante: x_{n+1} = x_n - f(x_n) * (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1})).",
                                    "Codificar em Python/MATLAB com loop até |f(x)| < ε ou máximo de iterações.",
                                    "Inicializar com x0 e x1 próximos da solução esperada.",
                                    "Registrar valores de x_n, f(x_n) em tabela para análise."
                                  ],
                                  "verification": "Código executa sem erros e produz tabela de iterações iniciais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (Python com NumPy/SciPy, MATLAB), computador.",
                                  "tips": "Use funções vetoriais para eficiência; teste com f(x) simples como x² - 2.",
                                  "learningObjective": "Dominar a implementação numérica do método da secante para equações não-lineares.",
                                  "commonMistakes": "Divisão por zero (escolha x0, x1 com f(x0) ≠ f(x1)); overflow em derivadas numéricas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Iterações e Analisar Convergência",
                                  "subSteps": [
                                    "Executar o algoritmo com parâmetros da viga (ex: L=5m, EI=1e6 N.m², q=1000 N/m).",
                                    "Plotar gráfico de x_n vs n e |f(x_n)| vs n para visualizar convergência.",
                                    "Calcular ordem de convergência aproximada: log(|e_{n+1}|/|e_n|) / log(|e_n|/|e_{n-1}|) ≈ 1.618.",
                                    "Identificar número de iterações até |x_{n+1} - x_n| < ε.",
                                    "Comparar com solução analítica aproximada se disponível."
                                  ],
                                  "verification": "Gráficos mostram convergência quadrática e tabela com <20 iterações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de plotagem (Matplotlib, MATLAB), dados da Step 2.",
                                  "tips": "Escolha x0, x1 dentro do intervalo de atração para convergência rápida.",
                                  "learningObjective": "Analisar taxa e comportamento de convergência do método da secante.",
                                  "commonMistakes": "Parar iterações prematuramente; ignorar oscilações em x0 ruim."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Resultados e Interpretar",
                                  "subSteps": [
                                    "Verificar |f(x*)| < 10^{-6} e |x_{n+1} - x_n| < ε.",
                                    "Interpretar x* como ponto de deformação máxima ou seção crítica.",
                                    "Validar fisicamente: deformação < limite de material (ex: 1/360 L).",
                                    "Realizar análise de sensibilidade variando EI ou q em ±10%.",
                                    "Documentar relatório com equação, solução, gráficos e conclusões."
                                  ],
                                  "verification": "Relatório confirma validação com ε e interpretação coerente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Resultados anteriores, software de simulação (opcional como ANSYS).",
                                  "tips": "Compare com método de Newton para benchmark de precisão.",
                                  "learningObjective": "Interpretar soluções numéricas em contexto de engenharia e validar rigorosamente.",
                                  "commonMistakes": "Aceitar solução sem check físico; negligenciar tolerância em todas métricas."
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de L=4m, EI=2e7 N.m², carga uniforme q=5kN/m, resolver f(x)=EI*(6*(L-x)^2 / L^3 * x - q) ≈0 para x de máxima deformação, usando x0=1m, x1=2m, convergindo em 8 iterações para x*≈1.5m com ε=1e-6.",
                              "finalVerifications": [
                                "Solução satisfaz |f(x*)| < 10^{-6}.",
                                "Convergência em <15 iterações com gráfico confirmando.",
                                "Interpretação física: deformação compatível com teoria de Euler-Bernoulli.",
                                "Análise de sensibilidade mostra estabilidade.",
                                "Código reproduzível e documentado.",
                                "Relatório completo com todas métricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação do método da secante (100% funcional).",
                                "Análise de convergência com gráficos e métricas quantitativas.",
                                "Validação rigorosa com ε=10^{-6} em múltiplas normas.",
                                "Interpretação correta no contexto de vigas.",
                                "Relatório claro, com erros <5% vs analítico.",
                                "Eficiência: tempo de execução <1s."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais e métodos numéricos.",
                                "Programação: Implementação em Python/MATLAB com visualização.",
                                "Física: Mecânica dos sólidos e teoria de vigas.",
                                "Estatística: Análise de erro e sensibilidade."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios, resolve deformações não-lineares em vigas sob cargas reais, validando designs contra colapso (ex: software como SAP2000 usa métodos similares para otimização estrutural)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Ajuste de Curvas por Mínimos Quadrados Lineares",
                    "description": "Técnica para ajustar uma reta ou polinômio linear a dados experimentais minimizando a soma dos quadrados dos resíduos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Fundamentos do Método dos Mínimos Quadrados",
                        "description": "Conceitos básicos do método dos mínimos quadrados lineares, incluindo definição de resíduos, soma dos quadrados dos resíduos e o princípio de minimização para ajuste de modelos lineares a dados experimentais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Identificar resíduos em ajuste de curvas",
                            "description": "Calcular os resíduos como a diferença entre os valores observados e os valores preditos pelo modelo linear, entendendo sua importância na avaliação da qualidade do ajuste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de resíduos em ajuste de curvas",
                                  "subSteps": [
                                    "Defina resíduo como a diferença entre o valor observado (y_i) e o valor predito pelo modelo (ŷ_i), ou seja, e_i = y_i - ŷ_i.",
                                    "Explique a importância dos resíduos: eles medem o erro do modelo e ajudam a avaliar a bondade do ajuste.",
                                    "Discuta propriedades ideais: resíduos devem ser aleatórios, com média zero e variância constante (homocedasticidade).",
                                    "Identifique tipos de resíduos: absolutos, padronizados e studentizados.",
                                    "Relacione com o método dos mínimos quadrados: minimiza a soma dos quadrados dos resíduos."
                                  ],
                                  "verification": "Resuma em suas palavras o que são resíduos e sua importância, sem erros conceituais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de estatística ou regressão linear",
                                    "Notas ou quadro branco"
                                  ],
                                  "tips": "Use analogia: resíduos são como 'erros de previsão' em um mapa de estrada.",
                                  "learningObjective": "Entender conceitualmente resíduos e seu papel na validação de modelos lineares.",
                                  "commonMistakes": "Confundir resíduo com desvio padrão ou ignorar que podem ser positivos/negativos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular resíduos para um conjunto de dados simples",
                                  "subSteps": [
                                    "Colete dados observados: ex., x = [1,2,3,4], y = [2.1, 3.9, 6.2, 8.0].",
                                    "Ajuste o modelo linear: calcule coeficientes a e b da reta y = a + b*x via mínimos quadrados.",
                                    "Prediga ŷ_i para cada x_i: ŷ_i = a + b*x_i.",
                                    "Calcule e_i = y_i - ŷ_i para cada ponto.",
                                    "Liste os resíduos em uma tabela organizada."
                                  ],
                                  "verification": "Confirme que soma dos resíduos é aproximadamente zero e calcule manualmente para verificação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Excel",
                                    "Papel para tabela de dados"
                                  ],
                                  "tips": "Use fórmulas prontas para a e b: b = (n∑xy - ∑x∑y)/(n∑x² - (∑x)²), a = (∑y - b∑x)/n.",
                                  "learningObjective": "Executar cálculo manual de resíduos passo a passo.",
                                  "commonMistakes": "Erro aritmético em predições ou inverter y_i e ŷ_i."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Visualizar e analisar padrões nos resíduos",
                                  "subSteps": [
                                    "Plote resíduos vs. valores preditos (gráfico de resíduos).",
                                    "Verifique aleatoriedade: procure padrões como curvas, funis ou heterocedasticidade.",
                                    "Calcule estatísticas: média, variância e soma de quadrados dos resíduos (SSR).",
                                    "Compare com suposições do modelo linear: independência e normalidade.",
                                    "Interprete: resíduos aleatórios indicam bom ajuste; padrões sugerem modelo inadequado."
                                  ],
                                  "verification": "Descreva o gráfico de resíduos e identifique se há violações de suposições.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software como Excel, Python (matplotlib/seaborn) ou MATLAB"
                                  ],
                                  "tips": "No Excel, use gráfico de dispersão com e_i no eixo y e ŷ_i no x.",
                                  "learningObjective": "Analisar resíduos graficamente para diagnosticar o modelo.",
                                  "commonMistakes": "Ignorar escalas no gráfico ou confundir correlação com causalidade nos padrões."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar a qualidade do ajuste usando resíduos",
                                  "subSteps": [
                                    "Calcule R² = 1 - (SSR / SST), onde SST é variância total.",
                                    "Teste hipóteses: resíduo médio = 0 via t-test.",
                                    "Identifique outliers: resíduos > 2-3 desvios padrões.",
                                    "Sugira melhorias: transformação de variáveis se padrões detectados.",
                                    "Documente conclusões sobre a adequação do modelo linear."
                                  ],
                                  "verification": "Produza relatório curto com R², gráfico e recomendações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou script Python",
                                    "Dados do exemplo anterior"
                                  ],
                                  "tips": "R² próximo de 1 indica bom ajuste; <0.7 pode precisar de modelo não-linear.",
                                  "learningObjective": "Usar resíduos para quantificar e qualificar a qualidade do ajuste.",
                                  "commonMistakes": "Sobrepor R² como medida única, ignorando diagnóstico de resíduos."
                                }
                              ],
                              "practicalExample": "Em um teste de tração de concreto: dados de deformação (x: 0.0001, 0.0002, ..., 0.001 m/m) vs. tensão (y: 1.2, 2.5, ..., 12 MPa). Ajuste linear σ = Eε, calcule resíduos para verificar linearidade até ruptura.",
                              "finalVerifications": [
                                "Capacidade de calcular corretamente resíduos para 5 pontos dados.",
                                "Interpretação correta de gráfico de resíduos sem padrões evidentes.",
                                "Cálculo preciso de R² a partir de resíduos.",
                                "Identificação de pelo menos um erro comum em análise de resíduos.",
                                "Explicação verbal da importância dos resíduos em 1 minuto.",
                                "Aplicação em exemplo real de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de resíduos (erro <1%).",
                                "Qualidade da análise gráfica e detecção de padrões.",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Uso correto de estatísticas derivadas de resíduos (R², média).",
                                "Criatividade em conexões com aplicações reais.",
                                "Completude da documentação e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuições e testes de hipóteses.",
                                "Programação: Implementação em Python (numpy, scipy.stats.linregress).",
                                "Física: Modelagem de materiais em mecânica dos sólidos.",
                                "Matemática: Álgebra linear para matrizes de regressão."
                              ],
                              "realWorldApplication": "Na engenharia civil, identificar resíduos em ajuste de curvas de carga-descida em fundações ou tração em concreto garante precisão em projetos estruturais, evitando colapsos por modelos inadequados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Formular a função soma dos quadrados dos resíduos",
                            "description": "Construir a função objetivo S = Σ (y_i - ŷ_i)^2 para um conjunto de dados experimentais (x_i, y_i) e um modelo linear ŷ = a + b x.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os dados experimentais e o modelo linear",
                                  "subSteps": [
                                    "Identifique o conjunto de dados experimentais composto por pares (x_i, y_i), onde x_i são as variáveis independentes (ex.: cargas aplicadas) e y_i as dependentes (ex.: deformações observadas).",
                                    "Defina o modelo linear proposto: ŷ_i = a + b * x_i, onde a é o intercepto e b a inclinação da reta de ajuste.",
                                    "Explique o conceito de previsão: ŷ_i representa o valor previsto pelo modelo para cada x_i.",
                                    "Discuta a necessidade de medir a discrepância entre valores observados (y_i) e previstos (ŷ_i).",
                                    "Esboce graficamente os pontos de dados e a reta de ajuste para visualização."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito os componentes do modelo e os dados, confirmando que ŷ_i = a + b x_i está claro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta para esboço gráfico; conjunto de dados exemplo (5-10 pontos).",
                                  "tips": "Use um exemplo concreto de engenharia civil, como carga vs. deformação em uma viga, para fixar conceitos.",
                                  "learningObjective": "Entender a estrutura dos dados e o modelo linear como base para o cálculo de resíduos.",
                                  "commonMistakes": "Confundir x_i com y_i ou assumir modelo não-linear sem justificativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e calcular os resíduos individuais",
                                  "subSteps": [
                                    "Defina o resíduo para o i-ésimo ponto: e_i = y_i - ŷ_i.",
                                    "Substitua ŷ_i no resíduo: e_i = y_i - (a + b x_i).",
                                    "Calcule e_i para cada ponto de dados manualmente ou em tabela.",
                                    "Interprete o sinal do resíduo: positivo indica subestimação do modelo, negativo superestimação.",
                                    "Registre todos os e_i em uma tabela organizada."
                                  ],
                                  "verification": "Crie uma tabela com x_i, y_i, ŷ_i e e_i para 5 pontos e verifique se e_i = y_i - ŷ_i.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha Excel ou papel quadriculado; calculadora.",
                                  "tips": "Sempre subtraia previsto do observado: observado menos previsto.",
                                  "learningObjective": "Calcular com precisão os resíduos como medida de erro pontual.",
                                  "commonMistakes": "Inverter a subtração (ŷ_i - y_i) ou esquecer de calcular ŷ_i primeiro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Elevar os resíduos ao quadrado",
                                  "subSteps": [
                                    "Explique por que elevar ao quadrado: elimina sinal negativo e penaliza erros maiores quadraticamente.",
                                    "Calcule e_i² para cada resíduo e_i.",
                                    "Registre os valores de e_i² em uma nova coluna da tabela.",
                                    "Verifique unidades: confirme que e_i² tem unidades consistentes (ex.: mm⁴ se y em mm).",
                                    "Some visualmente os e_i² para antecipar a soma final."
                                  ],
                                  "verification": "Confirme que todos e_i² são positivos e liste-os corretamente na tabela.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou software (Excel/Python); tabela anterior.",
                                  "tips": "Use fórmula no Excel: = (y_i - (a + b*x_i))^2 para automação.",
                                  "learningObjective": "Aplicar o quadrado aos resíduos para preparar a soma dos erros.",
                                  "commonMistakes": "Esquecer o expoente 2 ou calcular |e_i| em vez de e_i²."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular a função soma dos quadrados dos resíduos S",
                                  "subSteps": [
                                    "Defina S = Σ_{i=1}^n (y_i - ŷ_i)^2, onde n é o número de pontos.",
                                    "Expanda: S = Σ_{i=1}^n [y_i - (a + b x_i)]^2.",
                                    "Calcule a soma numérica de todos e_i² para obter S.",
                                    "Interprete S: quanto menor, melhor o ajuste do modelo.",
                                    "Escreva a função S explicitamente como objetivo a minimizar."
                                  ],
                                  "verification": "Escreva a fórmula S completa e compute seu valor numérico para os dados exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela completa; calculadora para soma.",
                                  "tips": "A soma Σ é de i=1 a n; inclua todos os pontos sem exceção.",
                                  "learningObjective": "Construir a função objetivo S pronta para minimização.",
                                  "commonMistakes": "Usar média em vez de soma ou omitir o índice i na notação Σ."
                                }
                              ],
                              "practicalExample": "Dados de teste em viga de concreto: (x: carga em kN, y: deformação em mm) Pontos: (0,0), (10,0.5), (20,1.2), (30,1.8), (40,2.4). Modelo: ŷ = 0.06x. Resíduos: 0, 0, 0.04, -0.06, 0. Somados quadrados: S = 0 + 0 + 0.0016 + 0.0036 + 0 = 0.0052.",
                              "finalVerifications": [
                                "Escreve corretamente S = Σ (y_i - (a + b x_i))^2.",
                                "Calcula resíduos e seus quadrados para um conjunto de 5 pontos sem erros.",
                                "Explica o propósito de S como função objetivo.",
                                "Identifica que S ≥ 0 e S=0 indica ajuste perfeito.",
                                "Aplica a fórmula em dados reais de engenharia civil.",
                                "Discute impacto de outliers em S."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de resíduo e fórmula S (100% correto).",
                                "Correção nos cálculos numéricos (erro < 1%).",
                                "Clareza na notação matemática (Σ, índices corretos).",
                                "Interpretação conceitual adequada (mínimos quadrados).",
                                "Uso apropriado de exemplos práticos.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceito de variância e soma de quadrados.",
                                "Programação: Implementação em Python (numpy.sum((y - y_hat)**2)).",
                                "Física: Modelagem de leis lineares em materiais.",
                                "Cálculo: Derivadas para minimização de S.",
                                "Geometria: Distância euclidiana quadrática."
                              ],
                              "realWorldApplication": "Em engenharia civil, formula S para ajustar curvas de carga-deformação em vigas, prevendo falhas estruturais e otimizando projetos de pontes ou edifícios via regressão linear."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Entender o princípio de minimização",
                            "description": "Explicar como a minimização da soma dos quadrados dos resíduos leva ao melhor ajuste linear em termos de critério de mínimos quadrados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de resíduos em regressão linear",
                                  "subSteps": [
                                    "Defina resíduo como a diferença entre o valor observado (y_i) e o valor predito pela linha (ŷ_i = a + b x_i).",
                                    "Discuta por que resíduos medem o erro de ajuste do modelo linear aos dados.",
                                    "Identifique que resíduos positivos e negativos indicam super e subestimações.",
                                    "Explique a importância de resíduos aleatórios e sem padrão para um bom ajuste.",
                                    "Calcule manualmente resíduos para um conjunto pequeno de 3-4 pontos de dados."
                                  ],
                                  "verification": "Liste corretamente os resíduos para um conjunto de dados dado e identifique padrões incorretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Conjunto de dados exemplo com 5 pontos (x,y)"
                                  ],
                                  "tips": "Visualize resíduos graficamente plotando pontos e linha de ajuste para intuitivamente entender desvios.",
                                  "learningObjective": "Definir e calcular resíduos em um modelo linear simples.",
                                  "commonMistakes": [
                                    "Confundir resíduo com diferença absoluta em vez de y - ŷ",
                                    "Ignorar o sinal dos resíduos ao analisar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e calcular a Soma dos Quadrados dos Resíduos (SSR)",
                                  "subSteps": [
                                    "Escreva a fórmula da SSR: SSR = Σ (y_i - ŷ_i)^2 para i=1 a n.",
                                    "Explique por que elevar ao quadrado: penaliza erros grandes mais e elimina sinais opostos.",
                                    "Calcule SSR passo a passo para um conjunto de dados com linha assumida.",
                                    "Compare SSR para duas linhas diferentes no mesmo conjunto de dados.",
                                    "Use uma planilha para automatizar o cálculo e variar parâmetros."
                                  ],
                                  "verification": "Compute SSR corretamente para dados fornecidos e compare com valores conhecidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Dados de exemplo com coordenadas x,y"
                                  ],
                                  "tips": "Sempre verifique unidades: garanta que x e y estejam na mesma escala para SSR significativa.",
                                  "learningObjective": "Formular e computar a função objetivo SSR para um ajuste linear.",
                                  "commonMistakes": [
                                    "Esquecer de quadrado, usando soma absoluta",
                                    "Não somar todos os termos corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender o princípio geométrico e estatístico da minimização",
                                  "subSteps": [
                                    "Visualize geometricamente: a linha que minimiza distâncias perpendiculares quadradas aos pontos.",
                                    "Discuta propriedades: SSR mínima implica resíduos ortogonais à direção da reta.",
                                    "Explique critério de mínimos quadrados: único critério que leva a solução fechada via derivadas.",
                                    "Compare com outros critérios (ex: mínimos absolutos) e por que quadrados são preferidos.",
                                    "Derive intuitivamente que minimizar SSR equilibra erros positivos e negativos."
                                  ],
                                  "verification": "Descreva em palavras por que minimizar SSR dá o 'melhor' ajuste e dê contraexemplo para soma absoluta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico impresso ou software de plotagem como Desmos",
                                    "Vídeo curto sobre geometria dos mínimos quadrados"
                                  ],
                                  "tips": "Pense em SSR como 'energia total' dos erros: minimizar é encontrar equilíbrio estável.",
                                  "learningObjective": "Explicar intuitivamente por que minimizar SSR leva ao melhor ajuste linear.",
                                  "commonMistakes": [
                                    "Confundir minimização com zero resíduos (impossível exceto interpolação)",
                                    "Ignorar normalização de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conectar minimização à solução analítica dos mínimos quadrados",
                                  "subSteps": [
                                    "Escreva modelo linear: y = a + b x + ε.",
                                    "Minimize SSR tomando derivadas parciais ∂SSR/∂a = 0 e ∂SSR/∂b = 0.",
                                    "Resolva as equações normais para a e b em termos de médias e covariâncias.",
                                    "Verifique que a solução minimiza SSR derivando segunda derivada positiva.",
                                    "Implemente em código simples para validar."
                                  ],
                                  "verification": "Derive as fórmulas de a e b a partir da minimização e aplique a dados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Cálculo básico (derivadas)",
                                    "Python ou MATLAB snippet para mínimos quadrados"
                                  ],
                                  "tips": "Use equações normais: b = Σ(x- x̄)(y-ȳ)/Σ(x- x̄)^2 para memorizar ligação.",
                                  "learningObjective": "Ligar princípio de minimização às fórmulas padrão de regressão linear.",
                                  "commonMistakes": [
                                    "Erro em derivadas: esquecer o fator 2 ou somatórios",
                                    "Não centralizar dados antes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e validar o princípio em um exemplo prático",
                                  "subSteps": [
                                    "Escolha dados reais: tensão vs deformação em material de construção.",
                                    "Calcule SSR para linha ótima vs linhas ruins.",
                                    "Ajuste linha via fórmula e confirme SSR mínima.",
                                    "Analise sensibilidade: altere um ponto e reajauste.",
                                    "Discuta limitações: assume homocedasticidade e normalidade."
                                  ],
                                  "verification": "Produza relatório curto mostrando SSR mínima para ajuste ótimo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Dados de engenharia civil exemplo",
                                    "Software de regressão como Excel Solver"
                                  ],
                                  "tips": "Sempre plote: visual confirma o que matemática prova.",
                                  "learningObjective": "Aplicar princípio de minimização para validar melhor ajuste.",
                                  "commonMistakes": [
                                    "Overfitting com poucos pontos",
                                    "Não checar pressupostos do modelo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um teste de tração de concreto, dados de carga (x) vs deformação (y): pontos (0,0), (10,0.001), (20,0.0025), (30,0.004). Calcule resíduos para linha y=0.00013x, SSR=0.000001; teste outra linha y=0.0001x, SSR maior=0.000002, confirmando minimização como melhor ajuste para prever deformações futuras.",
                              "finalVerifications": [
                                "Explica verbalmente por que soma de quadrados em vez de absolutos.",
                                "Calcula SSR corretamente para novo conjunto de 5 pontos.",
                                "Deriva fórmula de slope b da minimização.",
                                "Identifica linha de SSR mínima em gráfico com 3 opções.",
                                "Discute limitação: não captura não-linearidades.",
                                "Aplica a dados reais e interpreta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e cálculo de resíduos e SSR (80% correto).",
                                "Compreensão conceitual: explica geometria e razão quadrados (rubrica 1-5).",
                                "Derivação correta das equações normais sem erros algébricos.",
                                "Aplicação prática: ajusta linha corretamente em exemplo (erro <5%).",
                                "Análise crítica: menciona pelo menos 2 pressupostos e violações.",
                                "Clareza na comunicação: diagrama ou plot explica princípio."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: distribuições de resíduos e testes de significância.",
                                "Cálculo: otimização via derivadas e Hessiana positiva.",
                                "Programação: implementação em Python (numpy.polyfit) para automação.",
                                "Física: princípio de menor ação análogo à minimização de energia.",
                                "Engenharia de Software: validação de modelos preditivos."
                              ],
                              "realWorldApplication": "Na engenharia civil, minimizar SSR ajusta curvas de calibragem em ensaios de solos para prever assentamentos; otimiza regressões em monitoramento estrutural para detectar falhas precocemente em pontes, economizando custos em manutenção preditiva."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Ajuste de Reta Linear",
                        "description": "Aplicação do método dos mínimos quadrados para determinar os coeficientes de uma reta y = a + b x que melhor se ajusta a um conjunto de dados experimentais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Derivar as equações normais para reta linear",
                            "description": "Obter as equações normais ∂S/∂a = 0 e ∂S/∂b = 0, resultando no sistema linear para os coeficientes a e b em termos de somas de x_i, y_i, x_i y_i e x_i².",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo da reta linear e a função soma de quadrados dos erros S",
                                  "subSteps": [
                                    "Escreva a equação do modelo: y = a + b x, onde a é o intercepto e b a inclinação.",
                                    "Liste os n pares de dados observados: (x_i, y_i) para i = 1 até n.",
                                    "Defina o resíduo para cada ponto: e_i = y_i - (a + b x_i).",
                                    "Formule a função objetivo: S(a, b) = ∑_{i=1}^n e_i² = ∑_{i=1}^n (y_i - a - b x_i)².",
                                    "Explique o objetivo: encontrar a e b que minimizem S."
                                  ],
                                  "verification": "Confirme que S está expandida corretamente como soma de termos quadráticos sem derivadas ainda.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Lista de dados de exemplo (x_i, y_i)"
                                  ],
                                  "tips": "Expanda S explicitamente para visualizar os termos em a, b, x_i e y_i.",
                                  "learningObjective": "Compreender a base do método dos mínimos quadrados para ajuste de reta.",
                                  "commonMistakes": [
                                    "Usar soma de erros absolutos em vez de quadrados",
                                    "Esquecer o índice i na soma",
                                    "Confundir y_i com valores preditos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a equação normal ∂S/∂a = 0",
                                  "subSteps": [
                                    "Escreva S(a, b) = ∑ (y_i - a - b x_i)².",
                                    "Calcule a derivada parcial ∂/∂a de um termo: ∂/∂a [(y_i - a - b x_i)²] = 2 (y_i - a - b x_i) (-1).",
                                    "Some sobre todos os i: ∂S/∂a = -2 ∑ (y_i - a - b x_i).",
                                    "Iguale a zero: ∑ (y_i - a - b x_i) = 0.",
                                    "Simplifique: ∑ y_i = n a + b ∑ x_i."
                                  ],
                                  "verification": "Verifique se a equação final é ∑ y_i = n a + b ∑ x_i.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para somas simbólicas"
                                  ],
                                  "tips": "Trate b como constante ao derivar em relação a a.",
                                  "learningObjective": "Aplicar derivada parcial para minimização em relação ao intercepto a.",
                                  "commonMistakes": [
                                    "Esquecer o fator -2 na derivada",
                                    "Não distribuir a soma corretamente",
                                    "Usar média em vez de soma total"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a equação normal ∂S/∂b = 0",
                                  "subSteps": [
                                    "Reescreva S(a, b) = ∑ (y_i - a - b x_i)².",
                                    "Calcule ∂/∂b de um termo: ∂/∂b [(y_i - a - b x_i)²] = 2 (y_i - a - b x_i) (-x_i).",
                                    "Some sobre i: ∂S/∂b = -2 ∑ x_i (y_i - a - b x_i).",
                                    "Iguale a zero: ∑ x_i (y_i - a - b x_i) = 0.",
                                    "Simplifique: ∑ x_i y_i = a ∑ x_i + b ∑ x_i²."
                                  ],
                                  "verification": "Confirme a equação: ∑ x_i y_i = a ∑ x_i + b ∑ x_i².",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo numérico para prática"
                                  ],
                                  "tips": "Note o fator x_i na derivada, pois b multiplica x_i.",
                                  "learningObjective": "Dominar a derivada parcial para o coeficiente angular b.",
                                  "commonMistakes": [
                                    "Esquecer o -x_i na derivada",
                                    "Confundir ∑ x_i y_i com (∑ x_i)(∑ y_i)",
                                    "Não expandir corretamente o produto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar e interpretar o sistema de equações normais",
                                  "subSteps": [
                                    "Colete as duas equações: (1) n a + (∑ x_i) b = ∑ y_i; (2) (∑ x_i) a + (∑ x_i²) b = ∑ x_i y_i.",
                                    "Escreva em forma matricial: [[n, ∑x], [∑x, ∑x²]] [a, b]^T = [∑y, ∑xy]^T.",
                                    "Discuta resolução: usar eliminação gaussiana ou fórmula explícita para a e b.",
                                    "Calcule somas estatísticas necessárias: n, ∑x_i, ∑y_i, ∑x_i y_i, ∑x_i².",
                                    "Verifique consistência com propriedades como ortogonalidade dos resíduos."
                                  ],
                                  "verification": "Resolva um sistema simples e confirme que minimiza S.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou software como Python/MATLAB"
                                  ],
                                  "tips": "Denote S_x = ∑ x_i / n (média) para fórmulas alternativas.",
                                  "learningObjective": "Montar e resolver o sistema linear das equações normais.",
                                  "commonMistakes": [
                                    "Trocar coeficientes entre equações",
                                    "Dividir por n prematuramente",
                                    "Ignorar unidades nos dados"
                                  ]
                                }
                              ],
                              "practicalExample": "Dados: x = [1, 2, 3], y = [2, 4, 5] (n=3). Somas: ∑x=6, ∑y=11, ∑xy=2+8+15=25, ∑x²=1+4+9=14. Sistema: 3a + 6b = 11; 6a + 14b = 25. Solução: b = 1.5, a = 2/3 ≈ 0.667. Verifique S minimizado.",
                              "finalVerifications": [
                                "Deriva corretamente ∂S/∂a = -2 ∑ (y_i - a - b x_i) = 0.",
                                "Obtém equação normal 1: n a + b ∑ x_i = ∑ y_i.",
                                "Deriva corretamente ∂S/∂b = -2 ∑ x_i (y_i - a - b x_i) = 0.",
                                "Forma sistema com ∑ x_i y_i = a ∑ x_i + b ∑ x_i².",
                                "Resolve exemplo numérico obtendo a e b corretos.",
                                "Confirma minimização computando S para os valores ótimos."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica nas derivadas parciais (fator 2 e sinais corretos).",
                                "Correção na simplificação para somas totais (∑ y_i, etc.).",
                                "Formação precisa do sistema 2x2 linear.",
                                "Interpretação correta dos coeficientes a e b.",
                                "Aplicação bem-sucedida em exemplo prático com cálculos numéricos exatos.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Derivadas parciais e otimização.",
                                "Álgebra Linear: Resolução de sistemas lineares e forma matricial.",
                                "Estatística: Conceitos de regressão linear e coeficientes de correlação.",
                                "Programação Computacional: Implementação em Python (NumPy) para dados reais.",
                                "Engenharia: Análise de dados experimentais em estruturas."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, derivação usada para ajustar retas em ensaios de materiais (ex.: deformação vs. carga em concreto), calibração de instrumentos geotécnicos ou modelagem de subsidência em solos, permitindo predições precisas para projetos estruturais seguros."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Resolver o sistema para coeficientes da reta",
                            "description": "Calcular analiticamente os valores de a e b usando as fórmulas fechadas: b = (n Σ x y - Σ x Σ y)/(n Σ x² - (Σ x)²) e a = (Σ y - b Σ x)/n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados e calcular somas básicas",
                                  "subSteps": [
                                    "Liste os pares de dados (x_i, y_i) e determine n, o número de pontos.",
                                    "Calcule Σx (soma de todos x_i) e Σy (soma de todos y_i).",
                                    "Calcule Σx² (soma dos quadrados de x_i).",
                                    "Registre todos os valores em uma tabela organizada.",
                                    "Verifique a contagem de n e as somas iniciais."
                                  ],
                                  "verification": "Confira se as somas batem com uma segunda cálculo manual ou usando uma calculadora.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel, caneta, calculadora científica, conjunto de dados exemplo.",
                                  "tips": "Use uma tabela para organizar: coluna para x, y, x², etc., para evitar erros de anotação.",
                                  "learningObjective": "Dominar a organização de dados para regressão linear.",
                                  "commonMistakes": "Esquecer de contar n corretamente ou somar valores errados devido a distração."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Σxy e preparar numerador/denominador para b",
                                  "subSteps": [
                                    "Calcule xy para cada par (x_i * y_i) e some para obter Σxy.",
                                    "Calcule o numerador para b: n * Σxy - Σx * Σy.",
                                    "Calcule o denominador para b: n * Σx² - (Σx)².",
                                    "Verifique se numerador e denominador não são zero (evite divisão por zero).",
                                    "Anote os valores intermediários claramente."
                                  ],
                                  "verification": "Recalcule Σxy independentemente e confirme se numerador/denominador fazem sentido (denominador > 0 para dados reais).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora, papel com tabela expandida (adicionar coluna xy).",
                                  "tips": "Multiplique x e y com cuidado; use parênteses em fórmulas compostas na calculadora.",
                                  "learningObjective": "Entender os componentes da fórmula de mínimos quadrados para o coeficiente angular.",
                                  "commonMistakes": "Erro no cálculo de Σxy (confundir com Σx * Σy) ou no quadrado de Σx."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o coeficiente b (inclinação da reta)",
                                  "subSteps": [
                                    "Aplique a fórmula: b = (n Σxy - Σx Σy) / (n Σx² - (Σx)²).",
                                    "Divida numerador por denominador com precisão (use 4 casas decimais).",
                                    "Arredonde b conforme necessário (ex: 2-3 decimais para engenharia).",
                                    "Registre b e verifique se o sinal faz sentido com os dados.",
                                    "Teste com um valor simples: se todos x iguais, b deve ser 0."
                                  ],
                                  "verification": "Substitua valores conhecidos em uma fórmula simbólica ou use software para comparar.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora com memória para valores intermediários.",
                                  "tips": "Salve somas na memória da calculadora para reutilizar.",
                                  "learningObjective": "Executar o cálculo fechado para o coeficiente angular b.",
                                  "commonMistakes": "Dividir errado ou inverter numerador/denominador."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o coeficiente a (intercepto) e validar",
                                  "subSteps": [
                                    "Aplique a fórmula: a = (Σy - b Σx) / n.",
                                    "Calcule Σy - b Σx primeiro, depois divida por n.",
                                    "Arredonde a similarmente a b.",
                                    "Calcule y previsto para um ponto médio e compare com real.",
                                    "Plote mentalmente ou esboce a reta para checar ajuste visual."
                                  ],
                                  "verification": "Para um ponto (x_i, y_i), verifique se y_pred = a + b x_i está próximo de y_i.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel para esboço gráfico simples, calculadora.",
                                  "tips": "Sempre calcule a após b, pois depende dele.",
                                  "learningObjective": "Completar o par (a, b) e entender sua interpretação geométrica.",
                                  "commonMistakes": "Esquecer de multiplicar b por Σx ou dividir por n incorretamente."
                                }
                              ],
                              "practicalExample": "Dados: n=5, pontos (1,2), (2,3), (3,5), (4,4), (5,5). Σx=15, Σy=19, Σx²=55, Σxy=60. b=(5*60 -15*19)/(5*55 -225)= (300-285)/(275-225)=15/50=0.3. a=(19-0.3*15)/5=(19-4.5)/5=14.5/5=2.9. Reta: y=2.9 + 0.3x.",
                              "finalVerifications": [
                                "Coeficientes a e b calculados corretamente com fórmulas exatas.",
                                "Denominador para b não é zero.",
                                "Valores previstos para pelo menos 3 pontos estão próximos dos reais.",
                                "Sinal e magnitude de b condizem com tendência dos dados.",
                                "Cálculos intermediários (somas) recálculados sem discrepâncias.",
                                "Esboço da reta ajusta visualmente os pontos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de somas (erro <1%).",
                                "Aplicação correta das fórmulas fechadas sem derivação desnecessária.",
                                "Interpretação física de a (intercepto) e b (inclinação).",
                                "Detecção e correção de erros comuns como divisão por zero.",
                                "Apresentação organizada de tabela de dados e resultados.",
                                "Validação com pelo menos um ponto de teste."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Entender mínimos quadrados como método de estimação.",
                                "Programação: Implementar em Python (numpy.polyfit) ou Excel para automação.",
                                "Física: Ajuste de dados experimentais em leis lineares (ex: Ohm).",
                                "Álgebra Linear: Reconhecer como solução de sistema 2x2 normal.",
                                "Geometria Analítica: Equação da reta y = ax + b."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usado para ajustar curvas de regressão linear em testes de materiais (ex: tensão vs. deformação em concreto), previsão de subsidência de solos baseada em dados de nivelamento, ou calibração de sensores em monitoramento estrutural, minimizando erros quadráticos para modelos preditivos confiáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Implementar ajuste de reta em software",
                            "description": "Usar MATLAB ou Python (ex: polyfit ou numpy.polyfit) para ajustar uma reta a dados experimentais e plotar o resultado com resíduos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de programação e os dados experimentais",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: numpy e matplotlib via pip.",
                                    "Crie um novo script Python ou Jupyter Notebook.",
                                    "Defina arrays de dados experimentais (ex: x = carga, y = deformação de um ensaio em concreto).",
                                    "Visualize os dados brutos com um scatter plot inicial.",
                                    "Verifique se os dados estão limpos (sem NaNs ou outliers óbvios)."
                                  ],
                                  "verification": "Dados carregados e plotados corretamente em um gráfico scatter sem erros de execução.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Jupyter Notebook ou VS Code",
                                    "Bibliotecas: numpy, matplotlib"
                                  ],
                                  "tips": "Use dados reais de ensaios civis para maior relevância; comece com 10-20 pontos.",
                                  "learningObjective": "Configurar ambiente de programação e preparar dados para análise.",
                                  "commonMistakes": [
                                    "Esquecer de importar bibliotecas",
                                    "Usar arrays com comprimentos diferentes",
                                    "Ignorar unidades dos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o ajuste de reta usando polyfit",
                                  "subSteps": [
                                    "Importe numpy como np.",
                                    "Use np.polyfit(x, y, 1) para obter coeficientes da reta (inclinação e intercepto).",
                                    "Calcule a reta ajustada: y_fit = np.polyval(coef, x).",
                                    "Imprima os coeficientes e interprete fisicamente (ex: inclinação como módulo de elasticidade).",
                                    "Calcule o coeficiente de determinação R² manualmente para validar."
                                  ],
                                  "verification": "Coeficientes da reta calculados e impressos corretamente; R² próximo de 1 para bons dados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código Python do Step 1"
                                  ],
                                  "tips": "Sempre especifique grau 1 para reta linear; use weights se houver incertezas desiguais.",
                                  "learningObjective": "Aplicar mínimos quadrados lineares via polyfit para estimar parâmetros da reta.",
                                  "commonMistakes": [
                                    "Confundir ordem dos coeficientes (polyfit retorna [slope, intercept])",
                                    "Não ordenar dados",
                                    "Usar polyfit com grau >1 acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar os dados experimentais e a reta ajustada",
                                  "subSteps": [
                                    "Crie um novo figure com matplotlib.pyplot.",
                                    "Plote scatter dos dados originais (x, y).",
                                    "Plote a linha da reta ajustada (x, y_fit) em cor diferente.",
                                    "Adicione labels, título, grid e legenda.",
                                    "Salve o gráfico como PNG para relatório."
                                  ],
                                  "verification": "Gráfico mostra dados e reta sobrepostos, com elementos visuais claros e sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código dos Steps anteriores",
                                    "matplotlib"
                                  ],
                                  "tips": "Use plt.xlim e plt.ylim para focar na região relevante; cores contrastantes ajudam.",
                                  "learningObjective": "Visualizar o ajuste para validar a adequação do modelo linear.",
                                  "commonMistakes": [
                                    "Plotar y_fit sem gerar pontos suficientes",
                                    "Esquecer legenda ou labels",
                                    "Escala inadequada no eixo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular, plotar e analisar resíduos",
                                  "subSteps": [
                                    "Calcule resíduos: resid = y - y_fit.",
                                    "Crie um subplot para resíduos vs x (scatter).",
                                    "Adicione linha horizontal em y=0.",
                                    "Plote histograma dos resíduos para checar normalidade.",
                                    "Interprete: resíduos aleatórios indicam bom ajuste; padrões sugerem não-linearidade."
                                  ],
                                  "verification": "Gráfico de resíduos mostra dispersão aleatória em torno de zero; histograma aproximadamente normal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código completo anterior"
                                  ],
                                  "tips": "Use subplots para comparar dados/reta e resíduos no mesmo figure.",
                                  "learningObjective": "Diagnosticar qualidade do ajuste através da análise de resíduos.",
                                  "commonMistakes": [
                                    "Confundir resíduos com erros absolutos",
                                    "Não plotar linha zero nos resíduos",
                                    "Ignorar autocorrelação nos resíduos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ensaio de compressão de cilindro de concreto (norma ABNT NBR 5738), use dados de carga (kN) vs deformação (mm): x = [0, 100, 200, 300, 400], y = [0, 0.05, 0.12, 0.18, 0.22]. Ajuste a reta para estimar o módulo de elasticidade E = slope * conversão de unidades.",
                              "finalVerifications": [
                                "Código executa sem erros e produz todos os outputs esperados.",
                                "Coeficientes da reta coincidem com cálculo manual aproximado.",
                                "Gráfico de dados + reta mostra sobreposição visual adequada.",
                                "Resíduos são aleatórios, sem padrões evidentes.",
                                "R² > 0.9 para dados lineares simulados.",
                                "Gráficos salvos com labels profissionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão do ajuste (R² e resíduos < 5% do range de y).",
                                "Qualidade dos plots (legibilidade, escalas, legendas).",
                                "Correção do código (uso adequado de polyfit e polyval).",
                                "Interpretação física dos coeficientes.",
                                "Análise diagnóstica dos resíduos.",
                                "Eficiência e modularidade do código."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Princípios de regressão linear e mínimos quadrados.",
                                "Programação: Manipulação de arrays e visualização em Python.",
                                "Física/Mecânica: Modelagem constitutiva linear em materiais.",
                                "Análise de Dados: Diagnóstico de modelos via resíduos.",
                                "Engenharia Experimental: Processamento de dados de ensaios."
                              ],
                              "realWorldApplication": "Na engenharia civil, usado para calibrar extensômetros em ensaios de materiais, modelar deformações em estruturas lineares (ex: vigas), validar linearidade em testes de solo ou concreto, e gerar relatórios de laudos técnicos conforme normas ABNT."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Ajuste de Polinômios Lineares e Avaliação",
                        "description": "Generalização para polinômios lineares de grau superior (y = a0 + a1 x + ... + an x^n) e métricas de avaliação do ajuste como coeficiente de determinação R².",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Formular ajuste para polinômio linear",
                            "description": "Montar o sistema de equações normais A^T A β = A^T y para modelos polinomiais lineares em parâmetros, onde A é a matriz de Vandermonde.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados e definir modelo polinomial",
                                  "subSteps": [
                                    "Colete os dados de entrada: pares (x_i, y_i) para i=1 a n.",
                                    "Escolha o grau do polinômio m (ex: m=2 para quadrático).",
                                    "Verifique se n > m+1 para superdeterminação.",
                                    "Defina o modelo y ≈ β_0 + β_1 x + ... + β_m x^m.",
                                    "Escreva a forma matricial Y = A β + ε."
                                  ],
                                  "verification": "Confirme que os dados estão listados corretamente e o grau m é apropriado (n > m+1).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha ou software como MATLAB/Excel; papel e lápis.",
                                  "tips": "Use dados reais de engenharia civil, como deflexão vs carga.",
                                  "learningObjective": "Compreender a formulação do problema de regressão polinomial linear em parâmetros.",
                                  "commonMistakes": "Escolher m muito alto levando a n ≤ m+1; ignorar outliers nos dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de Vandermonde A",
                                  "subSteps": [
                                    "Crie a matriz A de dimensão n x (m+1), onde A_{i,j} = x_i^{j-1} para j=1 a m+1.",
                                    "Preencha a primeira coluna com 1's (para β_0).",
                                    "Calcule as potências sucessivas de cada x_i.",
                                    "Verifique simetria ou propriedades se aplicável.",
                                    "Armazene A em formato matricial."
                                  ],
                                  "verification": "Multiplique A por um vetor β de teste e veja se reproduz o polinômio avaliado nos x_i.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora matricial ou Python (NumPy); tabela para anotar.",
                                  "tips": "Comece com poucos pontos para testar (n=4, m=1).",
                                  "learningObjective": "Dominar a construção da matriz de base para polinômios.",
                                  "commonMistakes": "Índices errados nas potências (confundir 0-based vs 1-based); erros de cálculo em x_i^k altos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular A^T y e A^T A",
                                  "subSteps": [
                                    "Compute o vetor b = A^T y, onde y é o vetor de observações.",
                                    "Calcule cada elemento b_j = soma_{i=1}^n y_i * x_i^{j-1}.",
                                    "Compute a matriz H = A^T A, com H_{j,k} = soma_{i=1}^n x_i^{j-1 + k-1}.",
                                    "Verifique se H é simétrica positiva definida.",
                                    "Armazene b e H."
                                  ],
                                  "verification": "Confirme simetria de H e dimensões corretas: H (m+1)x(m+1), b (m+1)x1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de álgebra linear (MATLAB, Python NumPy); papel para somas manuais.",
                                  "tips": "Use fórmulas de somas de potências para verificação analítica.",
                                  "learningObjective": "Aplicar multiplicação matricial para formar equações normais.",
                                  "commonMistakes": "Erros em transposição (A^T vs A); somas incorretas em potências elevadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e verificar o sistema normal",
                                  "subSteps": [
                                    "Escreva o sistema H β = b, ou A^T A β = A^T y.",
                                    "Resolva para β (ex: inversa de H ou fatoração QR).",
                                    "Calcule resíduos ε = y - A β.",
                                    "Avalie o erro quadrático soma ε_i^2.",
                                    "Compare com polinômios de graus vizinhos."
                                  ],
                                  "verification": "Verifique se β minimiza ||y - A β||^2 via gradiente nulo ou teste numérico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Solver linear (NumPy linalg.solve); gráfico de resíduos.",
                                  "tips": "Para m baixo, resolva manualmente para entender.",
                                  "learningObjective": "Formular e interpretar as equações normais dos mínimos quadrados.",
                                  "commonMistakes": "Confundir ordem de multiplicação; não condicionar H se mal-condicionada."
                                }
                              ],
                              "practicalExample": "Dados de engenharia civil: 6 pontos de (carga em kN, deflexão em mm): (0,0), (10,2), (20,7), (30,15), (40,25), (50,38). Ajuste polinômio quadrático (m=2). Construa A = [[1,0,0],[1,10,100],...], compute A^T A e A^T y, resolva para β ≈ [0.1, 0.8, 0.01], verificando erro baixo.",
                              "finalVerifications": [
                                "Matriz A tem dimensões n x (m+1) com potências corretas.",
                                "H = A^T A é simétrica e b = A^T y tem dimensões corretas.",
                                "Solução β produz resíduos com soma quadrados mínima.",
                                "Gráfico do polinômio ajustado interpola bem os dados.",
                                "Condição de H é razoável (<10^6 para evitar instabilidade).",
                                "Comparação com grau m-1 mostra melhoria significativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da matriz de Vandermonde (100% correto).",
                                "Cálculos de A^T A e A^T y sem erros aritméticos.",
                                "Formulação explícita do sistema H β = b.",
                                "Interpretação correta dos coeficientes β.",
                                "Análise de resíduos e qualidade do ajuste (R^2 > 0.95).",
                                "Uso eficiente de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Multiplicação matricial e sistemas lineares.",
                                "Estatística: Regressão linear múltipla e análise de variância.",
                                "Programação: Implementação em Python/MATLAB para automação.",
                                "Cálculo: Derivação das equações normais via minimização.",
                                "Engenharia Civil: Modelagem experimental de estruturas."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para ajustar curvas de ensaios de materiais (ex: diagrama tensão-deformação de concreto), previsão de deflexões em vigas, ou calibração de modelos hidrológicos baseados em dados de vazão vs tempo, otimizando projetos estruturais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Calcular o coeficiente de determinação R²",
                            "description": "Computar R² = 1 - (SS_res / SS_tot), onde SS_res é a soma dos quadrados dos resíduos e SS_tot é a soma dos quadrados totais, para avaliar a bondade de ajuste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados e calcular a média dos valores observados (ȳ)",
                                  "subSteps": [
                                    "Colete os valores observados y_i do conjunto de dados.",
                                    "Calcule a média aritmética ȳ = (∑ y_i) / n, onde n é o número de observações.",
                                    "Verifique se os dados estão corretamente pareados com os valores independentes x_i.",
                                    "Registre a média ȳ para uso posterior.",
                                    "Confirme que não há valores ausentes ou outliers não tratados."
                                  ],
                                  "verification": "A média ȳ calculada manualmente coincide com a calculada por software (ex: Excel ou Python).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Conjunto de dados de exemplo (x_i, y_i)",
                                    "Calculadora ou planilha Excel",
                                    "Papel e caneta para cálculos manuais"
                                  ],
                                  "tips": "Use funções prontas como AVERAGE no Excel para validar cálculos manuais.",
                                  "learningObjective": "Compreender o papel da média como referência para variabilidade total.",
                                  "commonMistakes": [
                                    "Esquecer de dividir pela n ao calcular a média.",
                                    "Confundir valores observados com preditos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Soma dos Quadrados Totais (SS_tot)",
                                  "subSteps": [
                                    "Para cada y_i, compute o desvio em relação à média: (y_i - ȳ).",
                                    "Eleve cada desvio ao quadrado: (y_i - ȳ)².",
                                    "Some todos os quadrados: SS_tot = ∑ (y_i - ȳ)².",
                                    "Registre o valor de SS_tot.",
                                    "Valide com fórmula alternativa: SS_tot = ∑ y_i² - (∑ y_i)² / n."
                                  ],
                                  "verification": "SS_tot é positivo e reflete a variância total dos dados; compare com cálculo automatizado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha com dados",
                                    "Software como Python (numpy.var * (n-1)) para validação"
                                  ],
                                  "tips": "Evite arredondamentos prematuros; use precisão decimal alta.",
                                  "learningObjective": "Dominar o cálculo da variabilidade total dos dados observados.",
                                  "commonMistakes": [
                                    "Usar desvio absoluto em vez de quadrado.",
                                    "Incluir a média no somatório incorretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os valores preditos e a Soma dos Quadrados dos Resíduos (SS_res)",
                                  "subSteps": [
                                    "Use os coeficientes do modelo ajustado para calcular ŷ_i para cada x_i.",
                                    "Compute os resíduos: e_i = y_i - ŷ_i.",
                                    "Eleve ao quadrado: e_i².",
                                    "Some: SS_res = ∑ e_i².",
                                    "Confirme que SS_res < SS_tot para um bom ajuste."
                                  ],
                                  "verification": "Resíduos somam zero aproximadamente e SS_res é menor que SS_tot.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Coeficientes do polinômio ajustado (a, b, etc.)",
                                    "Gráfico de resíduos para visualização"
                                  ],
                                  "tips": "Plote ŷ_i vs y_i para inspeção visual do ajuste.",
                                  "learningObjective": "Entender os resíduos como medida de erro do modelo.",
                                  "commonMistakes": [
                                    "Confundir ŷ_i com y_i.",
                                    "Esquecer de quadrado nos resíduos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar e interpretar o coeficiente de determinação R²",
                                  "subSteps": [
                                    "Calcule R² = 1 - (SS_res / SS_tot).",
                                    "Verifique se 0 ≤ R² ≤ 1.",
                                    "Interprete: R² próximo de 1 indica bom ajuste; próximo de 0 indica pobre.",
                                    "Compare com benchmarks do contexto (ex: >0.9 para engenharia).",
                                    "Documente o valor e implicações para o modelo."
                                  ],
                                  "verification": "R² calculado manualmente igual ao de software (ex: scikit-learn r2_score).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Valores de SS_res e SS_tot",
                                    "Tabela de interpretação de R²"
                                  ],
                                  "tips": "Lembre-se: alto R² não implica causalidade.",
                                  "learningObjective": "Aplicar a fórmula de R² e avaliar a qualidade do ajuste.",
                                  "commonMistakes": [
                                    "Dividir SS_tot por SS_res em vez do inverso.",
                                    "Interpretar R² como percentual de causalidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um teste de tração de concreto, dados: deformação x = [0.0001, 0.0002, ..., 0.002], tensão y = [1.2, 2.5, ..., 25] MPa. Após ajuste polinomial linear, SS_tot = 150.3, SS_res = 12.1, R² = 1 - 12.1/150.3 ≈ 0.919, indicando 91.9% da variância explicada pelo modelo.",
                              "finalVerifications": [
                                "R² calculado coincide com implementação em Python/Excel.",
                                "SS_tot e SS_res são positivos e SS_res ≤ SS_tot.",
                                "Interpretação correta: R²=0.92 significa bom ajuste para engenharia.",
                                "Resíduos plotados mostram distribuição aleatória sem padrões.",
                                "Fórmula aplicada corretamente sem erros aritméticos.",
                                "Valor de R² usado para decidir se o modelo é adequado."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de SS_tot e SS_res (erro <1%).",
                                "Correta aplicação da fórmula R² = 1 - (SS_res / SS_tot).",
                                "Interpretação qualitativa apropriada ao contexto de engenharia civil.",
                                "Uso correto de ferramentas computacionais para validação.",
                                "Identificação e correção de erros comuns nos passos.",
                                "Documentação clara dos resultados e implicações."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceitos de variância e decomposição da soma de quadrados.",
                                "Programação: Implementação em Python (numpy, scikit-learn) ou MATLAB.",
                                "Engenharia de Software: Validação de modelos preditivos em simulações.",
                                "Matemática Aplicada: Otimização por mínimos quadrados.",
                                "Análise de Dados: Métricas de avaliação de regressão em big data."
                              ],
                              "realWorldApplication": "Em engenharia civil, R² avalia quão bem um modelo polinomial prediz a resistência de materiais sob carga, auxiliando no dimensionamento seguro de vigas e lajes, evitando falhas estruturais em pontes ou edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Analisar condicionamento do ajuste",
                            "description": "Avaliar a matriz de Gram (A^T A) e discutir ill-conditioning em ajustes polinomiais de alto grau, relacionando com autovalores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Matriz de Gram e Condicionamento",
                                  "subSteps": [
                                    "Revise a formulação do método dos mínimos quadrados lineares para ajuste de polinômios.",
                                    "Defina a matriz de Gram como A^T A, onde A é a matriz de Vandermonde para bases polinomiais.",
                                    "Explique o número de condicionamento κ(A) = ||A|| * ||A^{-1}|| e sua relação com autovalores.",
                                    "Discuta o impacto do ill-conditioning na estabilidade numérica das soluções.",
                                    "Identifique causas de ill-conditioning em polinômios de alto grau, como colinearidade das colunas de A."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e forneça um exemplo simples de κ para uma matriz 2x2.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre mínimos quadrados",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Use diagramas para visualizar a relação entre autovalores pequenos e ill-conditioning.",
                                  "learningObjective": "Entender a base teórica da matriz de Gram e métricas de condicionamento.",
                                  "commonMistakes": [
                                    "Confundir A^T A com A A^T",
                                    "Ignorar o papel dos autovalores na decomposição espectral"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e Calcular a Matriz de Gram para Ajuste Polinomial",
                                  "subSteps": [
                                    "Colete dados de exemplo: pontos (x_i, y_i) simulando medições em uma estrutura civil.",
                                    "Construa a matriz de Vandermonde A para graus polinomiais variáveis (ex: grau 1 a 5).",
                                    "Calcule A^T A manualmente para baixo grau e verifique com software.",
                                    "Analise a simetria e positividade definida da matriz de Gram.",
                                    "Compare matrizes para diferentes graus para observar crescimento de elementos."
                                  ],
                                  "verification": "Gere A^T A para um conjunto de 6 pontos e grau 3; confira diagonal dominante.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha Excel ou Python (NumPy)",
                                    "Dados de exemplo: deformações em viga",
                                    "Software MATLAB para verificação"
                                  ],
                                  "tips": "Normalizar os dados x_i para [-1,1] para reduzir ill-conditioning inicial.",
                                  "learningObjective": "Dominar a construção prática da matriz de Gram em contextos polinomiais.",
                                  "commonMistakes": [
                                    "Escala errada nos powers de x",
                                    "Erro na transposição de A"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Autovalores e Avaliar o Condicionamento",
                                  "subSteps": [
                                    "Compute os autovalores de A^T A usando decomposição espectral.",
                                    "Calcule o número de condicionamento como razão entre maior e menor autovalor (λ_max / λ_min).",
                                    "Repita para polinômios de graus crescentes e registre κ.",
                                    "Interprete valores: κ > 10^6 indica severo ill-conditioning.",
                                    "Visualize autovalores com gráfico de espectro."
                                  ],
                                  "verification": "Para grau 5, mostre κ > 10^10 e liste autovalores ordenados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy para eigvals",
                                    "MATLAB eig() function",
                                    "Gráficos via Matplotlib"
                                  ],
                                  "tips": "Use precisão de dupla para evitar erros de arredondamento em altos graus.",
                                  "learningObjective": "Aplicar análise espectral para quantificar condicionamento.",
                                  "commonMistakes": [
                                    "Usar autovalores de A em vez de A^T A",
                                    "Ignorar autovalores próximos de zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Ill-Conditioning e Estratégias de Mitigação",
                                  "subSteps": [
                                    "Explique por que altos graus causam ill-conditioning (Runge phenomenon indireto).",
                                    "Relacione com soluções: ortogonalização (ex: polinômios de Legendre), regularização.",
                                    "Simule ajuste instável vs estável e compare resíduos.",
                                    "Discuta implicações em engenharia civil: precisão em modelagem de curvas de carga.",
                                    "Redija relatório resumindo achados."
                                  ],
                                  "verification": "Escreva um parágrafo discutindo ill-conditioning em grau 10 vs grau 3.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Artigos sobre polinômios ortogonais",
                                    "Software para regularização (Ridge regression)"
                                  ],
                                  "tips": "Sempre prefira bases ortogonais em prática para evitar esses problemas.",
                                  "learningObjective": "Interpretar resultados e propor soluções práticas.",
                                  "commonMistakes": [
                                    "Atribuir ill-conditioning só a ruído nos dados",
                                    "Não considerar reescalonamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga de concreto, dados de deflexão vs carga são ajustados com polinômios. Para grau 2, κ ≈ 10^3 (bom); para grau 6, κ ≈ 10^12 (ill-conditioned), levando a oscilações espúrias na curva ajustada, simulando falha prematura.",
                              "finalVerifications": [
                                "Calcula corretamente A^T A e seus autovalores para dados dados.",
                                "Identifica corretamente quando κ indica ill-conditioning severo.",
                                "Explica relação entre grau polinomial e spread de autovalores.",
                                "Propõe pelo menos duas estratégias para mitigar ill-conditioning.",
                                "Interpreta impactos em ajustes reais de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matriciais (erro < 1e-10).",
                                "Compreensão conceitual demonstrada em discussões.",
                                "Uso adequado de software para análise espectral.",
                                "Profundidade na interpretação de resultados numéricos.",
                                "Criatividade em conexões com aplicações reais.",
                                "Clareza na documentação de steps e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição em autovalores e SVD.",
                                "Programação Numérica: Implementação em Python/MATLAB.",
                                "Estatística: Análise de resíduos e validação de modelos.",
                                "Engenharia Computacional: Estabilidade em simulações FEM."
                              ],
                              "realWorldApplication": "Na análise de estruturas civis, avaliar condicionamento previne erros em modelagem de curvas de deformação, evitando projetos superdimensionados ou falhas catastróficas em pontes e edifícios sob cargas variáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.4",
                            "name": "Aplicar em problemas de engenharia civil",
                            "description": "Resolver um problema real, como ajuste de curva de tensão-deformação ou carga-deflexão, usando mínimos quadrados lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o problema e coletar dados experimentais",
                                  "subSteps": [
                                    "Analise o problema de engenharia civil, como curva tensão-deformação de um aço ou carga-deflexão de uma viga.",
                                    "Reúna dados experimentais reais ou simulados (pares x,y), garantindo pelo menos 10 pontos para robustez.",
                                    "Registre unidades (ex: MPa para tensão, mm para deformação) e condições experimentais.",
                                    "Visualize os dados em gráfico scatter para identificar tendência linear.",
                                    "Defina o modelo linear proposto: y = a*x + b."
                                  ],
                                  "verification": "Gráfico scatter plot mostra tendência linear clara nos dados coletados.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Planilha Excel ou Python (matplotlib), dados experimentais de tensão-deformação ou carga-deflexão.",
                                  "tips": "Use dados reais de ensaios ASTM para autenticidade.",
                                  "learningObjective": "Compreender como dados experimentais se relacionam com modelos lineares em engenharia civil.",
                                  "commonMistakes": "Ignorar outliers ou não converter unidades consistentemente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar dados e formular equações dos mínimos quadrados",
                                  "subSteps": [
                                    "Liste os valores de x (deformação ou deflexão) e y (tensão ou carga).",
                                    "Calcule as somas necessárias: Σx, Σy, Σxy, Σx².",
                                    "Se necessário, linearize o modelo (ex: para não-linearidades leves).",
                                    "Configure as equações normais: a = (nΣxy - ΣxΣy)/(nΣx² - (Σx)²), b = (Σy - aΣx)/n.",
                                    "Verifique dimensionalidade dos dados para evitar erros numéricos."
                                  ],
                                  "verification": "Equações normais formuladas corretamente com somas precisas calculadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora científica, planilha Excel ou script Python/NumPy.",
                                  "tips": "Use funções SUM e SUMPRODUCT no Excel para automação.",
                                  "learningObjective": "Dominar a formulação matemática dos mínimos quadrados lineares.",
                                  "commonMistakes": "Erro no cálculo de somas ou divisão por zero em denominador pequeno."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar mínimos quadrados e ajustar a curva",
                                  "subSteps": [
                                    "Resolva as equações para obter coeficientes a (inclinação) e b (interseção).",
                                    "Gere valores preditos ŷ = a*x + b para todos x.",
                                    "Calcule resíduos (y - ŷ) e soma de quadrados dos resíduos (SSR).",
                                    "Implemente em software para plotar curva ajustada sobre dados.",
                                    "Calcule coeficiente de determinação R² = 1 - (SSR/SST), onde SST é variância total."
                                  ],
                                  "verification": "Coeficientes a e b calculados, com R² > 0.9 indicando bom ajuste.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python (NumPy, SciPy.linregress), MATLAB ou Excel (função TREND).",
                                  "tips": "Use np.polyfit(x,y,1) no Python para verificação rápida.",
                                  "learningObjective": "Executar computacionalmente o ajuste de curvas lineares.",
                                  "commonMistakes": "Confundir a e b ou não normalizar dados para grandes escalas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar ajuste e interpretar no contexto da engenharia",
                                  "subSteps": [
                                    "Analise resíduos para homocedasticidade e ausência de padrões.",
                                    "Interprete a (módulo de elasticidade E) e b (tensão inicial).",
                                    "Preveja valores fora do intervalo (extrapolação com cautela).",
                                    "Compare com normas de engenharia civil (ex: ABNT NBR para materiais).",
                                    "Documente relatório com gráficos, equação e métricas."
                                  ],
                                  "verification": "Relatório inclui interpretação física correta e R² alto com resíduos aleatórios.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software de plotagem, normas técnicas (ABNT/ASTM).",
                                  "tips": "Sempre valide com testes estatísticos como teste F se possível.",
                                  "learningObjective": "Aplicar resultados do ajuste em decisões de engenharia civil.",
                                  "commonMistakes": "Sobreinterpretar R² alto sem checar resíduos ou extrapolação excessiva."
                                }
                              ],
                              "practicalExample": "Em um ensaio de tração de aço estrutural, dados de tensão (MPa) vs. deformação (%): ajuste linear para região elástica, obtendo E ≈ 200 GPa, usado para dimensionar cabos em ponte pênsil.",
                              "finalVerifications": [
                                "R² ≥ 0.95 para dados lineares.",
                                "Resíduos aleatórios sem padrões (gráfico Q-Q).",
                                "Coeficientes fisicamente coerentes (ex: E positivo e realista).",
                                "Previsões dentro de ±5% dos dados experimentais.",
                                "Gráfico final com curva sobreposta aos pontos.",
                                "Relatório documenta todas somas e cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática dos coeficientes (erro <1%).",
                                "Qualidade do ajuste visual e métrica R².",
                                "Interpretação correta no contexto civil (unidades, significado físico).",
                                "Tratamento adequado de dados e erros comuns evitados.",
                                "Relatório claro e completo com gráficos.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e estatística descritiva.",
                                "Física: Mecânica dos materiais e comportamento elástico.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Estatística: Análise de regressão e validação de modelos."
                              ],
                              "realWorldApplication": "Dimensionamento de estruturas como vigas e colunas em edifícios, verificação de conformidade com normas de segurança (ex: previsão de deflexão máxima sob carga viva), otimização de materiais em projetos de pontes e barragens."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Ajuste de Curvas Não-Lineares",
                    "description": "Métodos iterativos para ajustar funções não-lineares a conjuntos de dados, como regressão não-linear.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Formulação do Problema de Ajuste de Curvas Não-Lineares",
                        "description": "Definição do problema de regressão não-linear, incluindo a modelagem de funções não-lineares e a minimização da soma dos quadrados dos resíduos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Identificar modelos não-lineares adequados",
                            "description": "Selecionar e formular funções não-lineares (ex: exponencial, potência, logística) para ajustar a conjuntos de dados experimentais em problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o contexto físico e preparar os dados experimentais",
                                  "subSteps": [
                                    "Revisar o problema de engenharia civil, identificando o fenômeno físico (ex: deformação em solos ou concreto).",
                                    "Definir variáveis independentes (ex: tempo, carga) e dependentes (ex: deformação, assentamento).",
                                    "Examinar propriedades dos dados: faixa de valores, unidades, número de pontos e presença de ruído.",
                                    "Limpar dados: remover ou tratar outliers e valores ausentes."
                                  ],
                                  "verification": "Relatório inicial com descrição das variáveis, faixa de dados e limpeza realizada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Conjunto de dados em CSV/Excel, software de planilhas (Excel) ou Python (Pandas).",
                                  "tips": "Registre unidades para evitar erros de escala nas modelagens.",
                                  "learningObjective": "Entender o background físico e preparar dados limpos para análise.",
                                  "commonMistakes": "Ignorar o contexto físico ou não tratar outliers, levando a modelos inadequados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualizar os dados graficamente",
                                  "subSteps": [
                                    "Plotar gráfico de dispersão (x vs y) em escala linear.",
                                    "Testar transformações: gráficos em escalas log-log, semi-log para linearizar possíveis modelos.",
                                    "Identificar tendências visuais: crescimento rápido, saturação ou potência.",
                                    "Adicionar linhas de tendência manuais para padrões iniciais.",
                                    "Salvar gráficos com legendas claras."
                                  ],
                                  "verification": "Gráficos gerados mostrando padrões não-lineares evidentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (Matplotlib, NumPy) ou Excel/MATLAB para plotagem.",
                                  "tips": "Use escalas logarítmicas para revelar linearidade em modelos potência ou exponencial.",
                                  "learningObjective": "Visualizar padrões não-lineares para guiar a seleção de modelos.",
                                  "commonMistakes": "Plotar apenas em escala linear, perdendo padrões ocultos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar características não-lineares nos dados",
                                  "subSteps": [
                                    "Observar assintotas horizontais ou verticais nos gráficos.",
                                    "Detectar pontos de inflexão ou curvas em 'S' (sigmoide).",
                                    "Avaliar taxa de crescimento: inicial rápida (exponencial), proporcional (potência) ou limitante (logística).",
                                    "Comparar com comportamento físico esperado (ex: saturação em solos).",
                                    "Anotar 3-5 características chave."
                                  ],
                                  "verification": "Lista anotada de 3-5 características não-lineares identificadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráficos do passo anterior, caderno ou documento digital.",
                                  "tips": "Relacione características aos princípios físicos da engenharia civil.",
                                  "learningObjective": "Reconhecer assinaturas de diferentes não-linearidades.",
                                  "commonMistakes": "Confundir ruído com padrão real ou ignorar limites físicos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com modelos não-lineares padrão",
                                  "subSteps": [
                                    "Listar candidatos: exponencial (y = a*e^(bx)), potência (y = a*x^b), logística (y = L/(1+e^(-k(x-x0)))).",
                                    "Superpor curvas qualitativas nos gráficos para cada modelo.",
                                    "Avaliar adequação visual: melhor sobreposição e consistência com características.",
                                    "Consultar literatura de engenharia civil para modelos comuns em contextos similares.",
                                    "Ranquear 2-3 melhores candidatos."
                                  ],
                                  "verification": "Tabela de comparação com rankings e justificativas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software de plotagem (Python/MATLAB), tabelas de referência de modelos.",
                                  "tips": "Comece com o modelo mais simples que capture a essência.",
                                  "learningObjective": "Associar padrões de dados a formas funcionais específicas.",
                                  "commonMistakes": "Escolher modelo complexo sem necessidade (princípio da parcimônia)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Formular e justificar o modelo selecionado",
                                  "subSteps": [
                                    "Escrever a equação do modelo escolhido com parâmetros simbólicos.",
                                    "Propor valores iniciais para parâmetros baseados em física/dados.",
                                    "Justificar escolha: ligação com visualização, características e contexto.",
                                    "Preparar para ajuste numérico (ex: least-squares).",
                                    "Documentar alternativas descartadas e motivos."
                                  ],
                                  "verification": "Equação formulada, justificativa escrita e preparação para ajuste.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto ou Jupyter Notebook, referências teóricas.",
                                  "tips": "Inclua limites físicos nos parâmetros (ex: capacidade máxima).",
                                  "learningObjective": "Formular modelo acionável e justificável para otimização.",
                                  "commonMistakes": "Não justificar adequadamente, enfraquecendo a robustez."
                                }
                              ],
                              "practicalExample": "Dados de assentamento de solo em uma fundação ao longo do tempo: deformação inicial rápida (exponencial), estabilizando em platô. Visualização em semi-log revela linearidade, levando à seleção de modelo exponencial y = a*(1 - e^(-bt)) para prever estabilização.",
                              "finalVerifications": [
                                "O modelo captura todas as características principais dos dados (assintotas, inflexões)?",
                                "A formulação reflete o comportamento físico esperado na engenharia civil?",
                                "Gráficos mostram boa sobreposição qualitativa?",
                                "Justificativa liga dados, visualização e teoria?",
                                "Modelo é o mais simples possível sem perda de precisão?",
                                "Preparado para ajuste numérico com parâmetros iniciais viáveis?"
                              ],
                              "assessmentCriteria": [
                                "Precisão da identificação de padrões não-lineares (80%+ adequação visual).",
                                "Justificativa física e técnica robusta (mínimo 3 argumentos).",
                                "Uso correto de visualizações e transformações (escalas log).",
                                "Seleção parcimoniosa de modelo (prefere simplicidade).",
                                "Documentação completa e clara.",
                                "Preparação adequada para próxima etapa de ajuste."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise exploratória de dados e regressão não-linear.",
                                "Física/Mecânica dos Solos: Comportamentos constitutivos de materiais.",
                                "Programação Computacional: Uso de bibliotecas como SciPy para otimização.",
                                "Matemática Aplicada: Transformações logarítmicas e funções especiais."
                              ],
                              "realWorldApplication": "Na análise de subsidência de barragens ou fundações, onde modelos logísticos preveem estabilização de solos saturados, otimizando projetos para evitar colapsos e reduzir custos de monitoramento."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Calcular resíduos e função objetivo",
                            "description": "Computar resíduos ponderados e definir a função de custo (soma dos quadrados dos resíduos) para um conjunto de dados e parâmetros iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Resíduos e Função Objetivo",
                                  "subSteps": [
                                    "Defina resíduo como a diferença entre o valor observado (y_i) e o valor previsto pelo modelo (ŷ_i(θ)) para cada ponto de dados.",
                                    "Explique resíduos ponderados: r_i,w = w_i * (y_i - ŷ_i(θ)), onde w_i é o peso baseado em incerteza ou importância.",
                                    "Descreva a função de custo como a soma dos quadrados dos resíduos: J(θ) = Σ r_i² ou Σ r_i,w² para ponderados.",
                                    "Discuta o papel da função objetivo no ajuste de curvas não-lineares como minimizar J(θ) para encontrar melhores parâmetros."
                                  ],
                                  "verification": "Escreva as fórmulas em um papel e explique verbalmente para um colega ou grave um vídeo curto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Notas de aula sobre ajuste de curvas",
                                    "Calculadora ou software como Python/Jupyter"
                                  ],
                                  "tips": [
                                    "Use analogia: resíduos são 'erros de previsão' que queremos minimizar.",
                                    "Memorize fórmulas básicas antes de calcular."
                                  ],
                                  "learningObjective": "Dominar definições e fórmulas de resíduos e função objetivo em contexto de ajuste não-linear.",
                                  "commonMistakes": [
                                    "Confundir resíduo com erro absoluto (use quadrado para penalizar grandes erros)",
                                    "Esquecer pesos em resíduos ponderados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Dados e Definir Modelo com Parâmetros Iniciais",
                                  "subSteps": [
                                    "Colete ou carregue o conjunto de dados: liste pares (x_i, y_i) observados, ex: cargas e deformações em uma viga.",
                                    "Escolha o modelo não-linear, ex: deformação ε = a * σ^b para tensão σ (parâmetros iniciais θ_0 = [a=1.0, b=0.5]).",
                                    "Defina pesos w_i se aplicável (ex: w_i = 1/σ_y_i² para variância).",
                                    "Organize em tabela: colunas para x_i, y_i, ŷ_i(θ_0), r_i."
                                  ],
                                  "verification": "Crie uma tabela completa com dados e parâmetros iniciais; verifique se todos valores estão corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Dados de exemplo: 5-10 pontos de tensão-deformação de concreto",
                                    "Documentação do modelo constitutivo"
                                  ],
                                  "tips": [
                                    "Comece com dados reais de experimentos civis para relevância.",
                                    "Use valores iniciais razoáveis baseados em literatura."
                                  ],
                                  "learningObjective": "Preparar inputs necessários para cálculos de resíduos de forma organizada.",
                                  "commonMistakes": [
                                    "Escolher parâmetros iniciais irreais levando a resíduos explosivos",
                                    "Ignorar unidades inconsistentes entre x e y"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Resíduos Individuais e Ponderados",
                                  "subSteps": [
                                    "Para cada i, compute ŷ_i(θ_0) usando o modelo e parâmetros iniciais.",
                                    "Calcule resíduo não-ponderado: r_i = y_i - ŷ_i(θ_0).",
                                    "Se ponderado, aplique w_i * r_i.",
                                    "Registre todos r_i e r_i,w em tabela, plotando gráfico de resíduos vs x_i para visualização."
                                  ],
                                  "verification": "Some manualmente alguns r_i e compare com cálculo em software; gráfico deve mostrar padrão aleatório ideal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software Python com NumPy/Matplotlib ou MATLAB",
                                    "Papel milimetrado para plot manual"
                                  ],
                                  "tips": [
                                    "Automatize com loop em código para eficiência.",
                                    "Verifique sinal dos resíduos (positivo/negativo indica sub/sobre-estima)."
                                  ],
                                  "learningObjective": "Executar cálculos precisos de resíduos para todo dataset.",
                                  "commonMistakes": [
                                    "Erro aritmético em ŷ_i (verifique exponenciações)",
                                    "Confundir ordem: y_obs - y_mod, não inverso"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir e Computar a Função de Custo",
                                  "subSteps": [
                                    "Some os quadrados: J(θ_0) = Σ_{i=1}^n r_i² (não-ponderado) ou Σ r_i,w².",
                                    "Compare com valor esperado ou benchmark de literatura.",
                                    "Analise magnitude de J: valores altos indicam parâmetros ruins iniciais.",
                                    "Documente J(θ_0) como baseline para otimização futura."
                                  ],
                                  "verification": "Recalcule J com subconjunto de dados para validação cruzada; deve coincidir.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou script Python",
                                    "Gráfico de J vs iterações (preparar para próximo)"
                                  ],
                                  "tips": [
                                    "Use função soma em Excel para rapidez.",
                                    "Log J em escala para grandes datasets."
                                  ],
                                  "learningObjective": "Computar e interpretar função objetivo como métrica de ajuste.",
                                  "commonMistakes": [
                                    "Esquecer quadrado (soma linear não penaliza adequadamente)",
                                    "Incluir i=0 ou índices errados"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Interpretar Resultados",
                                  "subSteps": [
                                    "Verifique normalidade dos resíduos (histograma ou teste QQ).",
                                    "Calcule estatísticas: média r_i ≈0, variância.",
                                    "Discuta implicações: J alto sugere necessidade de otimização.",
                                    "Prepare relatório resumido com tabela, gráfico e J."
                                  ],
                                  "verification": "Compartilhe relatório com peer review; J deve ser consistente em recálculo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plot (Matplotlib/Excel)",
                                    "Templates de relatório"
                                  ],
                                  "tips": [
                                    "Sempre plote resíduos para detectar heterocedasticidade.",
                                    "Compare com ajustes lineares simples."
                                  ],
                                  "learningObjective": "Garantir validade dos cálculos e insights iniciais.",
                                  "commonMistakes": [
                                    "Ignorar outliers inflando J",
                                    "Não normalizar dados se escalas variam"
                                  ]
                                }
                              ],
                              "practicalExample": "Em teste de compressão de concreto: dados (σ=[0,10,20,30,40] MPa, ε=[0,0.0005,0.0012,0.0025,0.005] un.). Modelo ε=a*σ^b, θ_0=[a=0.0001, b=1.2]. Calcule r_i=ε_obs-ε_mod, J=Σ r_i² ≈0.000012 (exato varia).",
                              "finalVerifications": [
                                "Todos r_i calculados corretamente para n pontos.",
                                "J(θ_0) matches recálculo independente.",
                                "Gráfico de resíduos sem padrões sistemáticos.",
                                "Pesos aplicados uniformemente se usados.",
                                "Documentação completa com fórmulas e valores.",
                                "Interpretação coerente com dados civis.",
                                "Baseline J pronto para minimização."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos r_i e J (erro <1%).",
                                "Uso correto de fórmulas ponderadas.",
                                "Organização clara em tabelas/gráficos.",
                                "Interpretação física relevante (ex: subestimação de deformação).",
                                "Eficiência temporal nos cálculos.",
                                "Detecção de erros comuns evitada.",
                                "Relatório profissional e completo."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Método dos mínimos quadrados e análise de resíduos.",
                                "Programação: Implementação numérica em Python/Octave para automação.",
                                "Matemática: Otimização não-linear e cálculo diferencial.",
                                "Física/Mecânica: Modelos constitutivos de materiais em engenharia.",
                                "Química dos Materiais: Comportamento não-linear de concreto/polímeros."
                              ],
                              "realWorldApplication": "Na calibração de modelos constitutivos para simulação de estruturas civis (ex: vigas de concreto em pontes), onde resíduos minimizados garantem previsões precisas de deformações e falhas sob cargas reais, otimizando design e segurança contra colapsos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Avaliar condicionamento inicial",
                            "description": "Analisar a matriz de Gram e autovalores para verificar o condicionamento do problema de ajuste não-linear.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular e construir a matriz de Gram para o problema de ajuste não-linear",
                                  "subSteps": [
                                    "Relembrar a definição da matriz de Gram como G = J^T J, onde J é a matriz Jacobiana das funções modelo avaliadas nos dados.",
                                    "Coletar os dados experimentais (x_i, y_i) e definir o modelo não-linear y = f(x, β).",
                                    "Computar numericamente a Jacobiana J avaliando derivadas parciais ∂f/∂β_j em pontos representativos.",
                                    "Multiplicar J^T por J para obter a matriz de Gram G.",
                                    "Verificar simetria e positividade semi-definida de G."
                                  ],
                                  "verification": "Conferir se G é simétrica (G = G^T) e todos os elementos estão corretos comparando com cálculo manual para submatriz pequena.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software computacional (Python com NumPy/SciPy ou MATLAB), dados de exemplo em planilha CSV.",
                                  "tips": "Use aproximações finitas para derivadas se analíticas forem complexas: ∂f/∂β ≈ [f(β + ε) - f(β - ε)] / (2ε).",
                                  "learningObjective": "Compreender a origem da matriz de Gram no método dos mínimos quadrados não-lineares.",
                                  "commonMistakes": "Confundir Jacobiana com Hessiana; usar dados ruidosos sem pré-processamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os autovalores da matriz de Gram",
                                  "subSteps": [
                                    "Implementar ou usar função built-in para decomposição em autovalores (e.g., np.linalg.eigvals em Python).",
                                    "Executar o cálculo na matriz G obtida.",
                                    "Ordenar os autovalores em ordem decrescente: λ1 ≥ λ2 ≥ ... ≥ λp.",
                                    "Identificar o maior (λ_max) e o menor autovalor não-nulo (λ_min).",
                                    "Verificar se há autovalores próximos de zero, indicando singularidade."
                                  ],
                                  "verification": "Comparar autovalores com trace(G)/p (média aproximada) e confirmar que soma dos autovalores equals trace(G).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (NumPy, SciPy) ou MATLAB, script Jupyter Notebook para reproducibilidade.",
                                  "tips": "Escalone G antes se necessário para evitar overflow numérico.",
                                  "learningObjective": "Dominar o cálculo numérico de autovalores e sua interpretação espectral.",
                                  "commonMistakes": "Ignorar autovalores zero ou negativos devido a ruído numérico; não ordenar corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar o número de condicionamento κ",
                                  "subSteps": [
                                    "Calcular κ = λ_max / λ_min, onde λ_min é o menor autovalor positivo.",
                                    "Se λ_min ≈ 0, considerar o problema mal condicionado.",
                                    "Comparar κ com thresholds típicos: κ < 10^3 bem condicionado, >10^6 mal condicionado.",
                                    "Realizar análise de sensibilidade variando ligeiramente os dados.",
                                    "Documentar o valor de κ e intervalos de confiança."
                                  ],
                                  "verification": "Recalcular κ com subconjunto de dados e verificar consistência (variação <5%).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesmos do step anterior, calculadora para thresholds.",
                                  "tips": "Use log(κ) para evitar underflow em κ muito grande.",
                                  "learningObjective": "Aplicar o conceito de número de condicionamento para avaliar estabilidade numérica.",
                                  "commonMistakes": "Dividir por autovalor zero; usar norma Frobenius em vez de espectral."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o condicionamento e propor ajustes iniciais",
                                  "subSteps": [
                                    "Classificar: bem condicionado (κ baixo), moderado ou mal condicionado (κ alto).",
                                    "Se mal condicionado, sugerir reparametrização do modelo ou normalização de variáveis.",
                                    "Avaliar impacto em iterativos como Gauss-Newton.",
                                    "Gerar relatório com κ, autovalores e recomendações.",
                                    "Testar com simulação de ruído para robustez."
                                  ],
                                  "verification": "Simular ajuste com e sem correções e comparar resíduos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de otimização (SciPy.optimize.leastsq), relatório em Markdown/PDF.",
                                  "tips": "Priorize reescalonamento de parâmetros para λ_min próximo de 1.",
                                  "learningObjective": "Interpretar resultados de condicionamento no contexto de otimização não-linear.",
                                  "commonMistakes": "Subestimar efeitos de correlação entre parâmetros; ignorar contexto físico."
                                }
                              ],
                              "practicalExample": "Em um experimento de deformação de vigas de concreto (Engenharia Civil), com dados de carga vs. deslocamento, construa G para modelo exponencial σ = a * exp(b*ε). Calcule autovalores [1e5, 1e3, 10], κ=1e4 (moderado), sugerindo normalizar ε para [0,1].",
                              "finalVerifications": [
                                "Matriz G é simétrica positiva semi-definida.",
                                "Autovalores ordenados corretamente com λ_min > 1e-10.",
                                "Número de condicionamento κ calculado com precisão relativa <1%.",
                                "Interpretação alinhada com thresholds padrão.",
                                "Recomendações práticas documentadas.",
                                "Teste de sensibilidade confirma estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da Jacobiana e G (erro <1e-6).",
                                "Correta identificação de λ_max e λ_min.",
                                "Interpretação qualitativa e quantitativa de κ.",
                                "Propostas de mitigação viáveis e justificadas.",
                                "Clareza no relatório com visualizações (e.g., espectro de autovalores).",
                                "Integração com contexto de Engenharia Civil."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição espectral e normas de matriz.",
                                "Estatística: Análise de mínimos quadrados e multicolinearidade.",
                                "Programação Numérica: Implementação em Python/MATLAB.",
                                "Análise Numérica: Estabilidade de algoritmos iterativos."
                              ],
                              "realWorldApplication": "Na modelagem de curvas de tensão-deformação para dimensionamento de estruturas civis, avaliar condicionamento inicial previne falhas em previsões de colapso, otimizando projetos de pontes e edifícios contra sobrecargas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Métodos Iterativos para Otimização Não-Linear",
                        "description": "Algoritmos iterativos baseados em otimização, como método de Newton-Gauss e Levenberg-Marquardt, para solução de equações não-lineares no ajuste de curvas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Implementar método dos menores quadrados não-lineares",
                            "description": "Aplicar iterações do método Gauss-Newton para minimizar resíduos, resolvendo sistemas lineares aproximados em cada passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o modelo não-linear e preparar dados",
                                  "subSteps": [
                                    "Defina a função modelo não-linear f(x, β) onde β são os parâmetros a estimar.",
                                    "Colete ou simule dados observados y com variáveis independentes x.",
                                    "Escolha valores iniciais razoáveis para β₀ baseados em conhecimento do domínio.",
                                    "Implemente função para calcular resíduos r = y - f(x, β).",
                                    "Teste cálculo inicial de resíduos com β₀."
                                  ],
                                  "verification": "Resíduos iniciais calculados corretamente e plotados contra x para visualização.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy e Matplotlib; conjunto de dados exemplo (ex: assentamento de solo).",
                                  "tips": "Use plots para validar dados e modelo inicial; evite valores iniciais extremos.",
                                  "learningObjective": "Compreender a formulação do problema de mínimos quadrados não-lineares.",
                                  "commonMistakes": "Escolha de β₀ inadequada levando a divergência; ignorar unidades dos dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar cálculo do Jacobiano e resíduos",
                                  "subSteps": [
                                    "Defina a matriz Jacobiana J como derivadas parciais ∂f/∂βⱼ avaliadas em x e β atual.",
                                    "Implemente função analítica ou numérica para J (prefira analítica para precisão).",
                                    "Calcule resíduos r(β) e J(β) para iteração atual.",
                                    "Verifique dimensionalidade: J deve ser m x p (m pontos, p parâmetros).",
                                    "Teste com valores conhecidos para validar derivadas."
                                  ],
                                  "verification": "Jacobiano calculado e multiplicado por vetor teste produz gradiente esperado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy para derivadas numéricas opcionais; calculadora simbólica como SymPy.",
                                  "tips": "Use finite differences para protótipo rápido, mas otimize com analítico.",
                                  "learningObjective": "Dominar computação do Jacobiano essencial para aproximação linear.",
                                  "commonMistakes": "Erros de sinal nas derivadas; Jacobiano singular devido a colinearidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações do método Gauss-Newton",
                                  "subSteps": [
                                    "Em loop: resolva sistema normal Jᵀ J Δβ = Jᵀ r para Δβ usando np.linalg.solve.",
                                    "Atualize β ← β + Δβ.",
                                    "Recalcule r e J com novo β.",
                                    "Monitore norma de r ou Δβ para progresso.",
                                    "Limite iterações máximas (ex: 100) para evitar loops infinitos."
                                  ],
                                  "verification": "Parâmetros atualizam corretamente em pelo menos 3 iterações simuladas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com NumPy para solvers lineares; debugger para rastrear iterações.",
                                  "tips": "Registre histórico de β e ||r|| em lista para análise posterior.",
                                  "learningObjective": "Aplicar iterações Gauss-Newton para minimizar resíduos quadraticamente.",
                                  "commonMistakes": "Não transpor J corretamente; step size Δβ muito grande causando overshoot."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar critérios de convergência e validação",
                                  "subSteps": [
                                    "Defina critérios: ||Δβ|| < tol1, ||r|| < tol2, ou iterações máx atingidas.",
                                    "Pare o loop quando critérios satisfeitos.",
                                    "Calcule métricas finais: soma quadrados resíduos (SSR), R² ajustado.",
                                    "Plote curva ajustada vs dados observados.",
                                    "Compare com solução conhecida ou biblioteca (ex: curve_fit)."
                                  ],
                                  "verification": "Algoritmo converge em <20 iterações com SSR < threshold.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matplotlib para plots; SciPy.optimize.curve_fit para benchmark.",
                                  "tips": "Use tol = 1e-6; ajuste damping se necessário para estabilidade.",
                                  "learningObjective": "Garantir convergência robusta e validar solução.",
                                  "commonMistakes": "Critérios frouxos levando a soluções imprecisas; ignorar warnings de singularidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e refinar implementação",
                                  "subSteps": [
                                    "Calcule intervalos de confiança via aproximação assintótica (cov = (JᵀJ)⁻¹).",
                                    "Teste sensibilidade a β₀ diferentes.",
                                    "Otimize código para eficiência (vetorização).",
                                    "Documente função completa com docstring.",
                                    "Execute em dataset real de engenharia civil."
                                  ],
                                  "verification": "Código roda sem erros, resultados coincidem com SciPy em 1e-4.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Jupyter Notebook para experimentação; dados reais de assentamento.",
                                  "tips": "Vectorize loops com NumPy para speed-up.",
                                  "learningObjective": "Refinar e robustecer implementação para uso prático.",
                                  "commonMistakes": "Sobreajuste ignorando R²; não testar múltiplos inicializadores."
                                }
                              ],
                              "practicalExample": "Ajustar modelo exponencial y = a * exp(-b t) + c a dados de assentamento de fundação ao longo do tempo t, usando dados simulados com ruído: t=[0,1,2,3,4,5], y=[10.0,7.5,5.8,4.5,3.6,2.9], β₀=[10,0.2,0]. Após 5 iterações, converge para a≈10.2, b≈0.22, c≈0.1 com SSR<0.01.",
                              "finalVerifications": [
                                "Norma dos resíduos finais < 1e-4 * norma inicial.",
                                "Mudança em β < 1e-6 entre iterações consecutivas.",
                                "Curva plotada sobrepõe dados com resíduos aleatórios.",
                                "Solução bate com SciPy curve_fit em 3 casas decimais.",
                                "Código executa em <1s para 100 pontos.",
                                "Intervalos de confiança razoáveis (<20% de β)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro relativo <1% vs solução analítica/biblioteca.",
                                "Eficiência: converge em ≤15 iterações para casos padrão.",
                                "Robustez: lida com 3 β₀ diferentes sem falha.",
                                "Clareza: código comentado, funções modulares.",
                                "Validação: plots e métricas incluídos.",
                                "Escalabilidade: vetorizado para n>1000 pontos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: resolução de JᵀJ Δβ = Jᵀr.",
                                "Cálculo: derivadas parciais para Jacobiano.",
                                "Programação: loops, vetores, solvers numéricos.",
                                "Estatística: análise de resíduos e R².",
                                "Engenharia Civil: modelagem de dados experimentais."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para calibrar modelos de assentamento de solos não-lineares em fundações, previsão de deformações em barragens, ou ajuste de curvas de carga-descarga em estruturas, permitindo simulações precisas e otimização de projetos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Usar algoritmo Levenberg-Marquardt",
                            "description": "Implementar o algoritmo híbrido que combina gradiente e Newton para melhorar convergência em problemas mal-condicionados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Algoritmo Levenberg-Marquardt",
                                  "subSteps": [
                                    "Estude o problema de minimização de soma de quadrados de resíduos: min ||r(x)||^2 onde r(x) são os resíduos.",
                                    "Revise o método de Gauss-Newton: atualização Δx = (J^T J)^{-1} J^T r, onde J é a Jacobiana.",
                                    "Entenda o gradiente descendente: atualização Δx = -α ∇f, com ∇f = J^T r.",
                                    "Aprenda o papel do parâmetro de damping λ: combina as duas abordagens via (J^T J + λ I)^{-1} J^T r.",
                                    "Analise como λ grande favorece gradiente e λ pequeno favorece Newton."
                                  ],
                                  "verification": "Resuma em um diagrama ou parágrafo como o LM transita entre GD e GN.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Documentação oficial do algoritmo (ex: Wikipedia ou paper original), caderno de notas, calculadora matricial online.",
                                  "tips": "Desenhe fluxogramas para visualizar a hibridização.",
                                  "learningObjective": "Dominar os princípios teóricos que justificam a robustez do LM em problemas mal-condicionados.",
                                  "commonMistakes": "Confundir Jacobiana com Hessiana; ignorar que LM aproxima a Hessiana."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Parâmetros Iniciais e Inicializar o Algoritmo",
                                  "subSteps": [
                                    "Defina a função de custo f(x) = 0.5 ||r(x)||^2 e compute resíduos iniciais r(x0).",
                                    "Calcule a Jacobiana inicial J(x0) numericamente ou analiticamente.",
                                    "Escolha x0 (parâmetros iniciais), λ inicial (ex: 0.01), fatores de ajuste v=10, μ=10.",
                                    "Defina critérios de parada: tolerância em ||Δx|| < εx, ||∇f|| < εg, iterações máx=100.",
                                    "Prepare estrutura de dados para armazenar histórico de iterações."
                                  ],
                                  "verification": "Verifique se J(x0) está correta comparando com diferenças finitas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy e SciPy, Jupyter Notebook, dataset de exemplo (ex: dados sintéticos de curva exponencial).",
                                  "tips": "Use λ inicial pequeno para problemas bem-condicionados; teste sensibilidade.",
                                  "learningObjective": "Configurar corretamente os hiperparâmetros para garantir convergência estável.",
                                  "commonMistakes": "Escolha ruim de x0 levando a mínimos locais; λ fixo sem ajuste dinâmico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Loop Iterativo Principal",
                                  "subSteps": [
                                    "No loop: compute J e r atuais.",
                                    "Resolva o sistema (J^T J + λ diag(J^T J)) Δx = -J^T r para Δx.",
                                    "Teste candidato x_new = x + Δx: compute ganho ρ = (f(x) - f(x_new)) / modelo predito.",
                                    "Atualize λ: se ρ > 0.75, λ /= 10; senão λ *= μ. Aceite x_new se ρ > 0.25.",
                                    "Repita até critério de parada."
                                  ],
                                  "verification": "Execute 5 iterações manuais em papel para um toy problem e confira Δx.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Código Python (NumPy para álgebra linear, linalg.solve), debugger.",
                                  "tips": "Use decomposição QR para resolver o sistema em problemas grandes.",
                                  "learningObjective": "Codificar o coração do algoritmo com ajuste adaptativo de λ.",
                                  "commonMistakes": "Erro na diagonal de damping (deve ser λ * diag(J^T J), não λ I); divisão por zero em λ=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a Implementação e Analisar Resultados",
                                  "subSteps": [
                                    "Compare com função built-in (ex: scipy.optimize.leastsq).",
                                    "Plote curvas ajustadas vs dados, resíduos vs iterações.",
                                    "Compute métricas: R², RMSE, número de iterações, tempo CPU.",
                                    "Teste sensibilidade variando x0 e λ inicial.",
                                    "Documente código com comentários e gere relatório."
                                  ],
                                  "verification": "R² > 0.95 e convergência em <50 iterações para dataset padrão.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Matplotlib para plots, dataset real de engenharia civil (ex: ensaio de compressão).",
                                  "tips": "Salve histórico para diagnosticar falhas de convergência.",
                                  "learningObjective": "Avaliar robustez e precisão da implementação em cenários reais.",
                                  "commonMistakes": "Ignorar normalização de dados; sobreajuste sem validação cruzada."
                                }
                              ],
                              "practicalExample": "Implemente o LM para ajustar o modelo σ = a (1 - e^{-b ε}) a dados de ensaio de tração em concreto, onde σ é tensão, ε deformação, otimizando a e b para minimizar resíduos entre curvas prevista e medida.",
                              "finalVerifications": [
                                "O algoritmo convergeu com ||Δx|| < 1e-6 em menos de 100 iterações.",
                                "Resíduos finais têm norma < 1e-4 vezes norma inicial.",
                                "Parâmetros ajustados reproduzem dados com R² > 0.98.",
                                "Gráficos mostram boa sobreposição curva ajustada vs observada.",
                                "Testes com x0 diferentes convergem ao mesmo mínimo.",
                                "Tempo de execução < 1 segundo para 1000 pontos de dados."
                              ],
                              "assessmentCriteria": [
                                "Correção teórica: equações implementadas fielmente ao LM padrão.",
                                "Eficiência: número de iterações e tempo competitivos com bibliotecas.",
                                "Robustez: converge em 90% dos casos mal-condicionados testados.",
                                "Clareza do código: modular, comentado, com funções reutilizáveis.",
                                "Análise de resultados: métricas quantitativas e plots informativos.",
                                "Tratamento de erros: exceções para singularidade ou não-convergência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (inversas, decomposições) e cálculo multivariável.",
                                "Programação: Otimização numérica com Python/NumPy e controle de loops.",
                                "Estatística: Análise de mínimos quadrados e diagnósticos de ajuste.",
                                "Engenharia Mecânica: Modelagem constitutiva de materiais não-lineares.",
                                "Ciência de Dados: Machine Learning para regressão não-linear."
                              ],
                              "realWorldApplication": "Em engenharia civil, o LM é usado para calibrar modelos constitutivos em simulações FEM de estruturas (ex: ajuste de curvas tensão-deformação para concreto armado), previsão de assentamentos em fundações ou calibração de sensores em monitoramento estrutural, melhorando precisão em projetos de pontes e edifícios."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Escolher parâmetros iniciais e critérios de parada",
                            "description": "Determinar valores iniciais para parâmetros e definir tolerâncias para convergência baseada em gradiente ou mudança nos parâmetros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o problema de otimização não-linear",
                                  "subSteps": [
                                    "Identificar a função objetivo f(x) e as variáveis de otimização relevantes para o ajuste de curvas.",
                                    "Determinar o domínio físico e restrições baseadas no contexto de engenharia civil (ex: valores positivos para parâmetros de rigidez).",
                                    "Realizar análise preliminar: plotar a função, calcular derivadas ou gradientes em pontos conhecidos.",
                                    "Estudar o comportamento esperado da função (convexidade, mínimos locais) usando gráficos ou ferramentas numéricas.",
                                    "Documentar insights iniciais sobre sensibilidade aos parâmetros iniciais."
                                  ],
                                  "verification": "Relatório com função objetivo, domínio e gráficos preliminares documentados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de plotagem (Python com Matplotlib, MATLAB ou Excel), dados do problema, papel e caneta.",
                                  "tips": "Visualize sempre o 'landscape' da função para prever armadilhas como mínimos locais.",
                                  "learningObjective": "Compreender a estrutura matemática e física do problema de otimização.",
                                  "commonMistakes": "Ignorar restrições reais do domínio, levando a valores iniciais inviáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar valores iniciais para os parâmetros (x₀)",
                                  "subSteps": [
                                    "Basear x₀ em aproximações analíticas ou soluções lineares simplificadas.",
                                    "Usar conhecimento de domínio: valores típicos de engenharia civil (ex: módulo de elasticidade médio para solos).",
                                    "Experimentar múltiplos x₀ próximos ao esperado, calculando gradiente inicial em cada.",
                                    "Escolher x₀ com gradiente não nulo e apontando para o mínimo esperado.",
                                    "Registrar justificativa para o x₀ escolhido, incluindo análise de sensibilidade preliminar."
                                  ],
                                  "verification": "Lista de candidatos a x₀ testados, com gradientes calculados e escolha final justificada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora científica, software numérico (Python/NumPy, MATLAB), tabelas de valores típicos em engenharia civil.",
                                  "tips": "Prefira x₀ dentro do domínio convexo hull dos dados observados para ajuste de curvas.",
                                  "learningObjective": "Selecionar x₀ que acelere convergência e evite divergência.",
                                  "commonMistakes": "Escolher x₀ aleatório sem base domínio, resultando em convergência lenta ou falha."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir critérios de parada e tolerâncias",
                                  "subSteps": [
                                    "Estabelecer tolerância no gradiente: ||∇f(x)|| < ε (ex: ε = 10^{-6}).",
                                    "Definir tolerância na mudança de parâmetros: ||x_{k+1} - x_k|| < δ (ex: δ = 10^{-8}).",
                                    "Incluir número máximo de iterações (ex: 1000) para evitar loops infinitos.",
                                    "Adicionar tolerância na função objetivo: |f(x_{k+1}) - f(x_k)| < γ.",
                                    "Justificar valores de ε, δ, γ baseados na precisão necessária para aplicações civis (ex: precisão de 0.1% em deformações)."
                                  ],
                                  "verification": "Tabela com critérios definidos, valores numéricos e justificativas documentadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Literatura técnica (livros de otimização numérica), exemplos de problemas similares em engenharia.",
                                  "tips": "Escolha tolerâncias conservadoras inicialmente e ajuste com testes; equilibre precisão vs. tempo computacional.",
                                  "learningObjective": "Garantir convergência robusta e eficiente do algoritmo iterativo.",
                                  "commonMistakes": "Tolerâncias muito rigorosas causando iterações excessivas ou muito frouxas ignorando não-convergência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar os parâmetros e critérios escolhidos",
                                  "subSteps": [
                                    "Implementar 5-10 iterações iniciais do método (ex: gradiente descendente) com x₀ e critérios.",
                                    "Verificar se os critérios são atingidos rapidamente e a solução é estável.",
                                    "Testar sensibilidade: variar x₀ em ±10% e observar impacto na convergência.",
                                    "Ajustar critérios se necessário (ex: aumentar max_iter se oscilações ocorrerem).",
                                    "Documentar resultados: número de iterações, valor final de f(x) e resíduos."
                                  ],
                                  "verification": "Relatório de simulação com logs de iterações, gráficos de convergência e ajustes feitos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código de implementação (Python/Scipy.optimize, MATLAB fminunc), computador.",
                                  "tips": "Monitore o histórico de ||∇f|| e ||Δx|| em gráfico para diagnóstico visual.",
                                  "learningObjective": "Avaliar e refinar escolhas para robustez em problemas reais.",
                                  "commonMistakes": "Não testar múltiplos cenários, levando a falhas em problemas não ideais."
                                }
                              ],
                              "practicalExample": "Em ajuste de curva hiperbólica para dados de assentamento de fundações sob carga (dados: carga vs. deformação), escolha x₀ = [0.5, 1.2] baseado em médias dos dados (parâmetros a e b da curva y = a/(1 + b*x)), ε = 1e-6 para gradiente, δ = 1e-8 para parâmetros, max_iter = 1000. Execute gradiente descendente: converge em 150 iterações para parâmetros finais [0.48, 1.15], com RMSE < 0.01 mm.",
                              "finalVerifications": [
                                "Convergência atingida dentro do número máximo de iterações.",
                                "Solução sensível a variações pequenas em x₀ (<5% de mudança).",
                                "Resíduos do ajuste de curva abaixo de tolerância especificada.",
                                "Gradiente final próximo de zero (||∇f|| < ε).",
                                "Parâmetros finais fisicamente realistas (ex: positivos e dentro de faixas conhecidas).",
                                "Tempo total de computação razoável (<1 minuto para problemas médios)."
                              ],
                              "assessmentCriteria": [
                                "Justificativa clara e baseada em domínio para escolha de x₀.",
                                "Critérios de parada realistas e bem equilibrados (precisão vs. eficiência).",
                                "Análise de sensibilidade documentada com testes múltiplos.",
                                "Verificação numérica com pelo menos 3 execuções simuladas.",
                                "Documentação completa com gráficos de convergência.",
                                "Ausência de erros comuns como tolerâncias inadequadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e análise de gradientes.",
                                "Programação: Implementação de algoritmos numéricos em Python ou MATLAB.",
                                "Estatística: Avaliação de ajuste via resíduos e testes de significância.",
                                "Física/Mecânica: Modelos constitutivos não-lineares em solos e estruturas."
                              ],
                              "realWorldApplication": "Na otimização de parâmetros de modelos constitutivos para simulações de estruturas civis (ex: análise não-linear de vigas em software como ANSYS ou SAP2000), garantindo convergência rápida em projetos de fundações ou pontes, reduzindo tempo de simulação e evitando falhas por não-convergência."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Análise de Convergência e Validação do Ajuste",
                        "description": "Técnicas para avaliar a qualidade do ajuste, incluindo análise de erros, resíduos e testes estatísticos, com foco em aplicações computacionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Analisar resíduos e testes de adequação",
                            "description": "Verificar normalidade, homocedasticidade e independência dos resíduos usando gráficos e testes estatísticos para validar o modelo ajustado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular e visualizar resíduos do modelo ajustado",
                                  "subSteps": [
                                    "Extraia os valores ajustados (fitted values) do modelo não-linear ajustado usando a função apropriada no software (ex: residuals() em R ou .resid em Python statsmodels).",
                                    "Calcule os resíduos como diferença entre valores observados e ajustados: e_i = y_i - ŷ_i.",
                                    "Gere gráficos iniciais: resíduos vs valores ajustados e resíduos vs índice de observação.",
                                    "Salve os resíduos em um data frame ou array para análises subsequentes.",
                                    "Documente os valores médios e variância inicial dos resíduos."
                                  ],
                                  "verification": "Confirme que os resíduos somam aproximadamente zero e que os gráficos foram gerados sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de análise (Python com statsmodels/scipy ou R), dados do modelo ajustado (ex: CSV com y observados e parâmetros ajustados).",
                                  "tips": "Padronize os resíduos (divida pela desvio padrão) para facilitar comparações.",
                                  "learningObjective": "Compreender o conceito de resíduos e gerar visualizações básicas para inspeção inicial.",
                                  "commonMistakes": "Confundir resíduos com erros de previsão; não verificar se o modelo foi ajustado corretamente antes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Testar normalidade dos resíduos",
                                  "subSteps": [
                                    "Crie um gráfico QQ-plot (Quantile-Quantile) dos resíduos contra a distribuição normal.",
                                    "Aplique o teste de Shapiro-Wilk para normalidade (shapiro() em Python ou shapiro.test() em R).",
                                    "Interprete o p-valor: se > 0.05, assumir normalidade.",
                                    "Complemente com histograma dos resíduos sobreposto à curva normal teórica.",
                                    "Registre estatísticas descritivas como skewness e kurtosis."
                                  ],
                                  "verification": "QQ-plot mostra pontos alinhados na linha reta e p-valor do teste > 0.05.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Bibliotecas: scipy.stats (Python) ou nortest (R), ambiente Jupyter ou RStudio.",
                                  "tips": "Use qqnorm() em R para QQ-plot rápido; ignore outliers extremos inicialmente.",
                                  "learningObjective": "Avaliar suposição de normalidade usando métodos gráficos e formais.",
                                  "commonMistakes": "Interpretar erroneamente p-valores baixos como rejeição absoluta sem contexto amostral."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar homocedasticidade dos resíduos",
                                  "subSteps": [
                                    "Plote resíduos vs valores ajustados; procure por padrão de funil (heterocedasticidade).",
                                    "Aplique teste de Breusch-Pagan (breusch_pagan() em statsmodels Python ou bptest() em lmtest R).",
                                    "Se necessário, teste White para heterocedasticidade geral.",
                                    "Calcule e plote resíduos padronizados se variância não constante.",
                                    "Documente o p-valor e conclusão sobre variância constante."
                                  ],
                                  "verification": "Gráfico sem padrões claros e p-valor > 0.05 no teste.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Bibliotecas: statsmodels (Python) ou lmtest (R), gráficos com matplotlib/ggplot2.",
                                  "tips": "Transformações como log(y) podem corrigir heterocedasticidade; teste após.",
                                  "learningObjective": "Identificar e testar variância constante dos resíduos.",
                                  "commonMistakes": "Ignorar heterocedasticidade em dados de engenharia com escalas variáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar independência dos resíduos",
                                  "subSteps": [
                                    "Plote resíduos vs ordem temporal ou índice de observação.",
                                    "Calcule o teste de Durbin-Watson (durbin_watson() em statsmodels ou dwtest() em R).",
                                    "Valores DW próximos a 2 indicam independência (1.5-2.5 aceitável).",
                                    "Se dados sequenciais, verifique autocorrelação com ACF plot.",
                                    "Conclua se resíduos são independentes."
                                  ],
                                  "verification": "Gráfico sem padrões seriais e DW entre 1.5-2.5.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Bibliotecas: statsmodels ou lmtest/forecast (R).",
                                  "tips": "Para dados não temporais, foque em independência observacional.",
                                  "learningObjective": "Detectar dependência serial nos resíduos.",
                                  "commonMistakes": "Aplicar testes de autocorrelação em dados independentes, gerando falsos positivos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar resultados e validar o modelo",
                                  "subSteps": [
                                    "Compile relatório com todos gráficos, p-valores e conclusões.",
                                    "Se suposições violadas, sugira correções (ex: modelo robusto, transformações).",
                                    "Compare R² ajustado e resíduos para validade geral.",
                                    "Decida se o modelo é adequado para predições.",
                                    "Salve relatório em PDF ou notebook."
                                  ],
                                  "verification": "Relatório completo com recomendações claras sobre validade do modelo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Ferramentas de relatório: Jupyter notebook ou R Markdown.",
                                  "tips": "Use um checklist para todas suposições OLS.",
                                  "learningObjective": "Integrar análises para decisão final sobre qualidade do ajuste.",
                                  "commonMistakes": "Aceitar modelo sem todas suposições validadas."
                                }
                              ],
                              "practicalExample": "Em um experimento de engenharia civil, ajuste uma curva exponencial aos dados de deformação (mm) vs carga (kN) em um tirante de concreto. Calcule resíduos, verifique normalidade via QQ-plot (p=0.12>0.05), homocedasticidade (BP p=0.08), e independência (DW=1.92), validando o modelo para predizer falhas estruturais.",
                              "finalVerifications": [
                                "Todos gráficos de resíduos gerados e interpretados corretamente.",
                                "Testes estatísticos executados com p-valores reportados.",
                                "Suposições de normalidade, homocedasticidade e independência confirmadas ou corrigidas.",
                                "Relatório sintetiza validade do modelo.",
                                "Nenhum erro de código ou dados ausentes.",
                                "Recomendações para uso prático incluídas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração e interpretação de gráficos de resíduos (30%).",
                                "Correta aplicação e interpretação de testes estatísticos (30%).",
                                "Identificação precisa de violações de suposições (20%).",
                                "Qualidade do relatório e síntese (10%).",
                                "Eficiência temporal e uso de materiais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Testes de hipóteses e distribuições.",
                                "Programação Computacional: Manipulação de dados em Python/R.",
                                "Engenharia Mecânica: Modelagem de materiais e deformações.",
                                "Análise de Dados: Visualização e machine learning básico."
                              ],
                              "realWorldApplication": "Na engenharia civil, validar modelos de ajuste de curvas para prever deformações em estruturas sob carga, garantindo segurança em pontes, edifícios e barragens, evitando colapsos por modelos inadequados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Implementar em software numérico",
                            "description": "Codificar o ajuste não-linear em MATLAB ou Python, utilizando funções como lsqnonlin ou scipy.optimize, e interpretar resultados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de software e os dados do problema",
                                  "subSteps": [
                                    "Instalar e importar bibliotecas necessárias: numpy e scipy.optimize para Python, ou verificar disponibilidade de lsqnonlin no MATLAB.",
                                    "Carregar o conjunto de dados experimentais (ex: vetores de tensão e deformação de um ensaio uniaxial).",
                                    "Definir a função modelo não-linear (ex: modelo Ramberg-Osgood: ε = σ/E + (σ/K)^(1/n)).",
                                    "Criar a função objetivo de mínimos quadrados (resíduos entre dados observados e preditos).",
                                    "Estabelecer valores iniciais para os parâmetros (E, K, n) baseados em literatura ou inspeção visual."
                                  ],
                                  "verification": "Plotar os dados originais e a curva modelo com parâmetros iniciais para visual inspeção; ausência de erros de importação ou sintaxe.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (Anaconda/Jupyter) com numpy e scipy instalados; ou MATLAB; arquivo CSV com dados de exemplo (tensão vs. deformação).",
                                  "tips": "Normalizar os dados se houver grande variação de escala para melhorar convergência.",
                                  "learningObjective": "Configurar corretamente o problema de ajuste não-linear, incluindo modelo e função objetivo.",
                                  "commonMistakes": "Valores iniciais irreais levando a divergência; não importar bibliotecas corretamente; escala inadequada dos dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o algoritmo de otimização numérica",
                                  "subSteps": [
                                    "Definir as opções do otimizador (tolerância, máximo de iterações, algoritmo: 'trust-region-reflective' no scipy).",
                                    "Codificar a chamada ao otimizador: usar curve_fit ou least_squares do scipy.optimize em Python; ou lsqnonlin no MATLAB.",
                                    "Passar a função residual, parâmetros iniciais e bounds opcionais (ex: n > 0).",
                                    "Capturar saídas: parâmetros otimizados, covariância e mensagem de status.",
                                    "Implementar tratamento de erros para falhas de convergência."
                                  ],
                                  "verification": "Executar o código e verificar se retorna parâmetros sem warnings de falha; plotar curva ajustada sobre dados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ambiente Python/MATLAB configurado; script Jupyter ou .m com funções definidas no passo anterior.",
                                  "tips": "Use bounds para restringir parâmetros fisicamente realistas (ex: módulo E entre 100-300 GPa para aço).",
                                  "learningObjective": "Codificar e configurar solvers de otimização não-linear para ajuste de curvas.",
                                  "commonMistakes": "Função residual com sinal errado (minimizar soma de quadrados); ignorar bounds levando a parâmetros não-físicos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a otimização e analisar a convergência",
                                  "subSteps": [
                                    "Rodar o otimizador e registrar histórico de iterações se disponível (ex: callback no scipy).",
                                    "Verificar critérios de convergência: norma dos resíduos < tolerância, mudança nos parâmetros pequena.",
                                    "Calcular métricas: RMSE, R², resíduos padronizados.",
                                    "Plotar resíduos vs. preditos para detectar padrões (heterocedasticidade).",
                                    "Comparar com múltiplas inicializações para checar mínimos locais."
                                  ],
                                  "verification": "R² > 0.95 e resíduos aleatórios sem padrões; status de sucesso no otimizador.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Script com otimizador implementado; bibliotecas matplotlib/seaborn para plots.",
                                  "tips": "Teste com 3-5 conjuntos de parâmetros iniciais diferentes para robustez.",
                                  "learningObjective": "Monitorar e diagnosticar o processo de convergência em otimizações não-lineares.",
                                  "commonMistakes": "Aceitar convergência prematura sem checar resíduos; não testar múltiplas inicializações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e validar o ajuste",
                                  "subSteps": [
                                    "Interpretar parâmetros otimizados no contexto físico (ex: n indica não-linearidade).",
                                    "Calcular intervalos de confiança via covariância ou bootstrap.",
                                    "Validar com dados de teste independentes ou cross-validation.",
                                    "Documentar limitações (ex: extrapolação fora do range de dados).",
                                    "Gerar relatório com plots, tabela de parâmetros e métricas."
                                  ],
                                  "verification": "Relatório gerado com interpretação coerente e validação quantitativa (ex: erro < 5% em teste).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Resultados da otimização; dados de validação; template de relatório Markdown/PDF.",
                                  "tips": "Use seaborn para plots profissionais de resíduos e curvas ajustadas.",
                                  "learningObjective": "Extrair insights físicos dos resultados e validar robustez do modelo.",
                                  "commonMistakes": "Sobreajuste (overfitting) sem validação; interpretação sem contexto físico."
                                }
                              ],
                              "practicalExample": "Ajuste de uma curva tensão-deformação de aço estrutural usando o modelo Ramberg-Osgood. Dados de ensaio uniaxial (σ de 0-500 MPa, ε de 0-0.02) são ajustados para obter E=200 GPa, K=800 MPa, n=15, resultando em R²=0.98 e previsão precisa do escoamento.",
                              "finalVerifications": [
                                "Código executa sem erros e converge consistentemente.",
                                "R² ≥ 0.95 e RMSE < 5% do range de dados.",
                                "Resíduos aleatórios e sem autocorrelação.",
                                "Parâmetros dentro de bounds físicos realistas.",
                                "Validação com subconjunto de dados confirma generalização.",
                                "Relatório inclui plots e interpretação."
                              ],
                              "assessmentCriteria": [
                                "Precisão quantitativa do ajuste (R², RMSE).",
                                "Qualidade da interpretação física dos parâmetros.",
                                "Robustez a diferentes inicializações.",
                                "Detecção e correção de problemas de convergência.",
                                "Clareza e completude do relatório com visualizações.",
                                "Eficiência do código (tempo de execução < 10s)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Métodos numéricos de otimização não-linear e análise de resíduos.",
                                "Programação: Desenvolvimento de scripts numéricos em Python/MATLAB.",
                                "Estatística: Métricas de ajuste (R², intervalos de confiança) e validação de modelos.",
                                "Física/Mecânica: Modelos constitutivos de materiais em engenharia."
                              ],
                              "realWorldApplication": "Na engenharia civil, essa habilidade é usada para calibrar modelos constitutivos de materiais (aço, concreto, solos) em simulações de elementos finitos para análise de estruturas sob carregamento não-linear, prevendo falhas em pontes, edifícios e barragens."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Aplicar em problemas de engenharia civil",
                            "description": "Resolver problemas reais, como ajuste de curvas de deformação em materiais ou previsão de cargas, usando métodos de Monte Carlo para incertezas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Problema e Identificar Incertezas",
                                  "subSteps": [
                                    "Analise o problema de engenharia civil, como deformação em materiais ou previsão de cargas em estruturas.",
                                    "Identifique variáveis incertas (ex: propriedades do material, cargas ambientais) e distribuições probabilísticas associadas (normal, log-normal).",
                                    "Formule o modelo matemático não-linear, incluindo equações de ajuste de curvas (ex: modelo de Ramberg-Osgood para deformação).",
                                    "Defina parâmetros iniciais e intervalos de variação baseados em dados reais ou normas técnicas.",
                                    "Crie um diagrama de fluxo do problema destacando pontos de incerteza."
                                  ],
                                  "verification": "Verifique se o modelo matemático está documentado com equações claras e distribuições de incerteza listadas em um relatório inicial.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Normas ABNT NBR ou Eurocode para materiais; software como MATLAB ou Python (NumPy, SciPy); dados experimentais de deformação.",
                                  "tips": "Comece com incertezas simples (uma variável) antes de expandir para múltiplas.",
                                  "learningObjective": "Compreender como mapear incertezas reais em modelos probabilísticos para problemas de engenharia civil.",
                                  "commonMistakes": "Ignorar correlações entre variáveis incertas ou usar distribuições inadequadas sem justificativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e Implementar Simulação Monte Carlo",
                                  "subSteps": [
                                    "Gere amostras aleatórias das distribuições de incerteza usando funções randômicas (ex: np.random.normal).",
                                    "Implemente o solver não-linear para cada amostra (ex: least_squares do SciPy para ajuste de curvas).",
                                    "Defina o número de iterações (mínimo 10.000 para convergência) e execute a simulação em loop.",
                                    "Monitore convergência com testes estatísticos (ex: coeficiente de variação < 5%).",
                                    "Salve resultados em arrays para análise posterior (parâmetros ajustados, resíduos)."
                                  ],
                                  "verification": "Confirme que a simulação roda sem erros e gera histogramas de parâmetros com estatísticas descritivas (média, desvio padrão).",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Python com bibliotecas SciPy, NumPy, Matplotlib; Jupyter Notebook; computador com pelo menos 8GB RAM.",
                                  "tips": "Use paralelização (ex: joblib) para acelerar simulações com muitas iterações.",
                                  "learningObjective": "Dominar a implementação prática do método Monte Carlo para propagação de incertezas em ajustes não-lineares.",
                                  "commonMistakes": "Número insuficiente de simulações levando a resultados não convergentes; não seedar o gerador aleatório para reprodutibilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Resultados e Avaliar Convergência",
                                  "subSteps": [
                                    "Calcule estatísticas dos parâmetros ajustados (média, intervalos de confiança 95%).",
                                    "Gere curvas médias e bandas de incerteza plotando percentis (5%, 50%, 95%).",
                                    "Avalie qualidade do ajuste com métricas (R², RMSE médio sobre simulações).",
                                    "Teste sensibilidade variando uma incerteza por vez.",
                                    "Compare com dados experimentais ou validação analítica."
                                  ],
                                  "verification": "Produza gráficos de curvas com bandas de incerteza e relatório com métricas numéricas aceitáveis (R² > 0.9).",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Matplotlib/Seaborn para plots; Pandas para manipulação de dados; referências de validação experimental.",
                                  "tips": "Visualize distribuições de resíduos para detectar vieses.",
                                  "learningObjective": "Interpretar saídas probabilísticas de Monte Carlo e quantificar incertezas em ajustes de curvas.",
                                  "commonMistakes": "Interpretar apenas a média sem considerar intervalos de confiança; plots sem legendas claras."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Aplicar ao Problema Real",
                                  "subSteps": [
                                    "Valide o modelo ajustado simulando cenários de falha (ex: deformação excessiva sob carga máxima).",
                                    "Preveja cargas ou deformações com probabilidades de exceedance (ex: P(deformação > limite) < 5%).",
                                    "Documente recomendações de projeto (fatores de segurança baseados em incertezas).",
                                    "Teste com conjunto de validação independente.",
                                    "Prepare relatório final com código fonte e resultados reproduzíveis."
                                  ],
                                  "verification": "O modelo prevê comportamentos realistas validados contra normas ou dados reais, com relatório completo.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Dados de campo/projetos reais; software de simulação estrutural (ex: ANSYS para comparação).",
                                  "tips": "Integre resultados em dimensionamento de estruturas para contexto prático.",
                                  "learningObjective": "Aplicar resultados de Monte Carlo em decisões de engenharia civil seguras e quantificadas.",
                                  "commonMistakes": "Não considerar efeitos de segunda ordem como não-linearidades geométricas."
                                }
                              ],
                              "practicalExample": "Em um projeto de ponte, ajuste a curva de deformação de cabos de aço sob cargas variáveis. Use Monte Carlo para simular incertezas no módulo de elasticidade (variação 10%) e tensão de escoamento, gerando uma curva média com bandas de ±15% de deformação prevista, validando contra ensaios reais para garantir segurança.",
                              "finalVerifications": [
                                "Simulação converge com CV < 5% em 10.000 iterações.",
                                "Intervalos de confiança dos parâmetros não se sobrepõem a valores críticos de falha.",
                                "R² médio > 0.95 e RMSE < 5% dos dados observados.",
                                "Previsões de risco (ex: P(falha) < 1%) alinhadas com normas de engenharia.",
                                "Código é reproduzível com seed fixo e documentado.",
                                "Gráficos mostram curvas com bandas de incerteza claras."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo: Métricas de ajuste dentro de limites aceitáveis.",
                                "Tratamento de incertezas: Distribuições e amostragem corretas.",
                                "Análise estatística: Cálculo e interpretação adequados de estatísticas.",
                                "Validação: Comparação com dados reais ou analíticos.",
                                "Relatório: Clareza, completude e reprodutibilidade.",
                                "Eficiência computacional: Tempo razoável sem perda de precisão."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: Propagação de incertezas e análise de Monte Carlo.",
                                "Programação Computacional: Implementação em Python/MATLAB.",
                                "Mecânica dos Materiais: Modelos constitutivos não-lineares.",
                                "Gestão de Projetos: Aplicação em dimensionamento seguro de estruturas.",
                                "Ética Profissional: Consideração de riscos em projetos civis."
                              ],
                              "realWorldApplication": "Em obras civis como edifícios altos ou pontes, usa-se para prever deformações em fundações sob cargas sísmicas incertas, otimizando projetos com fatores de segurança probabilísticos, reduzindo custos sem comprometer a integridade estrutural."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Redes Neurais Artificiais",
                "description": "Introdução às redes neurais artificiais e suas aplicações em soluções computacionais.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Conceitos Básicos de Redes Neurais Artificiais",
                    "description": "Definição, inspiração biológica e componentes principais como camadas e conexões.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Definição de Redes Neurais Artificiais",
                        "description": "Compreensão fundamental do que são as Redes Neurais Artificiais (RNA), seu propósito em modelagem computacional e aplicações em problemas de engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Definir RNA",
                            "description": "Explicar que uma Rede Neural Artificial é um modelo computacional inspirado no cérebro humano, composto por unidades interconectadas que processam informações para aprender padrões a partir de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a inspiração biológica das Redes Neurais Artificiais",
                                  "subSteps": [
                                    "Pesquise o funcionamento básico do cérebro humano, focando em neurônios e sinapses.",
                                    "Identifique como os neurônios biológicos recebem, processam e transmitem sinais.",
                                    "Compare sinapses biológicas com conexões artificiais em modelos computacionais.",
                                    "Anote similaridades e simplificações feitas no modelo artificial.",
                                    "Desenhe um diagrama simples comparando um neurônio biológico com um artificial."
                                  ],
                                  "verification": "Crie um diagrama comparativo e explique oralmente ou por escrito as semelhanças principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vídeo introdutório sobre neurônios (ex: Khan Academy)",
                                    "Papel e caneta para diagrama",
                                    "Artigo curto sobre neurociência básica"
                                  ],
                                  "tips": "Use analogias cotidianas, como 'neurônios como interruptores elétricos', para fixar o conceito.",
                                  "learningObjective": "Entender a base biológica que inspira as RNAs, reconhecendo simplificações.",
                                  "commonMistakes": [
                                    "Confundir o modelo artificial com o cérebro real (RNAs são abstrações matemáticas)",
                                    "Ignorar que RNAs não replicam fielmente a biologia"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir formalmente o que é uma Rede Neural Artificial",
                                  "subSteps": [
                                    "Leia a definição padrão: 'Modelo computacional inspirado no cérebro, com unidades interconectadas que processam dados'.",
                                    "Identifique palavras-chave: modelo computacional, inspirado no cérebro, unidades interconectadas, processar informações, aprender padrões.",
                                    "Reescreva a definição em suas próprias palavras, mantendo precisão.",
                                    "Diferencie RNA de outros modelos de IA, como regras lógicas ou árvores de decisão.",
                                    "Registre exemplos de onde RNAs são usadas versus não."
                                  ],
                                  "verification": "Escreva uma definição de 1-2 parágrafos e compare com fontes confiáveis para precisão.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Definição oficial de fontes como Wikipedia ou livros de IA",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Mantenha a definição concisa: foque em inspiração, estrutura e propósito.",
                                  "learningObjective": "Formular uma definição clara e precisa de RNA.",
                                  "commonMistakes": [
                                    "Definir muito vagamente (ex: 'como o cérebro')",
                                    "Omitir o aspecto de aprendizado de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar os componentes principais de uma RNA",
                                  "subSteps": [
                                    "Estude os neurônios artificiais: entradas, soma ponderada, função de ativação.",
                                    "Descreva camadas: entrada, ocultas, saída e suas funções.",
                                    "Explique pesos e bias como parâmetros ajustáveis.",
                                    "Visualize fluxos de dados através da rede com um diagrama simples.",
                                    "Liste funções de ativação comuns (ex: sigmoide, ReLU)."
                                  ],
                                  "verification": "Monte um diagrama de uma RNA simples com 3 camadas e rotule componentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho online (ex: Draw.io)",
                                    "Tutorial visual de RNA (ex: YouTube 3Blue1Brown)"
                                  ],
                                  "tips": "Pense em pesos como 'forças' das conexões, ajustadas durante o aprendizado.",
                                  "learningObjective": "Identificar e descrever os blocos de construção de uma RNA.",
                                  "commonMistakes": [
                                    "Confundir camadas ocultas com camadas de saída",
                                    "Esquecer funções de ativação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender o propósito: aprendizado de padrões a partir de dados",
                                  "subSteps": [
                                    "Explique o treinamento: ajuste de pesos via backpropagation para minimizar erros.",
                                    "Diferencie aprendizado supervisionado, não supervisionado e reforço em RNAs.",
                                    "Discuta entrada de dados como vetores e saída como predições.",
                                    "Exemplo: como uma RNA 'aprende' a classificar imagens de rachaduras em concreto.",
                                    "Reflita sobre limitações: necessidade de dados grandes e risco de overfitting."
                                  ],
                                  "verification": "Descreva o ciclo de aprendizado de uma RNA em um fluxograma simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vídeo sobre backpropagation",
                                    "Exemplo de dataset simples (ex: Iris para classificação)"
                                  ],
                                  "tips": "Veja o aprendizado como 'treinar um cachorro com recompensas e correções'.",
                                  "learningObjective": "Compreender como RNAs aprendem padrões de dados.",
                                  "commonMistakes": [
                                    "Pensar que RNAs 'pensam' como humanos",
                                    "Ignorar dependência de dados de qualidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em engenharia civil, defina uma RNA para prever falhas em pontes: ela recebe dados de sensores (vibrações, umidade), processa através de camadas interconectadas inspiradas no cérebro, e aprende padrões para alertar sobre riscos, ajustando pesos com dados históricos de inspeções.",
                              "finalVerifications": [
                                "Explicar a definição completa de RNA em 1 minuto sem consultar notas.",
                                "Desenhar e rotular um diagrama básico de RNA.",
                                "Diferenciar RNA de outros modelos de IA.",
                                "Dar um exemplo de aplicação em engenharia civil.",
                                "Identificar 3 componentes chave e seu papel.",
                                "Descrever o processo de aprendizado de padrões."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da definição (80% das palavras-chave incluídas).",
                                "Clareza na explicação da inspiração biológica e simplificações.",
                                "Correta identificação de componentes (neurônios, camadas, pesos).",
                                "Compreensão do aprendizado supervisionado vs. outros.",
                                "Relevância de exemplos ao contexto de engenharia civil.",
                                "Ausência de equívocos comuns sobre 'pensamento humano'."
                              ],
                              "crossCurricularConnections": [
                                "Biologia/Neurociência: Analogia com neurônios e sinapses.",
                                "Matemática: Álgebra linear para pesos e vetores.",
                                "Programação: Implementação em Python (TensorFlow/Keras).",
                                "Engenharia Civil: Previsão de estruturas e análise de dados sensoriais.",
                                "Estatística: Tratamento de dados e validação de modelos."
                              ],
                              "realWorldApplication": "Na engenharia civil, RNAs definidas como modelos inspirados no cérebro são usadas para analisar dados de sensores em barragens, prevendo colapsos por erosão ao aprender padrões de vibração e umidade, otimizando manutenções preventivas e salvando vidas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Diferenciar RNA de métodos tradicionais",
                            "description": "Comparar RNA com métodos numéricos clássicos como ajuste de curvas ou Monte Carlo, destacando a capacidade de RNA em lidar com não-linearidades complexas sem programação explícita de regras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar métodos numéricos tradicionais",
                                  "subSteps": [
                                    "Defina ajuste de curvas e dê um exemplo simples em engenharia civil, como modelar tensão em uma viga linear.",
                                    "Explique o método Monte Carlo, incluindo geração de amostras aleatórias para simulações probabilísticas.",
                                    "Identifique limitações principais: dependência de suposições lineares e necessidade de regras matemáticas explícitas.",
                                    "Liste cenários onde esses métodos são eficazes, como problemas bem definidos e lineares.",
                                    "Compare com problemas reais que envolvem não-linearidades, destacando ineficiências."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças entre ajuste de curvas e Monte Carlo com um exemplo de engenharia civil.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de métodos numéricos (ex: Burden & Faires)",
                                    "Vídeo tutorial sobre Monte Carlo no YouTube",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": [
                                    "Use diagramas para visualizar simulações Monte Carlo.",
                                    "Relacione sempre com contextos de engenharia civil."
                                  ],
                                  "learningObjective": "Compreender os princípios e limitações dos métodos numéricos clássicos.",
                                  "commonMistakes": [
                                    "Confundir métodos probabilísticos com determinísticos.",
                                    "Ignorar a necessidade de programação explícita de equações."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir conceitos fundamentais de Redes Neurais Artificiais (RNA)",
                                  "subSteps": [
                                    "Descreva a estrutura básica de uma RNA: neurônios, camadas (entrada, ocultas, saída) e funções de ativação.",
                                    "Explique o processo de treinamento: forward pass, backward propagation e ajuste de pesos via gradiente descendente.",
                                    "Destaque a natureza 'black-box': aprendizado implícito de padrões sem regras pré-definidas.",
                                    "Compare com biologia: inspiração no cérebro humano para processamento paralelo.",
                                    "Identifique vantagens iniciais: capacidade de aproximar funções não-lineares arbitrárias (Teorema de Universal Approximation)."
                                  ],
                                  "verification": "Desenhe um diagrama simples de uma RNA com 1 camada oculta e rotule os componentes principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo introdutório sobre RNA (ex: Wikipedia ou Goodfellow et al.)",
                                    "Ferramenta de desenho online (ex: Draw.io)",
                                    "Vídeo Khan Academy sobre redes neurais"
                                  ],
                                  "tips": [
                                    "Comece com uma RNA simples de 1 neurônio para entender o forward pass.",
                                    "Evite mergulhar em matemática avançada neste passo."
                                  ],
                                  "learningObjective": "Dominar os componentes básicos e o mecanismo de aprendizado das RNAs.",
                                  "commonMistakes": [
                                    "Pensar que RNA requer programação de regras como em métodos tradicionais.",
                                    "Confundir treinamento com otimização explícita."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar abordagens de modelagem: Explícita vs. Implícita",
                                  "subSteps": [
                                    "Compare modelagem explícita em tradicionais (equações fixas) vs. implícita em RNA (aprendizado de dados).",
                                    "Analise dependência de dados: tradicionais precisam de modelo teórico; RNA de dados históricos.",
                                    "Discuta escalabilidade: Monte Carlo explode em complexidade para altos dimensões; RNA escala com dados e poder computacional.",
                                    "Examine interpretabilidade: tradicionais são transparentes; RNA são opacas mas preditivas.",
                                    "Crie uma tabela comparativa com colunas: Abordagem, Requisitos, Vantagens, Desvantagens."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 4 critérios e valide com uma fonte confiável.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para tabela",
                                    "Artigos comparativos (ex: 'Neural Networks vs Traditional Methods')",
                                    "Calculadora para simulações simples"
                                  ],
                                  "tips": [
                                    "Use exemplos numéricos pequenos para ilustrar diferenças computacionais.",
                                    "Foque em critérios relevantes para engenharia civil."
                                  ],
                                  "learningObjective": "Identificar diferenças fundamentais nas abordagens de modelagem.",
                                  "commonMistakes": [
                                    "Superestimar interpretabilidade das RNAs.",
                                    "Ignorar custos computacionais das RNAs em comparação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar vantagens das RNAs em não-linearidades complexas",
                                  "subSteps": [
                                    "Defina não-linearidades complexas: interações multifatoriais sem forma analítica conhecida (ex: solos heterogêneos).",
                                    "Explique como tradicionais falham: suposições lineares levam a erros altos ou inviabilidade.",
                                    "Descreva como RNA lida: funções de ativação não-lineares (ReLU, sigmoid) capturam padrões complexos automaticamente.",
                                    "Simule um caso: previsão de assentamento de fundações com dados não-lineares.",
                                    "Sintetize diferenças chave em uma lista: flexibilidade, generalização, ausência de regras explícitas."
                                  ],
                                  "verification": "Resuma em 3-5 pontos as vantagens das RNAs para não-linearidades e teste com um exemplo hipotético.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software simples como Python com NumPy para mini-simulação",
                                    "Dados de exemplo de engenharia civil (ex: datasets Kaggle)",
                                    "Papel para fluxogramas"
                                  ],
                                  "tips": [
                                    "Visualize com gráficos: curvas lineares vs. aproximadas por RNA.",
                                    "Relacione sempre com problemas reais da engenharia."
                                  ],
                                  "learningObjective": "Compreender por que RNAs superam tradicionais em cenários complexos.",
                                  "commonMistakes": [
                                    "Achar que RNAs funcionam sem dados de qualidade.",
                                    "Subestimar necessidade de validação em RNAs."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma análise de deformação de uma ponte sob carga variável, use ajuste de curvas para modelar linearmente (rápido mas impreciso para fadiga não-linear); com RNA treinada em dados sensoriais históricos, preveja deformações complexas sem equações explícitas, reduzindo erros em 40%.",
                              "finalVerifications": [
                                "Liste e explique 4 diferenças principais entre RNA e métodos tradicionais.",
                                "Forneça um exemplo onde RNA é superior em não-linearidades.",
                                "Crie uma tabela comparativa precisa com pelo menos 5 critérios.",
                                "Explique o teorema de aproximação universal de RNAs.",
                                "Identifique 2 limitações de cada abordagem.",
                                "Simule verbalmente uma comparação em um problema de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de métodos tradicionais (sem confusões conceituais).",
                                "Clareza na explicação de mecanismos de RNA (estrutura e treinamento).",
                                "Profundidade na comparação, com exemplos quantitativos ou qualitativos.",
                                "Uso correto de terminologia técnica (ex: backward propagation, Monte Carlo).",
                                "Capacidade de destacar vantagens em contextos não-lineares complexos.",
                                "Síntese coerente das diferenças principais em tabela ou lista.",
                                "Aplicação relevante ao contexto de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-linear e aproximação de funções (cálculo variacional).",
                                "Estatística: Modelagem probabilística e validação de modelos preditivos.",
                                "Programação: Implementação de algoritmos de machine learning em Python/TensorFlow.",
                                "Física: Modelagem de fenômenos dinâmicos e não-lineares em estruturas.",
                                "Ciência da Computação: Algoritmos de aprendizado de máquina e big data."
                              ],
                              "realWorldApplication": "Na engenharia civil, RNAs diferenciam-se ao prever falhas em barragens por análise sísmica não-linear, onde Monte Carlo seria computacionalmente proibitivo; RNAs treinadas em dados de sensores IoT capturam interações complexas de solo-estrutura, otimizando designs e reduzindo custos de manutenção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Identificar aplicações em engenharia civil",
                            "description": "Reconhecer usos de RNA em previsão de cargas estruturais, análise de solos ou otimização de projetos civis, relacionando com soluções computacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto geral das RNA na Engenharia Civil",
                                  "subSteps": [
                                    "Pesquisar definições básicas de RNA e seus componentes principais (neurônios, camadas, funções de ativação).",
                                    "Identificar desafios comuns na engenharia civil que envolvem dados incertos ou complexos, como cargas variáveis e solos heterogêneos.",
                                    "Listar 3-5 problemas civis onde métodos tradicionais falham, preparando o terreno para soluções computacionais baseadas em RNA.",
                                    "Mapear como RNA processa dados não lineares, diferenciando de métodos analíticos clássicos.",
                                    "Revisar literatura introdutória sobre IA em engenharia (ex: artigos de revisão)."
                                  ],
                                  "verification": "Criar um mapa mental conectando RNA a 3 desafios civis específicos, com pelo menos 5 conexões explicadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Artigos acadêmicos (Google Scholar: 'Neural Networks in Civil Engineering'), software de mind mapping (MindMeister ou papel/caneta).",
                                  "tips": "Comece com vídeos curtos no YouTube (canais como 'Practical AI' ou 'Engineering with AI') para visualização rápida.",
                                  "learningObjective": "Entender como RNA se aplica a problemas civis incertos, diferenciando de abordagens determinísticas.",
                                  "commonMistakes": "Confundir RNA com regressão linear simples; foque na capacidade de aprendizado não supervisionado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar aplicações em previsão de cargas estruturais",
                                  "subSteps": [
                                    "Estudar casos onde RNA prevê cargas dinâmicas em pontes ou edifícios sob ventos/sismos.",
                                    "Analisar datasets de cargas (ex: sensores IoT em estruturas reais) e como RNA os modela.",
                                    "Simular um modelo simples de RNA para previsão de carga usando Python (biblioteca Keras).",
                                    "Comparar precisão de RNA vs. métodos finitos elementares (FEM).",
                                    "Documentar métricas como RMSE para avaliação de previsões."
                                  ],
                                  "verification": "Executar um script Jupyter simples prevendo carga em uma viga e gerar gráfico de comparação com dados reais.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python/Jupyter Notebook, bibliotecas TensorFlow/Keras, datasets públicos (UCI ML Repository: 'Bridge Loads').",
                                  "tips": "Use Google Colab para evitar setup local; normalize dados de entrada para melhorar convergência.",
                                  "learningObjective": "Reconhecer RNA como ferramenta para previsão precisa de cargas em cenários reais de engenharia.",
                                  "commonMistakes": "Ignorar pré-processamento de dados; sempre escale features para [0,1]."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar usos em análise de solos e otimização de projetos",
                                  "subSteps": [
                                    "Investigar RNA para classificação de solos (ex: coesão, ângulo de atrito via parâmetros SPT/CPT).",
                                    "Explorar otimização de projetos civis, como dimensionamento de fundações ou traçados de estradas via RNA + algoritmos genéticos.",
                                    "Revisar estudos de caso: previsão de assentamento em aterros ou otimização de concreto armado.",
                                    "Identificar inputs/outputs típicos (ex: propriedades geotécnicas → capacidade portante).",
                                    "Discutir limitações, como necessidade de dados de treinamento abundantes."
                                  ],
                                  "verification": "Elaborar tabela comparativa de 3 aplicações em solos/projetos, com inputs, outputs e benefícios.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Papers (ex: 'ANN for Soil Properties Prediction' no ASCE Library), Excel para tabelas.",
                                  "tips": "Busque repositórios GitHub com códigos prontos de RNA para solos para inspiração prática.",
                                  "learningObjective": "Identificar aplicações específicas de RNA em solos e otimização, destacando ganhos em eficiência.",
                                  "commonMistakes": "Superestimar generalização; valide com conjuntos de teste independentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar aplicações com soluções computacionais integradas",
                                  "subSteps": [
                                    "Integrar conhecimentos: como RNA se conecta a BIM, FEM e simulações CFD em workflows civis.",
                                    "Desenhar fluxograma de um sistema híbrido (ex: RNA + software ETABS para otimização estrutural).",
                                    "Avaliar viabilidade computacional (tempo de treino, hardware GPU).",
                                    "Sintetizar vantagens: rapidez em iterações vs. métodos manuais.",
                                    "Preparar apresentação resumindo 5 aplicações chave."
                                  ],
                                  "verification": "Produzir fluxograma e relatório de 1 página listando integrações computacionais.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de diagrama (Draw.io ou Lucidchart), software civil (trial de ETABS/SAP2000).",
                                  "tips": "Pense em APIs: integre RNA via Python com ferramentas como Revit API.",
                                  "learningObjective": "Relacionar RNA a ecossistemas computacionais civis para soluções holísticas.",
                                  "commonMistakes": "Isolar RNA; sempre contextualize em pipelines maiores."
                                }
                              ],
                              "practicalExample": "Em um projeto de ponte estaiada, use RNA treinada com dados de sensores para prever cargas de vento extremas, otimizando cabos e evitando sobrecargas – simulando com Keras em dados históricos de furacões.",
                              "finalVerifications": [
                                "Lista precisa de pelo menos 5 aplicações de RNA em engenharia civil com exemplos concretos.",
                                "Fluxograma mostrando integração de RNA em workflow computacional civil.",
                                "Comparação quantitativa (ex: acurácia >80%) de RNA vs. métodos tradicionais em um caso.",
                                "Identificação de 3 limitações e soluções computacionais para mitigá-las.",
                                "Apresentação oral ou relatório sintetizando conexões com soluções civis.",
                                "Teste prático: código rodando previsão simples de carga/solo."
                              ],
                              "assessmentCriteria": [
                                "Profundidade na identificação de aplicações específicas (previsão, análise, otimização): 25%.",
                                "Precisão na relação com soluções computacionais (integrações, fluxos): 25%.",
                                "Uso de exemplos reais e verificáveis: 20%.",
                                "Clareza e estrutura nos passos/explicações: 15%.",
                                "Criatividade em conexões interdisciplinares: 10%.",
                                "Ausência de erros conceituais comuns: 5%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não linear e estatística (regressão, validação cruzada).",
                                "Programação: Python/ML libraries (Keras, Scikit-learn) para implementação.",
                                "Física/Mecânica dos Solos: Modelagem de cargas e propriedades geotécnicas.",
                                "Gestão de Projetos: Integração em BIM e ciclos de design iterativo.",
                                "Ética em Engenharia: Viés em dados de treinamento para previsões críticas."
                              ],
                              "realWorldApplication": "Empresas como Arup ou AECOM usam RNA para otimizar projetos de arranha-céus, prevendo cargas sísmicas em solos complexos (ex: Torre Shanghai), reduzindo custos em 15-20% via simulações rápidas e iterações automatizadas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Inspiração Biológica das RNA",
                        "description": "Exploração das bases biológicas que inspiram as RNA, conectando conceitos neuronais reais aos artificiais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Descrever o neurônio biológico",
                            "description": "Explicar a estrutura de um neurônio biológico, incluindo dendritos (recepção de sinais), soma (processamento) e axônio (transmissão), como base para o modelo artificial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral do neurônio biológico",
                                  "subSteps": [
                                    "Pesquise imagens e diagramas de neurônios biológicos para visualizar a forma geral.",
                                    "Identifique as três partes principais: dendritos, soma e axônio.",
                                    "Anote as funções básicas de cada parte em um diagrama simples.",
                                    "Compare com células comuns para destacar especializações neuronais.",
                                    "Registre diferenças entre neurônios e outros tipos celulares."
                                  ],
                                  "verification": "Desenhe um esboço rotulado do neurônio identificando as três partes principais corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagramas de neurônios online (Khan Academy ou Wikipedia), papel e caneta para esboço.",
                                  "tips": "Use cores diferentes para cada parte para facilitar a memorização visual.",
                                  "learningObjective": "Identificar e descrever as componentes principais de um neurônio biológico.",
                                  "commonMistakes": "Confundir dendritos com axônios devido à similaridade ramificada; sempre lembre que dendritos recebem e axônios transmitem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os dendritos e sua função de recepção",
                                  "subSteps": [
                                    "Estude a estrutura ramificada dos dendritos e sua localização na célula.",
                                    "Aprenda como dendritos recebem sinais químicos/elétricos de outros neurônios via sinapses.",
                                    "Descreva o processo de recepção de impulsos sinápticos.",
                                    "Anote exemplos de neurotransmissores envolvidos.",
                                    "Crie um fluxograma mostrando entrada de sinais nos dendritos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como os dendritos recebem sinais, citando pelo menos dois exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Vídeos animados sobre sinapses (YouTube: Crash Course Biology), fluxograma em branco.",
                                  "tips": "Pense nos dendritos como 'antenas receptoras' para fixar a ideia de entrada de informação.",
                                  "learningObjective": "Descrever a estrutura e função dos dendritos na recepção de sinais.",
                                  "commonMistakes": "Ignorar o papel sináptico; lembre que dendritos não transmitem, apenas recebem."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a soma (corpo celular) e seu papel no processamento",
                                  "subSteps": [
                                    "Examine a soma como centro contendo núcleo e organelas.",
                                    "Aprenda como integra sinais recebidos dos dendritos.",
                                    "Estude o potencial de ação: soma decide se dispara impulso.",
                                    "Descreva o mecanismo de somação espacial e temporal.",
                                    "Registre organelas chave como mitocôndrias e ribossomos."
                                  ],
                                  "verification": "Liste 3 funções da soma e explique somação de sinais em um parágrafo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro ou PDF de neurobiologia básica, quadro branco para diagrama de somação.",
                                  "tips": "Visualize a soma como um 'computador central' somando inputs para decidir output.",
                                  "learningObjective": "Explicar o processamento de sinais na soma do neurônio.",
                                  "commonMistakes": "Subestimar a soma como passiva; ela é ativa no threshold de disparo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar o axônio e sua função de transmissão",
                                  "subSteps": [
                                    "Descreva a estrutura alongada e mielinizada do axônio.",
                                    "Aprenda propagação do potencial de ação ao longo do axônio.",
                                    "Estude terminais axônicos e liberação de neurotransmissores.",
                                    "Compare axônios mielinizados vs. não mielinizados em velocidade.",
                                    "Crie um diagrama do fluxo de sinal do soma para terminais."
                                  ],
                                  "verification": "Desenhe e rotule o caminho de transmissão no axônio, indicando nós de Ranvier.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Animações de potencial de ação (Neuronado app ou vídeos), papel para diagrama.",
                                  "tips": "Associe axônio a um 'cabo de alta tensão' para transmissão rápida.",
                                  "learningObjective": "Detalhar a estrutura e transmissão de sinais pelo axônio.",
                                  "commonMistakes": "Confundir direção: sinal sempre sai da soma via axônio, nunca reverso."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar conhecimentos e relacionar com neurônio artificial",
                                  "subSteps": [
                                    "Resuma fluxo completo: dendritos → soma → axônio.",
                                    "Compare com neurônio artificial: dendritos=inputs, soma=pesos/soma, axônio=output.",
                                    "Identifique analogias e limitações biológicas vs. artificiais.",
                                    "Crie tabela comparativa das partes.",
                                    "Explique por que essa inspiração é base para RNAs."
                                  ],
                                  "verification": "Produza uma descrição escrita completa do neurônio biológico e sua analogia com RNA.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Tabela em Excel/Google Sheets, resumo anterior dos steps.",
                                  "tips": "Use analogias simples como 'telefone celular' para fixar conexões.",
                                  "learningObjective": "Sintetizar descrição do neurônio biológico como base para modelos artificiais.",
                                  "commonMistakes": "Forçar similaridades excessivas; destaque que RNAs simplificam biologia."
                                }
                              ],
                              "practicalExample": "Desenhe um neurônio biológico em um papel, rotulando dendritos (entradas de setas), soma (círculo central com + e - para somação) e axônio (linha longa terminando em setas de saída). Explique oralmente como um sinal de dor viaja de dendritos na pele, processado na soma e transmitido pelo axônio ao cérebro.",
                              "finalVerifications": [
                                "Pode rotular corretamente dendritos, soma e axônio em um diagrama?",
                                "Explica o fluxo de sinal: recepção-processamento-transmissão?",
                                "Identifica funções específicas de cada parte?",
                                "Compara com neurônio artificial listando 3 analogias?",
                                "Descreve somação espacial/temporal sem erros?",
                                "Cita exemplos de neurotransmissores ou mielina?"
                              ],
                              "assessmentCriteria": [
                                "Precisão anatômica e funcional (sem confusões entre partes).",
                                "Clareza na descrição do fluxo de sinais.",
                                "Profundidade de detalhes em subestruturas (ex: nós de Ranvier).",
                                "Qualidade das analogias com neurônios artificiais.",
                                "Uso de terminologia correta (dendritos, soma, axônio).",
                                "Capacidade de visualização via desenhos ou diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Biologia: Anatomia celular e neurociência.",
                                "Computação: Modelos de redes neurais e IA.",
                                "Engenharia Civil: Aplicações de RNAs em previsão de falhas estruturais.",
                                "Física: Propagação de impulsos elétricos e potencial de ação.",
                                "Matemática: Somação ponderada de sinais."
                              ],
                              "realWorldApplication": "Entender o neurônio biológico inspira RNAs usadas em engenharia civil para modelar comportamentos complexos, como prever deformações em pontes sob cargas variáveis, simulando 'aprendizado' de padrões de estresse semelhantes à integração neuronal."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Explicar sinapses e pesos sinápticos",
                            "description": "Detalhar como sinapses biológicas modulam a força dos sinais, análogo aos pesos ajustáveis nas conexões das RNA durante o aprendizado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica de uma sinapse biológica",
                                  "subSteps": [
                                    "Estude a definição de sinapse como ponto de conexão entre neurônios.",
                                    "Identifique os componentes principais: neurônio pré-sináptico, fenda sináptica e neurônio pós-sináptico.",
                                    "Observe diagramas que mostram vesículas sinápticas liberando neurotransmissores.",
                                    "Diferencie sinapses químicas das elétricas, focando nas químicas como padrão.",
                                    "Anote como a sinapse permite comunicação unidirecional."
                                  ],
                                  "verification": "Desenhe um diagrama simples de uma sinapse e rotule os componentes principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de sinapse biológica (impresso ou digital)",
                                    "Vídeo introdutório sobre neurônios (ex: Khan Academy)"
                                  ],
                                  "tips": "Use analogias cotidianas, como uma 'ponte' entre células, para fixar o conceito.",
                                  "learningObjective": "Identificar e descrever os elementos estruturais de uma sinapse biológica.",
                                  "commonMistakes": [
                                    "Confundir sinapse com axônio ou dendrito",
                                    "Ignorar a direção da transmissão sináptica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o funcionamento e modulação da força sináptica",
                                  "subSteps": [
                                    "Descreva o processo de transmissão: potencial de ação chega, Ca2+ entra, vesículas liberam neurotransmissores.",
                                    "Explique como receptores pós-sinápticos geram potenciais excitatórios ou inibitórios.",
                                    "Discuta plasticidade sináptica: LTP (potenciação de longo prazo) aumenta força, LTD diminui.",
                                    "Relacione repetição de estímulos à mudança na quantidade de neurotransmissores ou receptores.",
                                    "Registre exemplos biológicos, como aprendizado associativo no hipocampo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o processo de liberação de neurotransmissores e como a força é modulada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Animação interativa de sinapse (ex: Neurobiology simulations)",
                                    "Artigo simples sobre plasticidade sináptica"
                                  ],
                                  "tips": "Pense na sinapse como um 'volume ajustável' para o sinal neural.",
                                  "learningObjective": "Detalhar como sinapses biológicas modulam a intensidade dos sinais através de plasticidade.",
                                  "commonMistakes": [
                                    "Achar que sinapses são fixas e não mudam",
                                    "Confundir excitação com inibição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir o conceito de pesos sinápticos em redes neurais artificiais",
                                  "subSteps": [
                                    "Defina peso sináptico como um valor numérico que multiplica o sinal de entrada em uma conexão neuronal artificial.",
                                    "Mostre a fórmula básica: saída = soma (entrada_i * peso_i) + bias.",
                                    "Explique que pesos iniciais são aleatórios e representam 'força' da conexão.",
                                    "Diferencie pesos positivos (excitatórios) de negativos (inibitórios).",
                                    "Visualize em um diagrama de RNA perceptron simples com pesos anotados."
                                  ],
                                  "verification": "Calcule manualmente a saída de um neurônio artificial com entradas [1, 0.5] e pesos [0.3, -0.2].",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta online de visualização de RNA (ex: TensorFlow Playground)",
                                    "Papel e lápis para cálculos"
                                  ],
                                  "tips": "Compare pesos a 'resistores variáveis' em circuitos elétricos.",
                                  "learningObjective": "Compreender pesos como análogos numéricos da força sináptica em RNA.",
                                  "commonMistakes": [
                                    "Esquecer o papel do bias",
                                    "Confundir pesos com ativações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estabelecer a analogia e o ajuste de pesos durante o aprendizado",
                                  "subSteps": [
                                    "Compare: sinapse biológica modula via plasticidade; peso ajusta via backpropagation.",
                                    "Descreva o algoritmo de aprendizado: erro calculado, gradientes propagados, pesos atualizados (ex: gradiente descendente).",
                                    "Simule um exemplo: peso aumenta com correlação positiva entre entradas/saídas desejadas.",
                                    "Discuta convergência: pesos otimizados mimetizam 'memória' aprendida.",
                                    "Reflita sobre limitações: RNA simplificam biologia complexa."
                                  ],
                                  "verification": "Crie uma tabela comparativa entre sinapse biológica e peso sináptico em RNA.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de código Python simples com RNA (ex: perceptron ajustando pesos)",
                                    "Tabela comparativa em branco"
                                  ],
                                  "tips": "Use setas para mostrar 'antes/depois' do ajuste de pesos em um diagrama.",
                                  "learningObjective": "Explicar a analogia biológica-inspirada e o mecanismo de aprendizado em RNA.",
                                  "commonMistakes": [
                                    "Achar que backpropagation existe no cérebro",
                                    "Ignorar que pesos são otimizados matematicamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma RNA simples para classificar imagens de pontes rachadas vs. intactas (aplicação em Engenharia Civil), pesos sinápticos iniciais aleatórios produzem classificações erradas. Após treinamento com dados de imagens reais, pesos são ajustados: conexões detectando 'rachaduras' ganham pesos altos (análogos a sinapses fortalecidas por repetição de estímulos perigosos no cérebro).",
                              "finalVerifications": [
                                "Desenhar e explicar um diagrama de sinapse biológica com modulação de força.",
                                "Calcular saída de um neurônio artificial dado entradas e pesos.",
                                "Comparar verbalmente sinapse biológica com peso sináptico em pelo menos 3 aspectos.",
                                "Simular ajuste de peso em um exemplo numérico simples.",
                                "Identificar plasticidade sináptica como base para aprendizado em RNA.",
                                "Explicar por que pesos são ajustáveis durante o treinamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção entre biologia e modelo computacional (30%).",
                                "Clareza na analogia: Analogia sinapse-peso bem articulada e sem confusões (25%).",
                                "Uso de exemplos: Inclusão de pelo menos um exemplo prático e verificável (20%).",
                                "Profundidade técnica: Menção a plasticidade, backpropagation e fórmulas básicas (15%).",
                                "Comunicação: Explicação fluida, diagramas claros e linguagem acessível (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Biologia: Plasticidade sináptica e neurociência celular.",
                                "Matemática: Álgebra linear (multiplicação matricial) e otimização (gradiente descendente).",
                                "Computação: Programação de RNA e algoritmos de machine learning.",
                                "Engenharia Civil: Modelagem preditiva de falhas estruturais via RNA.",
                                "Física: Analogia com circuitos elétricos e transmissão de sinais."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, compreender sinapses e pesos permite desenvolver RNA para prever colapsos de pontes analisando dados sensoriais (vibrações, tensões), onde pesos ajustados simulam 'aprendizado' biológico para detectar padrões de falha precocemente, otimizando manutenção preditiva."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Relacionar rede neural biológica à artificial",
                            "description": "Comparar a rede de neurônios no cérebro humano com a arquitetura de RNA, enfatizando simplificações para computação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica da rede neural biológica no cérebro humano",
                                  "subSteps": [
                                    "Estude a composição do cérebro: cerca de 86 bilhões de neurônios interconectados.",
                                    "Descreva o neurônio biológico: dendritos (receptores), soma (corpo celular), axônio (transmissor).",
                                    "Explique sinapses: junções químicas ou elétricas para transmissão de sinais via neurotransmissores.",
                                    "Discuta plasticidade sináptica: fortalecimento ou enfraquecimento de conexões baseado em uso.",
                                    "Visualize uma rede: neurônios em camadas hierárquicas processando informações em paralelo."
                                  ],
                                  "verification": "Desenhe um diagrama simples de um neurônio biológico e rede, rotulando componentes principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de neurociência básica ou vídeo Khan Academy sobre neurônios; papel e caneta para diagrama.",
                                  "tips": "Use analogias cotidianas, como dendritos como 'antenas receptoras' e axônios como 'cabos de transmissão'.",
                                  "learningObjective": "Identificar e descrever os componentes fundamentais de uma rede neural biológica.",
                                  "commonMistakes": "Confundir sinapses com conexões diretas; ignorar o papel da plasticidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a arquitetura fundamental de uma Rede Neural Artificial (RNA)",
                                  "subSteps": [
                                    "Defina RNA: modelo matemático inspirado no cérebro, composto por nós artificiais (neurônios).",
                                    "Descreva componentes: entrada (dendritos), soma ponderada (soma), função de ativação (axônio).",
                                    "Explique pesos sinápticos: números que ajustam a força das conexões durante o treinamento.",
                                    "Discuta camadas: entrada, ocultas e saída, com processamento feedforward.",
                                    "Mencione backpropagation: algoritmo para ajustar pesos baseado em erros."
                                  ],
                                  "verification": "Crie um fluxograma de uma RNA simples com 3 camadas, indicando fluxo de dados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tutorial online sobre RNA (ex: TensorFlow playground); software de desenho como Draw.io.",
                                  "tips": "Experimente no TensorFlow Playground para ver pesos mudando em tempo real.",
                                  "learningObjective": "Mapear os elementos estruturais de uma RNA e seu funcionamento básico.",
                                  "commonMistakes": "Pensar que RNAs são cópias exatas do cérebro; ignorar funções de ativação como sigmoide ou ReLU."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer analogias diretas entre rede biológica e artificial",
                                  "subSteps": [
                                    "Compare neurônio biológico vs. artificial: dendritos/entradas, sinapses/pesos, axônio/saída.",
                                    "Relação rede: cérebro como rede massivamente paralela vs. RNA multicamadas.",
                                    "Paralelismo: ambos processam informações distribuídas.",
                                    "Aprendizado: plasticidade sináptica vs. ajuste de pesos via gradiente descendente.",
                                    "Tabule uma tabela de similaridades lado a lado."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 analogias claras.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Planilha Google Sheets ou papel para tabela; diagramas dos steps anteriores.",
                                  "tips": "Use cores para destacar similaridades: verde para matches, vermelho para diferenças.",
                                  "learningObjective": "Identificar e articular pelo menos 5 analogias precisas entre os dois sistemas.",
                                  "commonMistakes": "Superestimar similaridades, como afirmar que RNAs 'pensam' como humanos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar simplificações da RNA em relação à biologia para fins computacionais",
                                  "subSteps": [
                                    "Simplificação 1: Neurônios binários/determinísticos vs. estocásticos biológicos.",
                                    "Simplificação 2: Conexões fixas vs. dinâmicas e plásticas em tempo real.",
                                    "Simplificação 3: Processamento sequencial em computadores vs. paralelo massivo no cérebro.",
                                    "Simplificação 4: Escala: milhões de parâmetros vs. trilhões de sinapses.",
                                    "Discuta trade-offs: eficiência computacional ganha simplicidade e treinabilidade."
                                  ],
                                  "verification": "Escreva um parágrafo explicando 3 simplificações principais e seus motivos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigo sobre 'Neural Networks are not like the Brain'; notas anteriores.",
                                  "tips": "Pergunte: 'O que sacrificamos pela computabilidade?' para guiar análise.",
                                  "learningObjective": "Explicar como e por quê as RNAs simplificam a biologia para viabilizar computação.",
                                  "commonMistakes": "Ignorar limitações biológicas reais, como ruído e fadiga neuronal."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar a comparação e discutir implicações",
                                  "subSteps": [
                                    "Resuma similaridades e diferenças em um infográfico.",
                                    "Discuta limitações: RNAs não capturam consciência ou emoção.",
                                    "Explore evoluções: RNAs recorrentes ou spiking networks aproximando mais a biologia.",
                                    "Relacione ao contexto: como essa inspiração beneficia engenharia civil (ex: previsão estrutural).",
                                    "Reflita: inspiração biológica acelera inovação computacional?"
                                  ],
                                  "verification": "Apresente uma síntese oral ou escrita de 200 palavras relacionando os conceitos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta Canva para infográfico; gravador de áudio se oral.",
                                  "tips": "Conecte à prática: 'Como isso ajuda em modelar trincas em concreto?'",
                                  "learningObjective": "Integrar conhecimentos para uma visão holística da relação biológica-artificial.",
                                  "commonMistakes": "Focar só em similaridades, negligenciando críticas à analogia."
                                }
                              ],
                              "practicalExample": "Compare um neurônio motor no cérebro (recebe sinais sensoriais via dendritos, integra no soma, dispara impulso via axônio para músculo) com um perceptron em RNA (recebe features de entrada, aplica pesos e bias, passa por sigmoide para output probabilístico de 'mover' ou não). Em engenharia civil, use isso para prever deformação em vigas: inputs como carga/vento, output probabilidade de falha.",
                              "finalVerifications": [
                                "Pode desenhar e explicar diagramas paralelos de rede biológica e RNA?",
                                "Lista corretamente 4 analogias e 3 simplificações principais?",
                                "Explica o papel da plasticidade vs. backpropagation?",
                                "Identifica limitações computacionais das RNAs?",
                                "Aplica o conceito a um exemplo em engenharia civil?",
                                "Discute evoluções futuras aproximando biologia?"
                              ],
                              "assessmentCriteria": [
                                "Precisão científica: analogias e simplificações corretas (30%)",
                                "Profundidade de análise: cobertura de componentes chave (25%)",
                                "Clareza na comunicação: diagramas/tabelas legíveis (20%)",
                                "Criatividade em exemplos: relevância ao contexto civil (15%)",
                                "Síntese integrada: implicações discutidas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Biologia: Neurociência e fisiologia neuronal.",
                                "Matemática: Álgebra linear para pesos e vetores.",
                                "Computação: Programação de modelos em Python/TensorFlow.",
                                "Engenharia Civil: Aplicações em análise preditiva de estruturas."
                              ],
                              "realWorldApplication": "Em engenharia civil, essa compreensão permite desenvolver RNAs para monitorar saúde estrutural de pontes, prevendo falhas por vibrações (inputs sensoriais como neurônios), simplificando bilhões de interações biológicas em milhões de parâmetros treináveis para simulações em tempo real, otimizando manutenção preventiva."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Componentes Principais das RNA",
                        "description": "Identificação e descrição dos elementos estruturais fundamentais das RNA, como camadas e conexões.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Descrever camadas de entrada",
                            "description": "Explicar a camada de entrada como receptora de dados de entrada normalizados, representando variáveis de problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental da camada de entrada em RNAs",
                                  "subSteps": [
                                    "Defina o que é uma camada de entrada em uma Rede Neural Artificial (RNA).",
                                    "Explique o papel da camada de entrada como receptora inicial de dados.",
                                    "Identifique que ela transforma dados brutos em representações numéricas (vetores).",
                                    "Diferencie camada de entrada de camadas ocultas e de saída.",
                                    "Estude diagramas básicos de RNAs destacando a camada de entrada."
                                  ],
                                  "verification": "Crie um diagrama simples de uma RNA rotulando a camada de entrada e descreva seu função em 3 frases.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notebook ou papel para diagrama",
                                    "Tutoriais online sobre componentes de RNA (ex: TensorFlow docs)",
                                    "Vídeos introdutórios de RNA no YouTube"
                                  ],
                                  "tips": "Use analogias como 'porta de entrada de um edifício' para fixar o conceito.",
                                  "learningObjective": "Entender a função primária da camada de entrada como interface de dados para a RNA.",
                                  "commonMistakes": "Confundir com camada de saída; ignorar que é passiva (sem ativação complexa)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender sobre normalização e pré-processamento de dados de entrada",
                                  "subSteps": [
                                    "Explique por que normalizar dados (escala 0-1 ou média zero).",
                                    "Aprenda métodos de normalização: Min-Max, Z-score.",
                                    "Aplique normalização em um conjunto de dados simples manualmente.",
                                    "Discuta impactos de dados não normalizados (gradientes instáveis).",
                                    "Relacione com entradas de engenharia: unidades variadas (kN, m, MPa)."
                                  ],
                                  "verification": "Normalize um vetor de 5 valores de exemplo e compare antes/depois.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou Python/Jupyter Notebook",
                                    "Biblioteca scikit-learn para normalização",
                                    "Exemplos de dados de engenharia civil"
                                  ],
                                  "tips": "Sempre verifique a faixa de valores após normalização para evitar overflow.",
                                  "learningObjective": "Dominar técnicas de normalização para preparar dados adequados à camada de entrada.",
                                  "commonMistakes": "Esquecer de aplicar a mesma transformação no conjunto de teste; usar escala errada para dados negativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear variáveis de problemas de engenharia civil para a camada de entrada",
                                  "subSteps": [
                                    "Liste variáveis comuns em EC: cargas, dimensões, materiais (ex: resistência concreto).",
                                    "Atribua cada variável a um neurônio/elemento na camada de entrada.",
                                    "Crie um vetor de entrada exemplo para um problema específico (ex: análise de viga).",
                                    "Discuta dimensionalidade: número de neurônios = número de features.",
                                    "Analise como variáveis categóricas (ex: tipo de solo) são codificadas (one-hot)."
                                  ],
                                  "verification": "Monte um vetor de entrada para um problema de EC com 4 variáveis e justifique normalização.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Casos reais de problemas EC (ex: livros de estruturas)",
                                    "Ferramentas de visualização como Draw.io"
                                  ],
                                  "tips": "Priorize features mais impactantes para reduzir dimensionalidade inicial.",
                                  "learningObjective": "Relacionar variáveis reais de EC com representações vetoriais na camada de entrada.",
                                  "commonMistakes": "Incluir variáveis irrelevantes, aumentando ruído; ignorar correlações entre features."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Elaborar uma descrição completa e visual da camada de entrada",
                                  "subSteps": [
                                    "Estruture uma descrição: função, normalização, mapeamento de variáveis EC.",
                                    "Crie um fluxograma: dados brutos → normalização → camada de entrada.",
                                    "Escreva um parágrafo descritivo integrando todos os conceitos.",
                                    "Simule em código simples (ex: Python com NumPy) a criação da camada.",
                                    "Revise e refine a descrição para clareza e precisão."
                                  ],
                                  "verification": "Produza um relatório de 1 página com descrição, diagrama e código exemplo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Editor de texto ou LaTeX",
                                    "Python com NumPy/Pandas",
                                    "Ferramentas de diagrama (Lucidchart ou similar)"
                                  ],
                                  "tips": "Use bullet points para mapeamento de variáveis para facilitar leitura.",
                                  "learningObjective": "Sintetizar conhecimentos em uma descrição acionável e visual da camada de entrada.",
                                  "commonMistakes": "Descrições vagas sem exemplos; omitir normalização ou contexto EC."
                                }
                              ],
                              "practicalExample": "Em uma RNA para prever a deformação máxima em uma viga de concreto armado sob carga distribuída, a camada de entrada recebe um vetor normalizado [0.3, 0.7, 0.5, 0.2, 0.8] representando: carga (kN/m), comprimento (m), seção transversal (cm²), módulo de elasticidade (GPa) e fator de segurança, todos escalados via Min-Max para [0,1].",
                              "finalVerifications": [
                                "Descreva verbalmente a camada de entrada sem consultar notas.",
                                "Crie um vetor de entrada para um novo problema EC e normalize-o corretamente.",
                                "Identifique erros em uma descrição incompleta de camada de entrada.",
                                "Desenhe um diagrama de RNA destacando a camada de entrada.",
                                "Explique impacto de normalização inadequada em um exemplo EC.",
                                "Compare camada de entrada com camadas subsequentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: função e componentes corretos (30%)",
                                "Integração com EC: variáveis relevantes mapeadas (25%)",
                                "Detalhes técnicos: normalização e representação vetorial (20%)",
                                "Clareza e estrutura: descrição organizada e visual (15%)",
                                "Exemplos práticos: aplicabilidade real demonstrada (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores, matrizes e normalização linear",
                                "Programação: Manipulação de arrays em Python/NumPy",
                                "Estatística: Pré-processamento de dados e escalonamento",
                                "Física/Engenharia: Variáveis de mecânica estrutural",
                                "Design Computacional: Arquitetura de modelos de ML"
                              ],
                              "realWorldApplication": "Na engenharia civil, camadas de entrada em RNAs processam dados de sensores IoT em pontes para prever fadiga estrutural, permitindo manutenção preditiva e evitando colapsos, como em sistemas de monitoramento da ponte Rio-Niterói."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Explicar camadas ocultas",
                            "description": "Detalhar camadas ocultas como processadoras de informações não-lineares via funções de ativação, permitindo aprendizado de padrões complexos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica das camadas ocultas em uma RNA",
                                  "subSteps": [
                                    "Defina camadas ocultas como as camadas intermediárias entre entrada e saída em uma rede neural artificial.",
                                    "Compare com camadas de entrada (recebem dados brutos) e saída (produzem resultados finais).",
                                    "Identifique que camadas ocultas recebem entradas ponderadas das camadas anteriores e aplicam transformações.",
                                    "Visualize um diagrama simples de uma RNA com uma camada oculta.",
                                    "Explique o fluxo de dados: forward pass através das camadas ocultas."
                                  ],
                                  "verification": "Desenhe um diagrama de uma RNA simples com camadas ocultas e rotule cada uma corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de desenho como Draw.io",
                                    "Diagrama exemplo de RNA de um tutorial online"
                                  ],
                                  "tips": "Comece com uma rede de uma única camada oculta para simplicidade antes de múltiplas.",
                                  "learningObjective": "Identificar e diferenciar camadas ocultas de outras camadas em uma RNA.",
                                  "commonMistakes": [
                                    "Confundir camadas ocultas com camadas de saída",
                                    "Ignorar o papel intermediário das ocultas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar funções de ativação nas camadas ocultas",
                                  "subSteps": [
                                    "Liste funções comuns: ReLU, Sigmoid, Tanh e explique suas fórmulas matemáticas básicas.",
                                    "Descreva como funções de ativação introduzem não-linearidade nos neurônios.",
                                    "Calcule manualmente a saída de um neurônio com ativação ReLU para entradas simples (ex: soma ponderada = 2 → saída = 2; soma = -1 → saída = 0).",
                                    "Compare ativação linear vs. não-linear e por que linear não permite aprendizado complexo.",
                                    "Implemente uma função de ativação simples em Python usando NumPy."
                                  ],
                                  "verification": "Implemente e execute um código Python que aplique ReLU a um vetor de entradas e compare saídas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy instalado",
                                    "Notebook Jupyter ou editor online como Google Colab"
                                  ],
                                  "tips": "Use gráficos para visualizar curvas de ativação (matplotlib.plot).",
                                  "learningObjective": "Explicar o papel das funções de ativação em introduzir não-linearidade nas camadas ocultas.",
                                  "commonMistakes": [
                                    "Esquecer que funções lineares destroem a capacidade de modelar padrões não-lineares",
                                    "Confundir ativação com soma ponderada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o processamento de informações não-lineares",
                                  "subSteps": [
                                    "Descreva como múltiplas camadas ocultas compõem transformações não-lineares complexas.",
                                    "Explique o conceito de 'representações hierárquicas': camadas iniciais detectam features simples, profundas detectam complexas.",
                                    "Simule com exemplo: em reconhecimento de padrões estruturais, primeira camada detecta bordas em imagens de rachaduras, camadas profundas detectam padrões de falha.",
                                    "Discuta backpropagation: como pesos nas ocultas são ajustados para minimizar erro.",
                                    "Calcule um forward pass completo em uma rede com 2 neurônios ocultos."
                                  ],
                                  "verification": "Resolva um exercício manual de forward pass em uma mini-RNA e identifique contribuições não-lineares.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou calculadora para simulações numéricas",
                                    "Tutorial interativo de RNA como TensorFlow Playground"
                                  ],
                                  "tips": "Use TensorFlow Playground para visualizar como ativações afetam o processamento.",
                                  "learningObjective": "Detalhar como camadas ocultas processam informações de forma não-linear.",
                                  "commonMistakes": [
                                    "Pensar que camadas ocultas são 'caixas-pretas' sem explicação hierárquica",
                                    "Subestimar o impacto da profundidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conectar camadas ocultas ao aprendizado de padrões complexos",
                                  "subSteps": [
                                    "Explique como combinações de ativações não-lineares permitem aproximar qualquer função contínua (Teorema de Aproximação Universal).",
                                    "Dê exemplo em Engenharia Civil: previsão de assentamento de solos baseado em dados não-lineares de carga e umidade.",
                                    "Descreva treinamento: gradiente descendente ajusta pesos para capturar padrões em dados de treinamento.",
                                    "Discuta overfitting e como regularização afeta camadas ocultas.",
                                    "Crie um fluxograma do processo de aprendizado envolvendo ocultas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como camadas ocultas habilitam aprendizado de padrões complexos em um caso de engenharia civil.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigos ou vídeos sobre Teorema de Cybenko",
                                    "Dataset simples de engenharia civil para RNA (ex: Kaggle)"
                                  ],
                                  "tips": "Relacione sempre a exemplos práticos de engenharia para fixar conceitos.",
                                  "learningObjective": "Demonstrar como camadas ocultas permitem o aprendizado de padrões complexos via não-linearidade.",
                                  "commonMistakes": [
                                    "Ignorar o teorema de universal approximation",
                                    "Confundir aprendizado com mero armazenamento de dados"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma RNA para prever deformações em vigas de concreto sob cargas variáveis, as camadas ocultas processam entradas como tensão, umidade e idade do material via ReLU, detectando padrões não-lineares como fadiga acelerada em condições úmidas, permitindo predições precisas que evitam colapsos estruturais.",
                              "finalVerifications": [
                                "Pode diagramar uma RNA com camadas ocultas e rotular funções de ativação?",
                                "Explica corretamente a não-linearidade e seu impacto no aprendizado?",
                                "Calcula forward pass em uma rede simples com ocultas?",
                                "Relaciona camadas ocultas a um problema real de engenharia civil?",
                                "Discute limitações como vanishing gradients em redes profundas?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e diferenciação de camadas ocultas (30%)",
                                "Compreensão profunda de funções de ativação e não-linearidade (25%)",
                                "Capacidade de simular processamento e forward pass (20%)",
                                "Aplicação conceitual a padrões complexos e teorema de aproximação (15%)",
                                "Clareza na explicação oral/escrita com exemplos relevantes (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de pesos) e cálculo (derivadas em backprop)",
                                "Programação: Implementação em Python/TensorFlow para simulações",
                                "Física: Modelagem não-linear de materiais em engenharia estrutural",
                                "Estatística: Análise de dados para treinamento de RNAs"
                              ],
                              "realWorldApplication": "Nas soluções computacionais para engenharia civil, camadas ocultas em RNAs preveem comportamentos não-lineares como fluxo de tráfego em pontes ou estabilidade de taludes, otimizando projetos e reduzindo riscos de falhas catastróficas em infraestruturas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Definir camadas de saída e conexões",
                            "description": "Descrever a camada de saída para predições finais e conexões como links pesados entre neurônios, ajustados por algoritmos de otimização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Camada de Saída em Redes Neurais",
                                  "subSteps": [
                                    "Estude a definição de camada de saída como a última camada da RNA responsável por gerar predições finais.",
                                    "Identifique tipos comuns de camadas de saída: linear para regressão, softmax para classificação multiclasse.",
                                    "Analise funções de ativação adequadas, como sigmoid para saída binária ou ReLU para regressão contínua.",
                                    "Desenhe um diagrama simples de uma RNA com camadas de entrada, ocultas e saída.",
                                    "Relacione com problemas de engenharia civil, como previsão de deformação em estruturas."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama de RNA destacando a camada de saída.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou software de desenho como Draw.io; slides ou vídeo sobre arquitetura de RNA.",
                                  "tips": "Use analogias como 'a camada de saída é a boca que pronuncia a resposta final'.",
                                  "learningObjective": "Explicar o papel e tipos da camada de saída em uma RNA.",
                                  "commonMistakes": "Confundir camada de saída com camadas ocultas; ignorar funções de ativação específicas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Conexões como Links Pesados entre Neurônios",
                                  "subSteps": [
                                    "Descreva conexões como arestas direcionadas entre neurônios de camadas adjacentes com pesos associados.",
                                    "Explique pesos como valores numéricos que modulam a influência de um neurônio no seguinte.",
                                    "Calcule a saída de um neurônio: soma ponderada das entradas mais bias, seguida de ativação.",
                                    "Implemente uma conexão simples em pseudocódigo ou Python.",
                                    "Visualize pesos em um grafo de rede neural usando ferramentas como TensorFlow Playground."
                                  ],
                                  "verification": "Implemente e execute um cálculo manual de uma conexão com pesos dados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora; editor de código Python com NumPy; TensorFlow Playground online.",
                                  "tips": "Pense nos pesos como 'forças' que fortalecem ou enfraquecem sinais entre neurônios.",
                                  "learningObjective": "Modelar conexões sinápticas artificiais com pesos ajustáveis.",
                                  "commonMistakes": "Esquecer o bias nas conexões; confundir pesos com funções de ativação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar Ajuste de Pesos por Algoritmos de Otimização",
                                  "subSteps": [
                                    "Revise backpropagation como método para calcular gradientes de erro em relação aos pesos.",
                                    "Estude otimizadores como Gradient Descent, Adam ou SGD para atualizar pesos.",
                                    "Simule um ciclo de treinamento: forward pass, cálculo de perda, backward pass e update.",
                                    "Aplique a uma mini-RNA com dados de engenharia civil, como tensão em vigas.",
                                    "Monitore convergência plotando perda vs. épocas."
                                  ],
                                  "verification": "Simule um update de peso manual usando gradiente descendente em um exemplo simples.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Jupyter Notebook com PyTorch ou TensorFlow; dataset simples de regressão.",
                                  "tips": "Comece com learning rate baixo para evitar divergência no treinamento.",
                                  "learningObjective": "Descrever o processo de otimização de conexões para minimizar erros.",
                                  "commonMistakes": "Ignorar a direção do gradiente; usar learning rate inadequado levando a oscilações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Camada de Saída e Conexões em uma RNA Completa",
                                  "subSteps": [
                                    "Construa uma RNA feedforward simples com camada de saída e conexões definidas.",
                                    "Treine o modelo em um problema real: prever carga crítica em estruturas civis.",
                                    "Avalie predições comparando com valores reais.",
                                    "Ajuste hiperparâmetros como número de neurônios na saída e otimizador.",
                                    "Documente o design final com diagrama e equações."
                                  ],
                                  "verification": "Treine uma RNA e gere predições precisas (erro < 10%) em dataset de teste.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com Keras/TensorFlow; dataset público de engenharia civil (ex: UCI ML repo).",
                                  "tips": "Normalize dados de entrada para acelerar convergência.",
                                  "learningObjective": "Aplicar conceitos de saída e conexões em um modelo funcional.",
                                  "commonMistakes": "Sobrecarregar a camada de saída com neurônios desnecessários; não validar o modelo."
                                }
                              ],
                              "practicalExample": "Em engenharia civil, use uma RNA para prever a resistência à compressão do concreto. A camada de saída tem 1 neurônio (regressão linear), conexões pesadas conectam camadas ocultas à saída, ajustadas via Adam para minimizar MSE em dados de misturas de cimento.",
                              "finalVerifications": [
                                "Diagrama da RNA rotulado corretamente com camada de saída e conexões.",
                                "Cálculo manual de forward pass através de conexões.",
                                "Simulação de backpropagation atualizando pesos.",
                                "Modelo treinado com perda convergindo abaixo de threshold.",
                                "Predição precisa em exemplo de engenharia civil.",
                                "Explicação escrita dos componentes em 200 palavras."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da camada de saída (tipos e ativações).",
                                "Correção no modelamento de conexões e pesos.",
                                "Compreensão demonstrada de otimização (backprop e otimizadores).",
                                "Integração coerente em exemplo prático.",
                                "Ausência de erros comuns em cálculos e implementações.",
                                "Clareza em diagramas e explicações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para multiplicação de matrizes de pesos.",
                                "Programação: Implementação em Python com bibliotecas de ML.",
                                "Estatística: Análise de perda e métricas de avaliação.",
                                "Engenharia Civil: Aplicações em modelagem preditiva de materiais e estruturas."
                              ],
                              "realWorldApplication": "Nas obras civis, RNAs com camadas de saída bem definidas e conexões otimizadas preveem falhas em pontes ou túneis, otimizando manutenção preventiva e reduzindo custos em milhões, como em sistemas de monitoramento estrutural da ASCE."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.4",
                            "name": "Representar diagrama de RNA básica",
                            "description": "Esboçar e interpretar um diagrama simples de RNA com camadas de entrada, oculta e saída, incluindo conexões e pesos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar componentes básicos de uma RNA",
                                  "subSteps": [
                                    "Identifique as três camadas principais: entrada, oculta e saída.",
                                    "Entenda que nós (neurônios) na camada de entrada recebem dados de entrada.",
                                    "Aprenda que a camada oculta processa dados via pesos e funções de ativação.",
                                    "Compreenda que a camada de saída produz a predição final.",
                                    "Liste exemplos de funções de ativação comuns como ReLU ou sigmoide."
                                  ],
                                  "verification": "Crie uma lista anotada dos componentes e explique cada um em voz alta ou por escrito.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, caneta, diagrama de referência de RNA simples (impresso ou digital).",
                                  "tips": "Use cores diferentes para cada camada para facilitar a visualização.",
                                  "learningObjective": "Compreender a estrutura hierárquica e funções de cada camada em uma RNA básica.",
                                  "commonMistakes": "Confundir camada oculta com saída; ignorar funções de ativação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Esboçar as camadas e nós da RNA",
                                  "subSteps": [
                                    "Desenhe 3-5 nós na camada de entrada (esquerda).",
                                    "Adicione 3-4 nós na camada oculta (meio).",
                                    "Desenhe 2-3 nós na camada de saída (direita).",
                                    "Alinhe as camadas verticalmente para clareza.",
                                    "Rotule cada camada claramente (Entrada, Oculta, Saída)."
                                  ],
                                  "verification": "Verifique se o esboço tem exatamente três camadas alinhadas com nós representados como círculos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, lápis, borracha, régua.",
                                  "tips": "Mantenha espaçamento uniforme entre nós para simetria visual.",
                                  "learningObjective": "Dominar o layout espacial das camadas e representação de neurônios.",
                                  "commonMistakes": "Desalinhar camadas; usar poucos nós na oculta, subestimando complexidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar conexões e pesos entre camadas",
                                  "subSteps": [
                                    "Desenhe setas conectando todos os nós de entrada aos da oculta.",
                                    "Conecte todos os nós ocultos aos da saída com setas.",
                                    "Atribua valores numéricos aleatórios aos pesos (ex: w11=0.5, w12=-0.3).",
                                    "Rotule cada seta com seu peso correspondente.",
                                    "Indique direção do fluxo de dados com setas unidirecionais."
                                  ],
                                  "verification": "Conte as conexões: deve haver conexões completas entre camadas adjacentes com pesos rotulados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Marcadores finos para setas e rótulos, calculadora para pesos aleatórios.",
                                  "tips": "Use pesos positivos e negativos para mostrar inibição/excitação.",
                                  "learningObjective": "Representar sinapses artificiais via conexões pesadas.",
                                  "commonMistakes": "Esquecer conexões fully connected; rotular pesos incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e anotar o diagrama completo",
                                  "subSteps": [
                                    "Explique o fluxo: dados entram → multiplicados por pesos → soma e ativação → saída.",
                                    "Anotar funções de ativação em nós ocultos e saída.",
                                    "Simule um exemplo numérico simples com entradas fictícias.",
                                    "Identifique como pesos afetam a saída.",
                                    "Descreva limitações de uma RNA básica (sem bias inicial)."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a interpretação e simule uma passagem forward.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel adicional para anotações, software de desenho opcional como Draw.io.",
                                  "tips": "Use setas grossas para fluxos principais e finas para pesos pequenos.",
                                  "learningObjective": "Interpretar funcionalmente o diagrama e simular propagação forward.",
                                  "commonMistakes": "Ignorar ativações; não simular numericamente."
                                }
                              ],
                              "practicalExample": "Desenhe uma RNA básica para prever a resistência à compressão de concreto: 4 entradas (cimento, areia, água, idade), 3 nós ocultos, 1 saída (resistência MPa). Atribua pesos como w1=0.8 (cimento forte), simule entrada [300,600,200,28] → saída 45 MPa.",
                              "finalVerifications": [
                                "Diagrama possui três camadas distintas com nós corretos?",
                                "Todas conexões fully connected estão presentes e direcionadas?",
                                "Pesos numéricos estão rotulados em cada conexão?",
                                "Funções de ativação estão indicadas nos nós ocultos/saída?",
                                "Interpretação escrita explica fluxo de dados e impacto de pesos?",
                                "Exemplo prático é simulável com números fornecidos?"
                              ],
                              "assessmentCriteria": [
                                "Clareza visual: layout limpo, rótulos legíveis (30%)",
                                "Precisão técnica: camadas, conexões e pesos corretos (30%)",
                                "Completude: todos elementos (ativações, fluxos) incluídos (20%)",
                                "Interpretação: explicação funcional precisa (10%)",
                                "Criatividade: exemplo relevante a engenharia civil (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: multiplicação matricial para propagação forward.",
                                "Programação: implementação em Python com NumPy/TensorFlow.",
                                "Engenharia Civil: modelagem preditiva de propriedades de materiais.",
                                "Física: analogia com sinapses neurais biológicas."
                              ],
                              "realWorldApplication": "Em engenharia civil, diagramas de RNA básica são usados para visualizar modelos que preveem falhas em estruturas, otimizam misturas de concreto ou detectam anomalias em monitoramento de pontes via sensores IoT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Modelo de Neurônio Artificial",
                    "description": "Estrutura do neurônio: soma ponderada de entradas e funções de ativação comuns (ex: sigmoide, ReLU).",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Entradas e Pesos Sinápticos no Neurônio Artificial",
                        "description": "Compreender os componentes iniciais do modelo de neurônio artificial, incluindo as entradas (variáveis de entrada) e os pesos sinápticos (w_i), que representam a força de conexão de cada entrada com o neurônio.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Identificar entradas e pesos em um neurônio",
                            "description": "Dado um conjunto de entradas x_1, x_2, ..., x_n e pesos w_1, w_2, ..., w_n, identificar corretamente cada componente e sua representação matemática no modelo de neurônio artificial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica de um neurônio artificial",
                                  "subSteps": [
                                    "Estude a definição de um neurônio artificial como unidade computacional inspirada no neurônio biológico.",
                                    "Analise um diagrama padrão de neurônio, identificando soma ponderada e função de ativação.",
                                    "Liste os componentes principais: entradas, pesos sinápticos, soma, bias e saída.",
                                    "Compare com neurônio biológico para destacar simplificações matemáticas.",
                                    "Anote a fórmula geral: z = Σ(x_i * w_i) + b"
                                  ],
                                  "verification": "Desenhe um diagrama rotulado de um neurônio artificial simples e explique verbalmente cada parte.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de neurônio artificial (imagem ou vídeo introdutório)",
                                    "Folha de papel e caneta para esboço"
                                  ],
                                  "tips": "Use cores diferentes para entradas (azul) e pesos (vermelho) no diagrama para facilitar a visualização.",
                                  "learningObjective": "Dominar os componentes fundamentais de um neurônio artificial e sua representação visual.",
                                  "commonMistakes": [
                                    "Confundir neurônio artificial com biológico sem simplificações",
                                    "Omitir o bias na soma ponderada",
                                    "Ignorar a direção das setas nos diagramas (entradas → pesos)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e representar as entradas (x_i)",
                                  "subSteps": [
                                    "Defina entradas como variáveis de entrada: x_1, x_2, ..., x_n representando features do problema.",
                                    "Examine exemplos: em engenharia civil, x_1 pode ser carga aplicada, x_2 umidade do solo.",
                                    "Pratique rotulando entradas em diagramas: círculo ou vetor de entrada à esquerda do neurônio.",
                                    "Escreva notação matemática: vetor X = [x_1, x_2, ..., x_n].",
                                    "Discuta dimensionalidade: n entradas para problemas multivariados."
                                  ],
                                  "verification": "Dado um diagrama sem rótulos, rotule corretamente todas as entradas e justifique.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagramas de neurônios com entradas destacadas",
                                    "Exemplos de features em engenharia civil"
                                  ],
                                  "tips": "Lembre-se: entradas são dados brutos ou normalizados, sempre indexadas de 1 a n.",
                                  "learningObjective": "Reconhecer entradas como vetores de features e sua posição no modelo de neurônio.",
                                  "commonMistakes": [
                                    "Confundir entradas com saídas",
                                    "Usar índices errados (começar de 0 sem contexto)",
                                    "Ignorar que entradas podem ser normalizadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e representar os pesos sinápticos (w_i)",
                                  "subSteps": [
                                    "Defina pesos como coeficientes de importância: w_1, w_2, ..., w_n multiplicando cada x_i.",
                                    "Visualize pesos como setas ou multiplicadores nas conexões entrada-neurônio.",
                                    "Examine exemplos: w_1 alto indica alta influência de x_1 na soma.",
                                    "Escreva notação: vetor W = [w_1, w_2, ..., w_n], produto escalar X·W.",
                                    "Discuta aprendizado: pesos ajustados durante treinamento via backpropagation."
                                  ],
                                  "verification": "Em um diagrama, associe pesos corretos a entradas específicas e calcule soma parcial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagramas com pesos anotados",
                                    "Calculadora para produto escalar simples"
                                  ],
                                  "tips": "Pesos podem ser positivos (ativação) ou negativos (inibição); teste com valores.",
                                  "learningObjective": "Identificar pesos como moduladores de entradas e sua representação vetorial.",
                                  "commonMistakes": [
                                    "Trocar pesos por entradas",
                                    "Assumir pesos fixos sem menção a treinamento",
                                    "Esquecer sinal dos pesos (positivos/negativos)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar identificação de entradas e pesos com representação matemática",
                                  "subSteps": [
                                    "Combine conceitos: dado {x_i} e {w_i}, escreva soma z = Σ x_i w_i.",
                                    "Pratique em diagramas completos: rotule x_i e w_i em um neurônio com 3-5 entradas.",
                                    "Calcule soma ponderada manualmente para verificação.",
                                    "Inclua bias opcionalmente: z = Σ x_i w_i + b.",
                                    "Explique papel no neurônio: entradas e pesos formam input para ativação."
                                  ],
                                  "verification": "Resolva exercício: identifique e compute z para dado conjunto x e w.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exercícios impressos ou digitais com diagramas",
                                    "Planilha para cálculos"
                                  ],
                                  "tips": "Sempre verifique índices: x_1 com w_1, etc., para evitar desalinhamento.",
                                  "learningObjective": "Aplicar identificação conjunta de entradas e pesos em contexto matemático completo.",
                                  "commonMistakes": [
                                    "Desalinhar índices entre x e w",
                                    "Omitir soma no cálculo",
                                    "Confundir z com saída final (pré-ativação)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo para prever resistência de concreto: entradas x_1=200 (kg/m³ cimento), x_2=0.5 (relação água/cimento), x_3=15 (idade em dias); pesos w_1=0.6, w_2=-0.3, w_3=0.4. Identifique: x_1 e w_1 na primeira conexão, calcule z = (200*0.6) + (0.5*-0.3) + (15*0.4) = 120 - 0.15 + 6 = 125.85.",
                              "finalVerifications": [
                                "Rotular corretamente entradas e pesos em qualquer diagrama de neurônio.",
                                "Escrever a fórmula matemática Σ x_i w_i para soma ponderada.",
                                "Calcular soma ponderada sem erros para 3-5 entradas/pesos.",
                                "Explicar diferença entre entradas (dados) e pesos (aprendidos).",
                                "Identificar em contexto de engenharia civil (ex: features estruturais).",
                                "Diferenciar de bias ou ativação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na rotulação: 100% correto em diagramas.",
                                "Correção matemática: soma ponderada exata.",
                                "Explicação clara: define x_i e w_i com exemplos.",
                                "Compreensão contextual: liga a aplicações reais.",
                                "Ausência de confusões: distingue entradas/pesos/bias.",
                                "Rapidez e confiança na identificação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: vetores e produto escalar (X · W).",
                                "Programação: implementação em Python (NumPy arrays para x e w).",
                                "Estatística: pesos como coeficientes de regressão em modelos preditivos.",
                                "Engenharia Civil: features como cargas/variáveis em simulações ANN.",
                                "Física: analogia com forças ponderadas em estruturas."
                              ],
                              "realWorldApplication": "Em engenharia civil, identificar entradas (ex: tensão, deformação) e pesos em ANNs para prever falhas em pontes ou otimizar misturas de concreto, permitindo simulações precisas sem testes físicos caros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Representar matematicamente entradas e pesos",
                            "description": "Escrever a expressão matemática para o produto de entradas por pesos, como ∑(w_i * x_i), e explicar o papel dos pesos na modulação das entradas no contexto de problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de entradas e pesos em um neurônio artificial",
                                  "subSteps": [
                                    "Defina entradas (x_i) como variáveis de entrada representando dados do problema, como cargas ou deformações em estruturas civis.",
                                    "Defina pesos sinápticos (w_i) como coeficientes ajustáveis que modulam a influência de cada entrada.",
                                    "Desenhe um diagrama simples de um neurônio artificial destacando entradas e pesos conectados ao soma.",
                                    "Discuta como múltiplas entradas (i=1 a n) convergem via pesos para uma soma ponderada."
                                  ],
                                  "verification": "Escreva definições claras e desenhe o diagrama; verifique se identifica corretamente x_i e w_i em um exemplo dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, imagem de neurônio artificial (imprimir ou digital)",
                                  "tips": "Pense nos pesos como 'forças de conexão' semelhantes a rigidez em elementos finitos.",
                                  "learningObjective": "Identificar e diferenciar entradas e pesos no modelo de neurônio.",
                                  "commonMistakes": "Confundir entradas com pesos ou assumir pesos fixos em vez de treináveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a expressão matemática da soma ponderada",
                                  "subSteps": [
                                    "Escreva a expressão para uma única entrada-peso: w_1 * x_1.",
                                    "Expanda para múltiplas: w_1 * x_1 + w_2 * x_2 + ... + w_n * x_n.",
                                    "Introduza a notação de soma: ∑_{i=1}^n (w_i * x_i).",
                                    "Inclua o bias se aplicável, mas foque na soma principal: z = ∑ w_i x_i."
                                  ],
                                  "verification": "Escreva a fórmula ∑(w_i * x_i) corretamente em um caderno e teste com n=3 valores numéricos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, caneta, calculadora para validação numérica",
                                  "tips": "Use índices i consistentes; pratique com 2-3 entradas primeiro.",
                                  "learningObjective": "Derivar e notate a soma ponderada matematicamente.",
                                  "commonMistakes": "Esquecer o índice i na soma ou inverter w_i e x_i na multiplicação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o papel dos pesos na modulação das entradas",
                                  "subSteps": [
                                    "Descreva pesos positivos amplificando entradas (ex: w_i > 1 aumenta impacto).",
                                    "Descreva pesos negativos inibindo entradas (ex: w_i < 0 reduz ou inverte sinal).",
                                    "Explique ajuste via treinamento: pesos mudam para otimizar saída do neurônio.",
                                    "Ilustre com exemplo: peso alto em entrada de 'carga crítica' modula mais em análise estrutural.",
                                    "Compare a pesos como 'sensibilidades' em modelos de engenharia."
                                  ],
                                  "verification": "Escreva um parágrafo explicando modulação e dê um exemplo numérico onde mudar w_i altera z significativamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, exemplos numéricos impressos ou em spreadsheet simples",
                                  "tips": "Visualize pesos como alavancas ajustáveis em uma balança de forças.",
                                  "learningObjective": "Compreender como pesos controlam influência relativa das entradas.",
                                  "commonMistakes": "Assumir pesos sempre positivos ou ignorar seu papel dinâmico no aprendizado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a representação em contexto de engenharia civil",
                                  "subSteps": [
                                    "Identifique entradas relevantes: ex. x1= carga vertical, x2= vento, x3= deformação basal em uma ponte.",
                                    "Atribua pesos iniciais: ex. w1=0.8 (alta para carga), w2=0.4, w3=0.6.",
                                    "Calcule z = ∑ w_i x_i para valores numéricos dados.",
                                    "Discuta como isso alimenta a função de ativação para previsão de falha estrutural.",
                                    "Registre como pesos são otimizados em NN para precisão em simulações civis."
                                  ],
                                  "verification": "Resolva um problema numérico completo e explique o impacto de um peso alterado na saída.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Calculadora ou Excel/Python básico, dados de exemplo de estruturas civis",
                                  "tips": "Escolha entradas realistas de problemas civis para melhor retenção.",
                                  "learningObjective": "Contextualizar a fórmula em aplicações de engenharia civil.",
                                  "commonMistakes": "Usar entradas irrelevantes ou não escalar valores para unidades consistentes."
                                }
                              ],
                              "practicalExample": "Em análise de uma viga de concreto sob cargas variáveis: entradas x1=10 kN (carga morta), x2=5 kN (carga viva), x3=2 kN (vento); pesos w1=0.9, w2=0.7, w3=0.3. Calcule z = 0.9*10 + 0.7*5 + 0.3*2 = 11.1 kN efetivo, onde pesos modulam contribuição para prever tensão máxima.",
                              "finalVerifications": [
                                "Escreve corretamente ∑_{i=1}^n w_i x_i sem erros de notação.",
                                "Explica verbalmente o papel modulador dos pesos com exemplo numérico.",
                                "Aplica a fórmula a um cenário de engenharia civil com cálculo preciso.",
                                "Identifica como pesos são ajustados em treinamento de redes neurais.",
                                "Desenha diagrama de neurônio com entradas, pesos e soma rotulados.",
                                "Discute limitações, como necessidade de normalização de entradas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da fórmula matemática (correta notação e índices): 25%.",
                                "Clareza na explicação do papel dos pesos (modulação e ajuste): 25%.",
                                "Correção em cálculo numérico de exemplo prático: 20%.",
                                "Relevância ao contexto de engenharia civil: 15%.",
                                "Profundidade dos subpassos e avoidance de erros comuns: 15%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (vetores de pesos e entradas como produto escalar).",
                                "Física: Mecânica estrutural (cargas ponderadas semelhantes a combinações de ações).",
                                "Programação: Implementação em Python/NumPy para soma de arrays.",
                                "Estatística: Inicialização e otimização de pesos via gradiente descendente."
                              ],
                              "realWorldApplication": "Em redes neurais para previsão de colapso de pontes ou edifícios, entradas de sensores (strain gauges, acelerômetros) são ponderadas por pesos treinados para detectar anomalias precocemente, otimizando manutenção preditiva e segurança em infraestrutura civil."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Inicializar pesos em um exemplo simples",
                            "description": "Para um neurônio com 3 entradas, atribuir valores iniciais aos pesos e justificar escolhas comuns como inicialização aleatória pequena, relacionando com estabilidade numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a estrutura do neurônio artificial com 3 entradas",
                                  "subSteps": [
                                    "Desenhe um diagrama simples de um neurônio com 3 entradas (x1, x2, x3), pesos sinápticos (w1, w2, w3) e viés (b).",
                                    "Explique a fórmula da soma ponderada: z = x1*w1 + x2*w2 + x3*w3 + b.",
                                    "Discuta por que os pesos iniciais afetam o aprendizado.",
                                    "Identifique o papel dos pesos como variáveis ajustáveis durante o treinamento.",
                                    "Anote exemplos de valores de entrada típicos em contextos de engenharia civil, como tensões ou cargas."
                                  ],
                                  "verification": "Diagrama desenhado corretamente e fórmula escrita sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, software de desenho como Draw.io ou Python com Matplotlib (opcional)",
                                  "tips": "Use setas para representar entradas e pesos no diagrama para visualização clara.",
                                  "learningObjective": "Compreender a topologia básica de um neurônio e o impacto dos pesos iniciais.",
                                  "commonMistakes": "Confundir pesos com entradas ou esquecer o viés na soma ponderada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar métodos comuns de inicialização de pesos",
                                  "subSteps": [
                                    "Liste métodos: inicialização zero (ruim para simetria), aleatória pequena (uniforme [-0.1, 0.1]), Xavier/Glorot ou He.",
                                    "Explique por que inicialização zero causa problemas de gradiente nulo.",
                                    "Discuta inicialização aleatória pequena para quebrar simetria e manter gradientes estáveis.",
                                    "Relacione com estabilidade numérica: valores pequenos evitam overflow/underflow em ativações.",
                                    "Pesquise referências rápidas como papers de LeCun ou Goodfellow."
                                  ],
                                  "verification": "Lista de métodos com prós/contras documentada em tabela.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Notebook, acesso à internet para referências (Deep Learning book capítulo 6)",
                                  "tips": "Crie uma tabela comparativa para fixar diferenças entre métodos.",
                                  "learningObjective": "Identificar e justificar o método de inicialização aleatória pequena para estabilidade.",
                                  "commonMistakes": "Escolher valores grandes (>1) sem considerar escala das entradas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar inicialização de pesos em um exemplo com 3 entradas",
                                  "subSteps": [
                                    "Defina entradas exemplo: x1=1.0 (carga vertical), x2=0.5 (vento), x3=-0.2 (deformação prévia).",
                                    "Gere pesos aleatórios pequenos: w1=0.12, w2=-0.08, w3=0.05 (uniforme [-0.1, 0.1]).",
                                    "Calcule soma inicial z = 1.0*0.12 + 0.5*(-0.08) + (-0.2)*0.05 + b=0 = 0.066.",
                                    "Implemente em código Python simples usando numpy.random.uniform.",
                                    "Repita 3 vezes para observar variabilidade."
                                  ],
                                  "verification": "Cálculo de z correto e código executado com pesos na faixa esperada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy, Jupyter Notebook",
                                  "tips": "Use seed para reproducibilidade: np.random.seed(42).",
                                  "learningObjective": "Executar inicialização prática e calcular saída inicial.",
                                  "commonMistakes": "Usar random.uniform sem limites pequenos ou escalar incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar escolhas e avaliar estabilidade numérica",
                                  "subSteps": [
                                    "Justifique: pesos pequenos evitam saturação em sigmoide/tanh e gradientes explosivos.",
                                    "Simule estabilidade: compare soma com pesos grandes (ex: w=10) vs pequenos.",
                                    "Discuta impacto em treinamento: gradientes proporcionais inicialmente.",
                                    "Relacione com engenharia civil: estabilidade em predições de falhas estruturais.",
                                    "Documente lições aprendidas em parágrafo."
                                  ],
                                  "verification": "Justificativa escrita com simulação comparativa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código Python do step anterior, calculadora",
                                  "tips": "Teste ativações como sigmoid(z) para visualizar diferenças.",
                                  "learningObjective": "Relacionar inicialização com estabilidade numérica e aplicações reais.",
                                  "commonMistakes": "Ignorar escala das entradas ao escolher limites de inicialização."
                                }
                              ],
                              "practicalExample": "Em um modelo para prever deformação em vigas de concreto, neurônio com entradas x1=1.2 (carga), x2=0.8 (temperatura), x3=-0.5 (umidade relativa). Inicialize pesos w1=0.07, w2=-0.03, w3=0.11 (uniforme [-0.1,0.1]), viés=0. Soma z ≈ 0.12, evitando ativação saturada desde o início.",
                              "finalVerifications": [
                                "Pesos gerados estão na faixa [-0.1, 0.1] para todas as entradas.",
                                "Cálculo da soma ponderada inicial é preciso até 3 casas decimais.",
                                "Justificativa inclui menção a quebra de simetria e estabilidade numérica.",
                                "Simulação comparativa com pesos inadequados mostra diferenças claras.",
                                "Código Python reproduzível gera os mesmos valores iniciais.",
                                "Conexão com contexto de engenharia civil explicitada."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da soma ponderada (100% correto).",
                                "Qualidade da justificativa (cobre simetria e estabilidade, 3+ pontos).",
                                "Diversidade nos pesos gerados (não todos iguais ou zero).",
                                "Uso correto de método aleatório com limites apropriados.",
                                "Clareza no diagrama e documentação (legível e completo).",
                                "Aplicação contextualizada em engenharia (relevante e criativa)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Distribuições uniformes e estabilidade numérica em somas ponderadas.",
                                "Programação: Geração de números aleatórios com NumPy e reproducibilidade.",
                                "Estatística: Quebra de simetria em modelos de machine learning.",
                                "Engenharia de Software: Boas práticas em inicialização de hiperparâmetros."
                              ],
                              "realWorldApplication": "Na engenharia civil, inicializar pesos adequadamente em redes neurais permite treinamento eficiente para prever falhas em estruturas, como deformações em pontes sob cargas variáveis, reduzindo tempo de convergência e melhorando precisão em simulações computacionais de problemas reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Soma Ponderada e Termo de Bias",
                        "description": "Calcular a soma ponderada das entradas multiplicadas pelos pesos, adicionando o termo de bias (b), resultando no potencial de ativação net = ∑(w_i * x_i) + b.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Calcular a soma ponderada",
                            "description": "Dadas entradas específicas, pesos e bias, computar manualmente e via fórmula o valor de net, aplicando a problemas como previsão de cargas em estruturas civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes da soma ponderada",
                                  "subSteps": [
                                    "Identifique as entradas (x_i) como variáveis de entrada, como cargas ou forças em estruturas civis.",
                                    "Defina os pesos (w_i) como coeficientes que indicam a importância relativa de cada entrada.",
                                    "Explique o bias (b) como um termo de ajuste constante para melhorar a precisão da previsão.",
                                    "Memorize a fórmula básica: net = Σ(x_i * w_i) + b.",
                                    "Esboce um diagrama simples de um neurônio artificial destacando soma ponderada."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito cada componente e a fórmula completa sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de neurônio artificial impresso ou digital"
                                  ],
                                  "tips": "Use analogias como 'pesos são como alavancas em estruturas, ajustando o impacto das cargas'.",
                                  "learningObjective": "Entender conceitualmente entradas, pesos, bias e a fórmula net.",
                                  "commonMistakes": [
                                    "Confundir pesos com entradas",
                                    "Esquecer o papel do bias",
                                    "Ignorar a notação de soma Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar cálculo manual passo a passo",
                                  "subSteps": [
                                    "Liste as entradas, pesos e bias fornecidos (ex: x1=10, x2=5, w1=0.8, w2=0.2, b=2).",
                                    "Calcule cada produto individual: x1*w1, x2*w2.",
                                    "Some os produtos: soma = x1*w1 + x2*w2.",
                                    "Adicione o bias: net = soma + b.",
                                    "Registre todos os valores intermediários em uma tabela."
                                  ],
                                  "verification": "Compare o resultado final com uma calculadora; deve coincidir em pelo menos 4 casas decimais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simples",
                                    "Folha de papel quadriculado",
                                    "Exemplo de dados numéricos"
                                  ],
                                  "tips": "Trabalhe com números pequenos primeiro para praticar precisão antes de escalar.",
                                  "learningObjective": "Executar multiplicações, somas e adição manualmente com exatidão.",
                                  "commonMistakes": [
                                    "Erro aritmético em multiplicações",
                                    "Ordem errada na soma",
                                    "Esquecer de adicionar bias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a notação de soma e fórmula compacta",
                                  "subSteps": [
                                    "Escreva a fórmula usando Σ: net = Σ_{i=1 to n} (x_i * w_i) + b.",
                                    "Expanda a soma para 3-4 entradas e calcule.",
                                    "Compare o cálculo expandido com o manual para validar.",
                                    "Pratique com vetores: represente x e w como vetores e use produto escalar.",
                                    "Simplifique expressões algébricas para casos simbólicos."
                                  ],
                                  "verification": "Resolva um problema com 4 entradas e confirme que net é idêntico ao método manual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software de anotações como Notion ou papel"
                                  ],
                                  "tips": "Visualize Σ como uma 'máquina somadora' para entradas ponderadas.",
                                  "learningObjective": "Dominar a notação matemática formal e simplificações.",
                                  "commonMistakes": [
                                    "Índices errados no Σ",
                                    "Confundir produto escalar com soma simples",
                                    "Ignorar limites da soma"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a previsão de cargas em estruturas civis",
                                  "subSteps": [
                                    "Selecione um problema real: entradas como carga vertical (x1), vento (x2), peso próprio (x3).",
                                    "Atribua pesos baseados em normas civis (ex: w1=0.7 para carga principal).",
                                    "Calcule net para prever tensão total em uma viga.",
                                    "Interprete o resultado: net > threshold indica risco de falha.",
                                    "Ajuste pesos e bias iterativamente para simular otimização."
                                  ],
                                  "verification": "Gere um relatório curto com cálculo, interpretação e recomendação estrutural.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Dados de exemplo de engenharia civil",
                                    "Normas ABNT ou similares (PDF)",
                                    "Calculadora"
                                  ],
                                  "tips": "Relacione pesos a fatores de segurança em projetos reais.",
                                  "learningObjective": "Integrar soma ponderada a contextos práticos de engenharia.",
                                  "commonMistakes": [
                                    "Unidades inconsistentes (kN vs N)",
                                    "Ignorar contexto físico",
                                    "Pesos irreais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga de ponte: x1=50 kN (carga veicular), x2=20 kN (vento), x3=10 kN (peso próprio); pesos w1=0.6, w2=0.3, w3=0.1; bias b=5 kN. Calcule net = (50*0.6 + 20*0.3 + 10*0.1) + 5 = 37.0 kN para prever tensão máxima.",
                              "finalVerifications": [
                                "Calcula net corretamente para 3 conjuntos de dados diferentes.",
                                "Explica o impacto de alterar um peso em net.",
                                "Identifica e corrige erros em cálculos de pares.",
                                "Aplica a um cenário civil sem orientação.",
                                "Representa a fórmula em notação vetorial.",
                                "Compara resultados manuais vs fórmula compacta."
                              ],
                              "assessmentCriteria": [
                                "Precisão aritmética: 100% nos cálculos intermediários e finais.",
                                "Compreensão conceitual: Define corretamente todos os componentes.",
                                "Eficiência: Usa notação Σ de forma fluida.",
                                "Aplicação contextual: Relaciona a engenharia civil adequadamente.",
                                "Criatividade: Propõe ajustes realistas em pesos/bias.",
                                "Clareza na documentação: Tabelas e passos legíveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e produto escalar.",
                                "Programação: Implementação em Python (numpy.dot).",
                                "Física: Análise de forças e momentos em estruturas.",
                                "Estatística: Otimização de pesos via gradiente descendente."
                              ],
                              "realWorldApplication": "Previsão de cargas em pontes e edifícios usando neurônios artificiais para detectar sobrecargas precocemente, otimizando manutenção e prevenindo colapsos como em casos históricos de falhas estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Incorporar o bias na soma",
                            "description": "Explicar e calcular o impacto do bias na soma ponderada, demonstrando como ele permite ao neurônio modelar desvios lineares em dados de engenharia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Soma Ponderada sem Bias",
                                  "subSteps": [
                                    "Lembre-se da fórmula da soma ponderada: z = Σ (w_i * x_i), onde w_i são pesos e x_i entradas.",
                                    "Calcule um exemplo simples com 2 entradas: x1=2, x2=3, w1=0.5, w2=0.4.",
                                    "Discuta limitações: passa sempre por origem (0,0), não modela desvios lineares.",
                                    "Desenhe gráfico manual de linha reta passando pela origem.",
                                    "Compare com dados reais de engenharia que não passam pela origem."
                                  ],
                                  "verification": "Confirme se z=2.1 calculado corretamente e identifique limitação da origem.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel, lápis, calculadora",
                                  "tips": "Use entradas positivas primeiro para simplicidade.",
                                  "learningObjective": "Compreender a soma ponderada básica e suas restrições.",
                                  "commonMistakes": "Esquecer de multiplicar pesos por entradas; ignorar limitação da origem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Bias",
                                  "subSteps": [
                                    "Defina bias (b) como termo constante que desloca a função linear.",
                                    "Explique intuitivamente: permite intercepto não-zero na reta y = mx + b.",
                                    "Discuta necessidade em dados de engenharia: e.g., deformação basal em vigas não zero.",
                                    "Compare equações: sem bias z=0 quando x=0; com bias z=b quando x=0.",
                                    "Esboce gráficos com e sem bias para visualizar deslocamento."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito como bias modela desvios.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, calculadora, software de gráficos como Desmos",
                                  "tips": "Pense no bias como 'compensação fixa' para imperfeições nos dados.",
                                  "learningObjective": "Entender o papel do bias em modelar offsets lineares.",
                                  "commonMistakes": "Confundir bias com peso; achar que bias é sempre positivo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar o Bias na Fórmula da Soma",
                                  "subSteps": [
                                    "Escreva nova fórmula: z = Σ (w_i * x_i) + b.",
                                    "Atribua valores: use exemplo anterior + b=1.5, recalcule z=2.1 + 1.5=3.6.",
                                    "Varie entradas para x1=x2=0, verifique z=b.",
                                    "Implemente em pseudocódigo ou Python simples.",
                                    "Calcule impacto percentual: (z_com_bias - z_sem_bias)/z_sem_bias."
                                  ],
                                  "verification": "Mostre cálculos corretos para 3 cenários diferentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora, editor de código (Python/Jupyter), exemplos de dados",
                                  "tips": "Sempre isole o termo bias isoladamente para checar.",
                                  "learningObjective": "Dominar a integração matemática do bias na soma ponderada.",
                                  "commonMistakes": "Adicionar bias dentro da soma em vez de fora; erros aritméticos em somas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Impacto em Dados de Engenharia",
                                  "subSteps": [
                                    "Use dados civis: prever carga (y) vs. deformação (x) em viga; adicione ruído.",
                                    "Ajuste pesos e bias manualmente para fit: e.g., w=2.5, b=0.8 para dados [ (1,3.3), (2,5.8) ].",
                                    "Calcule erros MSE com/sem bias.",
                                    "Plote resultados e analise como bias corrige desvio linear.",
                                    "Discuta generalização para neurônios em ANN."
                                  ],
                                  "verification": "Produza gráfico e tabela mostrando redução de erro com bias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python (NumPy/Matplotlib), dados de exemplo em CSV",
                                  "tips": "Comece com 2-3 pontos de dados para evitar complexidade.",
                                  "learningObjective": "Aplicar bias para modelar desvios reais em engenharia civil.",
                                  "commonMistakes": "Overfitting manual; ignorar escala das entradas."
                                }
                              ],
                              "practicalExample": "Em análise de vigas: entradas x=[deformação medida em mm], pesos w=[sensibilidade material], sem bias prevê carga=0 para deformação=0 (irreal); com b=5kN corrige para carga basal residual, calculando z = 2.5*x + 5, prevendo 7.5kN para x=1mm.",
                              "finalVerifications": [
                                "Explica corretamente a fórmula z = Σ(w_i x_i) + b.",
                                "Calcula z com bias para entradas zero retornando b.",
                                "Identifica redução de erro em dados deslocados.",
                                "Desenha gráfico mostrando deslocamento vertical pelo bias.",
                                "Implementa código simples que inclui bias na soma.",
                                "Discute limitação sem bias em contextos de engenharia."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (erro <5%).",
                                "Clareza na explicação do impacto do bias.",
                                "Uso correto de exemplos de engenharia civil.",
                                "Qualidade dos gráficos e visualizações.",
                                "Identificação de erros comuns e correções.",
                                "Generalização para neurônios artificiais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e equações lineares.",
                                "Estatística: Regressão linear com intercepto.",
                                "Programação: Implementação numérica em Python/NumPy.",
                                "Física: Modelagem de desvios em estruturas civis."
                              ],
                              "realWorldApplication": "Em simulações de estruturas civis com ANN, o bias corrige offsets em previsões de deformações sob carga, permitindo modelos precisos para pontes/vigas onde há tensão residual basal, otimizando designs seguros e econômicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Implementar soma ponderada em pseudocódigo",
                            "description": "Escrever pseudocódigo para calcular net em um loop sobre entradas e pesos, preparando para implementação em linguagens como MATLAB ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e declarar variáveis de entrada",
                                  "subSteps": [
                                    "Identifique as entradas (x1, x2, ..., xn) como um array ou lista.",
                                    "Defina os pesos correspondentes (w1, w2, ..., wn) em um array similar.",
                                    "Declare o termo de bias (b) como uma variável escalar.",
                                    "Especifique o número de entradas (n) para o loop.",
                                    "Inicialize uma variável soma_net como zero."
                                  ],
                                  "verification": "Verifique se todas as variáveis estão declaradas corretamente com tipos apropriados em pseudocódigo (ex: array para x e w, real para b e soma_net).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou papel para pseudocódigo",
                                    "Exemplo de dados: x = [1.0, 2.0, 3.0], w = [0.5, 0.3, 0.2], b = 0.1"
                                  ],
                                  "tips": "Use nomes descritivos como 'entradas', 'pesos', 'bias' para clareza.",
                                  "learningObjective": "Compreender e declarar as componentes matemáticas da soma ponderada.",
                                  "commonMistakes": [
                                    "Confundir entradas com pesos",
                                    "Esquecer de declarar o número n",
                                    "Não inicializar soma_net como zero"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a soma ponderada",
                                  "subSteps": [
                                    "Defina soma_net = 0 no início do algoritmo.",
                                    "Confirme que n = tamanho do array de entradas.",
                                    "Adicione um comentário explicando o propósito da inicialização.",
                                    "Verifique compatibilidade de tamanhos entre entradas e pesos.",
                                    "Prepare a estrutura para o loop."
                                  ],
                                  "verification": "Confirme que soma_net é zero antes do loop e n está definido corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Pseudocódigo do Step 1",
                                    "Calculadora para validar tamanhos"
                                  ],
                                  "tips": "Sempre inicialize acumuladores em zero para evitar resultados incorretos.",
                                  "learningObjective": "Garantir inicialização correta para acumulação precisa.",
                                  "commonMistakes": [
                                    "Inicializar soma_net com valor diferente de zero",
                                    "Não verificar se arrays têm mesmo comprimento",
                                    "Usar índice errado para n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop de soma ponderada",
                                  "subSteps": [
                                    "Inicie um loop FOR de i = 1 até n.",
                                    "Dentro do loop, calcule produto = entradas[i] * pesos[i].",
                                    "Acumule soma_net = soma_net + produto.",
                                    "Adicione tratamento para índices baseados em 1 ou 0 (especifique no pseudocódigo).",
                                    "Inclua um comentário no loop explicando a ponderação."
                                  ],
                                  "verification": "Execute manualmente o loop com exemplo pequeno e confira soma intermediária.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplo numérico: x=[1,2], w=[0.5,0.3]",
                                    "Papel para simulação manual"
                                  ],
                                  "tips": "Use pseudocódigo indentado para clareza visual do loop.",
                                  "learningObjective": "Dominar iteração e multiplicação acumulada em pseudocódigo.",
                                  "commonMistakes": [
                                    "Índices off-by-one (ex: i=0 a n-1 vs 1 a n)",
                                    "Esquecer de acumular na soma",
                                    "Multiplicar arrays errados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar o termo de bias e finalizar net",
                                  "subSteps": [
                                    "Após o loop, calcule net = soma_net + bias.",
                                    "Declare net como variável de saída.",
                                    "Adicione um comando de saída ou retorno de net.",
                                    "Inclua comentários finais sobre o resultado.",
                                    "Teste com valores completos."
                                  ],
                                  "verification": "Calcule net manualmente e compare com o pseudocódigo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Pseudocódigo completo até aqui",
                                    "Calculadora"
                                  ],
                                  "tips": "Bias é adicionado após a soma para simular o neurônio artificial.",
                                  "learningObjective": "Completar o modelo matemático do neurônio com bias.",
                                  "commonMistakes": [
                                    "Adicionar bias dentro do loop",
                                    "Esquecer o sinal de soma",
                                    "Não nomear a saída como 'net'"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar o pseudocódigo",
                                  "subSteps": [
                                    "Revise o código por erros de sintaxe em pseudocódigo.",
                                    "Simule execução com pelo menos dois conjuntos de dados.",
                                    "Adicione blocos de erro (ex: se tamanhos diferem, pare).",
                                    "Formate com indentação consistente.",
                                    "Documente premissas (ex: arrays 1-indexed)."
                                  ],
                                  "verification": "Pseudocódigo roda sem erros em simulação manual e produz net correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Dois exemplos de teste",
                                    "Ferramenta de pseudocódigo online opcional"
                                  ],
                                  "tips": "Teste edge cases como n=1 ou n=0.",
                                  "learningObjective": "Garantir robustez e legibilidade do pseudocódigo.",
                                  "commonMistakes": [
                                    "Falta de indentação",
                                    "Ignorar casos edge",
                                    "Comentários insuficientes"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado entradas = [1.0, 2.0, 3.0], pesos = [0.5, 0.3, 0.2], bias = 0.1:\nINICIALIZE soma_net = 0\nPARA i = 1 ATÉ 3:\n  produto = entradas[i] * pesos[i]\n  soma_net = soma_net + produto\nnet = soma_net + bias\n// Resultado: net = (1*0.5 + 2*0.3 + 3*0.2) + 0.1 = 1.7",
                              "finalVerifications": [
                                "Pseudocódigo declara corretamente entradas, pesos, bias e net.",
                                "Loop itera exatamente n vezes com multiplicação e acumulação.",
                                "Bias é adicionado após o loop.",
                                "Simulação manual com exemplo produz net correto (ex: 1.7).",
                                "Código é legível com comentários e indentação.",
                                "Edge case n=1 calculado corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: soma ponderada + bias correta.",
                                "Estrutura do loop: FOR correto com índices apropriados.",
                                "Declaração de variáveis: todas presentes e inicializadas.",
                                "Legibilidade: indentação, comentários e nomes claros.",
                                "Robustez: menção a verificação de tamanhos.",
                                "Testabilidade: inclui simulação ou saída verificável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (vetores e produto escalar).",
                                "Programação: Estruturas de loop e arrays em linguagens como Python/MATLAB.",
                                "Engenharia Civil: Modelagem preditiva em análise estrutural via redes neurais.",
                                "Física: Cálculo de forças ponderadas em estruturas."
                              ],
                              "realWorldApplication": "Em engenharia civil, essa soma ponderada é o núcleo de um neurônio artificial para prever deformações em vigas sob cargas variáveis, processando entradas como tensões e pesos como coeficientes aprendidos, permitindo simulações precisas de falhas estruturais em pontes ou edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Funções de Ativação Comuns",
                        "description": "Aplicar funções de ativação à soma ponderada para gerar a saída do neurônio, focando em sigmoide (σ(net) = 1/(1 + e^{-net})) e ReLU (max(0, net)), e suas propriedades em modelagem não-linear.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Definir e calcular função sigmoide",
                            "description": "Calcular o valor da sigmoide para diferentes valores de net, plotar sua curva em forma de S e discutir sua suavidade e interpretação probabilística em contextos civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função sigmoide e sua fórmula matemática",
                                  "subSteps": [
                                    "Estude a definição: a função sigmoide, também conhecida como logística, mapeia qualquer valor real para o intervalo (0,1).",
                                    "Memorize a fórmula: σ(net) = 1 / (1 + e^(-net)), onde 'net' é a soma ponderada das entradas.",
                                    "Entenda os limites: quando net → ∞, σ(net) → 1; quando net → -∞, σ(net) → 0.",
                                    "Discuta a suavidade: derivada contínua, ideal para gradientes em aprendizado de máquina.",
                                    "Relacione com interpretação probabilística: saída como probabilidade de 'ativação'."
                                  ],
                                  "verification": "Recite a fórmula corretamente e explique os limites assintóticos em voz alta ou por escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica",
                                    "Referência online sobre funções de ativação"
                                  ],
                                  "tips": "Visualize a curva S mentalmente: simétrica em torno de net=0, onde σ(0)=0.5.",
                                  "learningObjective": "Compreender a definição matemática e propriedades fundamentais da sigmoide.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo no expoente",
                                    "Confundir com função tangente hiperbólica (tanh)",
                                    "Ignorar os limites assintóticos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular valores da sigmoide para diferentes entradas 'net'",
                                  "subSteps": [
                                    "Selecione valores de net: -5, -2, 0, 2, 5.",
                                    "Calcule manualmente: use aproximações para e^x (e^2≈7.39, e^5≈148.41).",
                                    "Verifique com calculadora: compare resultados exatos (ex: σ(-5)≈0.0067, σ(0)=0.5, σ(5)≈0.9933).",
                                    "Registre em tabela: net | σ(net) | Interpretação probabilística.",
                                    "Analise padrões: valores negativos → baixa probabilidade; positivos → alta."
                                  ],
                                  "verification": "Crie uma tabela com 5 cálculos precisos (erro <0.01) e interprete um como probabilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha Excel ou papel quadriculado",
                                    "Tabela de valores de e^x"
                                  ],
                                  "tips": "Para net grande negativo, σ(net)≈0; use 1/(1+grande número) para simplificar.",
                                  "learningObjective": "Dominar o cálculo numérico da sigmoide e sua interpretação probabilística.",
                                  "commonMistakes": [
                                    "Erro aritmético no expoente",
                                    "Arredondar prematuramente",
                                    "Não inverter corretamente 1/(1+e^-net)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar a curva sigmoide em forma de S",
                                  "subSteps": [
                                    "Prepare eixos: x de -10 a 10 (net), y de 0 a 1 (σ(net)).",
                                    "Calcule 10-15 pontos: use os de Step 2 e adicione mais (ex: -10, -1, 1, 10).",
                                    "Plote pontos e conecte com curva suave: destaque simetria em (0,0.5).",
                                    "Use ferramenta digital: Python (matplotlib), Excel ou GeoGebra para gráfico preciso.",
                                    "Rotule: eixos, título 'Função Sigmoide σ(net)' e assíntotas y=0 e y=1."
                                  ],
                                  "verification": "Produza um gráfico com pelo menos 10 pontos plotados corretamente e curva suave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (Python/Matlab/Excel)",
                                    "Papel milimetrado para rascunho"
                                  ],
                                  "tips": "Gere pontos equidistantes para suavidade; zoom em torno de net=0 para ver transição.",
                                  "learningObjective": "Visualizar graficamente a forma sigmoide e suas características.",
                                  "commonMistakes": [
                                    "Escala errada nos eixos",
                                    "Pontos incorretos de cálculo",
                                    "Curva não suave ou assimétrica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir suavidade, interpretação e aplicações em contextos civis",
                                  "subSteps": [
                                    "Explique suavidade: função diferenciável em todo R, derivada σ'(net)=σ(net)(1-σ(net)).",
                                    "Interpretação probabilística: saída como P(ativação|net), útil em classificação binária.",
                                    "Aplique em Engenharia Civil: prever probabilidade de falha em estruturas via ANN.",
                                    "Compare com step function: sigmoide é suave, evita gradientes nulos.",
                                    "Debata limitações: vanishing gradient para nets extremos."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo suavidade, interpretação e uma aplicação civil.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigos sobre ANN em Engenharia Civil",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Pense em exemplos reais: sensores em pontes → net → σ(net)=risco de colapso.",
                                  "learningObjective": "Analisar propriedades avançadas e contextualizar em problemas civis.",
                                  "commonMistakes": [
                                    "Ignorar derivada ou vanishing gradient",
                                    "Não ligar a contextos probabilísticos",
                                    "Focar só em ML genérico, ignorar civil"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma ANN para monitoramento de pontes, net=3.5 (de sensores de tensão) resulta em σ(3.5)≈0.97, interpretado como 97% de probabilidade de falha iminente, acionando alerta preventivo.",
                              "finalVerifications": [
                                "Definir corretamente a fórmula σ(net)=1/(1+e^(-net)).",
                                "Calcular σ(net) para 5 valores variados com precisão >99%.",
                                "Plotar e descrever a curva S com assíntotas e ponto de inflexão.",
                                "Explicar suavidade via diferenciabilidade e interpretação como probabilidade.",
                                "Dar exemplo de aplicação em previsão de riscos estruturais civis.",
                                "Identificar pelo menos 2 limitações (ex: vanishing gradient)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos e fórmula (peso 25%).",
                                "Qualidade do gráfico: pontos corretos, suavidade e legendas (peso 20%).",
                                "Profundidade na análise de propriedades (suavidade, probabilística) (peso 20%).",
                                "Relevância de exemplos e conexões com Engenharia Civil (peso 15%).",
                                "Clareza na verificação e discussão de erros comuns (peso 10%).",
                                "Completude de todos os passos e subpassos (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções logísticas e análise de limites/derivadas.",
                                "Programação: Implementação em Python (NumPy/Matplotlib) para cálculo e plotagem.",
                                "Estatística: Interpretação probabilística e modelagem preditiva.",
                                "Física/Engenharia: Modelagem de transições suaves em sistemas dinâmicos civis.",
                                "Computação Científica: Otimização em ANN para simulações estruturais."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, a sigmoide é usada em redes neurais para prever probabilidades de falha em barragens ou edifícios a partir de dados de sensores (vibração, umidade), permitindo manutenção preditiva e redução de riscos catastróficos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Aplicar função ReLU",
                            "description": "Computar a saída ReLU para uma soma ponderada, analisar vantagens como evitar vanishing gradient e relacionar com eficiência computacional em simulações estruturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e o comportamento da função ReLU",
                                  "subSteps": [
                                    "Estude a fórmula matemática: ReLU(z) = max(0, z), onde z é a soma ponderada.",
                                    "Analise o gráfico da função: linear para z > 0 e zero para z ≤ 0.",
                                    "Compare com funções como sigmoid e tanh, destacando a não saturação para valores positivos.",
                                    "Identifique o 'dying ReLU' como problema potencial quando neurônios ficam inativos.",
                                    "Desenhe exemplos gráficos de entrada e saída."
                                  ],
                                  "verification": "Desenhar corretamente o gráfico da ReLU e explicar verbalmente sua definição.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráfico impresso de funções de ativação",
                                    "Calculadora"
                                  ],
                                  "tips": "Visualize a ReLU como um 'interruptor' que ativa apenas sinais positivos.",
                                  "learningObjective": "Entender conceitualmente a ReLU e seu papel em introduzir não-linearidade.",
                                  "commonMistakes": [
                                    "Confundir ReLU com step function (ReLU é zero, não -1 para negativos)",
                                    "Ignorar o problema de dying ReLU"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar a saída ReLU para uma soma ponderada",
                                  "subSteps": [
                                    "Calcule a soma ponderada z = Σ(wi * xi) + b para um vetor de entrada exemplo.",
                                    "Aplique ReLU(z): se z > 0, saída = z; senão, saída = 0.",
                                    "Repita para múltiplos exemplos: z = -2.5 → 0; z = 1.3 → 1.3; z = 0 → 0.",
                                    "Registre entradas, z e saídas em uma tabela.",
                                    "Verifique derivada: 1 se z > 0, 0 caso contrário."
                                  ],
                                  "verification": "Resolver 5 exercícios manuais com acurácia 100%, mostrando cálculos passo a passo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel quadriculado",
                                    "Exemplos de pesos e biases impressos"
                                  ],
                                  "tips": "Use uma tabela para organizar entradas, pesos, z e ReLU(z).",
                                  "learningObjective": "Calcular com precisão a ativação ReLU em um neurônio artificial.",
                                  "commonMistakes": [
                                    "Erro aritmético na soma ponderada",
                                    "Aplicar ReLU antes de somar pesos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar as vantagens da ReLU em redes neurais",
                                  "subSteps": [
                                    "Explique como ReLU evita vanishing gradient: derivada não diminui exponencialmente.",
                                    "Discuta eficiência computacional: operação simples (max) sem exponenciais caros.",
                                    "Compare gradientes: ReLU mantém gradiente 1 para positivos vs. sigmoid saturando.",
                                    "Simule backpropagation manualmente para um exemplo com ReLU vs. sigmoid.",
                                    "Liste 3 vantagens adicionais: sparsity, convergência mais rápida."
                                  ],
                                  "verification": "Escrever um parágrafo explicando 3 vantagens com exemplos numéricos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Vídeo curto sobre vanishing gradient (YouTube)",
                                    "Folha com fórmulas de derivadas"
                                  ],
                                  "tips": "Pense em gradientes como 'fluxo de aprendizado': ReLU mantém o fluxo forte.",
                                  "learningObjective": "Identificar e justificar vantagens da ReLU sobre outras ativações.",
                                  "commonMistakes": [
                                    "Confundir vanishing com exploding gradient",
                                    "Subestimar impacto computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar ReLU com eficiência em simulações estruturais",
                                  "subSteps": [
                                    "Descreva uso de NN com ReLU em previsão de tensões em vigas ou edifícios.",
                                    "Calcule tempo de computação: ReLU vs. sigmoid em 1000 neurônios.",
                                    "Simule um caso: NN para detectar falhas em estruturas civis.",
                                    "Avalie impacto: ReLU acelera treinamentos em simulações FEM (Finite Element Method).",
                                    "Discuta escalabilidade para grandes modelos de engenharia."
                                  ],
                                  "verification": "Criar um diagrama de aplicação em simulação estrutural com ReLU destacada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software Python simples (NumPy) ou simulador online",
                                    "Artigo sobre NN em engenharia civil"
                                  ],
                                  "tips": "Considere ReLU como otimizador para simulações em tempo real de desastres.",
                                  "learningObjective": "Aplicar conceitos de ReLU a contextos reais de engenharia civil.",
                                  "commonMistakes": [
                                    "Ignorar contexto computacional em hardware limitado",
                                    "Generalizar sem exemplo específico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de deformação de viga cantilever: pesos wi=[0.4, 0.6], entradas xi=[-1, 3], bias b=0.2 → z=0.4*(-1)+0.6*3+0.2=2 → ReLU(2)=2 (ativa previsão de tensão alta).",
                              "finalVerifications": [
                                "Computar ReLU corretamente para 10 somas ponderadas variadas.",
                                "Explicar verbalmente como ReLU evita vanishing gradient com exemplo.",
                                "Implementar ReLU em código Python simples e testar.",
                                "Relacionar ReLU a uma simulação estrutural real.",
                                "Identificar dying ReLU em um cenário e propor solução (Leaky ReLU).",
                                "Comparar eficiência ReLU vs. sigmoid em tabela."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos cálculos de ReLU.",
                                "Explicação clara e completa das vantagens (mínimo 3).",
                                "Uso correto de terminologia técnica (z, soma ponderada, gradiente).",
                                "Aplicação contextualizada à engenharia civil.",
                                "Criatividade no exemplo prático e verificações.",
                                "Tempo respeitado e materiais utilizados adequadamente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções piecewise e derivadas.",
                                "Programação: Implementação em Python/NumPy para ML.",
                                "Física: Modelagem de tensões e deformações em estruturas.",
                                "Computação: Otimização de algoritmos em simulações FEM.",
                                "Estatística: Gradientes em aprendizado de máquina."
                              ],
                              "realWorldApplication": "Em softwares como ANSYS ou SAP2000 integrados com NN, ReLU acelera simulações de estabilidade sísmica em edifícios altos, reduzindo tempo de treinamento de dias para horas e permitindo análises em tempo real durante projetos de infraestrutura."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Comparar sigmoide e ReLU em exemplos",
                            "description": "Comparar saídas de sigmoide e ReLU para os mesmos nets, identificando cenários de uso em problemas de engenharia civil como regressão vs. classificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as definições e fórmulas das funções sigmoide e ReLU",
                                  "subSteps": [
                                    "Estude a fórmula da sigmoide: σ(x) = 1 / (1 + e^(-x))",
                                    "Estude a fórmula da ReLU: f(x) = max(0, x)",
                                    "Plote graficamente ambas as funções usando ferramentas como Desmos ou Python (Matplotlib)",
                                    "Identifique características chave: sigmoide é suave e bounded [0,1]; ReLU é piecewise linear e não bounded",
                                    "Compare gradientes: vanishing gradient na sigmoide para valores extremos"
                                  ],
                                  "verification": "Crie gráficos manuais ou digitais das duas funções e anote 3 diferenças principais",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Calculadora científica",
                                    "Ferramenta de plotagem (Desmos, Matplotlib)",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Comece com valores de x de -10 a 10 para visualizar comportamentos assimétricos",
                                  "learningObjective": "Compreender matematicamente as funções de ativação sigmoide e ReLU",
                                  "commonMistakes": [
                                    "Confundir sigmoide com tanh",
                                    "Ignorar o problema de vanishing gradient na sigmoide"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e comparar saídas para entradas comuns",
                                  "subSteps": [
                                    "Selecione entradas de teste: x = [-2, -1, 0, 1, 2]",
                                    "Calcule saídas manualmente para sigmoide e ReLU",
                                    "Registre em uma tabela: entrada, saída sigmoide, saída ReLU, diferença relativa",
                                    "Analise padrões: ReLU zera negativos; sigmoide comprime tudo em (0,1)",
                                    "Repita com entradas grandes (|x| > 5) para observar saturação na sigmoide"
                                  ],
                                  "verification": "Tabela completa com cálculos corretos e análise de 2 padrões observados",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Calculadora"
                                  ],
                                  "tips": "Use aproximações para e^(-x) se sem calculadora: e^-1 ≈ 0.367, e^-2 ≈ 0.135",
                                  "learningObjective": "Calcular e contrastar saídas numéricas das funções",
                                  "commonMistakes": [
                                    "Erros aritméticos em exponenciais",
                                    "Esquecer de normalizar diferenças"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular saídas em uma rede neural simples com ambas as ativações",
                                  "subSteps": [
                                    "Defina uma rede de 1 neurônio: entrada única, peso=1, bias=0",
                                    "Implemente em Python (NumPy) ou ferramenta online como TensorFlow Playground",
                                    "Teste com as mesmas entradas do Step 2, comparando ativações na camada oculta e saída",
                                    "Expanda para 2 neurônios em paralelo, somando saídas ponderadas",
                                    "Registre gradientes aproximados (derivadas: sigmoide σ(1-σ), ReLU=1 se x>0)"
                                  ],
                                  "verification": "Código ou simulação rodando com tabelas de comparação de saídas e gradientes",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "TensorFlow Playground online",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use funções prontas: np.sigmoid() e np.maximum(0,x)",
                                  "learningObjective": "Observar impactos das ativações em uma rede neural básica",
                                  "commonMistakes": [
                                    "Não fixar pesos/bias iguais nas simulações",
                                    "Ignorar gradientes na comparação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar cenários de uso em problemas de engenharia civil",
                                  "subSteps": [
                                    "Regressão: prever deformação em vigas (saídas contínuas >1) → prefira ReLU (não satura)",
                                    "Classificação: detectar falha estrutural (saídas probabilísticas 0-1) → sigmoide adequada",
                                    "Simule dataset fictício: cargas em ponte (regressão) vs tipos de rachadura (classificação)",
                                    "Compare performance hipotética: ReLU mais rápida em regressão; sigmoide interpretável em probs",
                                    "Documente prós/contras: ReLU (simples, dying neurons); sigmoide (suave, vanishing gradient)"
                                  ],
                                  "verification": "Relatório com 2 exemplos civis, recomendação de ativação por tarefa e justificativa",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Datasets exemplo (Kaggle: structural engineering)",
                                    "Papel para diagramas de redes"
                                  ],
                                  "tips": "Ligue a regressão com problemas lineares em estruturas; classificação com detecção binária",
                                  "learningObjective": "Aplicar comparação a contextos reais de engenharia civil",
                                  "commonMistakes": [
                                    "Recomendar sigmoide para regressão sem bounded outputs",
                                    "Ignorar contexto civil"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede para prever a deformação máxima (mm) de uma viga sob carga (regressão): use ReLU para outputs >1 sem saturação. Para classificar se uma ponte tem risco de colapso (probabilidade 0-1): use sigmoide na saída. Simule inputs de cargas [10kN, 50kN, 100kN]; ReLU dá [0,50,100], sigmoide satura em ~1.",
                              "finalVerifications": [
                                "Explicar verbalmente diferenças em saídas para x=-2 e x=5",
                                "Mostrar tabela de comparação em rede simples com código funcional",
                                "Recomendar ativação para regressão de tensões vs classificação de materiais",
                                "Identificar 2 problemas (vanishing gradient, dying ReLU) e soluções",
                                "Aplicar a um problema civil: escolha correta com justificativa",
                                "Plotar ambas funções com anotações de cenários de uso"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos e simulações (90%+ correção)",
                                "Profundidade na comparação de saídas e gradientes",
                                "Relevância das aplicações à engenharia civil (regressão/classificação)",
                                "Clareza em tabelas, gráficos e relatórios",
                                "Identificação correta de prós/contras e cenários ideais",
                                "Criatividade em exemplos práticos e conexões reais"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções não-lineares e derivadas",
                                "Programação: Implementação numérica em Python/NumPy",
                                "Estatística: Interpretação de probabilidades em sigmoide",
                                "Engenharia de Materiais: Modelagem de falhas estruturais",
                                "Física: Comportamento de materiais sob cargas (regressão)"
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, como monitoramento de pontes via IoT: ReLU em modelos de previsão de deformações para alertas precoces (regressão); sigmoide em classificadores de integridade (binário: segura/insegura), otimizando inspeções e reduzindo custos de manutenção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.1",
                              "10.1.6.2.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.4",
                            "name": "Implementar ativação completa do neurônio",
                            "description": "Combinar soma ponderada com ativação em pseudocódigo, gerando a saída final y = f(net), e testar com dados numéricos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular a soma ponderada (net input)",
                                  "subSteps": [
                                    "Identifique os pesos (w), entradas (x) e bias (b) do neurônio.",
                                    "Aplique a fórmula net = Σ(w_i * x_i) + b para múltiplas entradas.",
                                    "Use um exemplo simples com 2 entradas: x1=1, x2=2, w1=0.5, w2=0.3, b=0.1.",
                                    "Calcule manualmente: net = (0.5*1) + (0.3*2) + 0.1 = 1.2.",
                                    "Registre o valor de net para o próximo passo."
                                  ],
                                  "verification": "Confirme que net foi calculado corretamente comparando com cálculo manual em papel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Pseudocódigo base de neurônio"
                                  ],
                                  "tips": "Sempre liste entradas e pesos em uma tabela para evitar confusão.",
                                  "learningObjective": "Dominar o cálculo da soma ponderada como entrada para a ativação.",
                                  "commonMistakes": [
                                    "Esquecer o bias (b)",
                                    "Confundir multiplicação de pesos com entradas",
                                    "Erro aritmético em somas simples"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e definir a função de ativação",
                                  "subSteps": [
                                    "Escolha uma função comum como sigmoid: f(net) = 1 / (1 + e^(-net)).",
                                    "Explique o propósito: introduzir não-linearidade (ex: sigmoid mapeia para [0,1]).",
                                    "Escreva a fórmula em pseudocódigo: function sigmoid(net) { return 1 / (1 + exp(-net)); }.",
                                    "Compare brevemente com ReLU: f(net) = max(0, net) para entender diferenças.",
                                    "Decida usar sigmoid para este exemplo."
                                  ],
                                  "verification": "Escreva e teste a fórmula com net=0 (deve dar 0.5 para sigmoid).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação de funções de ativação (imagem ou tabela)",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Lembre-se: sigmoid é suave e probabilística; ideal para saídas binárias.",
                                  "learningObjective": "Compreender o papel e implementação de funções de ativação.",
                                  "commonMistakes": [
                                    "Usar e^x em vez de e^(-net)",
                                    "Ignorar o range de saída da função",
                                    "Confundir sigmoid com tanh"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Combinar soma ponderada com ativação em pseudocódigo",
                                  "subSteps": [
                                    "Escreva o pseudocódigo completo: y = sigmoid( sum(w_i * x_i) + b ).",
                                    "Defina variáveis: inputs = [x1, x2], weights = [w1, w2], bias = b.",
                                    "Implemente loop para soma: net = 0; for i in 0 to len(inputs)-1 { net += weights[i] * inputs[i]; } net += bias.",
                                    "Aplique ativação: y = sigmoid(net).",
                                    "Formate como função: function neuron(inputs, weights, bias) { ... return y; }."
                                  ],
                                  "verification": "Execute mentalmente com valores do Step 1; net=1.2, y ≈ 0.7685.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto simples",
                                    "Pseudocódigo template"
                                  ],
                                  "tips": "Use indentação clara para loops e funções no pseudocódigo.",
                                  "learningObjective": "Integrar soma e ativação em uma estrutura de código acionável.",
                                  "commonMistakes": [
                                    "Erro no loop de soma (off-by-one)",
                                    "Aplicar ativação antes da soma",
                                    "Falta de bias na função"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar a implementação com dados numéricos simples",
                                  "subSteps": [
                                    "Use os valores: inputs=[1,2], weights=[0.5,0.3], bias=0.1; espere y≈0.768.",
                                    "Calcule passo a passo: net=1.2, sigmoid(1.2)=1/(1+e^{-1.2})≈0.768.",
                                    "Teste variação: mude x2=0, recalcule net=0.6, y≈0.645.",
                                    "Registre resultados em tabela: Entradas | net | y.",
                                    "Valide com calculadora online se disponível."
                                  ],
                                  "verification": "Resultados numéricos coincidem com cálculos manuais em pelo menos 2 testes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou app exponencial",
                                    "Tabela de testes em papel"
                                  ],
                                  "tips": "Teste casos extremos: net=0, net grande positivo/negativo.",
                                  "learningObjective": "Validar a implementação através de testes empíricos.",
                                  "commonMistakes": [
                                    "Erro de arredondamento em exponenciais",
                                    "Não testar múltiplos cenários",
                                    "Confundir net com y final"
                                  ]
                                }
                              ],
                              "practicalExample": "Para prever se uma viga resiste a carga: inputs=[carga=1, comprimento=2], weights=[0.5,0.3] (aprendidos), bias=0.1. net=1.2, y=sigmoid(1.2)≈0.77 (77% chance de resistência).",
                              "finalVerifications": [
                                "Pseudocódigo executa sem erros lógicos.",
                                "Cálculo de net correto para 3 conjuntos de dados.",
                                "Saída y matches com fórmula sigmoid manual.",
                                "Função lida com múltiplas entradas.",
                                "Testes incluem casos edge (net=0, net negativo)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na soma e ativação (100% correto).",
                                "Clareza e completude do pseudocódigo.",
                                "Uso correto de sigmoid com valores numéricos.",
                                "Inclusão de bias em todos cálculos.",
                                "Tabela de testes com pelo menos 3 exemplos variados.",
                                "Explicação verbal da saída y."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e funções exponenciais.",
                                "Programação: Estruturas de loop e funções modulares.",
                                "Engenharia Civil: Modelagem preditiva de falhas estruturais.",
                                "Estatística: Interpretação probabilística de saídas sigmoid."
                              ],
                              "realWorldApplication": "Em engenharia civil, implementar neurônios para redes neurais que preveem deformações em pontes sob cargas variáveis, combinando dados sensoriais (entradas) com pesos treinados para saída de risco de colapso."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.3",
                              "10.1.6.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Arquiteturas de Redes Neurais",
                    "description": "Tipos principais como redes feedforward (MLP) e introdução a redes convolucionais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Redes Feedforward (MLP)",
                        "description": "As redes feedforward, também conhecidas como Multilayer Perceptron (MLP), são arquiteturas básicas de redes neurais artificiais compostas por camadas de neurônios interconectados, onde a informação flui unidirecionalmente da entrada para a saída, sem ciclos ou loops de feedback. Elas são amplamente usadas em problemas de regressão e classificação em engenharia civil, como previsão de deformações em estruturas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Identificar a estrutura básica de uma MLP",
                            "description": "Reconhecer e descrever os componentes principais de uma rede feedforward, incluindo camada de entrada, camadas ocultas, camada de saída, pesos sinápticos, biases e funções de ativação como sigmoid, ReLU ou tanh.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de um Neurônio Artificial",
                                  "subSteps": [
                                    "Estude a fórmula matemática de um neurônio: saída = f(∑(pesos * entradas) + bias), onde f é a função de ativação.",
                                    "Identifique entradas (inputs), pesos sinápticos (w), bias (b) e função de ativação (ex: sigmoid, ReLU, tanh).",
                                    "Desenhe um diagrama simples de um único neurônio com setas representando pesos.",
                                    "Compare funções de ativação: ReLU para não-linearidade positiva, sigmoid para probabilidades (0-1), tanh para valores centrados em zero.",
                                    "Explique verbalmente como um neurônio processa uma entrada simples, como prever tensão em um material."
                                  ],
                                  "verification": "Desenhar e rotular corretamente um diagrama de neurônio artificial e explicar seu funcionamento em uma frase.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Vídeo tutorial sobre neurônios artificiais (ex: YouTube - 3Blue1Brown Neural Networks)",
                                    "Notebook Jupyter com exemplo simples de neurônio em Python (NumPy)"
                                  ],
                                  "tips": "Comece com um exemplo numérico simples: entrada=2, peso=0.5, bias=1, ReLU → saída=2.",
                                  "learningObjective": "Reconhecer os componentes fundamentais de um neurônio como base para redes MLP.",
                                  "commonMistakes": "Confundir pesos com biases (pesos conectam entradas, biases são offsets independentes); ignorar que ativações introduzem não-linearidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Camada de Entrada em uma MLP",
                                  "subSteps": [
                                    "Defina a camada de entrada como o conjunto de nós que recebem os dados de feature (ex: dimensões de uma viga, carga aplicada).",
                                    "Aprenda que não há processamento na entrada: ela apenas passa features para as camadas ocultas via pesos.",
                                    "Examine um diagrama de MLP e circule a camada de entrada, contando o número de nós (igual ao número de features).",
                                    "Discuta dimensionalidade: para engenharia civil, entrada pode ter 5 features (comprimento, largura, material, carga, idade).",
                                    "Implemente uma camada de entrada em código Python simples usando arrays."
                                  ],
                                  "verification": "Rotular corretamente a camada de entrada em um diagrama fornecido e listar 3 exemplos de features em contexto civil.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama de MLP impresso ou digital (ex: de TensorFlow playground)",
                                    "Código Python: import numpy as np; input_layer = np.array([1,2,3])"
                                  ],
                                  "tips": "Lembre-se: camada de entrada é 'dumb' – só distribui dados; processamento começa depois.",
                                  "learningObjective": "Distinguir a camada de entrada como interface de dados brutos para a rede.",
                                  "commonMistakes": "Pensar que entrada aplica ativação (não aplica); confundir com camada de saída."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Camadas Ocultas e seus Componentes",
                                  "subSteps": [
                                    "Descreva camadas ocultas como intermediárias que processam dados via pesos, biases e ativações.",
                                    "Entenda forward pass: cada nó oculto computa soma ponderada + bias + ativação.",
                                    "Compare múltiplas camadas ocultas: shallow (1) vs deep (múltiplas) para complexidade crescente.",
                                    "Identifique em diagrama: setas entre camadas representam matrizes de pesos.",
                                    "Simule uma camada oculta com exemplo: 3 entradas → 4 nós ocultos com ReLU."
                                  ],
                                  "verification": "Traçar o caminho de uma entrada através de uma camada oculta em um diagrama e calcular saída manualmente para valores simples.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta interativa TensorFlow Playground",
                                    "Planilha Excel para simular multiplicação de matrizes pesos-entradas",
                                    "Código Python com Keras para visualizar camadas"
                                  ],
                                  "tips": "Visualize pesos como 'forças' ajustáveis que 'pesam' a importância das entradas.",
                                  "learningObjective": "Explicar o papel das camadas ocultas na extração de features intermediárias.",
                                  "commonMistakes": "Esquecer biases em cada nó; assumir ativação linear (MLP requer não-linear para universal approximation)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer a Camada de Saída e a Estrutura Completa da MLP",
                                  "subSteps": [
                                    "Defina camada de saída como nós finais que produzem predições (ex: 1 nó para regressão de resistência de concreto).",
                                    "Escolha ativação de saída: linear para regressão, softmax para classificação multi-classe.",
                                    "Monte a estrutura completa: entrada → ocultas (1+) → saída, com pesos/biases em todas conexões.",
                                    "Desenhe uma MLP completa com 4 entradas, 1 oculta (3 nós), 1 saída.",
                                    "Explique fluxo feedforward: unidirecional, sem loops."
                                  ],
                                  "verification": "Desenhar e rotular uma MLP completa, identificando todos componentes principais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel para desenho final",
                                    "Exemplo de código Keras: model = Sequential([Dense(3,activation='relu'), Dense(1)])",
                                    "Diagrama comparativo MLP vs outras redes"
                                  ],
                                  "tips": "Pense na MLP como uma 'cascata' de transformações lineares + não-lineares.",
                                  "learningObjective": "Integrar todos componentes em uma visão holística da estrutura MLP.",
                                  "commonMistakes": "Confundir feedforward com recurrente (MLP não tem memória/feedback); ignorar que número de camadas define profundidade."
                                }
                              ],
                              "practicalExample": "Em um projeto de engenharia civil, uma MLP prevê a resistência à compressão de concreto com 6 features de entrada (cimento, escória, cinzas, água, superplastificante, idade). Identifique: camada de entrada (6 nós), 2 camadas ocultas (10 e 5 nós com ReLU), saída (1 nó linear). Desenhe o diagrama e trace um forward pass com dados de exemplo.",
                              "finalVerifications": [
                                "Desenhar diagrama rotulado de MLP com todas camadas e componentes.",
                                "Explicar forward pass verbalmente para um exemplo simples.",
                                "Listar 3 funções de ativação e seus usos.",
                                "Identificar diferenças entre entrada, ocultas e saída em um diagrama dado.",
                                "Simular computação de um nó com valores numéricos.",
                                "Discutir por que biases e ativações são essenciais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de camadas (entrada/ocultas/saída): 25%.",
                                "Correta descrição de pesos, biases e ativações: 25%.",
                                "Capacidade de desenhar/diagrama estrutura completa: 20%.",
                                "Explicação clara do forward pass: 15%.",
                                "Exemplos contextualizados em engenharia civil: 10%.",
                                "Evitar erros comuns (ex: confundir ativações): 5%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (multiplicação matriz-vetor para pesos).",
                                "Programação: Implementação em Python/Keras para visualização.",
                                "Engenharia Civil: Aplicações em previsão de propriedades materiais e análise estrutural.",
                                "Física: Analogia com sinapses neurais e forças em estruturas."
                              ],
                              "realWorldApplication": "Em engenharia civil, MLPs modelam comportamentos complexos como previsão de deformações em pontes sob cargas variáveis, otimizando designs e prevenindo falhas com base em dados sensoriais e históricos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Realizar propagação forward em uma MLP",
                            "description": "Calcular manualmente ou via código simples o forward pass em uma MLP com poucas camadas, aplicando multiplicação matricial, soma ponderada e aplicação de funções de ativação para obter a saída da rede a partir de uma entrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a arquitetura da MLP e preparar a entrada",
                                  "subSteps": [
                                    "Defina o número de camadas, neurônios por camada e funções de ativação (ex: ReLU para ocultas, sigmoid para saída).",
                                    "Inicialize pesos (W) e biases (b) com valores simples ou aleatórios para uma rede pequena (ex: 2 entradas, 3 ocultos, 1 saída).",
                                    "Prepare um vetor de entrada x com valores numéricos concretos (ex: x = [0.5, 0.8]).",
                                    "Desenhe um diagrama da rede no papel para visualizar conexões.",
                                    "Escreva pseudocódigo ou código Python inicial com NumPy para armazenar W e b."
                                  ],
                                  "verification": "Verifique se todos os parâmetros estão dimensionados corretamente (ex: W1 shape (2,3) para 2 entradas e 3 neurônios).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Python com NumPy instalado"
                                  ],
                                  "tips": "Use valores pequenos para facilitar cálculos manuais; armazene em dicionário para código.",
                                  "learningObjective": "Compreender e preparar componentes necessários para forward pass.",
                                  "commonMistakes": [
                                    "Dimensões erradas de matrizes",
                                    "Confundir número de entradas/saídas",
                                    "Esquecer bias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a combinação linear na primeira camada (z1 = W1 * x + b1)",
                                  "subSteps": [
                                    "Realize multiplicação matricial manual: cada neurônio recebe soma ponderada das entradas.",
                                    "Adicione o bias correspondente a cada neurônio.",
                                    "Repita o cálculo para todos os neurônios da primeira camada.",
                                    "Implemente o mesmo em Python usando np.dot() ou @ para matrizes.",
                                    "Compare resultado manual com código para validar."
                                  ],
                                  "verification": "z1 deve ter tamanho igual ao número de neurônios na camada (ex: vetor de 3 elementos).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para cálculos manuais",
                                    "Python interpreter"
                                  ],
                                  "tips": "Lembre-se: multiplicação é linha-coluna; use transposta se necessário.",
                                  "learningObjective": "Dominar multiplicação matricial e adição de bias no forward pass.",
                                  "commonMistakes": [
                                    "Erro na ordem de multiplicação (Wx vs xW)",
                                    "Esquecer de somar bias",
                                    "Dividir por dimensões erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar função de ativação à primeira camada e propagar para camadas ocultas",
                                  "subSteps": [
                                    "Aplique ativação (ex: ReLU: max(0, z)) elemento a elemento em z1 para obter a1.",
                                    "Use a1 como entrada para a próxima camada: z2 = W2 * a1 + b2.",
                                    "Aplique ativação em z2 para obter a2.",
                                    "Repita para camadas adicionais se houver.",
                                    "Codifique em loop Python para generalizar."
                                  ],
                                  "verification": "Cada ativação preserva dimensões e aplica transformação não-linear corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de funções de ativação impressa",
                                    "Código Python anterior"
                                  ],
                                  "tips": "ReLU é simples: zero abaixo de zero; teste com valores negativos.",
                                  "learningObjective": "Entender introdução de não-linearidade via ativações em forward pass.",
                                  "commonMistakes": [
                                    "Aplicar ativação antes da multiplicação",
                                    "Usar ativação errada por camada",
                                    "Perder track de ativações intermediárias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Obter a saída final e validar o forward pass completo",
                                  "subSteps": [
                                    "Calcule saída final: z_final = W_final * a_ultima + b_final, aplique ativação de saída.",
                                    "Compare saída com expectativa para entrada conhecida.",
                                    "Implemente função forward completa em Python que retorna saída e ativações intermediárias.",
                                    "Teste com múltiplas entradas para robustez.",
                                    "Documente todos os valores intermediários em tabela."
                                  ],
                                  "verification": "Saída final bate entre cálculo manual e código; ativações intermediárias rastreáveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel para validação",
                                    "Código Python completo"
                                  ],
                                  "tips": "Salve ativações em lista para depuração; use print() em código.",
                                  "learningObjective": "Executar e validar forward pass end-to-end em MLP.",
                                  "commonMistakes": [
                                    "Propagação errada entre camadas",
                                    "Ativação de saída omitida",
                                    "Mismatch entre manual e código"
                                  ]
                                }
                              ],
                              "practicalExample": "Para MLP 2-3-1: x=[1,0], W1=[[0.1,0.2,0.3],[0.4,0.5,0.6]], b1=[0.1,0.1,0.1], ReLU; W2=[[0.7],[0.8],[0.9]], b2=0.1, sigmoid. Calcule: z1=W1x+b1=[0.2,0.5,0.7], a1=[0.2,0.5,0.7], z2=W2 a1 + b2=0.95, y=sigmoid(0.95)≈0.72.",
                              "finalVerifications": [
                                "Calcula corretamente forward manual para rede 2-2-1 com valores dados.",
                                "Implementa função forward em Python que reproduz cálculo manual.",
                                "Identifica e corrige erros em ativações intermediárias.",
                                "Explica papel de cada componente (W, b, ativação) verbalmente.",
                                "Aplica forward a nova entrada sem erros.",
                                "Rastreia ativações em diagrama da rede."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (erro < 0.01).",
                                "Correta propagação sequencial por camadas.",
                                "Implementação de código funcional e eficiente.",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Validação cruzada manual vs. código.",
                                "Gestão de dimensões matriciais sem falhas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Multiplicação de matrizes e vetores.",
                                "Programação: Uso de NumPy para operações vetoriais.",
                                "Matemática Aplicada: Funções não-lineares e composição.",
                                "Engenharia Civil: Modelagem preditiva de respostas estruturais."
                              ],
                              "realWorldApplication": "Em engenharia civil, forward pass em MLP prevê deformações em vigas sob cargas variáveis, usando entradas como tensão/material e pesos treinados em dados experimentais, auxiliando no design seguro de estruturas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Diferenciar funções de ativação em MLP",
                            "description": "Comparar e aplicar funções de ativação comuns em MLPs (ex.: linear, sigmoid, ReLU, softmax), explicando seu impacto na convergência do treinamento e na capacidade de modelar não-linearidades em problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o papel fundamental das funções de ativação em MLPs",
                                  "subSteps": [
                                    "Estude a definição de função de ativação e seu posicionamento na arquitetura MLP (após soma ponderada).",
                                    "Analise como funções de ativação introduzem não-linearidades essenciais para modelar relações complexas.",
                                    "Revise equações matemáticas básicas: z = w*x + b, a = f(z).",
                                    "Explore por que funções lineares sozinhas limitam o MLP a modelos lineares.",
                                    "Discuta o impacto inicial na convergência: gradientes e backpropagation."
                                  ],
                                  "verification": "Resuma em um parágrafo o papel das ativações e desenhe um diagrama simples de uma camada MLP.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notebook com Python/Jupyter",
                                    "Documentação TensorFlow/PyTorch",
                                    "Gráficos de funções de ativação (pré-baixados)"
                                  ],
                                  "tips": "Comece visualizando curvas de ativações para intuitivamente entender não-linearidades.",
                                  "learningObjective": "Compreender o conceito teórico e a necessidade de não-linearidades em MLPs.",
                                  "commonMistakes": [
                                    "Confundir ativação com soma ponderada",
                                    "Ignorar que múltiplas lineares equivalem a uma linear"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar funções de ativação comuns: linear, sigmoid, ReLU e softmax",
                                  "subSteps": [
                                    "Implemente e plote a função linear: f(z) = z, discuta usos em regressão.",
                                    "Codifique sigmoid: f(z) = 1/(1 + e^{-z}), calcule derivada e observe saturação.",
                                    "Implemente ReLU: f(z) = max(0, z), compare gradientes e problema do neurônio morto.",
                                    "Codifique softmax para multiclasse: f(z_i) = e^{z_i}/∑e^{z_j}, teste com vetores.",
                                    "Compare derivadas e ranges de saída em código interativo."
                                  ],
                                  "verification": "Gere plots comparativos das 4 funções e suas derivadas usando Matplotlib.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy, Matplotlib, SciPy",
                                    "Jupyter Notebook",
                                    "Referência: 'Deep Learning' de Goodfellow (cap. 6)"
                                  ],
                                  "tips": "Use funções lambda para prototipagem rápida e animações para derivadas.",
                                  "learningObjective": "Implementar e visualizar comportamentos matemáticos de cada função.",
                                  "commonMistakes": [
                                    "Esquecer normalização em softmax",
                                    "Usar ReLU em saídas de regressão contínua"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar impactos na convergência e modelagem de não-linearidades",
                                  "subSteps": [
                                    "Treine MLPs simples com cada ativação em dataset não-linear (ex.: XOR ou deformação de vigas).",
                                    "Monitore loss/accuracy ao longo de épocas, analisando vanishing/exploding gradients.",
                                    "Meça convergência: iterações para loss < 0.1, usando TensorBoard.",
                                    "Avalie capacidade de não-linearidade: teste em problema civil como previsão de fissuras.",
                                    "Documente trade-offs: sigmoid (suave, vanishing), ReLU (rápida, morta), softmax (probabilidades)."
                                  ],
                                  "verification": "Relatório com gráficos de loss por ativação e tabela de métricas comparativas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "TensorFlow/Keras ou PyTorch",
                                    "Dataset sintético de engenharia civil (ex.: simulação de cargas)",
                                    "GPU opcional para aceleração"
                                  ],
                                  "tips": "Normalize dados de entrada para evitar gradientes iniciais ruins.",
                                  "learningObjective": "Quantificar efeitos práticos na performance de treinamento.",
                                  "commonMistakes": [
                                    "Treinar sem seeds fixas para reprodutibilidade",
                                    "Ignorar batch size no vanishing gradient"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em contexto de engenharia civil e sintetizar conhecimentos",
                                  "subSteps": [
                                    "Selecione problema real: modelar não-linearidade em análise estrutural (ex.: curvatura de vigas sob carga).",
                                    "Construa MLP otimizado escolhendo ativações por camada (ReLU hidden, linear/sigmoid output).",
                                    "Treine, valide e compare com baseline linear.",
                                    "Explique escolhas: ReLU para convergência rápida em features não-lineares civis.",
                                    "Prepare apresentação com insights para engenharia."
                                  ],
                                  "verification": "Modelo funcional que supera baseline em métrica RMSE para dado civil simulado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dataset de engenharia civil (ex.: Kaggle estruturas ou simulado ANSYS)",
                                    "Keras/TensorFlow",
                                    "Ferramentas de visualização como Seaborn"
                                  ],
                                  "tips": "Comece com arquitetura pequena (1-2 hidden layers) para depuração rápida.",
                                  "learningObjective": "Aplicar diferenciação de ativações em problema domain-specific.",
                                  "commonMistakes": [
                                    "Overfitting sem validação cruzada",
                                    "Escolher softmax para regressão univariada"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um MLP em Keras para prever a deformação não-linear de uma viga de concreto sob cargas variáveis. Use ReLU nas camadas ocultas para capturar não-linearidades plásticas e linear na saída. Compare com sigmoid (lento) e treine em dataset de 1000 simulações FEM, alcançando RMSE < 0.05 após 50 épocas.",
                              "finalVerifications": [
                                "Plotar e descrever curvas/derivadas das 4 funções corretamente.",
                                "Treinar MLPs com cada ativação e reportar curvas de loss comparativas.",
                                "Explicar verbalmente 3 impactos na convergência (ex.: vanishing em sigmoid).",
                                "Aplicar ReLU vs. outros em modelo civil e justificar performance.",
                                "Identificar quando usar cada: softmax para classificação multiclasse de falhas estruturais.",
                                "Discutir limitações como dying ReLU em contextos civis ruidosos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição matemática e visual das funções (80%+ acerto em quiz).",
                                "Qualidade dos experimentos: reprodutíveis, com métricas claras (loss < threshold).",
                                "Análise profunda de trade-offs (cobrir convergência e não-linearidades).",
                                "Relevância ao contexto civil: ligação explícita com problemas estruturais.",
                                "Criatividade na aplicação prática e verificações finais robustas.",
                                "Clareza no relatório: diagramas, código comentado e conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial (derivadas para backprop), álgebra linear (vetores em softmax).",
                                "Programação: Implementação numérica em Python/NumPy para simulações.",
                                "Engenharia Civil: Modelagem não-linear de materiais (plástico, fadiga em estruturas).",
                                "Estatística: Análise de gradientes e métricas de convergência (MSE, grad norm).",
                                "Física: Comportamentos não-lineares em mecânica dos sólidos."
                              ],
                              "realWorldApplication": "Em engenharia civil, otimizar MLPs com ReLU acelera previsão de colapsos não-lineares em pontes sob terremotos, permitindo simulações FEM híbridas mais rápidas que puramente numéricas, reduzindo tempo de projeto de semanas para horas e melhorando segurança preditiva."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Redes Convolucionais (CNN)",
                        "description": "As redes convolucionais (CNN) são arquiteturas especializadas para processamento de dados em grade, como imagens, utilizando operações de convolução para extrair características locais hierarquicamente. Introdução focada em aplicações iniciais em engenharia civil, como análise de imagens de danos em estruturas ou detecção de defeitos em concreto.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Compreender a operação de convolução em CNN",
                            "description": "Explicar e implementar a convolução 2D com kernels/filtros em imagens, incluindo stride, padding e como ela captura padrões locais como bordas ou texturas em dados de inspeção civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Convolução 2D",
                                  "subSteps": [
                                    "Defina convolução 2D como uma operação que desliza um kernel sobre a imagem de entrada.",
                                    "Explique a multiplicação elemento a elemento entre o kernel e a região da imagem.",
                                    "Some os resultados para obter o valor de saída em cada posição.",
                                    "Compare com imagens de entrada e saída em dimensões reduzidas.",
                                    "Visualize com uma matriz 3x3 de entrada e kernel 2x2."
                                  ],
                                  "verification": "Desenhe manualmente a convolução de uma imagem 4x4 com kernel 2x2 e confirme o mapa de características 3x3.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhos manuais",
                                    "Notebook com Jupyter Notebook",
                                    "Biblioteca NumPy instalada"
                                  ],
                                  "tips": "Comece com imagens em escala de cinza para simplificar; use visualizações para entender o processo.",
                                  "learningObjective": "Compreender a mecânica fundamental da operação de convolução 2D em imagens.",
                                  "commonMistakes": [
                                    "Confundir convolução com multiplicação direta da matriz inteira",
                                    "Ignorar a normalização da soma dos elementos do kernel"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Kernels/Filtros e Detecção de Padrões Locais",
                                  "subSteps": [
                                    "Estude kernels comuns: Sobel para bordas horizontais/verticais, Gaussian para suavização.",
                                    "Aplique kernels em imagens de texturas civis como concreto rachado.",
                                    "Analise como kernels capturam padrões locais (bordas, texturas).",
                                    "Experimente kernels personalizados para detecção de rachaduras.",
                                    "Compare ativações antes/depois em visualizações."
                                  ],
                                  "verification": "Crie um kernel para detectar bordas verticais e aplique em uma imagem de inspeção, observando o mapa de ativação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Imagens de amostra de inspeção civil (ex: rachaduras em pontes)",
                                    "NumPy ou OpenCV",
                                    "Ferramentas de visualização como Matplotlib"
                                  ],
                                  "tips": "Normalise kernels para soma unitária; teste em regiões com e sem padrões conhecidos.",
                                  "learningObjective": "Identificar como diferentes kernels extraem características específicas como bordas e texturas.",
                                  "commonMistakes": [
                                    "Usar kernels sem normalização levando a valores de saída inconsistentes",
                                    "Aplicar kernels rotacionados incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Stride e Padding na Convolução",
                                  "subSteps": [
                                    "Defina stride como o passo de deslizamento do kernel (ex: stride=1 vs stride=2).",
                                    "Explique padding 'valid' (sem padding), 'same' (padding para manter tamanho).",
                                    "Calcule dimensões de saída: (W - K + 2P)/S + 1.",
                                    "Implemente em código com diferentes configurações.",
                                    "Visualize impactos no tamanho e resolução do mapa de características."
                                  ],
                                  "verification": "Implemente convolução com stride=2 e padding='same' em uma imagem 28x28, confirmando saída 28x28.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com PyTorch ou TensorFlow",
                                    "Imagens de teste 28x28 pixels de defeitos civis"
                                  ],
                                  "tips": "Use funções prontas como torch.nn.Conv2d para validar implementações manuais.",
                                  "learningObjective": "Dominar o controle de dimensões de saída via stride e padding.",
                                  "commonMistakes": [
                                    "Erro no cálculo de padding necessário para 'same'",
                                    "Confundir stride com tamanho do kernel"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Convolução em Dados de Inspeção Civil",
                                  "subSteps": [
                                    "Carregue imagem real de inspeção (ex: drone de ponte com rachaduras).",
                                    "Aplique múltiplos kernels para camadas de características.",
                                    "Interprete mapas de ativação para padrões civis (bordas de fissuras, texturas irregulares).",
                                    "Compare com inspeção manual.",
                                    "Otimize kernels para detecção específica."
                                  ],
                                  "verification": "Gere e interprete mapas de características de uma imagem civil, destacando padrões detectados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Dataset de imagens civis (ex: Kaggle Concrete Crack Images)",
                                    "PyTorch/TensorFlow",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": "Aumente contraste das imagens de entrada; use batch processing para eficiência.",
                                  "learningObjective": "Aplicar convolução para análise prática em contextos de engenharia civil.",
                                  "commonMistakes": [
                                    "Processar imagens coloridas sem converter para cinza",
                                    "Ignorar ruído em imagens reais de campo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma imagem 5x5 representando uma seção de concreto com rachadura vertical (valores altos na coluna central), aplique um kernel Sobel vertical 3x3: [[-1,0,1],[-2,0,2],[-1,0,1]]. Com stride=1 e padding='valid', o mapa de saída destacará a rachadura como picos altos no centro.",
                              "finalVerifications": [
                                "Explicar convolução 2D, stride e padding em termos próprios.",
                                "Implementar convolução manual em NumPy para imagem 5x5.",
                                "Gerar mapas de características de imagem civil com múltiplos kernels.",
                                "Calcular dimensões de saída corretamente para cenários variados.",
                                "Interpretar ativações como detecção de bordas/texturas em inspeção.",
                                "Comparar resultados com bibliotecas como PyTorch."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual na explicação de convolução e parâmetros (80%+ correto).",
                                "Código funcional e eficiente sem erros de índice/dimensão.",
                                "Interpretação correta de mapas de ativação em contexto civil.",
                                "Uso adequado de stride/padding para preservar informações.",
                                "Criatividade em kernels personalizados para padrões civis.",
                                "Visualizações claras e anotadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e operações matriciais.",
                                "Programação: Manipulação de arrays multidimensionais em Python.",
                                "Engenharia Civil: Análise de imagens para inspeção não-destrutiva.",
                                "Processamento de Sinais: Filtros em domínio espacial.",
                                "Machine Learning: Base para camadas convolucionais em redes profundas."
                              ],
                              "realWorldApplication": "Na engenharia civil, convoluções em CNNs processam imagens de drones ou câmeras para detectar rachaduras, corrosão ou deformações em pontes e edifícios, permitindo inspeções preditivas, redução de custos e prevenção de falhas estruturais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Aplicar camadas de pooling em CNN",
                            "description": "Descrever e calcular operações de pooling (max, average) para redução dimensional, explicando sua função na invariância a translações e na diminuição de parâmetros computacionais em análises de imagens estruturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Pooling em CNNs",
                                  "subSteps": [
                                    "Estude a definição de pooling como operação de downsampling em camadas convolucionais.",
                                    "Analise a função do pooling na redução da dimensionalidade espacial das feature maps.",
                                    "Explore como o pooling promove invariância a translações, mantendo características relevantes independentemente de pequenas deslocações.",
                                    "Discuta a redução de parâmetros computacionais, comparando feature maps antes e após pooling.",
                                    "Revise exemplos visuais de pooling em imagens de estruturas civis, como detecção de rachaduras."
                                  ],
                                  "verification": "Resuma em um parágrafo os benefícios do pooling e desenhe um diagrama simples de uma feature map 4x4 reduzida para 2x2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação TensorFlow/PyTorch sobre pooling",
                                    "Imagens de exemplo de estruturas civis (ex: pontes com rachaduras)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use animações online para visualizar o processo de pooling em movimento.",
                                  "learningObjective": "Explicar o papel do pooling na redução dimensional e invariância a translações em CNNs.",
                                  "commonMistakes": [
                                    "Confundir pooling com convolução",
                                    "Ignorar o impacto na redução de overfitting"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Tipos de Pooling: Max e Average",
                                  "subSteps": [
                                    "Implemente manualmente max pooling em uma matriz 4x4 com kernel 2x2, selecionando o valor máximo em cada janela.",
                                    "Calcule average pooling na mesma matriz, computando a média em cada janela.",
                                    "Compare saídas de max e average pooling em termos de preservação de bordas e suavização.",
                                    "Aplique os cálculos em uma feature map simulada de análise de imagem estrutural (ex: intensidade de pixels em concreto rachado).",
                                    "Registre diferenças numéricas e visuais entre os dois tipos."
                                  ],
                                  "verification": "Crie uma tabela comparativa com entradas, saídas e tempos computacionais estimados para max vs average.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Jupyter Notebook",
                                    "Matrizes de exemplo pré-definidas"
                                  ],
                                  "tips": "Comece com kernels pequenos (2x2) para facilitar cálculos manuais antes de codificar.",
                                  "learningObjective": "Calcular e diferenciar operações de max e average pooling manualmente.",
                                  "commonMistakes": [
                                    "Usar stride diferente do kernel size",
                                    "Arredondar incorretamente valores em average pooling"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Camadas de Pooling em uma CNN Prática",
                                  "subSteps": [
                                    "Configure um ambiente com TensorFlow ou PyTorch e carregue uma imagem de estrutura civil (ex: foto de ponte).",
                                    "Adicione camadas de convolução seguidas de MaxPooling2D(2,2) e AveragePooling2D(2,2) em uma rede simples.",
                                    "Treine a CNN em um dataset pequeno de imagens de defeitos estruturais e monitore o shape das feature maps.",
                                    "Visualize as feature maps antes e após pooling usando ferramentas como TensorBoard.",
                                    "Ajuste hiperparâmetros como pool_size e strides para otimizar redução dimensional."
                                  ],
                                  "verification": "Execute o código e confirme redução de dimensionalidade (ex: de 28x28 para 14x14) via print dos shapes.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "TensorFlow/Keras ou PyTorch",
                                    "Dataset de imagens civis (ex: Kaggle Concrete Crack Images)",
                                    "GPU opcional para treinamento"
                                  ],
                                  "tips": "Use padding='valid' inicialmente para observar efeitos claros de redução.",
                                  "learningObjective": "Integrar e aplicar camadas de pooling em uma arquitetura CNN funcional.",
                                  "commonMistakes": [
                                    "Esquecer de especificar input_shape",
                                    "Não normalizar imagens de entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Impacto e Otimizar Pooling em Análises Estruturais",
                                  "subSteps": [
                                    "Meça o número de parâmetros antes/depois pooling e calcule economia computacional.",
                                    "Teste invariância a translações aplicando shifts leves em imagens de teste e comparando predições.",
                                    "Compare performance de CNNs com/ sem pooling em precisão e tempo de inferência.",
                                    "Otimize escolhendo max pooling para detecção de bordas em rachaduras vs average para texturas.",
                                    "Documente resultados em um relatório com métricas quantitativas."
                                  ],
                                  "verification": "Gere gráficos de accuracy/loss e relatório de redução de parâmetros (>50% esperado).",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código da Step 3",
                                    "Métricas de modelo (accuracy, params_count)",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Use callbacks para logging automático de shapes e params.",
                                  "learningObjective": "Quantificar benefícios do pooling em eficiência e robustez para aplicações civis.",
                                  "commonMistakes": [
                                    "Treinar sem validação cruzada",
                                    "Ignorar overhead de memória em pooling"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma inspeção de pontes, aplique max pooling em feature maps de imagens de concreto para detectar rachaduras: uma feature map 64x64x32 é reduzida para 32x32x32, preservando picos de intensidade (bordas de rachaduras) enquanto reduz computação em 75%, permitindo análise em tempo real via drone.",
                              "finalVerifications": [
                                "Calcule corretamente pooling manual em matrizes 4x4 para max e average.",
                                "Implemente CNN com pooling e confirme redução de shape via logs.",
                                "Demonstre invariância a translações com shifts de 1-2 pixels em testes.",
                                "Relate economia de parâmetros >50% em modelo treinado.",
                                "Visualize feature maps pós-pooling destacando características estruturais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos manuais de pooling (100% correto).",
                                "Funcionalidade do código CNN com pooling integrado (execução sem erros).",
                                "Explicação clara de invariância e redução computacional (com evidências numéricas).",
                                "Otimização demonstrada via comparação de modelos (melhoria mensurável).",
                                "Relatório completo com visualizações e métricas.",
                                "Aplicação contextualizada a engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações matriciais e downsampling (álgebra linear).",
                                "Programação: Manipulação de arrays multidimensionais em Python/NumPy.",
                                "Engenharia Civil: Análise não-destrutiva de estruturas via visão computacional.",
                                "Física: Processamento de sinais em imagens de materiais (ex: propagação de rachaduras)."
                              ],
                              "realWorldApplication": "Na manutenção preditiva de infraestruturas civis, como pontes e barragens, camadas de pooling em CNNs permitem processar imagens de drones em edge devices, reduzindo tempo de análise de horas para minutos e detectando defeitos precocemente, economizando milhões em reparos reativos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Desenhar uma arquitetura básica de CNN",
                            "description": "Montar um diagrama simples de CNN com camadas convolucionais, pooling, flatten e fully connected, relacionando-a a problemas como classificação de imagens de falhas em pontes ou edifícios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de CNN",
                                  "subSteps": [
                                    "Estude a função de cada camada: convolucional (extração de features), pooling (redução dimensional), flatten (vetorização), fully connected (classificação).",
                                    "Revise dimensões: como o shape muda após conv e pool (ex: input 128x128x3 -> Conv(32,3x3) -> 126x126x32).",
                                    "Analise exemplos de CNNs básicas como LeNet ou simples classificadores de imagens.",
                                    "Relacione com o contexto: detecção de falhas em imagens de pontes/edifícios.",
                                    "Anote definições chave em um papel."
                                  ],
                                  "verification": "Lista de conceitos revisados com exemplos de shapes corretos anotados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notebook com acesso a tutoriais CNN (ex: Towards Data Science)"
                                  ],
                                  "tips": "Use diagramas prontos como referência inicial, mas não copie.",
                                  "learningObjective": "Compreender o fluxo de dados em uma CNN básica.",
                                  "commonMistakes": [
                                    "Confundir pooling com convolução",
                                    "Ignorar mudança de dimensões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir input e problema específico",
                                  "subSteps": [
                                    "Escolha o problema: classificação binária de imagens de falhas em pontes (rachada vs intacta).",
                                    "Defina input shape: ex: 128x128x3 (RGB images).",
                                    "Especifique output: 1 neurônio com sigmoid para probabilidade de falha.",
                                    "Calcule classes e dataset hipotético: 1000 imagens por classe.",
                                    "Desenhe caixa inicial do input no diagrama."
                                  ],
                                  "verification": "Input shape e output definido anotados no esboço inicial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação como draw.io ou papel"
                                  ],
                                  "tips": "Comece com shapes pequenos para facilitar cálculos manuais.",
                                  "learningObjective": "Adaptar CNN a um problema de engenharia civil real.",
                                  "commonMistakes": [
                                    "Input shape incompatível com conv",
                                    "Esquecer canais de cor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar camadas convolucionais e pooling",
                                  "subSteps": [
                                    "Adicione primeira Conv2D: 32 filtros 3x3, ReLU, seguido de MaxPool 2x2.",
                                    "Calcule novo shape: de 128x128x3 para ~62x62x32 após conv+pool.",
                                    "Adicione segunda Conv2D: 64 filtros 3x3, ReLU, MaxPool 2x2 (~30x30x64).",
                                    "Desenhe setas conectando camadas com shapes anotados.",
                                    "Inclua padding='same' se necessário para manter dimensões."
                                  ],
                                  "verification": "Shapes calculados corretamente e diagramados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "draw.io ou papel quadriculado",
                                    "Calculadora para shapes"
                                  ],
                                  "tips": "Use fórmula: output_size = (input - kernel + 2*padding)/stride + 1.",
                                  "learningObjective": "Dominar feature extraction via conv e redução via pooling.",
                                  "commonMistakes": [
                                    "Erros em cálculos de shape",
                                    "Pool antes de conv"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar flatten e fully connected",
                                  "subSteps": [
                                    "Insira Flatten após última pool: converte ~30x30x64 em vetor de ~57600.",
                                    "Adicione Dense(128, ReLU) para abstração.",
                                    "Final Dense(1, sigmoid) para output.",
                                    "Desenhe conexões completas com ativações anotadas.",
                                    "Relacione: features de conv detectam rachaduras -> classificação."
                                  ],
                                  "verification": "Diagrama completo com todas camadas e shapes consistentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesma ferramenta de diagramação"
                                  ],
                                  "tips": "Reduza Dense se vetor flatten for muito grande (use GlobalAvgPool).",
                                  "learningObjective": "Completar pipeline de CNN para classificação.",
                                  "commonMistakes": [
                                    "Flatten em shape errado",
                                    "Output sem ativação adequada"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Finalizar diagrama e validar",
                                  "subSteps": [
                                    "Anotar labels, shapes e funções em cada camada.",
                                    "Simule forward pass com exemplo de imagem de ponte.",
                                    "Verifique consistência: shapes diminuem logicamente.",
                                    "Exporte ou fotografe o diagrama final.",
                                    "Escreva uma legenda relacionando à detecção de falhas."
                                  ],
                                  "verification": "Diagrama limpo, legível e validado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de export PDF"
                                  ],
                                  "tips": "Use cores para diferenciar tipos de camadas.",
                                  "learningObjective": "Produzir diagrama profissional e contextualizado.",
                                  "commonMistakes": [
                                    "Falta de anotações",
                                    "Inconsistências não detectadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para classificar imagens 128x128x3 de pontes: Input -> Conv2D(32,3x3,ReLU) -> MaxPool2x2 -> Conv2D(64,3x3,ReLU) -> MaxPool2x2 -> Flatten -> Dense(128,ReLU) -> Dense(1,sigmoid). Features de conv detectam rachaduras; output >0.5 indica falha.",
                              "finalVerifications": [
                                "Diagrama inclui todas camadas: conv, pool, flatten, FC.",
                                "Shapes de input/output calculados e anotados corretamente.",
                                "Fluxo de dados lógico com setas conectando camadas.",
                                "Ativações (ReLU, sigmoid) especificadas.",
                                "Relacionamento com detecção de falhas em estruturas civis explícito.",
                                "Diagrama legível e profissional."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de dimensões (100% correto).",
                                "Presença e ordem correta das camadas essenciais.",
                                "Clareza visual e anotações completas.",
                                "Adequação ao contexto de engenharia civil.",
                                "Criatividade na relação com problema real.",
                                "Consistência no forward pass simulado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de convoluções e redução dimensional.",
                                "Programação: Implementação equivalente em Keras/TensorFlow.",
                                "Engenharia Civil: Análise não-destrutiva de estruturas.",
                                "Física: Processamento de imagens ópticas de danos.",
                                "Estatística: Interpretação de probabilidades de falha."
                              ],
                              "realWorldApplication": "Em inspeções de infraestrutura civil, CNNs assim são usadas em apps de drones para detectar rachaduras em pontes/edifícios em tempo real, priorizando manutenções e evitando colapsos, como no sistema de monitoramento da ponte Golden Gate."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.4",
                            "name": "Comparar MLP e CNN em contextos de engenharia",
                            "description": "Analisar vantagens da CNN sobre MLP para dados espaciais (ex.: imagens de topografia ou scans de estruturas), destacando eficiência paramétrica e extração automática de features.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de MLP (Multilayer Perceptron)",
                                  "subSteps": [
                                    "Estude a arquitetura de MLP: camadas fully connected, funções de ativação (ReLU, sigmoid).",
                                    "Analise o fluxo de dados: entrada achatada (flatten) para vetores 1D.",
                                    "Calcule parâmetros: (input_size + 1) * hidden_size para cada camada.",
                                    "Implemente um MLP simples em Python com Keras para classificação básica.",
                                    "Teste com dados não-espaciais para observar limitações iniciais."
                                  ],
                                  "verification": "Implemente e treine um MLP em um dataset simples (ex: MNIST achatado) e verifique acurácia >80%.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Keras: keras.io/api/layers/core/",
                                    "Dataset MNIST via tensorflow.datasets"
                                  ],
                                  "tips": "Use Dropout para evitar overfitting em MLPs densos.",
                                  "learningObjective": "Compreender a estrutura fully connected do MLP e suas limitações para dados de alta dimensionalidade.",
                                  "commonMistakes": "Confundir MLP com redes recorrentes; sempre achate imagens para entrada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Arquitetura de CNN (Convolutional Neural Network)",
                                  "subSteps": [
                                    "Estude camadas convolucionais: kernels, strides, padding e feature maps.",
                                    "Analise pooling (max/average) para redução dimensional.",
                                    "Calcule parâmetros: muito menos que MLP devido a compartilhamento de pesos (kernel_size * channels_in * channels_out).",
                                    "Implemente uma CNN básica em Keras para imagens (ex: Conv2D + MaxPooling2D + Dense).",
                                    "Compare visualmente ativações intermediárias com ferramentas como TensorBoard."
                                  ],
                                  "verification": "Treine uma CNN em MNIST 28x28 e compare loss curve com MLP equivalente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tutorial CNN Keras: keras.io/examples/vision/mnist_convnet/",
                                    "TensorBoard para visualização"
                                  ],
                                  "tips": "Comece com kernels 3x3 para capturar padrões locais em imagens.",
                                  "learningObjective": "Dominar como CNNs exploram estrutura espacial via convoluções locais.",
                                  "commonMistakes": "Ignorar padding='same' levando a perda de bordas; teste strides=1 inicialmente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Eficiência Paramétrica e Extração de Features",
                                  "subSteps": [
                                    "Calcule número de parâmetros para MLP vs CNN em input 128x128x3: MLP ~50M, CNN ~1M.",
                                    "Analise extração automática: CNN aprende hierarquias (bordas -> texturas -> objetos).",
                                    "Meça overfitting: CNN generaliza melhor em dados espaciais devido a inductive bias.",
                                    "Use model.summary() em Keras para tabelas comparativas.",
                                    "Discuta trade-offs: MLP mais flexível para dados tabulares, CNN para grids."
                                  ],
                                  "verification": "Gere tabela comparativa de params, FLOPs e acurácia em dataset de imagens.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Keras model.summary()",
                                    "Paper 'Understanding CNNs' de CS231n"
                                  ],
                                  "tips": "Foco em receptive fields: CNNs constroem contextos locais progressivamente.",
                                  "learningObjective": "Quantificar vantagens paramétricas da CNN e seu papel na feature engineering automática.",
                                  "commonMistakes": "Subestimar impacto de pooling na redução params; sempre compare baselines."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Comparação a Dados Espaciais de Engenharia Civil",
                                  "subSteps": [
                                    "Selecione dataset: imagens de topografia (ex: satélite) ou scans de estruturas (ex: rachaduras em concreto).",
                                    "Treine MLP (achatado) vs CNN e compare métricas: accuracy, precision, recall, tempo de treino.",
                                    "Analise falhas: MLP ignora correlações espaciais, CNN captura padrões como defeitos lineares.",
                                    "Visualize heatmaps (Grad-CAM) para features aprendidas.",
                                    "Documente vantagens: CNN 2-5x mais eficiente em params e performance."
                                  ],
                                  "verification": "Relatório com gráficos de performance mostrando superioridade CNN em dados espaciais.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Dataset Kaggle: Concrete Crack Images",
                                    "Grad-CAM via tf-keras-vis"
                                  ],
                                  "tips": "Aumente data augmentation (rotations, flips) para robustez em engenharia.",
                                  "learningObjective": "Demonstrar superioridade prática da CNN em contextos de engenharia civil.",
                                  "commonMistakes": "Usar dataset pequeno sem validação cruzada; mire 80/20 split."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Vantagens e Limitações",
                                  "subSteps": [
                                    "Liste prós CNN: eficiência params, translation invariance, feature sharing.",
                                    "Liste contras: menos interpretável que MLP em alguns casos.",
                                    "Discuta cenários híbridos: MLP para features não-espaciais pós-CNN.",
                                    "Prepare apresentação comparativa com diagramas.",
                                    "Reflita sobre escalabilidade em engenharia (ex: drones para inspeção)."
                                  ],
                                  "verification": "Crie mindmap ou tabela resumindo 5 vantagens chave da CNN sobre MLP.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Draw.io para diagramas",
                                    "Notas de aulas anteriores"
                                  ],
                                  "tips": "Use analogias: MLP como 'olhar global sem foco', CNN como 'varredura localizada'.",
                                  "learningObjective": "Consolidar conhecimento para comunicação clara de trade-offs.",
                                  "commonMistakes": "Generalizar demais; especifique 'para dados espaciais altos-dims'."
                                }
                              ],
                              "practicalExample": "Em inspeção de pontes civis, treine MLP vs CNN em dataset de 10k imagens de rachaduras (224x224). MLP usa 12M params e acurácia 72%; CNN usa 2M params e 92%, detectando padrões espaciais sutis como fissuras lineares automaticamente.",
                              "finalVerifications": [
                                "Explicar cálculo de params: CNN compartilha kernels vs fully connected MLP.",
                                "Identificar 3 features automáticas da CNN ausentes no MLP (bordas, texturas, formas).",
                                "Comparar curvas de learning em dataset espacial: CNN converge mais rápido.",
                                "Aplicar a exemplo real: por que CNN para scans topográficos?",
                                "Discutir quando MLP ainda é preferível (dados tabulares de sensores).",
                                "Gerar relatório com métricas quantitativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de parâmetros (erro <10%).",
                                "Explicação clara de inductive bias espacial da CNN.",
                                "Evidências empíricas de superioridade via experimentos.",
                                "Análise qualitativa de features extraídas.",
                                "Conexão explícita a contextos de engenharia civil.",
                                "Comunicação concisa em tabela/diagrama."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações de convolução como filtros lineares (álgebra linear).",
                                "Programação: Implementação em Python/Keras com GPU acceleration.",
                                "Estatística: Métricas de performance (ROC-AUC) e validação cruzada.",
                                "Física/Materiais: Interpretação de defeitos em estruturas civis via visão.",
                                "Gestão de Projetos: Escalabilidade computacional em inspeções reais."
                              ],
                              "realWorldApplication": "Na engenharia civil, CNNs otimizam inspeções autônomas de infraestrutura via drones, detectando anomalias em imagens topográficas ou scans LiDAR com 90%+ acurácia e 80% menos params que MLPs, reduzindo custos de manutenção preditiva em pontes e barragens."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Algoritmo de Retropropagação",
                    "description": "Processo de treinamento: cálculo de gradientes e ajuste de pesos via descida de gradiente.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Passagem Forward na Rede Neural",
                        "description": "Cálculo da saída da rede neural a partir das entradas, propagando os sinais através das camadas usando funções de ativação, essencial para avaliar o desempenho antes do treinamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Calcular ativações em uma camada",
                            "description": "Realizar o produto matricial entre pesos, bias e entradas, seguido da aplicação de função de ativação como sigmoide ou ReLU, para obter ativações de neurônios em uma camada oculta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar os componentes da camada neural",
                                  "subSteps": [
                                    "Identifique as dimensões: número de entradas (n), neurônios na camada (m).",
                                    "Defina ou carregue a matriz de pesos W (m x n), vetor de bias b (m x 1) e vetor de entrada x (n x 1).",
                                    "Verifique compatibilidade dimensional: W tem shape (m, n), x (n, 1), b (m, 1).",
                                    "Inicialize valores se necessário (ex: pesos aleatórios pequenos, bias zero).",
                                    "Escolha a função de ativação (ex: ReLU ou sigmoide)."
                                  ],
                                  "verification": "Confirme que dimensões de W, x e b são compatíveis via print de shapes.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Jupyter Notebook ou editor de código",
                                    "Papel e caneta para esboço manual"
                                  ],
                                  "tips": "Use np.random.seed(42) para reproducibilidade em testes.",
                                  "learningObjective": "Compreender e preparar corretamente as estruturas de dados matriciais para forward pass.",
                                  "commonMistakes": "Confundir dimensões de entrada/saída ou transpor incorretamente matrizes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a pré-ativação z (produto matricial e bias)",
                                  "subSteps": [
                                    "Compute o produto matricial: z_temp = np.dot(W, x).",
                                    "Adicione o bias: z = z_temp + b.",
                                    "Realize o cálculo manualmente para um subconjunto pequeno para validação.",
                                    "Armazene z em uma variável e imprima seu shape e valores.",
                                    "Confirme que z tem shape (m, 1), representando soma ponderada para cada neurônio."
                                  ],
                                  "verification": "z deve ter valores escalares corretos comparados a cálculo manual.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "NumPy para operações matriciais",
                                    "Calculadora para verificação manual"
                                  ],
                                  "tips": "Use broadcasting do NumPy para adicionar bias automaticamente.",
                                  "learningObjective": "Executar com precisão o cálculo linear z = Wx + b.",
                                  "commonMistakes": "Esquecer de adicionar bias ou usar multiplicação elemento-a-elemento em vez de matricial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a função de ativação para obter ativações a",
                                  "subSteps": [
                                    "Defina a função: para ReLU, a = np.maximum(0, z); para sigmoide, a = 1 / (1 + np.exp(-z)).",
                                    "Aplique elemento a elemento na vetor z.",
                                    "Implemente a função customizada ou use bibliotecas como np.where para ReLU.",
                                    "Imprima valores de a e compare com z (ex: ReLU zera negativos).",
                                    "Salve a como saída da camada para próxima iteração forward."
                                  ],
                                  "verification": "Para ReLU, todos valores negativos em z viram 0 em a; teste com z conhecido.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "NumPy para funções vetoriais",
                                    "Gráfico opcional com Matplotlib para visualizar"
                                  ],
                                  "tips": "Evite overflow na sigmoide usando np.clip(z, -500, 500).",
                                  "learningObjective": "Aplicar corretamente funções não-lineares para introduzir não-linearidade.",
                                  "commonMistakes": "Aplicar ativação antes do bias ou usar função errada (ex: ReLU em sigmoide)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar as ativações calculadas",
                                  "subSteps": [
                                    "Compare resultado automatizado com cálculo manual passo a passo.",
                                    "Teste com diferentes entradas e funções de ativação.",
                                    "Analise impacto: como ativações diferem com ReLU vs sigmoide.",
                                    "Documente o processo em um relatório curto com valores finais.",
                                    "Prepare para forward pass completo integrando com camadas anteriores."
                                  ],
                                  "verification": "Resultados coincidem em pelo menos 3 testes manuais independentes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Planilha ou papel para cálculos manuais",
                                    "Código Python para automação"
                                  ],
                                  "tips": "Use asserts no código: assert np.allclose(a_manual, a_computed).",
                                  "learningObjective": "Garantir robustez e interpretação das ativações na rede.",
                                  "commonMistakes": "Ignorar verificações, levando a erros propagados em camadas subsequentes."
                                }
                              ],
                              "practicalExample": "Entrada x = [[1.0], [0.5]] (2 features). Pesos W = [[0.1, 0.8], [0.4, 0.6]] (2 neurônios). Bias b = [[0.1], [0.2]]. z = [[0.1*1 + 0.8*0.5 + 0.1], [0.4*1 + 0.6*0.5 + 0.2]] = [[0.6], [0.8]]. Com ReLU: a = [[0.6], [0.8]] (positivos mantidos).",
                              "finalVerifications": [
                                "Dimensões de a coincidem com número de neurônios (m x 1).",
                                "Cálculo manual de z e a bate com código (erro < 1e-6).",
                                "Função de ativação aplicada corretamente em todos elementos.",
                                "Teste com entrada zero resulta em ativações esperadas.",
                                "Integração com camada anterior: saída anterior como x atual.",
                                "Sensibilidade: pequena mudança em x altera a proporcionalmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erro absoluto < 0.01).",
                                "Correta manipulação de dimensões matriciais.",
                                "Implementação eficiente usando vetores NumPy.",
                                "Validação completa com exemplos manuais e automatizados.",
                                "Interpretação clara do papel das ativações na rede.",
                                "Código limpo, comentado e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: multiplicação de matrizes e operações vetoriais.",
                                "Programação Computacional: uso de NumPy para eficiência.",
                                "Engenharia Civil: modelagem de dados sensoriais em estruturas.",
                                "Estatística: introdução de não-linearidade em regressões.",
                                "Matemática Numérica: estabilidade de funções de ativação."
                              ],
                              "realWorldApplication": "Em engenharia civil, calcular ativações em redes neurais processa dados de sensores (ex: deformações em pontes) para prever falhas estruturais durante o forward pass do algoritmo de retropropagação, otimizando manutenção preditiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Propagar saídas através de múltiplas camadas",
                            "description": "Implementar iterações sequenciais de cálculo de ativações de entrada para saída, considerando arquiteturas feedforward em redes neurais artificiais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a arquitetura da rede e dados de entrada",
                                  "subSteps": [
                                    "Defina o número de camadas: entrada, uma ou mais camadas ocultas e saída.",
                                    "Especifique dimensões: neurônios por camada (ex: entrada=3, oculta1=4, saída=1).",
                                    "Inicialize matrizes de pesos (W) e biases (b) para cada camada com valores aleatórios ou fixos.",
                                    "Prepare vetor de entrada x com valores normalizados (ex: [0.5, 0.3, 0.8]).",
                                    "Verifique dimensões: W1 deve ser (neurônios_oculta1 x neurônios_entrada)."
                                  ],
                                  "verification": "Confirme que todas matrizes têm dimensões corretas e entrada está normalizada (use print ou debugger).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta para esboço; Python com NumPy; editor de código (VS Code ou Jupyter Notebook).",
                                  "tips": "Desenhe um diagrama da rede para visualizar conexões antes de codificar.",
                                  "learningObjective": "Compreender a estrutura feedforward e preparar componentes para propagação.",
                                  "commonMistakes": "Confundir dimensões de matrizes (ex: transpor incorretamente); não normalizar entrada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular ativações da primeira camada oculta (forward pass inicial)",
                                  "subSteps": [
                                    "Compute z1 = W1 * x + b1 (multiplicação matricial).",
                                    "Aplique função de ativação σ(z1), como ReLU: max(0, z1) ou sigmoide.",
                                    "Armazene a1 = σ(z1) como saída da camada 1.",
                                    "Teste com valores numéricos simples para validar (ex: x=[1,0], W1=[[1,2],[3,4]], b1=[0,0]).",
                                    "Registre valores intermediários para depuração."
                                  ],
                                  "verification": "Calcule manualmente z1 e a1 para entrada pequena e compare com código (erro < 1e-6).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "NumPy para operações matriciais; calculadora para verificação manual.",
                                  "tips": "Use np.dot() ou @ para multiplicação eficiente; evite loops para performance.",
                                  "learningObjective": "Dominar cálculo linear e não-linear na primeira propagação forward.",
                                  "commonMistakes": "Esquecer bias; aplicar ativação antes da soma linear; overflow em ativações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e validar a saída final da rede",
                                  "subSteps": [
                                    "Compute z_out = W_out * a_last + b_out.",
                                    "Aplique ativação de saída (ex: sigmoide para regressão/binário).",
                                    "Obtenha y_hat = σ(z_out).",
                                    "Compare y_hat com valor esperado/target para perda simples (MSE).",
                                    "Execute forward pass completo com entrada de teste múltiplas vezes."
                                  ],
                                  "verification": "y_hat deve coincidir com implementação em bibliotecas como scikit-learn (erro < 0.01).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Biblioteca TensorFlow/Keras para benchmark opcional; dados de teste.",
                                  "tips": "Vectorize para batches: X @ W + b para múltiplas entradas.",
                                  "learningObjective": "Finalizar propagação forward e preparar para backpropagation.",
                                  "commonMistakes": "Aplicar ativação errada na saída; ignorar normalização final."
                                }
                              ],
                              "practicalExample": "Rede simples para previsão de resistência de concreto: entrada [cimento, agua, agregados]; 2 camadas ocultas (4 e 3 neurônios, ReLU); saída [MPa]. Exemplo: x=[300,150,800], após forward: y_hat=35.2 MPa.",
                              "finalVerifications": [
                                "Cálculo manual de todas ativações coincide com código (precisão 1e-5).",
                                "Propagação funciona para redes com 3+ camadas sem erros dimensionais.",
                                "Mudança na entrada altera saída corretamente (teste sensibilidade).",
                                "Tempo de execução <1s para 1000 amostras.",
                                "Gráficos de ativações mostram padrões esperados (sem NaNs).",
                                "Comparação com Keras Sequential model idêntica."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matriciais (100% match manual).",
                                "Implementação eficiente sem loops desnecessários.",
                                "Tratamento correto de funções de ativação em todas camadas.",
                                "Documentação clara de ativações intermediárias.",
                                "Generalidade para diferentes arquiteturas (testes variados).",
                                "Ausência de erros comuns como transposições."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (multiplicação matricial, vetores).",
                                "Programação: NumPy/Pandas para manipulação de dados.",
                                "Engenharia Civil: Modelagem preditiva de materiais/estruturas.",
                                "Estatística: Normalização e validação de predições."
                              ],
                              "realWorldApplication": "Em engenharia civil, propagar forward em RNAs prevê deformações em vigas sob carga, otimizando projetos de pontes e edifícios com dados sensoriais IoT, reduzindo custos de testes físicos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Avaliar função de perda na saída",
                            "description": "Computar erros como MSE ou cross-entropy entre saídas previstas e valores reais, preparando para o cálculo de gradientes no retropropagação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e selecionar a função de perda apropriada",
                                  "subSteps": [
                                    "Defina o conceito de função de perda como medida de erro entre predições e valores reais.",
                                    "Identifique funções comuns: MSE (Erro Quadrático Médio) para regressão e Cross-Entropy para classificação.",
                                    "Analise o problema de engenharia civil (ex: previsão contínua de deformações vs. classificação de falhas).",
                                    "Justifique a escolha com base no tipo de saída da rede neural (contínua ou categórica).",
                                    "Consulte documentação de bibliotecas como PyTorch ou TensorFlow para fórmulas exatas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que escolheu MSE para um problema de regressão em estruturas civis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação de PyTorch/TensorFlow",
                                    "Notebook Jupyter com exemplos de problemas civis"
                                  ],
                                  "tips": "Sempre priorize MSE para saídas numéricas contínuas como tensões ou deformações.",
                                  "learningObjective": "Selecionar a função de perda correta com base no tipo de tarefa de aprendizado de máquina.",
                                  "commonMistakes": [
                                    "Confundir regressão com classificação e usar Cross-Entropy em predições contínuas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair saídas previstas e valores reais após forward pass",
                                  "subSteps": [
                                    "Execute a passagem forward na rede para obter as predições na camada de saída.",
                                    "Carregue os valores reais (targets) do conjunto de dados de validação ou batch atual.",
                                    "Verifique a compatibilidade de dimensões: shapes de predições e targets devem coincidir.",
                                    "Normalize ou preprocess os dados se necessário (ex: escalar valores de engenharia para [0,1]).",
                                    "Armazene em variáveis ou tensores para cálculo subsequente."
                                  ],
                                  "verification": "Imprima shapes e valores de predições e targets; confirme que são iguais.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código da rede neural em Python",
                                    "Dataset de exemplo (ex: dados de resistência de concreto)"
                                  ],
                                  "tips": "Use print() ou debugger para inspecionar tensores durante o forward pass.",
                                  "learningObjective": "Coletar corretamente dados de entrada para o cálculo de perda.",
                                  "commonMistakes": [
                                    "Esquecer de aplicar softmax na saída para Cross-Entropy em classificação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o valor da função de perda",
                                  "subSteps": [
                                    "Aplique a fórmula: para MSE, calcule média de (pred - target)^2 elemento a elemento.",
                                    "Para Cross-Entropy, use -soma(target * log(pred)) com softmax nas predições.",
                                    "Se for batch, compute a média sobre todas as amostras do lote.",
                                    "Implemente manualmente em NumPy ou use funções built-in como torch.nn.MSELoss().",
                                    "Registre o valor escalar da perda para monitoramento."
                                  ],
                                  "verification": "Compare cálculo manual com função da biblioteca; diferença < 1e-6.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca NumPy/PyTorch",
                                    "Notebook com forward pass implementado"
                                  ],
                                  "tips": "Evite overflow em log() dividindo por pequeno epsilon em predições próximas de zero.",
                                  "learningObjective": "Implementar e calcular precisamente a função de perda.",
                                  "commonMistakes": [
                                    "Não reduzir para escalar (média) em batches, resultando em tensor em vez de valor único."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a perda e preparar para retropropagação",
                                  "subSteps": [
                                    "Interprete o valor: perda baixa indica bom ajuste; alta sugere necessidade de treinamento.",
                                    "Visualize a perda em gráfico para um batch ou época.",
                                    "Retorne o tensor de perda para o otimizador calcular gradientes automaticamente.",
                                    "Teste com dados conhecidos para validar (ex: pred=real → perda=0).",
                                    "Documente o valor para análise posterior em problemas de engenharia."
                                  ],
                                  "verification": "Execute backprop e confirme que gradientes são computados sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráficos com Matplotlib",
                                    "Otimizador como Adam em PyTorch"
                                  ],
                                  "tips": "Monitore perda em treino vs. validação para detectar overfitting.",
                                  "learningObjective": "Avaliar a significância da perda e integrá-la ao ciclo de treinamento.",
                                  "commonMistakes": [
                                    "Ignorar NaN ou Inf na perda devido a divisões por zero."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede neural para prever resistência à compressão de concreto (regressão): predições = [30.5, 35.2] MPa, targets = [32.0, 33.0] MPa. MSE = [(30.5-32)^2 + (35.2-33)^2]/2 = (2.25 + 5.29)/2 ≈ 3.77 MPa². Implemente em PyTorch: loss_fn = nn.MSELoss(); loss = loss_fn(predictions, targets).",
                              "finalVerifications": [
                                "Calcula MSE manualmente para um vetor de 5 predições e targets com precisão de 4 casas decimais.",
                                "Implementa Cross-Entropy para classificação binária de falhas estruturais em código funcional.",
                                "Explica a diferença entre MSE e Cross-Entropy em contexto de engenharia civil.",
                                "Verifica que perda é zero quando predições iguais a targets.",
                                "Integra perda em loop de treinamento sem erros de gradientes.",
                                "Gera gráfico de perda decrescente ao longo de épocas."
                              ],
                              "assessmentCriteria": [
                                "Escolha correta da função de perda baseada no problema (25%)",
                                "Precisão no cálculo da perda (manual e código) (30%)",
                                "Correta manipulação de batches e shapes (20%)",
                                "Interpretação adequada do valor da perda (15%)",
                                "Integração perfeita com retropropagação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de derivadas para gradientes da perda.",
                                "Estatística: Medidas de erro e variância em predições.",
                                "Programação: Manipulação de tensores em Python/NumPy.",
                                "Engenharia Civil: Aplicação em modelagem preditiva de materiais e estruturas."
                              ],
                              "realWorldApplication": "Na engenharia civil, avaliar a função de perda em redes neurais permite otimizar modelos para prever deformações em pontes ou resistência de solos, minimizando erros em simulações e auxiliando decisões de projeto seguras e econômicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Retropropagação do Erro e Cálculo de Gradientes",
                        "description": "Propagação reversa do erro da saída para as camadas iniciais, utilizando a regra da cadeia para derivar gradientes parciais em relação aos pesos e biases.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Aplicar regra da cadeia para derivadas",
                            "description": "Derivar gradientes de erro em relação às ativações, pesos e entradas de cada camada, considerando funções de ativação diferenciáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Regra da Cadeia e Notação da Forward Pass",
                                  "subSteps": [
                                    "Defina a notação padrão para uma rede neural: entradas x, pesos W, biases b, ativações a = σ(z), onde z = W*a_prev + b.",
                                    "Escreva a função de perda L em termos da saída final ŷ.",
                                    "Revise a regra da cadeia: dL/dvar = dL/dnext * dnext/dvar para funções compostas.",
                                    "Identifique funções de ativação diferenciáveis comuns (sigmoid, ReLU, tanh) e suas derivadas.",
                                    "Desenhe o grafo computacional de uma rede com 1-2 camadas ocultas."
                                  ],
                                  "verification": "Consegue derivar manualmente dσ/dz para sigmoid e explicar o grafo computacional.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Tabela de derivadas de ativações"
                                  ],
                                  "tips": "Sempre anote as dependências de variáveis para visualizar o caminho da derivada.",
                                  "learningObjective": "Dominar a notação e regra da cadeia básica para composições em redes neurais.",
                                  "commonMistakes": [
                                    "Confundir ativação a com pré-ativação z.",
                                    "Esquecer derivada da perda em relação à saída."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Gradiente Local da Perda na Camada de Saída",
                                  "subSteps": [
                                    "Comece pela perda L e compute ∂L/∂a_L (gradiente w.r.t. ativação da última camada).",
                                    "Aplique chain rule: ∂L/∂z_L = ∂L/∂a_L * ∂a_L/∂z_L (derivada da ativação).",
                                    "Compute ∂L/∂W_L = ∂L/∂z_L * a_{L-1}^T e ∂L/∂b_L = ∂L/∂z_L.",
                                    "Verifique dimensionalidade: gradientes devem combinar com shapes de W e b.",
                                    "Teste com perda MSE: ∂L/∂ŷ = (ŷ - y)."
                                  ],
                                  "verification": "Calcula corretamente todos os gradientes locais para uma camada de saída com sigmoid.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Exemplo numérico simples (x=1, y=0)"
                                  ],
                                  "tips": "Use transposições corretas para outer products em gradientes de pesos.",
                                  "learningObjective": "Aplicar chain rule para gradientes w.r.t. pesos, biases e ativações na saída.",
                                  "commonMistakes": [
                                    "Erro em broadcast de biases.",
                                    "Inverter shapes em multiplicações matriciais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Propagar Gradientes Através de Camadas Ocultas",
                                  "subSteps": [
                                    "Para camada l: δ_l = ∂L/∂z_l = (W_{l+1}^T * δ_{l+1}) ⊙ σ'(z_l).",
                                    "Compute ∂L/∂W_l = δ_l * a_{l-1}^T e ∂L/∂b_l = δ_l.",
                                    "Propague δ_{l-1} = W_l^T * δ_l ⊙ σ'(z_{l-1}).",
                                    "Repita até a primeira camada, incluindo gradientes w.r.t. entradas se necessário.",
                                    "Registre todos os gradientes em uma tabela por camada."
                                  ],
                                  "verification": "Propaga δ corretamente de saída para entrada em uma rede de 2 camadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python (NumPy)",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use elemento-wise multiplication (⊙) para derivada da ativação.",
                                  "learningObjective": "Executar backpropagation completa usando chain rule em múltiplas camadas.",
                                  "commonMistakes": [
                                    "Esquecer multiplicação elemento-wise com σ'.",
                                    "Não transpor W ao propagar δ."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Implementar Numericamente",
                                  "subSteps": [
                                    "Implemente forward e backward pass em código Python com NumPy.",
                                    "Use finite differences para verificar gradientes analíticos: approx_grad = (f(θ+ε) - f(θ-ε))/(2ε).",
                                    "Compare gradientes analíticos vs. numéricos (erro < 1e-6).",
                                    "Teste com diferentes ativações (ReLU, sigmoid).",
                                    "Ajuste hiperparâmetros como learning rate para um passo de gradiente descendente."
                                  ],
                                  "verification": "Gradientes analíticos coincidem com numéricos em pelo menos 95% dos casos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python + NumPy",
                                    "Código template de rede simples"
                                  ],
                                  "tips": "Escolha ε ~ 1e-5 para finite differences; normalize para evitar underflow.",
                                  "learningObjective": "Validar aplicação da chain rule via verificação numérica e implementação.",
                                  "commonMistakes": [
                                    "ε muito pequeno causando NaNs.",
                                    "Não normalizar finite differences para vetores."
                                  ]
                                }
                              ],
                              "practicalExample": "Rede simples: 1 entrada x=2, camada oculta (W1=[0.5], b1=1, σ=sigmoid → z1=2, a1≈0.88), saída (W2=0.3, b2=-0.2 → z2≈0.064, a2≈0.517), perda MSE com y=1: L≈0.117. Compute δ2 = (0.517-1)*sigmoid'(0.064)≈ -0.24, W2_grad=δ2*a1≈-0.21, etc. Propague δ1=W2^T*δ2*sigmoid'(2)≈-0.12.",
                              "finalVerifications": [
                                "Calcula todos os gradientes (∂L/∂W, ∂L/∂b, ∂L/∂a) corretamente para cada camada.",
                                "Propagação de δ através da rede sem erros dimensionais.",
                                "Verificação numérica confirma gradientes analíticos (erro < 1e-4).",
                                "Implementação em código reproduz forward/backward pass manual.",
                                "Ajusta pesos com gradientes e observa redução na perda.",
                                "Explica verbalmente o papel da chain rule em cada derivada."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: derivadas corretas em 100% dos componentes.",
                                "Compreensão conceitual: explica chain rule sem erros em grafo computacional.",
                                "Habilidade computacional: código funcional com verificação numérica.",
                                "Eficiência: tempo de convergência em simulação de treinamento.",
                                "Generalização: aplica a diferentes ativações e arquiteturas.",
                                "Documentação: tabela clara de gradientes por camada."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: regra da cadeia multivariável e gradientes.",
                                "Programação Numérica: implementação de autodiff manual em Python/NumPy.",
                                "Otimização: gradiente descendente em problemas de engenharia.",
                                "Estatística: minimização de erro quadrático médio em modelagem.",
                                "Engenharia Computacional: simulações em análise estrutural."
                              ],
                              "realWorldApplication": "Em engenharia civil, aplica backpropagation para treinar redes neurais que preveem deformações em estruturas sob carga, otimizando pesos para minimizar erros entre simulações FEM e dados reais, permitindo detecção precoce de falhas em pontes ou edifícios."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Computar gradientes locais por camada",
                            "description": "Calcular δ (delta de erro) para neurônios de saída e propagá-lo reversamente, multiplicando por pesos transpose e derivadas de ativação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular o delta de erro para a camada de saída",
                                  "subSteps": [
                                    "Calcule o erro na saída usando a função de perda (ex: MSE: (y_pred - y_true)^2 / 2).",
                                    "Compute a derivada da função de ativação na camada de saída (ex: sigmoid' = sigmoid*(1-sigmoid)).",
                                    "Multiplique o gradiente do erro pela derivada da ativação para obter δ_output = dL/dz_output.",
                                    "Armazene δ_output para cada neurônio da camada de saída.",
                                    "Verifique dimensionalidade: δ_output deve ter o mesmo shape que a saída."
                                  ],
                                  "verification": "Confira se δ_output = (y_pred - y_true) * activation_deriv(z_output) para regressão simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora ou Python com NumPy para um exemplo numérico simples.",
                                  "tips": "Use valores numéricos pequenos (ex: 2-3 neurônios) para facilitar cálculos manuais.",
                                  "learningObjective": "Dominar o cálculo inicial do gradiente de erro na camada de saída.",
                                  "commonMistakes": "Esquecer de multiplicar pela derivada da ativação; confundir perda com gradiente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Propagar o delta de erro para camadas ocultas",
                                  "subSteps": [
                                    "Obtenha os pesos transpose da camada seguinte (W_next.T).",
                                    "Multiplique δ da camada seguinte por W_next.T para obter o gradiente pré-derivada na camada atual.",
                                    "Aplique a derivada da ativação da camada atual: δ_hidden = (W_next.T * δ_next) * activation_deriv(z_current).",
                                    "Repita o processo reversamente para todas as camadas ocultas até a entrada.",
                                    "Registre δ para cada camada em uma lista ou array."
                                  ],
                                  "verification": "Para uma camada oculta, δ_hidden deve resultar em valores coerentes com o forward pass anterior.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou script Python com arrays NumPy representando pesos e ativações.",
                                  "tips": "Implemente em loop reverso: for layer in reversed(hidden_layers): delta[layer] = ...",
                                  "learningObjective": "Entender a propagação reversa do sinal de erro através das camadas.",
                                  "commonMistakes": "Usar pesos originais em vez de transpose; propagar na direção errada (forward em vez de backward)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar gradientes locais por camada",
                                  "subSteps": [
                                    "Para cada camada, multiplique δ da camada atual pela ativação da camada anterior (a_prev): grad_W = δ_current * a_prev.T.",
                                    "Calcule gradiente de bias: grad_b = δ_current (média ou soma por neurônio).",
                                    "Atualize gradientes locais: dL/dW_layer = outer_product(δ_current, a_prev).",
                                    "Armazene gradientes em formato matricial compatível com os pesos originais.",
                                    "Some gradientes sobre o batch se aplicável (grad_W /= batch_size)."
                                  ],
                                  "verification": "Gradientes devem ter shape (output_neurons, input_neurons) para cada camada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código Python com NumPy para operações matriciais (np.outer, np.dot).",
                                  "tips": "Use broadcasting NumPy para eficiência: grad_W = np.outer(delta_current, a_prev).",
                                  "learningObjective": "Calcular precisamente os gradientes parciais para atualização de pesos.",
                                  "commonMistakes": "Inverter dimensões no produto externo; esquecer normalização por batch."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e depurar os gradientes computados",
                                  "subSteps": [
                                    "Compare gradientes numéricos com gradientes analíticos para uma rede toy.",
                                    "Execute um forward + backward pass e verifique se perda diminui após update.",
                                    "Use gradient checking: approx_grad = (f(W+eps) - f(W-eps))/(2*eps) vs computed_grad.",
                                    "Visualize gradientes com heatmaps para detectar anomalias (NaNs, zeros).",
                                    "Teste com diferentes funções de ativação e perca."
                                  ],
                                  "verification": "Erro relativo entre gradientes numéricos e analíticos < 1e-7.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Script Python completo com NumPy/Matplotlib para gradient checking e plots.",
                                  "tips": "Escolha eps = 1e-4 para gradient check; foque em uma conexão peso específica.",
                                  "learningObjective": "Garantir correção e robustez dos gradientes locais calculados.",
                                  "commonMistakes": "Gradientes explodindo/vanishing devido a ativações erradas; não checar NaNs."
                                }
                              ],
                              "practicalExample": "Em uma rede para prever deformação em vigas de concreto (2 entradas: carga, comprimento; 3 neurônios ocultos ReLU; 1 saída linear). Forward: z_out = sigmoid(W_out * ReLU(W_hid * [carga, comp])); perda MSE=0.05. δ_out = (pred-0.1)*sigmoid'(z_out)=[-0.02]. Propague: δ_hid = (W_out.T * δ_out) * ReLU'(z_hid)=[0.01, -0.005, 0.03]. Grad_hid = outer(δ_hid, [carga, comp]).",
                              "finalVerifications": [
                                "δ_output corresponde exatamente à derivada da perda vezes derivada da ativação.",
                                "Todos δ_hidden propagados têm dimensões corretas e valores não-NaN.",
                                "Gradientes locais têm shape idêntico aos pesos correspondentes.",
                                "Gradient checking confirma precisão numérica (>99.9% match).",
                                "Perda diminui após uma iteração de update com esses gradientes.",
                                "Gradientes são zero onde esperado (ex: bias em ativação zero)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Cálculos manuais/código produzem δ e grads exatos (erro <1e-6).",
                                "Completude: Todos os gradientes por camada computados e armazenados corretamente.",
                                "Eficiência: Implementação usa operações matriciais vetoriais, não loops ineficientes.",
                                "Validação: Gradient checking implementado e passa em pelo menos 90% dos pesos.",
                                "Clareza: Código comentado explica cada multiplicação e propagação.",
                                "Robustez: Funciona com diferentes tamanhos de rede e ativações."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Derivadas parciais e chain rule diretamente aplicados.",
                                "Programação Computacional: Uso de NumPy para otimização matricial em Engenharia.",
                                "Otimização em Engenharia Civil: Gradientes para minimizar erros em simulações estruturais.",
                                "Estatística: Gradientes em regressão para previsão de falhas em materiais."
                              ],
                              "realWorldApplication": "Em análise estrutural civil, compute gradientes para treinar NNs que otimizam designs de pontes, prevendo tensões com dados de sensores IoT, ajustando pesos para minimizar erros de previsão e evitar colapsos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Armazenar gradientes para todas as conexões",
                            "description": "Manter matrizes de gradientes parciais para pesos e biases em cada camada, preparando para o ajuste via otimização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e mapear todas as conexões na rede neural",
                                  "subSteps": [
                                    "Liste todas as camadas da rede (entrada, ocultas, saída).",
                                    "Para cada camada, determine as dimensões dos pesos (W) e biases (b).",
                                    "Crie um dicionário ou lista para rastrear conexões: ex. {'layer1_W': shape, 'layer1_b': shape}.",
                                    "Verifique compatibilidade de shapes entre camadas adjacentes.",
                                    "Documente o mapa de conexões em um diagrama simples."
                                  ],
                                  "verification": "Mapa de conexões impresso com shapes corretos para todas as camadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notebook Jupyter, NumPy, papel e caneta para diagrama.",
                                  "tips": "Use np.shape() para confirmar dimensões dinamicamente.",
                                  "learningObjective": "Compreender a estrutura de conexões para alocação precisa de gradientes.",
                                  "commonMistakes": "Ignorar biases ou confundir shapes de entrada/saída."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar matrizes de gradientes parciais",
                                  "subSteps": [
                                    "Crie tensores zero com shapes idênticos aos pesos e biases de cada camada usando np.zeros().",
                                    "Armazene em um dicionário: gradients = {'layer1_W': np.zeros_like(W1), ...}.",
                                    "Inclua gradientes para todas as conexões (W e b por camada).",
                                    "Teste inicialização imprimindo shapes e valores iniciais (todos zeros).",
                                    "Garanta que o dicionário seja acessível globalmente ou passado como parâmetro."
                                  ],
                                  "verification": "Dicionário de gradientes impresso com shapes corretos e valores zero.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "NumPy, código da rede neural existente.",
                                  "tips": "Use np.zeros_like(weights) para herdar shapes automaticamente.",
                                  "learningObjective": "Criar estruturas de dados eficientes para acumular gradientes.",
                                  "commonMistakes": "Usar shapes errados ou esquecer inicializar biases."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e armazenar gradientes durante retropropagação",
                                  "subSteps": [
                                    "Comece pela camada de saída: compute dL/dA (delta) e armazene dL/dW = delta * A_prev.T, dL/db = delta.",
                                    "Propague erro para camadas ocultas: delta_prev = W_next.T * delta * sigmoid'(A_prev).",
                                    "Armazene gradientes parciais em gradients['layerX_W'] += dL/dW (acumulação para mini-batches).",
                                    "Repita para todas as camadas em loop reverso.",
                                    "Registre logs de valores de gradientes para depuração."
                                  ],
                                  "verification": "Gradientes preenchidos e não-zero após uma forward-backward pass simulada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código de retropropagação parcial, dados de exemplo (batch pequeno).",
                                  "tips": "Implemente acumulação += para múltiplas amostras; normalize por batch size depois.",
                                  "learningObjective": "Integrar cálculo de gradientes com armazenamento em tempo real.",
                                  "commonMistakes": "Erro na transposição de matrizes ou propagação errada de delta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e preparar gradientes para otimização",
                                  "subSteps": [
                                    "Verifique shapes e valores finitos (np.isfinite()) em todos os gradientes.",
                                    "Compare magnitudes: gradientes não devem explodir/vanir.",
                                    "Teste com gradiente numérico aproximado para uma conexão aleatória.",
                                    "Salve gradientes em arquivo para inspeção posterior.",
                                    "Prepare passagem para atualizador (ex: gradients prontos para SGD)."
                                  ],
                                  "verification": "Relatório de validação: todos shapes OK, valores finitos, match com numérico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Função de perda, otimizador simples, biblioteca de testes (pytest ou asserts).",
                                  "tips": "Use gradiente de verificação numérica: (loss(x+eps) - loss(x-eps))/(2*eps).",
                                  "learningObjective": "Garantir integridade dos gradientes antes do ajuste de parâmetros.",
                                  "commonMistakes": "Não detectar NaNs/Inf ou mismatch de shapes na validação."
                                }
                              ],
                              "practicalExample": "Em uma rede de 2 camadas para prever deformações em vigas (Engenharia Civil): entrada=10 features (cargas), camada oculta=5 neurônios, saída=1 (deformação). Após forward com batch de 32 vigas, backward calcula e armazena dL/dW1 (10x5), dL/dW2 (5x1), etc., acumulando gradientes para otimizar predições de falhas estruturais.",
                              "finalVerifications": [
                                "Todas as matrizes de gradientes têm shapes idênticos aos pesos/biases.",
                                "Valores de gradientes são finitos e não-zero após treinamento.",
                                "Gradientes acumulam corretamente em mini-batches (teste com 2 batches).",
                                "Validação numérica confirma precisão em pelo menos 90% das conexões.",
                                "Gradientes preparados sem erros para passo de otimização.",
                                "Logs mostram propagação correta através de todas as camadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na inicialização: 100% shapes corretos.",
                                "Correção no cálculo: erro <1e-4 vs. numérico em 80% conexões.",
                                "Eficiência: tempo de backward <2x forward em rede pequena.",
                                "Robustez: lida com NaNs e shapes variados.",
                                "Documentação: código comentado e mapa de conexões claro.",
                                "Integração: funciona seamless com otimizador SGD/Adam."
                              ],
                              "crossCurrularConnections": [
                                "Matemática: Cálculo multivariável e derivadas parciais.",
                                "Programação: Estruturas de dados (dicionários, tensores) em Python/NumPy.",
                                "Engenharia Civil: Otimização de modelos preditivos para estruturas.",
                                "Estatística: Gradientes em aprendizado estatístico e minimização de perda."
                              ],
                              "realWorldApplication": "Em simulações de engenharia civil, armazena gradientes para treinar redes neurais que otimizam designs de pontes/predizem falhas em barragens, ajustando pesos para minimizar erros em predições de tensões sob cargas reais, economizando tempo em análises iterativas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Ajuste de Pesos via Descida de Gradiente",
                        "description": "Atualização iterativa dos parâmetros da rede usando gradientes computados, com taxa de aprendizado para minimizar a função de perda.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Implementar descida de gradiente estocástico",
                            "description": "Atualizar pesos como w_new = w_old - η * ∇w, onde η é a taxa de aprendizado e ∇w o gradiente médio ou por amostra.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar a rede neural, hiperparâmetros e dataset",
                                  "subSteps": [
                                    "Carregue o dataset de treinamento (ex: dados de deformações estruturais em engenharia civil).",
                                    "Inicialize os pesos da rede com valores aleatórios pequenos (ex: Xavier initialization).",
                                    "Defina a taxa de aprendizado η (ex: 0.01) e outros hiperparâmetros como número de epochs.",
                                    "Prepare o dataloader para amostragem aleatória de uma instância por vez.",
                                    "Defina a função de perda (ex: MSE para regressão de cargas estruturais)."
                                  ],
                                  "verification": "Verifique se pesos são arrays NumPy com dimensões corretas e η é um float positivo; imprima shapes e valores iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "Dataset CSV de engenharia civil (ex: concreto ou deformações)"
                                  ],
                                  "tips": "Use np.random.seed(42) para reprodutibilidade; normalize features para estabilidade.",
                                  "learningObjective": "Compreender e configurar os componentes iniciais para SGD em uma RNA.",
                                  "commonMistakes": [
                                    "Inicializar pesos com zeros (causa simetria)",
                                    "Escolher η muito alta sem normalização",
                                    "Ignorar shapes incompatíveis entre camadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar forward propagation em uma amostra estocástica",
                                  "subSteps": [
                                    "Selecione uma amostra aleatória do dataset usando np.random.choice.",
                                    "Compute ativações forward: z1 = X * W1 + b1, a1 = sigmoid(z1), etc., até a saída ŷ.",
                                    "Calcule a perda L = loss(ŷ, y_true) para essa amostra.",
                                    "Armazene ativações intermediárias para uso no backprop.",
                                    "Repita para confirmar forward em múltiplas amostras."
                                  ],
                                  "verification": "Imprima ŷ e y_true; verifique se perda é um escalar positivo e forward produz saídas no range esperado (ex: [0,1] para sigmoid).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Funções de ativação (sigmoid, ReLU) implementadas"
                                  ],
                                  "tips": "Evite loops desnecessários; use broadcasting NumPy para eficiência.",
                                  "learningObjective": "Executar forward pass corretamente para computar predições e perda por amostra.",
                                  "commonMistakes": [
                                    "Erro em broadcasting de bias",
                                    "Não armazenar ativações para backprop",
                                    "Usar toda a batch em vez de uma amostra"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular gradiente via backpropagation para a amostra",
                                  "subSteps": [
                                    "Inicie backprop da saída: δL/δŷ = (ŷ - y_true) * derivada_ativação(ŷ).",
                                    "Propague δ para camadas anteriores: δL/δz_l = δL/δa_l * derivada_ativação(z_l).",
                                    "Compute gradientes de pesos: ∇W_l = a_{l-1}^T * δL/δz_l.",
                                    "Compute gradientes de bias: ∇b_l = mean(δL/δz_l, axis=0).",
                                    "Zere gradientes acumulados antes de cada backprop por amostra."
                                  ],
                                  "verification": "Imprima gradientes; verifque se têm shapes corretas (ex: ∇W1 shape == W1 shape) e magnitudes razoáveis (não NaN/inf).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "Funções derivadas de ativações"
                                  ],
                                  "tips": "Use transposições corretas (.T); debug com dataset toy 1D primeiro.",
                                  "learningObjective": "Derivar e computar gradientes locais estocásticos via chain rule.",
                                  "commonMistakes": [
                                    "Não zerar gradientes entre amostras",
                                    "Erro na ordem de propagação backward",
                                    "Confundir δz e δW"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Atualizar pesos com fórmula SGD e iterar",
                                  "subSteps": [
                                    "Atualize pesos: W_new = W_old - η * ∇W; similar para bias.",
                                    "Execute um loop de epochs: para cada epoch, amostre todas as instâncias uma vez (shuffle).",
                                    "Monitore perda média por epoch e plote curvas de convergência.",
                                    "Implemente early stopping se perda não diminui.",
                                    "Salve modelo final e teste em validação."
                                  ],
                                  "verification": "Verifique se pesos mudam após update (norm(W_new - W_old) > 0); perda média diminui em epochs iniciais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código completo anterior",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": "Comece com η pequena; ajuste com scheduler se oscilar.",
                                  "learningObjective": "Implementar update estocástico e controlar convergência da otimização.",
                                  "commonMistakes": [
                                    "η muito grande causa divergência",
                                    "Não shuffle dataset (overfit ordem)",
                                    "Atualizar com gradiente médio em vez de por amostra"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de propriedades de concreto (features: cimento, água, idade; target: resistência à compressão), implemente SGD para treinar uma RNA de 1 camada oculta. Após 100 epochs, a perda cai de 150 para 20, prevendo resistência com erro <10%. Código NumPy completo simula otimização para design de misturas otimizadas em engenharia civil.",
                              "finalVerifications": [
                                "Pesos atualizam corretamente sem NaN/inf após 10 updates.",
                                "Perda diminui monotonicamente em 80% das epochs iniciais.",
                                "Gradientes têm shapes e magnitudes consistentes com forward.",
                                "Predições em conjunto de teste têm MSE < threshold inicial.",
                                "Código roda em <5s por epoch para dataset de 1000 amostras.",
                                "Shuffle previne padrões de perda cíclica."
                              ],
                              "assessmentCriteria": [
                                "Correção da fórmula SGD: uso preciso de η * ∇w por amostra.",
                                "Eficiência computacional: vetorização NumPy sem loops Python lentos.",
                                "Convergência demonstrada: plots de loss com declínio estável.",
                                "Robustez: lida com datasets variados sem crashes.",
                                "Documentação: comentários explicam cada gradiente e update.",
                                "Escalabilidade: adapta a múltiplas camadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e otimização não-linear.",
                                "Programação: Vetorização e debugging numérico em Python.",
                                "Estatística: Amostragem estocástica e variância de gradientes.",
                                "Engenharia Civil: Otimização de parâmetros em simulações estruturais.",
                                "Física: Analogia com dinâmica de partículas em gradientes de energia."
                              ],
                              "realWorldApplication": "Na engenharia civil, SGD treina RNAs para prever falhas em pontes (baseado em sensores IoT), otimizar alocações de materiais em construções sustentáveis ou simular respostas sísmicas, reduzindo custos de protótipos físicos em 30-50% via aprendizado rápido em grandes datasets de simulações FEM."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Configurar hiperparâmetros de treinamento",
                            "description": "Escolher e ajustar taxa de aprendizado, momentum ou variantes como Adam, monitorando convergência em problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Selecionar Hiperparâmetros Relevantes",
                                  "subSteps": [
                                    "Revise os hiperparâmetros principais: taxa de aprendizado (learning rate), momentum, beta1/beta2 para Adam.",
                                    "Identifique o impacto de cada um na convergência: learning rate alto causa oscilação, baixo causa lentidão.",
                                    "Escolha valores iniciais baseados em literatura: learning rate 0.001-0.1, momentum 0.9, Adam betas (0.9, 0.999).",
                                    "Relacione com problemas de engenharia civil, como previsão de deformações em vigas.",
                                    "Documente escolhas iniciais em um log."
                                  ],
                                  "verification": "Lista de hiperparâmetros selecionados com justificativas documentadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação TensorFlow/PyTorch, artigos sobre otimizadores (ex: Kingma & Ba para Adam).",
                                  "tips": "Comece com Adam para robustez em datasets ruidosos de engenharia civil.",
                                  "learningObjective": "Compreender o papel de cada hiperparâmetro na descida de gradiente.",
                                  "commonMistakes": "Ignorar escala de features, levando a learning rates inadequados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Ambiente e Dataset para Experimentos",
                                  "subSteps": [
                                    "Carregue um dataset de engenharia civil, como previsão de resistência de concreto (UCI Concrete Compressive Strength).",
                                    "Pré-processe dados: normalize features, divida em train/validation/test (70/15/15).",
                                    "Defina arquitetura de NN simples: 2-3 camadas densas para o problema.",
                                    "Configure callbacks para monitorar loss e accuracy em TensorFlow/PyTorch.",
                                    "Implemente logging de métricas como loss por epoch e gradientes."
                                  ],
                                  "verification": "Dataset carregado e modelo baseline rodando uma epoch sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python, TensorFlow ou PyTorch, dataset UCI Concrete (disponível online).",
                                  "tips": "Use MinMaxScaler para normalização em dados de engenharia com escalas variadas.",
                                  "learningObjective": "Configurar pipeline reprodutível para testes de hiperparâmetros.",
                                  "commonMistakes": "Não dividir dados corretamente, causando vazamento de validação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Treinamentos Iniciais e Monitorar Convergência",
                                  "subSteps": [
                                    "Treine com configurações iniciais por 50-100 epochs, plotando curvas de loss/train-val.",
                                    "Monitore sinais de convergência: loss decrescente estável, sem explosão ou platô prematuro.",
                                    "Compare SGD com momentum vs. Adam em runs paralelas.",
                                    "Registre métricas: tempo de convergência, loss final, validação accuracy.",
                                    "Salve modelos e plots para análise."
                                  ],
                                  "verification": "Plots de loss mostrando padrões de convergência para pelo menos 3 runs.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Jupyter Notebook, Matplotlib/Seaborn para plots.",
                                  "tips": "Use TensorBoard para visualização interativa de métricas.",
                                  "learningObjective": "Identificar padrões de convergência ruins via monitoramento.",
                                  "commonMistakes": "Treinar poucas epochs, mascarando problemas de learning rate."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar Iterativamente e Otimizar Hiperparâmetros",
                                  "subSteps": [
                                    "Ajuste learning rate: reduza se oscilante (divida por 10), aumente se lenta.",
                                    "Teste momentum (0.8-0.99) ou Adam params, re-treinando e comparando.",
                                    "Use grid/random search para 5-10 combinações, priorizando validação loss.",
                                    "Pare early se loss não melhorar por 10 epochs (EarlyStopping).",
                                    "Selecione a configuração com melhor generalização (menor val loss)."
                                  ],
                                  "verification": "Tabela comparativa de runs com hiperparâmetros, losses e tempos.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": "Scikit-learn para grid search, ou Optuna para automação.",
                                  "tips": "Log escala para learning rate em buscas para cobrir ordens de magnitude.",
                                  "learningObjective": "Aplicar ajustes baseados em evidências empíricas.",
                                  "commonMistakes": "Overfitting a validação sem teste final independente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Documentar Configuração Final",
                                  "subSteps": [
                                    "Treine modelo final no dataset completo com melhores hiperparâmetros.",
                                    "Avalie em conjunto de teste: compute métricas como MAE para previsão de resistência.",
                                    "Compare com baseline não otimizado.",
                                    "Documente processo completo: escolhas, ajustes e razões.",
                                    "Teste sensibilidade: varie um hiperparâmetro e observe impacto."
                                  ],
                                  "verification": "Relatório final com métricas de teste e plots comparativos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmo ambiente anterior.",
                                  "tips": "Sempre valide em hold-out test para real generalização.",
                                  "learningObjective": "Garantir robustez da configuração em cenários reais.",
                                  "commonMistakes": "Não testar sensibilidade, assumindo otimalidade única."
                                }
                              ],
                              "practicalExample": "Usando dataset UCI Concrete Compressive Strength, configure hiperparâmetros para uma NN prevendo resistência à compressão a partir de 8 features (cimento, água, etc.). Ajuste learning rate de 0.01 para 0.001 com Adam, alcançando MAE < 5 MPa em 50 epochs, simulando otimização para controle de qualidade em obras civis.",
                              "finalVerifications": [
                                "Curvas de loss mostram convergência estável sem oscilações ou divergência.",
                                "Validação loss < 10% maior que train loss (sem overfitting).",
                                "Tempo de convergência reduzido em pelo menos 20% após ajustes.",
                                "MAE ou RMSE no teste dentro de tolerância de engenharia (ex: <5% erro relativo).",
                                "Documentação completa com tabelas e plots reproduzíveis.",
                                "Modelo sensível apenas a variações pequenas em hiperparâmetros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção inicial de hiperparâmetros com justificativas teóricas.",
                                "Monitoramento completo de métricas com visualizações claras.",
                                "Ajustes iterativos baseados em evidências, não aleatórios.",
                                "Melhoria mensurável em convergência e performance final.",
                                "Aplicação contextualizada a problemas de engenharia civil.",
                                "Ausência de erros comuns como não normalizar dados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização estocástica e análise de gradientes.",
                                "Estatística: Análise de curvas de aprendizado e validação cruzada.",
                                "Programação: Implementação eficiente em Python/ML frameworks.",
                                "Engenharia Civil: Modelagem preditiva para materiais e estruturas."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, otimizar hiperparâmetros permite treinar NNs para prever falhas em pontes ou solos, reduzindo tempo de simulação de dias para horas, integrando em softwares BIM para decisões em tempo real durante construção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Executar épocas completas de treinamento",
                            "description": "Iterar forward, backward e update sobre dataset de treinamento, avaliando perda e precisão em validação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar e inicializar o loop de épocas de treinamento",
                                  "subSteps": [
                                    "Definir o número total de épocas (ex: num_epochs = 100).",
                                    "Inicializar listas vazias para armazenar losses e accuracies de treinamento e validação (ex: train_losses = []).",
                                    "Configurar o dispositivo (CPU ou GPU) e mover modelo e dados para ele.",
                                    "Definir o modelo para modo de treinamento (model.train()).",
                                    "Preparar otimizador e scheduler, se aplicável."
                                  ],
                                  "verification": "Verificar se as listas de métricas estão vazias, o modelo está em modo train() e o otimizador está inicializado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com PyTorch ou TensorFlow",
                                    "Dataset de treinamento e validação carregados",
                                    "DataLoaders configurados"
                                  ],
                                  "tips": "Use tqdm para adicionar uma barra de progresso no loop de épocas.",
                                  "learningObjective": "Compreender a preparação inicial necessária antes de iniciar as iterações de treinamento.",
                                  "commonMistakes": "Esquecer de definir model.train(), o que impede o uso de dropout e batchnorm corretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar forward, backward e update nos batches de treinamento",
                                  "subSteps": [
                                    "Iterar sobre os batches do DataLoader de treinamento.",
                                    "Zerar os gradientes do otimizador (optimizer.zero_grad()).",
                                    "Realizar forward pass com os dados de entrada.",
                                    "Calcular a perda (loss) entre predições e targets.",
                                    "Executar backward pass (loss.backward()).",
                                    "Atualizar os pesos (optimizer.step()) e acumular métricas de perda e precisão."
                                  ],
                                  "verification": "Observar que a perda média de treinamento diminui ao final da época.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "DataLoader de treinamento",
                                    "Função de perda (ex: CrossEntropyLoss)",
                                    "Otimizador (ex: Adam)"
                                  ],
                                  "tips": "Monitore a perda a cada 10 batches para depuração rápida.",
                                  "learningObjective": "Dominar o ciclo completo de um passo de treinamento em uma época.",
                                  "commonMistakes": "Esquecer optimizer.zero_grad(), causando acúmulo de gradientes e instabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar o modelo no conjunto de validação",
                                  "subSteps": [
                                    "Definir o modelo para modo de avaliação (model.eval()).",
                                    "Desabilitar cálculo de gradientes (with torch.no_grad():).",
                                    "Iterar sobre os batches do DataLoader de validação.",
                                    "Realizar forward pass e calcular perda e precisão.",
                                    "Acumular métricas e calcular as médias para a época."
                                  ],
                                  "verification": "Calcular e registrar perda e precisão médias de validação para a época atual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "DataLoader de validação",
                                    "Mesmo modelo e função de perda"
                                  ],
                                  "tips": "Sempre use no_grad() em avaliação para economizar memória e tempo.",
                                  "learningObjective": "Aprender a avaliar o desempenho sem atualizar pesos.",
                                  "commonMistakes": "Manter o modelo em modo train() durante avaliação, ativando dropout desnecessariamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Registrar métricas e monitorar convergência",
                                  "subSteps": [
                                    "Adicionar as métricas de train e val às listas respectivas.",
                                    "Imprimir ou logar as métricas da época atual.",
                                    "Visualizar curvas de perda e precisão usando matplotlib.",
                                    "Verificar critérios de parada precoce (early stopping) se a perda de val não melhorar.",
                                    "Salvar o melhor modelo baseado na métrica de validação."
                                  ],
                                  "verification": "Gerar gráficos mostrando redução de perda e estabilização de precisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca matplotlib ou tensorboard",
                                    "Listas de métricas acumuladas"
                                  ],
                                  "tips": "Logue métricas a cada 5-10 épocas para evitar spam no console.",
                                  "learningObjective": "Monitorar o progresso do treinamento e detectar overfitting.",
                                  "commonMistakes": "Treinar indefinidamente sem early stopping, desperdiçando recursos."
                                }
                              ],
                              "practicalExample": "Em um dataset de sensores de vibração em pontes (Engenharia Civil), carregue 1000 amostras de treinamento e 200 de validação. Execute 50 épocas com learning rate 0.001: observe perda de treinamento cair de 1.2 para 0.15 e precisão de validação subir para 91%, plotando as curvas para confirmar convergência.",
                              "finalVerifications": [
                                "O loop completou todas as épocas sem erros de runtime.",
                                "Perda de treinamento diminuiu consistentemente (redução > 50%).",
                                "Precisão de validação estabilizou acima de 85%.",
                                "Diferença entre train e val (gap) menor que 10% para evitar overfitting.",
                                "Gráficos de loss/acc gerados e salvos corretamente.",
                                "Melhor modelo salvo baseado em métrica de validação."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta do loop de épocas e batches (30%).",
                                "Execução precisa de forward, backward e update (25%).",
                                "Avaliação adequada no conjunto de validação (20%).",
                                "Registro e visualização de métricas (15%).",
                                "Manejo de convergência e early stopping (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de gradientes e otimização via descida de gradiente.",
                                "Estatística: Cálculo de perda (ex: MSE) e métricas de precisão.",
                                "Programação: Estruturas de loops aninhados e gerenciamento de memória.",
                                "Engenharia Civil: Aplicação em previsão de deformações estruturais."
                              ],
                              "realWorldApplication": "Na engenharia civil, treinar redes neurais para prever cargas em estruturas de concreto armado a partir de dados de sensores IoT, executando épocas completas até convergência para um modelo que alerta sobre falhas potenciais em pontes ou edifícios em tempo real."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.4",
                            "name": "Evitar problemas numéricos no treinamento",
                            "description": "Lidar com vanishing/exploding gradients usando normalização ou clipping, relacionando com condicionamento matricial e autovalores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os problemas de vanishing e exploding gradients",
                                  "subSteps": [
                                    "Estude a retropropagação e como os gradients são multiplicados através das camadas.",
                                    "Identifique vanishing gradients como gradients próximos de zero em camadas iniciais.",
                                    "Identifique exploding gradients como gradients muito grandes causando instabilidade.",
                                    "Simule um exemplo simples em uma rede profunda sem técnicas de mitigação.",
                                    "Analise o impacto na convergência do treinamento."
                                  ],
                                  "verification": "Plotar curvas de loss e gradients magnitudes ao longo das épocas; verificar se loss não diminui ou explode.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Jupyter Notebook, PyTorch ou TensorFlow, dataset simples como MNIST adaptado para regressão.",
                                  "tips": "Use log scale nos plots de gradients para visualizar melhor extremos.",
                                  "learningObjective": "Explicar mecanicamente como multiplicações repetidas de Jacobianas causam vanishing/exploding.",
                                  "commonMistakes": "Confundir com overfitting/underfitting; ignorar profundidade da rede."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Relacionar problemas com condicionamento matricial e autovalores",
                                  "subSteps": [
                                    "Revise condicionamento de matrizes: kappa = |λ_max / λ_min| onde λ são autovalores.",
                                    "Calcule autovalores das matrizes de pesos em uma rede simples.",
                                    "Explique como autovalores >1 propagam exploding e <1 causam vanishing.",
                                    "Implemente análise de autovalores em uma camada fully connected.",
                                    "Discuta inicializações como Xavier/He que controlam espectro de autovalores."
                                  ],
                                  "verification": "Calcular e plotar autovalores; verificar se kappa > 1000 indica mau condicionamento.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "NumPy, SciPy para eigen decomposition, notebook com rede toy.",
                                  "tips": "Use np.linalg.eig para autovalores; foque em magnitude absoluta.",
                                  "learningObjective": "Conectar estabilidade numérica de gradients com propriedades espectrais das matrizes de pesos.",
                                  "commonMistakes": "Esquecer normalizar autovalores; confundir com singular values."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar gradient clipping para mitigar exploding gradients",
                                  "subSteps": [
                                    "Configure um threshold global ou por norma (ex: clip_norm=1.0).",
                                    "Aplique torch.nn.utils.clip_grad_norm_ ou equivalente em TensorFlow.",
                                    "Treine uma rede profunda propensa a exploding e compare com/ sem clipping.",
                                    "Monitore normas de gradients antes/depois do clipping.",
                                    "Ajuste o threshold baseado em experimentos empíricos."
                                  ],
                                  "verification": "Gradients norms estabilizam abaixo do threshold; loss converge sem NaNs.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "PyTorch/TensorFlow, GPU opcional, dataset de simulação estrutural simples.",
                                  "tips": "Comece com clip_norm=0.5 e aumente gradualmente; logue norms a cada batch.",
                                  "learningObjective": "Aplicar clipping para forçar gradients em uma esfera de raio controlado.",
                                  "commonMistakes": "Clippar demais causa underflow; não monitorar pré-clip."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar normalização de gradients e verificação integrada",
                                  "subSteps": [
                                    "Implemente gradient centralization ou normalization por layer.",
                                    "Combine com batch normalization nas ativações para controle indireto.",
                                    "Treine rede completa relacionando com condicionamento melhorado.",
                                    "Compare métricas: loss, gradient flow (via wandb ou tensorboard).",
                                    "Teste em contexto civil: prever tensões em vigas com dados simulados."
                                  ],
                                  "verification": "Autovalores estabilizam (kappa < 100); gradients fluem uniformemente por camadas.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Bibliotecas DL, dataset sintético de engenharia (ex: FEM outputs).",
                                  "tips": "Use gradient flow visualization como histogramas por layer.",
                                  "learningObjective": "Integrar múltiplas técnicas para treinamento numéricamente estável.",
                                  "commonMistakes": "Não recalcular autovalores pós-treinamento; ignorar batch size effects."
                                }
                              ],
                              "practicalExample": "Em uma rede neural para prever deformações em estruturas de concreto sob carga, sem técnicas: gradients explodem após 5 épocas causando NaNs. Com clipping (norm=1.0) e análise de autovalores (kappa reduz de 10^4 para 50), o modelo converge em 20 épocas com MAE < 0.01.",
                              "finalVerifications": [
                                "Gradients magnitudes estáveis entre 1e-4 e 1e1 por todas camadas.",
                                "Loss converge monotonicamente sem oscilações extremas.",
                                "Condicionamento matricial (kappa) < 100 em matrizes de pesos finais.",
                                "Sem NaNs ou Infs nos logs de treinamento.",
                                "Grad flow homogêneo: var(grad_layer_i) similar para i=1 a L.",
                                "Modelo generaliza em validação sem degradação numérica."
                              ],
                              "assessmentCriteria": [
                                "Explicação precisa de vanishing/exploding via autovalores (80% acerto em quiz).",
                                "Implementação correta de clipping com threshold otimizado (loss < baseline).",
                                "Análise quantitativa de condicionamento pré/pós (redução >50%).",
                                "Código reproduzível e comentado com plots de verificação.",
                                "Aplicação contextualizada a problema civil com resultados mensuráveis.",
                                "Identificação de 3+ erros comuns evitados no relatório."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores e decomposição espectral.",
                                "Análise Numérica: estabilidade e condicionamento de algoritmos iterativos.",
                                "Engenharia Civil: simulações FEM onde redes substituem solvers caros.",
                                "Estatística: controle de variância em otimização estocástica."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, como otimização de projetos de pontes via redes neurais surrogate para FEM, evitando crashes numéricos permite treinar modelos robustos para simular milhares de cenários de carga, acelerando iterações de design e reduzindo custos computacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Aplicações em Engenharia Civil",
                    "description": "Uso em previsão de falhas estruturais, otimização de projetos e análise de dados geotécnicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Previsão de Falhas Estruturais",
                        "description": "Aplicação de redes neurais artificiais (RNAs) para prever falhas em estruturas civis, utilizando dados de sensores e simulações numéricas para identificar padrões de degradação e riscos de colapso, integrando métodos como solução de equações não-lineares e ajuste de curvas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Identificar padrões de falhas com RNAs",
                            "description": "Analisar dados de tensões e deformações em estruturas para treinar RNAs que detectem anomalias, relacionando com métodos numéricos como problemas de valor inicial e autovalores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e Pré-processamento de Dados de Tensões e Deformações",
                                  "subSteps": [
                                    "Identifique fontes de dados como sensores IoT em estruturas civis (ex: strain gauges, acelerômetros).",
                                    "Colete dados históricos de tensões (σ) e deformações (ε) de estruturas reais ou simuladas.",
                                    "Limpe os dados removendo outliers, normalizando valores (ex: min-max scaling) e lidando com valores ausentes via interpolação.",
                                    "Crie labels para anomalias baseadas em thresholds físicos (ex: σ > limite de escoamento).",
                                    "Divida o dataset em treino (70%), validação (15%) e teste (15%)."
                                  ],
                                  "verification": "Dataset pré-processado salvo em formato CSV com colunas limpas, labels balanceados e splits verificados via shapes.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Sensores simulados ou datasets públicos (Kaggle), Python (Pandas, NumPy), Jupyter Notebook.",
                                  "tips": "Use visualizações (histograms, boxplots) para identificar anomalias antes do pré-processamento.",
                                  "learningObjective": "Dominar preparação de dados estruturais para input em RNAs.",
                                  "commonMistakes": "Ignorar desbalanceamento de classes (anomalias raras), escalando incorretamente features com unidades diferentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construção e Treinamento da Rede Neural Artificial",
                                  "subSteps": [
                                    "Defina arquitetura: camadas densas (input: features de σ/ε, hidden: 64-128 neurônios, output: classificação binária anomalia/normal).",
                                    "Escolha otimizador (Adam), loss (Binary Crossentropy) e métricas (Precision, Recall, F1-score).",
                                    "Treine o modelo com early stopping e batch size 32-64 por 50-100 épocas.",
                                    "Ajuste hiperparâmetros via grid search na validação (learning rate, dropout).",
                                    "Avalie no conjunto de teste plotando confusion matrix e ROC curve."
                                  ],
                                  "verification": "Modelo treinado com accuracy >85% no teste, métricas salvas e curvas de perda convergentes.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": "TensorFlow/Keras ou PyTorch, GPU opcional, datasets do Step 1.",
                                  "tips": "Implemente dropout (0.2-0.5) para evitar overfitting em datasets pequenos.",
                                  "learningObjective": "Construir e otimizar RNAs para detecção de anomalias em dados estruturais.",
                                  "commonMistakes": "Overfitting sem validação cruzada, ignorar recall para anomalias raras."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integração com Métodos Numéricos: Problemas de Valor Inicial e Autovalores",
                                  "subSteps": [
                                    "Modele equações diferenciais de valor inicial (ex: dε/dt = f(σ)) para simular dinâmicas estruturais.",
                                    "Calcule autovalores de matrizes de rigidez (K) para modos de vibração e falhas (ex: autovalor negativo indica instabilidade).",
                                    "Use outputs da RNA como features adicionais nos solvers numéricos (ex: Runge-Kutta para IVP).",
                                    "Compare predições da RNA com soluções analíticas/numéricas para validar detecções.",
                                    "Extraia padrões: agrupe anomalias por autovalores dominantes."
                                  ],
                                  "verification": "Relatório comparando predições RNA vs. métodos numéricos com erro <10%, autovalores computados corretamente.",
                                  "estimatedTime": "5-7 horas",
                                  "materials": "SciPy (solve_ivp, eig), MATLAB opcional, modelo RNA do Step 2.",
                                  "tips": "Normalizar autovalores para scales compatíveis com inputs da RNA.",
                                  "learningObjective": "Relacionar RNAs com análise numérica para previsão de falhas.",
                                  "commonMistakes": "Confundir autovalores com autovetores, não sincronizar time-steps entre simulações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise e Identificação de Padrões de Falhas",
                                  "subSteps": [
                                    "Aplique o modelo integrado a novos dados para gerar heatmaps de anomalias.",
                                    "Clusterize padrões usando K-means em features (σ, ε, autovalores).",
                                    "Interprete resultados: identifique padrões como 'fadiga por vibração alta' ou 'concentração de tensão'.",
                                    "Gere relatórios com visualizações (SHAP para explainability).",
                                    "Teste robustez com dados ruidosos ou variações ambientais."
                                  ],
                                  "verification": "Padrões identificados documentados com clusters distintos e explainability plots.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Scikit-learn (KMeans, SHAP), Matplotlib/Seaborn, modelo final.",
                                  "tips": "Use feature importance da RNA para priorizar padrões críticos.",
                                  "learningObjective": "Extrair insights acionáveis de predições de RNAs em contextos civis.",
                                  "commonMistakes": "Sobreinterpretar clusters pequenos, ignorar contexto físico dos padrões."
                                }
                              ],
                              "practicalExample": "Em uma ponte estaiada, colete dados de strain gauges; treine RNA para detectar anomalias em cabos; integre com autovalores da matriz de massa/rigidez para prever colapso por flutter; identifique padrão 'vibração excessiva em ventos fortes'.",
                              "finalVerifications": [
                                "RNA atinge F1-score >0.90 em detecção de anomalias.",
                                "Padrões de falhas correlacionam com autovalores físicos conhecidos.",
                                "Simulações numéricas validam predições com erro médio <5%.",
                                "Heatmaps destacam regiões críticas em estruturas simuladas.",
                                "Modelo resiste a 20% de ruído nos dados de entrada.",
                                "Relatório inclui 3+ padrões distintos com exemplos reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação de dados (balanceamento e limpeza).",
                                "Desempenho do modelo RNA (métricas de validação).",
                                "Correção na integração numérica (autovalores e IVPs).",
                                "Qualidade da interpretação de padrões (explainability).",
                                "Robustez e generalização do pipeline completo.",
                                "Clareza do relatório e visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores), EDOs de valor inicial.",
                                "Programação: Machine Learning (Keras), Análise Numérica (SciPy).",
                                "Estatística: Validação de modelos, clustering.",
                                "Física: Mecânica dos sólidos, dinâmica estrutural."
                              ],
                              "realWorldApplication": "Monitoramento preditivo de pontes e edifícios (ex: sistema SHM em Golden Gate Bridge), prevenindo colapsos como em Morandi (2018) via detecção precoce de fadiga em cabos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Treinar modelo de previsão de falhas",
                            "description": "Implementar uma RNA feedforward para prever falhas em vigas ou lajes, utilizando bibliotecas como MATLAB ou Python, com otimização via programação matemática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação e Exploração dos Dados",
                                  "subSteps": [
                                    "Coletar dataset de falhas estruturais (ex: cargas aplicadas, dimensões de vigas/lajes, propriedades de materiais, labels de falha/sucesso).",
                                    "Limpar dados: tratar valores ausentes, outliers e normalizar features (ex: Min-Max scaling).",
                                    "Explorar dados com visualizações (histogramas, correlações) para identificar padrões.",
                                    "Dividir dataset em treino (70%), validação (15%) e teste (15%).",
                                    "Balancear classes se houver desequilíbrio (ex: SMOTE para oversampling)."
                                  ],
                                  "verification": "Dataset limpo e dividido salva em arquivos CSV; relatórios de EDA gerados sem erros.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Python (pandas, numpy, matplotlib, seaborn), dataset de falhas (ex: Kaggle ou simulado via ANSYS).",
                                  "tips": "Use pandas profiling para EDA rápida e insights automáticos.",
                                  "learningObjective": "Dominar pré-processamento de dados para RNA, garantindo qualidade de input.",
                                  "commonMistakes": "Ignorar normalização, levando a gradientes instáveis; não balancear classes, causando bias para maioria."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construção da Arquitetura da RNA Feedforward",
                                  "subSteps": [
                                    "Definir camadas: input (número de features), hidden (2-3 camadas com 64-128 neurônios ReLU), output (1 neurônio sigmoid para binário falha/não).",
                                    "Implementar em Python com Keras/TensorFlow ou MATLAB Neural Net Toolbox.",
                                    "Adicionar dropout (0.2-0.5) e batch normalization para regularização.",
                                    "Configurar loss (binary_crossentropy), optimizer (Adam) e métricas (accuracy, precision, recall).",
                                    "Compilar o modelo e visualizar arquitetura com plot_model."
                                  ],
                                  "verification": "Modelo compilado sem erros; summary() mostra arquitetura correta.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": "Python (TensorFlow/Keras), MATLAB (se preferido), Jupyter Notebook.",
                                  "tips": "Comece com arquitetura simples e adicione complexidade iterativamente.",
                                  "learningObjective": "Construir RNA feedforward otimizada para classificação binária de falhas.",
                                  "commonMistakes": "Camadas hidden muito profundas sem dropout, causando overfitting; optimizer com learning rate alto demais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Treinamento e Otimização do Modelo",
                                  "subSteps": [
                                    "Treinar modelo com dados de treino/validação (epochs=100-200, batch_size=32).",
                                    "Monitorar curvas de loss/accuracy para early stopping (patience=10).",
                                    "Otimizar hiperparâmetros via grid search ou Bayesian (ex: learning rate, neurônios).",
                                    "Usar programação matemática (scipy.optimize ou MATLAB fmincon) para tuning fino de pesos iniciais.",
                                    "Salvar melhor modelo baseado em validação (ex: menor loss)."
                                  ],
                                  "verification": "Treinamento converge (loss <0.1); modelo salvo com pesos ótimos.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": "TensorFlow callbacks (EarlyStopping, ModelCheckpoint), scikit-optimize ou Optuna.",
                                  "tips": "Use GPU se disponível para acelerar; logue com TensorBoard.",
                                  "learningObjective": "Treinar e otimizar RNA para alta precisão em previsão de falhas.",
                                  "commonMistakes": "Treinar sem validação, detectando overfitting tarde; ignorar early stopping, desperdiçando tempo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliação e Validação Final",
                                  "subSteps": [
                                    "Testar modelo em conjunto de teste: calcular accuracy, F1-score, confusion matrix.",
                                    "Realizar cross-validation k-fold (k=5) para robustez.",
                                    "Analisar feature importance com SHAP ou permutation importance.",
                                    "Simular cenários reais: prever falha em viga com inputs novos.",
                                    "Documentar resultados em relatório com gráficos ROC/AUC."
                                  ],
                                  "verification": "Métricas >85% accuracy/F1; relatório gerado.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Scikit-learn (metrics, cross_val), SHAP library.",
                                  "tips": "Compare com baseline (ex: regressão logística) para validar superioridade da RNA.",
                                  "learningObjective": "Avaliar modelo de forma rigorosa, garantindo generalização.",
                                  "commonMistakes": "Avaliar só em treino (data leakage); ignorar métricas além de accuracy para classes desbalanceadas."
                                }
                              ],
                              "practicalExample": "Usando dataset de vigas de concreto: features (comprimento=5m, seção=0.3x0.5m, carga=200kN, fc=30MPa); modelo prevê falha (1) ou não (0) com 92% accuracy, otimizado para detectar vigas críticas em pontes.",
                              "finalVerifications": [
                                "Modelo atinge >90% accuracy em teste independente.",
                                "Curvas de learning não mostram overfitting (gap treino/validação <10%).",
                                "Previsões corretas em 80% de casos edge (cargas extremas).",
                                "Hiperparâmetros otimizados reduzem loss em >20%.",
                                "Relatório inclui confusion matrix e ROC curve.",
                                "Modelo deployável (salvo em .h5)."
                              ],
                              "assessmentCriteria": [
                                "Precisão e recall >85% em falhas positivas.",
                                "Tempo de treinamento <2h em CPU padrão.",
                                "Generalização comprovada via k-fold CV.",
                                "Código limpo, comentado e reproduzível.",
                                "Otimização matemática melhora performance em >10%.",
                                "Análise de erros identifica fraquezas do modelo."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: validação cruzada e métricas de performance.",
                                "Programação: bibliotecas ML e otimização numérica.",
                                "Mecânica dos Materiais: features baseadas em propriedades estruturais.",
                                "Matemática Aplicada: gradiente descendente e funções de ativação.",
                                "Gestão de Projetos: documentação e deploy de modelos."
                              ],
                              "realWorldApplication": "Em inspeções de pontes/ edifícios, o modelo prevê falhas em vigas/lajes antes de colapso, permitindo manutenção preditiva, redução de custos (ex: evitar demolição de barragem como em Brumadinho) e segurança pública via integração com IoT sensores."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Avaliar precisão da previsão",
                            "description": "Utilizar métricas como erro médio quadrático e validação cruzada para avaliar o desempenho da RNA em cenários reais de engenharia civil, referenciando Chapra e Canale (2002).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Métricas de Precisão como MSE e MAE",
                                  "subSteps": [
                                    "Estude a definição de Erro Médio Quadrático (MSE) como a média dos quadrados das diferenças entre valores previstos e reais.",
                                    "Aprenda Erro Médio Absoluto (MAE) como a média das diferenças absolutas.",
                                    "Revise conceitos de validação cruzada (k-fold) de Chapra e Canale (2002), Capítulo 20, sobre análise de erros numéricos.",
                                    "Compare MSE e MAE em termos de sensibilidade a outliers.",
                                    "Calcule manualmente MSE para um conjunto de dados pequeno de deformações em vigas."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre MSE e MAE, com fórmulas corretas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro Chapra e Canale (2002)",
                                    "Planilha Excel ou Jupyter Notebook",
                                    "Artigos sobre métricas de regressão"
                                  ],
                                  "tips": "Use diagramas visuais para entender como MSE penaliza erros grandes mais que MAE.",
                                  "learningObjective": "Explicar e calcular métricas básicas de erro em previsões de RNA.",
                                  "commonMistakes": [
                                    "Confundir MSE com RMSE (raiz quadrada)",
                                    "Ignorar unidades nos erros de engenharia"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Cálculo de MSE em Código para Dados de Engenharia Civil",
                                  "subSteps": [
                                    "Prepare um dataset de falhas estruturais (ex: deformações em pontes com cargas reais).",
                                    "Use Python com NumPy e Scikit-learn para carregar dados e treinar uma RNA simples com Keras.",
                                    "Implemente função personalizada para MSE: np.mean((y_true - y_pred)**2).",
                                    "Compare com métrica built-in do Scikit-learn: mean_squared_error(y_true, y_pred).",
                                    "Visualize erros com gráficos de resíduos (predicted vs actual)."
                                  ],
                                  "verification": "Execute código e produza gráfico de resíduos com MSE < 0.05 para dataset de teste.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python 3.8+",
                                    "Bibliotecas: NumPy, Scikit-learn, Keras/TensorFlow",
                                    "Dataset público de falhas estruturais (ex: UCI ML Repository)"
                                  ],
                                  "tips": "Normalize dados de entrada para melhorar convergência da RNA.",
                                  "learningObjective": "Codificar e validar MSE em previsões de RNA para cenários civis.",
                                  "commonMistakes": [
                                    "Não dividir train/test sets",
                                    "Usar dados não normalizados levando a MSE inflado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Validação Cruzada (K-Fold) para Avaliação Robusta",
                                  "subSteps": [
                                    "Configure k-fold cross-validation com k=5 usando cross_val_score do Scikit-learn.",
                                    "Treine RNA em cada fold e compute MSE médio e desvio padrão.",
                                    "Aplique em dados reais de engenharia civil, como previsão de fissuras em concreto.",
                                    "Interprete variância: baixo desvio indica modelo estável (ref. Chapra e Canale, análise de incertezas).",
                                    "Gere relatório com tabela de MSE por fold."
                                  ],
                                  "verification": "Obtenha MSE médio < 0.03 com desvio padrão < 0.01 em validação cruzada.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Scikit-learn para cross_val_score",
                                    "Dados de simulação estrutural (ex: ANSYS export)"
                                  ],
                                  "tips": "Use GridSearchCV para otimizar hiperparâmetros durante CV.",
                                  "learningObjective": "Aplicar validação cruzada para avaliar robustez da previsão de RNA.",
                                  "commonMistakes": [
                                    "Leakage de dados entre folds",
                                    "k muito pequeno levando a overfitting"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Aplicar em Cenário Real de Engenharia Civil",
                                  "subSteps": [
                                    "Analise MSE em contexto: converta para unidades físicas (ex: mm de deformação).",
                                    "Compare com thresholds de segurança (ex: MSE < limite normativo ABNT NBR).",
                                    "Simule cenário: previsão de falha em ponte com dados reais.",
                                    "Documente relatório referenciando Chapra e Canale para validação numérica.",
                                    "Teste sensibilidade alterando hiperparâmetros da RNA."
                                  ],
                                  "verification": "Produza relatório de 1 página com interpretação e recomendações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Normas ABNT para estruturas",
                                    "Software de simulação como SAP2000 para dados reais"
                                  ],
                                  "tips": "Sempre relacione erro numérico com impacto físico na estrutura.",
                                  "learningObjective": "Interpretar métricas em aplicações reais de previsão de falhas.",
                                  "commonMistakes": [
                                    "Ignorar escala física dos erros",
                                    "Sobre-generalizar de um dataset"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma ponte suspensa, use RNA treinada com dados de sensores IoT para prever deformação máxima sob vento. Calcule MSE=0.02 (2mm erro médio) via CV-5, confirmando precisão para inspeções preditivas.",
                              "finalVerifications": [
                                "Calcular MSE manualmente para 10 amostras com precisão >95%.",
                                "Executar k-fold CV e reportar MSE médio e std dev.",
                                "Interpretar MSE em termos de segurança estrutural.",
                                "Comparar performance antes/depois de tuning.",
                                "Gerar gráfico de learning curve estável."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de MSE (erro <1%).",
                                "Uso correto de validação cruzada (k>=5 folds).",
                                "Interpretação contextualizada para engenharia civil.",
                                "Código limpo, reproduzível e comentado.",
                                "Referência adequada a Chapra e Canale.",
                                "Relatório com visualizações claras."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e testes de hipótese.",
                                "Programação: Python para ML e análise numérica.",
                                "Mecânica dos Materiais: Interpretação de deformações reais.",
                                "Gestão de Projetos: Decisões baseadas em risco preditivo."
                              ],
                              "realWorldApplication": "Em manutenção preditiva de barragens, avaliar MSE de RNA prevê fissuras com antecedência, evitando colapsos como em Brumadinho, otimizando inspeções e reduzindo custos em 30%."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Otimização de Projetos Estruturais",
                        "description": "Uso de RNAs para otimizar dimensões e materiais em projetos civis, combinando com técnicas de otimização e programação matemática para minimizar custos e maximizar segurança.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Modelar otimização com RNAs",
                            "description": "Desenvolver RNAs que aproximem funções objetivo em problemas de otimização de estruturas, integrando método dos resíduos ponderados e condicionamento de matrizes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Otimização Estrutural e Redes Neurais Artificiais",
                                  "subSteps": [
                                    "Estude os princípios básicos de otimização em engenharia estrutural, focando em funções objetivo como minimização de peso ou custo.",
                                    "Revise a arquitetura de RNAs feedforward e backpropagation para aproximação de funções.",
                                    "Analise exemplos de problemas de otimização não linear em estruturas civis, como treliças ou vigas.",
                                    "Identifique como RNAs podem surrogatear funções objetivo complexas.",
                                    "Compile anotações sobre limitações de métodos tradicionais de otimização."
                                  ],
                                  "verification": "Crie um diagrama conceitual ligando otimização estrutural a RNAs e explique em 200 palavras.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Livro 'Otimização Estrutural' de Haftka",
                                    "Tutorial TensorFlow/Keras sobre RNAs",
                                    "Artigos sobre surrogate models em engenharia"
                                  ],
                                  "tips": [
                                    "Use diagramas de fluxo para visualizar o pipeline.",
                                    "Comece com problemas 2D simples para intuição.",
                                    "Assista vídeos curtos no YouTube sobre surrogate optimization."
                                  ],
                                  "learningObjective": "Compreender como RNAs aproximam funções objetivo em otimização estrutural.",
                                  "commonMistakes": [
                                    "Confundir RNAs com métodos exatos de otimização.",
                                    "Ignorar não-linearidades em problemas estruturais.",
                                    "Pular revisão de backpropagation."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar o Método dos Resíduos Ponderados",
                                  "subSteps": [
                                    "Aprenda a formulação matemática do método: minimizar resíduos ponderados em equações de equilíbrio estrutural.",
                                    "Implemente em código simples um exemplo de aplicação em uma estrutura estática.",
                                    "Estude pesos adaptativos baseados em sensibilidade ou erro local.",
                                    "Compare com métodos de penalidades e Lagrange multipliers.",
                                    "Teste em um problema de otimização com restrições de deslocamento."
                                  ],
                                  "verification": "Resolva um problema de viga cantilever usando resíduos ponderados e valide contra solução analítica.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Paper 'Weighted Residual Methods in Structural Optimization'",
                                    "Python com NumPy/SciPy",
                                    "Exemplos de código GitHub sobre métodos de resíduos"
                                  ],
                                  "tips": [
                                    "Escolha pesos iniciais uniformes e itere.",
                                    "Visualize resíduos com plots de calor.",
                                    "Integre com solvers como fsolve."
                                  ],
                                  "learningObjective": "Aplicar método dos resíduos ponderados para lidar com restrições em otimização.",
                                  "commonMistakes": [
                                    "Pesos mal calibrados levando a convergência lenta.",
                                    "Não normalizar resíduos.",
                                    "Aplicar linearmente em problemas não-lineares."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Condicionamento de Matrizes em Otimização",
                                  "subSteps": [
                                    "Revise conceitos de condicionamento numérico: número de condicionamento e decomposição SVD.",
                                    "Analise impacto em matrizes de rigidez estrutural durante otimização.",
                                    "Implemente técnicas de pré-condicionamento como ILU ou diagonal scaling.",
                                    "Integre com resíduos ponderados para melhorar estabilidade.",
                                    "Teste em matrizes mal condicionadas de estruturas finitas."
                                  ],
                                  "verification": "Calcule o número de condicionamento antes/depois de pré-condicionamento em uma matriz de exemplo e reduza em pelo menos 50%.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Livro 'Numerical Linear Algebra' de Trefethen",
                                    "MATLAB/Python SciPy para SVD",
                                    "Tutoriais sobre preconditioners"
                                  ],
                                  "tips": [
                                    "Use cond(A) no NumPy para métricas rápidas.",
                                    "Aplique em sub-matrizes primeiro.",
                                    "Monitore eigenvalues durante iterações."
                                  ],
                                  "learningObjective": "Melhorar estabilidade numérica em problemas de otimização estrutural.",
                                  "commonMistakes": [
                                    "Ignorar escalas de unidades em matrizes.",
                                    "Usar preconditioners sem testar sensibilidade.",
                                    "Confundir com regularização L2."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar RNAs com Resíduos Ponderados e Condicionamento para Modelagem",
                                  "subSteps": [
                                    "Desenhe arquitetura do RNA: entradas (parâmetros estruturais), saídas (função objetivo aproximada).",
                                    "Incorpore resíduos ponderados na loss function do RNA.",
                                    "Aplique condicionamento nas features de entrada/saída do RNA.",
                                    "Treine o modelo com dados de simulações FEM (Finite Element Method).",
                                    "Otimize hiperparâmetros e valide com hold-out set."
                                  ],
                                  "verification": "Treine RNA e demonstre erro de aproximação <5% em função objetivo de teste.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": [
                                    "TensorFlow/Keras",
                                    "Software FEM como Abaqus ou FEniCS",
                                    "Datasets sintéticos de estruturas"
                                  ],
                                  "tips": [
                                    "Use early stopping para evitar overfitting.",
                                    "Normalise inputs com MinMaxScaler.",
                                    "Experimente dropout para generalização."
                                  ],
                                  "learningObjective": "Desenvolver modelo de RNA completo para otimização estrutural.",
                                  "commonMistakes": [
                                    "Dataset pequeno levando a poor generalization.",
                                    "Não integrar resíduos na loss corretamente.",
                                    "Ignorar preconditioning no training."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Refinar o Modelo de Otimização",
                                  "subSteps": [
                                    "Compare RNA com solver tradicional (e.g., gradient descent).",
                                    "Analise sensibilidade a ruído e variações paramétricas.",
                                    "Refine com fine-tuning usando transfer learning se aplicável.",
                                    "Documente pipeline completo em relatório.",
                                    "Teste em caso real: otimização de treliça."
                                  ],
                                  "verification": "Otimize uma estrutura real e compare tempo/convergência com baseline.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Jupyter Notebook para experimentos",
                                    "Ferramentas de plotting: Matplotlib/Seaborn"
                                  ],
                                  "tips": [
                                    "Use cross-validation k-fold.",
                                    "Registre métricas com TensorBoard.",
                                    "Salve modelos para reprodutibilidade."
                                  ],
                                  "learningObjective": "Validar eficácia do modelo integrado em cenários práticos.",
                                  "commonMistakes": [
                                    "Validação só em treino set.",
                                    "Não quantificar speedup.",
                                    "Sobreajustar a um caso específico."
                                  ]
                                }
                              ],
                              "practicalExample": "Otimizar o design de uma treliça plana para minimizar peso sob cargas de vento, usando RNA para aproximar a função objetivo (compliance), com resíduos ponderados para restrições de tensão e preconditioning para estabilidade da matriz de rigidez.",
                              "finalVerifications": [
                                "O RNA aproxima a função objetivo com erro médio <3%.",
                                "Integração de resíduos ponderados reduz violações de restrições em 80%.",
                                "Condicionamento da matriz melhorado em fator >10x.",
                                "Modelo treina em <1 hora para 1000 épocas.",
                                "Otimização converge 2x mais rápido que método baseline.",
                                "Validação cruzada mostra generalização em estruturas similares."
                              ],
                              "assessmentCriteria": [
                                "Precisão da aproximação da função objetivo (MSE <0.01).",
                                "Estabilidade numérica demonstrada por métricas de condicionamento.",
                                "Eficiência computacional vs. métodos tradicionais.",
                                "Correta implementação de resíduos ponderados na loss.",
                                "Qualidade do código: modular, comentado e reprodutível.",
                                "Análise de erros e sensibilidade abrangente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Linear (condicionamento, SVD) e Cálculo Variacional.",
                                "Computação: Machine Learning (RNAs, otimização de hiperparâmetros).",
                                "Física: Mecânica dos Sólidos e Análise Estrutural.",
                                "Estatística: Validação de modelos e análise de erro."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios altos, onde otimização iterativa via FEM é cara; RNAs aceleram design, reduzindo tempo de simulação de dias para horas, permitindo exploração de mais variantes e economia de material."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Aplicar RNA em design de pontes",
                            "description": "Otimizar seções transversais de pontes usando RNAs treinadas com simulações numéricas, conforme Yang et al. (2005).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar literatura e preparar ambiente computacional",
                                  "subSteps": [
                                    "Ler o paper de Yang et al. (2005) sobre otimização de seções transversais de pontes com RNA.",
                                    "Instalar bibliotecas necessárias: Python, TensorFlow/Keras, NumPy, SciPy e software de simulação como ANSYS ou FEniCS.",
                                    "Definir parâmetros iniciais da ponte: comprimento do vão, cargas, materiais (ex: concreto armado).",
                                    "Configurar workspace com notebooks Jupyter para experimentação.",
                                    "Estudar arquitetura de RNA sugerida no paper (ex: MLP com 3 camadas ocultas)."
                                  ],
                                  "verification": "Ambiente rodando com script de teste que importa bibliotecas e plota uma seção transversal simples.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python 3.8+, TensorFlow 2.x, Jupyter Notebook, PDF do paper Yang et al. (2005)",
                                    "Computador com GPU recomendada"
                                  ],
                                  "tips": "Comece com um dataset pequeno para testes rápidos; use Google Colab se sem GPU local.",
                                  "learningObjective": "Compreender o problema de otimização de seções transversais e configurar ferramentas para RNA.",
                                  "commonMistakes": [
                                    "Ignorar restrições de engenharia como fator de segurança; instalar versões incompatíveis de bibliotecas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar dataset de simulações numéricas",
                                  "subSteps": [
                                    "Definir variáveis de entrada: dimensões da seção (altura, largura, espessura), materiais e cargas.",
                                    "Executar simulações numéricas (FEA) para 1000+ casos variando parâmetros, registrando tensão máxima, deslocamento e peso.",
                                    "Normalizar dados de entrada/saída para escala [0,1].",
                                    "Dividir dataset em treino (70%), validação (15%) e teste (15%).",
                                    "Visualizar correlações com gráficos de dispersão."
                                  ],
                                  "verification": "Dataset salvo como CSV com pelo menos 1000 amostras e gráficos mostrando boa variabilidade.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Software FEA: ANSYS, Abaqus ou código Python com FEniCS",
                                    "Planilhas Excel para organização inicial"
                                  ],
                                  "tips": "Use scripts automatizados para variar parâmetros e rodar simulações em batch para eficiência.",
                                  "learningObjective": "Gerar dados realistas de simulações para treinar RNA em problemas estruturais.",
                                  "commonMistakes": [
                                    "Gerar dados insuficientes levando a overfitting; não normalizar causando instabilidade no treinamento."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Treinar a Rede Neural Artificial",
                                  "subSteps": [
                                    "Implementar arquitetura MLP conforme Yang et al.: entrada (dimensões/cargas), saída (peso otimizado/tensões).",
                                    "Configurar otimizador (Adam), perda (MSE) e early stopping.",
                                    "Treinar por 100-500 épocas, monitorando perda em treino/validação.",
                                    "Avaliar com métricas: MAE, R² no conjunto de teste.",
                                    "Salvar modelo treinado e plotar curvas de aprendizado."
                                  ],
                                  "verification": "Modelo com R² > 0.95 no teste e curvas de perda convergentes sem overfitting.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "TensorFlow/Keras, Matplotlib/Seaborn para plots"
                                  ],
                                  "tips": "Ajuste learning rate se perda oscilar; use callbacks para salvar melhor modelo.",
                                  "learningObjective": "Treinar RNA surrogate para aproximar simulações numéricas em otimização estrutural.",
                                  "commonMistakes": [
                                    "Overfitting por falta de dropout ou regularização; ignorar validação cruzada."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar RNA para otimização de seções transversais",
                                  "subSteps": [
                                    "Definir função objetivo: minimizar peso sujeito a restrições (tensão < limite, deslocamento < threshold).",
                                    "Implementar algoritmo de otimização (ex: Genetic Algorithm ou SciPy.optimize) usando RNA como surrogate.",
                                    "Executar iterações de otimização, prevendo com RNA e validando periodicamente com FEA.",
                                    "Comparar design otimizado vs. baseline (design manual).",
                                    "Refinar hiperparâmetros se necessário."
                                  ],
                                  "verification": "Design otimizado com redução de peso >10% e todas restrições satisfeitas via FEA final.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "SciPy para otimização, código de FEA para validação"
                                  ],
                                  "tips": "Use penalidades altas em restrições violadas; valide RNA predictions com FEA em pontos chave.",
                                  "learningObjective": "Usar RNA treinada para acelerar otimização em design de pontes.",
                                  "commonMistakes": [
                                    "Não validar predições RNA com simulações reais; otimização local em vez de global."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar, documentar e iterar",
                                  "subSteps": [
                                    "Realizar análise de sensibilidade nos parâmetros otimizados.",
                                    "Documentar processo, resultados e comparações em relatório com figuras.",
                                    "Testar robustez com variações de carga/vento.",
                                    "Iterar treinamento se precisão insuficiente.",
                                    "Preparar apresentação com métricas chave."
                                  ],
                                  "verification": "Relatório completo com design validado e ready para revisão por engenheiro.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "LaTeX/Word para relatório, Git para versionamento"
                                  ],
                                  "tips": "Inclua código fonte no repositório GitHub para reprodutibilidade.",
                                  "learningObjective": "Garantir validade prática e documentar aplicação de RNA em engenharia.",
                                  "commonMistakes": [
                                    "Pular validação física; relatório sem quantificação de ganhos."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma ponte de 100m de vão com carga viva de 50kN/m², use RNA para otimizar seção I de viga: de baseline 1.2m altura/0.8m largura (peso 25ton) para otimizada 1.0m/0.7m (peso 18ton), reduzindo 28% material sem exceder tensão de 30MPa.",
                              "finalVerifications": [
                                "RNA prediz tensões com erro <5% vs. FEA em 20 casos teste.",
                                "Design otimizado reduz peso em pelo menos 15% vs. baseline.",
                                "Todas restrições (tensão, deslocamento, estabilidade) satisfeitas.",
                                "Processo documentado com código reprodutível.",
                                "Sensibilidade mostra robustez a ±10% variação de cargas.",
                                "Comparação com Yang et al. (2005) valida abordagem."
                              ],
                              "assessmentCriteria": [
                                "Precisão da RNA (R² >0.92, MAE <2%).",
                                "Eficiência da otimização (redução de custo/peso quantificada).",
                                "Validação com simulações independentes.",
                                "Clareza da documentação e visualizações.",
                                "Tratamento de restrições de engenharia.",
                                "Tempo de computação reduzido vs. FEA pura (>50%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-linear e álgebra linear em redes neurais.",
                                "Programação: Machine Learning com Python/TensorFlow.",
                                "Física/Mecânica: Análise de elementos finitos e mecânica estrutural.",
                                "Estatística: Validação de modelos e análise de sensibilidade.",
                                "Gestão de Projetos: Documentação e reprodutibilidade em engenharia."
                              ],
                              "realWorldApplication": "Em projetos reais como a Ponte Rio-Niterói ou Millennium Bridge retrofit, RNAs aceleram iterações de design, reduzindo custos de material em 20-30% e tempo de análise de semanas para horas, integrando com BIM e normas como ABNT NBR 7188."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Comparar com métodos tradicionais",
                            "description": "Contrastar resultados de otimização via RNA com métodos de Monte Carlo e geração de números aleatórios para validar eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Compreender os Métodos Tradicionais e RNA",
                                  "subSteps": [
                                    "Estude os princípios do método de Monte Carlo: amostragem aleatória para estimar distribuições probabilísticas em otimização.",
                                    "Analise a geração de números aleatórios: uniformes, normais e sua aplicação em buscas aleatórias para otimização.",
                                    "Revise o funcionamento de RNAs para otimização: backpropagation, funções de perda e treinamento para minimizar custos estruturais.",
                                    "Identifique métricas comuns de comparação: tempo de convergência, precisão da solução ótima, variância dos resultados e uso computacional.",
                                    "Defina o problema de otimização estrutural exemplo: minimizar peso de uma treliça sujeita a restrições de tensão."
                                  ],
                                  "verification": "Criar um resumo escrito de 1 página comparando conceitualmente os métodos, com diagramas de fluxo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação de bibliotecas (NumPy, SciPy), artigos acadêmicos sobre Monte Carlo e RNA em otimização estrutural, software de edição de texto.",
                                  "tips": "Use diagramas Venn para visualizar sobreposições e diferenças entre métodos.",
                                  "learningObjective": "Compreender as bases teóricas para uma comparação fundamentada.",
                                  "commonMistakes": "Confundir Monte Carlo (probabilístico) com métodos determinísticos como gradiente descendente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e Executar Métodos Tradicionais",
                                  "subSteps": [
                                    "Configure o ambiente em Python com NumPy e SciPy para geração de números aleatórios e Monte Carlo.",
                                    "Defina o espaço de busca: variáveis como seções transversais e materiais para a treliça.",
                                    "Implemente simulação Monte Carlo: gere 10.000 amostras aleatórias e avalie funções objetivo (peso vs. tensão).",
                                    "Execute múltiplas rodadas (ex: 50 iterações) e registre métricas: tempo médio, melhor solução encontrada, desvio padrão.",
                                    "Gere visualizações iniciais: histogramas de distribuições de soluções e curvas de convergência."
                                  ],
                                  "verification": "Código executado com logs de métricas salvas em CSV e gráficos gerados.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python 3+, bibliotecas NumPy, SciPy, Matplotlib; dataset simples de treliça (ex: truss optimization benchmark).",
                                  "tips": "Use seeds fixos para reprodutibilidade em comparações aleatórias.",
                                  "learningObjective": "Aplicar métodos tradicionais a um problema real de engenharia civil.",
                                  "commonMistakes": "Número insuficiente de amostras levando a variância alta e resultados não confiáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Executar Otimização via RNA",
                                  "subSteps": [
                                    "Configure rede neural com TensorFlow/Keras: camadas densas para modelar função objetivo de otimização estrutural.",
                                    "Prepare dados de treinamento: gere dataset sintético de configurações estruturais com rótulos de fitness.",
                                    "Treine a RNA: use otimizador Adam, monitore perda e valide com conjunto separado.",
                                    "Execute inferência para otimização: use RNA treinada para guiar busca iterativa até convergência.",
                                    "Registre métricas equivalentes: tempo total de treinamento + inferência, precisão da solução ótima."
                                  ],
                                  "verification": "Modelo treinado salvo, métricas logadas em CSV e gráfico de perda vs. épocas.",
                                  "estimatedTime": "4 horas",
                                  "materials": "TensorFlow/Keras, GPU opcional; mesmo dataset de treliça do Step 2.",
                                  "tips": "Normalize inputs para aceleração de convergência da RNA.",
                                  "learningObjective": "Dominar uso de RNA como ferramenta de otimização surrogate.",
                                  "commonMistakes": "Overfitting da RNA devido a dataset pequeno; sempre use validação cruzada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Resultados e Validar Eficiência",
                                  "subSteps": [
                                    "Colete dados paralelos: compile tabelas de métricas (tempo, precisão, variância) dos dois approaches.",
                                    "Gere visualizações comparativas: boxplots de soluções, curvas tempo vs. fitness, scatter plots.",
                                    "Aplique testes estatísticos: t-test para diferenças significativas em precisão e tempo.",
                                    "Analise trade-offs: eficiência computacional da RNA vs. simplicidade dos métodos aleatórios.",
                                    "Documente conclusões: valide superioridade da RNA em cenários de alta dimensionalidade."
                                  ],
                                  "verification": "Relatório final com tabelas, gráficos e conclusões quantitativas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Pandas para análise de dados, Seaborn/Matplotlib para plots, SciPy para testes estatísticos.",
                                  "tips": "Foquem em normalização de escalas para comparações justas (ex: tempo por dimensão).",
                                  "learningObjective": "Realizar análise crítica e quantitativa para validar eficiência.",
                                  "commonMistakes": "Ignorar custos computacionais do treinamento da RNA em comparações de tempo."
                                }
                              ],
                              "practicalExample": "Otimizar uma treliça de 10 barras para minimizar peso sob cargas de vento: Monte Carlo requer 50.000 simulações (2 min), RNA converge em 100 épocas (30s total), alcançando 15% melhor solução com menor variância.",
                              "finalVerifications": [
                                "Tabelas comparativas de métricas geradas e salvas.",
                                "Gráficos de convergência e distribuições de soluções produzidos.",
                                "Testes estatísticos confirmam diferenças significativas (p-value < 0.05).",
                                "Relatório escrito resume superioridade da RNA em eficiência.",
                                "Códigos reproduzíveis com seeds e ambientes documentados.",
                                "Solução ótima da RNA validada via análise finita de elementos (FEA)."
                              ],
                              "assessmentCriteria": [
                                "Precisão quantitativa das métricas comparadas (90%+ acurácia).",
                                "Qualidade das visualizações e clareza interpretativa.",
                                "Uso correto de testes estatísticos e análise de variância.",
                                "Profundidade da discussão de trade-offs e limitações.",
                                "Reprodutibilidade total do experimento.",
                                "Conexão explícita com aplicações em engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipótese e análise probabilística.",
                                "Programação: Implementação numérica e visualização de dados.",
                                "Matemática Computacional: Otimização não-linear e aproximações.",
                                "Engenharia Mecânica: Análise estrutural e FEA."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios altos, engenheiros civis usam RNA para otimizar designs rapidamente vs. simulações Monte Carlo demoradas, reduzindo custos e tempo em licitações, como no design da ponte Golden Gate modernizada."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Análise de Dados Geotécnicos",
                        "description": "Emprego de RNAs na interpretação de dados de solos e rochas, prevendo propriedades mecânicas e estabilidade de taludes a partir de ensaios de campo.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Processar dados geotécnicos com RNAs",
                            "description": "Pré-processar dados de sondagens e ensaios triaxiais para input em RNAs, utilizando ajuste de curvas e solução de equações não-lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Aquisição e Exploração Inicial dos Dados Geotécnicos",
                                  "subSteps": [
                                    "Coletar dados de sondagens (SPT, CPT) e ensaios triaxiais de fontes confiáveis como relatórios de campo ou bancos de dados.",
                                    "Importar dados para ferramentas como Python (pandas) ou Excel para visualização inicial.",
                                    "Realizar análise exploratória: histogramas, boxplots e correlações para identificar padrões e anomalias.",
                                    "Documentar metadados: profundidade, tipo de solo, condições de ensaio.",
                                    "Identificar variáveis relevantes: resistência ao cisalhamento, módulo de elasticidade, umidade."
                                  ],
                                  "verification": "Relatório de exploração gerado com gráficos e estatísticas descritivas sem erros de importação.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com pandas, matplotlib, seaborn",
                                    "Dados de sondagens em CSV/Excel",
                                    "Relatórios de ensaios triaxiais"
                                  ],
                                  "tips": "Use seaborn para visualizações rápidas; sempre backup os dados originais.",
                                  "learningObjective": "Compreender a estrutura e qualidade inicial dos dados geotécnicos para processamento.",
                                  "commonMistakes": [
                                    "Ignorar outliers óbvios",
                                    "Não documentar unidades de medida",
                                    "Confundir dados de diferentes ensaios"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Limpeza e Tratamento de Dados Ausentes ou Inconsistentes",
                                  "subSteps": [
                                    "Detectar e tratar valores ausentes: imputação por média/mediana ou interpolação linear para séries temporais de profundidade.",
                                    "Remover ou corrigir outliers usando método IQR ou Z-score.",
                                    "Padronizar formatos: converter unidades (kPa para MPa) e tipos de dados.",
                                    "Verificar consistência entre sondagens e ensaios triaxiais (ex: matching de amostras).",
                                    "Criar dataset limpo e salvo em formato estruturado."
                                  ],
                                  "verification": "Dataset limpo sem NaNs, outliers removidos e consistência verificada via summary statistics.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python: pandas, numpy, scikit-learn para imputação",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Visualize antes e depois da limpeza para validar mudanças; prefira interpolação para dados geotécnicos sequenciais.",
                                  "learningObjective": "Garantir qualidade dos dados para evitar viés em modelos de RNA.",
                                  "commonMistakes": [
                                    "Imputar excessivamente sem justificativa",
                                    "Remover dados válidos como outliers",
                                    "Ignorar correlações entre variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajuste de Curvas e Solução de Equações Não-Lineares",
                                  "subSteps": [
                                    "Selecionar modelos não-lineares comuns em geotécnica (ex: hiperbólica para curvas de consolidação).",
                                    "Usar otimização (scipy.optimize) para ajustar curvas aos dados de ensaios triaxiais.",
                                    "Resolver equações não-lineares para parâmetros como φ' e c' via métodos numéricos (Newton-Raphson).",
                                    "Validar ajuste com R² > 0.9 e resíduos aleatórios.",
                                    "Gerar features derivadas: parâmetros ajustados como inputs para RNA."
                                  ],
                                  "verification": "Curvas ajustadas plotadas com dados originais e métricas de goodness-of-fit calculadas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python: scipy, numpy",
                                    "Funções de modelo não-linear definidas (ex: Duncan-Chang)"
                                  ],
                                  "tips": "Comece com guesses iniciais razoáveis baseados em literatura; plote resíduos para diagnosticar problemas.",
                                  "learningObjective": "Aplicar métodos numéricos para extrair features não-lineares de dados geotécnicos.",
                                  "commonMistakes": [
                                    "Má escolha de modelo inicial",
                                    "Não convergência por poor initial guess",
                                    "Sobreajuste ignorando validação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Normalização e Preparação Final para Input em RNAs",
                                  "subSteps": [
                                    "Aplicar normalização Min-Max ou Z-score às features (dados crus + derivadas).",
                                    "Dividir dataset em train/test (80/20) com estratificação por tipo de solo.",
                                    "Codificar variáveis categóricas (ex: tipo de solo via one-hot).",
                                    "Criar arrays X (features) e y (target, ex: capacidade portante) compatíveis com RNA.",
                                    "Salvar em formato pickle ou HDF5 para treinamento."
                                  ],
                                  "verification": "Arrays normalizados inspecionados (médias ~0, desvios ~1) e shapes compatíveis com modelo RNA.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python: scikit-learn (StandardScaler, train_test_split)",
                                    "TensorFlow/Keras para preview"
                                  ],
                                  "tips": "Escolha scaler baseado no tipo de RNA (MinMax para sigmóide); preserve scaler para inferência futura.",
                                  "learningObjective": "Preparar dados otimizados para treinamento eficiente de RNAs.",
                                  "commonMistakes": [
                                    "Normalizar train e test juntos (data leakage)",
                                    "Esquecer variáveis categóricas",
                                    "Leakage de target em features"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de fundação de edifício, pré-processe dados de 50 sondagens SPT e 20 ensaios triaxiais: limpe outliers de umidade >30%, ajuste curvas hiperbólicas para obter parâmetros de resistência, normalize e prepare para RNA prever capacidade portante, alcançando MSE <5% em teste.",
                              "finalVerifications": [
                                "Dataset final sem NaNs ou outliers, com >95% completude.",
                                "Curvas ajustadas com R² >0.9 e resíduos <5% dos valores observados.",
                                "Dados normalizados uniformemente (0-1 ou Z-score).",
                                "Divisão train/test balanceada por classes de solo.",
                                "Arrays X/y salvos e carregáveis sem perda de informação.",
                                "Preview de RNA treinado converge sem erros de shape."
                              ],
                              "assessmentCriteria": [
                                "Qualidade de limpeza: redução de outliers >80% sem perda excessiva de dados.",
                                "Precisão de ajuste de curvas: R² médio >0.92.",
                                "Eficiência de normalização: variância preservada pós-processamento.",
                                "Preparação para RNA: acurácia inicial de modelo baseline >70%.",
                                "Documentação: relatório completo com códigos e plots.",
                                "Tempo total dentro de 7.5 horas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-linear e equações diferenciais.",
                                "Programação: Manipulação de dados com Python/pandas e ML libraries.",
                                "Estatística: Análise exploratória, testes de normalidade e validação de modelos.",
                                "Física do Solo: Modelos constitutivos como Cam-Clay.",
                                "Inteligência Artificial: Pré-processamento para deep learning."
                              ],
                              "realWorldApplication": "Pré-processamento de dados geotécnicos para RNAs em projetos de fundações, túneis e barragens, permitindo previsões precisas de assentamentos e estabilidade de taludes, reduzindo custos de investigação de campo em até 30%."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Prever parâmetros de solo",
                            "description": "Treinar RNA para estimar coesão e ângulo de atrito a partir de dados geofísicos, integrando matriz de Gram e autofunções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação e Exploração dos Dados Geofísicos",
                                  "subSteps": [
                                    "Coletar dados geofísicos como velocidade de ondas P e S, resistividade elétrica e densidade aparente.",
                                    "Realizar limpeza: remover outliers usando método IQR e tratar valores ausentes por imputação mediana.",
                                    "Explorar dados com estatísticas descritivas e visualizações (histogramas, boxplots).",
                                    "Normalizar features usando MinMaxScaler e separar em X (features) e y (coesão c e ângulo de atrito φ).",
                                    "Dividir dataset em treino (70%), validação (15%) e teste (15%)."
                                  ],
                                  "verification": "Dataset limpo, normalizado e dividido, com relatório de estatísticas gerado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python 3.8+, bibliotecas: pandas, numpy, matplotlib, seaborn"
                                  ],
                                  "tips": [
                                    "Visualize distribuições antes e depois da normalização para garantir qualidade."
                                  ],
                                  "learningObjective": "Compreender e preparar dados geofísicos para modelagem preditiva.",
                                  "commonMistakes": [
                                    "Ignorar desbalanceamento de classes nos targets",
                                    "Não documentar transformações aplicadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construção da Matriz de Gram e Extração de Autofunções",
                                  "subSteps": [
                                    "Escolher kernel RBF com parâmetro gamma otimizado via grid search.",
                                    "Computar matriz de Gram K onde K_ij = exp(-gamma * ||x_i - x_j||^2).",
                                    "Calcular autovalores e autofunções da matriz K usando decomposição espectral.",
                                    "Selecionar as top-10 autofunções baseadas em variância explicada (>95%).",
                                    "Projetar dados originais no espaço das autofunções para obter features reduzidas."
                                  ],
                                  "verification": "Matriz de Gram computada e features projetadas com variância explicada reportada.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Scikit-learn (KernelPCA), numpy, scipy.linalg"
                                  ],
                                  "tips": [
                                    "Use KernelPCA do scikit-learn para automação, mas entenda a matemática por trás."
                                  ],
                                  "learningObjective": "Aplicar métodos kernel para extração de features não-lineares em dados geofísicos.",
                                  "commonMistakes": [
                                    "Escolher gamma inadequado levando a overfitting",
                                    "Não centralizar a matriz de Gram"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configuração da Arquitetura da Rede Neural Artificial",
                                  "subSteps": [
                                    "Definir arquitetura: entrada (features de autofunções), 3 camadas ocultas (128, 64, 32 neurônios) com ReLU.",
                                    "Saída: 2 neurônios lineares para regressão de c e φ.",
                                    "Configurar otimizador Adam (lr=0.001), loss MSE e métricas MAE/R².",
                                    "Implementar dropout (0.2) e early stopping com paciência 10 épocas.",
                                    "Preparar dataloaders com batch_size=32."
                                  ],
                                  "verification": "Modelo compilado e primeira época de treino executada sem erros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "TensorFlow/Keras 2.10+, scikit-learn"
                                  ],
                                  "tips": [
                                    "Comece com arquitetura simples e adicione complexidade gradualmente."
                                  ],
                                  "learningObjective": "Projetar RNA otimizada para regressão multivariada.",
                                  "commonMistakes": [
                                    "Usar ativações erradas na saída de regressão",
                                    "Batch size muito pequeno causando instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Treinamento e Otimização do Modelo",
                                  "subSteps": [
                                    "Treinar por 100 épocas com validação cruzada 5-fold.",
                                    "Monitorar curvas de loss e ajustar hiperparâmetros via Keras Tuner.",
                                    "Aplicar regularização L2 (0.001) se detectar overfitting.",
                                    "Salvar melhor modelo baseado em validação.",
                                    "Gerar previsões no conjunto de teste."
                                  ],
                                  "verification": "Modelo treinado com loss de validação < 0.05 e checkpoints salvos.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "TensorFlow/Keras, Keras Tuner"
                                  ],
                                  "tips": [
                                    "Use GPU se disponível para acelerar o treino."
                                  ],
                                  "learningObjective": "Treinar RNA robusta integrando features de autofunções.",
                                  "commonMistakes": [
                                    "Treinar sem validação levando a overfitting",
                                    "Ignorar curvas de aprendizado"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliação e Interpretação dos Resultados",
                                  "subSteps": [
                                    "Calcular métricas: MAE, RMSE, R² para c e φ no teste.",
                                    "Visualizar previsões vs reais com scatter plots e resíduos.",
                                    "Realizar análise de importância de features (SHAP).",
                                    "Testar sensibilidade a variações nos dados geofísicos.",
                                    "Documentar relatório com conclusões e limitações."
                                  ],
                                  "verification": "Relatório de avaliação com métricas acima de thresholds (R² > 0.85).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matplotlib, seaborn, SHAP library"
                                  ],
                                  "tips": [
                                    "Compare com baseline linear para validar ganhos da RNA."
                                  ],
                                  "learningObjective": "Avaliar e interpretar previsões de parâmetros de solo.",
                                  "commonMistakes": [
                                    "Confundir treino com teste nas métricas",
                                    "Não analisar resíduos para heteroscedasticidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de fundação de edifício em solo argiloso, use dados de MASW (velocidades de ondas) para treinar RNA que prevê c=25 kPa e φ=28° , reduzindo necessidade de ensaios triaxiais caros.",
                              "finalVerifications": [
                                "Modelo atinge R² > 0.85 em coesão e ângulo de atrito no teste.",
                                "Features de autofunções explicam >90% variância dos dados originais.",
                                "Previsões geradas para novo dataset geofísico sem erros.",
                                "Relatório documenta integração de Gram matrix e autofunções.",
                                "Análise SHAP identifica features geofísicas mais impactantes.",
                                "Baseline simples (regressão linear) é superado em pelo menos 10%."
                              ],
                              "assessmentCriteria": [
                                "Precisão das previsões (MAE < 5% dos valores médios de c e φ).",
                                "Correta implementação da matriz de Gram e projeção em autofunções.",
                                "Arquitetura RNA otimizada sem overfitting (gap loss treino-validação < 0.02).",
                                "Uso adequado de validação cruzada e métricas de regressão.",
                                "Interpretação clara com visualizações e análise de erros.",
                                "Eficiência computacional (treino < 2h em CPU padrão)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: decomposição espectral e autovalores.",
                                "Estatística: validação cruzada e análise de variância.",
                                "Programação: Python com ML/DL frameworks.",
                                "Geotecnia: interpretação de parâmetros de resistência ao cisalhamento.",
                                "Física: propriedades de propagação de ondas em solos."
                              ],
                              "realWorldApplication": "Previsão de parâmetros de solo em projetos de infraestrutura civil, como barragens e rodovias, otimizando investigações geotécnicas, reduzindo custos em até 30% e acelerando aprovações ambientais."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Simular estabilidade com RNA",
                            "description": "Aplicar RNA em análises de estabilidade de encostas, comparando com métodos numéricos de Kincaid e Cheney (2001).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar métodos numéricos de estabilidade de encostas (Kincaid e Cheney, 2001)",
                                  "subSteps": [
                                    "Ler o capítulo relevante de Kincaid e Cheney (2001) sobre métodos numéricos para estabilidade de taludes.",
                                    "Identificar equações principais para cálculo do fator de segurança (FS) em encostas.",
                                    "Implementar um exemplo simples em Python ou MATLAB usando método de equilíbrio limite.",
                                    "Calcular FS para um caso de estudo básico com parâmetros geotécnicos conhecidos.",
                                    "Documentar limitações dos métodos numéricos tradicionais."
                                  ],
                                  "verification": "Código executado com FS calculado corretamente para o exemplo, comparado com resultados teóricos.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro Kincaid e Cheney (2001)",
                                    "Python/MATLAB",
                                    "Dados de exemplo de encostas"
                                  ],
                                  "tips": "Comece com casos 2D simples antes de complexos; use bibliotecas como NumPy para cálculos matriciais.",
                                  "learningObjective": "Compreender e aplicar métodos numéricos clássicos para benchmark.",
                                  "commonMistakes": [
                                    "Ignorar condições de drenagem",
                                    "Erro na discretização da superfície de ruptura"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar dataset geotécnico para treinamento de RNA",
                                  "subSteps": [
                                    "Coletar dados reais ou sintéticos: ângulo de fricção, coesão, altura de encosta, saturação, etc.",
                                    "Limpar e normalizar dados (z-score ou min-max scaling).",
                                    "Dividir dataset em treino (70%), validação (15%) e teste (15%).",
                                    "Gerar rótulos de estabilidade (FS >1 estável, <1 instável) usando métodos numéricos como referência.",
                                    "Explorar dados com visualizações (correlações, distribuições)."
                                  ],
                                  "verification": "Dataset preparado com pelo menos 500 amostras, normalizado e dividido corretamente (verificar shapes e estatísticas).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Datasets públicos de encostas (USGS ou similares)",
                                    "Pandas, Scikit-learn",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use dados balanceados para evitar bias em classes de instabilidade.",
                                  "learningObjective": "Preparar dados de qualidade para modelagem preditiva com RNA.",
                                  "commonMistakes": [
                                    "Não balancear classes",
                                    "Escolha inadequada de features"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Treinar e validar modelo de RNA para simulação de estabilidade",
                                  "subSteps": [
                                    "Definir arquitetura: MLP com 2-3 camadas ocultas, ativação ReLU, otimizador Adam.",
                                    "Treinar modelo com Keras/TensorFlow, monitorando loss e accuracy.",
                                    "Aplicar validação cruzada (k=5) e early stopping.",
                                    "Ajustar hiperparâmetros (learning rate, neurônios) via grid search.",
                                    "Avaliar no conjunto de teste com métricas: MSE, accuracy, confusão matrix."
                                  ],
                                  "verification": "Modelo treinado com accuracy >85% no teste e loss <0.1.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "TensorFlow/Keras",
                                    "Scikit-learn para métricas",
                                    "GPU recomendada"
                                  ],
                                  "tips": "Use dropout (0.2-0.5) para evitar overfitting em datasets pequenos.",
                                  "learningObjective": "Implementar RNA para prever FS de encostas com precisão.",
                                  "commonMistakes": [
                                    "Overfitting sem validação",
                                    "Hiperparâmetros não otimizados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar simulações RNA vs. métodos numéricos e interpretar resultados",
                                  "subSteps": [
                                    "Executar simulações paralelas: RNA e Kincaid/Cheney em novos casos.",
                                    "Calcular métricas de comparação: erro médio absoluto (MAE), correlação R².",
                                    "Visualizar resultados: gráficos de FS predito vs. real, curvas ROC.",
                                    "Analisar discrepâncias e sensibilidade a parâmetros.",
                                    "Redigir relatório com conclusões sobre vantagens da RNA."
                                  ],
                                  "verification": "Relatório com tabelas/gráficos mostrando R² >0.9 e MAE <0.05.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Matplotlib/Seaborn",
                                    "Código dos passos anteriores"
                                  ],
                                  "tips": "Teste cenários extremos (encostas altas/saturadas) para robustez.",
                                  "learningObjective": "Avaliar superioridade da RNA em relação a métodos tradicionais.",
                                  "commonMistakes": [
                                    "Ignorar incertezas nos dados de entrada",
                                    "Comparação sem normalização"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma encosta de 20m de altura, coesão 10kPa, φ=25°, saturação 80%. Calcule FS numérico=1.2 (estável). Treine RNA com 1000 amostras similares; prediga FS=1.18 (acurácia 92%), validando tempo de computação 10x menor que numérico.",
                              "finalVerifications": [
                                "Modelo RNA prediz FS com erro <5% vs. Kincaid/Cheney em 10 casos teste.",
                                "Gráficos de comparação mostram alta correlação (R²>0.9).",
                                "Relatório documenta dataset, arquitetura e hiperparâmetros.",
                                "Simulação roda em <1min para novos inputs.",
                                "Análise de sensibilidade identifica parâmetros críticos (ex: saturação)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da RNA (accuracy >85%, MAE <0.05).",
                                "Qualidade do benchmark numérico (FS manual correto).",
                                "Robustez: performance em dados não vistos.",
                                "Documentação clara de código e resultados.",
                                "Interpretação: discussão de limitações e aplicações.",
                                "Eficiência computacional vs. métodos tradicionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização e cálculo numérico (gradientes em RNA).",
                                "Estatística: Análise de dados, validação cruzada e métricas de erro.",
                                "Programação: Python/ML libraries para engenharia computacional.",
                                "Geotecnia: Parâmetros de solos e mecanismos de ruptura."
                              ],
                              "realWorldApplication": "Em projetos de rodovias/aterros, RNA acelera análises de risco de deslizamentos durante chuvas, integrando em softwares BIM para monitoramento em tempo real, reduzindo custos de protótipos físicos e prevenindo desastres como em Brumadinho."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.4",
                            "name": "Validar com dados reais",
                            "description": "Validar modelo de RNA geotécnico com conjuntos de dados experimentais, calculando confiança via simulações de Monte Carlo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Aquisição e Preparação de Dados Experimentais Geotécnicos",
                                  "subSteps": [
                                    "Identifique fontes confiáveis de dados experimentais, como testes de penetração cônica (CPT) ou ensaios triaxiais em solos.",
                                    "Colete conjuntos de dados com variáveis relevantes (ex.: profundidade, resistência ao cisalhamento, porosidade).",
                                    "Limpe os dados removendo outliers, tratando valores ausentes e normalizando features.",
                                    "Divida os dados em conjuntos de treinamento (70%), validação (15%) e teste (15%).",
                                    "Documente metadados dos dados, incluindo condições experimentais e unidades."
                                  ],
                                  "verification": "Verifique se o dataset limpo tem pelo menos 1000 amostras válidas e estatísticas descritivas (média, desvio padrão) calculadas.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Planilhas Excel/Google Sheets, Python com pandas e numpy, datasets públicos como USGS Soil Database.",
                                  "tips": "Use visualizações (histogramas, boxplots) para detectar anomalias antes da limpeza.",
                                  "learningObjective": "Compreender a importância de dados de alta qualidade para validação robusta de modelos de RNA.",
                                  "commonMistakes": "Ignorar unidades inconsistentes nos dados ou não balancear classes em solos heterogêneos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração do Modelo de RNA Treinado",
                                  "subSteps": [
                                    "Carregue o modelo de RNA geotécnico previamente treinado (ex.: rede feedforward para previsão de parâmetros de solo).",
                                    "Ajuste hiperparâmetros se necessário (ex.: learning rate, número de neurônios) com base em validação cruzada.",
                                    "Implemente pré-processamento idêntico ao usado no treinamento (normalização min-max ou z-score).",
                                    "Defina métricas de avaliação iniciais: MSE, MAE, R².",
                                    "Teste o modelo em um subconjunto pequeno para confirmar funcionamento."
                                  ],
                                  "verification": "Execute uma predição em 10 amostras e confirme que as saídas estão no intervalo físico esperado (ex.: resistência >0).",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com TensorFlow/Keras ou PyTorch, Jupyter Notebook, modelo salvo (.h5 ou .pth).",
                                  "tips": "Salve o pré-processador (Scaler) junto ao modelo para consistência.",
                                  "learningObjective": "Garantir reprodutibilidade na aplicação do modelo a novos dados.",
                                  "commonMistakes": "Aplicar normalização diferente do treinamento, levando a predições enviesadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Execução da Validação com Dados Experimentais",
                                  "subSteps": [
                                    "Aplique o modelo aos dados de teste experimentais e gere predições.",
                                    "Calcule métricas de performance: erro quadrático médio (RMSE), correlação entre predito e real.",
                                    "Gere gráficos de dispersão (predito vs. observado) e resíduos.",
                                    "Compare com benchmarks empíricos (ex.: correlações CPT tradicionais).",
                                    "Registre discrepâncias regionais ou por tipo de solo."
                                  ],
                                  "verification": "Métricas mostram RMSE < 10% do desvio padrão dos dados reais e R² > 0.85.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com scikit-learn (metrics), matplotlib/seaborn para plots.",
                                  "tips": "Use validação cruzada k-fold (k=5) nos dados de teste para robustez.",
                                  "learningObjective": "Avaliar quão bem o modelo generaliza para dados reais não vistos.",
                                  "commonMistakes": "Sobreajuste ao superestimar R² sem checar resíduos heteroscedásticos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementação de Simulações de Monte Carlo para Intervalos de Confiança",
                                  "subSteps": [
                                    "Defina distribuições de incerteza nos dados de entrada (ex.: normal para medições CPT, μ=valor médio, σ=5%).",
                                    "Gere N=10000 amostras Monte Carlo via bootstrapping ou reamostragem.",
                                    "Propague as amostras através do modelo de RNA para obter distribuições de saída.",
                                    "Calcule percentis (2.5% e 97.5%) para intervalos de confiança de 95%.",
                                    "Avalie cobertura: % de valores reais dentro dos intervalos gerados."
                                  ],
                                  "verification": "Intervalos de confiança cobrem >90% dos dados reais e largura média <20% do valor médio.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Python com numpy.random, scipy.stats, multiprocessing para aceleração.",
                                  "tips": "Paralelize simulações para N grande usando joblib ou multiprocessing.",
                                  "learningObjective": "Quantificar incertezas propagadas do modelo e dados.",
                                  "commonMistakes": "Subestimar variância de entrada, resultando em intervalos irrealisticamente estreitos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Análise Final e Relatório de Confiança",
                                  "subSteps": [
                                    "Sintetize métricas: tabela com RMSE, cobertura MC, comparações empíricas.",
                                    "Interprete resultados: aceita/rejeita modelo baseado em thresholds (ex.: cobertura >95%).",
                                    "Gere relatório com visualizações (histogramas MC, funis de confiança).",
                                    "Recomende melhorias (ex.: mais dados, ensemble de RNAs).",
                                    "Arquive código e resultados para reprodutibilidade."
                                  ],
                                  "verification": "Relatório completo com todas métricas e conclusão clara sobre validade do modelo.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Jupyter Notebook para relatório, LaTeX/Pandoc para PDF final.",
                                  "tips": "Use templates de relatório para padronização.",
                                  "learningObjective": "Comunicar resultados de validação de forma profissional.",
                                  "commonMistakes": "Omitir sensibilidade a hiperparâmetros MC como N ou σ."
                                }
                              ],
                              "practicalExample": "Valide um modelo de RNA treinado para prever a resistência ao cisalhamento de argila a partir de dados CPT de um canteiro de obras em São Paulo: use 500 perfis reais, execute 5000 iterações MC com σ=3% nas medições de ponta, obtendo IC95% de [150-220 kPa] vs. valor médio experimental de 185 kPa, com cobertura de 92%.",
                              "finalVerifications": [
                                "Métricas de validação (RMSE, R²) atendem thresholds geotécnicos (>0.85 R²).",
                                "Simulações MC convergem (variação <1% após N=5000).",
                                "Intervalos de confiança cobrem >90% dos dados experimentais reais.",
                                "Gráficos mostram padrões físicos plausíveis (sem predições negativas).",
                                "Relatório documenta todas suposições e seeds aleatórias.",
                                "Código é executável e reproduz resultados em <10min."
                              ],
                              "assessmentCriteria": [
                                "Precisão: RMSE <15% do range dos dados reais.",
                                "Robustez: Cobertura MC >92% com largura IC <25%.",
                                "Eficiência: Tempo total de validação <24h em máquina padrão.",
                                "Reprodutibilidade: Resultados idênticos com mesma seed.",
                                "Interpretação: Conclusões alinhadas com literatura geotécnica.",
                                "Documentação: Código comentado e relatório claro."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Propagação de incertezas e inferência bayesiana.",
                                "Programação: Otimização paralela e manipulação de dados em Python.",
                                "Geotecnia: Correlações empíricas CPT e comportamento de solos.",
                                "Machine Learning: Generalização e quantificação de incerteza em RNAs.",
                                "Engenharia de Riscos: Análise probabilística para projetos civis."
                              ],
                              "realWorldApplication": "Em projetos de fundações profundas, como arranha-céus ou barragens, validar modelos de RNA com dados CPT reais via Monte Carlo permite quantificar riscos de falha no dimensionamento de estacas, evitando superdimensionamentos caros ou subdimensionamentos perigosos, conforme normas ABNT NBR 6122."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Geração de Números Aleatórios e Método de Monte Carlo",
                "description": "Geração de números pseudo-aleatórios e uso do método de Monte Carlo em simulações estocásticas.",
                "totalSkills": 57,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Números Pseudo-Aleatórios",
                    "description": "Definição e propriedades de sequências numéricas geradas deterministicamente que simulam aleatoriedade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.1.1",
                        "name": "Definição de Números Pseudo-Aleatórios",
                        "description": "Conceito fundamental que define números pseudo-aleatórios como sequências numéricas geradas por algoritmos determinísticos que aparentam aleatoriedade, diferenciando-os de números aleatórios verdadeiros.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.1",
                            "name": "Diferenciar números pseudo-aleatórios de aleatórios verdadeiros",
                            "description": "Identificar as características determinísticas dos números pseudo-aleatórios, explicando que eles são produzidos por fórmulas matemáticas baseadas em uma semente inicial, ao contrário de processos físicos aleatórios como ruído térmico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Números Aleatórios Verdadeiros (TRNG)",
                                  "subSteps": [
                                    "Defina aleatoriedade verdadeira como oriunda de processos físicos imprevisíveis.",
                                    "Identifique fontes comuns: ruído térmico, decaimento radioativo, ruído atmosférico.",
                                    "Explique o conceito de entropia como medida de imprevisibilidade.",
                                    "Discuta hardware RNG como geradores baseados em fenômenos quânticos.",
                                    "Compare com previsibilidade: cada geração é única e não repetível."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito três fontes de TRNG e por que são imprevisíveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo sobre entropia e TRNG",
                                    "Vídeo explicativo sobre fontes físicas de aleatoriedade (ex: YouTube - True Random Number Generators)"
                                  ],
                                  "tips": "Lembre-se: aleatoriedade verdadeira não pode ser reproduzida, mesmo com as mesmas condições iniciais.",
                                  "learningObjective": "Identificar e descrever fontes físicas de aleatoriedade verdadeira.",
                                  "commonMistakes": [
                                    "Confundir TRNG com software comum",
                                    "Achar que todos os processos computacionais são verdadeiramente aleatórios"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Números Pseudo-Aleatórios (PRNG)",
                                  "subSteps": [
                                    "Defina PRNG como sequência gerada por algoritmo determinístico.",
                                    "Explique o papel da semente (seed) inicial na geração.",
                                    "Descreva fórmulas comuns: Linear Congruential Generator (LCG) ou Mersenne Twister.",
                                    "Demonstre repetibilidade: mesma seed produz mesma sequência.",
                                    "Liste propriedades: aparência aleatória, mas periodicidade e padrões detectáveis."
                                  ],
                                  "verification": "Gere uma sequência com seed fixa e reproduza-a para confirmar determinismo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Python random module",
                                    "Calculadora ou código simples em Python para LCG"
                                  ],
                                  "tips": "Sempre teste com seed fixa para ver padrões; PRNG é 'aleatório' só superficialmente.",
                                  "learningObjective": "Descrever o mecanismo determinístico dos PRNG e seu dependência de seed.",
                                  "commonMistakes": [
                                    "Achar PRNG imprevisível",
                                    "Ignorar a periodicidade longa mas finita"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Características Determinísticas dos PRNG",
                                  "subSteps": [
                                    "Analise repetibilidade: execute gerador múltiplas vezes com mesma seed.",
                                    "Detecte padrões: correlações lineares em LCG ou ciclo finito.",
                                    "Compare distribuições: teste uniformidade vs. verdadeiros aleatórios.",
                                    "Discuta vulnerabilidades: previsibilidade em criptografia se seed conhecida.",
                                    "Use testes estatísticos simples: frequência, runs test."
                                  ],
                                  "verification": "Realize teste de repetibilidade e documente resultados idênticos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python ou Excel para gerar sequências",
                                    "Ferramenta online de testes de aleatoriedade (ex: NIST STS)"
                                  ],
                                  "tips": "Grave seeds e sequências lado a lado para visualização clara de determinismo.",
                                  "learningObjective": "Reconhecer evidências empíricas de determinismo em PRNG.",
                                  "commonMistakes": [
                                    "Confiar cegamente na 'aleatoriedade' visual",
                                    "Não testar repetibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Diferenciar PRNG de TRNG",
                                  "subSteps": [
                                    "Crie tabela comparativa: fonte, repetibilidade, entropia, aplicações.",
                                    "Discuta trade-offs: PRNG rápido e reproduzível vs. TRNG lento e seguro.",
                                    "Aplique em Monte Carlo: PRNG suficiente para simulações civis.",
                                    "Simule falha: use PRNG ruim em cripto e veja quebra.",
                                    "Conclua quando usar cada um."
                                  ],
                                  "verification": "Apresente tabela comparativa e explique escolha para um cenário.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha para tabela comparativa",
                                    "Exemplos de código Python misturando random e secrets module"
                                  ],
                                  "tips": "Foco em contexto: engenharia usa PRNG por eficiência em simulações.",
                                  "learningObjective": "Diferenciar claramente PRNG e TRNG com exemplos práticos.",
                                  "commonMistakes": [
                                    "Subestimar PRNG para segurança",
                                    "Superestimar custo de TRNG"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python, execute: import random; random.seed(42); print([random.randint(1,100) for _ in range(5)]) → [81, 46, 12, 89, 23] sempre. Para TRNG: use secrets module ou leia /dev/urandom → sequência única toda vez. Teste repetindo 10x.",
                              "finalVerifications": [
                                "Explicar determinismo de PRNG com seed.",
                                "Listar 3 fontes de TRNG.",
                                "Demonstrar repetibilidade de PRNG via código.",
                                "Identificar por que PRNG falha em criptografia.",
                                "Escolher corretamente PRNG vs TRNG para Monte Carlo.",
                                "Detectar padrão em sequência PRNG curta."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de PRNG e TRNG (80%+ correto).",
                                "Demonstração prática de repetibilidade.",
                                "Tabela comparativa completa e precisa.",
                                "Explicação clara de trade-offs e aplicações.",
                                "Identificação correta de 3+ características determinísticas.",
                                "Uso adequado de testes empíricos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmos recursivos e funções modulares.",
                                "Física: Fenômenos quânticos e termodinâmica (entropia).",
                                "Computação: Programação de geradores e testes estatísticos.",
                                "Estatística: Testes de hipóteses de aleatoriedade (Chi-quadrado).",
                                "Engenharia Civil: Simulações Monte Carlo para análise de riscos estruturais."
                              ],
                              "realWorldApplication": "Em análises Monte Carlo para projetos civis (ex: carga de vento em pontes), PRNG permite simulações reproduzíveis e rápidas para validar modelos de risco, evitando erros de aleatoriedade fraca que poderiam subestimar falhas catastróficas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2",
                            "name": "Explicar o papel da semente inicial",
                            "description": "Compreender como uma semente (valor inicial) determina toda a sequência pseudo-aleatória de forma reproduzível, permitindo simulações consistentes em aplicações de engenharia civil como Monte Carlo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o conceito de semente inicial em geradores pseudo-aleatórios",
                                  "subSteps": [
                                    "Ler definições de semente em documentação de RNGs como Python's random module ou NumPy.",
                                    "Diferenciar semente de números aleatórios verdadeiros, destacando o caráter determinístico.",
                                    "Exemplificar com analogia: semente como 'receita inicial' que produz sempre o mesmo 'prato'.",
                                    "Identificar o propósito: iniciar o estado interno do gerador.",
                                    "Listar cenários onde reproducibilidade é essencial, como testes científicos."
                                  ],
                                  "verification": "Escrever uma definição de 3-5 frases explicando a semente e recitá-la corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Python random: https://docs.python.org/3/library/random.html",
                                    "Vídeo introdutório sobre PRNGs (5-10 min)",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Visualize a semente como a posição inicial de uma roda dentada em um mecanismo clockwork.",
                                  "learningObjective": "Compreender a semente como valor inicial que torna o processo pseudo-aleatório determinístico e reproduzível.",
                                  "commonMistakes": [
                                    "Confundir semente com o primeiro número gerado",
                                    "Acreditar que semente garante aleatoriedade perfeita",
                                    "Ignorar que diferentes sementes produzem sequências diferentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o mecanismo de geração a partir da semente",
                                  "subSteps": [
                                    "Estudar fórmula básica de Linear Congruential Generator (LCG): X_{n+1} = (a * X_n + c) mod m, onde X_0 é a semente.",
                                    "Executar cálculo manual de 3-5 iterações com semente fixa (ex: semente=7, a=5, c=3, m=16).",
                                    "Implementar LCG simples em Python ou calculadora para gerar sequência.",
                                    "Comparar sequências de comprimentos variados iniciadas pela mesma semente.",
                                    "Analisar como pequenas mudanças na semente alteram toda a sequência."
                                  ],
                                  "verification": "Gerar e listar 10 números de uma sequência LCG manualmente e via código, confirmando igualdade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora ou papel para cálculos manuais",
                                    "Editor de código Python (VS Code, Jupyter)",
                                    "Referência LCG: Wikipedia ou livro de métodos numéricos"
                                  ],
                                  "tips": "Comece com parâmetros simples para evitar erros aritméticos; use mod m para manter números gerenciáveis.",
                                  "learningObjective": "Dominar como a semente propaga deterministicamente através do algoritmo para formar a sequência inteira.",
                                  "commonMistakes": [
                                    "Erros em cálculos modulares (ex: esquecer mod m)",
                                    "Confundir parâmetros a, c, m com a semente",
                                    "Executar apenas uma iteração, perdendo visão da cadeia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar a reproducibilidade da sequência com semente fixa",
                                  "subSteps": [
                                    "Configurar gerador com semente fixa (ex: random.seed(123)) e gerar 10 números.",
                                    "Reiniciar programa múltiplas vezes (3x) com mesma semente e verificar identidade das sequências.",
                                    "Testar com semente diferente e comparar diferenças.",
                                    "Salvar sequências em arquivo para prova visual.",
                                    "Explicar impacto em debugging: 'set seed' para reproduzir bugs aleatórios."
                                  ],
                                  "verification": "Executar código 3 vezes e confirmar sequências idênticas bit a bit.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com random e numpy",
                                    "Script pronto: import random; random.seed(123); print([random.random() for _ in range(10)])",
                                    "Ferramenta de diff para comparar outputs"
                                  ],
                                  "tips": "Use print com alta precisão (random.random() com format) para verificar exatidão numérica.",
                                  "learningObjective": "Provar empiricamente que a semente garante a mesma sequência em execuções independentes.",
                                  "commonMistakes": [
                                    "Não resetar semente corretamente entre runs",
                                    "Usar random sem seed, obtendo variabilidade real",
                                    "Ignorar flutuações de ponto flutuante em comparações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contextualizar o papel da semente em simulações Monte Carlo para Engenharia Civil",
                                  "subSteps": [
                                    "Revisar Monte Carlo: usar amostras aleatórias para estimar propriedades (ex: falha estrutural).",
                                    "Simular Monte Carlo simples para carga em viga com semente fixa (ex: 1000 simulações de variação de material).",
                                    "Executar simulação 2x com mesma semente, validando consistência de resultados (média, desvio).",
                                    "Discutir cenários civis: análise de risco sísmico, otimização de fundações.",
                                    "Relatar vantagens: reproducibilidade para validação, compartilhamento de resultados."
                                  ],
                                  "verification": "Produzir relatório com código, outputs idênticos e interpretação dos resultados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com numpy.random, matplotlib para plots",
                                    "Exemplo código Monte Carlo para probabilidade de falha em estrutura",
                                    "Dados fictícios de engenharia civil (cargas, materiais)"
                                  ],
                                  "tips": "Integre seed no topo do script; plot histograma para visualizar consistência.",
                                  "learningObjective": "Aplicar conceito de semente para habilitar simulações consistentes em problemas de engenharia civil.",
                                  "commonMistakes": [
                                    "Usar aleatoriedade sem seed em simulações longas",
                                    "Subestimar tempo computacional em loops grandes",
                                    "Não conectar de volta ao determinismo da semente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python para simulação Monte Carlo de falha em uma laje de concreto: `import numpy as np; np.random.seed(42); cargas = np.random.normal(100, 20, 10000); falhas = np.sum(cargas > 150) / 10000`. Executando múltiplas vezes, a fração de falhas (ex: 0.0228) é sempre idêntica, permitindo análise reproduzível.",
                              "finalVerifications": [
                                "Explicar em 1 minuto o papel da semente sem consultar notas.",
                                "Gerar sequência idêntica de 20 números pseudo-aleatórios com semente fixa.",
                                "Executar Monte Carlo simples e confirmar resultados consistentes em 3 runs.",
                                "Identificar 3 benefícios da semente em engenharia.",
                                "Diferenciar output com/ sem semente em código demo."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa e completa da semente (80% cobertura conceitual).",
                                "Cálculos e códigos executados corretamente sem erros.",
                                "Demonstração clara de reproducibilidade com evidências empíricas.",
                                "Conexões lógicas com Monte Carlo em contextos civis.",
                                "Relatório estruturado com exemplos e interpretações."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação e uso de bibliotecas RNG em scripts.",
                                "Estatística: Reprodutibilidade em métodos de simulação estocástica.",
                                "Matemática: Algoritmos iterativos e aritmética modular.",
                                "Física/Engenharia Mecânica: Modelagem de incertezas em cargas e materiais.",
                                "Ciência da Computação: Determinismo em sistemas pseudo-aleatórios."
                              ],
                              "realWorldApplication": "Na engenharia civil, sementes fixas em simulações Monte Carlo para análise de risco sísmico em pontes permitem que equipes reproduzam cenários exatos de falha potencial, facilitando validação de projetos, depuração de modelos e relatórios regulatórios consistentes, como na previsão de colapso sob cargas variáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3",
                            "name": "Reconhecer a determinística na geração",
                            "description": "Analisar que, apesar da aparente aleatoriedade, a mesma semente sempre gera a mesma sequência, fundamental para depuração e validação em soluções computacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de determinismo em geradores pseudo-aleatórios",
                                  "subSteps": [
                                    "Estude a definição de números pseudo-aleatórios (PRA): sequências que parecem aleatórias mas são geradas por algoritmos determinísticos.",
                                    "Aprenda o papel da semente (seed): valor inicial que inicializa o gerador, garantindo a mesma sequência para a mesma semente.",
                                    "Diferencie aleatoriedade verdadeira (hardware) de pseudo-aleatoriedade (software).",
                                    "Analise por que o determinismo é crucial: permite reproducibilidade em testes e depuração.",
                                    "Revise exemplos matemáticos simples, como o gerador linear congruencial: X_{n+1} = (a * X_n + c) mod m."
                                  ],
                                  "verification": "Explique em suas palavras por que a mesma semente produz a mesma sequência e liste 2 benefícios para engenharia computacional.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Python random module",
                                    "Artigo sobre geradores pseudo-aleatórios (ex: Wikipedia Linear Congruential Generator)",
                                    "Notebook Jupyter ou editor de código"
                                  ],
                                  "tips": "Use analogias: pense na semente como uma 'foto inicial' de um dado que sempre rola da mesma forma.",
                                  "learningObjective": "Entender que pseudo-aleatoriedade é determinística e o impacto da semente na reproducibilidade.",
                                  "commonMistakes": [
                                    "Confundir pseudo-aleatório com verdadeiramente aleatório",
                                    "Ignorar que sem semente fixa, o sistema usa tempo atual como default"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e gerar sequências com semente fixa em Python",
                                  "subSteps": [
                                    "Instale/importe a biblioteca random: import random.",
                                    "Defina uma semente fixa: random.seed(42).",
                                    "Gere uma sequência de 10 números: [random.random() for _ in range(10)].",
                                    "Registre a sequência gerada em uma lista ou arquivo.",
                                    "Repita a geração sem alterar a semente e compare."
                                  ],
                                  "verification": "Execute o código duas vezes com a mesma semente e confirme que as sequências são idênticas (hash ou print igual).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "IDE como VS Code ou Jupyter Notebook",
                                    "Biblioteca random (padrão)"
                                  ],
                                  "tips": "Sempre fixe a semente no início do script para consistência em experimentos.",
                                  "learningObjective": "Implementar geração determinística de números pseudo-aleatórios usando semente.",
                                  "commonMistakes": [
                                    "Esquecer de importar random",
                                    "Definir semente após a primeira geração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar e validar o determinismo comparando sementes",
                                  "subSteps": [
                                    "Gere sequências com semente 42 e salve.",
                                    "Gere com semente diferente (ex: 123) e compare diferenças.",
                                    "Teste sem semente (default) em execuções separadas para ver variação.",
                                    "Meça estatísticas básicas (média, desvio padrão) para confirmar propriedades aleatórias apesar do determinismo.",
                                    "Documente observações em um relatório curto."
                                  ],
                                  "verification": "Produza tabelas comparativas mostrando sequências idênticas para mesma semente e diferentes para sementes variadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código Python do Step 2",
                                    "Pandas para tabelas (opcional: import pandas as pd)",
                                    "Planilha Excel para registro"
                                  ],
                                  "tips": "Use print com formatação para comparar floats precisamente: print(f'{num:.10f}').",
                                  "learningObjective": "Validar empiricamente o determinismo através de experimentos controlados.",
                                  "commonMistakes": [
                                    "Usar semente após randomizações iniciais",
                                    "Comparar floats sem precisão suficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em uma simulação simples de Monte Carlo para engenharia civil",
                                  "subSteps": [
                                    "Crie uma simulação: gere cargas aleatórias em uma viga (ex: normal distribution com seed fixa).",
                                    "Calcule fator de segurança médio em 1000 iterações.",
                                    "Repita com mesma semente e valide resultados idênticos.",
                                    "Altere semente e discuta impactos na validação.",
                                    "Conclua com código comentado e insights."
                                  ],
                                  "verification": "Execute simulação 3 vezes com mesma semente; resultados devem coincidir em até 1e-10.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com numpy: import numpy as np",
                                    "Código base de Monte Carlo para viga simples"
                                  ],
                                  "tips": "Use np.random.normal com seed para distribuições realistas em engenharia.",
                                  "learningObjective": "Reconhecer utilidade do determinismo em validação de simulações computacionais.",
                                  "commonMistakes": [
                                    "Não fixar seed em todas as randomizações da simulação",
                                    "Ignorar flutuações numéricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para análise de uma ponte sob cargas variáveis: fixe seed=42 para gerar 10.000 cargas pseudo-aleatórias; execute duas vezes e obtenha o mesmo risco de falha (ex: 2.5%), permitindo depuração precisa de discrepâncias.",
                              "finalVerifications": [
                                "Gere 20 números pseudo-aleatórios com seed=100 duas vezes e confirme identidade exata.",
                                "Explique verbalmente ou por escrito: 'Por que depuração é mais fácil com determinismo?'.",
                                "Implemente e rode uma simulação Monte Carlo simples com seed fixa, reproduzindo resultados.",
                                "Identifique em código onde a seed afeta a saída e altere para testar.",
                                "Compare estatísticas (média, variância) de sequências com/ sem seed fixa."
                              ],
                              "assessmentCriteria": [
                                "Compreensão conceitual: explica corretamente determinismo vs. aleatoriedade (80% precisão).",
                                "Implementação prática: código gera sequências idênticas com mesma seed (funcionalidade total).",
                                "Validação empírica: compara e documenta resultados de múltiplas execuções.",
                                "Aplicação contextual: relaciona a engenharia civil (ex: reproducibilidade em simulações).",
                                "Análise de erros: identifica e corrige common mistakes como seed mal posicionada.",
                                "Relatório claro: inclui verificações, tempos e lições aprendidas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de números e congruências lineares.",
                                "Estatística: Propriedades de distribuições pseudo-aleatórias (teste de uniformidade).",
                                "Programação: Controle de estado em bibliotecas random.",
                                "Engenharia Civil: Simulações Monte Carlo para análise estrutural e risco."
                              ],
                              "realWorldApplication": "Na validação de modelos computacionais para projetos de barragens ou edifícios, onde simulações Monte Carlo com sementes fixas garantem que engenheiros reproduzam resultados exatos para auditorias regulatórias e depuração de falhas em análises de risco sísmico."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.2",
                        "name": "Propriedades Desejáveis de Sequências Pseudo-Aleatórias",
                        "description": "Propriedades estatísticas e matemáticas que uma boa sequência pseudo-aleatória deve possuir para simular adequadamente a aleatoriedade em métodos numéricos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.2.1",
                            "name": "Identificar o período da sequência",
                            "description": "Definir e calcular o período como o número de elementos antes da repetição da sequência, enfatizando a importância de períodos longos para evitar ciclos curtos em simulações extensas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição de Período em Sequências Pseudo-Aleatórias",
                                  "subSteps": [
                                    "Ler a definição formal: o período é o menor número positivo k tal que X_{n+k} = X_n para todo n suficientemente grande.",
                                    "Estudar exemplos de sequências periódicas curtas e longas.",
                                    "Analisar por que sequências com período curto são indesejáveis em simulações.",
                                    "Discutir a relação com o módulo m em geradores congruenciais lineares.",
                                    "Visualizar graficamente a repetição da sequência."
                                  ],
                                  "verification": "Explicar em suas próprias palavras o conceito de período e sua importância, com um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Texto introdutório sobre números pseudo-aleatórios",
                                    "Vídeo explicativo (ex: Khan Academy ou YouTube)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Associe o período a um 'ciclo de repetição' como em padrões musicais para facilitar a memorização.",
                                  "learningObjective": "Definir precisamente o período e justificar sua relevância em simulações extensas.",
                                  "commonMistakes": [
                                    "Confundir período com o comprimento total da sequência",
                                    "Ignorar que o período é o menor k possível",
                                    "Achar que todas as sequências têm período infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Padrões de Repetição em Sequências Dadas",
                                  "subSteps": [
                                    "Listar os primeiros 20 termos de uma sequência pseudo-aleatória fornecida.",
                                    "Comparar termos iniciais com subsequentes para detectar repetições.",
                                    "Marcar visualmente o ponto onde a sequência retorna ao estado inicial.",
                                    "Testar diferentes pontos potenciais de repetição para confirmar o menor k.",
                                    "Registrar observações sobre a estrutura cíclica observada."
                                  ],
                                  "verification": "Apontar corretamente o início da repetição em uma sequência exemplo de 15 termos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para listar sequências",
                                    "Sequências de exemplo impressas ou digitais",
                                    "Calculadora"
                                  ],
                                  "tips": "Use cores diferentes para destacar termos iniciais e repetidos para visualização rápida.",
                                  "learningObjective": "Detectar visual e numericamente o ciclo de repetição em sequências curtas.",
                                  "commonMistakes": [
                                    "Parar na primeira repetição parcial sem verificar o ciclo completo",
                                    "Contar termos errados devido a desalinhamento",
                                    "Confundir repetição local com período global"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Período de uma Sequência Manualmente",
                                  "subSteps": [
                                    "Escolher uma sequência gerada por método congruencial linear com parâmetros conhecidos.",
                                    "Gerar termos sequencialmente até detectar repetição do primeiro termo e sequência inicial.",
                                    "Contar o número exato de elementos únicos antes da repetição.",
                                    "Verificar se k é o menor possível testando divisores.",
                                    "Documentar o cálculo passo a passo em uma tabela."
                                  ],
                                  "verification": "Calcular corretamente o período de uma sequência de pelo menos 10 termos e apresentar o raciocínio.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Fórmula do gerador congruencial linear",
                                    "Papel quadriculado ou software como Python/Excel para geração",
                                    "Tabela de parâmetros (a, c, m, X0)"
                                  ],
                                  "tips": "Comece sempre pelo estado inicial (X0) e procure quando ele e os seguintes se repetem exatamente.",
                                  "learningObjective": "Executar cálculo preciso do período, identificando o comprimento do ciclo.",
                                  "commonMistakes": [
                                    "Erro aritmético na geração de termos",
                                    "Não reconhecer que o período pode ser menor que m",
                                    "Contar inclusive o termo repetido no comprimento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar a Qualidade do Período e Sua Importância",
                                  "subSteps": [
                                    "Comparar o período calculado com o tamanho da simulação pretendida.",
                                    "Discutir impactos de períodos curtos (ex: viés em Monte Carlo).",
                                    "Pesquisar critérios para períodos 'bons' (ex: próximo a 2^31).",
                                    "Propor melhorias em parâmetros para aumentar o período.",
                                    "Aplicar o conceito a um caso de engenharia civil."
                                  ],
                                  "verification": "Explicar por que um período longo é crucial e sugerir um parâmetro melhor para um gerador dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigos sobre propriedades de LCG",
                                    "Exemplos de simulações Monte Carlo em engenharia",
                                    "Internet para pesquisa rápida"
                                  ],
                                  "tips": "Pense em termos práticos: 'Quantas iterações de simulação cabem antes de repetir?'",
                                  "learningObjective": "Avaliar criticamente a adequação do período para aplicações reais.",
                                  "commonMistakes": [
                                    "Subestimar o impacto de ciclos curtos em grandes simulações",
                                    "Ignorar dependência de parâmetros como m primo",
                                    "Generalizar que período = m sempre"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o gerador congruencial linear X_{n+1} = (5 * X_n + 1) mod 8, com X_0 = 0. Sequência: 0,1,6,7,4,5,2,3,0,... O período é 8, pois após 8 termos retorna exatamente a 0 e repete. Calcule e verifique manualmente.",
                              "finalVerifications": [
                                "Define corretamente o período como o menor k de repetição completa.",
                                "Identifica o período em sequências curtas (<20 termos) com 100% de acerto.",
                                "Calcula período de gerador LCG simples sem erros aritméticos.",
                                "Explica a importância de períodos longos para simulações extensas.",
                                "Avalia adequadamente a qualidade de um período dado contexto.",
                                "Aplica o conceito a um exemplo de Monte Carlo em engenharia."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual na definição (sem ambiguidades).",
                                "Correção no cálculo do período (menor k identificado).",
                                "Profundidade na análise de repetições e padrões.",
                                "Clareza na explicação da importância prática.",
                                "Criatividade em conexões com aplicações reais.",
                                "Ausência de erros comuns listados nos steps."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números e congruências modulares.",
                                "Programação: Implementação e teste de geradores RNG em Python ou MATLAB.",
                                "Estatística: Avaliação de independência em amostras pseudo-aleatórias.",
                                "Engenharia de Computação: Otimização de algoritmos de simulação.",
                                "Física: Modelagem estocástica em dinâmicas de estruturas."
                              ],
                              "realWorldApplication": "Em análises Monte Carlo para dimensionamento de estruturas civis sob cargas sísmicas aleatórias, um período curto no gerador pseudo-aleatório pode repetir padrões, levando a subestimação de riscos e falhas catastróficas em pontes ou edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.2.2",
                            "name": "Avaliar uniformidade e independência",
                            "description": "Verificar se os números estão uniformemente distribuídos no intervalo [0,1] e se são estatisticamente independentes, usando testes simples como histograma para análise visual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a sequência de números pseudo-aleatórios",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: numpy e matplotlib via pip.",
                                    "Implemente ou carregue um gerador de números pseudo-aleatórios (ex: linear congruencial ou random.uniform).",
                                    "Gere uma sequência de pelo menos 10.000 números no intervalo [0,1].",
                                    "Salve a sequência em um array numpy para análise.",
                                    "Visualize os primeiros e últimos valores para inspeção inicial."
                                  ],
                                  "verification": "Confirme que o array tem o tamanho correto e valores entre 0 e 1 usando print ou len().",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python 3+, Jupyter Notebook, bibliotecas numpy e matplotlib",
                                  "tips": "Use np.random.seed(42) para reprodutibilidade nos testes.",
                                  "learningObjective": "Entender como gerar sequências pseudo-aleatórias adequadas para testes estatísticos.",
                                  "commonMistakes": "Gerar amostras muito pequenas (<1000), o que invalida análises visuais; ignorar normalização para [0,1]."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e analisar histograma para uniformidade",
                                  "subSteps": [
                                    "Divida o intervalo [0,1] em 10-20 bins iguais.",
                                    "Crie o histograma usando plt.hist() com density=True para normalizar.",
                                    "Plote o histograma e adicione uma linha de referência uniforme (y=1).",
                                    "Calcule estatísticas básicas: média ≈0.5, variância ≈1/12.",
                                    "Ajuste bins se necessário para melhor visualização."
                                  ],
                                  "verification": "O histograma deve mostrar barras aproximadamente iguais em altura, sem picos ou vales pronunciados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com numpy e matplotlib",
                                  "tips": "Use bins=10 * np.sqrt(N) para número ótimo de bins, onde N é o tamanho da amostra.",
                                  "learningObjective": "Aplicar análise visual para verificar distribuição uniforme em [0,1].",
                                  "commonMistakes": "Usar bins irregulares ou não normalizar o histograma, levando a interpretações erradas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar independência com scatter plot de lags",
                                  "subSteps": [
                                    "Crie um scatter plot de x[i] vs x[i+1] para i=0 a N-2.",
                                    "Adicione uma linha y=x para referência.",
                                    "Calcule a correlação de Pearson entre pares consecutivos (deve ser ≈0).",
                                    "Repita para lags 2 e 3 se possível.",
                                    "Inspecione visualmente por padrões ou clusters."
                                  ],
                                  "verification": "Scatter plot uniforme ao redor de y=x sem tendências lineares ou agrupamentos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com numpy, matplotlib e scipy.stats para correlação",
                                  "tips": "Use plt.scatter com alpha=0.1 para grandes amostras evitar sobreposição visual.",
                                  "learningObjective": "Detectar dependências seriais em sequências pseudo-aleatórias via visualização.",
                                  "commonMistakes": "Confundir ruído aleatório com padrões reais; usar lags muito altos sem amostra suficiente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e documentar conclusões",
                                  "subSteps": [
                                    "Compare histograma com distribuição uniforme ideal.",
                                    "Analise scatter plots para ausência de correlação.",
                                    "Registre métricas quantitativas: KS-test p-value >0.05 para uniformidade.",
                                    "Conclua se a sequência atende aos critérios (uniforme e independente).",
                                    "Salve gráficos e relatório em PDF ou notebook."
                                  ],
                                  "verification": "Relatório escrito afirma 'uniforme' ou 'não uniforme' com evidências visuais e métricas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Jupyter Notebook para exportação",
                                  "tips": "Inclua thresholds: desvio >20% em bins indica não-uniformidade.",
                                  "learningObjective": "Sintetizar análises visuais em julgamentos estatísticos acionáveis.",
                                  "commonMistakes": "Ignorar viés do gerador (ex: LCG ruim em lags altos); superinterpretar ruído como falha."
                                }
                              ],
                              "practicalExample": "Gere 10.000 números usando o gerador congruencial linear X_{n+1} = (a*X_n + c) mod m com a=1664525, c=1013904223, m=2^32, X0=1. Plote histograma (deve ser uniforme) e scatter x[n] vs x[n+1] (sem correlação).",
                              "finalVerifications": [
                                "Histograma mostra barras com alturas variando <15% da média.",
                                "Correlação de Pearson entre pares consecutivos |r| < 0.05.",
                                "Média da sequência ≈0.5 e variância ≈0.083.",
                                "Scatter plot sem padrões visíveis ou clusters.",
                                "Teste KS para uniformidade com p-value >0.05.",
                                "Relatório documenta todas as evidências gráficamente."
                              ],
                              "assessmentCriteria": [
                                "Gera sequência adequada (>10k pontos) e normalizada [0,1].",
                                "Constrói histogramas e scatters corretos com interpretações precisas.",
                                "Identifica corretamente uniformidade e independência em exemplos bons/ruins.",
                                "Usa métricas quantitativas além de visuais.",
                                "Evita erros comuns como amostras pequenas ou bins inadequados.",
                                "Conecta resultados a propriedades desejáveis de PRNGs."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses e distribuições uniformes.",
                                "Programação: Manipulação de arrays numpy e visualização matplotlib.",
                                "Engenharia Civil: Simulações Monte Carlo para análise de risco estrutural.",
                                "Matemática: Análise de sequências e propriedades congruenciais."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para dimensionamento de barragens ou análise sísmica de edifícios, sequências uniformes e independentes garantem estimativas precisas de probabilidades de falha, evitando vieses que poderiam subestimar riscos e levar a projetos inseguros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.2.3",
                            "name": "Compreender correlação serial",
                            "description": "Examinar a ausência de correlação entre elementos consecutivos ou próximos na sequência, crucial para a precisão em métodos de Monte Carlo aplicados a problemas de engenharia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito básico de correlação serial",
                                  "subSteps": [
                                    "Defina correlação serial como a dependência estatística entre elementos consecutivos ou próximos em uma sequência.",
                                    "Explique por que a ausência de correlação serial é essencial para sequências pseudo-aleatórias em simulações.",
                                    "Diferencie correlação serial de outras propriedades como uniformidade e independência.",
                                    "Relacione com métodos de Monte Carlo: sequências correlacionadas levam a estimativas enviesadas.",
                                    "Estude exemplos simples de sequências correlacionadas vs. não correlacionadas."
                                  ],
                                  "verification": "Resuma em suas palavras o que é correlação serial e sua importância em 3 frases.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro ou artigo sobre geração de números pseudo-aleatórios",
                                    "Notas de aula sobre Monte Carlo"
                                  ],
                                  "tips": "Use analogias como 'lançamentos de dados verdadeiramente aleatórios não se influenciam mutuamente'.",
                                  "learningObjective": "Compreender o conceito teórico de correlação serial e sua relevância em engenharia.",
                                  "commonMistakes": [
                                    "Confundir com autocorrelação em séries temporais",
                                    "Ignorar o impacto em simulações Monte Carlo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender métodos para medir correlação serial",
                                  "subSteps": [
                                    "Estude o coeficiente de correlação de Pearson para pares consecutivos: ρ_k = cov(X_i, X_{i+k}) / (σ^2).",
                                    "Calcule manualmente correlação serial de lag 1 em uma pequena sequência de 10 números.",
                                    "Implemente teste de autocorrelação usando lag plots ou função ACF (Autocorrelation Function).",
                                    "Interprete resultados: valores próximos de zero indicam ausência de correlação.",
                                    "Pratique com software: gere sequências e compute correlações para lags 1 a 5."
                                  ],
                                  "verification": "Gere uma sequência de 100 números e calcule ρ_1; confirme se |ρ_1| < 0.05.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com bibliotecas numpy e matplotlib",
                                    "Excel ou calculadora científica"
                                  ],
                                  "tips": "Sempre normalize a sequência para [0,1] antes de calcular correlação.",
                                  "learningObjective": "Dominar técnicas quantitativas para detectar correlação serial.",
                                  "commonMistakes": [
                                    "Usar amostras muito pequenas (menos de 100 pontos)",
                                    "Confundir lag 0 (sempre 1) com lags maiores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos práticos de sequências",
                                  "subSteps": [
                                    "Gere uma sequência ruim (ex: linear congruencial mal parametrizada) e detecte correlação alta.",
                                    "Compare com uma boa sequência (ex: Mersenne Twister) mostrando correlações próximas de zero.",
                                    "Crie lag plots: plote X_i vs X_{i+1} e verifique dispersão aleatória.",
                                    "Aplique teste estatístico: verifique se correlações estão dentro de bandas de confiança (±1.96/√N).",
                                    "Documente diferenças em um relatório curto com gráficos."
                                  ],
                                  "verification": "Produza gráficos de lag plot para duas sequências e interprete a ausência/presença de correlação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "Gerador de RNG online como random.org para comparação"
                                  ],
                                  "tips": "Use N=1000 para testes robustos; foque em lags baixos (1-10).",
                                  "learningObjective": "Identificar visual e quantitativamente correlação serial em sequências reais.",
                                  "commonMistakes": [
                                    "Ignorar normalização da sequência",
                                    "Interpretar padrões visuais como correlação sem teste estatístico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar no contexto de Monte Carlo em Engenharia Civil",
                                  "subSteps": [
                                    "Simule um problema: cargas aleatórias em uma viga; use sequência com correlação serial.",
                                    "Compare resultados de Monte Carlo com e sem correlação: observe viés na estimativa de probabilidade de falha.",
                                    "Otimize: substitua por gerador sem correlação e valide precisão.",
                                    "Discuta implicações: em análise estrutural, correlação leva a subestimação de riscos.",
                                    "Crie um checklist para validar propriedades em simulações futuras."
                                  ],
                                  "verification": "Execute simulação Monte Carlo e demonstre impacto da correlação serial nos resultados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python para Monte Carlo em viga simples",
                                    "Software como MATLAB ou Ansys (opcional)"
                                  ],
                                  "tips": "Comece com modelo 1D simples para isolar o efeito da correlação.",
                                  "learningObjective": "Integrar compreensão de correlação serial em aplicações práticas de engenharia.",
                                  "commonMistakes": [
                                    "Usar sementes fixas sem variar",
                                    "Não quantificar o erro introduzido pela correlação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para estimar a probabilidade de colapso de uma ponte sob cargas variáveis, gere 10.000 cargas pseudo-aleatórias. Calcule a correlação serial de lag 1: se ρ_1 > 0.1, a sequência é inadequada, levando a estimativas enviesadas de risco; corrija usando um bom RNG e valide com lag plots.",
                              "finalVerifications": [
                                "Explique correlação serial e calcule ρ_1 para uma sequência dada.",
                                "Gere lag plot e interprete ausência de padrão linear.",
                                "Simule Monte Carlo com sequência correlacionada e identifique viés.",
                                "Liste 3 testes para validar ausência de correlação serial.",
                                "Aplique em um problema de engenharia civil e justifique resultados.",
                                "Crie checklist para propriedades de sequências pseudo-aleatórias."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de coeficiente de correlação (erro < 5%).",
                                "Interpretação correta de gráficos e testes estatísticos.",
                                "Demonstração clara do impacto em simulações Monte Carlo.",
                                "Uso adequado de ferramentas computacionais e documentação.",
                                "Conexão explícita com aplicações em engenharia civil.",
                                "Identificação e correção de erros comuns em sequências."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: testes de autocorrelação e análise de séries temporais.",
                                "Programação: implementação de RNG e visualizações em Python/R.",
                                "Probabilidade: independência em processos estocásticos.",
                                "Engenharia Computacional: validação de simulações numéricas.",
                                "Análise de Dados: detecção de padrões em grandes datasets."
                              ],
                              "realWorldApplication": "Na análise de confiabilidade de estruturas civis, como barragens ou edifícios altos, métodos Monte Carlo usam sequências pseudo-aleatórias para modelar cargas sísmicas ou eólicas. A ausência de correlação serial garante estimativas precisas de probabilidade de falha, evitando subestimações de riscos que poderiam levar a projetos inseguros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.2.4",
                            "name": "Discutir portabilidade e eficiência",
                            "description": "Analisar como as propriedades devem ser mantidas em diferentes plataformas computacionais e a velocidade de geração para aplicações em tempo real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Portabilidade e Eficiência em PRNGs",
                                  "subSteps": [
                                    "Defina portabilidade como a capacidade de um PRNG manter propriedades estatísticas (uniformidade, independência, período) em diferentes arquiteturas de hardware e sistemas operacionais.",
                                    "Explique eficiência como a velocidade de geração de números pseudo-aleatórios, medida em números por segundo, considerando overhead computacional.",
                                    "Identifique propriedades desejáveis de PRNGs (ex.: teste de Diehard ou NIST) que devem ser preservadas.",
                                    "Discuta por que portabilidade é crítica em aplicações distribuídas e eficiência em simulações em tempo real.",
                                    "Revise literatura básica sobre PRNGs como Linear Congruential Generator (LCG) e Mersenne Twister."
                                  ],
                                  "verification": "Resuma os conceitos em um parágrafo coeso e liste 3 exemplos de falhas de portabilidade reportadas em literatura.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de testes NIST para PRNGs",
                                    "Artigos sobre Mersenne Twister e LCG",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Use diagramas para visualizar como seeds e parâmetros afetam portabilidade entre plataformas.",
                                  "learningObjective": "Diferenciar portabilidade de eficiência e listar propriedades chave preservadas.",
                                  "commonMistakes": [
                                    "Confundir portabilidade com precisão numérica",
                                    "Ignorar variações de hardware como caches em CPUs diferentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Testar Portabilidade de um PRNG em Diferentes Plataformas",
                                  "subSteps": [
                                    "Implemente um PRNG simples (ex.: LCG) em linguagens portáveis como Python ou C.",
                                    "Execute testes estatísticos (Kolmogorov-Smirnov para uniformidade) em pelo menos 3 plataformas: Windows, Linux e macOS.",
                                    "Compare sequências geradas com a mesma seed em todas as plataformas.",
                                    "Analise discrepâncias devidas a precisão de ponto flutuante ou ordem de bytes.",
                                    "Documente resultados em uma tabela comparativa."
                                  ],
                                  "verification": "Gere relatórios de testes mostrando p-valores > 0.01 em todos os testes para confirmar portabilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Máquinas virtuais para Windows/Linux/macOS",
                                    "Suite de testes NIST STS"
                                  ],
                                  "tips": "Use seeds fixas e normalize saídas para [0,1] para comparações justas.",
                                  "learningObjective": "Avaliar empiricamente a portabilidade de um PRNG através de testes cross-platform.",
                                  "commonMistakes": [
                                    "Não usar a mesma seed ou parâmetros",
                                    "Ignorar diferenças de compilador (ex.: GCC vs MSVC)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Medir e Analisar Eficiência de Geração de PRNGs",
                                  "subSteps": [
                                    "Implemente benchmarks para medir taxa de geração (ex.: 1 milhão de números) em diferentes PRNGs (LCG, PCG, Xorshift).",
                                    "Meça tempo de CPU e throughput em hardware variado (CPU vs GPU se possível).",
                                    "Identifique gargalos como operações modulares ou shifts bit a bit.",
                                    "Compare eficiência relativa e discuta trade-offs com qualidade estatística.",
                                    "Otimize um PRNG para maior velocidade mantendo propriedades."
                                  ],
                                  "verification": "Crie gráficos de throughput vs tamanho de batch e explique variações >10%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Bibliotecas como random em Python/C++",
                                    "Ferramentas de profiling (timeit, perf)",
                                    "Hardware com specs conhecidas"
                                  ],
                                  "tips": "Teste em loops otimizados e evite overhead de I/O nos benchmarks.",
                                  "learningObjective": "Quantificar eficiência e identificar fatores impactantes na velocidade de PRNGs.",
                                  "commonMistakes": [
                                    "Medir tempo total em vez de por número",
                                    "Não considerar cache warmup"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Implicações para Aplicações em Tempo Real na Engenharia Civil",
                                  "subSteps": [
                                    "Analise requisitos de tempo real em simulações Monte Carlo para análise de estruturas (ex.: vento em pontes).",
                                    "Avalie se PRNGs portáteis e eficientes atendem latências <1ms por iteração.",
                                    "Discuta trade-offs: PRNGs rápidos vs robustos em cenários distribuídos (ex.: cloud vs edge computing).",
                                    "Proponha estratégias como hardware accelerators ou PRNGs SIMD.",
                                    "Escreva um relatório integrando portabilidade, eficiência e contexto civil."
                                  ],
                                  "verification": "Defenda escolhas de PRNG para um caso de estudo com dados de benchmarks.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Casos de estudo Monte Carlo em engenharia civil",
                                    "Ferramentas de simulação como MATLAB ou OpenMC"
                                  ],
                                  "tips": "Relacione com normas como Eurocode para simulações probabilísticas.",
                                  "learningObjective": "Integrar portabilidade e eficiência em discussões aplicadas a problemas reais.",
                                  "commonMistakes": [
                                    "Generalizar resultados sem contexto específico",
                                    "Subestimar requisitos de tempo real"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para avaliar o risco de colapso de uma barragem sob cargas aleatórias de água, implemente o Mersenne Twister em Python (Linux) e C# (Windows). Teste portabilidade gerando 10^6 amostras com seed=12345, verificando uniformidade via KS-test (p>0.05 em ambas). Meça eficiência: MT gera 50M/s no Linux vs 45M/s no Windows, adequado para 10^5 iterações em <1s para análises em tempo real durante monitoramento.",
                              "finalVerifications": [
                                "Explicar portabilidade com exemplo de falha em LCG devido a overflow em 32-bit vs 64-bit.",
                                "Apresentar benchmarks mostrando throughput >10M números/segundo para eficiência.",
                                "Discutir 2 trade-offs entre velocidade e qualidade estatística.",
                                "Propor PRNG para simulação civil em tempo real com justificativa.",
                                "Listar 3 testes NIST aplicáveis para verificação cross-platform.",
                                "Relacionar com aplicação em Engenharia Civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Definições corretas de portabilidade e eficiência (30%)",
                                "Qualidade empírica: Testes cross-platform com resultados quantificados (25%)",
                                "Análise de eficiência: Benchmarks comparativos e otimizações (20%)",
                                "Relevância aplicada: Discussão contextualizada em tempo real (15%)",
                                "Clareza e estrutura: Relatório lógico com gráficos/tabelas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação e otimização de algoritmos em múltiplas linguagens.",
                                "Estatística: Testes de hipóteses para propriedades de PRNGs (KS, chi-quadrado).",
                                "Engenharia de Software: Portabilidade e padrões IEEE 754 para flutuantes.",
                                "Computação de Alto Desempenho: Paralelismo SIMD para PRNGs eficientes.",
                                "Engenharia Civil: Modelagem estocástica em análise de riscos estruturais."
                              ],
                              "realWorldApplication": "Na análise de riscos sísmicos para edifícios altos usando Monte Carlo, um PRNG portátil e eficiente permite simulações em tempo real durante inspeções de campo em tablets (Android/iOS) ou servidores cloud, garantindo consistência de resultados entre engenheiros em diferentes locais e velocidades para decisões rápidas em emergências."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.3",
                        "name": "Geradores Pseudo-Aleatórios Básicos",
                        "description": "Algoritmos simples e comuns para geração de números pseudo-aleatórios, com foco em sua implementação e limitações.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.3.1",
                            "name": "Implementar Gerador Linear Congruencial (LCG)",
                            "description": "Desenvolver código para o LCG usando a recursão X_{n+1} = (a * X_n + c) mod m, selecionando parâmetros ótimos como m=2^31, a=1664525, c=1013904223.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o LCG e Selecionar Parâmetros Ótimos",
                                  "subSteps": [
                                    "Estude a fórmula do LCG: X_{n+1} = (a * X_n + c) mod m",
                                    "Pesquise critérios para bons parâmetros (período completo, boa distribuição)",
                                    "Selecione m=2^31, a=1664525, c=1013904223 e uma seed inicial (ex: 42)",
                                    "Documente por que esses parâmetros são recomendados (baseado em literatura como Numerical Recipes)",
                                    "Calcule manualmente os primeiros 5 números para validar compreensão"
                                  ],
                                  "verification": "Caderno ou documento com fórmula anotada, parâmetros justificados e 5 primeiros números calculados corretamente",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação online sobre LCG (Wikipedia, Numerical Recipes)",
                                    "Calculadora ou papel para cálculos manuais",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Comece com cálculos manuais para internalizar a recursão antes de codificar",
                                  "learningObjective": "Compreender a matemática por trás do LCG e escolher parâmetros que maximizem o período e uniformidade",
                                  "commonMistakes": [
                                    "Escolher m não potência de 2 levando a período curto",
                                    "Ignorar overflow em cálculos manuais",
                                    "Usar seed=0 que pode causar período zero"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a Função LCG em Python",
                                  "subSteps": [
                                    "Crie uma classe LCG com atributos para m, a, c, seed e estado atual",
                                    "Implemente método __init__ para inicializar parâmetros",
                                    "Implemente método next() que aplica a fórmula e retorna X_n / m (normalizado para [0,1])",
                                    "Adicione método para resetar seed",
                                    "Teste unitário básico gerando 10 números e imprimindo"
                                  ],
                                  "verification": "Código roda sem erros e gera sequência idêntica aos cálculos manuais dos primeiros 5 números",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python 3 instalado",
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Biblioteca random para comparação opcional"
                                  ],
                                  "tips": "Use int() para evitar float em multiplicações grandes; normalize dividindo por m no final",
                                  "learningObjective": "Codificar corretamente a recursão modular evitando overflow e garantindo reproducibilidade",
                                  "commonMistakes": [
                                    "Não usar módulo m corretamente causando números negativos",
                                    "Overflow sem usar tipos grandes (use int em Python3)",
                                    "Esquecer de normalizar para [0,1]"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Sequência e Visualizar Distribuição",
                                  "subSteps": [
                                    "Gere uma sequência de 10000 números pseudo-aleatórios usando loop",
                                    "Calcule estatísticas básicas: média, variância (deve ser ~0.5 e ~1/12)",
                                    "Crie histograma com matplotlib para visualizar uniformidade",
                                    "Compare com random.uniform() para inspeção visual",
                                    "Salve sequência em lista ou arquivo CSV para análise posterior"
                                  ],
                                  "verification": "Histograma mostra distribuição uniforme; média ≈0.5, variância ≈0.0833",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Bibliotecas Python: numpy, matplotlib",
                                    "Jupyter Notebook para plots interativos"
                                  ],
                                  "tips": "Use np.histogram para precisão; gere amostras grandes para melhor visualização",
                                  "learningObjective": "Avaliar empiricamente a qualidade pseudo-aleatória via estatísticas e visualização",
                                  "commonMistakes": [
                                    "Amostra pequena distorcendo estatísticas",
                                    "Escala errada no histograma",
                                    "Confundir X_n com normalizado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Período e Integrar em Exemplo Simples",
                                  "subSteps": [
                                    "Implemente detecção de ciclo comparando estados até repetição",
                                    "Verifique se período é próximo de m para seed boa",
                                    "Use LCG em simulação Monte Carlo simples: estimar π com pontos aleatórios em quadrado",
                                    "Compare precisão com random() após 10000 trials",
                                    "Documente limitações do LCG (não passa testes avançados como Diehard)"
                                  ],
                                  "verification": "Código detecta ciclo corretamente; estimativa de π converge para ~3.14",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "numpy para simulação Monte Carlo"
                                  ],
                                  "tips": "Para período completo, certifique-se que c !=0, a-1 divisível por todos fatores primos de m",
                                  "learningObjective": "Detectar limitações do LCG e aplicá-lo em contexto prático de simulação",
                                  "commonMistakes": [
                                    "Assumir período sempre m (só para parâmetros hull-dobell)",
                                    "Erro em detecção de ciclo por comparação errada",
                                    "Trials insuficientes em Monte Carlo"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um LCG para gerar 5000 alturas de precipitação diária normalizadas [0,1], multiplique por 100mm para simular chuvas em análise hidrológica de barragem; use Monte Carlo para estimar probabilidade de overflow (acima de 80mm/dia).",
                              "finalVerifications": [
                                "Sequência de 10000 números gerada sem erros ou overflow",
                                "Estatísticas: média ~0.5, variância ~1/12",
                                "Histograma uniforme visualmente",
                                "Período detectado próximo de 2^31 para seed boa",
                                "Simulação Monte Carlo converge corretamente",
                                "Código reproduzível com mesma seed"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: fórmula implementada sem bugs modulares",
                                "Eficiência: O(1) por número, sem loops desnecessários",
                                "Qualidade pseudo-aleatória: passa testes básicos de uniformidade",
                                "Documentação: comentários explicando parâmetros e normalização",
                                "Aplicação: integração válida em exemplo Monte Carlo",
                                "Robustez: trata seeds inválidas e evita ciclos curtos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e teoria dos números",
                                "Estatística: Testes de uniformidade e simulações Monte Carlo",
                                "Engenharia Civil: Modelagem estocástica em hidrologia e análise de riscos estruturais",
                                "Programação: OOP, testes unitários e visualização de dados",
                                "Física: Processos aleatórios em dinâmica de fluidos"
                              ],
                              "realWorldApplication": "Em engenharia civil, LCGs são usados em simulações Monte Carlo para modelar cargas sísmicas aleatórias, precipitação variável em projetos hidráulicos ou tráfego estocástico em análise de pontes, permitindo previsões probabilísticas de falhas sem hardware caro de RNGs verdadeiros."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.3.2",
                            "name": "Escolher parâmetros para bom desempenho",
                            "description": "Selecionar multiplicador 'a', incremento 'c' e módulo 'm' baseados em critérios como período completo (c=0, m potência de 2, a-1 divisível por 4) para maximizar qualidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os critérios de qualidade para geradores LCG",
                                  "subSteps": [
                                    "Revise a fórmula do LCG: X_{n+1} = (a * X_n + c) mod m",
                                    "Estude o conceito de período completo: o gerador deve ciclar por todos os valores possíveis antes de repetir",
                                    "Identifique métricas de qualidade: período máximo, distribuição uniforme e ausência de correlações",
                                    "Analise condições para período completo: gcd(c, m)=1, m divide a-1 ou outras dependendo de c",
                                    "Pesquise impactos de más escolhas: padrões detectáveis e falhas em simulações"
                                  ],
                                  "verification": "Resuma em um parágrafo os 3 principais critérios para bom desempenho do LCG",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de Knuth sobre geradores aleatórios, notas de aula sobre LCG",
                                  "tips": "Use diagramas de ciclo para visualizar o período",
                                  "learningObjective": "Explicar os critérios fundamentais para avaliar a qualidade de parâmetros em LCG",
                                  "commonMistakes": "Confundir período completo com aleatoriedade verdadeira; ignorar dependências entre a, c e m"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o módulo m apropriado",
                                  "subSteps": [
                                    "Escolha m como potência de 2 (m=2^k) para simplificar operações e maximizar período",
                                    "Justifique: com c=0, período completo se m| (a-1) e outras condições",
                                    "Calcule exemplos: m=2^16=65536, m=2^32 para aplicações modernas",
                                    "Considere trade-offs: m maior melhora qualidade mas aumenta custo computacional",
                                    "Verifique compatibilidade com semente X_0 (0 < X_0 < m)"
                                  ],
                                  "verification": "Liste 3 valores de m potências de 2 e explique por que são preferíveis",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora ou Python para potências de 2, tabela de potências de 2",
                                  "tips": "Prefira m=2^31 ou 2^32 em linguagens de 32/64 bits para alinhamento nativo",
                                  "learningObjective": "Justificar e selecionar m otimizado para período completo em LCG",
                                  "commonMistakes": "Escolher m primo em vez de potência de 2, perdendo simplicidade bitwise"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escolher multiplicador a e incremento c para período completo",
                                  "subSteps": [
                                    "Para c=0 e m=2^k: selecione a tal que a-1 divisível por 4 (a ≡ 1 mod 4)",
                                    "Exemplos de a bons: a=5 (para m=8), a=16807 (para m=2^31-1, mas adapte para 2^k)",
                                    "Para período completo com c≠0: exija gcd(c,m)=1 e a≡1 mod p para cada primo p|m",
                                    "Teste condições: verifique se a-1 é divisível por 4 e preferencialmente por 8 para k>=3",
                                    "Selecione c=0 para máxima simplicidade ou c ímpar para m=2^k"
                                  ],
                                  "verification": "Proponha a=21 e c=0 para m=32 e verifique condições manualmente",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Folha de cálculos, referências como 'The Art of Computer Programming' Vol.2",
                                  "tips": "Use a = 4*t +1 onde t múltiplo de 4 para k>2",
                                  "learningObjective": "Aplicar regras matemáticas para escolher a e c que garantam período máximo",
                                  "commonMistakes": "Escolher a par ou não verificar divisibilidade por 4; usar c múltiplo de 2 com m=2^k"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar a escolha de parâmetros",
                                  "subSteps": [
                                    "Implemente o LCG em código com parâmetros escolhidos",
                                    "Simule o período: gere sequência até repetir semente inicial e conte ciclos",
                                    "Teste uniformidade: plote histograma de 10^5 números gerados",
                                    "Verifique correlações: teste plot de pontos (X_n, X_{n+1}) para adjacência",
                                    "Compare com parâmetros ruins para contrastar qualidade"
                                  ],
                                  "verification": "Gere relatório com comprimento do período e estatísticas de teste",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python ou MATLAB com bibliotecas numpy/matplotlib para simulação e plot",
                                  "tips": "Use semente X_0=1 e monitore por wrap-around",
                                  "learningObjective": "Implementar e validar empiricamente os parâmetros para confirmar bom desempenho",
                                  "commonMistakes": "Não testar período completo; ignorar overflow em implementações de 32 bits"
                                }
                              ],
                              "practicalExample": "Para simulação Monte Carlo em análise de pavimentos (Engenharia Civil), escolha m=2^32, a=1664525 (a-1=1664524 divisível por 4), c=1013904223 (ímpar, gcd=1). Implemente para gerar cargas aleatórias em lajes e verifique período próximo a 2^32.",
                              "finalVerifications": [
                                "Período da sequência atinge pelo menos 90% de m",
                                "Histograma mostra distribuição uniforme (teste chi-quadrado p>0.05)",
                                "Scatter plot (X_n vs X_{n+1}) sem padrões lineares visíveis",
                                "Teste de poker ou runs confirma aleatoriedade",
                                "Geração de 10^6 números sem repetições prematuras",
                                "Compatibilidade com aplicações de Monte Carlo sem bias"
                              ],
                              "assessmentCriteria": [
                                "Correta aplicação de regras para m (potência de 2)",
                                "Seleção de a com a-1 divisível por 4 e justificativa",
                                "Escolha adequada de c (0 ou coprimo com m)",
                                "Validação empírica via simulação com métricas quantitativas",
                                "Identificação de trade-offs computacionais",
                                "Explicação clara de critérios em contexto de Engenharia Civil"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números (congruências, gcd)",
                                "Programação: Implementação eficiente com operações modulares",
                                "Estatística: Testes de hipóteses para uniformidade",
                                "Engenharia Civil: Aplicações em simulações estocásticas de cargas",
                                "Computação: Otimização bitwise para performance"
                              ],
                              "realWorldApplication": "Em Engenharia Civil, parâmetros otimizados em LCG são usados no Método de Monte Carlo para simular variabilidade em propriedades de materiais (ex: resistência do concreto), previsão de falhas em estruturas sob ventos aleatórios ou análise de tráfego em pavimentos, garantindo simulações confiáveis sem padrões artificiais que distorcem resultados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.3.3",
                            "name": "Normalizar para intervalo [0,1]",
                            "description": "Converter a saída inteira do gerador em fração uniforme dividindo por m, aplicável em simulações de Monte Carlo para engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Saída do Gerador Pseudo-Aleatório",
                                  "subSteps": [
                                    "Revise o funcionamento de um gerador linear congruente (LCG), que produz inteiros X_i no intervalo [0, m-1].",
                                    "Identifique m como o módulo do gerador, tipicamente uma potência de 2 ou primo grande.",
                                    "Explique por que os inteiros precisam ser normalizados para uso em simulações probabilísticas.",
                                    "Calcule manualmente exemplos simples de X_i para um LCG básico.",
                                    "Discuta a importância da uniformidade discreta aproximando a contínua."
                                  ],
                                  "verification": "Resuma em uma frase o intervalo de saída e o propósito da normalização.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta; documentação de LCG (ex: Wikipedia).",
                                  "tips": "Use um LCG simples com a=1, c=1, m=10 para testes iniciais.",
                                  "learningObjective": "Entender a natureza discreta e limitada da saída inteira do gerador.",
                                  "commonMistakes": "Confundir m com o seed inicial; assumir saída já em [0,1]."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Fórmula de Normalização",
                                  "subSteps": [
                                    "Memorize a fórmula U = X / m, onde U ∈ [0,1) e X ∈ [0, m-1].",
                                    "Demonstre com cálculos manuais: para m=100, X=0 → U=0; X=99 → U=0.99.",
                                    "Analise o impacto de m grande na precisão da aproximação uniforme.",
                                    "Compare com normalização para outros intervalos (ex: [a,b]).",
                                    "Verifique propriedades: média ≈0.5, variância ≈1/12."
                                  ],
                                  "verification": "Calcule U para 5 valores de X e confirme todos em [0,1).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora; planilha Excel para cálculos em lote.",
                                  "tips": "Sempre use divisão real (float), não inteira.",
                                  "learningObjective": "Dominar a transformação matemática para distribuição uniforme contínua.",
                                  "commonMistakes": "Dividir por (m-1) em vez de m; arredondar prematuramente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Normalização em Código",
                                  "subSteps": [
                                    "Escreva uma função em Python que gere X via LCG e normalize para U.",
                                    "Inclua parâmetros para seed, a, c, m; gere sequência de 1000 U's.",
                                    "Plote histograma para visualizar uniformidade usando matplotlib.",
                                    "Adicione tratamento de overflow para m grande (use int64).",
                                    "Teste com diferentes m e observe convergência."
                                  ],
                                  "verification": "Execute código e confirme histograma uniforme em [0,1].",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python 3 com numpy/matplotlib; Jupyter Notebook.",
                                  "tips": "Defina m=2**31-1 para realismo; use random.seed() para reprodutibilidade.",
                                  "learningObjective": "Implementar algoritmo programaticamente para automação.",
                                  "commonMistakes": "Erro de tipo (int vs float); loop infinito por overflow."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Aplicar em Simulação Monte Carlo",
                                  "subSteps": [
                                    "Gere U's normalizados e use em estimativa de π via método de Monte Carlo.",
                                    "Compare precisão com diferentes tamanhos de amostra (10^3 vs 10^6).",
                                    "Calcule estatísticas: média, variância e teste de Kolmogorov-Smirnov.",
                                    "Aplique em contexto civil: simule carga aleatória em vigas.",
                                    "Documente código com comentários sobre normalização."
                                  ],
                                  "verification": "Erro na estimativa de π <5% com 10^5 amostras.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Código Python do step 3; referências Monte Carlo em engenharia.",
                                  "tips": "Aumente m para melhor uniformidade em amostras grandes.",
                                  "learningObjective": "Integrar normalização em simulações práticas de engenharia civil.",
                                  "commonMistakes": "Ignorar correlações em sequências LCG curtas; não validar uniformidade."
                                }
                              ],
                              "practicalExample": "Em um LCG com m=100, seed=1, a=5, c=3: X1=(5*1+3)%100=8 → U1=8/100=0.08. Gere 10 U's e plote histograma para verificar uniformidade aproximada.",
                              "finalVerifications": [
                                "Todos U gerados estão em [0,1).",
                                "Média da amostra ≈0.5 (±0.01 para n=1000).",
                                "Histograma mostra distribuição uniforme visualmente.",
                                "Código roda sem erros para m=10^9.",
                                "Aplicação Monte Carlo converge corretamente.",
                                "Explicação oral da fórmula e limitações."
                              ],
                              "assessmentCriteria": [
                                "Precisão da fórmula: 100% correta.",
                                "Implementação funcional e eficiente.",
                                "Validação estatística com métricas quantitativas.",
                                "Integração em contexto de engenharia civil.",
                                "Clareza de documentação e comentários.",
                                "Identificação de pelo menos 2 limitações (ex: granularidade 1/m)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuições uniformes e testes de aderência.",
                                "Programação: Algoritmos numéricos e visualização de dados.",
                                "Matemática: Aritmética modular e análise numérica.",
                                "Engenharia Civil: Simulações estocásticas para análise de riscos."
                              ],
                              "realWorldApplication": "Em engenharia civil, normalizar números pseudo-aleatórios permite simulações Monte Carlo para estimar falhas em estruturas sob cargas variáveis (ex: vento aleatório em pontes), otimizando projetos de segurança com base em probabilidades realistas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Gerador Congruencial Linear",
                    "description": "Algoritmo básico para geração de números pseudo-aleatórios baseado em recorrência linear modular.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Recorrência Linear Modular",
                        "description": "Fórmula fundamental do Gerador Congruencial Linear (GCL): X_{n+1} = (a * X_n + c) mod m, onde a é o multiplicador, c o incremento, m o módulo e X_0 a semente inicial, gerando uma sequência pseudo-aleatória determinística.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Identificar componentes da fórmula do GCL",
                            "description": "Explicar o papel de cada parâmetro (X_0, a, c, m) na recorrência linear modular e como eles influenciam a geração da sequência pseudo-aleatória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a fórmula básica da recorrência linear modular do GCL",
                                  "subSteps": [
                                    "Escreva a fórmula padrão: X_{n+1} = (a * X_n + c) mod m",
                                    "Identifique os quatro componentes principais: X_0, a, c e m",
                                    "Explique que é uma recorrência porque cada termo depende do anterior",
                                    "Discuta que 'mod m' garante que os valores fiquem entre 0 e m-1",
                                    "Anote a importância de ser pseudo-aleatória, não verdadeiramente aleatória"
                                  ],
                                  "verification": "Recite a fórmula corretamente e aponte cada componente em um papel",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, calculadora básica",
                                  "tips": "Visualize a fórmula como uma 'caixa preta' que transforma X_n em X_{n+1}",
                                  "learningObjective": "Memorizar e compreender a estrutura matemática do GCL",
                                  "commonMistakes": "Confundir 'mod' com divisão simples; esquecer que é inteiro"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o papel do parâmetro X_0 (semente inicial)",
                                  "subSteps": [
                                    "Defina X_0 como o valor inicial da sequência (0 ≤ X_0 < m)",
                                    "Descreva que determina o ponto de partida da sequência pseudo-aleatória",
                                    "Teste com X_0 = 0 vs X_0 = 1 para ver sequências diferentes",
                                    "Note que sequências com mesma semente são idênticas (reprodutibilidade)",
                                    "Discuta escolha: evite X_0 = 0 se c=0 para não gerar zeros constantes"
                                  ],
                                  "verification": "Gere duas sequências curtas com sementes diferentes e compare",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou planilha Excel",
                                  "tips": "Pense na semente como a 'chave' que inicia o gerador",
                                  "learningObjective": "Compreender como X_0 inicia e afeta a reprodutibilidade",
                                  "commonMistakes": "Achar que X_0 afeta a 'qualidade' aleatória (só o início)"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar os parâmetros a (multiplicador), c (incremento) e m (módulo)",
                                  "subSteps": [
                                    "Explique a: multiplica X_n para 'esticar' o valor (escolha ímpar, bom período)",
                                    "Descreva c: adiciona um offset para evitar padrões (c=0 é multiplicativo)",
                                    "Defina m: módulo primo ou 2^k para bom período e distribuição uniforme",
                                    "Compare GCL com c=0 vs c>0: c melhora aleatoriedade",
                                    "Liste critérios de Hull-Dobell para período máximo: gcd(c,m)=1, etc."
                                  ],
                                  "verification": "Escreva definições e exemplos numéricos para cada um",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, caneta, tabela de exemplos pré-calculados",
                                  "tips": "Use m=potência de 2 para testes simples em computadores",
                                  "learningObjective": "Identificar funções e critérios de escolha de a, c, m",
                                  "commonMistakes": "Escolher a par (leva a período curto); ignorar gcd"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar influência coletiva na geração da sequência pseudo-aleatória",
                                  "subSteps": [
                                    "Gere uma sequência completa com parâmetros exemplo: X_0=1, a=5, c=3, m=16",
                                    "Observe ciclo/período: calcule até repetir X_0",
                                    "Analise distribuição: conte frequência de cada valor",
                                    "Discuta trade-offs: período longo vs computação rápida",
                                    "Compare com sequência ruim (a=1, c=0: constante)"
                                  ],
                                  "verification": "Gere e plote 10 termos; identifique ciclo e uniformidade",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha ou Python simples para gerar sequência",
                                  "tips": "Comece com m pequeno (16) para visualizar manualmente",
                                  "learningObjective": "Entender interações e impactos na qualidade pseudo-aleatória",
                                  "commonMistakes": "Subestimar período; achar que bom período = aleatório perfeito"
                                }
                              ],
                              "practicalExample": "Usando X_0=7, a=5, c=3, m=16: Sequência: 7 → 40 mod16=8 → 43 mod16=11 → 58 mod16=10 → ... Ciclo de período 16, distribuição uniforme.",
                              "finalVerifications": [
                                "Recitar fórmula e nomear todos parâmetros corretamente",
                                "Explicar papel de X_0 com exemplo de reprodutibilidade",
                                "Descrever como escolher a, c, m para bom período",
                                "Gerar sequência manual de 5 termos e analisar",
                                "Identificar erro em parâmetros ruins (ex: a=0 leva a constantes)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula e identificação de componentes (100%)",
                                "Explicação clara do papel de cada parâmetro (detalhes influências)",
                                "Demonstração prática com exemplo numérico correto",
                                "Compreensão de critérios para qualidade (período, uniformidade)",
                                "Aplicação a cenários reais de Monte Carlo",
                                "Ausência de erros comuns como confusão mod/divisão"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números (módulos, gcd)",
                                "Programação: Implementação em loops (Python/C++)",
                                "Probabilidade: Testes de aleatoriedade (χ², poker)",
                                "Estatística: Simulações Monte Carlo em riscos"
                              ],
                              "realWorldApplication": "Em Engenharia Civil, GCL gera números pseudo-aleatórios para simulações Monte Carlo, como análise de falhas em estruturas sob cargas variáveis ou modelagem de tráfego em pontes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Calcular iterações manuais do GCL",
                            "description": "Realizar cálculos passo a passo de 5-10 iterações usando valores específicos de parâmetros para entender o comportamento da sequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e anotar os parâmetros do GCL",
                                  "subSteps": [
                                    "Escolha valores específicos para a semente X₀ (entre 0 e m-1), multiplicador a (tipicamente ímpar, 1 < a < m), incremento c (0 ≤ c < m) e módulo m (potência de 2 ou primo).",
                                    "Verifique se os parâmetros atendem critérios de qualidade básica (ex: m > 0, a > 0, c ≥ 0).",
                                    "Anote todos os valores em uma tabela ou papel para referência rápida.",
                                    "Calcule e anote o primeiro número pseudoaleatório U₀ = X₀ / m.",
                                    "Registre a fórmula geral: X_{n+1} = (a * X_n + c) mod m."
                                  ],
                                  "verification": "Confirme que todos os parâmetros estão anotados corretamente e U₀ calculado sem erros aritméticos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, caneta, calculadora simples ou planilha.",
                                  "tips": "Use m = 16 (potência de 2) para facilitar cálculos manuais iniciais.",
                                  "learningObjective": "Compreender a configuração inicial do GCL e preparar para iterações.",
                                  "commonMistakes": "Escolher valores que violem restrições (ex: a ≥ m) ou esquecer de normalizar U₀."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as primeiras 5 iterações manualmente",
                                  "subSteps": [
                                    "Para n=0: Calcule X₁ = (a * X₀ + c) mod m e U₁ = X₁ / m.",
                                    "Para n=1: Calcule X₂ = (a * X₁ + c) mod m e U₂ = X₂ / m.",
                                    "Continue até X₅ e U₅, registrando cada X_n e U_n em uma tabela.",
                                    "Realize todas as multiplicações e somas antes do mod m para evitar erros de ordem.",
                                    "Verifique cada passo recalculando o anterior."
                                  ],
                                  "verification": "Tabela completa com X₁ a X₅ e U₁ a U₅ sem discrepâncias em recálculos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel com tabela pré-formatada, calculadora.",
                                  "tips": "Faça a operação modular passo a passo: multiplique, some, divida por m e pegue resto.",
                                  "learningObjective": "Dominar o cálculo iterativo básico do GCL.",
                                  "commonMistakes": "Esquecer o mod m após soma, levando a valores fora de [0, m-1]; arredondar U_n prematuramente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender para 5-10 iterações adicionais e observar padrões",
                                  "subSteps": [
                                    "Continue de X₅ para X₆ até X₁₀ (ou mais), calculando U_n correspondentes.",
                                    "Registre todos em uma linha temporal ou gráfico simples de U_n vs n.",
                                    "Identifique possíveis repetições ou ciclos na sequência X_n.",
                                    "Calcule estatísticas básicas: média dos U_n e frequência de valores.",
                                    "Compare com expectativas de uniformidade."
                                  ],
                                  "verification": "Sequência completa de 10 iterações em tabela, com pelo menos um padrão anotado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, régua para gráfico, calculadora.",
                                  "tips": "Procure ciclos curtos com parâmetros ruins para entender limitações.",
                                  "learningObjective": "Executar múltiplas iterações e iniciar análise comportamental.",
                                  "commonMistakes": "Perder o rastreamento da iteração atual; ignorar overflow em multiplicações manuais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o comportamento da sequência gerada",
                                  "subSteps": [
                                    "Plote os U_n em um gráfico linear para visualizar distribuição.",
                                    "Calcule o período detectado (distância até repetição de X_n).",
                                    "Avalie uniformidade qualitativa (U_n espalhados em [0,1]?).",
                                    "Discuta limitações observadas (ex: ciclo curto se c=0).",
                                    "Compare com propriedades teóricas do GCL."
                                  ],
                                  "verification": "Relatório curto com gráfico, período e análise de uniformidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel milimetrado, lápis de cor para gráfico.",
                                  "tips": "Use intervalos de 0.1 para bins e conte frequências manualmente.",
                                  "learningObjective": "Interpretar resultados para entender dinâmica do GCL.",
                                  "commonMistakes": "Atribuir aleatoriedade perfeita sem análise; confundir período com ciclo completo."
                                }
                              ],
                              "practicalExample": "Use X₀=3, a=5, c=7, m=16. Cálculos: X₁=(5*3+7) mod 16=28 mod 16=12, U₁=12/16=0.75; X₂=(5*12+7) mod 16=67 mod 16=3 (ciclo detectado em 2 passos). Continue para 10 iterações: observe ciclo curto [3,12,3,12,...].",
                              "finalVerifications": [
                                "Sequência de 10 X_n e U_n calculada corretamente sem erros aritméticos.",
                                "Tabela ou lista organizada com todos os valores.",
                                "Pelo menos um padrão ou ciclo identificado na sequência.",
                                "Gráfico de U_n vs n plotado e comentado.",
                                "Estatísticas básicas (média, período) computadas.",
                                "Discussão breve sobre qualidade da sequência."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos modulares (100% correto).",
                                "Completude da sequência (mínimo 10 iterações).",
                                "Qualidade da análise de padrões e uniformidade.",
                                "Clareza na tabela e visualizações.",
                                "Identificação correta de erros comuns ou limitações.",
                                "Profundidade na interpretação do comportamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e teoria dos números.",
                                "Programação: Implementação de loops para automação do GCL.",
                                "Estatística: Análise de uniformidade e testes de aleatoriedade.",
                                "Engenharia de Computação: Geradores de números pseudoaleatórios em simulações."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para análise de risco em estruturas civis, como previsão de falhas em barragens sob cargas aleatórias, onde GCL gera sequências para modelar variáveis incertas como ventos ou tráfego."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Implementar o GCL em pseudocódigo",
                            "description": "Escrever pseudocódigo para gerar uma sequência de N números pseudo-aleatórios usando a recorrência linear modular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a fórmula do Gerador Congruencial Linear (GCL)",
                                  "subSteps": [
                                    "Estude a recorrência linear modular: X_{n+1} = (a * X_n + c) mod m",
                                    "Identifique os parâmetros: semente X0, multiplicador a, incremento c, módulo m",
                                    "Verifique condições para bom GCL: m > 0, a e c inteiros entre 0 e m-1",
                                    "Pesquise propriedades como período máximo (ex: gcd(c, m)=1 para período cheio)",
                                    "Anote exemplos de parâmetros ruins vs. bons (ex: m=10, a=1, c=0 é ruim)"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula e parâmetros com um exemplo simples",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência online sobre GCL (Wikipedia ou livro de numerais métodos)"
                                  ],
                                  "tips": "Use notação matemática clara; memorize Hull-Dobell para período máximo",
                                  "learningObjective": "Compreender os componentes matemáticos do GCL e suas restrições",
                                  "commonMistakes": [
                                    "Confundir parâmetros (ex: trocar a e c)",
                                    "Ignorar que mod m garante valores em [0, m-1]",
                                    "Não verificar se m é potência de primo para bom período"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar variáveis e estrutura do pseudocódigo",
                                  "subSteps": [
                                    "Defina entrada: N (quantidade de números), X0 (semente), a, c, m",
                                    "Crie array ou lista resultado[] de tamanho N",
                                    "Inicialize resultado[0] = X0",
                                    "Defina variáveis auxiliares: X = X0",
                                    "Escreva cabeçalho do pseudocódigo: função GCL(N, X0, a, c, m)"
                                  ],
                                  "verification": "Pseudocódigo inicial compila conceitualmente sem erros de sintaxe básica",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto simples (Notepad++ ou similar)",
                                    "Papel para rascunho"
                                  ],
                                  "tips": "Use indentação consistente para clareza; nomeie variáveis descritivamente",
                                  "learningObjective": "Configurar corretamente as entradas e inicializações do algoritmo",
                                  "commonMistakes": [
                                    "Esquecer de armazenar X0 no array",
                                    "Não declarar tipos se pseudocódigo exigir",
                                    "Usar N como índice em vez de contador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop de geração da sequência",
                                  "subSteps": [
                                    "Inicie loop FOR i de 1 a N-1",
                                    "Calcule X_next = (a * X + c) % m",
                                    "Armazene resultado[i] = X_next",
                                    "Atualize X = X_next",
                                    "Feche o loop e adicione saída: retornar resultado[]"
                                  ],
                                  "verification": "Execute manualmente para N=3 e verifique se sequência está correta",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para verificação manual",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use operador % para módulo; priorize overflow avoidance em pseudocódigo com nota",
                                  "learningObjective": "Codificar o coração iterativo do GCL de forma precisa",
                                  "commonMistakes": [
                                    "Erro no índice do loop (começar de 0 em vez de 1)",
                                    "Fazer mod antes de multiplicar (perde precisão)",
                                    "Não atualizar X corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar comentários, tratamento de erros e teste",
                                  "subSteps": [
                                    "Adicione comentários explicando cada linha chave",
                                    "Inclua verificações: se m <=0 ou N<=0, retorne erro",
                                    "Teste com exemplo: N=5, X0=1, a=5, c=3, m=16 → sequência esperada",
                                    "Simule execução passo a passo",
                                    "Refatore para legibilidade (ex: constantes para parâmetros)"
                                  ],
                                  "verification": "Pseudocódigo completo gera sequência correta no exemplo de teste",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha Excel para simulação numérica",
                                    "Editor de texto"
                                  ],
                                  "tips": "Comente por que cada parâmetro afeta o período; use ASSERT para testes",
                                  "learningObjective": "Finalizar pseudocódigo robusto e documentado",
                                  "commonMistakes": [
                                    "Loop infinito por erro em condição",
                                    "Ignorar casos edge como N=1",
                                    "Comentários vagos ou ausentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente GCL com N=5, X0=1, a=5, c=3, m=16. Sequência esperada: 1, 8, 11, 2, 13. Pseudocódigo: resultado = [1]; X=1; for i=1 to 4: X=(5*X+3)%16; append X to resultado.",
                              "finalVerifications": [
                                "Sequência gerada manualmente pelo pseudocódigo coincide com cálculo matemático",
                                "Pseudocódigo lida com N=1 (retorna apenas X0)",
                                "Comentários cobrem fórmula, parâmetros e iterações",
                                "Tratamento de erros para parâmetros inválidos (m<=0)",
                                "Período detectado corretamente em exemplo com ciclo curto",
                                "Legibilidade alta: indentação e nomes claros"
                              ],
                              "assessmentCriteria": [
                                "Corretude matemática: fórmula implementada sem erros aritméticos",
                                "Estrutura lógica: loop e inicialização fluem corretamente",
                                "Completude: todos parâmetros usados e saída em array",
                                "Clareza e documentação: comentários explicativos em cada step",
                                "Robustez: verificações de input e casos edge",
                                "Eficiência: O(N) tempo sem loops desnecessários"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: GCL usado em simulações Monte Carlo para análise de falhas estruturais",
                                "Matemática Discreta: Teoria dos números (módulos, gcd) e sequências recursivas",
                                "Engenharia Civil: Aplicações em modelagem de cargas aleatórias em pontes",
                                "Programação: Pseudocódigo como ponte para implementação em Python/C++",
                                "Física: Simulações de processos estocásticos em dinâmica de fluidos civis"
                              ],
                              "realWorldApplication": "Em Engenharia Civil, GCL alimenta simulações Monte Carlo para estimar riscos em projetos de barragens ou edifícios, gerando cargas de vento/terremoto pseudo-aleatórias para testes probabilísticos de estabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Seleção de Parâmetros do GCL",
                        "description": "Escolha adequada dos parâmetros a, c, m e X_0 para maximizar a qualidade pseudo-aleatória, considerando critérios como período máximo e distribuição uniforme.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Aplicar critérios para escolha de m",
                            "description": "Selecionar o módulo m como potência de 2 ou número primo grande para otimizar o período e evitar correlações na sequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os critérios teóricos para escolha de m",
                                  "subSteps": [
                                    "Estude a fórmula do GCL: X_{n+1} = (a * X_n + c) mod m.",
                                    "Analise como m afeta o período máximo (idealmente m para c=0).",
                                    "Revise propriedades: m potência de 2 otimiza para a=4k+1; primo grande para flexibilidade.",
                                    "Identifique problemas de correlações se m mal escolhido (ex: fatores comuns com a).",
                                    "Consulte literatura sobre períodos full e hull-dobell."
                                  ],
                                  "verification": "Resuma em bullet points os 3 principais critérios para m e explique por que primos ou 2^k são preferidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro ou PDF sobre GCL (ex: Knuth 'The Art of Computer Programming'),",
                                    "Notas de aula do módulo DI-37",
                                    "Calculadora para testes simples"
                                  ],
                                  "tips": "Foquem em exemplos numéricos pequenos primeiro para visualizar o impacto no período.",
                                  "learningObjective": "Entender matematicamente por que m deve ser potência de 2 ou primo grande para maximizar período e minimizar correlações.",
                                  "commonMistakes": "Confundir período com tamanho de ciclo sem considerar condições de maximalidade; ignorar que m pequeno causa repetições rápidas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar candidatos para m",
                                  "subSteps": [
                                    "Defina o tamanho desejado do período (ex: 10^6 a 10^9 para simulações civis).",
                                    "Liste potências de 2 próximas: 2^20=1M, 2^30≈1B.",
                                    "Gere primos grandes usando tabela ou sieve de Eratóstenes até o limite.",
                                    "Compare trade-offs: 2^k mais rápido em hardware binário, primos evitam vieses aritméticos.",
                                    "Selecione 3-5 candidatos baseados no contexto da simulação."
                                  ],
                                  "verification": "Crie uma tabela com 5 candidatos, indicando se primo/2^k, tamanho e vantagens/desvantagens.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de primos online ou software como Python com sympy.isprime()",
                                    "Planilha Excel para listar",
                                    "Documentação de requisitos da simulação Monte Carlo"
                                  ],
                                  "tips": "Use log2 para calcular potências de 2 rapidamente; priorize m próximo a limites de precisão float.",
                                  "learningObjective": "Saber gerar e listar opções viáveis de m adaptadas ao escopo computacional.",
                                  "commonMistakes": "Escolher primos muito grandes causando overflow; não considerar compatibilidade com linguagem de programação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar impacto no período e correlações",
                                  "subSteps": [
                                    "Para cada candidato m, teste período com a e c fixos (use fórmula de período).",
                                    "Simule sequências curtas e plote autocoerelações (ex: lag-1).",
                                    "Verifique condições de Hull-Dobell para período full.",
                                    "Compare estatísticas: uniformidade via teste chi-quadrado simples.",
                                    "Identifique correlações indesejadas (ex: bits baixos não randômicos em 2^k)."
                                  ],
                                  "verification": "Gere gráficos ou tabela mostrando período alcançado e score de aleatoriedade para cada m.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python/MATLAB com numpy/matplotlib para simulação e plot",
                                    "Gerador de sequências GCL script"
                                  ],
                                  "tips": "Comece com sementes variadas; use spectral test para correlações visuais.",
                                  "learningObjective": "Quantificar como escolha de m otimiza qualidade pseudo-aleatória.",
                                  "commonMistakes": "Testar apenas uma semente; ignorar que bom período não garante baixa correlação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e justificar m final",
                                  "subSteps": [
                                    "Escolha m ótimo baseado em avaliações (ex: primo se hardware não binário).",
                                    "Justifique com evidências: período, correlações baixas, custo computacional.",
                                    "Documente decisão em relatório curto.",
                                    "Teste integrado no GCL completo com Monte Carlo simples.",
                                    "Planeje sensibilidade: como m afeta precisão da simulação civil."
                                  ],
                                  "verification": "Escreva parágrafo de justificativa + resultados de testes finais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Script GCL completo",
                                    "Relatório template"
                                  ],
                                  "tips": "Priorize m que equilibre qualidade e performance para aplicações civis reais.",
                                  "learningObjective": "Aplicar critérios para decisão final informada e documentada.",
                                  "commonMistakes": "Não justificar escolha; selecionar por conveniência sem testes."
                                }
                              ],
                              "practicalExample": "Em simulação Monte Carlo para análise de estabilidade de barragem, com período >10^7 necessário, teste m=2^24 vs m=1000000007 (primo). Simule 10^5 cargas aleatórias; m=primo mostra menor viés em distribuições de tensão.",
                              "finalVerifications": [
                                "m é potência de 2 ou primo grande verificado (ex: sympy).",
                                "Período simulado atinge pelo menos 90% de m.",
                                "Autocorrelação lag-1 <0.01 em 1000 amostras.",
                                "Sem padrões visíveis em plot de sequência.",
                                "Teste chi-quadrado passa para uniformidade (p>0.05)."
                              ],
                              "assessmentCriteria": [
                                "Correta identificação de critérios teóricos (80% precisão).",
                                "Candidatos listados adequados ao escopo (pelo menos 3 viáveis).",
                                "Análise quantitativa com evidências (gráficos/tabelas).",
                                "Justificativa lógica e completa.",
                                "Integração correta no GCL com testes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primalidade, teorema de Hull-Dobell).",
                                "Ciência da Computação: Algoritmos Numéricos e Análise de Performance.",
                                "Estatística: Testes de Aleatoriedade e Análise de Monte Carlo.",
                                "Engenharia Civil: Modelagem Estocástica de Cargas e Riscos."
                              ],
                              "realWorldApplication": "Na engenharia civil, selecionar m ótimo em GCL para simulações Monte Carlo de vento/temblores em pontes garante previsões confiáveis de falhas, evitando subestimação de riscos devido a padrões pseudo-aleatórios detectáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Verificar condições de Hull-Dobell",
                            "description": "Aplicar o teorema de Hull-Dobell para determinar se os parâmetros a e c garantem o período máximo m no GCL.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar e enunciar as condições do Teorema de Hull-Dobell",
                                  "subSteps": [
                                    "Estude o teorema: Para o GCL ter período máximo m, deve satisfazer: 1) gcd(c, m) = 1; 2) Todo primo p|m divide (a-1); 3) Se 4|m, então 4|(a-1).",
                                    "Escreva as condições em uma tabela ou lista numerada para referência visual.",
                                    "Identifique o tipo de m (potência de 2, primo, etc.) para contextualizar as condições.",
                                    "Confirme o entendimento com um exemplo simples: m=5 (primo), a=3, c=1."
                                  ],
                                  "verification": "Lista das 3 condições corretamente enunciadas e compreendidas sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de papel ou editor de texto; referência ao teorema (livro ou PDF de soluções computacionais).",
                                  "tips": "Use mnemônicos: 'C coprimo com M, A menos um divide primos de M, e 4 se aplicável'.",
                                  "learningObjective": "Compreender precisamente as condições necessárias para período máximo no GCL.",
                                  "commonMistakes": "Confundir condições para diferentes tipos de m ou inverter 'a-1' com 'a+1'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Fatorar m e identificar primos e divisores relevantes",
                                  "subSteps": [
                                    "Calcule a fatoração prima completa de m usando divisão sucessiva por primos.",
                                    "Liste todos os primos distintos p que dividem m.",
                                    "Verifique se 4 divide m (i.e., m % 4 == 0).",
                                    "Registre em tabela: m, fatores primos, 4|m? (sim/não).",
                                    "Teste com m dado no problema."
                                  ],
                                  "verification": "Fatoração correta de m confirmada por multiplicação dos fatores iguais a m.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora ou software como Python (sympy.factorint); papel para cálculos manuais.",
                                  "tips": "Comece testando divisibilidade por 2,3,5,... até sqrt(m).",
                                  "learningObjective": "Dominar fatoração prima para análise modular em GCL.",
                                  "commonMistakes": "Esquecer fatores repetidos ou parar antes de primos maiores que sqrt(m)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a condição gcd(c, m) = 1",
                                  "subSteps": [
                                    "Calcule gcd(c, m) usando algoritmo de Euclides.",
                                    "Execute: enquanto m != 0, troque c e m, m = c % m.",
                                    "Confirme se resultado é 1 (coprimo).",
                                    "Se não, anote falha imediata.",
                                    "Documente passos do cálculo."
                                  ],
                                  "verification": "gcd computado corretamente e igual a 1, ou falha registrada.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora; função gcd em Python ou Excel.",
                                  "tips": "Se m é potência de primo, cheque se c não é múltiplo desse primo.",
                                  "learningObjective": "Aplicar algoritmo de Euclides para coprimidade em parâmetros GCL.",
                                  "commonMistakes": "Parar Euclides cedo ou confundir com lcm."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar divisibilidade de (a-1) pelos primos de m e por 4 se aplicável",
                                  "subSteps": [
                                    "Compute k = a - 1.",
                                    "Para cada primo p de m, cheque se k % p == 0.",
                                    "Se 4|m, cheque se k % 4 == 0.",
                                    "Marque cada cheque como PASS/FAIL em tabela.",
                                    "Se todos PASS, condição satisfeita."
                                  ],
                                  "verification": "Tabela completa com todos cheques corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Lista de primos do step 2; calculadora modular.",
                                  "tips": "Use propriedades modulares: compute a mod p primeiro.",
                                  "learningObjective": "Avaliar condições de congruência para maximalidade do período.",
                                  "commonMistakes": "Usar a em vez de a-1 ou ignorar condição de 4."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir a verificação e documentar resultado",
                                  "subSteps": [
                                    "Revise todas condições: gcd=1, todos p|(a-1), 4|(a-1) se aplicável.",
                                    "Declare: 'Período máximo garantido' ou 'Não garantido' com razões.",
                                    "Crie resumo em tabela final.",
                                    "Simule 1-2 iterações GCL para intuição (opcional)."
                                  ],
                                  "verification": "Conclusão lógica baseada em todas verificações anteriores.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Tabelas dos steps anteriores.",
                                  "tips": "Uma falha basta para período não máximo.",
                                  "learningObjective": "Sintetizar verificações para decisão final sobre parâmetros GCL.",
                                  "commonMistakes": "Ignorar uma condição ou concluir prematuramente."
                                }
                              ],
                              "practicalExample": "Dado m=16 (2^4), a=5, c=1: 1) gcd(1,16)=1 ✓; 2) Primos:2, 5-1=4, 4%2=0 ✓; 3) 4|16, 4%4=0 ✓. Período máximo garantido. Simule: X0=0 →1→6→11→2→... ciclo 16.",
                              "finalVerifications": [
                                "Todas 3 condições do teorema checadas explicitamente.",
                                "Fatoração de m correta e completa.",
                                "Cálculos modulares sem erros aritméticos.",
                                "Tabela de resumo com PASS/FAIL por condição.",
                                "Conclusão final justificada.",
                                "Exemplo prático resolvido corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na enunciação do teorema (100% correto).",
                                "Correção dos cálculos de gcd e divisibilidades.",
                                "Completude da tabela de fatores e verificações.",
                                "Clareza na documentação e conclusão.",
                                "Identificação correta de falhas potenciais.",
                                "Tempo respeitado e eficiência nos passos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (fatoração, gcd, congruências).",
                                "Programação: Implementar GCL em Python para validar período via simulação.",
                                "Estatística: Avaliar qualidade de sequências pseudoaleatórias em Monte Carlo.",
                                "Engenharia Civil: Aplicar em simulações de cargas aleatórias em estruturas."
                              ],
                              "realWorldApplication": "Na engenharia civil, verificar Hull-Dobell assegura sequências pseudoaleatórias de alta qualidade em simulações Monte Carlo para modelar ventos aleatórios, tráfego ou falhas em estruturas, evitando ciclos curtos que distorcem análises de risco e dimensionamento seguro."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Escolher parâmetros recomendados",
                            "description": "Identificar e justificar conjuntos de parâmetros padrão (ex.: a=1664525, c=1013904223, m=2^32) para aplicações em engenharia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os critérios matemáticos para seleção de parâmetros em GCL",
                                  "subSteps": [
                                    "Estudar a fórmula do GCL: X_{n+1} = (a * X_n + c) mod m.",
                                    "Analisar condições para período máximo (full period): c ≠ 0, m e c coprimos, a-1 divisível por todos os fatores primos de m, a-1 divisível por 4 se m divisível por 4.",
                                    "Revisar teorema de Hull-Dobell para garantir ciclo completo.",
                                    "Entender requisitos para boa distribuição estatística (teste de uniformidade, independência).",
                                    "Comparar trade-offs: período vs. qualidade espectral."
                                  ],
                                  "verification": "Listar e explicar os 4 critérios principais para full period em um resumo escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação sobre GCL (Wikipedia, livros de simulação numérica), calculadora ou software como Python para testes iniciais.",
                                  "tips": "Memorize as condições de Hull-Dobell como checklist.",
                                  "learningObjective": "Dominar os requisitos teóricos para parâmetros ótimos em GCL.",
                                  "commonMistakes": "Confundir condições para m power-of-2 com casos gerais; ignorar coprimos de c e m."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar conjuntos de parâmetros recomendados",
                                  "subSteps": [
                                    "Pesquisar parâmetros padrão: a=1664525, c=1013904223, m=2^32 (Numerical Recipes).",
                                    "Listar alternativas: a=16807, c=0, m=2^31-1 (Park-Miller); a=48271, c=0, m=2^31-1 (L'Ecuyer).",
                                    "Verificar se atendem full period para m=2^32.",
                                    "Consultar referências em engenharia (ex.: livros de Monte Carlo para simulações estruturais).",
                                    "Catalogar 3-5 conjuntos com suas origens e aplicações."
                                  ],
                                  "verification": "Criar tabela comparativa com 4 conjuntos, indicando se atendem full period.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Referências online (Numerical Recipes, artigos IEEE), planilha Excel ou Google Sheets.",
                                  "tips": "Priorize m=2^32 por compatibilidade com 32-bit integers em programação.",
                                  "learningObjective": "Reconhecer e catalogar parâmetros testados empiricamente.",
                                  "commonMistakes": "Escolher parâmetros sem verificar full period; usar c=0 sem justificativa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Justificar a escolha de parâmetros para aplicações em engenharia",
                                  "subSteps": [
                                    "Avaliar necessidades da aplicação: precisão, velocidade computacional, tamanho do período.",
                                    "Comparar conjuntos: ex. Numerical Recipes para bom equilíbrio em simulações longas.",
                                    "Justificar a=1664525, c=1013904223, m=2^32: full period ~4 bilhões, passes em testes DIEHARD.",
                                    "Considerar contexto de engenharia civil: simulações Monte Carlo com alto volume de amostras.",
                                    "Documentar prós/contras vs. alternativas (ex.: vs. Mersenne Twister)."
                                  ],
                                  "verification": "Escrever parágrafo de justificativa para um conjunto específico, citando critérios.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigos acadêmicos sobre GCL em engenharia, software de teste como TestU01.",
                                  "tips": "Ligue justificativa ao contexto: engenharia precisa de reprodutibilidade e velocidade.",
                                  "learningObjective": "Aplicar critérios para selecionar parâmetros adequados ao problema.",
                                  "commonMistakes": "Ignorar overhead computacional de m grande; superestimar qualidade sem testes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a escolha através de implementação e testes simples",
                                  "subSteps": [
                                    "Implementar GCL em Python ou MATLAB com parâmetros escolhidos.",
                                    "Gerar sequência de 10.000 números e plotar histograma para uniformidade.",
                                    "Executar testes básicos: chi-quadrado, poker test ou autocorrelation.",
                                    "Comparar com sequência conhecida ou biblioteca padrão (random).",
                                    "Ajustar ou confirmar adequação para simulação de engenharia."
                                  ],
                                  "verification": "Gerar relatório com gráficos e métricas de teste mostrando aprovação.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (numpy, matplotlib), MATLAB ou Jupyter Notebook; conjunto de testes DIEHARD mini.",
                                  "tips": "Use seed fixa para reprodutibilidade nos testes.",
                                  "learningObjective": "Validar teoricamente parâmetros com evidência empírica.",
                                  "commonMistakes": "Não normalizar saída para [0,1]; testar sequências curtas insuficientes."
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para análise de estabilidade de uma barragem, use a=1664525, c=1013904223, m=2^32 para gerar variações aleatórias na pressão hidrostática (ex.: multiplicar saída por range de cargas), executando 1 milhão de iterações para estimar probabilidade de falha.",
                              "finalVerifications": [
                                "Pode citar e verificar full period para pelo menos 3 conjuntos recomendados.",
                                "Justifica corretamente a escolha do Numerical Recipes para m=2^32.",
                                "Implementa GCL e passa em teste de uniformidade básico.",
                                "Identifica limitações (ex.: baixa entropia dimensional) e sugere melhorias.",
                                "Aplica em mini-simulação de engenharia com resultados coerentes.",
                                "Documenta tabela comparativa com critérios atendidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação dos critérios de Hull-Dobell (80% cobertura).",
                                "Correção na identificação e verificação de parâmetros recomendados.",
                                "Qualidade da justificativa contextualizada para engenharia civil.",
                                "Robustez dos testes de validação (mínimo 3 métricas).",
                                "Clareza na documentação e exemplos práticos.",
                                "Capacidade de comparar alternativas e trade-offs."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números e Teorema de Hull-Dobell.",
                                "Programação: Implementação de algoritmos numéricos em Python/MATLAB.",
                                "Estatística: Testes de hipóteses para uniformidade e independência.",
                                "Engenharia Civil: Simulações Monte Carlo em análise de riscos estruturais."
                              ],
                              "realWorldApplication": "Na engenharia civil, parâmetros recomendados como a=1664525, c=1013904223, m=2^32 são usados em simulações Monte Carlo para modelar cargas sísmicas aleatórias em pontes ou barragens, permitindo estimar probabilidades de colapso com milhões de cenários, otimizando projetos para segurança e custo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.1",
                              "10.1.7.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.3",
                        "name": "Normalização e Avaliação do GCL",
                        "description": "Transformação da sequência em números uniformes [0,1] e análise de propriedades como período, independência e uniformidade para uso no Método de Monte Carlo.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.3.1",
                            "name": "Normalizar sequência para distribuição uniforme",
                            "description": "Converter os inteiros X_n em U_n = X_n / (m-1) ou X_n / m para obter números pseudo-aleatórios em [0,1].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e compreender a sequência inteira X_n gerada pelo GCL",
                                  "subSteps": [
                                    "Liste a sequência X_n obtida do gerador congruencial linear (GCL).",
                                    "Identifique o módulo m usado no GCL.",
                                    "Verifique o intervalo dos X_n (deve estar entre 0 e m-1).",
                                    "Registre o comprimento da sequência para processamento.",
                                    "Anote quaisquer padrões iniciais observados nos X_n."
                                  ],
                                  "verification": "Confirme que todos X_n estão no intervalo [0, m-1] e a sequência está completa sem valores ausentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Sequência X_n do GCL, calculadora ou planilha (Excel/Google Sheets), papel e caneta.",
                                  "tips": "Use uma tabela para organizar X_n e m lado a lado para visualização rápida.",
                                  "learningObjective": "Compreender a saída bruta do GCL antes da normalização.",
                                  "commonMistakes": "Ignorar valores fora do intervalo ou confundir m com outro parâmetro do GCL."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o método de normalização apropriado",
                                  "subSteps": [
                                    "Decida entre U_n = X_n / m (para [0,1)) ou U_n = X_n / (m-1) (para [0,1]).",
                                    "Considere o contexto: /m é comum para uniformidade em [0,1), /(m-1) para inclusão de 1.",
                                    "Justifique a escolha com base em referências de literatura de números pseudo-aleatórios.",
                                    "Documente a escolha e o racional em uma nota.",
                                    "Teste com um X_n de exemplo para validar a decisão."
                                  ],
                                  "verification": "Escreva uma justificativa clara da escolha do divisor e confirme com um cálculo de teste.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Documentação do GCL (notas de aula), calculadora.",
                                  "tips": "Prefira /m para a maioria das simulações Monte Carlo em engenharia, pois evita U_n=1.",
                                  "learningObjective": "Discernir entre opções de normalização e suas implicações na distribuição.",
                                  "commonMistakes": "Usar divisor incorreto sem justificativa, como sempre escolher m independentemente do contexto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a sequência normalizada U_n",
                                  "subSteps": [
                                    "Aplique a fórmula escolhida: U_n = X_n / divisor para cada n.",
                                    "Calcule cada U_n com precisão decimal (mínimo 4 casas).",
                                    "Registre U_n em uma nova coluna ou lista paralela aos X_n.",
                                    "Arredonde apenas se especificado, mantendo precisão original.",
                                    "Verifique cálculos cruzando com pelo menos 20% da sequência manualmente."
                                  ],
                                  "verification": "Compare U_n calculados com fórmula reaplicada em amostra aleatória; todos devem coincidir.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha (Excel/Google Sheets com fórmulas), calculadora científica.",
                                  "tips": "Use fórmulas de planilha como =X_n / m para automação e redução de erros.",
                                  "learningObjective": "Executar transformações matemáticas precisas em sequências numéricas.",
                                  "commonMistakes": "Erros de divisão (ex: dividir por (m+1)) ou perda de precisão em arredondamentos prematuros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a distribuição uniforme dos U_n",
                                  "subSteps": [
                                    "Confirme que todos U_n ∈ [0,1] (ou [0,1) conforme escolha).",
                                    "Calcule estatísticas básicas: média ≈0.5, variância ≈1/12.",
                                    "Plote histograma ou teste de Kolmogorov-Smirnov simples.",
                                    "Compare com critérios de uniformidade (ausência de gaps ou clusters).",
                                    "Ajuste se necessário e revalide."
                                  ],
                                  "verification": "Estatísticas dentro de tolerâncias esperadas (média 0.4-0.6, todos em intervalo correto).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software de plotagem (Python/MATLAB/Excel), calculadora estatística.",
                                  "tips": "Para sequências curtas, foque em inspeção visual; use testes estatísticos para longas.",
                                  "learningObjective": "Avaliar qualidade da normalização para pseudo-aleatoriedade.",
                                  "commonMistakes": "Não verificar o intervalo final ou ignorar desvios estatísticos significativos."
                                }
                              ],
                              "practicalExample": "Dado m=100, sequência X_n = [23, 67, 12, 89, 45]. Usando U_n = X_n / m: U = [0.23, 0.67, 0.12, 0.89, 0.45]. Verifique: todos em [0,1), média ≈0.472, pronta para simulação Monte Carlo de cargas em estruturas civis.",
                              "finalVerifications": [
                                "Todos U_n estão no intervalo [0,1] ou [0,1) conforme método escolhido.",
                                "Cálculos precisos sem erros aritméticos em 100% da sequência.",
                                "Média dos U_n próxima de 0.5 (±0.1).",
                                "Ausência de padrões não-uniformes visíveis no histograma.",
                                "Justificativa documentada da escolha de normalização.",
                                "Estatísticas básicas (média, variância) atendem critérios de uniformidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de U_n (erro <0.001).",
                                "Escolha correta e justificada do divisor (m ou m-1).",
                                "Validação completa com estatísticas e visualizações.",
                                "Documentação clara de passos e resultados.",
                                "Aplicação contextualizada ao GCL e Monte Carlo.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de uniformidade e análise descritiva.",
                                "Programação: Implementação em Python/R para automação de GCL.",
                                "Engenharia Civil: Simulações Monte Carlo para análise de riscos estruturais.",
                                "Matemática: Transformações lineares e propriedades de distribuições uniformes."
                              ],
                              "realWorldApplication": "Em engenharia civil, normalizar sequências GCL para gerar cargas aleatórias em simulações Monte Carlo, avaliando confiabilidade de pontes ou edifícios sob ventos variáveis, otimizando projetos para segurança e custo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.2",
                            "name": "Calcular e verificar o período da sequência",
                            "description": "Determinar o comprimento do ciclo da sequência gerada e compará-lo com o período teórico máximo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar parâmetros do GCL e determinar o período teórico máximo",
                                  "subSteps": [
                                    "Identifique os parâmetros do GCL: semente X0, multiplicador a, incremento c e módulo m.",
                                    "Verifique as condições para período máximo: c ≠ 0, gcd(c, m) = 1, e a ≡ 1 mod p para cada primo p dividindo m.",
                                    "Calcule o período teórico máximo esperado (idealmente m para bom GCL).",
                                    "Anote as condições satisfeitas ou não para o conjunto de parâmetros dado.",
                                    "Documente fórmulas teóricas usadas para referência."
                                  ],
                                  "verification": "Lista de parâmetros e condições verificadas está completa e correta, com período teórico calculado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto; tabela de fatores primos se necessário.",
                                  "tips": "Use fatoração prima rápida para m pequeno; memorize condições padrão para m potência de 2 ou primo.",
                                  "learningObjective": "Compreender as condições matemáticas que garantem o período máximo no GCL.",
                                  "commonMistakes": "Esquecer gcd(c,m)=1 ou confundir condições para a quando m não é potência de 2."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração da sequência de números no GCL",
                                  "subSteps": [
                                    "Escreva código ou fórmula para gerar a sequência até pelo menos 2*m iterações para detectar ciclos.",
                                    "Inicialize com X0 e gere X1, X2, ..., registrando cada valor.",
                                    "Armazene a sequência em uma lista ou array para análise posterior.",
                                    "Garanta precisão numérica evitando overflow (use inteiros grandes se necessário).",
                                    "Teste com poucos passos para validar implementação."
                                  ],
                                  "verification": "Sequência gerada manualmente coincide com código para os primeiros 10 termos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de programação (Python, MATLAB ou Excel); calculadora para validação manual.",
                                  "tips": "Use loop while com contador; imprima sequência periodicamente para monitoramento.",
                                  "learningObjective": "Implementar corretamente o algoritmo iterativo do GCL.",
                                  "commonMistakes": "Erro em módulo (usar / em vez de %); inicializar errado ou esquecer c."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar o comprimento do ciclo (período) na sequência gerada",
                                  "subSteps": [
                                    "Use um dicionário ou mapa para rastrear índices de primeira ocorrência de cada X_i.",
                                    "Itere pela sequência até detectar repetição de um valor já visto (X_j == X_i com i > j).",
                                    "Calcule período como i - j, onde i é posição atual e j é posição anterior do valor repetido.",
                                    "Confirme que é o menor período verificando não haver ciclos menores iniciais.",
                                    "Registre o ponto de entrada no ciclo (tail) se aplicável."
                                  ],
                                  "verification": "Período detectado leva de volta ao mesmo estado; sequência repete corretamente após isso.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código de programação com estruturas de dados (dict em Python); papel para sequências curtas.",
                                  "tips": "Comece com m pequeno para testar algoritmo; visualize sequência plotando valores.",
                                  "learningObjective": "Aplicar detecção de ciclos em sequências finitas usando hashing.",
                                  "commonMistakes": "Detectar ciclo prematuro ignorando tail; confundir período com comprimento total gerado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar período observado com teórico e analisar discrepâncias",
                                  "subSteps": [
                                    "Compare período calculado com o teórico máximo (m).",
                                    "Identifique violações de condições que expliquem período menor.",
                                    "Calcule métricas como período/ m (eficiência).",
                                    "Teste com parâmetros alternativos para validar análise.",
                                    "Documente conclusões e sugestões de melhoria."
                                  ],
                                  "verification": "Relatório compara valores corretamente e explica causas de diferenças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráficos da sequência; tabela de comparação.",
                                  "tips": "Use condicionais if para checar condições automaticamente no código.",
                                  "learningObjective": "Avaliar qualidade do GCL relacionando teoria e prática.",
                                  "commonMistakes": "Atribuir período baixo a erro de código em vez de parâmetros ruins."
                                }
                              ],
                              "practicalExample": "Para GCL com m=10, a=7, c=3, X0=0: Sequência: 3, 3*7+3=24%10=4, 4*7+3=31%10=1, 1*7+3=10%10=0, 0*7+3=3... Período=4 (detectado em X4=0==X0). Teórico máx=10, mas gcd(3,10)=1 ok, porém a=7 não satisfaz condições para full period (7-1=6 não div por 5). Eficiência=40%.",
                              "finalVerifications": [
                                "Sequência gerada está correta para primeiros 20 termos.",
                                "Período detectado é o menor k com repetição de estado.",
                                "Condições teóricas listadas e verificadas.",
                                "Período observado ≤ teórico máximo.",
                                "Relatório inclui eficiência (período/m) e causas de subótimo.",
                                "Código roda sem erros e reproduz resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção do período (exata).",
                                "Correta aplicação de condições teóricas.",
                                "Implementação eficiente e livre de bugs.",
                                "Análise clara de discrepâncias.",
                                "Documentação completa com visualizações.",
                                "Uso apropriado de recursos computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números (gcd, congruências modulares).",
                                "Programação: Estruturas de dados (dicionários para detecção de ciclos).",
                                "Estatística: Avaliação de qualidade de geradores pseudo-aleatórios.",
                                "Engenharia: Simulações Monte Carlo para análise de riscos estruturais."
                              ],
                              "realWorldApplication": "Em engenharia civil, GCL é usado em simulações Monte Carlo para modelar cargas aleatórias em pontes ou edifícios, avaliando falhas; período longo garante amostras independentes, evitando viés em análises probabilísticas de estabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.3",
                            "name": "Implementar teste de qualidade básica",
                            "description": "Gerar gráfico de histograma da sequência normalizada para avaliar uniformidade e detectar padrões ou ciclos curtos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a sequência normalizada do GCL",
                                  "subSteps": [
                                    "Implementar ou carregar o gerador congruencial linear (GCL) com parâmetros adequados (ex: a=1664525, c=1013904223, m=2**32, x0=1).",
                                    "Gerar uma sequência longa de pelo menos 10.000 números pseudoaleatórios.",
                                    "Normalizar a sequência dividindo cada Ui por m, obtendo valores em [0,1).",
                                    "Armazenar a sequência em um array NumPy para eficiência.",
                                    "Verificar estatisticamente os primeiros valores para confirmar normalização correta."
                                  ],
                                  "verification": "Executar print dos primeiros 10 valores normalizados e confirmar que estão em [0,1).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python 3, bibliotecas NumPy e Jupyter Notebook",
                                  "tips": "Use sementes fixas (seed) para reprodutibilidade durante testes.",
                                  "learningObjective": "Compreender e aplicar a normalização no GCL para obter distribuição em [0,1).",
                                  "commonMistakes": "Esquecer de subtrair 1 após divisão por m, resultando em valores até 1 inclusivo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir parâmetros e calcular frequências dos bins",
                                  "subSteps": [
                                    "Escolher o número de bins (ex: 50 para 10.000 amostras, regra de Sturges ou sqrt(n)).",
                                    "Definir os limites dos bins de 0 a 1.",
                                    "Usar np.histogram() para calcular as frequências absolutas em cada bin.",
                                    "Calcular frequências relativas dividindo por total de amostras.",
                                    "Armazenar bordas dos bins e frequências em variáveis separadas."
                                  ],
                                  "verification": "Verificar que soma das frequências absolutas equals len(sequência) e que há exatamente o número de bins definido.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Biblioteca NumPy",
                                  "tips": "Escolha bins como potência de 2 ou múltiplo de 10 para facilitar visualização.",
                                  "learningObjective": "Selecionar e calcular distribuições de frequências para análise de uniformidade.",
                                  "commonMistakes": "Usar bins muito poucos (ex: 10), mascarando padrões; ou muitos, criando ruído."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e visualizar o histograma",
                                  "subSteps": [
                                    "Importar matplotlib.pyplot as plt.",
                                    "Usar plt.hist() com a sequência, bins definidos, e normalização para densidade ou frequência relativa.",
                                    "Adicionar título 'Histograma da Sequência Normalizada GCL', labels 'Bins' e 'Frequência Relativa'.",
                                    "Configurar grade, limites do eixo y para melhor visualização.",
                                    "Exibir o gráfico com plt.show() ou salvar como PNG."
                                  ],
                                  "verification": "Gráfico gerado sem erros, com barras uniformes visualmente e eixos rotulados corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Biblioteca Matplotlib",
                                  "tips": "Use density=True para comparar com uniforme teórica (altura 1).",
                                  "learningObjective": "Criar visualizações de dados para testes estatísticos de qualidade.",
                                  "commonMistakes": "Esquecer plt.figure() para tamanho adequado ou não normalizar o histograma."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar uniformidade e detectar padrões ou ciclos",
                                  "subSteps": [
                                    "Observar visualmente: barras de alturas similares? Ausência de picos ou vales?",
                                    "Verificar desvios: calcular variância das frequências e comparar com esperada (1/bin_count).",
                                    "Procurar padrões: ciclos curtos aparecem como repetições em bins adjacentes.",
                                    "Comparar com histograma uniforme teórico (adicionar linha reta y=1).",
                                    "Documentar observações em relatório ou comentários no código."
                                  ],
                                  "verification": "Relatório escrito confirmando uniformidade ou identificando anomalias específicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfico gerado e calculadora ou NumPy para variância",
                                  "tips": "Aumente n para 100.000 se padrões não forem evidentes.",
                                  "learningObjective": "Interpretar histogramas para validar qualidade de geradores pseudoaleatórios.",
                                  "commonMistakes": "Ignorar variações aleatórias normais, confundindo com falhas do GCL."
                                }
                              ],
                              "practicalExample": "Em Python: gere sequência GCL com 50.000 pontos (a=1664525, m=2**32), normalize U[i] = X[i]/m, plote histograma com 100 bins e density=True. Adicione plt.plot([0,1],[1,1],'r--') para uniforme ideal. Observe se sobrepõe bem, indicando boa uniformidade.",
                              "finalVerifications": [
                                "Histograma exibe distribuição aproximadamente uniforme sem picos evidentes.",
                                "Frequências relativas próximas de 1/n_bins em todos os bins.",
                                "Ausência de padrões repetitivos ou ciclos curtos nos bins adjacentes.",
                                "Variância das frequências dentro de 10-20% do valor teórico.",
                                "Código executável gera gráfico reproduzível com seed fixa.",
                                "Relatório de análise documenta achados quantitativos e qualitativos."
                              ],
                              "assessmentCriteria": [
                                "Código completo e sem erros sintáticos ou lógicos.",
                                "Sequência normalizada corretamente em [0,1).",
                                "Histograma plotado com parâmetros adequados e visualmente claro.",
                                "Análise identifica corretamente uniformidade ou falhas do GCL.",
                                "Uso eficiente de bibliotecas (NumPy/Matplotlib).",
                                "Documentação de código com comentários explicativos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes qui-quadrado de bondade de ajuste para uniformidade.",
                                "Programação: Manipulação de arrays e visualização de dados com Python.",
                                "Engenharia Civil: Simulações Monte Carlo para análise de riscos em estruturas.",
                                "Matemática Computacional: Avaliação de algoritmos numéricos iterativos."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para previsão de falhas em barragens ou pontes, um histograma uniforme garante que as amostras representem distribuições reais de cargas e materiais, evitando vieses em análises de segurança."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.3",
                              "10.1.7.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Testes de Aleatoriedade",
                    "description": "Métodos para avaliar a qualidade de geradores pseudo-aleatórios, como testes de frequência e qui-quadrado.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Conceito Geral de Testes de Aleatoriedade",
                        "description": "Princípios fundamentais para avaliar a qualidade de geradores pseudo-aleatórios, incluindo a importância de verificar independência, uniformidade e ausência de padrões previsíveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Identificar a necessidade de testes de aleatoriedade",
                            "description": "Explicar por que geradores pseudo-aleatórios precisam ser testados, diferenciando aleatoriedade verdadeira de pseudo-aleatoriedade e os riscos de falhas em simulações como Monte Carlo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Diferenciar Aleatoriedade Verdadeira de Pseudo-Aleatoriedade",
                                  "subSteps": [
                                    "Defina aleatoriedade verdadeira como eventos imprevisíveis baseados em fenômenos físicos quânticos ou térmicos.",
                                    "Explique pseudo-aleatoriedade como sequências determinísticas geradas por algoritmos com semente inicial.",
                                    "Compare propriedades: verdadeira é imprevisível e sem padrões; pseudo tem período finito e pode ser reproduzível.",
                                    "Discuta fontes: hardware para verdadeira (ex: ruído térmico); software para pseudo (ex: Mersenne Twister)."
                                  ],
                                  "verification": "Resuma as diferenças em um parágrafo e forneça um exemplo de cada tipo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigos sobre fontes de entropia (NIST SP 800-90B)",
                                    "Documentação de PRNGs como Python random module"
                                  ],
                                  "tips": "Use analogias: verdadeira como lançamento de dado real; pseudo como dado com sequência pré-definida.",
                                  "learningObjective": "Compreender as diferenças fundamentais entre aleatoriedade verdadeira e pseudo-aleatoriedade.",
                                  "commonMistakes": [
                                    "Confundir reproduzibilidade de PRNGs com aleatoriedade verdadeira",
                                    "Ignorar que PRNGs são determinísticos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Limitações dos Geradores Pseudo-Aleatórios (PRNGs)",
                                  "subSteps": [
                                    "Identifique limitações: período finito, correlações estatísticas, baixa entropia em sementes ruins.",
                                    "Estude propriedades desejáveis: uniformidade, independência, longo período.",
                                    "Examine falhas comuns: padrões curtos em LCGs lineares congruentes.",
                                    "Revise testes básicos visuais como plot de pontos em plano unitário para detectar padrões.",
                                    "Discuta impacto: distribuições enviesadas em amostras grandes."
                                  ],
                                  "verification": "Gere 1000 números pseudo-aleatórios e plote para identificar qualquer padrão visual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou MATLAB para gerar e plotar sequências",
                                    "Exemplos de PRNGs fracos como rand() em C antigo"
                                  ],
                                  "tips": "Sempre fixe a semente para reproduzir e debugar problemas.",
                                  "learningObjective": "Reconhecer limitações inerentes dos PRNGs e suas implicações.",
                                  "commonMistakes": [
                                    "Assumir que todos PRNGs são igualmente bons",
                                    "Não considerar tamanho da amostra em análises"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Aplicações Críticas como Simulações Monte Carlo",
                                  "subSteps": [
                                    "Descreva Monte Carlo: método de amostragem aleatória para estimar integrais ou probabilidades.",
                                    "Explique dependência em PRNGs: bilhões de amostras requerem alta qualidade.",
                                    "Identifique contextos em Engenharia Civil: análise de risco em estruturas sob cargas variáveis.",
                                    "Discuta sensibilidade: PRNG ruim pode levar a estimativas enviesadas de falhas.",
                                    "Relacione com testes: sem testes, simulações perdem confiabilidade."
                                  ],
                                  "verification": "Descreva um fluxograma de uma simulação Monte Carlo simples e destaque onde PRNG é usado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tutoriais de Monte Carlo em engenharia (ex: livros de Ang e Tang)",
                                    "Código exemplo em Python para Monte Carlo pi"
                                  ],
                                  "tips": "Comece com problemas simples como estimar π para ver impacto de PRNGs ruins.",
                                  "learningObjective": "Entender por que aplicações como Monte Carlo demandam PRNGs testados.",
                                  "commonMistakes": [
                                    "Subestimar número de amostras necessárias",
                                    "Ignorar variância introduzida por PRNGs fracos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Riscos e Necessidade Imperativa de Testes",
                                  "subSteps": [
                                    "Liste riscos: decisões erradas em engenharia (ex: subestimar colapso estrutural).",
                                    "Cite casos históricos: falhas em criptografia ou simulações científicas por PRNGs ruins.",
                                    "Defina necessidade de testes: validar uniformidade, independência via testes estatísticos (Chi-quadrado, Kolmogorov-Smirnov).",
                                    "Planeje rotina: testar antes de usar em produção, monitorar em runtime.",
                                    "Conclua: testes garantem robustez em simulações críticas."
                                  ],
                                  "verification": "Escreva uma lista de 5 riscos específicos e como testes os mitigam.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Relatórios NIST sobre testes de aleatoriedade (STS suite)",
                                    "Casos de estudo de falhas PRNG (ex: Debian OpenSSL)"
                                  ],
                                  "tips": "Priorize testes estatísticos automatizados em pipelines de simulação.",
                                  "learningObjective": "Justificar a necessidade de testes de aleatoriedade em contextos práticos.",
                                  "commonMistakes": [
                                    "Achar que PRNGs built-in são infalíveis",
                                    "Pular testes por 'funcionar bem em testes pequenos'"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para estimar a probabilidade de falha de uma ponte sob vento turbulento, um PRNG fraco gera clusters de valores altos, superestimando estabilidade e levando a design inseguro. Testes revelam o viés, permitindo troca por PRNG testado.",
                              "finalVerifications": [
                                "Explique a diferença entre aleatoriedade verdadeira e pseudo em suas próprias palavras.",
                                "Identifique 3 limitações de PRNGs e dê exemplos.",
                                "Descreva como um PRNG ruim afeta Monte Carlo em engenharia civil.",
                                "Liste 4 testes de aleatoriedade comuns e seu propósito.",
                                "Justifique por que testes são necessários antes de simulações críticas.",
                                "Forneça um exemplo real-world de falha por PRNG não testado."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara entre tipos de aleatoriedade (30%)",
                                "Profundidade de análise: identificação correta de limitações e riscos (25%)",
                                "Relevância contextual: ligação forte com Monte Carlo e engenharia (20%)",
                                "Exemplos práticos: uso de casos concretos e verificáveis (15%)",
                                "Clareza e estrutura: explicação lógica e concisa (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses como Chi-quadrado para uniformidade.",
                                "Programação: Implementação e teste de algoritmos PRNG em Python/R.",
                                "Matemática: Teoria da probabilidade e convergência em Monte Carlo.",
                                "Engenharia Civil: Análise estocástica de riscos estruturais.",
                                "Cibersegurança: Importância de aleatoriedade em criptografia."
                              ],
                              "realWorldApplication": "Na engenharia civil, identificar a necessidade de testes de aleatoriedade assegura simulações Monte Carlo precisas para previsão de falhas em barragens ou edifícios sob terremotos, evitando erros custosos em projetos de infraestrutura."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Classificar tipos de testes de aleatoriedade",
                            "description": "Listar e categorizar testes comuns como testes de frequência, runs, poker e qui-quadrado, descrevendo o que cada um verifica na sequência gerada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Propósito Geral dos Testes de Aleatoriedade",
                                  "subSteps": [
                                    "Revise o conceito de aleatoriedade em sequências numéricas geradas por computadores.",
                                    "Identifique por que testes estatísticos são necessários para validar geradores de números pseudoaleatórios (GNPA).",
                                    "Liste os principais atributos de aleatoriedade: uniformidade, independência e ausência de padrões.",
                                    "Discuta limitações dos GNPA em aplicações de Engenharia Civil, como simulações Monte Carlo.",
                                    "Acesse documentação ou tutoriais sobre testes padrão (ex: NIST SP 800-22)."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o propósito e os atributos testados, confirmando com uma fonte confiável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação NIST SP 800-22 (PDF ou site)",
                                    "Notebook para anotações",
                                    "Acesso à internet"
                                  ],
                                  "tips": "Foquem em exemplos visuais de sequências ruins vs. boas para fixar conceitos.",
                                  "learningObjective": "Compreender o papel dos testes de aleatoriedade na validação de GNPA.",
                                  "commonMistakes": [
                                    "Confundir aleatoriedade verdadeira com pseudoaleatoriedade.",
                                    "Ignorar que testes avaliam propriedades específicas, não 'aleatoriedade total'."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Testes de Frequência e Runs",
                                  "subSteps": [
                                    "Aprenda o Teste de Frequência: conta a proporção de 0s e 1s em uma sequência binária, verificando uniformidade.",
                                    "Calcule manualmente para uma sequência pequena: esperada 50% cada, usando desvio qui-quadrado.",
                                    "Entenda o Teste de Runs: conta sequências de bits iguais consecutivos (runs up/down), testando independência.",
                                    "Implemente fórmulas: número de runs esperado ≈ (2n1n2)/n + 1, onde n1/n2 são contagens de 0/1.",
                                    "Compare resultados: frequência falha indica bias; runs falha indica correlação."
                                  ],
                                  "verification": "Aplique ambos testes a uma sequência de 20 bits e interprete p-valores >0.01 como passantes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou planilha Excel",
                                    "Sequências de exemplo (geradas por rand() em Python)",
                                    "Tabela de distribuição normal para p-valores"
                                  ],
                                  "tips": "Use sequências binárias curtas para prática manual antes de código.",
                                  "learningObjective": "Classificar e descrever o que Teste de Frequência e Runs verificam.",
                                  "commonMistakes": [
                                    "Esquecer converter decimal para binário.",
                                    "Confundir runs com frequência simples."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Testes de Poker e Qui-Quadrado",
                                  "subSteps": [
                                    "Estude Teste de Poker: agrupa 5 bits em 'mãos de poker' (todas iguais, uma par, etc.), testando distribuição.",
                                    "Liste 16 tipos de mãos e probabilidades esperadas (ex: 0.315 para flush).",
                                    "Aprenda Teste Qui-Quadrado (χ²): compara frequências observadas vs. esperadas em histograma de dígitos.",
                                    "Calcule estatística χ² = Σ(O_i - E_i)² / E_i, com graus de liberdade k-1.",
                                    "Aplique a uma sequência: divida em blocos, conte ocorrências e compare.",
                                    "Diferencie: Poker foca padrões locais; χ² global."
                                  ],
                                  "verification": "Gere uma sequência, aplique Poker e χ², rejeite se p < 0.01.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software Python (scipy.stats.chi2)",
                                    "Tabelas de probabilidades Poker",
                                    "Sequências de teste padrão"
                                  ],
                                  "tips": "Implemente em código para automação após cálculo manual.",
                                  "learningObjective": "Classificar e descrever verificações de Poker e Qui-Quadrado.",
                                  "commonMistakes": [
                                    "Usar blocos errados no χ² (tipicamente 10 dígitos).",
                                    "Ignorar graus de liberdade."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar e Comparar Todos os Testes",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: coluna para cada teste, linhas para atributos (uniformidade, independência, padrões).",
                                    "Classifique: Frequência (uniformidade), Runs (independência), Poker (distribuições locais), χ² (ajuste geral).",
                                    "Discuta forças/fraquezas: Frequência simples mas fraco; χ² poderoso mas sensível a amostra.",
                                    "Aplique a uma sequência real de GNPA em simulação Monte Carlo.",
                                    "Pratique categorizando novos testes como serial ou autocorrelation."
                                  ],
                                  "verification": "Preencha tabela corretamente e classifique 3 sequências como 'aleatória' ou 'não'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou Excel para tabela",
                                    "Código Python para gerar/testar sequências"
                                  ],
                                  "tips": "Use cores na tabela para atributos testados (verde=sim).",
                                  "learningObjective": "Categorizar testes e descrever o que cada um verifica.",
                                  "commonMistakes": [
                                    "Sobrecarregar um teste como 'teste completo'.",
                                    "Não considerar tamanho da amostra."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Classificação em Contextos Reais",
                                  "subSteps": [
                                    "Gere sequências com diferentes GNPA (linear congruente vs. Mersenne Twister).",
                                    "Aplique todos os 4 testes e classifique aleatoriedade.",
                                    "Simule aplicação em Engenharia Civil: teste números para Monte Carlo em análise de estruturas.",
                                    "Registre classificações e razões em um relatório curto.",
                                    "Debata com pares ou autoavalie inconsistências."
                                  ],
                                  "verification": "Relatório com classificações corretas para 2 sequências, >80% acerto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook com numpy.random",
                                    "Exemplos de Monte Carlo em Civil"
                                  ],
                                  "tips": "Compare GNPA ruins (ex: randu) vs. bons.",
                                  "learningObjective": "Aplicar classificação em cenários práticos.",
                                  "commonMistakes": [
                                    "Usar amostras pequenas (<1000 bits).",
                                    "Ignorar p-valores ajustados por múltiplos testes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para prever falhas em uma ponte sob cargas aleatórias, gere 10.000 números com GNPA linear congruente. Aplique os testes: Frequência falha (bias em 0s), Runs passa, Poker detecta padrões, χ² rejeita. Classifique como inadequado e troque por Mersenne Twister, que passa todos.",
                              "finalVerifications": [
                                "Liste corretamente os 4 testes e seus atributos principais sem consulta.",
                                "Classifique uma sequência binária de 100 bits usando todos os testes.",
                                "Explique por que um teste falha implica rejeição do GNPA.",
                                "Crie tabela comparativa precisa.",
                                "Aplique em código Python e interprete saídas.",
                                "Identifique teste ideal para uniformidade vs. independência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de cada teste (100% dos atributos corretos).",
                                "Capacidade de calcular manualmente para sequências pequenas (erro <5%).",
                                "Tabela comparativa completa e lógica.",
                                "Interpretação correta de p-valores (>0.01 passa).",
                                "Aplicação contextual em Engenharia Civil.",
                                "Identificação de erros comuns em exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuições qui-quadrado e normal.",
                                "Programação: Implementação em Python/R para testes automatizados.",
                                "Engenharia Civil: Validação em simulações Monte Carlo para confiabilidade estrutural.",
                                "Matemática: Probabilidade e análise combinatória (Poker).",
                                "Ciência da Computação: Algoritmos de GNPA e testes NIST."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, classificar testes de aleatoriedade garante sequências válidas em Monte Carlo para modelar cargas sísmicas, tráfego ou degradação de materiais, evitando erros em análises de risco que poderiam levar a projetos inseguros ou superdimensionados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Interpretar resultados de testes estatísticos",
                            "description": "Analisar p-valores e estatísticas de teste para determinar se um gerador passa ou falha, considerando níveis de significância como 0.05.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar componentes chave nos resultados do teste estatístico",
                                  "subSteps": [
                                    "Localize o p-valor no output do teste (ex: p = 0.03).",
                                    "Identifique a estatística de teste (ex: chi-quadrado = 15.2).",
                                    "Note os graus de liberdade (df) e o tamanho da amostra (n).",
                                    "Registre o nome do teste (ex: Kolmogorov-Smirnov, Chi-quadrado).",
                                    "Verifique se há intervalos de confiança ou outros métricas auxiliares."
                                  ],
                                  "verification": "Liste corretamente todos os componentes chave extraídos do output de exemplo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Output de teste estatístico de software (R, Python - scipy.stats); calculadora.",
                                  "tips": "Sempre copie o output completo antes de analisar para evitar perda de dados.",
                                  "learningObjective": "Compreender e extrair precisamente os elementos essenciais de um resultado de teste estatístico.",
                                  "commonMistakes": "Confundir p-valor com a estatística de teste; ignorar df ou n."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e justificar o nível de significância (alpha)",
                                  "subSteps": [
                                    "Escolha alpha padrão (0.05 para testes de aleatoriedade em Monte Carlo).",
                                    "Justifique a escolha baseada no contexto (ex: 0.01 para aplicações críticas em engenharia).",
                                    "Considere trade-offs: alpha baixo reduz falsos positivos, mas aumenta falsos negativos.",
                                    "Documente alpha selecionado e hipótese nula (H0: gerador é aleatório).",
                                    "Verifique se alpha é consistente com padrões da literatura (ex: Diehard tests)."
                                  ],
                                  "verification": "Explique por escrito a escolha de alpha e sua justificativa para um caso dado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Referências: livros de testes de RNG (Knuth); tabela de significância.",
                                  "tips": "Use alpha=0.05 como default, mas ajuste para contextos de engenharia civil sensíveis.",
                                  "learningObjective": "Selecionar apropriadamente o nível de significância com base no contexto de aplicação.",
                                  "commonMistakes": "Usar alpha arbitrário sem justificativa; confundir alpha com poder do teste."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar p-valor com alpha e decidir rejeição de H0",
                                  "subSteps": [
                                    "Compare: se p <= alpha, rejeite H0 (gerador falha).",
                                    "Se p > alpha, falhe em rejeitar H0 (gerador passa).",
                                    "Calcule a força da evidência (ex: p=0.001 é evidência forte contra H0).",
                                    "Considere múltiplos testes: ajuste alpha com Bonferroni se necessário.",
                                    "Registre a decisão binária: 'Passa' ou 'Falha' com p-valor e alpha."
                                  ],
                                  "verification": "Para um p-valor dado, declare corretamente 'passa' ou 'falha' com explicação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software para simular testes (Python: numpy.random, scipy.stats); planilha.",
                                  "tips": "Lembre: p-valor é probabilidade sob H0, não probabilidade de H0 ser verdadeira.",
                                  "learningObjective": "Aplicar corretamente a regra de decisão p-valor vs. alpha para testes de aleatoriedade.",
                                  "commonMistakes": "Inverter a condição (p > alpha rejeita); ignorar múltiplos testes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar implicações e reportar resultados no contexto",
                                  "subSteps": [
                                    "Explique o que 'falha' significa: gerador não é adequadamente aleatório para Monte Carlo.",
                                    "Discuta impacto em simulações de engenharia civil (ex: viés em análises estruturais).",
                                    "Recomende ações: trocar gerador, aumentar amostra, ou refazer teste.",
                                    "Crie um relatório resumido: teste, p-valor, decisão, implicações.",
                                    "Valide com benchmark: compare com resultados conhecidos de geradores padrão."
                                  ],
                                  "verification": "Produza um relatório de 1 parágrafo interpretando um resultado completo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Templates de relatório; exemplos de outputs de testes Diehard ou NIST.",
                                  "tips": "Sempre contextualize: aleatoriedade fraca afeta precisão de Monte Carlo em cargas aleatórias.",
                                  "learningObjective": "Traduzir resultados estatísticos em recomendações práticas para engenharia.",
                                  "commonMistakes": "Superestimar p-valor alto como 'perfeitamente aleatório'; omitir contexto."
                                }
                              ],
                              "practicalExample": "Usando Python (scipy.stats.kstest) em um gerador LCG: output mostra p=0.02, chi2=28.5 (df=10), alpha=0.05. Decisão: rejeitar H0, gerador falha teste KS – inadequado para simular ventos aleatórios em pontes.",
                              "finalVerifications": [
                                "Corretamente extrai e lista p-valor, estatística e df de um output.",
                                "Justifica alpha=0.05 e aplica regra de decisão sem erros.",
                                "Interpreta 'falha' com implicações para Monte Carlo.",
                                "Produz relatório claro com decisão binária e recomendações.",
                                "Ajusta para múltiplos testes usando Bonferroni.",
                                "Valida contra benchmark de gerador Mersenne Twister (p>0.05 esperado)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de componentes (100% correto).",
                                "Justificativa lógica para alpha (clareza e relevância).",
                                "Decisão p-valor vs. alpha sem inversão de lógica.",
                                "Profundidade na interpretação contextual (engenharia civil).",
                                "Qualidade do relatório: conciso, acionável e completo.",
                                "Tratamento de edge cases (p exato=alpha, múltiplos testes).",
                                "Consistência com literatura de testes de RNG."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Hipótese nula e testes.",
                                "Programação: Implementação em Python/R para testes.",
                                "Engenharia Civil: Aplicações em simulações Monte Carlo para estruturas.",
                                "Análise de Dados: Interpretação de outputs em big data de simulações.",
                                "Matemática Computacional: Teoria de geradores pseudo-aleatórios."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, validar geradores RNG antes de simulações Monte Carlo para modelar cargas sísmicas ou ventos em edifícios; falha no teste indica risco de análises enviesadas, potencialmente levando a designs inseguros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Teste de Frequência (Monobit)",
                        "description": "Teste que verifica a uniformidade da distribuição de bits 0 e 1 em uma sequência binária gerada pelo pseudo-gerador aleatório.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Calcular a estatística do teste de frequência",
                            "description": "Computar o número de 1s em uma sequência de N bits e aplicar a fórmula da estatística chi-quadrado simplificada: X = (n1 - n/2)^2 / (n/2), onde n1 é o número de 1s e n o comprimento total.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a sequência de bits e determinar o comprimento n",
                                  "subSteps": [
                                    "Obtenha ou gere a sequência de N bits de um gerador de números aleatórios.",
                                    "Valide que cada elemento da sequência é 0 ou 1 (binário).",
                                    "Calcule n como o comprimento total da sequência.",
                                    "Registre o valor de n para uso posterior.",
                                    "Opcionalmente, imprima a sequência para inspeção visual."
                                  ],
                                  "verification": "Confirme que n corresponde ao comprimento esperado e todos os bits são binários (sem erros de entrada).",
                                  "estimatedTime": "5-10 minutes",
                                  "materials": [
                                    "Sequência de bits (array ou string em Python/R/etc.)",
                                    "Editor de código (VS Code, Jupyter Notebook)"
                                  ],
                                  "tips": "Use funções como len() em Python para n; garanta que a sequência tenha pelo menos 100 bits para testes realistas.",
                                  "learningObjective": "Validar e preparar dados de entrada para análise estatística.",
                                  "commonMistakes": "Incluir bits não binários (ex: strings com letras), calcular n incorretamente como número de 1s."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contar o número de 1s (n1) na sequência",
                                  "subSteps": [
                                    "Inicialize um contador n1 = 0.",
                                    "Itere através de cada bit na sequência usando um loop.",
                                    "Para cada bit igual a 1, incremente n1 em 1.",
                                    "Após a iteração, registre o valor final de n1.",
                                    "Valide a contagem manualmente em uma sub-sequência curta."
                                  ],
                                  "verification": "Conte manualmente os 1s em uma porção da sequência (ex: primeiros 10 bits) e compare com o contador.",
                                  "estimatedTime": "10-15 minutes",
                                  "materials": [
                                    "Código de programação (Python: list.count('1') ou loop)",
                                    "Calculadora para validação manual"
                                  ],
                                  "tips": "Em Python, use sum(1 for bit in bits if bit == 1) para eficiência; evite contagens manuais para sequências longas.",
                                  "learningObjective": "Implementar contagem precisa de ocorrências em dados binários.",
                                  "commonMistakes": "Incrementar contador para 0s por engano, off-by-one errors em loops, confundir n1 com n."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a estatística X usando a fórmula",
                                  "subSteps": [
                                    "Calcule expected = n / 2.0 (use divisão de ponto flutuante).",
                                    "Compute diff = n1 - expected.",
                                    "Calcule squared = diff * diff.",
                                    "Calcule X = squared / expected.",
                                    "Arredonde X para 4 casas decimais e registre o resultado."
                                  ],
                                  "verification": "Substitua valores manualmente em uma calculadora e compare com o resultado computado.",
                                  "estimatedTime": "10-15 minutes",
                                  "materials": [
                                    "Código de programação",
                                    "Calculadora científica ou Google para verificação manual"
                                  ],
                                  "tips": "Sempre use float para expected e operações para evitar truncamento inteiro em linguagens como C/Python2.",
                                  "learningObjective": "Aplicar fórmula estatística chi-quadrado simplificada com precisão numérica.",
                                  "commonMistakes": "Usar divisão inteira (ex: n//2), esquecer de elevar ao quadrado, inverter n1 e expected."
                                }
                              ],
                              "practicalExample": "Para uma sequência de 20 bits: ['1','0','1','1','0','0','1','1','0','1','0','1','1','0','1','0','1','0','1','1']. n=20, n1=12 (conte os 1s). expected=10.0, diff=2.0, squared=4.0, X=4.0/10.0=0.4. Baixo valor sugere boa aleatoriedade.",
                              "finalVerifications": [
                                "n corresponde exatamente ao comprimento da sequência.",
                                "n1 é contado corretamente (validado manualmente em sub-sequência).",
                                "Cálculo de expected usa divisão float.",
                                "X é computado sem erros aritméticos (verificação manual).",
                                "Resultado X está no intervalo esperado (tipicamente 0 a ~n para n grande).",
                                "Código ou cálculo é reproduzível com os mesmos inputs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de n1 (100% correto).",
                                "Aplicação correta da fórmula sem variações (exato match).",
                                "Uso apropriado de tipos de dados (float para divisões).",
                                "Validação interna implementada (ex: prints ou asserts).",
                                "Eficiência do código (O(n) tempo, sem loops desnecessários).",
                                "Explicação clara do processo em comentários ou relatório."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Entender testes qui-quadrado e hipóteses nulas para aleatoriedade.",
                                "Programação: Loops, condicionais e manipulação de arrays/listas.",
                                "Probabilidade: Distribuição binomial subjacente ao teste monobit.",
                                "Engenharia Computacional: Validação de RNG em simulações numéricas."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para análise de confiabilidade de estruturas civis (ex: cargas aleatórias em pontes), este teste garante que o gerador de números aleatórios não tenha bias de frequência, evitando erros em previsões de falhas probabilísticas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Implementar o teste de frequência em código",
                            "description": "Escrever um programa em MATLAB ou Python para gerar uma sequência pseudo-aleatória, converter para binário e aplicar o teste, comparando com tabela crítica de chi-quadrado com 1 grau de liberdade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e gerar sequência pseudo-aleatória",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias: numpy para geração de números aleatórios e scipy para distribuições chi-quadrado.",
                                    "Definir parâmetros: tamanho da sequência (ex: n=10000), semente para reprodutibilidade (np.random.seed(42)).",
                                    "Gerar sequência uniforme: usar np.random.uniform(0,1,n) para criar números pseudo-aleatórios entre 0 e 1.",
                                    "Salvar a sequência em uma variável para uso posterior.",
                                    "Visualizar os primeiros 10 valores para inspeção inicial."
                                  ],
                                  "verification": "Executar o código e confirmar que a sequência tem o tamanho correto e valores entre 0 e 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com NumPy instalado; editor como Jupyter Notebook ou VS Code.",
                                  "tips": "Sempre defina uma semente para resultados reproduzíveis durante testes.",
                                  "learningObjective": "Entender geração de sequências pseudo-aleatórias uniformes em Python.",
                                  "commonMistakes": "Esquecer de importar bibliotecas ou usar intervalos errados (não 0-1)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter sequência para binário (Teste Monobit)",
                                  "subSteps": [
                                    "Criar array binário: converter valores >0.5 para 1 e <=0.5 para 0 usando np.where(seq > 0.5, 1, 0).",
                                    "Contar número de 1s (ones) e 0s (zeros): usar np.sum(binary_seq) para ones e n - ones para zeros.",
                                    "Verificar proporção: calcular ones/n e zeros/n, que devem estar próximos de 0.5 para aleatoriedade.",
                                    "Armazenar contagens em variáveis para próximo passo.",
                                    "Plotar histograma dos bits para visualização intuitiva."
                                  ],
                                  "verification": "Confirmar que soma de ones + zeros = n e proporções ≈0.5.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "NumPy; Matplotlib para plot opcional.",
                                  "tips": "Use vectorização do NumPy para eficiência em grandes n.",
                                  "learningObjective": "Mapear sequência contínua para binária conforme padrão Monobit.",
                                  "commonMistakes": "Usar threshold errado (ex: 0.5 estrito) ou confundir > com >=."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular estatística chi-quadrado do teste de frequência",
                                  "subSteps": [
                                    "Calcular proporções observadas: p_ones = ones/n, p_zeros = zeros/n.",
                                    "Computar estatística: chi2 = n * (p_ones - 0.5)**2 / 0.5 + n * (p_zeros - 0.5)**2 / 0.5, simplificando para n * (2*ones/n - 1)**2.",
                                    "Importar scipy.stats e obter valor crítico: chi2_crit = stats.chi2.ppf(0.95, df=1) para 95% confiança.",
                                    "Salvar chi2_stat e chi2_crit em variáveis.",
                                    "Imprimir valores para inspeção."
                                  ],
                                  "verification": "Estatística chi2 deve ser um valor positivo finito e valor crítico ≈3.84 para df=1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "SciPy.stats para chi-quadrado.",
                                  "tips": "Lembre-se: teste usa 1 grau de liberdade pois há uma restrição (ones + zeros = n).",
                                  "learningObjective": "Aplicar fórmula chi-quadrado para teste de frequência binária.",
                                  "commonMistakes": "Erro na fórmula (não usar df=1) ou proporções invertidas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar comparação, interpretação e validação",
                                  "subSteps": [
                                    "Comparar: se chi2_stat < chi2_crit, sequência passa no teste.",
                                    "Adicionar lógica condicional: print('Passa' if chi2_stat < chi2_crit else 'Falha').",
                                    "Testar com múltiplas sementes ou tamanhos n para robustez.",
                                    "Criar função reutilizável: def frequency_test(seq): ... retornando pass/fail e stats.",
                                    "Documentar código com comentários explicando cada parte."
                                  ],
                                  "verification": "Executar função em sequência conhecida boa/ruim e confirmar resultados esperados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código anterior; tabela chi-quadrado online para referência manual.",
                                  "tips": "Teste com n pequeno primeiro para depuração rápida.",
                                  "learningObjective": "Interpretar resultados e estruturar código modular.",
                                  "commonMistakes": "Ignorar nível de significância (use 0.05 padrão) ou não tratar edge cases como n par."
                                }
                              ],
                              "practicalExample": "Gere 10.000 números uniformes com semente 42 em Python. Converta para binário: obterá ≈4994 zeros e 5006 ones. Chi2_stat ≈ 0.000288 < 3.841, passando o teste a 95%. Código completo: import numpy as np; from scipy import stats; ...",
                              "finalVerifications": [
                                "Código executa sem erros para n=10.000.",
                                "Proporções de 0s/1s estão próximas de 50%.",
                                "Estatística chi2 < valor crítico para sequências boas.",
                                "Função retorna 'Passa/Falha' corretamente.",
                                "Resultados reproduzíveis com semente fixa.",
                                "Teste falha intencionalmente (ex: sequência constante)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da fórmula chi-quadrado (erro <0.01).",
                                "Eficiência: tempo de execução <1s para n=10k.",
                                "Modularidade: código em funções claras.",
                                "Comentários e visualizações incluídas.",
                                "Tratamento de casos extremos (n<100).",
                                "Comparação correta com df=1."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuição chi-quadrado e testes de hipóteses.",
                                "Programação: Vetorização NumPy e funções modulares.",
                                "Engenharia Civil: Validação de geradores em simulações Monte Carlo para análise estrutural.",
                                "Matemática: Teoria de probabilidade e aleatoriedade."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para previsão de falhas em estruturas civis (ex: cargas sísmicas), validar geradores pseudo-aleatórios garante confiabilidade dos resultados probabilísticos, evitando vieses em análises de risco."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.1",
                              "10.1.7.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.3",
                            "name": "Avaliar falhas no teste de frequência",
                            "description": "Diagnosticar causas comuns de reprovação, como bias no gerador linear congruente, e propor ajustes nos parâmetros do gerador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Interpretar os Resultados do Teste de Frequência",
                                  "subSteps": [
                                    "Executar o teste de frequência (Monobit) em uma sequência gerada, contando o número de 1s (S) em n bits.",
                                    "Calcular a estatística de teste: S_obs = 2 * (número de 1s) / n.",
                                    "Comparar S_obs com os limites críticos baseados na distribuição normal padrão: ±1.96 para nível de confiança de 95%.",
                                    "Identificar falha se S_obs estiver fora dos limites (ex.: muito próximo de 0 ou 2, indicando bias).",
                                    "Registrar o valor exato de S_obs e o p-valor, se disponível."
                                  ],
                                  "verification": "Confirme que o resultado está documentado com S_obs fora dos limites e uma interpretação clara da falha (ex.: 'Bias para 0s detectado').",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Sequência de bits gerados por LCG",
                                    "Planilha ou código Python/R para cálculo do teste",
                                    "Tabela de valores críticos chi-quadrado ou normal"
                                  ],
                                  "tips": "Sempre use n ≥ 10000 para testes confiáveis; visualize a distribuição de 0s/1s em um histograma para intuição.",
                                  "learningObjective": "Interpretar corretamente os resultados do teste de frequência e detectar falhas de aleatoriedade básica.",
                                  "commonMistakes": [
                                    "Confundir contagem de 1s com 0s",
                                    "Usar n muito pequeno levando a falsos positivos",
                                    "Ignorar o nível de significância (ex.: usar 1.96 para 99%)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Causas Comuns de Falha no Teste de Frequência",
                                  "subSteps": [
                                    "Examinar propriedades do gerador LCG: X_{i+1} = (a * X_i + c) mod m.",
                                    "Verificar período do LCG: Deve ser m para full period (m potência de 2, c ímpar, a ≡ 1 mod 4, etc.).",
                                    "Simular distribuições parciais de bits: Converter para binário e contar 0s/1s no LSB (Least Significant Bit).",
                                    "Identificar bias: Ex.: se m par e a/c pares, LSB tende a 0.",
                                    "Comparar com causas não-LCG: Ruído insuficiente ou truncamento inadequado."
                                  ],
                                  "verification": "Liste pelo menos 3 causas potenciais específicas ao LCG com evidências da sequência (ex.: '60% de 0s no LSB devido a m par').",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código fonte do LCG",
                                    "Ferramenta de análise de bits (Python com numpy/bitarray)",
                                    "Referência: Knuth Vol.2 ou NIST SP 800-22"
                                  ],
                                  "tips": "Foquem no LSB para Monobit; teste múltiplos seeds para confirmar bias sistemático.",
                                  "learningObjective": "Diagnosticar causas raiz de bias em geradores pseudo-aleatórios lineares congruentes.",
                                  "commonMistakes": [
                                    "Atribuir falha a 'azar' em vez de parâmetros",
                                    "Não verificar condições de full period de Hull-Dobell",
                                    "Confundir LCG com outros geradores como Mersenne Twister"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Propor Ajustes nos Parâmetros do Gerador LCG",
                                  "subSteps": [
                                    "Selecionar novos parâmetros ótimos: m=2^31-1 (Mersenne prime), a=48271, c=0 (multiplicativo).",
                                    "Verificar condições: gcd(c,m)=1, a-1 divisível por todos fatores primos de m, etc.",
                                    "Gerar nova sequência com parâmetros ajustados e tamanho equivalente.",
                                    "Executar teste de frequência na nova sequência.",
                                    "Documentar mudanças e impacto esperado (ex.: balanceamento 50/50)."
                                  ],
                                  "verification": "Forneça conjunto de parâmetros novos com justificativa e prévia do resultado esperado (S_obs dentro de limites).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de parâmetros LCG testados (ex.: Park-Miller)",
                                    "Implementação editável do LCG em Python/MATLAB"
                                  ],
                                  "tips": "Use bibliotecas como numpy.random para benchmark; evite c=0 se m não primo.",
                                  "learningObjective": "Selecionar e justificar parâmetros LCG que passem no teste de frequência.",
                                  "commonMistakes": [
                                    "Escolher a=1 (degenera para constante)",
                                    "Não normalizar para [0,1] após mod m",
                                    "Ignorar overflow em linguagens sem bigints"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Ajustes e Documentar o Processo",
                                  "subSteps": [
                                    "Rodar teste de frequência na sequência ajustada e confirmar aprovação.",
                                    "Executar testes adicionais (ex.: runs test) para robustez.",
                                    "Comparar métricas antes/depois em tabela.",
                                    "Escrever relatório: Causa, ajuste, evidência de correção.",
                                    "Testar sensibilidade variando seed."
                                  ],
                                  "verification": "Relatório completo mostra falha resolvida (S_obs dentro ±1.96) e pelo menos um teste extra aprovado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código de testes NIST-like",
                                    "Ferramenta de relatório (Jupyter notebook ou LaTeX)"
                                  ],
                                  "tips": "Automatize com script para múltiplas iterações; salve seeds para reprodutibilidade.",
                                  "learningObjective": "Validar correções e comunicar diagnósticos de forma profissional.",
                                  "commonMistakes": [
                                    "Não testar múltiplas seeds",
                                    "Aceitar S_obs borderline sem p-valor",
                                    "Omitir comparação quantitativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando LCG ruim (a=5, c=1, m=100): gera sequência binária LSB com 65% de 0s (S_obs=1.3 >1.96, falha). Diagnóstico: m par causa bias LSB. Ajuste para a=1664525, c=1013904223, m=2^32: nova S_obs=1.02 (passa). Aplicado em simulação Monte Carlo de carga em ponte.",
                              "finalVerifications": [
                                "Calcula corretamente S_obs e identifica falha com limites apropriados.",
                                "Lista causas LCG específicas com evidências da sequência.",
                                "Propõe parâmetros válidos que restauram balanceamento.",
                                "Valida com testes antes/depois e relatório claro.",
                                "Explica impacto em aplicações Monte Carlo.",
                                "Identifica erros comuns em parâmetros propostos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo e interpretação do teste Monobit (90%+ correto).",
                                "Profundidade no diagnóstico de bias LCG (cobre Hull-Dobell).",
                                "Qualidade dos ajustes propostos (passam teste em simulação).",
                                "Completude da validação e documentação.",
                                "Criatividade em conexões reais (ex.: engenharia civil).",
                                "Tempo de execução dentro do estimado com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuição binomial e testes de hipóteses.",
                                "Programação: Implementação e depuração de algoritmos numéricos.",
                                "Engenharia Civil: Simulações Monte Carlo para análise de risco estrutural.",
                                "Matemática Discreta: Teoria dos números e períodos de recorrência.",
                                "Qualidade de Software: Testes unitários para geradores aleatórios."
                              ],
                              "realWorldApplication": "Em análises Monte Carlo para dimensionamento de estruturas civis sob cargas aleatórias (ex.: vento sísmico), geradores biased levam a subestimação de riscos; diagnóstico garante simulações confiáveis para projetos seguros e econômicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.3",
                        "name": "Teste Qui-Quadrado de Aderência",
                        "description": "Teste estatístico para verificar se a distribuição empírica de números pseudo-aleatórios segue uma uniforme [0,1], dividindo em k intervalos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.3.1",
                            "name": "Definir intervalos e calcular frequências observadas",
                            "description": "Dividir o intervalo [0,1] em k bins iguais, contar a frequência Oi em cada bin para N números gerados e calcular a frequência esperada Ei = N/k.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar o número de bins k e definir os intervalos",
                                  "subSteps": [
                                    "Determine o valor de k com base em N (ex: k ≈ √N ou k=10 para N=1000, garantindo Ei ≥ 5)",
                                    "Calcule a largura de cada bin: largura = 1/k",
                                    "Defina os k intervalos: [0, 1/k), [1/k, 2/k), ..., [(k-1)/k, 1]",
                                    "Liste os limites inferior e superior para cada bin em uma tabela",
                                    "Verifique se os intervalos cobrem exatamente [0,1] sem sobreposição"
                                  ],
                                  "verification": "Confira se os intervalos são contíguos, cobrem [0,1] e o último inclui 1",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, planilha (Excel/Google Sheets) ou editor de texto",
                                  "tips": "Arredonde k para inteiro e priorize bins com largura igual para uniformidade",
                                  "learningObjective": "Compreender a discretização uniforme do intervalo [0,1] para testes de aderência",
                                  "commonMistakes": "Esquecer de incluir o limite superior 1 no último bin ou fazer intervalos de largura desigual"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contar as frequências observadas Oi para cada bin",
                                  "subSteps": [
                                    "Liste os N números aleatórios gerados no intervalo [0,1]",
                                    "Para cada número, identifique o bin correspondente comparando com os limites",
                                    "Crie uma tabela com colunas: bin, intervalo, Oi (inicialize Oi=0 para cada bin)",
                                    "Incremente Oi para o bin de cada número (use contagem manual ou fórmula em planilha)",
                                    "Some todos os Oi e confirme que soma = N"
                                  ],
                                  "verification": "Soma das Oi deve igualar exatamente N; cada Oi ≥ 0",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Lista dos N números aleatórios, planilha ou software (Python/R para automação)",
                                  "tips": "Ordene os números aleatórios primeiro para facilitar a contagem manual",
                                  "learningObjective": "Dominar a classificação de dados em bins e contagem de frequências empíricas",
                                  "commonMistakes": "Atribuir número 1.0 incorretamente (deve ir para o último bin) ou erros de arredondamento em comparações"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as frequências esperadas Ei para cada bin",
                                  "subSteps": [
                                    "Calcule Ei = N / k para todos os bins (distribuição uniforme implica Ei igual)",
                                    "Adicione a coluna Ei na tabela ao lado de Oi",
                                    "Verifique se todos Ei são iguais e soma dos Ei = N",
                                    "Registre Ei com precisão decimal se N/k não for inteiro",
                                    "Compare Oi e Ei visualmente para intuitar aderência"
                                  ],
                                  "verification": "Todos Ei = N/k exatos; soma Ei = N",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou planilha para divisão precisa",
                                  "tips": "Use fórmula =N/k em todas as células da coluna Ei para eficiência",
                                  "learningObjective": "Entender o modelo teórico de frequência uniforme sob hipótese nula",
                                  "commonMistakes": "Variar Ei por bin (todos devem ser iguais) ou erro aritmético em N/k"
                                }
                              ],
                              "practicalExample": "Para N=100 números aleatórios em [0,1] e k=10, intervalos: [0,0.1), [0.1,0.2), ..., [0.9,1]. Suponha contagens Oi: 8,12,9,11,10,9,12,10,11,8. Então Ei=100/10=10 para cada bin. Tabela: Bin 1 [0,0.1): Oi=8, Ei=10; etc.",
                              "finalVerifications": [
                                "Intervalos cobrem [0,1] sem lacunas ou sobreposições",
                                "Soma de todas Oi = N exatamente",
                                "Todos Ei = N/k e soma Ei = N",
                                "Nenhum Oi ou Ei negativo ou inválido",
                                "Tabela organizada com bins, Oi e Ei claros",
                                "k escolhido adequadamente (Ei ≥5 idealmente)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de intervalos (limites corretos e uniformes)",
                                "Exatidão na contagem de Oi (soma = N, classificações corretas)",
                                "Cálculo correto e uniforme de Ei",
                                "Organização clara da tabela de frequências",
                                "Escolha razoável de k com justificativa",
                                "Ausência de erros aritméticos ou lógicos"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Base para estatística qui-quadrada e testes de hipóteses",
                                "Programação: Implementação via loops e condicionais em Python/R",
                                "Probabilidade: Modelo uniforme contínuo e discretização",
                                "Engenharia Computacional: Pré-processamento para simulações Monte Carlo"
                              ],
                              "realWorldApplication": "Em engenharia civil, usado em testes de aleatoriedade para geradores de números em simulações Monte Carlo de cargas de vento, tráfego ou falhas estruturais, validando uniformidade antes de análises qui-quadradas para confiabilidade de modelos preditivos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.2",
                            "name": "Computar a estatística qui-quadrado",
                            "description": "Aplicar a fórmula X^2 = Σ (Oi - Ei)^2 / Ei para i=1 a k, e comparar com o valor crítico da distribuição qui-quadrado com k-1 graus de liberdade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e organizar frequências observadas (Oi)",
                                  "subSteps": [
                                    "Realize o experimento ou obtenha os dados observados de uma amostra (ex: lançamentos de um dado).",
                                    "Conte a frequência absoluta de cada categoria ou intervalo (Oi para i=1 a k).",
                                    "Registre os valores em uma tabela organizada com colunas para categoria, Oi e total de observações (n).",
                                    "Verifique se a soma de todos Oi equals n.",
                                    "Garanta que k (número de categorias) seja definido claramente."
                                  ],
                                  "verification": "Tabela completa com Oi somando exatamente n, sem erros de contagem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Dados experimentais ou simulados",
                                    "Planilha Excel ou papel e caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Use uma tabela para visualização clara; agrupe categorias raras se necessário para Ei > 5.",
                                  "learningObjective": "Identificar e registrar corretamente as frequências observadas de uma distribuição empírica.",
                                  "commonMistakes": [
                                    "Confundir Oi com probabilidades",
                                    "Erros de soma no total n",
                                    "Ignorar categorias vazias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular frequências esperadas (Ei)",
                                  "subSteps": [
                                    "Defina a hipótese nula (H0) e as probabilidades teóricas pi para cada categoria i.",
                                    "Calcule Ei = n * pi para cada i=1 a k.",
                                    "Registre Ei na tabela ao lado de Oi.",
                                    "Verifique se soma de Ei equals n e se todos Ei >= 5 (ajuste k se necessário).",
                                    "Ajuste categorias se Ei < 5 em mais de 20% dos casos."
                                  ],
                                  "verification": "Todos Ei calculados corretamente e somam n; nenhum Ei < 5 sem justificativa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de Oi do passo anterior",
                                    "Tabela de probabilidades teóricas (ex: uniforme 1/6 para dado)",
                                    "Calculadora"
                                  ],
                                  "tips": "Para distribuição uniforme, pi = 1/k; consulte tabelas para outras distribuições.",
                                  "learningObjective": "Aplicar probabilidades teóricas para computar frequências esperadas sob H0.",
                                  "commonMistakes": [
                                    "Usar probabilidades erradas para H0",
                                    "Esquecer de multiplicar por n",
                                    "Ei somando diferente de n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar contribuições individuais (Oi - Ei)^2 / Ei",
                                  "subSteps": [
                                    "Para cada i, calcule diferença di = Oi - Ei.",
                                    "Eleve ao quadrado: di^2.",
                                    "Divida por Ei: ci = di^2 / Ei.",
                                    "Registre ci na tabela.",
                                    "Verifique cálculos intermediários para precisão decimal."
                                  ],
                                  "verification": "Todos ci calculados com no máximo 2 casas decimais de erro; tabela atualizada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela com Oi e Ei",
                                    "Calculadora ou Excel para potências e divisões"
                                  ],
                                  "tips": "Use funções do Excel como =((A2-B2)^2)/B2 para automação.",
                                  "learningObjective": "Executar os cálculos componentes da fórmula qui-quadrado com precisão.",
                                  "commonMistakes": [
                                    "Dividir por Oi em vez de Ei",
                                    "Esquecer o quadrado da diferença",
                                    "Erros de sinal na diferença"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Somar para obter estatística X^2 e determinar graus de liberdade",
                                  "subSteps": [
                                    "Some todos ci: X^2 = Σ ci para i=1 a k.",
                                    "Calcule graus de liberdade gl = k - 1 - m (m=parâmetros estimados; geralmente m=0 para qui-quadrado de aderência simples).",
                                    "Registre X^2 e gl.",
                                    "Verifique se soma de ci matches X^2 manualmente.",
                                    "Confirme gl = k-1 para teste de aderência básica."
                                  ],
                                  "verification": "X^2 calculado corretamente como soma exata dos ci; gl correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela completa com ci",
                                    "Calculadora para soma"
                                  ],
                                  "tips": "Arredonde X^2 para 2 casas decimais; gl sempre k-1 em testes de uniformidade simples.",
                                  "learningObjective": "Agreggar componentes em X^2 e definir graus de liberdade apropriados.",
                                  "commonMistakes": [
                                    "Soma incorreta dos ci",
                                    "gl errado (ex: esquecer subtrair 1)",
                                    "Arredondamento prematuro"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar X^2 com valor crítico e interpretar",
                                  "subSteps": [
                                    "Escolha nível de significância α (ex: 0.05).",
                                    "Consulte tabela qui-quadrado para valor crítico χ²_α,gl.",
                                    "Compare: se X^2 > χ²_α,gl rejeite H0; senão, não rejeite.",
                                    "Calcule p-valor se possível (usando software ou tabela).",
                                    "Escreva conclusão em termos de aleatoriedade ou aderência."
                                  ],
                                  "verification": "Decisão de rejeição/aceitação justificada com valor crítico; conclusão clara.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de distribuição qui-quadrado",
                                    "Software como R ou Excel para p-valor opcional"
                                  ],
                                  "tips": "Tabelas qui-quadrado disponíveis online; use funções como CHISQ.INV.RT em Excel.",
                                  "learningObjective": "Interpretar estatística qui-quadrado no contexto de testes de hipóteses.",
                                  "commonMistakes": [
                                    "Valor crítico para gl errado",
                                    "Inverter regra de decisão",
                                    "Ignorar α na interpretação"
                                  ]
                                }
                              ],
                              "practicalExample": "Teste se um dado de 6 faces é justo: 120 lançamentos, Oi = [18,22,19,21,20,20]. H0: uniforme pi=1/6, Ei=20 cada. Calcule X^2 ≈ 1.00, gl=5, χ²_0.05,5=11.07. X^2 < crítico → dado justo.",
                              "finalVerifications": [
                                "Tabela completa com Oi, Ei, ci, X^2 precisa.",
                                "gl calculado corretamente como k-1.",
                                "Valor crítico consultado e comparado adequadamente.",
                                "Conclusão escrita corretamente (rejeitar ou não H0).",
                                "Todos cálculos verificados sem erros aritméticos.",
                                "Interpretação contextualizada para teste de aleatoriedade."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de Ei e ci (erro <1%).",
                                "Correta identificação de gl e valor crítico.",
                                "Tabela organizada e completa.",
                                "Interpretação lógica da decisão estatística.",
                                "Uso adequado de materiais e avoidance de erros comuns.",
                                "Tempo respeitado e substeps executados integralmente."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: Fundamentos de testes de hipóteses.",
                                "Programação: Implementação em Python/R para automação (scipy.stats.chisquare).",
                                "Engenharia Civil: Testes de qualidade em materiais e simulações Monte Carlo.",
                                "Física: Análise de distribuições experimentais em medições.",
                                "Gestão de Projetos: Controle estatístico de processos (SPC)."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usado no teste qui-quadrado de aderência para validar geradores de números aleatórios em simulações Monte Carlo para análise de estruturas sob cargas incertas, garantindo aleatoriedade em modelagens probabilísticas de falhas ou tráfego."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.3",
                            "name": "Implementar e interpretar o teste qui-quadrado",
                            "description": "Programar o teste completo em software numérico, gerar relatório com p-valor usando função cdf do qui-quadrado e discutir implicações para aplicações em engenharia civil como simulações Monte Carlo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir hipóteses e preparar dados para o teste",
                                  "subSteps": [
                                    "Estabeleça H0: os dados seguem a distribuição uniforme esperada; H1: não seguem.",
                                    "Gere ou carregue uma amostra de números aleatórios (ex: 10.000 números uniformes).",
                                    "Defina o número de bins (ex: 10) baseado na regra k ≈ sqrt(n).",
                                    "Calcule frequências observadas dividindo os dados em bins.",
                                    "Calcule frequências esperadas: n/k para cada bin."
                                  ],
                                  "verification": "Verifique se frequências observadas e esperadas somam ao tamanho da amostra e se bins estão corretamente definidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com numpy e matplotlib instalados",
                                    "Jupyter Notebook ou IDE"
                                  ],
                                  "tips": "Use np.histogram para bins automáticos; evite bins vazios ajustando limites.",
                                  "learningObjective": "Compreender a formulação de hipóteses e preparação de dados para teste de aderência.",
                                  "commonMistakes": [
                                    "Definir bins incorretos levando a esperadas <5",
                                    "Ignorar normalização das frequências"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar cálculo da estatística qui-quadrado",
                                  "subSteps": [
                                    "Importe bibliotecas: import numpy as np; from scipy.stats import chisquare.",
                                    "Calcule qui-quadrado: soma((observadas - esperadas)^2 / esperadas).",
                                    "Implemente manualmente ou use chisquare(observadas, esperadas).",
                                    "Calcule graus de liberdade: k-1 (ou k-1-p para parâmetros estimados).",
                                    "Visualize histograma com bins para inspeção visual."
                                  ],
                                  "verification": "Estatística qui-quadrado é positiva e finita; plot do histograma mostra distribuição.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com scipy.stats",
                                    "Exemplo de dados gerados"
                                  ],
                                  "tips": "Sempre verifique esperadas >=5 por bin; agrupe se necessário.",
                                  "learningObjective": "Programar o cálculo preciso da estatística qui-quadrado.",
                                  "commonMistakes": [
                                    "Dividir por zero em esperadas zero",
                                    "Esquecer graus de liberdade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular p-valor usando função CDF do qui-quadrado",
                                  "subSteps": [
                                    "Importe from scipy.stats import chi2.",
                                    "Calcule p-valor: 1 - chi2.cdf(stat_chi2, df).",
                                    "Ou use diretamente chisquare.pvalue.",
                                    "Defina nível de significância α=0.05.",
                                    "Compare p-valor com α para decisão inicial."
                                  ],
                                  "verification": "p-valor entre 0 e 1; código reproduz resultado manual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Scipy.stats chi2",
                                    "Cálculo anterior de stat e df"
                                  ],
                                  "tips": "Use chi2.sf(stat, df) para 1-cdf diretamente.",
                                  "learningObjective": "Aplicar CDF para inferência estatística automatizada.",
                                  "commonMistakes": [
                                    "Confundir cdf com pdf",
                                    "Usar df incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e gerar relatório com implicações",
                                  "subSteps": [
                                    "Interprete: se p>α, aceitar H0 (aleatoriedade OK).",
                                    "Discuta limitações: tamanho amostra, independência.",
                                    "Relate: inclua stat, df, p-valor, decisão, plot.",
                                    "Conecte a Monte Carlo: validade para simulações em engenharia civil.",
                                    "Sugira melhorias: testes múltiplos ou tamanhos maiores."
                                  ],
                                  "verification": "Relatório escrito com todos elementos e conclusão clara.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Template de relatório Markdown ou Word",
                                    "Gráficos gerados"
                                  ],
                                  "tips": "Estruture relatório: intro, método, resultados, discussão.",
                                  "learningObjective": "Interpretar estatisticamente e comunicar achados.",
                                  "commonMistakes": [
                                    "Ignorar contexto prático",
                                    "Concluir sem discutir limitações"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere 10.000 números aleatórios uniformes com np.random.uniform(0,1,10000). Divida em 10 bins, aplique teste qui-quadrado. Esperado: p-valor >0.05 confirmando uniformidade para uso em Monte Carlo simulando cargas aleatórias em vigas de concreto.",
                              "finalVerifications": [
                                "Código completo executa sem erros e produz p-valor válido.",
                                "Relatório inclui stat qui-quadrado, df, p-valor e interpretação.",
                                "Histograma visual confirma aderência aproximada.",
                                "Discussão liga resultados a simulações Monte Carlo em engenharia.",
                                "Teste sensível a violações (ex: seed fixa passa, mas biased falha)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de qui-quadrado e p-valor (erro <1%).",
                                "Correta formulação de hipóteses e df.",
                                "Qualidade do relatório: claro, completo e contextualizado.",
                                "Uso apropriado de software e visualizações.",
                                "Análise de implicações práticas para engenharia civil.",
                                "Identificação de erros comuns e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: testes de hipóteses não-paramétricos.",
                                "Programação Computacional: uso de scipy para análise numérica.",
                                "Simulações Estocásticas: validação de RNG em Monte Carlo.",
                                "Engenharia Civil: análise de risco em estruturas sob cargas aleatórias.",
                                "Probabilidade: distribuições qui-quadrado e uniforme."
                              ],
                              "realWorldApplication": "Em engenharia civil, o teste qui-quadrado valida geradores de números aleatórios em simulações Monte Carlo para modelar incertezas em cargas sísmicas, durabilidade de materiais ou fluxo de tráfego em pontes, garantindo confiabilidade das previsões de falha estrutural."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.2",
                              "10.1.7.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.4",
                            "name": "Comparar com outros testes qui-quadrado variantes",
                            "description": "Adaptar o teste para distribuições não-uniformes ou sequências correlacionadas, referenciando baterias de testes como DIEHARD ou NIST.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Teste Qui-Quadrado de Aderência Básico",
                                  "subSteps": [
                                    "Relembrar a hipótese nula: a sequência segue distribuição uniforme.",
                                    "Calcular estatística qui-quadrado: somar (observado - esperado)^2 / esperado para bins.",
                                    "Determinar graus de liberdade e p-valor crítico.",
                                    "Implementar em código para uma sequência gerada.",
                                    "Interpretar resultados: rejeitar ou aceitar uniformidade."
                                  ],
                                  "verification": "Implementar e executar o teste em uma sequência aleatória simples, obtendo p-valor > 0.05 para uniformidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy e SciPy; gerador de números aleatórios (np.random).",
                                  "tips": "Use pelo menos 10 bins para estabilidade; normalize a sequência para [0,1].",
                                  "learningObjective": "Compreender a formulação exata do teste qui-quadrado padrão para uniformidade.",
                                  "commonMistakes": "Ignorar correção de continuidade ou usar poucos bins, levando a falsos positivos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Variantes do Teste Qui-Quadrado",
                                  "subSteps": [
                                    "Explorar teste qui-quadrado de independência para pares consecutivos.",
                                    "Analisar teste de homogeneidade para sub-sequências.",
                                    "Comparar com goodness-of-fit para distribuições não-uniformes pré-definidas.",
                                    "Implementar uma variante simples em código.",
                                    "Calcular diferenças na estatística e graus de liberdade."
                                  ],
                                  "verification": "Executar teste de independência em uma sequência e comparar com aderência básica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação SciPy.stats.chi2_contingency; Jupyter Notebook.",
                                  "tips": "Crie tabela de contingência 10x10 para pares (i,j) em bins.",
                                  "learningObjective": "Identificar e diferenciar variantes qui-quadrado como independência e homogeneidade.",
                                  "commonMistakes": "Confundir graus de liberdade: para independência é (k-1)^2, não k-1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender Adaptações para Não-Uniformes e Correlacionadas",
                                  "subSteps": [
                                    "Para não-uniformes: ajustar probabilidades esperadas baseadas na distribuição teórica.",
                                    "Para correlacionadas: usar lags ou testes seriais com qui-quadrado em resíduos.",
                                    "Implementar adaptação: transformar sequência para uniformidade via CDF inversa.",
                                    "Testar em sequência com correlação artificial (ex: AR(1)).",
                                    "Avaliar sensibilidade das adaptações."
                                  ],
                                  "verification": "Aplicar adaptação em sequência não-uniforme e obter p-valor coerente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "SciPy.stats; exemplos de distribuições (norm, exp).",
                                  "tips": "Use ppf (CDF inversa) para mapear; teste correlação com autocorrelation plot.",
                                  "learningObjective": "Adaptar qui-quadrado para cenários reais além da uniformidade perfeita.",
                                  "commonMistakes": "Não transformar corretamente, causando viés no p-valor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Baterias DIEHARD e NIST com Foco em Qui-Quadrado",
                                  "subSteps": [
                                    "Estudar DIEHARD: identificar testes qui-quadrado como Birthday Spacings.",
                                    "Explorar NIST STS: suite com qui-quadrado em Frequency, Runs, etc.",
                                    "Comparar implementação: parâmetros, bins e thresholds.",
                                    "Rodar um teste DIEHARD/NIST em sequência gerada.",
                                    "Documentar referências bibliográficas."
                                  ],
                                  "verification": "Executar pelo menos 2 testes de cada bateria e interpretar relatórios.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "NIST STS software; DIEHARDer (Marsaglia); documentação oficial.",
                                  "tips": "Baixe suites prontas; use sequências de 10^6 bits para precisão.",
                                  "learningObjective": "Referenciar baterias padrão e mapear qui-quadrado variantes nelas.",
                                  "commonMistakes": "Usar sequências curtas, invalidando resultados das baterias."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar e Contrastar Todos os Testes",
                                  "subSteps": [
                                    "Criar tabela comparativa: poder, sensibilidade, complexidade computacional.",
                                    "Testar sequências defeituosas em múltiplos testes.",
                                    "Discutir quando usar cada variante (ex: correlacionadas → independência).",
                                    "Avaliar trade-offs com DIEHARD/NIST.",
                                    "Redigir relatório de comparação."
                                  ],
                                  "verification": "Produzir tabela e relatório com exemplos numéricos de p-valores.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Excel ou Pandas para tabela; sequências teste pré-geradas.",
                                  "tips": "Inclua métricas como tamanho de amostra mínima por teste.",
                                  "learningObjective": "Sintetizar comparações para seleção informada de testes.",
                                  "commonMistakes": "Ignorar poder estatístico: qui-quadrado básico falha em correlações fracas."
                                }
                              ],
                              "practicalExample": "Gere 1 milhão de números aleatórios com np.random.uniform(). Aplique: (1) qui-quadrado básico (bins=100), (2) variante de independência em pares, (3) adaptação para normal via CDF, (4) NIST Frequency test. Compare p-valores; introduza correlação (x[i]=0.9*x[i-1]+0.1*rand) e re-teste, notando falha apenas em variantes sensíveis.",
                              "finalVerifications": [
                                "Explicar diferenças entre qui-quadrado de aderência, independência e homogeneidade.",
                                "Implementar adaptação para distribuição exponencial e validar p-valor.",
                                "Rodar DIEHARD/NIST e interpretar qui-quadrado neles.",
                                "Criar tabela comparativa com prós/contras.",
                                "Identificar quando variante é superior ao básico.",
                                "Aplicar em sequência correlacionada e discutir resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática de variantes ( graus de liberdade corretos).",
                                "Corretude de implementações em código (p-valores reproduzíveis).",
                                "Profundidade na análise de adaptações para não-uniformes/correlationadas.",
                                "Integração precisa de referências DIEHARD/NIST.",
                                "Clareza na tabela comparativa e trade-offs.",
                                "Capacidade de interpretar falhas em testes reais."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: hipóteses e poder de testes.",
                                "Programação Computacional: implementação em Python/SciPy.",
                                "Simulações Monte Carlo: validação de RNGs em engenharia.",
                                "Análise de Dados: baterias NIST para criptografia.",
                                "Engenharia Civil: testes em modelagens estocásticas."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para análise de estruturas civis sob cargas aleatórias (ex: vento, sismos), testar RNGs com qui-quadrado variantes garante distribuições confiáveis; adaptações detectam correlações em dados reais de sensores, evitando erros em previsões de falhas, conforme baterias NIST usadas em softwares como ANSYS ou MATLAB para validação."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Fundamentos do Método de Monte Carlo",
                    "description": "Princípios de simulação estocástica usando amostragens aleatórias para aproximar soluções numéricas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Simulação Estocástica",
                        "description": "Princípios fundamentais da simulação estocástica, que utiliza amostragens aleatórias para modelar sistemas com incertezas, aproximando soluções numéricas de problemas complexos em engenharia civil, como análise de estruturas sob cargas variáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Diferenciar simulação determinística e estocástica",
                            "description": "Compreender as diferenças entre métodos determinísticos, que produzem resultados fixos para entradas iguais, e estocásticos, que incorporam aleatoriedade para capturar variabilidade real, com exemplos de problemas de valor inicial e de contorno em engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da simulação determinística",
                                  "subSteps": [
                                    "Defina simulação determinística como um processo computacional onde a mesma entrada sempre produz o mesmo resultado de saída.",
                                    "Identifique características principais: equações fixas, ausência de aleatoriedade e previsibilidade total.",
                                    "Analise um exemplo simples: resolução de equação diferencial para deformação de uma viga sob carga constante.",
                                    "Discuta problemas de valor inicial (ex.: evolução temporal de uma estrutura) resolvidos deterministicamente.",
                                    "Registre as vantagens, como reprodutibilidade e eficiência computacional."
                                  ],
                                  "verification": "Explique em suas palavras o que é simulação determinística e forneça um exemplo resolvido manualmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Software MATLAB ou Python (opcional)",
                                    "Texto sobre equações diferenciais"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar o processo determinístico e destacar a ausência de ramificações aleatórias.",
                                  "learningObjective": "Ao final deste passo, o aluno definirá e exemplificará simulação determinística com precisão.",
                                  "commonMistakes": [
                                    "Confundir com métodos numéricos iterativos que convergem aleatoriamente",
                                    "Ignorar que determinístico não modela incertezas reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender os fundamentos da simulação estocástica",
                                  "subSteps": [
                                    "Defina simulação estocástica como um método que incorpora variáveis aleatórias para simular variabilidade real.",
                                    "Explique o papel da geração de números pseudoaleatórios e métodos como Monte Carlo.",
                                    "Identifique características: resultados variáveis para mesmas entradas, captura de incertezas e distribuições probabilísticas.",
                                    "Analise um exemplo: simulação de carga de vento variável em uma estrutura usando Monte Carlo.",
                                    "Discuta problemas de contorno (ex.: distribuição de tensões em barragens com solos heterogêneos)."
                                  ],
                                  "verification": "Gere uma sequência simples de números aleatórios e descreva como ela afeta o resultado de uma simulação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python com biblioteca random",
                                    "Gerador de números aleatórios online",
                                    "Artigo sobre Método de Monte Carlo"
                                  ],
                                  "tips": "Sempre normalize as variáveis aleatórias para que representem distribuições reais, como normal ou uniforme.",
                                  "learningObjective": "Ao final deste passo, o aluno explicará como a aleatoriedade captura variabilidade em simulações.",
                                  "commonMistakes": [
                                    "Achar que estocástico é 'errado' por ser imprevisível",
                                    "Não distinguir pseudoaleatoriedade de aleatoriedade verdadeira"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e comparar as diferenças entre simulações determinística e estocástica",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: entradas/saídas, aleatoriedade, aplicações e limitações.",
                                    "Discuta quando usar cada uma: determinística para cenários ideais, estocástica para riscos e variabilidades.",
                                    "Analise trade-offs: precisão vs custo computacional.",
                                    "Exemplifique em engenharia civil: análise estática determinística vs dinâmica estocástica de terremotos.",
                                    "Realize uma simulação paralela simples para visualizar diferenças."
                                  ],
                                  "verification": "Preencha uma tabela comparativa e justifique a escolha de método para dois cenários hipotéticos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Python com NumPy para simulações rápidas"
                                  ],
                                  "tips": "Foquem em métricas como média, variância e intervalo de confiança para quantificar diferenças.",
                                  "learningObjective": "Ao final deste passo, o aluno comparará criticamente os dois tipos de simulação.",
                                  "commonMistakes": [
                                    "Superestimar determinística em cenários incertos",
                                    "Subestimar o número de iterações necessárias em estocástica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar as diferenças a problemas reais de engenharia civil",
                                  "subSteps": [
                                    "Selecione um problema de valor inicial: fluxo em tubulação determinístico vs com rugosidade estocástica.",
                                    "Selecione um problema de contorno: tensão em fundação determinística vs com cargas sísmicas aleatórias.",
                                    "Implemente uma simulação híbrida simples para demonstrar transição.",
                                    "Avalie resultados: determinístico dá valor único, estocástico dá distribuição.",
                                    "Conclua com critérios de escolha baseados em normas de engenharia (ex.: Eurocode)."
                                  ],
                                  "verification": "Desenvolva e execute um exemplo numérico comparativo, documentando resultados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software ANSYS ou similar (demo)",
                                    "Python com SciPy",
                                    "Normas ABNT NBR para estruturas"
                                  ],
                                  "tips": "Comece com poucos trials (100) em estocástica para protótipo antes de escalar.",
                                  "learningObjective": "Ao final deste passo, o aluno aplicará os conceitos a contextos profissionais de engenharia civil.",
                                  "commonMistakes": [
                                    "Não validar distribuições de entrada",
                                    "Ignorar convergência em simulações estocásticas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma ponte pênsil, simulação determinística calcula deslocamento máximo sob carga nominal fixa (ex.: 100kN), resultando em 2.5m. Simulação estocástica usa Monte Carlo com vento variável (distribuição Weibull), gerando distribuição de deslocamentos (média 2.6m, desvio 0.4m), permitindo calcular probabilidade de falha >3m.",
                              "finalVerifications": [
                                "Defina corretamente determinística e estocástica com exemplos.",
                                "Compare em tabela as diferenças chave.",
                                "Explique aplicação em problema de valor inicial e contorno.",
                                "Justifique escolha de método para cenário de risco em engenharia.",
                                "Gere e interprete resultados de uma simulação estocástica simples.",
                                "Identifique limitações de cada abordagem."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas: 30%)",
                                "Qualidade da comparação (tabela clara e completa: 25%)",
                                "Relevância de exemplos em engenharia civil (20%)",
                                "Correta interpretação de resultados estocásticos (15%)",
                                "Capacidade de aplicação prática (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística (distribuições e inferência)",
                                "Programação Computacional (implementação em Python/MATLAB)",
                                "Análise Numérica (métodos de solução de EDOs)",
                                "Gestão de Riscos (análise probabilística em projetos)"
                              ],
                              "realWorldApplication": "Na análise de barragens, simulações determinísticas projetam tensões médias sob carga hidrostática fixa, enquanto estocásticas incorporam variabilidade de infiltração e sismos, calculando risco de ruptura (ex.: probabilidade <1% em 50 anos, conforme normas de segurança)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Identificar aplicações da simulação estocástica",
                            "description": "Reconhecer usos em problemas de engenharia civil, como simulação de propagação de fissuras ou análise de riscos em barragens, baseando-se em princípios de simulação numérica descritos em Chapra e Canale (2002).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Simulação Estocástica",
                                  "subSteps": [
                                    "Ler seções relevantes sobre simulação estocástica no livro de Chapra e Canale (2002), focando em definições e princípios básicos.",
                                    "Identificar componentes chave: geração de números aleatórios, Monte Carlo e modelagem de variáveis aleatórias.",
                                    "Anotar exemplos genéricos de simulação estocástica em contextos numéricos.",
                                    "Comparar simulação estocástica com métodos determinísticos.",
                                    "Resumir em um diagrama mental os fluxos de simulação estocástica."
                                  ],
                                  "verification": "Criar um resumo de 1 página com definições e componentes chave, sem erros conceituais.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Numerical Methods for Engineers' de Chapra e Canale (2002), caderno de anotações, software de diagramação como Draw.io.",
                                  "tips": "Use destaques no livro para referências rápidas futuras.",
                                  "learningObjective": "Compreender os princípios fundamentais da simulação estocástica como base para aplicações práticas.",
                                  "commonMistakes": "Confundir simulação estocástica com otimização determinística; ignorar a aleatoriedade inerente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Princípios de Simulação Numérica em Engenharia",
                                  "subSteps": [
                                    "Explorar capítulos de Chapra e Canale sobre simulação numérica, enfatizando aplicações em engenharia.",
                                    "Analisar equações para propagação de incertezas e métodos de Monte Carlo.",
                                    "Identificar como variáveis aleatórias modelam fenômenos reais como cargas variáveis ou materiais heterogêneos.",
                                    "Resolver um exercício simples de simulação numérica do livro.",
                                    "Discutir limitações da simulação numérica em problemas estocásticos."
                                  ],
                                  "verification": "Resolver e documentar pelo menos um exercício do livro com resultados corretos.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Livro de Chapra e Canale (2002), calculadora ou MATLAB/Python para exercícios, folhas de cálculo.",
                                  "tips": "Implemente exercícios em código para visualização gráfica de distribuições.",
                                  "learningObjective": "Dominar os princípios numéricos que suportam simulações estocásticas em engenharia.",
                                  "commonMistakes": "Subestimar o número de iterações necessárias para convergência; ignorar validação estatística."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Problemas de Engenharia Civil com Incerteza",
                                  "subSteps": [
                                    "Listar problemas comuns em engenharia civil: propagação de fissuras, análise de riscos em barragens, cargas sísmicas variáveis.",
                                    "Classificar cada problema quanto ao tipo de incerteza (aleatória, epistemológica).",
                                    "Pesquisar casos reais de falhas estruturais devido a incertezas não modeladas.",
                                    "Mapear como simulação estocástica pode quantificar riscos nesses cenários.",
                                    "Criar uma tabela comparativa de problemas e métodos de simulação adequados."
                                  ],
                                  "verification": "Produzir uma tabela com 5 problemas civis, classificações de incerteza e potenciais simulações.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Artigos acadêmicos sobre engenharia civil, internet para casos reais, planilha Excel/Google Sheets.",
                                  "tips": "Busque estudos de caso em bases como ASCE ou ScienceDirect para exemplos autênticos.",
                                  "learningObjective": "Reconhecer incertezas inerentes a problemas civis e sua modelagem estocástica.",
                                  "commonMistakes": "Focar apenas em problemas determinísticos; superestimar precisão de modelos simplificados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Descrever Aplicações Específicas",
                                  "subSteps": [
                                    "Desenvolver exemplos detalhados: simulação de propagação de fissuras usando distribuições de Weibull para resistência.",
                                    "Simular análise de riscos em barragens com Monte Carlo para inundações extremas.",
                                    "Escrever descrições claras ligando princípios de Chapra a esses casos.",
                                    "Avaliar benefícios: probabilidade de falha, intervalos de confiança.",
                                    "Preparar um relatório com 3 aplicações identificadas."
                                  ],
                                  "verification": "Relatório final com 3 aplicações descritas, incluindo fluxogramas e justificativas.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software de simulação como MATLAB ou Python (com NumPy/SciPy), livro de referência.",
                                  "tips": "Use plots de histogramas para ilustrar resultados estocásticos.",
                                  "learningObjective": "Aplicar conceitos para identificar usos concretos da simulação estocástica em engenharia civil.",
                                  "commonMistakes": "Descrever aplicações vagamente sem ligar a princípios numéricos; omitir validação."
                                }
                              ],
                              "practicalExample": "Em uma barragem de concreto, simule a propagação de fissuras devido a cargas variáveis (modeladas por distribuição normal) usando Monte Carlo: gere 10.000 cenários aleatórios de tensão, compute probabilidades de falha > 5 MPa, e obtenha intervalo de confiança de 95% para risco de colapso.",
                              "finalVerifications": [
                                "Listar pelo menos 3 aplicações específicas em engenharia civil com justificativas baseadas em Chapra e Canale.",
                                "Explicar como simulação estocástica difere de análises determinísticas em contextos de risco.",
                                "Produzir um fluxograma de uma simulação para propagação de fissuras.",
                                "Calcular manualmente probabilidade simples de falha em um cenário de barragem.",
                                "Identificar limitações da simulação em problemas civis reais.",
                                "Conectar aplicações a normas como Eurocode para análise probabilística."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção entre estocástico e determinístico (30%).",
                                "Profundidade de exemplos: Aplicações civis detalhadas e realistas (25%).",
                                "Referenciação: Uso correto de Chapra e Canale com citações (20%).",
                                "Clareza e estrutura: Relatório lógico com diagramas (15%).",
                                "Criatividade: Conexões interdisciplinares identificadas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Distribuições para modelar incertezas.",
                                "Programação Computacional: Implementação em Python/MATLAB para Monte Carlo.",
                                "Mecânica dos Materiais: Modelagem de fissuras e tensões variáveis.",
                                "Gestão de Riscos: Análise probabilística em projetos de infraestrutura."
                              ],
                              "realWorldApplication": "Na manutenção de barragens como a de Itaipu, simulações estocásticas avaliam riscos de ruptura por sobrecarga hídrica, permitindo decisões informadas sobre reforços estruturais e redução de probabilidades de falha catastrófica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.3",
                            "name": "Explicar o papel da aleatoriedade na aproximação numérica",
                            "description": "Descrever como a aleatoriedade permite aproximar soluções de equações não-lineares e integrais complexas, contrastando com métodos exatos como resíduos ponderados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender métodos determinísticos exatos e suas limitações",
                                  "subSteps": [
                                    "Revise conceitos de métodos numéricos exatos, como eliminação gaussiana ou integração numérica trapezoidal.",
                                    "Identifique limitações para equações não-lineares (ex.: ausência de solução fechada) e integrais complexas (ex.: domínios irregulares).",
                                    "Analise exemplos de falhas, como divergência em problemas altamente não-lineares.",
                                    "Estude o método de resíduos ponderados (ex.: método de Galerkin) e suas restrições computacionais.",
                                    "Discuta trade-offs: precisão vs. custo computacional."
                                  ],
                                  "verification": "Resuma em um parágrafo as limitações de métodos exatos para problemas não-lineares e integrais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de métodos numéricos (ex.: Burden & Faires), slides sobre resíduos ponderados, calculadora científica."
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar quando métodos exatos falham.",
                                  "learningObjective": "Diferenciar métodos determinísticos exatos de aproximados e listar 3 limitações principais.",
                                  "commonMistakes": "Confundir métodos exatos com iterativos (ex.: Newton-Raphson é aproximado, não exato)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de aleatoriedade em métodos numéricos",
                                  "subSteps": [
                                    "Defina aleatoriedade como amostragem de distribuições probabilísticas para estimar valores esperados.",
                                    "Explique a Lei dos Grandes Números: média de amostras independentes converge para o valor esperado.",
                                    "Discuta Teorema do Limite Central para distribuição normal das médias amostrais.",
                                    "Compare com métodos determinísticos: aleatoriedade sacrifica exatidão por viabilidade computacional.",
                                    "Implemente geração simples de números aleatórios uniformes em Python ou Excel."
                                  ],
                                  "verification": "Gere 1000 números aleatórios e calcule a média; verifique convergência para 0.5 (uniforme [0,1]).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy, ou Excel; gerador de RNG online."
                                  ],
                                  "tips": "Visualize histogramas para observar convergência.",
                                  "learningObjective": "Explicar como a aleatoriedade usa probabilidade para aproximações estatísticas confiáveis.",
                                  "commonMistakes": "Ignorar dependência entre amostras, levando a viés."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar aplicação da aleatoriedade em aproximações de integrais e equações não-lineares",
                                  "subSteps": [
                                    "Para integrais: descreva Monte Carlo como I ≈ (b-a)/N * Σ f(X_i), onde X_i ~ Uniform(a,b).",
                                    "Para equações não-lineares: use rejeição ou importância sampling para resolver integrais implícitas.",
                                    "Simule um exemplo: aproxime ∫ sin(x)/x dx de 0 a π usando Monte Carlo.",
                                    "Aumente N e observe redução do erro padrão (√(Var(f)/N)).",
                                    "Contrastar variância com métodos determinísticos como Simpson."
                                  ],
                                  "verification": "Calcule integral de Monte Carlo com N=10^4 e compare erro com valor exato.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para Monte Carlo, tabela de integrais conhecidas."
                                  ],
                                  "tips": "Use variance reduction (ex.: antithetic variates) para eficiência.",
                                  "learningObjective": "Demonstrar como amostras aleatórias aproximam soluções intratáveis analiticamente.",
                                  "commonMistakes": "Escolha inadequada de distribuição, causando alta variância."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar aleatoriedade com métodos exatos como resíduos ponderados",
                                  "subSteps": [
                                    "Revise resíduos ponderados: minimizar ∫ w(x) R(u(x)) dx = 0 para aproximações fracas.",
                                    "Compare: determinístico (grade fixa) vs. estocástico (amostras aleatórias nos pontos de Gauss).",
                                    "Discuta cenários: Monte Carlo para alta dimensionalidade; resíduos para baixa dimensão.",
                                    "Avalie convergência: O(1/√N) para MC vs. O(h^p) para determinísticos.",
                                    "Conclua vantagens da aleatoriedade em problemas de Engenharia Civil (ex.: cargas aleatórias)."
                                  ],
                                  "verification": "Crie tabela comparativa de prós/contras para 2 problemas exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigos sobre métodos de Monte Carlo vs. FEM/Galerkin, quadro branco."
                                  ],
                                  "tips": "Use gráficos de erro vs. custo computacional para ilustrar.",
                                  "learningObjective": "Articular quando e por quê usar aleatoriedade sobre métodos exatos.",
                                  "commonMistakes": "Superestimar precisão de MC sem N suficiente."
                                }
                              ],
                              "practicalExample": "Em análise estrutural de uma ponte, use Monte Carlo para aproximar a integral da resposta dinâmica sob cargas aleatórias (vento/sim sismo), amostrando 10^5 cenários para estimar probabilidade de falha, contrastando com método de resíduos ponderados que falha em alta não-linearidade.",
                              "finalVerifications": [
                                "Explicar Lei dos Grandes Números em contexto de aproximação numérica.",
                                "Calcular manualmente Monte Carlo para integral simples com N=10.",
                                "Listar 3 limitações de métodos exatos para não-lineares.",
                                "Comparar erros de MC vs. trapezoidal em código.",
                                "Descrever aplicação em equação não-linear via sampling.",
                                "Verificar convergência plotando média vs. N."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção determinístico vs. estocástico (80%+ acerto em quiz).",
                                "Capacidade de implementar MC básico sem erros de código.",
                                "Explicação clara do papel da aleatoriedade (rubrica: 4/5 profundidade).",
                                "Contraste correto com resíduos ponderados (exemplos relevantes).",
                                "Análise de convergência com gráficos quantitativos.",
                                "Aplicação contextualizada em Engenharia Civil."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Lei Grandes Números, variância.",
                                "Programação Computacional: Implementação RNG e simulações.",
                                "Física/Mecânica: Modelagem estocástica de cargas em estruturas.",
                                "Análise Numérica: Comparação com quadratura e métodos iterativos."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, simulações Monte Carlo avaliam confiabilidade de barragens sob inundações aleatórias, aproximando integrais de distribuições de falha onde métodos exatos como resíduos ponderados são computacionalmente inviáveis devido à dimensionalidade."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.2",
                        "name": "Geração de Números Pseudoaleatórios",
                        "description": "Técnicas básicas para gerar sequências de números pseudoaleatórios, essenciais para a simulação estocástica, incluindo geradores lineares congruenciais e testes de qualidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.2.1",
                            "name": "Compreender geradores congruenciais lineares",
                            "description": "Explicar o algoritmo X_{n+1} = (a X_n + c) mod m, seus parâmetros e propriedades periódicas, conforme discutido em Kincaid e Cheney (2001).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a fórmula do gerador congruencial linear e seus parâmetros",
                                  "subSteps": [
                                    "Estude a fórmula X_{n+1} = (a * X_n + c) mod m, identificando cada componente.",
                                    "Defina os parâmetros: X_0 (semente), a (multiplicador), c (incremento), m (módulo).",
                                    "Leia a seção relevante em Kincaid e Cheney (2001) sobre LCGs.",
                                    "Anote as restrições típicas: m > 0, 0 ≤ X_0 < m, 0 ≤ c < m, 0 < a < m.",
                                    "Discuta o papel de cada parâmetro na geração de pseudoaleatórios."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o significado de cada parâmetro e forneça um exemplo numérico simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro Kincaid e Cheney (2001), caderno para anotações, calculadora.",
                                  "tips": "Visualize a fórmula como uma iteração modular para evitar confusão com operações aritméticas comuns.",
                                  "learningObjective": "Identificar e descrever corretamente todos os parâmetros do LCG e sua fórmula.",
                                  "commonMistakes": "Confundir 'mod m' com divisão comum; ignorar que parâmetros devem ser inteiros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a geração manual de uma sequência LCG",
                                  "subSteps": [
                                    "Escolha parâmetros exemplo: m=16, a=5, c=3, X_0=0.",
                                    "Calcule manualmente os primeiros 10 termos da sequência.",
                                    "Registre a sequência em uma tabela: n, X_n, X_{n+1}.",
                                    "Repita com diferentes sementes para observar variação.",
                                    "Compare sequências com c=0 (multiplicativo) vs c≠0."
                                  ],
                                  "verification": "Gere uma sequência de pelo menos 8 termos sem erros e plote em gráfico linear.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, calculadora ou planilha Excel, livro Kincaid e Cheney.",
                                  "tips": "Use uma tabela para rastrear cálculos e evitar erros de arredondamento.",
                                  "learningObjective": "Gerar corretamente sequências LCG manualmente e entender o impacto da semente.",
                                  "commonMistakes": "Esquecer o 'mod m' levando a números negativos ou fora do intervalo [0, m-1]; erros em multiplicações grandes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar propriedades periódicas do LCG",
                                  "subSteps": [
                                    "Defina período como o menor k > 0 tal que X_{n+k} = X_n para todo n.",
                                    "Estude teorema de Hull-Dobell para período máximo m: condições em a, c, m.",
                                    "Teste com parâmetros ruins (ex: a=1) vs bons (ex: m=2^p, a=2^k+1, c ímpar).",
                                    "Calcule o período de sequências exemplo do livro.",
                                    "Discuta independência e uniformidade aproximada."
                                  ],
                                  "verification": "Identifique condições para período completo e verifique em um exemplo com período < m.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Livro Kincaid e Cheney (2001), software como Python para simular longas sequências.",
                                  "tips": "Comece com m pequeno (potência de 2) para calcular períodos manualmente.",
                                  "learningObjective": "Explicar propriedades periódicas e condições para bom comportamento pseudoaleatório.",
                                  "commonMistakes": "Assumir sempre período máximo; confundir período com ciclo completo sem repetição inicial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar LCG em contexto de Monte Carlo e avaliar limitações",
                                  "subSteps": [
                                    "Implemente LCG em código simples (Python/MATLAB) para gerar 1000 números.",
                                    "Teste histograma para uniformidade em [0,1] normalizando X_n / m.",
                                    "Simule um problema simples: lançamento de dados ou integração Monte Carlo.",
                                    "Analise ciclo e correlações em pares consecutivos.",
                                    "Compare com geradores melhores como Mersenne Twister."
                                  ],
                                  "verification": "Execute simulação, gere relatório com histograma e período detectado.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Computador com Python ou MATLAB, código-fonte exemplo de LCG.",
                                  "tips": "Use bibliotecas como numpy.random apenas para validação, não geração.",
                                  "learningObjective": "Avaliar LCG em prática e reconhecer quando usar alternativas.",
                                  "commonMistakes": "Ignorar normalização X_n / (m-1); usar m não potência de 2 sem cuidado."
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para estimar a probabilidade de falha em uma viga de concreto sob carga variável, use LCG com m=2^31-1, a=1103515245, c=12345 para gerar cargas pseudoaleatórias uniformes em [0, 1000 kN], executando 10.000 iterações para calcular risco de colapso.",
                              "finalVerifications": [
                                "Explicar a fórmula LCG e parâmetros sem hesitação.",
                                "Gerar sequência manual de 10 termos corretamente.",
                                "Identificar condições de Hull-Dobell para período máximo.",
                                "Implementar LCG em código e plotar histograma uniforme.",
                                "Discutir limitações periódicas em aplicações Monte Carlo.",
                                "Referenciar corretamente Kincaid e Cheney (2001)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de parâmetros e fórmula (30%).",
                                "Correção nos cálculos manuais e implementados (25%).",
                                "Compreensão profunda de propriedades periódicas (20%).",
                                "Aplicação prática em exemplo Monte Carlo (15%).",
                                "Análise de limitações e conexões teóricas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra modular e teoria dos números.",
                                "Computação: Algoritmos iterativos e programação numérica.",
                                "Estatística: Geração de amostras uniformes para simulações.",
                                "Engenharia Civil: Modelagem estocástica em análise estrutural."
                              ],
                              "realWorldApplication": "Na engenharia civil, LCGs são usados em simulações Monte Carlo para modelar incertezas em cargas sísmicas, materiais ou tráfego em pontes, permitindo análise de confiabilidade e dimensionamento otimizado de estruturas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.2",
                            "name": "Aplicar testes de aleatoriedade",
                            "description": "Realizar testes como o de poker, frequência e corridas para validar a qualidade de sequências pseudoaleatórias geradas em MATLAB, como em Yang et al. (2005).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar Sequência Pseudoaleatória em MATLAB",
                                  "subSteps": [
                                    "Instale e abra o MATLAB.",
                                    "Gere uma sequência de números uniformes usando rand(1, N) com N >= 10000 (ex: N=10000).",
                                    "Converta para sequência binária: u_bin = floor(2*rand_seq);",
                                    "Salve a sequência em um arquivo .mat para reutilização."
                                  ],
                                  "verification": "Execute o código e visualize hist(u_bin) para confirmar distribuição uniforme (aprox. 50% zeros e uns).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "MATLAB R2020a ou superior",
                                    "Documentação MATLAB rand()"
                                  ],
                                  "tips": "Use N grande (10k+) para testes estatísticos confiáveis.",
                                  "learningObjective": "Entender geração de sequências pseudoaleatórias e conversão para binário.",
                                  "commonMistakes": "Usar N muito pequeno, levando a resultados instáveis; esquecer de limpar workspace com clear all."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e Executar Teste de Frequência",
                                  "subSteps": [
                                    "Carregue a sequência binária.",
                                    "Conte proporção de 1s: prop_ones = sum(u_bin)/length(u_bin);",
                                    "Calcule estatística qui-quadrado: chi2 = (sum(u_bin) - n/2)^2 / (n/4); df=1; pval = 1 - chi2cdf(chi2,1);",
                                    "Interprete: p > 0.01 indica aprovação (Yang et al., 2005)."
                                  ],
                                  "verification": "p-value exibido > 0.01 confirma equilíbrio de bits.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MATLAB Statistics Toolbox",
                                    "Artigo Yang et al. (2005)"
                                  ],
                                  "tips": "Use chi2cdf para p-value exato; teste múltiplas seeds com rng(seed).",
                                  "learningObjective": "Aplicar teste de frequência para checar uniformidade básica.",
                                  "commonMistakes": "Confundir soma de 1s com contagem total; usar teste z em vez de qui-quadrado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Executar Teste de Poker",
                                  "subSteps": [
                                    "Divida sequência em grupos de 5 bits: poker_hands = reshape(u_bin(1:5*floor(length(u_bin)/5)),5,[])' + 2.^(4:-1:0);",
                                    "Conte frequências de cada mão (0-31): freq = histcounts(poker_hands,0:32);",
                                    "Calcule qui-quadrado com probabilidades teóricas (ex: 0.302=10/32 para algumas); pval = 1-chi2cdf(chi2,15);",
                                    "Verifique p > 0.01."
                                  ],
                                  "verification": "Estatística qui-quadrado < limite crítico e p-value > 0.01.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "MATLAB base",
                                    "Tabela de probs poker do artigo"
                                  ],
                                  "tips": "Ajuste N múltiplo de 5; ignore último grupo incompleto.",
                                  "learningObjective": "Avaliar independência local via distribuições de poker.",
                                  "commonMistakes": "Erros em reshape ou potências de 2; probabilidades erradas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Executar Teste de Corridas (Runs)",
                                  "subSteps": [
                                    "Identifique corridas: runs = sum(diff([0 u_bin 1]) ~= 0);",
                                    "Calcule esperados: z = (runs - 2*n*0.5*0.5 -1) / sqrt(2*n*0.5*0.5*(2*0.5*0.5-1/sqrt(n)));",
                                    "p-value bilateral: pval = 2*(1-normcdf(abs(z)));",
                                    "Aprovação se p > 0.01."
                                  ],
                                  "verification": "Número de runs próximo ao esperado (2*n*0.5*0.5 +1) e p > 0.01.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MATLAB Statistics Toolbox",
                                    "Referência Yang et al."
                                  ],
                                  "tips": "Use normcdf para aproximação normal válida em N grande.",
                                  "learningObjective": "Detectar dependências seriais via teste de runs.",
                                  "commonMistakes": "Contar runs incorretamente sem diff(); usar distribuição exata para N pequeno."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados e Validar Qualidade",
                                  "subSteps": [
                                    "Compile p-values dos três testes em tabela.",
                                    "Compare com thresholds (0.01): conte aprovações.",
                                    "Gere relatório: if all(pvals>0.01), 'Sequência aprovada'; else 'Falha em [testes]'.",
                                    "Teste com diferentes geradores (rand vs. outros) para comparação."
                                  ],
                                  "verification": "Relatório indica aprovação em todos testes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Script consolidado MATLAB"
                                  ],
                                  "tips": "Automatize em função teste_aleatoriedade(u_bin).",
                                  "learningObjective": "Interpretar testes coletivamente para validar RNG.",
                                  "commonMistakes": "Ignorar falhas isoladas; não comparar múltiplos runs."
                                }
                              ],
                              "practicalExample": "Gere seq = rand(1,10000); u_bin = floor(2*seq); aplique os três testes. Resultado típico: frequência p=0.45, poker p=0.12, runs p=0.67 (todos >0.01), validando rand() como adequado para Monte Carlo.",
                              "finalVerifications": [
                                "Todos p-values > 0.01 nos três testes.",
                                "Número de runs entre limites esperados.",
                                "Distribuição poker uniforme (qui2 < 25.0 para df=15).",
                                "Proporção de 1s em [0.49, 0.51] para N=10k.",
                                "Relatório gerado confirma qualidade da sequência.",
                                "Testes repetidos com rng('default') consistentes."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta das fórmulas (chi2, z-score).",
                                "Cálculo preciso de p-values com funções MATLAB.",
                                "Interpretação adequada de thresholds (Yang et al.).",
                                "Código limpo, comentado e reproduzível.",
                                "Análise comparativa com sequências ruins (ex: sequências periódicas).",
                                "Relatório final com conclusões justificadas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes qui-quadrado e normal para hipóteses.",
                                "Probabilidade: Modelos binomiais e independência.",
                                "Programação: Scripting MATLAB e vetores.",
                                "Engenharia Civil: Validação para simulações Monte Carlo em estruturas.",
                                "Análise Numérica: Qualidade de geradores RNG."
                              ],
                              "realWorldApplication": "Na engenharia civil, testes de aleatoriedade validam sequências pseudoaleatórias usadas em métodos Monte Carlo para análise de confiabilidade estrutural, modelagem de cargas sísmicas, previsão de inundações e otimização de projetos sob incerteza, garantindo resultados estatisticamente robustos (ex: Yang et al., 2005)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.3",
                            "name": "Gerar variáveis aleatórias com distribuições específicas",
                            "description": "Usar métodos de transformação inversa e rejeição para obter amostras de distribuições uniforme, normal e exponencial a partir de uniformes pseudoaleatórios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Transformação Inversa",
                                  "subSteps": [
                                    "Revise a geração de números pseudoaleatórios uniformes U ~ Uniform(0,1).",
                                    "Estude a função de distribuição cumulativa (CDF) inversa: X = F^{-1}(U).",
                                    "Derive explicitamente a transformação para a distribuição exponencial: X = -ln(U)/λ.",
                                    "Explique por que isso preserva a uniformidade para distribuições contínuas.",
                                    "Pratique com exemplos manuais usando U gerados."
                                  ],
                                  "verification": "Derivar corretamente a fórmula para exponencial e justificar matematicamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Tabela de CDFs de distribuições comuns"
                                  ],
                                  "tips": "Sempre verifique se a CDF é estritamente crescente para garantir inversa única.",
                                  "learningObjective": "Dominar a teoria da transformação inversa para gerar amostras de distribuições conhecidas.",
                                  "commonMistakes": [
                                    "Confundir PDF com CDF",
                                    "Usar U ~ Uniform(a,b) sem ajustar para (0,1)",
                                    "Esquecer o sinal negativo na exponencial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Transformação Inversa para Distribuição Exponencial",
                                  "subSteps": [
                                    "Gere uma sequência de U ~ Uniform(0,1) usando função rand() em Python ou similar.",
                                    "Aplique a fórmula X = -ln(U)/λ para λ=1, gerando 1000 amostras.",
                                    "Calcule estatísticas descritivas: média, variância e compare com teóricas (1/λ, 1/λ²).",
                                    "Plote histograma das amostras e sobreponha a PDF exponencial.",
                                    "Teste com diferentes λ (ex: 0.5, 2.0) e valide."
                                  ],
                                  "verification": "Estatísticas das amostras coincidem com valores teóricos (erro <5%) e histograma visualmente compatível.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou equivalente",
                                    "Editor de código"
                                  ],
                                  "tips": "Use np.random.uniform(0,1) e np.log para eficiência; evite U=0 para evitar log(0).",
                                  "learningObjective": "Implementar e validar geração de variáveis exponenciais via inversa.",
                                  "commonMistakes": [
                                    "Gerar U incluindo 0 ou 1",
                                    "Não normalizar histograma para comparar com PDF",
                                    "Confundir parâmetro λ com média"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Método de Rejeição para Distribuição Normal",
                                  "subSteps": [
                                    "Entenda o algoritmo: proponha Y de uma distribuição envelope g(y) ≥ f(y), aceite com probabilidade f(y)/(M g(y)).",
                                    "Escolha envelope para normal: use exponencial dupla para |Z| e sinal aleatório.",
                                    "Implemente em código: gere propostas até aceitação, para N(0,1).",
                                    "Gere 1000 amostras e calcule estatísticas (média≈0, var≈1).",
                                    "Meça taxa de aceitação e otimize M."
                                  ],
                                  "verification": "Taxa de aceitação >20% e estatísticas próximas ao teórico (KS-test p>0.05).",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python com SciPy para testes KS",
                                    "Documentação do método de von Neumann"
                                  ],
                                  "tips": "Para normal padrão, M≈√(2/π e) com envelope exponencial funciona bem.",
                                  "learningObjective": "Aplicar método de rejeição para distribuições sem inversa fechada como a normal.",
                                  "commonMistakes": [
                                    "Envelope mal escolhido (g < f em algum ponto)",
                                    "Loop infinito por M insuficiente",
                                    "Esquecer sinal aleatório para normal simétrica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Comparar as Distribuições Geradas",
                                  "subSteps": [
                                    "Gere amostras uniformes, exponenciais e normais (10000 cada).",
                                    "Crie QQ-plots e histogramas comparativos com teóricos.",
                                    "Realize testes estatísticos: Kolmogorov-Smirnov para cada.",
                                    "Compare eficiência: tempo de CPU e número de uniformes consumidos.",
                                    "Documente resultados em relatório curto."
                                  ],
                                  "verification": "Todos testes KS com p>0.01 e QQ-plots lineares.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com SciPy.stats e Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Aumente N para melhor precisão; use seed para reprodutibilidade.",
                                  "learningObjective": "Avaliar qualidade e eficiência das métodos de geração.",
                                  "commonMistakes": [
                                    "Amostras insuficientes para validação",
                                    "Ignorar autocoerelacionamento em geradores ruins",
                                    "Não seedar para comparações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de tráfego viário para engenharia civil, gere tempos interarrivo exponenciais (λ=1/5 min) via inversa e velocidades normais N(50,10) km/h via rejeição, usando 5000 amostras para estimar probabilidade de congestionamento.",
                              "finalVerifications": [
                                "Histogramas e QQ-plots de amostras coincidem visualmente com PDFs teóricas.",
                                "Estatísticas descritivas (média, variância) dentro de 2% do teórico.",
                                "Testes KS rejeitam H0 de não-normalidade com p>0.05.",
                                "Eficiência: <10 uniformes por amostra normal em média.",
                                "Código roda sem erros e é reprodutível com seed.",
                                "Relatório documenta derivações e resultados."
                              ],
                              "assessmentCriteria": [
                                "Correta derivação teórica e implementação sem bugs (100%).",
                                "Validação estatística rigorosa com múltiplos testes.",
                                "Eficiência otimizada (taxa aceitação >25% para rejeição).",
                                "Código limpo, comentado e modular.",
                                "Interpretação correta de resultados e limitações.",
                                "Integração em contexto Monte Carlo simples."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: CDFs, testes de aderência.",
                                "Programação Computacional: Loops, vetores, plotting.",
                                "Análise Numérica: Algoritmos de amostragem.",
                                "Engenharia Civil: Simulações estocásticas em estruturas.",
                                "Física/Mecânica: Modelos aleatórios de cargas."
                              ],
                              "realWorldApplication": "No método de Monte Carlo para análise de risco em barragens ou pontes civis, gera cargas de vento normais e durações de eventos exponenciais para estimar probabilidades de falha estrutural sob incertezas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.3",
                        "name": "Princípios do Método de Monte Carlo",
                        "description": "Fundamentos do método que emprega amostragens aleatórias repetidas para estimar valores esperados, integrais e soluções probabilísticas, com ênfase na convergência e erro estatístico.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.3.1",
                            "name": "Aplicar a Lei dos Grandes Números",
                            "description": "Demonstrar como a média de N amostras independentes converge para o valor esperado à medida que N aumenta, base para a precisão do Monte Carlo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Lei dos Grandes Números",
                                  "subSteps": [
                                    "Estude a definição formal: a média de N variáveis aleatórias i.i.d. com média μ converge em probabilidade para μ quando N → ∞.",
                                    "Revise conceitos prévios: variáveis aleatórias independentes e identicamente distribuídas (i.i.d.), valor esperado E[X].",
                                    "Analise exemplos simples, como a média de lançamentos de uma moeda justa (E[X]=0.5).",
                                    "Discuta a intuição: flutuações diminuem com mais amostras.",
                                    "Leia provas intuitivas ou assista a vídeos explicativos."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando a LLGN e dê um exemplo com moeda.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeo Khan Academy sobre LLGN",
                                    "Notas de aula sobre probabilidade",
                                    "Calculadora ou papel para simulações manuais"
                                  ],
                                  "tips": "Use analogias cotidianas, como médias de notas em turmas grandes.",
                                  "learningObjective": "Definir precisamente a LLGN e identificar suas hipóteses chave.",
                                  "commonMistakes": [
                                    "Confundir convergência em probabilidade com convergência quase certa",
                                    "Ignorar a necessidade de independência das amostras",
                                    "Achar que vale para N fixo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar uma Simulação Computacional Simples",
                                  "subSteps": [
                                    "Escolha uma variável aleatória simples, ex: Uniforme[0,1], com E[X]=0.5.",
                                    "Escreva código em Python (usando numpy.random) para gerar N amostras e calcular a média.",
                                    "Teste com N pequeno (ex: 10) e registre a média.",
                                    "Prepare um loop para variar N de 10 a 10^6.",
                                    "Configure gráficos para plotar média vs log(N)."
                                  ],
                                  "verification": "Execute o código para N=100 e confirme que a média está próxima de 0.5 (±0.1).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Jupyter Notebook",
                                    "Template de código fornecido"
                                  ],
                                  "tips": "Use np.mean() e np.logspace() para N eficiente; evite loops lentos.",
                                  "learningObjective": "Implementar geração de amostras i.i.d. e cálculo de médias em código.",
                                  "commonMistakes": [
                                    "Gerar amostras dependentes",
                                    "Usar seed fixa sem variar",
                                    "Escala errada no eixo log"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Simulações e Observar a Convergência",
                                  "subSteps": [
                                    "Rode simulações para N=10, 100, 1k, 10k, 100k, 1M.",
                                    "Calcule a média para cada N e o erro absoluto |média - 0.5|.",
                                    "Repita 10 vezes por N para mostrar variância.",
                                    "Plote as curvas de convergência (média ± desvio padrão vs log N).",
                                    "Observe como a variância diminui como 1/sqrt(N)."
                                  ],
                                  "verification": "Gere um gráfico mostrando convergência clara para E[X] com aumento de N.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python do passo anterior",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": "Média múltiplas runs para suavizar; use semilogy para erro.",
                                  "learningObjective": "Demonstrar empiricamente a convergência da média amostral.",
                                  "commonMistakes": [
                                    "N insuficientemente grande",
                                    "Ignorar variância entre runs",
                                    "Plots lineares que mascaram convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Conectar ao Monte Carlo",
                                  "subSteps": [
                                    "Calcule a taxa de convergência (ex: erro ~ 1/sqrt(N)).",
                                    "Explique por que isso fundamenta a precisão do Monte Carlo: estimativas melhoram com mais simulações.",
                                    "Aplique a um exemplo Monte Carlo: estimar π via dardos.",
                                    "Discuta limitações: custo computacional para N muito grande.",
                                    "Escreva um relatório curto com gráficos e conclusões."
                                  ],
                                  "verification": "Produza um relatório de 1 página com plots e explicação da convergência.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Gráficos gerados",
                                    "Editor de texto"
                                  ],
                                  "tips": "Relacione explicitamente à precisão de integras Monte Carlo.",
                                  "learningObjective": "Ligar LLGN à justificativa teórica do método Monte Carlo.",
                                  "commonMistakes": [
                                    "Não quantificar erro",
                                    "Omitir conexão com Monte Carlo",
                                    "Generalizar além de i.i.d."
                                  ]
                                }
                              ],
                              "practicalExample": "Estime π usando Monte Carlo: gere pontos (X,Y) uniformes em [0,1]x[0,1]. A fração dentro do círculo x²+y²≤1 converge para π/4 pela LLGN. Rode para N=10 a 10^6, plote a estimativa vs N e observe convergência de ~0.785.",
                              "finalVerifications": [
                                "Gráficos mostram média convergindo monotonicamente para o valor esperado.",
                                "Erro diminui aproximadamente como 1/sqrt(N) em log-log plot.",
                                "Múltiplas runs confirmam baixa variância para N grande.",
                                "Código roda sem erros e reproduz resultados.",
                                "Relatório explica corretamente a LLGN no contexto.",
                                "Exemplo de π tem estimativa <1% erro para N=10^6."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual da LLGN (definição, hipóteses).",
                                "Qualidade e correção do código de simulação.",
                                "Clareza e interpretabilidade dos gráficos de convergência.",
                                "Quantificação correta de erro e variância.",
                                "Conexão explícita com fundamentos do Monte Carlo.",
                                "Relatório completo e bem estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Teorema Central do Limite e variância amostral.",
                                "Programação: Geração de aleatórios em Python/NumPy.",
                                "Probabilidade: Variáveis i.i.d. e convergência estocástica.",
                                "Engenharia Computacional: Simulações numéricas em CIV.",
                                "Física: Modelos estocásticos em dinâmica de estruturas."
                              ],
                              "realWorldApplication": "Na engenharia civil, a LLGN justifica simulações Monte Carlo para estimar riscos em projetos de pontes ou barragens sob cargas aleatórias (vento, tráfego), onde médias de milhares de cenários convergem para probabilidades confiáveis de falha."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.2",
                            "name": "Estimar integrais usando Monte Carlo",
                            "description": "Implementar a aproximação de integrais multidimensionais pela média de funções avaliadas em pontos aleatórios no domínio, com exemplo numérico simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o princípio do método Monte Carlo para estimar integrais",
                                  "subSteps": [
                                    "Revise a fórmula básica: para um domínio D com volume V, ∫_D f(x) d x ≈ (V / N) * Σ f(x_i), onde x_i são pontos uniformemente aleatórios em D.",
                                    "Entenda a justificativa probabilística baseada na lei dos grandes números: a média amostral converge para a esperança E[f(X)].",
                                    "Analise um exemplo unidimensional simples, como ∫_0^1 x dx = 0.5.",
                                    "Discuta limitações iniciais, como variância alta para poucas amostras.",
                                    "Anote as condições: f contínua e domínio com volume finito."
                                  ],
                                  "verification": "Explique oralmente ou por escrito a fórmula e por que ela converge, com um exemplo numérico manual.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Notebook com Python e NumPy",
                                    "Artigo ou vídeo curto sobre Monte Carlo (ex: Khan Academy)"
                                  ],
                                  "tips": "Visualize geometricamente: a integral é o volume médio sob a função no domínio.",
                                  "learningObjective": "Dominar a base teórica da aproximação Monte Carlo para integrais multidimensionais.",
                                  "commonMistakes": [
                                    "Esquecer de dividir pelo número de amostras N",
                                    "Confundir volume do domínio com 1",
                                    "Ignorar que pontos devem ser uniformes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o problema: função, domínio e parâmetros",
                                  "subSteps": [
                                    "Escolha uma função f simples, ex: f(x,y) = x*y em D = [0,1]x[0,1] (integral exata = 0.25).",
                                    "Calcule o volume V do domínio (aqui V=1 para cubo unitário).",
                                    "Defina o número de amostras N inicial (ex: 1000).",
                                    "Escreva pseudocódigo: gerar N pontos, avaliar f, somar.",
                                    "Verifique dimensionalidade: adapte para 1D, 2D ou mais."
                                  ],
                                  "verification": "Documente f, D, V e N em um arquivo ou caderno, confirmando valor exato da integral.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou Jupyter Notebook",
                                    "Calculadora para valor exato"
                                  ],
                                  "tips": "Comece com domínio unitário para simplificar (V=1).",
                                  "learningObjective": "Preparar o setup preciso para implementação computacional.",
                                  "commonMistakes": [
                                    "Definir domínio incorreto (ex: esquecer limites)",
                                    "Escolher f com alta variância sem motivo",
                                    "Não computar V corretamente para domínios não unitários"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar geração de pontos aleatórios e cálculo da média",
                                  "subSteps": [
                                    "Instale/importe bibliotecas: import numpy as np; np.random.uniform.",
                                    "Gere N pontos: para 2D, X = np.random.uniform(0,1,(N,2)).",
                                    "Avalie f em cada ponto: fx = f(X[:,0], X[:,1]).",
                                    "Calcule soma e média: media = np.mean(fx).",
                                    "Estime integral: integral_est = V * media."
                                  ],
                                  "verification": "Execute o código e imprima a estimativa; compare visualmente com valor exato.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3 com NumPy e Matplotlib",
                                    "Jupyter Notebook para testes interativos"
                                  ],
                                  "tips": "Use vetores NumPy para eficiência, evite loops lentos.",
                                  "learningObjective": "Implementar computacionalmente a amostragem e avaliação.",
                                  "commonMistakes": [
                                    "Usar random.random() em loop (lento)",
                                    "Índices errados em arrays multidimensionais",
                                    "Esquecer de multiplicar por V"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar precisão, convergência e refinar a estimativa",
                                  "subSteps": [
                                    "Repita com N=10^3, 10^4, 10^5; plote erro vs N (log-log).",
                                    "Calcule desvio padrão: np.std(fx) / sqrt(N) para intervalo de confiança.",
                                    "Visualize pontos e função com scatter plot.",
                                    "Teste outra função/dominio, ex: f(x)=sin(pi x) em [0,1].",
                                    "Discuta melhorias: stratified sampling ou importance sampling (intro)."
                                  ],
                                  "verification": "Gere gráfico mostrando convergência; erro <5% para N=10^5.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "Código do passo anterior"
                                  ],
                                  "tips": "Logscale no plot para ver taxa 1/sqrt(N).",
                                  "learningObjective": "Avaliar e melhorar a qualidade da aproximação.",
                                  "commonMistakes": [
                                    "Interpretar erro sem aumentar N",
                                    "Plot errados (eixo invertido)",
                                    "Ignorar variância da função"
                                  ]
                                }
                              ],
                              "practicalExample": "Estime ∫_{[0,1]^2} x * y dx dy (valor exato 0.25) com N=10000 pontos. Código Python: import numpy as np; N=10000; V=1; pts=np.random.uniform(0,1,(N,2)); f=pts[:,0]*pts[:,1]; est=V*np.mean(f). Resultado esperado ~0.25 ± 0.005.",
                              "finalVerifications": [
                                "Código executa sem erros e produz estimativa dentro de 10% do valor exato para N=1000.",
                                "Gráfico de convergência mostra redução de erro com N crescente.",
                                "Intervalo de confiança calculado corretamente (desvio/std/sqrt(N)).",
                                "Teste com pelo menos duas funções/domínios diferentes.",
                                "Explicação escrita da convergência.",
                                "Código comentado e reutilizável."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro <5% para N=10^5.",
                                "Correção teórica: fórmula e uniformidade corretas.",
                                "Eficiência computacional: uso de vetores NumPy.",
                                "Análise: gráfico de erro e discussão de variância.",
                                "Generalização: adaptação a 3D ou outra f.",
                                "Documentação: comentários e relatório curto."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Lei dos grandes números e variância amostral.",
                                "Programação: Geração de aleatórios e vetores NumPy.",
                                "Matemática: Teoria de medida e integrais múltiplas.",
                                "Física: Simulações estocásticas em mecânica.",
                                "Engenharia Civil: Estimativa de volumes em projetos geotécnicos."
                              ],
                              "realWorldApplication": "Em engenharia civil, usar Monte Carlo para estimar volumes de escavações irregulares, cargas probabilísticas em estruturas ou áreas de reservatórios, onde domínios complexos impossibilitam integração analítica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.3",
                            "name": "Analisar erro e convergência no Monte Carlo",
                            "description": "Calcular o erro padrão como σ / √N e discutir taxa de convergência O(1/√N), comparando com métodos determinísticos como otimização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de erro e convergência no método Monte Carlo",
                                  "subSteps": [
                                    "Revise a definição de erro padrão (σ) em distribuições estatísticas e sua relação com amostras independentes.",
                                    "Estude o teorema do limite central e como ele justifica a normalidade da estimativa Monte Carlo para N grande.",
                                    "Identifique que a variância da estimativa é σ²/N, levando ao erro padrão σ/√N.",
                                    "Discuta convergência como a redução do erro com aumento de N.",
                                    "Explore exemplos simples de integração numérica via Monte Carlo para visualizar o erro."
                                  ],
                                  "verification": "Explique em suas palavras como o erro padrão diminui com N e resuma o teorema do limite central em um parágrafo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro ou notas sobre Estatística (ex: 'Introduction to Probability' de Blitzstein)",
                                    "Vídeo tutorial sobre Monte Carlo no YouTube (Khan Academy ou similar)",
                                    "Jupyter Notebook vazio para anotações"
                                  ],
                                  "tips": "Use diagramas de distribuição normal para visualizar σ/√N; foque em intuição antes da matemática.",
                                  "learningObjective": "Entender a base estatística do erro e convergência no Monte Carlo.",
                                  "commonMistakes": [
                                    "Confundir variância com desvio padrão",
                                    "Ignorar independência das amostras",
                                    "Achar que Monte Carlo converge mais rápido que métodos exatos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o erro padrão σ/√N para uma estimativa Monte Carlo",
                                  "subSteps": [
                                    "Implemente uma simulação Monte Carlo simples em Python para estimar π (método de pontos aleatórios em círculo).",
                                    "Colete múltiplas runs para calcular a média e o desvio padrão σ da estimativa.",
                                    "Compute explicitamente o erro padrão como σ/√N para diferentes valores de N (ex: 10^3, 10^4, 10^5).",
                                    "Plote erro padrão vs. √N para verificar a relação linear.",
                                    "Calcule intervalos de confiança de 95% usando a aproximação normal."
                                  ],
                                  "verification": "Gere um gráfico mostrando erro padrão decaindo como 1/√N e forneça cálculos numéricos para N=10^4.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy, Matplotlib e SciPy",
                                    "Jupyter Notebook",
                                    "Código base para Monte Carlo de π disponível online"
                                  ],
                                  "tips": "Use np.std(samples, ddof=1) para desvio padrão amostral; rode simulações com semente fixa para reprodutibilidade.",
                                  "learningObjective": "Dominar o cálculo prático do erro padrão em simulações.",
                                  "commonMistakes": [
                                    "Usar desvio padrão populacional em vez de amostral",
                                    "Não normalizar por √N corretamente",
                                    "Escolha inadequada de N levando a plots enganosos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a taxa de convergência O(1/√N)",
                                  "subSteps": [
                                    "Derive matematicamente a taxa de convergência a partir da variância da estimativa.",
                                    "Compare numericamente com diferentes N, medindo RMSE (Root Mean Square Error) vs. valor exato.",
                                    "Discuta implicações: custo computacional O(N) para precisão O(1/√N).",
                                    "Teste em um problema de engenharia civil, como simulação de carga em vigas com variabilidade.",
                                    "Analise como aumentar N mitiga o erro, mas com retornos decrescentes."
                                  ],
                                  "verification": "Forneça uma derivação curta e um gráfico log-log de erro vs. N confirmando inclinação -0.5.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python/Jupyter",
                                    "Papel e lápis para derivação",
                                    "Artigo sobre Monte Carlo em engenharia (ex: ASCE journals)"
                                  ],
                                  "tips": "Use escalas log para visualizar O(1/√N) claramente; considere paralelização para N grandes.",
                                  "learningObjective": "Quantificar e interpretar a taxa de convergência Monte Carlo.",
                                  "commonMistakes": [
                                    "Confundir convergência em probabilidade com taxa determinística",
                                    "Ignorar custo computacional",
                                    "Plots lineares em vez de log para análise"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Monte Carlo com métodos determinísticos como otimização",
                                  "subSteps": [
                                    "Implemente um método determinístico equivalente, como quadratura numérica ou otimização gradient-based para o mesmo problema.",
                                    "Meça tempo de execução e precisão para ambos os métodos variando tolerância.",
                                    "Discuta trade-offs: Monte Carlo para problemas com alta dimensionalidade vs. determinísticos para baixa dimensão.",
                                    "Aplique a um caso civil: análise de confiabilidade de estruturas (Monte Carlo vs. FORM/SORM).",
                                    "Conclua quando usar cada um baseado em erro, custo e complexidade."
                                  ],
                                  "verification": "Crie uma tabela comparativa de precisão, tempo e escalabilidade para N/dimensões variadas.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Python com SciPy (quad) e NumPy",
                                    "Jupyter Notebook",
                                    "Referências: 'Reliability Engineering' livros"
                                  ],
                                  "tips": "Escolha problemas onde Monte Carlo brilha (ex: 10+ dimensões); benchmark em máquina real.",
                                  "learningObjective": "Avaliar Monte Carlo contra alternativas determinísticas.",
                                  "commonMistakes": [
                                    "Subestimar custo de Monte Carlo em baixa dimensão",
                                    "Não considerar variância em comparações",
                                    "Ignorar métodos híbridos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em engenharia civil, simule a probabilidade de falha de uma viga sob carga variável usando Monte Carlo: gere 10^6 amostras de cargas ~Normal(μ,σ), compute fator de segurança, estime P(falha). Calcule σ/√N ≈ 0.001 para N=10^6, plotando convergência e comparando com otimização FORM que converge em 10 iterações.",
                              "finalVerifications": [
                                "Calcula corretamente σ/√N para uma simulação dada.",
                                "Explica e demonstra graficamente O(1/√N).",
                                "Compara acuradamente Monte Carlo vs. determinístico em tabela.",
                                "Identifica limitações de Monte Carlo em problemas reais.",
                                "Aplica conceitos a um problema de engenharia civil.",
                                "Deriva intervalos de confiança adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de erro (90%+ correto).",
                                "Qualidade dos gráficos e visualizações (clareza, escalas corretas).",
                                "Profundidade da análise comparativa (trade-offs quantitativos).",
                                "Relevância ao contexto de engenharia civil.",
                                "Clareza na explicação escrita/verbal.",
                                "Criatividade no exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Teorema do Limite Central e intervalos de confiança.",
                                "Programação Computacional: Implementação eficiente em Python/NumPy.",
                                "Otimização: Métodos determinísticos como gradiente descendente.",
                                "Engenharia de Confiabilidade: Análise de risco em estruturas.",
                                "Física/Mecânica: Simulações estocásticas de cargas."
                              ],
                              "realWorldApplication": "Na engenharia civil, analisa incertezas em projetos de pontes ou edifícios, estimando probabilidades de falha sob cargas variáveis (vento, terremotos), otimizando N para equilibrar precisão e custo computacional em softwares como ANSYS ou OpenSees."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.4",
                            "name": "Resolver problemas simples de engenharia civil com Monte Carlo",
                            "description": "Aplicar o método para estimar probabilidades em problemas como falha estrutural sob cargas aleatórias, usando geração de números aleatórios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e modelar probabilisticamente",
                                  "subSteps": [
                                    "Identifique o problema de engenharia civil, como falha estrutural em uma viga sob cargas aleatórias.",
                                    "Defina as variáveis aleatórias envolvidas (ex.: carga máxima ~ Normal(μ=100kN, σ=20kN), resistência ~ Normal(μ=150kN, σ=15kN)).",
                                    "Estabeleça o critério de falha (ex.: falha se carga > resistência).",
                                    "Determine o número de simulações N (ex.: 10.000 iterações).",
                                    "Esboce o fluxograma do modelo Monte Carlo."
                                  ],
                                  "verification": "Modelo probabilístico documentado com distribuições, parâmetros e critério de falha claramente definidos em um diagrama ou pseudocódigo.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel e caneta ou software de diagramação (Draw.io), documentação de distribuições probabilísticas.",
                                  "tips": "Comece com distribuições simples como Normal ou Uniforme para evitar complexidade inicial.",
                                  "learningObjective": "Compreender como traduzir um problema físico em um modelo estocástico.",
                                  "commonMistakes": "Ignorar correlações entre variáveis ou escolher distribuições inadequadas sem justificativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração de números aleatórios e simulação",
                                  "subSteps": [
                                    "Configure o ambiente de programação (ex.: Python com NumPy).",
                                    "Gere amostras aleatórias para cada variável usando funções como np.random.normal().",
                                    "Implemente a lógica de falha para cada iteração (if carga > resistência: falha +=1).",
                                    "Estruture um loop principal para N simulações.",
                                    "Adicione seeds para reprodutibilidade (np.random.seed(42))."
                                  ],
                                  "verification": "Código executável que gera amostras e conta falhas iniciais sem erros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python 3+, bibliotecas NumPy e Matplotlib, editor de código (VS Code ou Jupyter Notebook).",
                                  "tips": "Teste com poucas iterações (N=100) para depurar antes de escalar.",
                                  "learningObjective": "Dominar a geração de variáveis aleatórias e lógica iterativa no Monte Carlo.",
                                  "commonMistakes": "Confundir parâmetros de distribuição (μ vs σ) ou esquecer de importar bibliotecas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações e coletar dados estatísticos",
                                  "subSteps": [
                                    "Execute o loop com N grande (10.000+).",
                                    "Colete estatísticas: número de falhas, probabilidade de falha (falhas/N), médias e desvios das variáveis.",
                                    "Gere histogramas ou plots de distribuições simuladas.",
                                    "Calcule intervalos de confiança para a probabilidade (ex.: usando binomial).",
                                    "Salve resultados em arquivo CSV para análise posterior."
                                  ],
                                  "verification": "Resultados salvos com probabilidade de falha calculada e visualizações geradas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmo ambiente Python, biblioteca Pandas para dados.",
                                  "tips": "Monitore tempo de execução; vetorize operações com NumPy para eficiência.",
                                  "learningObjective": "Aprender a coletar e visualizar dados de simulações massivas.",
                                  "commonMistakes": "N insuficiente levando a variância alta, ou não normalizar probabilidade (dividir por N)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e validar o modelo",
                                  "subSteps": [
                                    "Compare probabilidade estimada com solução analítica aproximada (se possível).",
                                    "Avalie convergência plotando probabilidade vs N.",
                                    "Discuta incertezas e sensibilidade a parâmetros.",
                                    "Documente conclusões e recomendações de design (ex.: aumentar resistência).",
                                    "Teste cenários alternativos (ex.: mudar distribuições)."
                                  ],
                                  "verification": "Relatório com análise, plots de convergência e validação documentados.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Jupyter Notebook para relatório interativo, SciPy para intervalos de confiança.",
                                  "tips": "Use log-probabilidade para eventos raros para melhor precisão numérica.",
                                  "learningObjective": "Interpretar resultados Monte Carlo e validar contra referências.",
                                  "commonMistakes": "Sobreinterpretar precisão sem checar convergência ou ignorar viés numérico."
                                }
                              ],
                              "practicalExample": "Estime a probabilidade de falha de uma viga de concreto em uma ponte sob cargas de tráfego aleatórias: carga ~ Normal(120kN, 25kN), resistência ~ LogNormal(160kN, 0.1). Rode 50.000 simulações e obtenha P(falha) ≈ 0.023, sugerindo reforço estrutural.",
                              "finalVerifications": [
                                "Código roda sem erros e converge para N>10.000.",
                                "Probabilidade de falha é consistente em múltiplas seeds.",
                                "Histogramas das variáveis simuladas casam com distribuições teóricas.",
                                "Intervalo de confiança reportado (ex.: 95% CI).",
                                "Conclusões ligadas a implicações de engenharia.",
                                "Relatório completo com código, plots e análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação Monte Carlo (geração correta de aleatórios).",
                                "Adequação do modelo ao problema de engenharia civil.",
                                "Qualidade da análise estatística e visualizações.",
                                "Validação e discussão de incertezas.",
                                "Clareza e completude do relatório.",
                                "Eficiência computacional do código."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuições probabilísticas e intervalos de confiança.",
                                "Programação: Loops, vetores e bibliotecas NumPy/SciPy.",
                                "Física/Mecânica: Modelos de falha estrutural e cargas.",
                                "Gestão de Riscos: Análise probabilística em projetos.",
                                "Matemática Computacional: Simulações numéricas."
                              ],
                              "realWorldApplication": "Em projetos de pontes e edifícios, o Monte Carlo estima riscos de colapso sob ventos/sismos aleatórios, auxiliando normas como Eurocode para fatores de segurança dinâmicos e otimização de custos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.5",
                    "name": "Integração Numérica via Monte Carlo",
                    "description": "Aplicação do método para calcular integrais definidas por meio de médias de amostras aleatórias.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.5.1",
                        "name": "Princípio Fundamental da Integração Monte Carlo",
                        "description": "Compreensão do método de Monte Carlo para integração numérica, baseado na representação da integral definida como uma expectativa matemática de uma variável aleatória uniforme no intervalo de integração.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.1.1",
                            "name": "Representar integral como expectativa",
                            "description": "Derivar e explicar a fórmula que transforma a integral definida de f(x) de a a b em (b-a) * E[f(U)], onde U é uma variável aleatória uniforme em [a,b].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição geométrica e analítica da integral definida",
                                  "subSteps": [
                                    "Explique a integral definida ∫_a^b f(x) dx como a área sob a curva f(x) de a a b.",
                                    "Discuta a interpretação como limite de somas de Riemann: ∑ f(x_i) Δx.",
                                    "Relação com a média: integral = (b-a) * (média de f(x) sobre [a,b]).",
                                    "Esboce um gráfico simples de f(x) = x em [0,1] e calcule a integral manualmente.",
                                    "Compare com a fórmula fundamental do cálculo para validação."
                                  ],
                                  "verification": "Escreva a integral de f(x)=x de 0 a 1 e confirme que é 1/2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora básica"
                                  ],
                                  "tips": "Visualize sempre a área para intuitividade.",
                                  "learningObjective": "Compreender a integral como largura vezes altura média.",
                                  "commonMistakes": "Confundir integral definida com indefinida; esquecer limites a e b."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir variável aleatória uniforme U em [a,b]",
                                  "subSteps": [
                                    "Defina U ~ Uniforme[a,b]: densidade de probabilidade f_U(u) = 1/(b-a) para u em [a,b].",
                                    "Calcule E[U] = ∫_a^b u * (1/(b-a)) du = (a+b)/2.",
                                    "Discuta propriedades: independência de eventos em intervalos iguais.",
                                    "Gere amostras mentais: U é igualmente provável em qualquer ponto de [a,b].",
                                    "Verifique normalização: ∫_a^b f_U(u) du = 1."
                                  ],
                                  "verification": "Prove que E[U] = (a+b)/2 para [0,1].",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis"
                                  ],
                                  "tips": "Pense em U como um ponto aleatório lançado uniformemente no intervalo.",
                                  "learningObjective": "Entender a distribuição uniforme e sua densidade.",
                                  "commonMistakes": "Esquecer o fator 1/(b-a) na densidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e calcular a expectativa E[f(U)]",
                                  "subSteps": [
                                    "Defina E[f(U)] = ∫_a^b f(u) f_U(u) du = ∫_a^b f(u) * (1/(b-a)) du.",
                                    "Simplifique: E[f(U)] = (1/(b-a)) ∫_a^b f(u) du.",
                                    "Inverta: ∫_a^b f(u) du = (b-a) E[f(U)].",
                                    "Calcule para f(u)=u em [0,1]: E[U]=0.5, integral=1*0.5=0.5.",
                                    "Generalize para qualquer f contínua."
                                  ],
                                  "verification": "Derive a fórmula ∫_a^b f(x) dx = (b-a) E[f(U)] passo a passo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software como Python para plotar densidade"
                                  ],
                                  "tips": "Substitua sempre f_U(u) = 1/(b-a) na integral de expectativa.",
                                  "learningObjective": "Derivar probabilisticamente a representação da integral como expectativa.",
                                  "commonMistakes": "Trocar a ordem: escrever E[f(U)] sem o fator de densidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e ilustrar com exemplo numérico e gráfico",
                                  "subSteps": [
                                    "Escolha f(x)=x^2 em [0,1]: integral exata=1/3.",
                                    "E[f(U)] = E[U^2] = ∫_0^1 u^2 du = 1/3, então (1-0)*1/3=1/3.",
                                    "Gere 100 amostras de U uniformes e compute média de f(U_i).",
                                    "Compare com valor exato e discuta convergência.",
                                    "Plote histograma de amostras vs. densidade teórica."
                                  ],
                                  "verification": "Simule em código e mostre que média aproxima E[f(U)].",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou MATLAB com numpy.random.uniform"
                                  ],
                                  "tips": "Use np.mean(f(U_samples)) para estimar E[f(U)].",
                                  "learningObjective": "Aplicar a fórmula em prática para validação.",
                                  "commonMistakes": "Gerar amostras fora de [a,b]; não escalar por (b-a)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explicar intuição e preparar para Monte Carlo",
                                  "subSteps": [
                                    "Intuição: amostragem uniforme 'média' f(x) naturalmente.",
                                    "Ligue a Monte Carlo: estimar integral via média empírica de f(U_i).",
                                    "Discuta erro: lei dos grandes números garante convergência.",
                                    "Estenda a múltiplas dimensões brevemente.",
                                    "Resuma derivação em uma frase chave."
                                  ],
                                  "verification": "Explique verbalmente por que a integral é (b-a) vezes a média aleatória.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para resumo"
                                  ],
                                  "tips": "Memorize: integral = largura * expectativa sob uniforme.",
                                  "learningObjective": "Internalizar o princípio fundamental da integração Monte Carlo.",
                                  "commonMistakes": "Ignorar que U é uniforme; confundir com normal."
                                }
                              ],
                              "practicalExample": "Para estimar ∫_0^1 √x dx = 2/3 ≈ 0.666, gere U_i ~ Unif[0,1], compute média de √U_i, multiplique por 1: após 1000 amostras, obtém ≈0.665.",
                              "finalVerifications": [
                                "Derivar corretamente ∫_a^b f(x) dx = (b-a) E[f(U)].",
                                "Calcular E[f(U)] para f(x)=x^2 em [0,2].",
                                "Simular 500 amostras e estimar integral de sin(x) em [0,π].",
                                "Explicar intuição probabilística em 2 frases.",
                                "Identificar erro em derivação comum (ex: faltar 1/(b-a)).",
                                "Aplicar a um problema de engenharia simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula (integral = (b-a) E[f(U)]).",
                                "Correta definição de densidade uniforme e expectativa.",
                                "Validação numérica com simulação convergente.",
                                "Clareza na explicação intuitiva e geométrica.",
                                "Identificação de erros comuns e correções.",
                                "Conexão com Monte Carlo e aplicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Expectativas e Lei dos Grandes Números.",
                                "Programação Computacional: Geração de aleatórios em Python/R.",
                                "Cálculo: Interpretação de integrais definidas.",
                                "Engenharia Civil: Simulações de cargas aleatórias em estruturas."
                              ],
                              "realWorldApplication": "Em engenharia civil, usar para integrar funções complexas em simulações Monte Carlo, como calcular áreas de seções transversais irregulares de rios para projetos de pontes ou estimar volumes de aterros com geometria variável."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.2",
                            "name": "Interpretar o estimador de Monte Carlo",
                            "description": "Explicar o estimador não viesado como a média aritmética das avaliações de f em N pontos aleatórios independentes, e sua relação com a Lei dos Grandes Números.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Estimadores Estatísticos",
                                  "subSteps": [
                                    "Defina o que é um estimador em estatística: uma função dos dados amostrais que estima um parâmetro populacional.",
                                    "Explique o conceito de viés: diferença entre o valor esperado do estimador e o verdadeiro parâmetro.",
                                    "Discuta estimadores não viesados, onde E[estimador] = parâmetro verdadeiro.",
                                    "Revise amostragem aleatória independente e identicamente distribuída (i.i.d.).",
                                    "Relacione com integração numérica: estimar ∫f(x)dx como expectativa E[f(X)] onde X é uniforme no domínio."
                                  ],
                                  "verification": "Escreva definições curtas para estimador, viés e i.i.d., e confirme com um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre probabilidade, calculadora ou papel para anotações.",
                                  "tips": "Use analogias cotidianas, como estimar a altura média de uma população com uma amostra.",
                                  "learningObjective": "Compreender os fundamentos de estimadores e viés para contextualizar o Monte Carlo.",
                                  "commonMistakes": "Confundir viés com variância; lembrar que não viesado não implica preciso."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Estimador de Monte Carlo para Integração",
                                  "subSteps": [
                                    "Estabeleça a integral I = ∫_D f(x) dx / vol(D), onde vol(D) é o volume do domínio.",
                                    "Gere N pontos X1, ..., XN ~ Uniform(D) independentes.",
                                    "Calcule o estimador θ_N = (1/N) Σ f(Xi) * vol(D).",
                                    "Explique por que isso aproxima I: cada f(Xi) é uma avaliação aleatória da função média.",
                                    "Implemente um código simples em Python para gerar pontos e calcular θ_N."
                                  ],
                                  "verification": "Implemente e execute um script que computa θ_N para f(x)=x em [0,1], verificando se aproxima 0.5.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy e Matplotlib, ou MATLAB; tutorial online de geração de aleatórios uniformes.",
                                  "tips": "Visualize os pontos aleatórios plotados no domínio para intuitividade.",
                                  "learningObjective": "Formular matematicamente o estimador Monte Carlo como média aritmética.",
                                  "commonMistakes": "Esquecer de multiplicar por vol(D); assumir domínio unitário sempre."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que o Estimador é Não Viesado",
                                  "subSteps": [
                                    "Calcule a esperança: E[θ_N] = E[(1/N) Σ f(Xi) * vol(D)] = (1/N) * N * E[f(X1)] * vol(D).",
                                    "Mostre E[f(X1)] = (1/vol(D)) ∫_D f(x) dx, pois X1 ~ Uniform(D).",
                                    "Conclua E[θ_N] = ∫_D f(x) dx = I, logo não viesado.",
                                    "Discuta independência dos Xi para linearidade da esperança.",
                                    "Verifique numericamente: rode múltiplas simulações e compare média das θ_N com I exato."
                                  ],
                                  "verification": "Derivação escrita da prova e gráfico de E[θ_N] aproximado vs. I exato.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel para derivação, Python para simulações múltiplas (ex: 1000 runs).",
                                  "tips": "Use propriedades de expectativa linear: E[aX + bY] = aE[X] + bE[Y].",
                                  "learningObjective": "Demonstrar matematicamente a propriedade de não viés do estimador.",
                                  "commonMistakes": "Ignorar a normalização por vol(D); confundir com variância que não some a zero."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com a Lei dos Grandes Números (LLN)",
                                  "subSteps": [
                                    "Enuncie a LLN: para Xi i.i.d. com E[Yi] = μ finita, (1/N) Σ Yi → μ quase certamente.",
                                    "Identifique Yi = f(Xi) * vol(D), com E[Yi] = I.",
                                    "Explique convergência: à medida que N→∞, θ_N → I em probabilidade/probabilidade forte.",
                                    "Discuta taxa de convergência: variância de θ_N = Var(f(X1))/N * vol(D)^2, cai como 1/√N.",
                                    "Simule em código: plote θ_N vs. N crescente, observe estabilização."
                                  ],
                                  "verification": "Gráfico de convergência θ_N para N=10 a 10^6, confirmando aproximação a I.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Python com loops para N crescente, planilha para dados.",
                                  "tips": "Use log-scale no eixo N para ver convergência lenta inicial.",
                                  "learningObjective": "Conectar o estimador à LLN para justificar precisão assintótica.",
                                  "commonMistakes": "Achar que Monte Carlo é exato para N finito; LLN é assintótica."
                                }
                              ],
                              "practicalExample": "Estimar a integral ∫_0^1 sin(πx) dx = 2/π ≈ 0.6366 usando Monte Carlo: gere N=10000 pontos uniformes em [0,1], compute média de sin(πXi), compare com valor exato.",
                              "finalVerifications": [
                                "Explicar em palavras próprias por que o estimador é não viesado.",
                                "Derivar E[θ_N] = I passo a passo.",
                                "Executar simulação numérica mostrando E[θ_N] próximo de I.",
                                "Plotar convergência θ_N vs. N e interpretar via LLN.",
                                "Calcular variância aproximada e discutir impacto de N.",
                                "Comparar com método determinístico como trapézio para mesma precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e formulação do estimador (correto uso de vol(D) e média).",
                                "Correção na prova de não viés (uso correto de expectativa).",
                                "Compreensão da LLN aplicada (convergência e i.i.d.).",
                                "Qualidade de simulações e visualizações (gráficos claros e interpretados).",
                                "Identificação de limitações (ex: variância alta para funções irregulares).",
                                "Clareza na explicação oral/escrita da relação conceitual."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Conceitos de expectativa, variância e LLN.",
                                "Programação Computacional: Implementação em Python/MATLAB para simulações.",
                                "Cálculo Numérico: Comparação com quadratura determinística.",
                                "Engenharia Civil: Aplicações em análise de riscos e simulações estocásticas."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usar Monte Carlo para estimar probabilidades de falha estrutural integrando distribuições de cargas e materiais sobre domínios complexos, como seções transversais irregulares de barragens."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.3",
                            "name": "Comparar com métodos determinísticos",
                            "description": "Discutir vantagens e desvantagens da integração Monte Carlo em relação a métodos como trapézio ou Simpson, especialmente para dimensões altas ou funções irregulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos dos Métodos Determinísticos",
                                  "subSteps": [
                                    "Estude a regra do trapézio: fórmula de integração numérica para intervalos uniformes e erro de truncamento O(h²).",
                                    "Analise a regra de Simpson: interpolação quadrática, erro O(h⁴), e limitações para funções não suaves.",
                                    "Discuta a 'maldição da dimensionalidade': explosão exponencial de pontos necessários em dimensões altas.",
                                    "Pratique com exemplos 1D simples, como ∫sin(x) dx de 0 a π.",
                                    "Identifique quando esses métodos falham: funções com descontinuidades ou picos irregulares."
                                  ],
                                  "verification": "Resuma em um quadro comparativo as fórmulas, erros e requisitos computacionais dos métodos trapézio e Simpson.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), calculadora ou Python/Jupyter para testes rápidos.",
                                  "tips": "Comece com 1D antes de pensar em múltiplas dimensões para construir intuição.",
                                  "learningObjective": "Compreender as bases matemáticas e limitações computacionais dos métodos determinísticos.",
                                  "commonMistakes": "Ignorar o custo exponencial em dims >3; assumir precisão uniforme para todas funções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Princípios da Integração Monte Carlo",
                                  "subSteps": [
                                    "Revise o princípio fundamental: média de f(X) onde X ~ uniforme no domínio, com variância reduzindo como 1/√N.",
                                    "Calcule o erro estatístico: desvio padrão / √N, independente da dimensão.",
                                    "Compare amostragem uniforme vs. importância para funções irregulares.",
                                    "Implemente um exemplo simples em 1D: ∫[0,1] x² dx usando 1000 amostras.",
                                    "Discuta convergência probabilística vs. determinística."
                                  ],
                                  "verification": "Execute uma simulação Monte Carlo em Python e plote a convergência do erro vs. N.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com NumPy/Matplotlib, ou MATLAB; tutorial online de Monte Carlo integration.",
                                  "tips": "Use seeds fixas para reprodutibilidade inicial, depois randomize.",
                                  "learningObjective": "Dominar como Monte Carlo transforma integração em problema de amostragem estatística.",
                                  "commonMistakes": "Confundir variância do estimador com bias; subestimar necessidade de muitas amostras para precisão alta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Complexidade Computacional e Precisão",
                                  "subSteps": [
                                    "Calcule custo: determinísticos ~ h^{-d} pontos em d dims; Monte Carlo ~ 1/ε² independente de d.",
                                    "Analise precisão para funções irregulares: determinísticos sofrem com oscilações, MC suaviza via média.",
                                    "Crie tabela: vantagens MC (dims altas, paralelizável, irregulares); desvantagens (lento para precisão, estocástico).",
                                    "Simule em 2D: integre f(x,y)=sin(πx)sin(πy) com ambos métodos.",
                                    "Discuta trade-offs: tempo vs. confiabilidade (intervalos de confiança em MC)."
                                  ],
                                  "verification": "Gere uma tabela comparativa com exemplos numéricos de tempo de CPU e erro para d=1,5,10.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Python/Octave para simulações multidimensionais; planilha Excel para tabelas.",
                                  "tips": "Meça tempo real com %timeit no Python para comparações justas.",
                                  "learningObjective": "Quantificar quando MC supera determinísticos em eficiência.",
                                  "commonMistakes": "Comparar sem normalizar pelo mesmo nível de precisão; ignorar overhead de geração de aleatórios."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Casos Específicos e Concluir",
                                  "subSteps": [
                                    "Foco dims altas: demonstre 'curse of dimensionality' com grade determinística vs. MC eficiente.",
                                    "Funções irregulares: teste com f(x)=1/|x-0.5| + ruído, compare falhas.",
                                    "Liste prós/cons: MC bom para protótipos rápidos em engenharia; determinísticos para baixa dim exata.",
                                    "Debata hibridizações: MC com quadratura em dims baixas.",
                                    "Prepare argumentos para discussão em sala."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo cenários onde MC é preferível, com evidências numéricas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Papel/caneta para esboços; código Python reutilizado dos steps anteriores.",
                                  "tips": "Use gráficos de erro vs. dimensão para visual impacto.",
                                  "learningObjective": "Aplicar comparações a contextos reais de engenharia civil computacional.",
                                  "commonMistakes": "Generalizar demais sem dados; esquecer variância em MC para funções de alta variância."
                                }
                              ],
                              "practicalExample": "Em uma simulação de carga de vento em uma estrutura 10D (fatores: velocidade, direção, rugosidade, etc.), use Monte Carlo para integrar a distribuição de probabilidade de falha (10^6 amostras, convergência rápida) vs. tentativa determinística que requeria 10^10 pontos inviáveis com trapézio multidimensional.",
                              "finalVerifications": [
                                "Pode listar pelo menos 3 vantagens do Monte Carlo sobre determinísticos em dims altas.",
                                "Executou simulação numérica comparando erros para uma função irregular em 4D.",
                                "Descreve corretamente a dependência dimensional do custo computacional.",
                                "Identifica cenários onde determinísticos ainda são superiores (ex: 1D suave).",
                                "Construí tabela ou gráfico de trade-offs precisão vs. tempo.",
                                "Explica intervalos de confiança em MC vs. erro garantido em determinísticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara entre erro determinístico/estatístico (30%).",
                                "Evidências quantitativas: uso de simulações/tabelas (25%).",
                                "Análise de cenários: foco em dims altas/irregulares (20%).",
                                "Clareza na discussão de prós/cons (15%).",
                                "Aplicação contextual a engenharia (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: variância, lei dos grandes números, intervalos de confiança.",
                                "Programação Computacional: implementação eficiente de loops e vetores em Python/MATLAB.",
                                "Probabilidade: geração de aleatórios multidimensionais e amostragem.",
                                "Análise Numérica: convergência de métodos quadratura."
                              ],
                              "realWorldApplication": "Na engenharia civil, para análise de confiabilidade de barragens sob cargas hidrológicas irregulares em múltiplas variáveis (vazão, sedimentos, sismos), Monte Carlo permite estimar probabilidades de falha rapidamente, onde métodos determinísticos como Simpson falham devido à dimensionalidade, otimizando projetos de segurança."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.2",
                        "name": "Geração e Uso de Amostras Aleatórias",
                        "description": "Técnicas para gerar números pseudoaleatórios uniformes e aplicá-los na avaliação da função integranda para estimar a integral.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.2.1",
                            "name": "Gerar amostras uniformes",
                            "description": "Implementar geração de N pontos aleatórios uniformes em [a,b] usando geradores de números aleatórios como rand() em linguagens como MATLAB ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Distribuição Uniforme e o Gerador rand()",
                                  "subSteps": [
                                    "Defina variável aleatória uniforme contínua em [0,1]: PDF constante f(x)=1 para x em [0,1].",
                                    "Estude a função rand() em MATLAB (rand()) ou Python (random.random()), que gera em [0,1).",
                                    "Verifique propriedades: independência entre chamadas, uniformidade estatística.",
                                    "Gere manualmente 10 amostras e observe a dispersão.",
                                    "Registre a diferença entre pseudo-aleatório e aleatório verdadeiro."
                                  ],
                                  "verification": "Responda quiz: 'Qual o valor esperado de rand()?' (resposta: 0.5) e descreva PDF.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de random (Python) ou rand (MATLAB)",
                                    "Notebook Jupyter ou MATLAB Online"
                                  ],
                                  "tips": "Sempre normalize para [0,1] primeiro antes de escalar.",
                                  "learningObjective": "Dominar os fundamentos teóricos da geração uniforme em [0,1].",
                                  "commonMistakes": [
                                    "Confundir uniforme com normal gaussiana",
                                    "Ignorar que rand() é [0,1) e não [0,1]",
                                    "Achar que é aleatório puro sem semente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Geração de N Amostras em [0,1]",
                                  "subSteps": [
                                    "Instale bibliotecas: import random e numpy em Python, ou use rand em MATLAB.",
                                    "Escreva função def gerar_uniforme(N): return [random.random() for _ in range(N)].",
                                    "Teste com N=100: armazene em lista ou array numpy.",
                                    "Configure semente para reprodutibilidade: random.seed(42).",
                                    "Gere e imprima as primeiras 5 amostras para inspeção."
                                  ],
                                  "verification": "Execute código e confirme que todas amostras estão em [0,1).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com numpy/random",
                                    "MATLAB ou Octave",
                                    "Editor de código (VSCode ou Spyder)"
                                  ],
                                  "tips": "Use numpy.random.uniform(0,1,N) para eficiência em grandes N.",
                                  "learningObjective": "Implementar código funcional para amostras uniformes em [0,1].",
                                  "commonMistakes": [
                                    "Esquecer import random",
                                    "Usar range(N) sem list comprehension",
                                    "Não definir semente para testes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escalar Amostras para Intervalo [a,b]",
                                  "subSteps": [
                                    "Lembre fórmula: X = a + (b-a) * U, onde U ~ Uniforme[0,1].",
                                    "Modifique função: def uniforme_ab(N, a, b): U = gerar_uniforme(N); return [a + (b-a)*u for u in U].",
                                    "Teste com a=2, b=5, N=50: verifique min≈2, max≈5.",
                                    "Implemente em vetor: numpy: (b-a)*U + a.",
                                    "Compare estatísticas: média deve ser (a+b)/2."
                                  ],
                                  "verification": "Calcule média e desv. padrão; média deve estar próxima de (a+b)/2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código do Step 2",
                                    "Biblioteca numpy para estatísticas"
                                  ],
                                  "tips": "Evite overflow em intervalos grandes; use float64.",
                                  "learningObjective": "Aplicar transformação linear para qualquer [a,b].",
                                  "commonMistakes": [
                                    "Erro na fórmula: usar b-a em vez de (b-a)*U + a",
                                    "Inverter a e b",
                                    "Não vetorizar para performance"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Visualizar a Uniformidade",
                                  "subSteps": [
                                    "Gere N=10000 amostras em [0,10].",
                                    "Crie histograma: plt.hist(amostras, bins=50, density=True).",
                                    "Calcule estatísticas: np.mean(), np.std(), teste KS para uniformidade.",
                                    "Compare com teórico: var=(b-a)^2/12.",
                                    "Salve plot e relatório de stats."
                                  ],
                                  "verification": "Histograma visualmente plano; KS p-value >0.05.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "matplotlib ou MATLAB plot",
                                    "scipy.stats para KS test"
                                  ],
                                  "tips": "Aumente N para melhor aproximação; bins≈sqrt(N).",
                                  "learningObjective": "Validar empiricamente a uniformidade gerada.",
                                  "commonMistakes": [
                                    "Poucos bins no histograma",
                                    "Ignorar normalização density=True",
                                    "N muito pequeno para testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python, gere 5000 amostras uniformes em [0, 100] para simular cargas distribuídas aleatoriamente (kN/m) em uma viga de concreto; plote histograma e verifique média ≈50 kN/m.",
                              "finalVerifications": [
                                "Todas amostras estão estritamente em [a,b].",
                                "Média empírica próxima a (a+b)/2 (erro <1% para N>1000).",
                                "Histograma visualmente uniforme sem picos.",
                                "Desvio padrão próximo a (b-a)/sqrt(12).",
                                "Teste de Kolmogorov-Smirnov aceita H0 de uniformidade (p>0.05).",
                                "Código roda sem erros para N=10^6.",
                                "Reprodutível com semente fixa."
                              ],
                              "assessmentCriteria": [
                                "Código completo e comentado corretamente (função escalável).",
                                "Transformação linear implementada sem erros matemáticos.",
                                "Visualizações (histograma) claras e interpretadas.",
                                "Estatísticas calculadas e comparadas com teóricas.",
                                "Testes de uniformidade realizados adequadamente.",
                                "Eficiência: vetorizado para grandes N."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: propriedades de distribuições.",
                                "Programação Computacional: vetores, loops, bibliotecas numéricas.",
                                "Engenharia Civil: simulações Monte Carlo para cargas incertas.",
                                "Análise Numérica: base para integração e otimização estocástica.",
                                "Visualização de Dados: gráficos e análise exploratória."
                              ],
                              "realWorldApplication": "Na engenharia civil, gera amostras uniformes para simulações Monte Carlo em integração numérica, estimando áreas de seções transversais irregulares ou probabilidades de falha em estruturas sob cargas aleatórias, otimizando projetos de pontes e edifícios."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.5.2.2",
                            "name": "Avaliar função em amostras",
                            "description": "Calcular a média das avaliações de f(xi) para xi gerados aleatoriamente e multiplicar pelo comprimento do intervalo para obter a estimativa da integral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar a função f em cada ponto amostral xi",
                                  "subSteps": [
                                    "Identifique o intervalo de integração [a, b] e a função f(x) a ser avaliada.",
                                    "Liste todos os pontos xi gerados aleatoriamente no intervalo [a, b].",
                                    "Para cada xi, substitua no expressão de f(x) e calcule f(xi) individualmente.",
                                    "Registre todos os valores f(xi) em uma tabela ou array para organização.",
                                    "Verifique cálculos iniciais com pontos conhecidos para garantir precisão."
                                  ],
                                  "verification": "Compare f(xi) calculados com valores esperados para 2-3 pontos de teste; todos devem coincidir dentro de tolerância de 0.001.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Lista de pontos xi gerados",
                                    "Definição da função f(x)",
                                    "Calculadora, planilha (Excel) ou software (Python/MATLAB)"
                                  ],
                                  "tips": "Use funções vetorizadas em software (ex: f = np.sin(xis) no NumPy) para eficiência com grandes N.",
                                  "learningObjective": "Computar com precisão os valores da função f nos pontos amostrais aleatórios.",
                                  "commonMistakes": [
                                    "Substituir incorretamente xi na função f",
                                    "Usar pontos fora do intervalo [a,b]",
                                    "Arredondar prematuramente causando perda de precisão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a média das avaliações f(xi)",
                                  "subSteps": [
                                    "Some todos os valores f(xi) obtidos na etapa anterior para obter a soma total S.",
                                    "Conte o número total de amostras N.",
                                    "Calcule a média como média = S / N.",
                                    "Registre a média com precisão adequada (ex: 4 casas decimais).",
                                    "Repita o cálculo manualmente para subconjunto pequeno para validação."
                                  ],
                                  "verification": "Verifique se soma S está correta somando manualmente um subconjunto; média deve igualar S/N exatamente.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Lista de f(xi) da etapa 1",
                                    "Calculadora ou software para soma e divisão"
                                  ],
                                  "tips": "Em programação, use funções built-in como np.mean(f_xi) para evitar erros aritméticos.",
                                  "learningObjective": "Aplicar a fórmula estatística da média aritmética às avaliações funcionais.",
                                  "commonMistakes": [
                                    "Confundir soma com média",
                                    "Dividir por N-1 em vez de N (viés amostral)",
                                    "Ignorar zeros ou valores negativos na soma"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar a integral multiplicando a média pelo comprimento do intervalo",
                                  "subSteps": [
                                    "Determine o comprimento do intervalo L = b - a.",
                                    "Multiplique a média pela largura: estimativa = média * L.",
                                    "Registre o resultado final com unidades apropriadas se aplicável.",
                                    "Compare com valor analítico conhecido (se disponível) para avaliar precisão.",
                                    "Documente o erro relativo: |estimativa - valor_real| / |valor_real|."
                                  ],
                                  "verification": "Cálculo final deve coincidir com média * L; erro relativo < 5% para N > 1000.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Média calculada",
                                    "Valores de a e b",
                                    "Valor analítico opcional para referência"
                                  ],
                                  "tips": "Sempre confirme L = b - a; para intervalos não-unitários, isso escala corretamente a estimativa.",
                                  "learningObjective": "Finalizar a estimativa da integral via fórmula do método Monte Carlo.",
                                  "commonMistakes": [
                                    "Esquecer de multiplicar pela largura L",
                                    "Usar L=1 por default",
                                    "Confundir estimativa com valor exato"
                                  ]
                                }
                              ],
                              "practicalExample": "Para estimar ∫_0^π sin(x) dx (valor real ≈ 2.0) com N=1000 xi ~ Uniform[0, π]: Calcule sin(xi) para cada, média ≈ 0.637, L=π≈3.1416, estimativa ≈ 0.637 * 3.1416 ≈ 2.00 (boa aproximação). Implemente em Python: import numpy as np; xi = np.random.uniform(0, np.pi, 1000); f_xi = np.sin(xi); media = np.mean(f_xi); integral = media * np.pi.",
                              "finalVerifications": [
                                "Todos f(xi) foram calculados corretamente sem erros aritméticos evidentes.",
                                "Soma S e N levam à média precisa (verificada por recálculo).",
                                "Comprimento L = b - a está correto.",
                                "Estimativa final = média * L coincide com implementação independente.",
                                "Erro relativo em relação a valor conhecido é razoável para o N usado.",
                                "Documentação inclui todos valores intermediários."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de f(xi): 100% corretos em amostra aleatória.",
                                "Correta aplicação da fórmula de média: soma/N exata.",
                                "Escalamento pelo comprimento do intervalo sem omissões.",
                                "Interpretação da estimativa como aproximação Monte Carlo.",
                                "Eficiência no uso de ferramentas computacionais.",
                                "Análise de erro e discussão de convergência com N."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceito de média amostral e lei dos grandes números.",
                                "Programação: Vetorização e funções numpy/matlab para arrays.",
                                "Probabilidade: Distribuição uniforme e integração como expectativa.",
                                "Cálculo: Relação com integral definida como área sob curva.",
                                "Engenharia Computacional: Simulações numéricas em problemas reais."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para estimar volumes de aterros irregulares ou áreas de terrenos complexos gerando amostras aleatórias via GPS/drone, avaliando função de altura/profundidade, e escalando pela área/base – essencial em projetos de barragens, estradas e modelagem hidráulica onde formas analíticas são inviáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.5.2.3",
                            "name": "Implementar algoritmo básico",
                            "description": "Escrever pseudocódigo ou código simples para integração Monte Carlo de uma função univariada, testando com integrais conhecidas como ∫ sin(x) dx de 0 a π.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Desenvolver pseudocódigo para integração Monte Carlo",
                                  "subSteps": [
                                    "Defina os parâmetros: limites de integração a e b, função f(x), número de amostras N (ex: 10.000)",
                                    "Descreva geração de N pontos x_i uniformemente distribuídos em [a, b] usando random.uniform(a, b)",
                                    "Calcule a soma dos valores f(x_i) para todos os i",
                                    "Estime a integral como (b - a) * (soma / N)",
                                    "Inclua inicialização de soma = 0 e loop para acumular valores"
                                  ],
                                  "verification": "Pseudocódigo escrito em papel ou editor de texto, lido em voz alta para confirmar lógica sem erros conceituais",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto simples",
                                    "Referência ao método Monte Carlo para integração univariada"
                                  ],
                                  "tips": "Estruture como uma função clara com entradas e saídas; teste mentalmente com N=1",
                                  "learningObjective": "Compreender e formalizar a lógica probabilística do método de Monte Carlo para aproximação de integrais",
                                  "commonMistakes": [
                                    "Esquecer o fator (b-a)",
                                    "Usar distribuição não-uniforme para x_i",
                                    "Dividir soma por N antes de multiplicar por (b-a) incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o algoritmo em código Python simples",
                                  "subSteps": [
                                    "Importe o módulo random (import random)",
                                    "Defina a função f(x), ex: def f(x): return math.sin(x) (importe math também)",
                                    "Crie a função monte_carlo_integral(f, a, b, N) com loop for i in range(N): x = random.uniform(a, b); soma += f(x)",
                                    "Retorne (b - a) * (soma / N)",
                                    "Adicione comentários explicando cada linha"
                                  ],
                                  "verification": "Código salvo em arquivo .py, executado no terminal sem erros de sintaxe (python arquivo.py)",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3 instalado",
                                    "Editor de código como VS Code ou IDLE",
                                    "Bibliotecas padrão: random e math"
                                  ],
                                  "tips": "Use range(N) para o loop; evite bibliotecas extras como numpy para manter simples",
                                  "learningObjective": "Traduzir pseudocódigo em código executável, praticando programação funcional",
                                  "commonMistakes": [
                                    "Erro de indentação no loop",
                                    "Não importar random ou math",
                                    "Variável soma não inicializada como 0.0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar o algoritmo com integral conhecida ∫ sin(x) dx de 0 a π",
                                  "subSteps": [
                                    "Chame a função: resultado = monte_carlo_integral(f, 0, math.pi, 10000)",
                                    "Imprima o resultado e compare com o valor exato (2)",
                                    "Execute múltiplas vezes (ex: 5 runs) e calcule média e desvio",
                                    "Aumente N para 100.000 e observe melhoria na precisão",
                                    "Registre erros percentuais: abs(resultado - 2)/2 * 100"
                                  ],
                                  "verification": "Resultados impressos mostram aproximação dentro de 1-5% do valor exato para N=10.000",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal ou Jupyter Notebook",
                                    "Código do passo anterior"
                                  ],
                                  "tips": "Use print(f'Resultado: {resultado:.4f}, Erro: {erro:.2f}%') para clareza",
                                  "learningObjective": "Validar implementação através de testes empíricos com benchmark conhecido",
                                  "commonMistakes": [
                                    "Usar math.pi sem importar math",
                                    "N muito pequeno causando alta variância",
                                    "Comparar sem calcular erro relativo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar precisão e refinar o algoritmo",
                                  "subSteps": [
                                    "Execute 10 simulações com N fixo e calcule média, variância e intervalo de confiança (aprox. std/sqrt(N))",
                                    "Teste com outra função simples, ex: f(x)=x^2 de 0 a 1 (exato=1/3)",
                                    "Adicione seed para reproducibilidade: random.seed(42)",
                                    "Discuta convergência: plote erro vs log(N) se possível (opcional com matplotlib)",
                                    "Documente limitações: lentidão para alta precisão"
                                  ],
                                  "verification": "Relatório curto escrito com tabela de resultados, mostrando convergência com N crescente",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "Planilha ou papel para tabelas",
                                    "Opcional: matplotlib para gráficos"
                                  ],
                                  "tips": "Para variância, some (f(x_i) - media)^2 / (N-1)",
                                  "learningObjective": "Avaliar robustez numérica e entender trade-offs de precisão vs custo computacional",
                                  "commonMistakes": [
                                    "Ignorar variância aleatória",
                                    "Não usar seed para testes repetíveis",
                                    "Confundir erro bias com variância"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o algoritmo para estimar ∫_0^π sin(x) dx (valor exato: 2). Com N=10.000, resultados típicos ficam entre 1.95 e 2.05; rode 5 vezes e média deve ser ~2.00 com erro <1%.",
                              "finalVerifications": [
                                "Pseudocódigo lógico e completo sem falhas conceituais",
                                "Código Python executa sem erros e produz saída numérica válida",
                                "Teste com sin(x) converge para 2 com erro relativo <2% para N=50.000",
                                "Múltiplas runs mostram variância esperada e média estável",
                                "Documentação inclui comentários e análise de erros",
                                "Algoritmo testado com segunda função (ex: x^2) corretamente"
                              ],
                              "assessmentCriteria": [
                                "Correção algorítmica: uso correto de uniforme e média ponderada (30%)",
                                "Precisão numérica: erro <5% em testes padrão (25%)",
                                "Clareza do código: comentários, estrutura e legibilidade (20%)",
                                "Análise de resultados: cálculo de erros e variância (15%)",
                                "Refinamentos: seed, testes múltiplos e discussão de limitações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: teorema do limite central e variáveis aleatórias uniformes",
                                "Programação Computacional: implementação de loops, funções e simulações estocásticas",
                                "Cálculo e Análise Numérica: aproximações de integrais definidas",
                                "Engenharia Civil: simulações para otimização de estruturas e análise de riscos probabilísticos"
                              ],
                              "realWorldApplication": "Na engenharia civil, usar Monte Carlo para estimar volumes de concreto em formas irregulares de fundações ou barragens, integrar cargas distribuídas variáveis ou calcular probabilidades de falha em solos heterogêneos onde soluções analíticas são inviáveis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.3",
                        "name": "Análise de Erro e Precisão",
                        "description": "Avaliação da variância do estimador, intervalo de confiança e estratégias para melhorar a precisão na integração Monte Carlo.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.3.1",
                            "name": "Calcular variância do estimador",
                            "description": "Derivar e computar a variância do estimador Monte Carlo como Var(f)/N, onde Var(f) é a variância da função no intervalo, e explicar a convergência em O(1/sqrt(N)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Estimador Monte Carlo para Integração Numérica",
                                  "subSteps": [
                                    "Lembre-se da fórmula do estimador Monte Carlo: I ≈ (b-a)/N * Σ f(X_i), onde X_i ~ Uniform(a,b).",
                                    "Identifique os componentes: função f, intervalo [a,b], amostras N independentes.",
                                    "Entenda que o estimador é a média amostral escalada pela largura do intervalo.",
                                    "Discuta propriedades: imparcialidade (E[estimador] = I exata) e consistência.",
                                    "Esboce um exemplo simples com f(x) = x^2 em [0,1]."
                                  ],
                                  "verification": "Escreva a fórmula do estimador corretamente e compute manualmente para N=5 amostras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora, notebook Jupyter com NumPy.",
                                  "tips": "Visualize o processo gerando pontos aleatórios uniformes e avaliando f neles.",
                                  "learningObjective": "Compreender a base probabilística do estimador Monte Carlo.",
                                  "commonMistakes": "Confundir a média amostral com a integral diretamente; esquecer o fator (b-a)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Variância Teórica do Estimador",
                                  "subSteps": [
                                    "Comece com Var(estimador) = Var( (b-a)/N * Σ f(X_i) ) = (b-a)^2 / N * Var(f(X_1)), pois independentes.",
                                    "Simplifique para Var(f)/N, onde Var(f) = E[f^2] - (E[f])^2 no intervalo uniforme.",
                                    "Mostre que E[f] = integral f(x)/(b-a) dx, a integral verdadeira.",
                                    "Derive E[f^2] = integral f(x)^2 /(b-a) dx.",
                                    "Conclua que Var(estimador) = [integral f^2 - (integral f)^2] / [N (b-a)]."
                                  ],
                                  "verification": "Derive a fórmula passo a passo em um caderno e verifique com um caso conhecido como f(x)=x em [0,1].",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta, tabela de integrais básicas.",
                                  "tips": "Use propriedades de variância de soma de independentes: Var(Σ) = Σ Var.",
                                  "learningObjective": "Derivar analiticamente a variância do estimador Monte Carlo.",
                                  "commonMistakes": "Esquecer o fator (b-a)^2 na variância; confundir E[f^2] com [E[f]]^2."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Cálculo Numérico da Variância",
                                  "subSteps": [
                                    "Gere N amostras uniformes em [a,b] usando np.random.uniform.",
                                    "Compute f(X_i) e a média amostral.",
                                    "Calcule a variância amostral de f(X_i): np.var(samples, ddof=1).",
                                    "Estime Var(estimador) ≈ variância_amostral_f / N.",
                                    "Compare com variância teórica se conhecida."
                                  ],
                                  "verification": "Execute código para f(x)=sin(x) em [0,π], imprima Var(estimador) para N=1000.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com NumPy e Matplotlib, Jupyter Notebook.",
                                  "tips": "Use ddof=1 para variância não viesada; plote histograma de f(X_i) para visualizar.",
                                  "learningObjective": "Computar empiricamente a variância usando simulações.",
                                  "commonMistakes": "Usar variância populacional (ddof=0) em vez de amostral; N muito pequeno para precisão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Convergência e Taxa de Erro",
                                  "subSteps": [
                                    "Explique que erro padrão é sqrt(Var(estimador)) = O(1/sqrt(N)).",
                                    "Simule para N=10^k, k=1..5, e plote erro vs 1/sqrt(N).",
                                    "Verifique linearidade no log-log plot.",
                                    "Discuta implicações: para precisão ε, N ~ 1/ε^2.",
                                    "Relacione com CLT: distribuição ~ Normal para N grande."
                                  ],
                                  "verification": "Gere gráfico de erro padrão vs 1/sqrt(N) mostrando inclinação -0.5.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com NumPy, Matplotlib; 100 repetições por N.",
                                  "tips": "Média sobre múltiplas runs para suavizar variância; use logscale no plot.",
                                  "learningObjective": "Explicar e demonstrar a convergência O(1/sqrt(N)) do Monte Carlo.",
                                  "commonMistakes": "Confundir variância com erro padrão; ignorar flutuações para N pequeno."
                                }
                              ],
                              "practicalExample": "Para estimar ∫_0^1 x^2 dx = 1/3 usando Monte Carlo com N=10000: gere X_i ~ U(0,1), compute média de X_i^2, Var(f) ≈ 0.08, então Var(estimador) ≈ 0.08/10000 = 8e-6, erro std ≈ 0.003, convergindo como 1/sqrt(N).",
                              "finalVerifications": [
                                "Derivação da fórmula Var(f)/N está correta e completa.",
                                "Código Python computa variância empiricamente com precisão <5% do teórico.",
                                "Gráfico de convergência mostra inclinação -0.5 em log-log.",
                                "Explicação verbal da taxa O(1/sqrt(N)) inclui CLT.",
                                "Teste com duas funções diferentes (ex: sin(x), exp(x)) confirma generalidade.",
                                "Documentação inclui N necessário para erro <0.01."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação matemática (fórmulas corretas, passos lógicos).",
                                "Correção do código: variância empirica converge para teórica.",
                                "Qualidade dos gráficos: eixos rotulados, legenda, evidência visual de O(1/sqrt(N)).",
                                "Profundidade da análise: discute limitações e melhorias (ex: antithetic variates).",
                                "Clareza da explicação: acessível, sem erros conceituais.",
                                "Eficiência computacional: código otimizado, tempos razoáveis."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Teorema Central do Limite e variância amostral.",
                                "Programação: Simulações numéricas com Python/NumPy.",
                                "Probabilidade: Distribuições uniformes e independência.",
                                "Engenharia Civil: Análise de incertezas em cargas aleatórias ou solos."
                              ],
                              "realWorldApplication": "Em engenharia civil, calcular variância do estimador Monte Carlo para integrar propriedades de materiais heterogêneos (ex: módulo de elasticidade variável) em simulações de estruturas, determinando N mínimo para precisão em análises de risco sísmico ou fadiga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.5.3.2",
                            "name": "Estimar intervalo de confiança",
                            "description": "Usar o teorema central do limite para calcular intervalos de confiança aproximados (ex: média ± 1.96 * desvio padrão / sqrt(N)) e interpretá-los.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Teorema Central do Limite (TCL)",
                                  "subSteps": [
                                    "Revise a declaração do TCL: a distribuição da média amostral aproxima-se de uma normal para N grande, independentemente da distribuição original.",
                                    "Identifique condições: amostras independentes, N ≥ 30, variância finita.",
                                    "Relacione com Monte Carlo: múltiplas simulações geram amostras para estimar integral.",
                                    "Discuta implicações para intervalos de confiança aproximados.",
                                    "Exemplo simples: role uma moeda 1000x e veja a distribuição das médias."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como o TCL justifica ICs em Monte Carlo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notebook com Python/Jupyter",
                                    "Documentação do TCL (Wikipedia ou livro-texto)"
                                  ],
                                  "tips": "Visualize com histogramas da soma de variáveis para intuitar a normalidade.",
                                  "learningObjective": "Entender os fundamentos teóricos que suportam a aproximação normal para ICs.",
                                  "commonMistakes": [
                                    "Ignorar N pequeno (leva a aproximações ruins)",
                                    "Confundir variância populacional com amostral"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Estatísticas Descritivas da Amostra Monte Carlo",
                                  "subSteps": [
                                    "Gere N simulações Monte Carlo para o integrando (ex: pontos aleatórios no hipercubo).",
                                    "Calcule a média amostral (μ̂ = soma(estimativas)/N).",
                                    "Calcule o desvio padrão amostral (σ̂ = sqrt( soma((xi - μ̂)^2)/(N-1) ) ).",
                                    "Verifique N grande (ex: 10^4 ou mais) para validade do TCL.",
                                    "Armazene em arrays para análise."
                                  ],
                                  "verification": "Confirme valores numéricos com print() e compare com valores esperados teóricos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Código base de Monte Carlo para integração"
                                  ],
                                  "tips": "Use np.mean() e np.std(ddof=1) para precisão amostral.",
                                  "learningObjective": "Dominar o cálculo de μ̂ e σ̂ a partir de simulações.",
                                  "commonMistakes": [
                                    "Usar desvio padrão populacional (ddof=0) em vez de amostral",
                                    "N insuficiente levando a σ̂ instável"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Intervalo de Confiança Aproximado",
                                  "subSteps": [
                                    "Calcule o erro padrão: SE = σ̂ / sqrt(N).",
                                    "Escolha z-score: 1.96 para 95% de confiança (de tabela normal padrão).",
                                    "Compute limites: limite_inferior = μ̂ - 1.96 * SE; limite_superior = μ̂ + 1.96 * SE.",
                                    "Formate o IC como [limite_inferior, limite_superior].",
                                    "Repita para diferentes níveis de confiança (ex: 90% z=1.645)."
                                  ],
                                  "verification": "O comprimento do IC diminui com sqrt(N) crescente; teste dobrando N.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python estendido",
                                    "Tabela de z-scores"
                                  ],
                                  "tips": "Automatize com função def confidence_interval(mean, std, n, z=1.96).",
                                  "learningObjective": "Aplicar fórmula prática do IC via TCL.",
                                  "commonMistakes": [
                                    "Esquecer sqrt(N) no SE",
                                    "Usar z=1 em vez de 1.96"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Validar o Intervalo de Confiança",
                                  "subSteps": [
                                    "Explique: com 95% confiança, o valor verdadeiro está no IC em 95% das repetições.",
                                    "Avalie precisão: largura do IC indica erro (menor com mais N).",
                                    "Compare com valor analítico conhecido (ex: integral exata).",
                                    "Discuta trade-offs: mais N melhora precisão mas aumenta tempo computacional.",
                                    "Gere gráfico: IC vs. N para visualizar convergência."
                                  ],
                                  "verification": "Interprete corretamente: '95% das simulações futuras terão μ̂ no IC do verdadeiro valor'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "Valor exato da integral para benchmark"
                                  ],
                                  "tips": "Simule 100 ICs e veja quantos cobrem o verdadeiro (deve ~95%).",
                                  "learningObjective": "Interpretar ICs probabilisticamente no contexto de precisão Monte Carlo.",
                                  "commonMistakes": [
                                    "Interpretar como probabilidade do valor verdadeiro dado IC (é fixo!)",
                                    "Ignorar custo computacional de N grande"
                                  ]
                                }
                              ],
                              "practicalExample": "Em simulação Monte Carlo para integral ∫_0^1 x^2 dx = 1/3 (~0.333), gere 10.000 pontos aleatórios [X,Y] em [0,1]x[0,1]; estimativa = média(Y < x^2). Suponha μ̂=0.334, σ̂=0.0047, N=10k → SE=0.00047, IC95%=[0.3332, 0.3348], contendo 1/3.",
                              "finalVerifications": [
                                "IC calculado coincide com fórmula manual.",
                                "Largura do IC diminui com N maior.",
                                "95% dos ICs bootstrap cobrem valor verdadeiro.",
                                "Interpretação escrita correta sem erros probabilísticos.",
                                "Código roda sem erros e produz plots.",
                                "Comparação com integral exata dentro do IC."
                              ],
                              "assessmentCriteria": [
                                "Correção na aplicação do TCL e escolha de N.",
                                "Precisão nos cálculos de μ̂, σ̂ e SE.",
                                "Uso correto de z-score e formatação do IC.",
                                "Interpretação probabilística precisa.",
                                "Análise de sensibilidade a N e visualizações.",
                                "Código limpo, comentado e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial (distribuições assintóticas).",
                                "Programação Numérica (NumPy para simulações).",
                                "Análise Numérica (convergência de métodos estocásticos).",
                                "Engenharia de Confiabilidade (quantificação de incertezas)."
                              ],
                              "realWorldApplication": "Na engenharia civil, estima incertezas em simulações Monte Carlo para previsão de deflexões em vigas sob cargas aleatórias (vento/sísmicas), dimensionamento seguro de pontes ou análise de durabilidade de concreto sob fadiga estocástica, garantindo projetos com níveis de confiança definidos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.5.3.3",
                            "name": "Aplicar em problemas de engenharia civil",
                            "description": "Aplicar o método para estimar áreas sob curvas de cargas probabilísticas ou volumes em problemas geotécnicos, avaliando precisão com diferentes N.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o Problema de Engenharia Civil",
                                  "subSteps": [
                                    "Identifique o problema específico, como estimar área sob curva de carga probabilística ou volume em escavação geotécnica.",
                                    "Defina a função integrando f(x) com limites de integração claros.",
                                    "Especifique as distribuições probabilísticas das variáveis (ex.: normal para cargas, uniforme para dimensões).",
                                    "Determine os parâmetros iniciais: média, desvio padrão, limites.",
                                    "Esboce o modelo matemático da integral a ser aproximada."
                                  ],
                                  "verification": "Documento com formulação completa: f(x), limites, distribuições e modelo matemático revisado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta para esboços",
                                    "Software de programação (Python com NumPy/SciPy ou MATLAB)",
                                    "Referências de problemas geotécnicos"
                                  ],
                                  "tips": "Use diagramas para visualizar o problema e valide com literatura de engenharia civil.",
                                  "learningObjective": "Formular precisamente problemas de integração numérica em contextos reais de engenharia civil com elementos probabilísticos.",
                                  "commonMistakes": [
                                    "Escolher distribuições inadequadas para o fenômeno físico",
                                    "Ignorar correlações entre variáveis geotécnicas",
                                    "Definir limites de integração incorretos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Algoritmo de Monte Carlo",
                                  "subSteps": [
                                    "Gere amostras aleatórias das distribuições definidas usando funções rand (ex.: np.random.normal).",
                                    "Calcule f(x) para cada amostra gerada.",
                                    "Some os valores de f(x) e divida pelo número de simulações N para obter a estimativa da integral.",
                                    "Implemente uma função reutilizável para diferentes N.",
                                    "Teste com N pequeno para depuração inicial."
                                  ],
                                  "verification": "Código executável que produz estimativa para N=100 sem erros.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ambiente de programação (Jupyter Notebook/Python)",
                                    "Bibliotecas: NumPy, SciPy, Matplotlib"
                                  ],
                                  "tips": "Vetorize operações para eficiência; use seeds para reprodutibilidade.",
                                  "learningObjective": "Codificar o método de Monte Carlo para integração numérica de forma eficiente e correta.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar pela área do domínio de integração",
                                    "Usar geradores de aleatórios sem seed para testes",
                                    "Acumular erros numéricos em somas grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Simulações com Diferentes Valores de N",
                                  "subSteps": [
                                    "Execute o código para N=100, 1.000, 10.000 e 100.000 simulações.",
                                    "Registre as estimativas de integral para cada N.",
                                    "Calcule estatísticas descritivas: média, desvio padrão das estimativas (rode múltiplas vezes se necessário).",
                                    "Gere gráficos de convergência (estimativa vs. log(N)).",
                                    "Compare com valor analítico exato se disponível."
                                  ],
                                  "verification": "Tabela e gráficos salvos mostrando estimativas e convergência para todos N.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Mesmo ambiente de programação",
                                    "Ferramentas de plotagem (Matplotlib/Plotly)"
                                  ],
                                  "tips": "Aumente N gradualmente para observar estabilização; paralelize se possível.",
                                  "learningObjective": "Executar e visualizar o impacto do número de simulações na aproximação.",
                                  "commonMistakes": [
                                    "Não logar N corretamente nos eixos",
                                    "Ignorar tempo de computação para N muito alto",
                                    "Confundir variância da estimativa com erro de viés"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Erro e Precisão da Aproximação",
                                  "subSteps": [
                                    "Calcule o erro relativo: |estimativa - valor exato| / valor exato para cada N.",
                                    "Avalie a convergência: verifique se erro diminui como 1/sqrt(N).",
                                    "Analise intervalos de confiança (média ± 2*desvio/sqrt(N)).",
                                    "Interprete resultados no contexto geotécnico (ex.: precisão aceitável para projetos).",
                                    "Documente recomendações de N mínimo para aplicações civis."
                                  ],
                                  "verification": "Relatório com cálculos de erro, gráficos e conclusões sobre precisão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilhas ou código para cálculos de erro",
                                    "Templates de relatório LaTeX/Word"
                                  ],
                                  "tips": "Use regressão linear para confirmar taxa de convergência 1/sqrt(N).",
                                  "learningObjective": "Quantificar e interpretar a precisão do Monte Carlo em problemas de engenharia.",
                                  "commonMistakes": [
                                    "Usar valor exato incorreto como referência",
                                    "Subestimar variância em distribuições assimétricas",
                                    "Generalizar N sem contexto de tolerância de erro"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Refinar a Aplicação",
                                  "subSteps": [
                                    "Compare resultados com métodos alternativos (ex.: Simpson ou Gauss).",
                                    "Teste sensibilidade a parâmetros probabilísticos.",
                                    "Ajuste o modelo se erro não convergir adequadamente.",
                                    "Prepare apresentação dos resultados com visualizações.",
                                    "Discuta limitações e melhorias futuras."
                                  ],
                                  "verification": "Validação cruzada com outro método e relatório final revisado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Códigos de métodos determinísticos",
                                    "Ferramentas de apresentação (PowerPoint/Beamer)"
                                  ],
                                  "tips": "Sempre valide com benchmarks conhecidos antes de aplicações reais.",
                                  "learningObjective": "Refinar e validar a solução Monte Carlo para robustez em engenharia civil.",
                                  "commonMistakes": [
                                    "Aceitar convergência sem validação externa",
                                    "Ignorar custos computacionais em projetos reais",
                                    "Sobreestimar precisão sem intervalos de confiança"
                                  ]
                                }
                              ],
                              "practicalExample": "Estime o volume esperado de solo a ser escavado em uma fundação onde a profundidade h segue N(5m, 0.5m) e a área base A segue Uniforme(100m², 120m²). Integral: E[Volume] = ∫ h * A * pdf(h,a) dh da. Rode Monte Carlo com N variando de 10³ a 10⁵ e avalie erro relativo vs. valor exato.",
                              "finalVerifications": [
                                "Código roda para todos N sem crashes.",
                                "Estimativas convergem monotonicamente com N crescente.",
                                "Erro relativo <5% para N=10.000.",
                                "Gráficos mostram taxa 1/sqrt(N).",
                                "Intervalos de confiança encolhem adequadamente.",
                                "Resultados interpretados corretamente no contexto civil.",
                                "Relatório completo com todas análises."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro relativo diminui com N (obrigatório <10% para N=10⁴).",
                                "Eficiência: tempo de execução razoável e escalável.",
                                "Visualizações claras de convergência e erro.",
                                "Interpretação correta de precisão para engenharia.",
                                "Código limpo, comentado e reprodutível.",
                                "Validação com método alternativo.",
                                "Documentação de limitações e N recomendado."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: análise de variância e convergência.",
                                "Programação Computacional: implementação numérica eficiente.",
                                "Geotecnia: modelagem probabilística de solos e cargas.",
                                "Análise Numérica: comparação com quadratura determinística.",
                                "Gestão de Projetos: avaliação custo-benefício de precisão vs. N."
                              ],
                              "realWorldApplication": "Em projetos de barragens ou fundações, o método estima volumes de aterro ou riscos de sobrecarga sob cargas probabilísticas (vento/sísmicas), permitindo dimensionamento seguro com N otimizado para precisão de 2-5%, reduzindo custos excessivos de simulações."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.6",
                    "name": "Simulações Estocásticas em Engenharia",
                    "description": "Uso do Monte Carlo em problemas de engenharia civil, como análise de confiabilidade estrutural.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.6.1",
                        "name": "Geração de Números Aleatórios",
                        "description": "Conceitos fundamentais para gerar sequências de números pseudoaleatórios utilizados como base para simulações estocásticas em problemas de engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.6.1.1",
                            "name": "Implementar gerador linear congruencial",
                            "description": "Desenvolver e programar um gerador de números pseudoaleatórios baseado no método linear congruencial, aplicando parâmetros adequados para simulações em análise estrutural, garantindo uniformidade e independência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a teoria do Gerador Linear Congruencial (LCG)",
                                  "subSteps": [
                                    "Estudar a fórmula básica: X_{n+1} = (a * X_n + c) mod m",
                                    "Identificar e explicar os parâmetros: m (módulo), a (multiplicador), c (incremento), X_0 (semente)",
                                    "Analisar condições para período completo (teorema de Hull-Dobell): gcd(c, m)=1, a-1 divisível por todos os fatores primários de m, etc.",
                                    "Discutir propriedades desejadas: uniformidade na distribuição [0,1] e independência serial",
                                    "Examinar exemplos numéricos manuais de 10 iterações com parâmetros ruins e bons"
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando a fórmula, parâmetros e condições para bom LCG, com um exemplo manual resolvido.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notebook e caneta",
                                    "Artigo ou capítulo sobre LCG (ex: Knuth 'The Art of Computer Programming')",
                                    "Calculadora ou Python para cálculos manuais"
                                  ],
                                  "tips": "Desenhe fluxogramas para visualizar iterações e use cores para destacar parâmetros.",
                                  "learningObjective": "Dominar os fundamentos matemáticos do LCG e critérios para geração de pseudoaleatórios de qualidade.",
                                  "commonMistakes": [
                                    "Confundir 'mod m' com divisão comum",
                                    "Ignorar gcd(c,m)=1 levando a período curto",
                                    "Escolher m não potência de 2 ou primo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar parâmetros adequados para aplicações em engenharia",
                                  "subSteps": [
                                    "Escolher m grande (ex: 2^31 para compatibilidade com int32)",
                                    "Selecionar a com propriedades espectrais boas (ex: 1664525 de Numerical Recipes)",
                                    "Definir c > 0 (não zero para evitar degeneração)",
                                    "Escolher semente X_0 imprevisível (ex: baseado em tempo ou ruído)",
                                    "Validar parâmetros com testes teóricos: verificar período esperado e lattice structure"
                                  ],
                                  "verification": "Listar e justificar um conjunto de parâmetros (m,a,c,X0) para simulação estrutural, calculando período teórico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabelas de parâmetros LCG recomendados (ex: Wikipedia LCG)",
                                    "Planilha Excel para simulações iniciais",
                                    "Documentação de bibliotecas como NumPy"
                                  ],
                                  "tips": "Priorize parâmetros testados em literatura para economizar tempo em tuning manual.",
                                  "learningObjective": "Aprender a escolher parâmetros que garantam uniformidade e independência para simulações estocásticas.",
                                  "commonMistakes": [
                                    "Usar c=0 (multiplicativo puro, ruim para uniformidade)",
                                    "m pequeno levando a correlações rápidas",
                                    "a=1 gerando sequência constante"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o gerador LCG em Python",
                                  "subSteps": [
                                    "Criar função geradora: def lcg(seed, a, c, m, n): que retorna lista de n números",
                                    "Normalizar para [0,1]: U_i = X_i / m",
                                    "Implementar loop iterativo com módulo aritmético",
                                    "Adicionar suporte a múltiplas sementes e salvar sequência em arquivo CSV",
                                    "Testar com 1000 números e imprimir primeiros 10"
                                  ],
                                  "verification": "Executar código e confirmar que gera sequência correta comparada a cálculo manual de 5 iterações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python 3 com Jupyter Notebook",
                                    "Bibliotecas: numpy, matplotlib (para plots futuros)",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Use typing hints e docstrings para código limpo; evite recursão para grandes n.",
                                  "learningObjective": "Desenvolver código funcional e eficiente para geração de pseudoaleatórios via LCG.",
                                  "commonMistakes": [
                                    "Overflow em multiplicações (use int64 ou modulo stepwise)",
                                    "Esquecer normalização para [0,1]",
                                    "Loop infinito sem limite n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar propriedades do LCG gerado",
                                  "subSteps": [
                                    "Gerar 10^5 números e plotar histograma para checar uniformidade",
                                    "Calcular teste qui-quadrado para uniformidade (p-value > 0.05)",
                                    "Computar autocorrelação serial para independência (lag 1 a 10 próximo de 0)",
                                    "Visualizar scatter plot de pares consecutivos (sem estrutura)",
                                    "Comparar com random.uniform() como benchmark"
                                  ],
                                  "verification": "Produzir relatório com plots e métricas: histograma uniforme, qui-quadrado aceito, autocorr < 0.05.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com numpy, scipy.stats, matplotlib, seaborn",
                                    "Jupyter Notebook para visualizações interativas"
                                  ],
                                  "tips": "Gere amostras grandes (>10^4) para testes estatísticos confiáveis; log escala no histograma.",
                                  "learningObjective": "Validar empiricamente a qualidade do gerador para uso em simulações de Monte Carlo.",
                                  "commonMistakes": [
                                    "Amostra pequena invalidando testes",
                                    "Escala errada no histograma mascarando não-uniformidade",
                                    "Ignorar p-values em testes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar LCG em simulação estocástica simples de análise estrutural",
                                  "subSteps": [
                                    "Modelar carga aleatória em viga: uniformes via LCG para 1000 simulações",
                                    "Calcular deflexão máxima via fórmula elástica: δ = (P L^3)/(48 E I)",
                                    "Executar Monte Carlo: estatísticas de δ (média, desv pad, percentil 95)",
                                    "Comparar com distribuição teórica (se uniforme, δ uniforme escalada)",
                                    "Gerar relatório com resultados e plots de distribuição de δ"
                                  ],
                                  "verification": "Simulação converge para valores esperados e demonstra variabilidade realista.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código LCG anterior",
                                    "numpy para cálculos estruturais simples",
                                    "matplotlib para histogramas de deflexão"
                                  ],
                                  "tips": "Mantenha modelo 1D simples; foque em integração LCG-Monte Carlo.",
                                  "learningObjective": "Integrar LCG em contexto de engenharia civil para simulações confiáveis.",
                                  "commonMistakes": [
                                    "Não escalar corretamente U_i para cargas físicas",
                                    "Correntes no LCG propagando erro em Monte Carlo",
                                    "Amostras insuficientes para convergência"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um LCG com m=2**31, a=1664525, c=1013904223, X0=12345 para gerar 10000 cargas uniformes [0,100kN] em uma viga de 10m, L=10m, E=30GPa, I=0.001m^4. Rode Monte Carlo para distribuição de deflexão máxima e plote histograma.",
                              "finalVerifications": [
                                "Código LCG gera sequência com período próximo a m e histograma uniforme",
                                "Testes estatísticos (qui-quadrado, autocorrelação) aprovam qualidade",
                                "Simulação Monte Carlo em viga converge com <5% erro em média teórica",
                                "Relatório inclui plots, métricas e discussão de limitações do LCG",
                                "Parâmetros justificados com referências bibliográficas",
                                "Código modular e reutilizável com funções bem documentadas"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da implementação (20%)",
                                "Qualidade dos parâmetros e validação estatística (25%)",
                                "Eficiência e legibilidade do código (20%)",
                                "Integração em simulação estrutural realista (20%)",
                                "Relatório completo com visualizações e análise (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra modular e teoria dos números",
                                "Programação: Estruturas de controle e análise numérica",
                                "Estatística: Testes de hipóteses e análise de séries temporais",
                                "Engenharia Civil: Métodos de Monte Carlo em confiabilidade estrutural",
                                "Física: Modelagem estocástica de cargas ambientais"
                              ],
                              "realWorldApplication": "Em análise de estruturas sob cargas aleatórias (vento, tráfego), LCG alimenta simulações Monte Carlo para estimar probabilidades de falha, dimensionamento seguro e certificação em normas como ABNT NBR 6123, otimizando projetos civis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.6.1.2",
                            "name": "Aplicar testes de aleatoriedade",
                            "description": "Realizar testes estatísticos como teste de qui-quadrado e Kolmogorov-Smirnov para validar a qualidade de sequências aleatórias geradas, essenciais para confiabilidade em simulações Monte Carlo de estruturas civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a sequência de números aleatórios e selecionar testes apropriados",
                                  "subSteps": [
                                    "Gerar ou obter uma sequência de números pseudoaleatórios (mínimo 1000 amostras).",
                                    "Dividir a sequência em intervalos para testes de frequência (ex: 10 bins para qui-quadrado).",
                                    "Escolher testes: qui-quadrado para uniformidade e Kolmogorov-Smirnov para distribuição cumulativa.",
                                    "Definir nível de significância (α = 0,05) e hipótese nula (H0: sequência é aleatória).",
                                    "Preparar software ou ferramenta (Python com scipy.stats ou Excel)."
                                  ],
                                  "verification": "Sequência carregada, bins definidos e hipóteses claras documentadas em relatório.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Computador com Python (bibliotecas numpy, scipy), sequência de números aleatórios gerada.",
                                  "tips": "Use geradores built-in como np.random.uniform() para testes iniciais.",
                                  "learningObjective": "Compreender pré-requisitos para aplicação de testes estatísticos de aleatoriedade.",
                                  "commonMistakes": "Usar amostras muito pequenas (<500), ignorar normalização da sequência para [0,1]."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar o teste qui-quadrado de adequação",
                                  "subSteps": [
                                    "Calcular frequências observadas (Oi) em cada bin da sequência.",
                                    "Calcular frequências esperadas (Ei = n/10 para 10 bins uniformes).",
                                    "Computar estatística qui-quadrado: Σ[(Oi - Ei)^2 / Ei].",
                                    "Determinar valor crítico da tabela qui-quadrado (graus de liberdade = k-1) ou p-value via software.",
                                    "Comparar com α e rejeitar/aceitar H0."
                                  ],
                                  "verification": "Estatística qui-quadrado calculada e p-value obtido, com interpretação inicial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (scipy.stats.chisquare), calculadora ou planilha Excel.",
                                  "tips": "Garanta que soma de Oi = n total; normalize bins igualmente.",
                                  "learningObjective": "Aplicar teste qui-quadrado para verificar uniformidade de sequências aleatórias.",
                                  "commonMistakes": "Esquecer de subtrair 1 nos graus de liberdade, usar bins desiguais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o teste Kolmogorov-Smirnov",
                                  "subSteps": [
                                    "Ordenar a sequência e calcular a função de distribuição empírica cumulativa (Fn(x)).",
                                    "Comparar com distribuição uniforme teórica F(x) = x para [0,1].",
                                    "Calcular estatística KS: sup |Fn(x) - F(x)| sobre todos x.",
                                    "Obter p-value da tabela KS ou via software (scipy.stats.kstest).",
                                    "Interpretar: se D > crítico ou p < α, rejeitar aleatoriedade."
                                  ],
                                  "verification": "Estatística KS e p-value computados, com gráfico opcional de Fn vs F.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (scipy.stats.kstest), matplotlib para visualização.",
                                  "tips": "Use kstest(rvs, 'uniform') diretamente no scipy para simplicidade.",
                                  "learningObjective": "Avaliar adequação à distribuição uniforme via teste KS.",
                                  "commonMistakes": "Não ordenar a sequência, confundir KS com testes paramétricos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e validar qualidade da sequência",
                                  "subSteps": [
                                    "Compilar resultados: p-values de ambos testes > α indica aleatoriedade.",
                                    "Analisar falhas: se rejeitado, identificar padrões (ex: runs test complementar).",
                                    "Documentar em relatório: estatísticas, conclusões e implicações para Monte Carlo.",
                                    "Testar múltiplas sementes ou geradores para robustez.",
                                    "Recomendar gerador se aprovado (ex: Mersenne Twister)."
                                  ],
                                  "verification": "Relatório final com tabelas, gráficos e recomendação clara.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto ou Jupyter Notebook para relatório.",
                                  "tips": "Sempre reporte ambos testes para validação cruzada.",
                                  "learningObjective": "Integrar resultados de testes para validar sequências em contextos de engenharia.",
                                  "commonMistakes": "Ignorar p-value em favor de valor crítico, superestimar aleatoriedade com um só teste."
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para análise de vibrações em uma ponte, gere 5000 números aleatórios com np.random.uniform(). Aplique qui-quadrado (p=0.23) e KS (p=0.15), ambos >0.05, validando o uso para modelar cargas estocásticas variáveis.",
                              "finalVerifications": [
                                "p-values de qui-quadrado e KS > 0.05.",
                                "Relatório documenta estatísticas, hipóteses e conclusões.",
                                "Gráficos de histogramas e CDF mostram uniformidade visual.",
                                "Sequência testada com múltiplas sementes passa nos testes.",
                                "Recomendação explícita para uso em simulações civis."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos estatísticos (erro <1%).",
                                "Interpretação correta de p-values e rejeição/aceitação de H0.",
                                "Uso adequado de software e documentação de código.",
                                "Identificação de padrões não-aleatórios se presentes.",
                                "Conexão clara com aplicações em Monte Carlo para engenharia civil.",
                                "Relatório completo e bem estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e testes de hipóteses.",
                                "Programação: Implementação em Python/R para análise de dados.",
                                "Engenharia Civil: Simulações estocásticas em estruturas.",
                                "Matemática: Probabilidade e distribuições contínuas.",
                                "Ciência de Dados: Validação de geradores RNG em ML."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, como análise de risco sísmico em edifícios via Monte Carlo, testes de aleatoriedade garantem que sequências de cargas e respostas sejam verdadeiramente estocásticas, evitando vieses que poderiam subestimar falhas estruturais e comprometer a segurança pública."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.6.1.3",
                            "name": "Gerar distribuições não-uniformes",
                            "description": "Utilizar métodos de transformação inversa e rejeição para gerar números aleatórios de distribuições normais, lognormais e exponenciais, comuns em modelagem de cargas e materiais em engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Método de Transformação Inversa",
                                  "subSteps": [
                                    "Revisar as funções de densidade de probabilidade (PDF) e distribuição cumulativa (CDF) para distribuições exponencial, lognormal e normal.",
                                    "Explicar o princípio da transformação inversa: gerar U ~ Uniforme(0,1) e aplicar F^{-1}(U), onde F é a CDF.",
                                    "Derivar analiticamente a função inversa para a distribuição exponencial: X = -λ^{-1} ln(1-U).",
                                    "Discutir limitações para distribuições sem inversa fechada, como normal.",
                                    "Praticar cálculo manual de 10 amostras exponenciais usando gerador de uniformes."
                                  ],
                                  "verification": "Gerar e plotar histograma de 100 amostras manuais/simuladas e comparar com PDF teórica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Probabilidade (ex: Ross)",
                                    "Jupyter Notebook com NumPy e Matplotlib",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Sempre normalize U para (0,1) e evite U=0 ou 1 para evitar log(0).",
                                  "learningObjective": "Dominar o conceito e derivação da transformação inversa para distribuições contínuas.",
                                  "commonMistakes": [
                                    "Confundir PDF com CDF",
                                    "Esquecer de inverter corretamente a CDF",
                                    "Usar U diretamente sem transformação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Transformação Inversa para Distribuições Exponencial e Lognormal",
                                  "subSteps": [
                                    "Implementar função em Python para exponencial usando numpy.random.uniform().",
                                    "Derivar e codificar inversa lognormal: X = exp(μ + σ * Φ^{-1}(U)), onde Φ^{-1} é a inversa normal padrão.",
                                    "Gerar 10.000 amostras de cada e calcular estatísticas descritivas (média, variância).",
                                    "Validar com testes KS (Kolmogorov-Smirnov) contra distribuições teóricas.",
                                    "Plotar Q-Q plots para visual inspeção."
                                  ],
                                  "verification": "Estatísticas amostrais coincidem com parâmetros teóricos (erro <5%) e KS p-value >0.05.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com SciPy.stats",
                                    "Jupyter Notebook",
                                    "Documentação NumPy/SciPy"
                                  ],
                                  "tips": "Use scipy.stats.norm.ppf para inversa normal na lognormal; teste com parâmetros conhecidos.",
                                  "learningObjective": "Codificar e validar geradores para exponencial e lognormal.",
                                  "commonMistakes": [
                                    "Erro nos parâmetros μ/σ da lognormal",
                                    "Não usar ppf (percent point function)",
                                    "Amostras insuficientes para validação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Método de Rejeição para Distribuição Normal",
                                  "subSteps": [
                                    "Explicar o algoritmo: propose Y da envelope g(y), aceite com probabilidade f(y)/(M g(y)).",
                                    "Escolher envelope exponencial para normal (Von Neumann) ou uniforme para cauda.",
                                    "Codificar em Python: loop até aceitação, com M otimizado.",
                                    "Gerar 10.000 amostras e medir taxa de aceitação (>20% ideal).",
                                    "Comparar histograma e estatísticas com numpy.random.normal."
                                  ],
                                  "verification": "Taxa de aceitação >15%, histograma sobreposto à normal teórica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/Matplotlib/SciPy",
                                    "Artigo original de Von Neumann"
                                  ],
                                  "tips": "Otimize M minimizando integral; pare loops com limite de tentativas para eficiência.",
                                  "learningObjective": "Entender e implementar rejeição para distribuições sem inversa fechada.",
                                  "commonMistakes": [
                                    "Envelope inadequado (M muito alto)",
                                    "Erro no cálculo da probabilidade de aceitação",
                                    "Loop infinito sem break"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Simulações Estocásticas para Engenharia Civil",
                                  "subSteps": [
                                    "Modelar carga viva lognormal (μ=2kN/m², σ=0.5) em pavimento.",
                                    "Gerar cargas via métodos aprendidos e simular 1.000 cenários de falha.",
                                    "Combinar com Monte Carlo: calcular probabilidade de sobrecarga (>4kN/m²).",
                                    "Analisar sensibilidade variando parâmetros.",
                                    "Documentar código e resultados em relatório."
                                  ],
                                  "verification": "Probabilidade simulada converge (IC 95% estreito) e código reproduzível.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Dados reais de normas ABNT NBR 6120"
                                  ],
                                  "tips": "Use seed para reprodutibilidade; vetorize código para velocidade.",
                                  "learningObjective": "Integrar geradores em modelagem estocástica de cargas/materiais.",
                                  "commonMistakes": [
                                    "Ignorar correlações entre variáveis",
                                    "Amostras insuficientes para convergência",
                                    "Unidades inconsistentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Simular cargas de tráfego lognormal em uma ponte: gere 5.000 amostras com μ=150kN, σ=50kN usando transformação inversa, combine com normal para vento via rejeição, e estime risco de colapso via Monte Carlo.",
                              "finalVerifications": [
                                "Gerar e validar 10.000 amostras de cada distribuição com testes estatísticos.",
                                "Implementar código completo reproduzível em Jupyter.",
                                "Simular cenário de engenharia com relatório de resultados.",
                                "Explicar trade-offs entre métodos (eficiência, simplicidade).",
                                "Plotar histogramas/Q-Q comparando métodos built-in vs custom.",
                                "Calcular tempo de execução e taxa de aceitação para rejeição."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática e implementação (90% acerto em testes).",
                                "Eficiência computacional (tempo <1s para 10k amostras).",
                                "Validação estatística rigorosa (KS, momentos).",
                                "Clareza do código e documentação.",
                                "Aplicação contextualizada em engenharia civil.",
                                "Análise de erros e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Fundamentos de PDF/CDF.",
                                "Programação Computacional: Python/NumPy para simulações.",
                                "Engenharia de Estruturas: Modelagem de cargas estocásticas.",
                                "Cálculo Numérico: Integração e otimização de envelopes.",
                                "Física Aplicada: Incertezas em materiais e cargas."
                              ],
                              "realWorldApplication": "Modelagem de cargas sísmicas (normal), durabilidade de concreto (lognormal) e eventos de pico de tráfego (exponencial) para dimensionamento seguro de edifícios e pontes, reduzindo custos e riscos em projetos civis."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.6.2",
                        "name": "Método de Monte Carlo",
                        "description": "Princípios e algoritmos do método de Monte Carlo para aproximação numérica de integrais e probabilidades em contextos estocásticos da engenharia.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.6.2.1",
                            "name": "Calcular integrais estocásticas",
                            "description": "Implementar o método de Monte Carlo para estimar integrais múltiplas, demonstrando convergência e erro estatístico em problemas como cálculo de áreas sob curvas de resposta estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Método de Monte Carlo para Integrais Estocásticas",
                                  "subSteps": [
                                    "Estude a representação de uma integral múltipla como uma expectativa de uma variável aleatória uniforme no domínio de integração.",
                                    "Revise a fórmula básica: I ≈ (V / N) * Σ f(X_i), onde V é o volume do domínio, N número de amostras, X_i pontos aleatórios.",
                                    "Analise o erro estatístico: desvio padrão σ / sqrt(N), onde σ é o desvio padrão de f(X).",
                                    "Discuta convergência pela lei dos grandes números e teorema central do limite."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como o método converte uma integral determinística em uma média estocástica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de referência: 'Monte Carlo Methods in Engineering' ou notas de aula sobre simulações estocásticas.",
                                    "Notebook Jupyter com exemplos simples de integrais 1D."
                                  ],
                                  "tips": "Visualize graficamente o domínio de integração e pontos amostrados para intuição.",
                                  "learningObjective": "Entender a base probabilística do método Monte Carlo para aproximação de integrais.",
                                  "commonMistakes": [
                                    "Confundir volume do domínio com área (para integrais duplas).",
                                    "Ignorar a normalização pelo volume V."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Problema Específico e Configurar o Domínio",
                                  "subSteps": [
                                    "Identifique a integral a estimar, e.g., ∫∫ f(x,y) dx dy sobre domínio D em problemas de resposta estrutural.",
                                    "Defina os limites do domínio D (e.g., retângulo [a,b]x[c,d]) e compute seu volume V.",
                                    "Especifique a função f relacionada à curva de resposta estrutural (e.g., probabilidade de excedência).",
                                    "Planeje o número de amostras N inicial (e.g., 10^4) e critérios de parada."
                                  ],
                                  "verification": "Escreva a integral matemática e compute manualmente V para um domínio simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de plotagem: Python (Matplotlib) ou MATLAB.",
                                    "Exemplo de dados: Curva de resposta de uma viga sob carga aleatória."
                                  ],
                                  "tips": "Sempre normalize o domínio para [0,1]^d para simplificar geração uniforme.",
                                  "learningObjective": "Configurar precisamente um problema de integral estocástica em contexto de engenharia civil.",
                                  "commonMistakes": [
                                    "Definir domínio incorreto levando a viés sistemático.",
                                    "Esquecer de mapear variáveis para o domínio real."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Geração de Amostras e Avaliação da Função",
                                  "subSteps": [
                                    "Gere N pontos aleatórios uniformes no domínio usando np.random.uniform().",
                                    "Avalie f em cada ponto X_i.",
                                    "Calcule a soma S = Σ f(X_i) e a estimativa I_est = (V / N) * S.",
                                    "Compute variância amostral para erro: σ_est = sqrt( var(f(X)) / N ) * V."
                                  ],
                                  "verification": "Execute código e verifique que pontos estão uniformemente distribuídos via histograma.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python: NumPy, Matplotlib.",
                                    "Código template para Monte Carlo básico."
                                  ],
                                  "tips": "Use np.random.seed() para reprodutibilidade em testes.",
                                  "learningObjective": "Implementar o núcleo computacional do algoritmo Monte Carlo.",
                                  "commonMistakes": [
                                    "Gerar amostras fora do domínio.",
                                    "Erro em avaliação vetorial de f (lento em loops)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Convergência e Erro Estatístico",
                                  "subSteps": [
                                    "Execute múltiplas simulações (M=100 runs) com N variando (10^3 a 10^6).",
                                    "Plote I_est vs. log(N) e intervalos de confiança.",
                                    "Verifique convergência linear em 1/sqrt(N).",
                                    "Compare com solução analítica ou numérica determinística (e.g., quadrature)."
                                  ],
                                  "verification": "Gere gráfico mostrando redução de erro com N crescente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python: NumPy, Matplotlib, SciPy para integrais exatas.",
                                    "Dados de benchmark: integral conhecida como π/4."
                                  ],
                                  "tips": "Use log-log plot para visualizar taxa de convergência.",
                                  "learningObjective": "Demonstrar empiricamente propriedades estatísticas do método.",
                                  "commonMistakes": [
                                    "Número insuficiente de runs M levando a estimativa ruidosa de erro.",
                                    "Ignorar correlação entre runs."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar a Exemplo em Engenharia Civil: Área sob Curva de Resposta Estrutural",
                                  "subSteps": [
                                    "Modele uma curva de resposta (e.g., drift vs. aceleração sísmica) como f(x,y).",
                                    "Estime integral para probabilidade de falha ou energia dissipada.",
                                    "Interprete resultados: incerteza na estimativa e implicações para design estrutural.",
                                    "Documente código completo e relatório com gráficos."
                                  ],
                                  "verification": "Produza relatório com estimativa final, erro e comparação com método alternativo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados reais: espectros sísmicos ou modelo finito elemento simples.",
                                    "Python completo com visualizações."
                                  ],
                                  "tips": "Integre com bibliotecas como OpenSeesPy para realismo.",
                                  "learningObjective": "Aplicar Monte Carlo a problema prático de simulação estocástica em estruturas.",
                                  "commonMistakes": [
                                    "Função f não suave levando a convergência lenta.",
                                    "Escala numérica errada em f grande."
                                  ]
                                }
                              ],
                              "practicalExample": "Estime a integral dupla ∫∫_D g(x,y) dx dy, onde D é o domínio de cargas sísmicas [0,1]x[0,2], g(x,y)=exp(-x*y) representando probabilidade de excedência de drift em uma estrutura de edifício, usando N=10^5 amostras para demonstrar erro <1%.",
                              "finalVerifications": [
                                "Código gera estimativa convergindo para valor conhecido com erro <5%.",
                                "Gráficos mostram distribuição uniforme e redução de variância com N.",
                                "Relatório interpreta erro estatístico corretamente.",
                                "Implementação roda em <5 min para N=10^6.",
                                "Comparação com método quadratura confirma precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimativa (erro relativo <10%).",
                                "Correta implementação de amostragem e normalização (100% pontos válidos).",
                                "Análise de convergência com plots quantitativos.",
                                "Clareza do código e documentação.",
                                "Interpretação contextual em engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Teorema Central do Limite e intervalos de confiança.",
                                "Programação Numérica: Vetorização em NumPy para eficiência.",
                                "Probabilidade: Variáveis aleatórias uniformes e expectativa.",
                                "Análise Numérica: Comparação com métodos determinísticos como Gauss Quadrature.",
                                "Engenharia Estrutural: Modelagem de incertezas em cargas dinâmicas."
                              ],
                              "realWorldApplication": "Em análise de risco sísmico, estima probabilidades de falha em pontes ou edifícios sob cargas aleatórias, auxiliando no design probabilístico e otimização de estruturas contra eventos extremos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.6.2.2",
                            "name": "Estimar probabilidades de falha",
                            "description": "Aplicar Monte Carlo para computar probabilidades de eventos raros, como falha estrutural sob cargas variáveis, analisando variância e número de simulações necessárias para precisão desejada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo de falha e variáveis estocásticas",
                                  "subSteps": [
                                    "Identifique o critério de falha (ex.: tensão máxima > resistência).",
                                    "Defina distribuições probabilísticas para variáveis (ex.: carga normal, resistência log-normal).",
                                    "Especifique parâmetros: média, desvio padrão, coeficiente de variação.",
                                    "Formule a função de falha g(X) onde g(X) ≤ 0 indica falha.",
                                    "Calcule probabilidade analítica aproximada se possível para benchmark."
                                  ],
                                  "verification": "Modelo documentado com distribuições e função g(X) implementada em pseudocódigo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou editor de texto; documentação de distribuições (SciPy.stats).",
                                  "tips": "Use coeficientes de variação realistas (0.1-0.3 para engenharia civil).",
                                  "learningObjective": "Compreender e modelar incertezas em sistemas estruturais.",
                                  "commonMistakes": "Ignorar correlações entre variáveis ou escolher distribuições inadequadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração de amostras aleatórias",
                                  "subSteps": [
                                    "Configure semente para reprodutibilidade (np.random.seed(42)).",
                                    "Gere N amostras independentes para cada variável (ex.: np.random.normal).",
                                    "Aplique transformações se necessário (ex.: log para log-normal).",
                                    "Verifique histograma das amostras para validar distribuições.",
                                    "Teste com N pequeno (1000) para depuração."
                                  ],
                                  "verification": "Histogramas das amostras coincidem com PDFs teóricas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy e Matplotlib; Jupyter Notebook.",
                                  "tips": "Use vectorização NumPy para eficiência em grandes N.",
                                  "learningObjective": "Gerar amostras aleatórias precisas de distribuições multivariadas.",
                                  "commonMistakes": "Esquecer de definir semente ou gerar amostras correlacionadas incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações Monte Carlo e contar falhas",
                                  "subSteps": [
                                    "Implemente loop ou vetorizado para avaliar g(X) em todas amostras.",
                                    "Conte número de falhas: nf = sum(g(X) <= 0).",
                                    "Estime probabilidade inicial: Pf = nf / N.",
                                    "Monitore convergência plotando Pf vs. N incremental.",
                                    "Aumente N iterativamente até estabilização visual."
                                  ],
                                  "verification": "Número de falhas registrado e Pf plotado vs. N.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy; código do Step 1 e 2.",
                                  "tips": "Use N inicial de 10^4, dobre até 10^6 para eventos raros (Pf < 10^-3).",
                                  "learningObjective": "Realizar simulações estocásticas eficientes.",
                                  "commonMistakes": "N insuficiente para eventos raros, levando a variância alta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar variância e determinar precisão",
                                  "subSteps": [
                                    "Calcule variância de Pf: Var(Pf) = Pf*(1-Pf)/N.",
                                    "Coeficiente de variação: CV = sqrt(Var(Pf))/Pf.",
                                    "Erro padrão: se = sqrt(Pf*(1-Pf)/N).",
                                    "Determine N necessário: N > (z * CV_target / Pf_target)^2 para CV < 10%.",
                                    "Compare com benchmark analítico e avalie convergência."
                                  ],
                                  "verification": "Relatório com Pf, CV, se e N recomendado calculados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código anterior; fórmulas de estatística binomial.",
                                  "tips": "Para Pf raro, mire CV < 20% e use importance sampling se N > 10^7.",
                                  "learningObjective": "Quantificar incerteza em estimativas Monte Carlo.",
                                  "commonMistakes": "Confundir variância amostral com teórica ou subestimar N."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar a análise",
                                  "subSteps": [
                                    "Execute com N final e plote distribuição de g(X).",
                                    "Teste sensibilidade variando parâmetros de entrada.",
                                    "Compare múltiplas sementes para robustez.",
                                    "Documente limitações (ex.: independência das amostras).",
                                    "Sugira melhorias como Latin Hypercube Sampling."
                                  ],
                                  "verification": "Relatório final com gráficos, tabelas e conclusões.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Todos códigos prévios; Matplotlib/Seaborn.",
                                  "tips": "Salve resultados em CSV para reprodutibilidade.",
                                  "learningObjective": "Validar e interpretar resultados de simulações.",
                                  "commonMistakes": "Sobreconfiança em Pf sem checar CV ou sensibilidade."
                                }
                              ],
                              "practicalExample": "Simule uma viga de concreto sob carga viva variável (normal μ=50kN, σ=10kN) e resistência flexural log-normal (μ_ln=4.0, σ_ln=0.2). Falha se momento > capacidade. Estime Pf com N=10^6, calcule CV e N para CV<10%.",
                              "finalVerifications": [
                                "Pf converge com CV < 15% para eventos raros.",
                                "Histogramas de entradas validam distribuições.",
                                "Gráficos de convergência Pf vs. N estabilizam.",
                                "N recomendado atende precisão desejada (ex.: erro < 20% de Pf).",
                                "Comparação com benchmark analítico dentro de 10%.",
                                "Relatório documenta todos cálculos e códigos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimativa Pf (erro < 20% vs. benchmark).",
                                "Correta análise de variância e CV.",
                                "Eficiência computacional (tempo razoável para N=10^6).",
                                "Validação visual (plots de qualidade).",
                                "Interpretação correta de limitações.",
                                "Código limpo, comentado e reprodutível."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência binomial e intervalos de confiança.",
                                "Programação: Vetorização NumPy e otimização de loops.",
                                "Engenharia Mecânica: Análise de confiabilidade estrutural.",
                                "Física: Modelagem de cargas estocásticas.",
                                "Matemática Computacional: Integração numérica estocástica."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios, estima Pf de colapso sob ventos/sismos variáveis para calibrar fatores de segurança (ex.: Eurocode), otimizando custos sem comprometer segurança."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.6.2.3",
                            "name": "Otimizar simulações com variância reduzida",
                            "description": "Implementar técnicas como amostragem de importância e variáveis antitéticas para reduzir a variância em simulações Monte Carlo aplicadas a análise de confiabilidade de vigas e lajes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a variância em simulações Monte Carlo e suas implicações",
                                  "subSteps": [
                                    "Revise o método Monte Carlo básico para estimativa de probabilidade de falha em vigas.",
                                    "Calcule a variância analítica de uma estimativa Monte Carlo simples usando fórmula Var(θ̂) = (p(1-p))/N.",
                                    "Simule uma viga com carga aleatória e meça a variância empírica em múltiplas runs.",
                                    "Identifique cenários onde alta variância exige muitas simulações (ex: p_falha baixa).",
                                    "Compare com limites de confiabilidade em normas como Eurocode para lajes."
                                  ],
                                  "verification": "Gerar relatório com gráficos de variância vs. N_simulações e confirmar que variância diminui como 1/N.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python com NumPy e Matplotlib; notebook Jupyter; dados de propriedades de vigas (módulo elástico, resistência).",
                                  "tips": "Use seeds fixas para reprodutibilidade ao medir variância.",
                                  "learningObjective": "Entender quantificar e visualizar o impacto da variância em estimativas de confiabilidade.",
                                  "commonMistakes": "Confundir variância com desvio padrão; ignorar dependência de p na variância."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar amostragem de importância para redução de variância",
                                  "subSteps": [
                                    "Defina uma função de densidade de importância q(x) que oversample regiões críticas (ex: perto da falha da viga).",
                                    "Derive o estimador não viesado: θ̂ = (1/N) Σ [I(falha)/q(x_i)] * p(x_i).",
                                    "Implemente em código para simulação de falha de viga sob carga gaussiana.",
                                    "Ajuste q(x) iterativamente comparando variância com Monte Carlo cru.",
                                    "Teste em laje com múltiplas cargas para validar redução >50%."
                                  ],
                                  "verification": "Comparar variâncias: var_importance < var_crude em pelo menos 3 runs independentes.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com SciPy para distribuições; exemplos de falha estrutural (momentos flecha > limite).",
                                  "tips": "Escolha q(x) suave e positiva em todo suporte para estabilidade numérica.",
                                  "learningObjective": "Aplicar amostragem de importância para focar simulações em eventos raros de falha.",
                                  "commonMistakes": "Usar q(x) com suporte menor que p(x), causando viés; não normalizar pesos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar variáveis antitéticas para correlação negativa",
                                  "subSteps": [
                                    "Gere pares antitéticos: U e 1-U para uniforme, aplicando a cargas de viga.",
                                    "Calcule covariância negativa: Cov(f(U), f(1-U)) < 0 para redução de variância.",
                                    "Implemente estimador: θ̂ = (1/(2N)) Σ [f(U_i) + f(1-U_i)].",
                                    "Simule laje com vento aleatório e compare variância com Monte Carlo padrão.",
                                    "Combine com amostragem estratificada para ganhos aditivos."
                                  ],
                                  "verification": "Coeficiente de correlação entre pares antitéticos < -0.2, com variância reduzida em 20-40%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "NumPy para geração de pares; gráficos de scatter para correlação.",
                                  "tips": "Verifique monotonicidade da função falha para garantir correlação negativa.",
                                  "learningObjective": "Usar dependência negativa para estabilizar estimativas Monte Carlo.",
                                  "commonMistakes": "Aplicar a funções não-monotônicas; esquecer de dividir por 2N."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar técnicas e otimizar para análise de vigas e lajes",
                                  "subSteps": [
                                    "Integre amostragem de importância + antitéticas em um framework unificado.",
                                    "Otimize hiperparâmetros (ex: largura de q(x)) via validação cruzada em simulações.",
                                    "Aplique a modelo realista: viga com seção retangular, carga viva + morta aleatória.",
                                    "Compare tempos de computação e precisão com Monte Carlo cru (meta: 10x menos simulações).",
                                    "Gere relatório com ICs (intervalos de confiança) para probabilidade de falha."
                                  ],
                                  "verification": "Redução total de variância >70% com N_sim <10% do crude para mesma precisão.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Jupyter; bibliotecas como Pandas para relatórios; modelo FEM simples para lajes.",
                                  "tips": "Use paralelização (joblib) para runs múltiplas rápidas.",
                                  "learningObjective": "Desenvolver pipeline otimizado para simulações estocásticas em estruturas.",
                                  "commonMistakes": "Sobre-otimizar q(x) levando a instabilidade; ignorar custo computacional extra."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e documentar a otimização em contexto de engenharia",
                                  "subSteps": [
                                    "Valide contra analítico exato para casos simples (ex: falha linear).",
                                    "Documente código com comentários e fluxograma do algoritmo.",
                                    "Teste sensibilidade a parâmetros incertos (ex: coef. variação de resistência).",
                                    "Prepare apresentação com métricas: ESS (effective sample size).",
                                    "Discuta limitações para projetos reais de pontes."
                                  ],
                                  "verification": "Código documentado roda sem erros e reproduz resultados em máquina diferente.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Git para versionamento; LaTeX ou Markdown para relatório.",
                                  "tips": "Calcule ESS = (média pesos)^2 / var(pesos) > 50% de N para importância.",
                                  "learningObjective": "Garantir robustez e comunicabilidade da solução otimizada.",
                                  "commonMistakes": "Não testar em N baixo; omitir discussão de viés."
                                }
                              ],
                              "practicalExample": "Simule a probabilidade de falha de uma viga de concreto armado (span 5m, carga viva ~N(10,2)kN/m) onde falha ocorre se momento máximo > Mr = 200kNm. Use 10k simulações crude (p~0.01, var alta), aplique importância com q centrada em cargas altas e antitéticas em U para cargas, reduzindo var para <10% com 1k sims.",
                              "finalVerifications": [
                                "Variância reduzida em >60% para ambas técnicas vs. Monte Carlo padrão.",
                                "Intervalo de confiança 95% para p_falha <5% do valor estimado.",
                                "Effective Sample Size (ESS) >70% de N total.",
                                "Código executa em <5min para 10k sims em laptop padrão.",
                                "Resultados consistentes em 5 runs independentes.",
                                "Gráficos mostram convergência mais rápida das otimizações."
                              ],
                              "assessmentCriteria": [
                                "Correta derivação matemática das técnicas (sem viés).",
                                "Implementação numérica precisa e eficiente.",
                                "Redução quantificável de variância com evidências empíricas.",
                                "Aplicação contextualizada a vigas/lajes com parâmetros realistas.",
                                "Documentação clara de passos, limitações e hiperparâmetros.",
                                "Análise de trade-offs (precisão vs. tempo computacional)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Teoria de variância, estimadores não viesados.",
                                "Programação: Otimização numérica, paralelismo em Python.",
                                "Engenharia Estrutural: Modelos de confiabilidade (FORM/SORM como baseline).",
                                "Matemática Computacional: Integração numérica estocástica.",
                                "Gestão de Projetos: Redução de custo computacional em simulações industriais."
                              ],
                              "realWorldApplication": "Em projetos de edifícios altos ou pontes, otimizar Monte Carlo permite estimar confiabilidade (ex: p_falha <10^-4/ano) com supercomputadores limitados, acelerando aprovações regulatórias e reduzindo iterações de design em 5-10x."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.6.3",
                        "name": "Aplicações em Análise de Confiabilidade Estrutural",
                        "description": "Uso prático do Monte Carlo em problemas reais de engenharia civil, focando em confiabilidade e avaliação de risco.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.6.3.1",
                            "name": "Modelar incertezas em propriedades materiais",
                            "description": "Simular variações estocásticas em resistência do concreto e aço usando Monte Carlo para avaliar índices de confiabilidade em elementos estruturais como pilares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir distribuições probabilísticas das propriedades materiais",
                                  "subSteps": [
                                    "Pesquise dados típicos de resistência à compressão do concreto (fck) e limite de escoamento do aço (fy) de normas como ABNT NBR 6118.",
                                    "Selecione distribuições adequadas: normal ou lognormal para fck (média 30 MPa, CV 15%) e normal para fy (média 500 MPa, CV 5%).",
                                    "Calcule parâmetros estatísticos: média (μ), desvio padrão (σ) ou coeficiente de variação (CV).",
                                    "Documente as suposições em um relatório inicial.",
                                    "Valide com literatura ou dados experimentais."
                                  ],
                                  "verification": "Verifique se os parâmetros das distribuições geram amostras com estatísticas coincidentes via histogramas e testes KS.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Normas técnicas (NBR 6118), Python com NumPy e SciPy, Jupyter Notebook",
                                  "tips": "Use CV = σ/μ para simplificar; priorize distribuições assimétricas para materiais frágeis como concreto.",
                                  "learningObjective": "Compreender modelagem estocástica de propriedades materiais em engenharia.",
                                  "commonMistakes": "Ignorar assimetria das distribuições reais; usar valores fixos em vez de estocásticos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração de números aleatórios e simulação Monte Carlo",
                                  "subSteps": [
                                    "Instale e importe bibliotecas: numpy.random para normal/lognormal, scipy.stats para PDF/CDF.",
                                    "Gere N amostras (ex: 10^5) para fck e fy usando np.random.normal ou lognormal.",
                                    "Crie um array de amostras pareadas para concreto e aço.",
                                    "Teste independência entre variáveis com correlação cruzada.",
                                    "Salve amostras em CSV para inspeção."
                                  ],
                                  "verification": "Execute script e confirme que amostras têm μ e σ próximos aos teóricos (erro <5%).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python 3, NumPy, SciPy, Pandas",
                                  "tips": "Use np.random.seed(42) para reprodutibilidade; aumente N para convergência.",
                                  "learningObjective": "Dominar geração de variáveis aleatórias para simulações estocásticas.",
                                  "commonMistakes": "Esquecer seed para resultados irreprodutíveis; gerar amostras insuficientes (N<10^4)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar o elemento estrutural e função limite",
                                  "subSteps": [
                                    "Defina geometria do pilar: seção 30x30 cm, altura 3m, armadura 4φ16mm.",
                                    "Estabeleça função limite g = RC - RA, onde RC e RA são capacidades nominais baseadas em fck e fy.",
                                    "Implemente fórmulas de cálculo: RC = 0.85 fck Ac, RA = fy As.",
                                    "Calcule g para cada amostra Monte Carlo.",
                                    "Classifique falhas: g < 0 indica falha."
                                  ],
                                  "verification": "Compare capacidades médias com cálculo determinístico (erro <1%).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Fórmulas de dimensionamento estrutural, Python com NumPy",
                                  "tips": "Simplifique para compressão axial primeiro; inclua fatores de segurança parciais.",
                                  "learningObjective": "Aplicar conceitos de confiabilidade estrutural via funções limite.",
                                  "commonMistakes": "Erros unitários em fórmulas; ignorar interações concreto-aço."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular índices de confiabilidade e analisar resultados",
                                  "subSteps": [
                                    "Calcule Pf = fração de g<0 / N (probabilidade de falha).",
                                    "Estime β = -Φ^{-1}(Pf), onde Φ é CDF normal padrão (use scipy.stats.norm).",
                                    "Gere histogramas de g, fck, fy e boxplots.",
                                    "Realize análise de sensibilidade variando CVs.",
                                    "Interprete: β>3.8 aceitável para estruturas."
                                  ],
                                  "verification": "Confirme Pf converge com N crescente; β coerente com normas.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python com Matplotlib, Seaborn, SciPy",
                                  "tips": "Plote QQ-plot para validar normalidade aproximada de g.",
                                  "learningObjective": "Interpretar métricas de confiabilidade de simulações Monte Carlo.",
                                  "commonMistakes": "Confundir Pf com 1-β; não linearizar g para β."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Visualizar e relatar achados",
                                  "subSteps": [
                                    "Crie gráficos: histograma g, scatter fck vs fy, curva de convergência Pf vs N.",
                                    "Escreva relatório com suposições, resultados (Pf, β) e recomendações.",
                                    "Compare com métodos FORM/SORM se possível.",
                                    "Exporte relatório em PDF.",
                                    "Apresente oralmente os insights."
                                  ],
                                  "verification": "Gráficos legíveis e relatório cobre todos passos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matplotlib, Seaborn, Jupyter ou LaTeX",
                                  "tips": "Use subplots para múltiplos gráficos; destaque incertezas dominantes.",
                                  "learningObjective": "Comunicar resultados de análises estocásticas efetivamente.",
                                  "commonMistakes": "Gráficos sem legendas/escalas; omitir limitações do modelo."
                                }
                              ],
                              "practicalExample": "Simule um pilar de concreto armado (30x30cm, 4φ16mm aço CA-50) sob carga axial Nc=800kN. Use fck~N(30,4.5MPa), fy~N(500,25MPa). Rode 10^5 iterações Monte Carlo para estimar Pf e β, verificando se β>3.5 atende NBR 6118.",
                              "finalVerifications": [
                                "Simulação converge (Pf estável para N>10^5).",
                                "β calculado corretamente e interpretado.",
                                "Histogramas mostram distribuições realistas.",
                                "Análise de sensibilidade identifica variável crítica.",
                                "Relatório documenta suposições e limitações.",
                                "Código roda sem erros e é reprodutível."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos parâmetros probabilísticos (90%+ match com normas).",
                                "Correta implementação Monte Carlo (convergência demonstrada).",
                                "Função limite g modelada adequadamente.",
                                "Cálculo e interpretação de Pf/β precisos.",
                                "Visualizações claras e insights válidos.",
                                "Relatório completo e bem estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: Distribuições e inferência.",
                                "Programação Computacional: Python para simulações numéricas.",
                                "Mecânica dos Materiais: Propriedades estocásticas.",
                                "Análise Estrutural: Dimensionamento não linear.",
                                "Gestão de Riscos: Avaliação de confiabilidade em projetos."
                              ],
                              "realWorldApplication": "Em projetos de edifícios altos ou pontes, como o caso da Ponte Rio-Niterói, onde simulações Monte Carlo avaliam riscos de falha por variabilidade em materiais, otimizando seções e evitando superdimensionamentos econômicos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.6.3.2",
                            "name": "Avaliar risco em sistemas estruturais",
                            "description": "Realizar simulações Monte Carlo para sistemas multi-grau de liberdade, calculando probabilidades de colapso sob ações sísmicas ou de vento em edifícios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema estrutural multi-grau de liberdade",
                                  "subSteps": [
                                    "Identificar o número de graus de liberdade (DOF) baseado na geometria do edifício (ex: 10 andares = 10 DOF).",
                                    "Definir equações de movimento dinâmicas: M ü + C ú + K u = -M r ï_g para ação sísmica.",
                                    "Implementar o modelo em software como MATLAB ou Python (usando bibliotecas como NumPy/SciPy).",
                                    "Incorporar não-linearidades se aplicável (ex: plastificação de elementos).",
                                    "Validar o modelo com análise modal estática."
                                  ],
                                  "verification": "Executar análise modal e comparar frequências naturais com valores teóricos esperados (erro <5%).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software MATLAB/Python",
                                    "Documentação de modelagem estrutural (ex: Chopra 'Dynamics of Structures')",
                                    "Dados de edifício exemplo"
                                  ],
                                  "tips": "Comece com um modelo linear simples antes de adicionar complexidades.",
                                  "learningObjective": "Construir e validar um modelo dinâmico preciso de edifício multi-DOF.",
                                  "commonMistakes": [
                                    "Ignorar acoplamento entre modos",
                                    "Escala incorreta de massas/rigidezes",
                                    "Não normalizar vetores modais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir parâmetros estocásticos e distribuições de probabilidade",
                                  "subSteps": [
                                    "Listar variáveis aleatórias: rigidez (K ~ lognormal), amortecimento (ξ ~ normal), carga de vento (V ~ Gumbel), espectro sísmico.",
                                    "Estimar parâmetros estatísticos (média, desvio padrão, coeficiente de variação) de literatura ou normas (ex: ASCE 7).",
                                    "Definir critérios de colapso (ex: deriva inter-andar > 5% ou aceleração > 1g).",
                                    "Gerar amostra de cenários (ex: 10^4 simulações).",
                                    "Documentar todas as distribuições em tabela."
                                  ],
                                  "verification": "Verificar que todas variáveis têm distribuições apropriadas e parâmetros realistas via histogramas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Tabelas de normas ASCE 7 / Eurocode 8",
                                    "Bibliotecas SciPy.stats para distribuições",
                                    "Planilha Excel para parâmetros"
                                  ],
                                  "tips": "Use coeficientes de variação realistas (CV=0.1-0.3 para propriedades materiais).",
                                  "learningObjective": "Identificar e parametrizar incertezas em sistemas estruturais.",
                                  "commonMistakes": [
                                    "Distribuições inadequadas (ex: normal para cargas extremas)",
                                    "Subestimar correlações entre variáveis",
                                    "Número insuficiente de simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e executar simulações Monte Carlo",
                                  "subSteps": [
                                    "Escrever loop Monte Carlo: amostrar variáveis → resolver equações dinâmicas → checar colapso.",
                                    "Usar integração numérica (ex: Newmark-beta) para resposta temporal.",
                                    "Paralelizar simulações para eficiência (ex: joblib em Python).",
                                    "Armazenar respostas: máximo deslocamento, aceleração por DOF.",
                                    "Monitorar convergência (plotar probabilidade vs. número de simulações)."
                                  ],
                                  "verification": "Plotar curva de convergência; probabilidade estabiliza após 5000 runs.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Código Python/MATLAB template",
                                    "Computador com >8GB RAM",
                                    "Bibliotecas: NumPy, SciPy, Matplotlib"
                                  ],
                                  "tips": "Teste com 100 runs primeiro para debug.",
                                  "learningObjective": "Executar simulações estocásticas eficientes em sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Não paralelizar (tempo excessivo)",
                                    "Overflow numérico em integrações",
                                    "Seeds fixos invalidando aleatoriedade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e calcular probabilidades de colapso",
                                  "subSteps": [
                                    "Calcular estatísticas: Pf = N_colapso / N_total para probabilidade de falha.",
                                    "Gerar histogramas de respostas extremas e curvas de fragilidade.",
                                    "Realizar análise de sensibilidade (tornado uma variável por vez).",
                                    "Comparar com métodos analíticos aproximados (ex: FORM).",
                                    "Gerar relatório com visualizações (boxplots, CDFs)."
                                  ],
                                  "verification": "Probabilidade de colapso converge e sensibilidade identifica variáveis chave.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Bibliotecas Pandas/Matplotlib/Seaborn",
                                    "Templates de plots para fragilidade"
                                  ],
                                  "tips": "Use log-probabilidades para Pf muito pequenas (<10^-4).",
                                  "learningObjective": "Interpretar resultados Monte Carlo para avaliação de risco.",
                                  "commonMistakes": [
                                    "Confundir Pf com média de resposta",
                                    "Ignorar caudas pesadas",
                                    "Visualizações enganosas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar risco para design estrutural",
                                  "subSteps": [
                                    "Comparar Pf com critérios de aceitabilidade (ex: Pf < 10^-4/ano).",
                                    "Propor mitigações (ex: aumentar rigidez se sensível a K).",
                                    "Documentar limitações (ex: modelo linear).",
                                    "Simular cenários alternativos (vento vs. sismo).",
                                    "Preparar apresentação de resultados."
                                  ],
                                  "verification": "Relatório final com Pf quantificado e recomendações acionáveis.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Normas de confiabilidade (ex: ISO 2394)",
                                    "Ferramentas de relatório (Jupyter/LaTeX)"
                                  ],
                                  "tips": "Sempre relacione Pf com taxa anual via hazard local.",
                                  "learningObjective": "Traduzir análises probabilísticas em decisões de engenharia.",
                                  "commonMistakes": [
                                    "Não contextualizar Pf com risco anual",
                                    "Sobre-generalizar resultados"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um edifício de 10 andares em MATLAB: amostre rigidez dos pilares (lognormal, CV=0.15), aplique espectro sísmico El Centro, calcule Pf de colapso (deriva >4%) com 10.000 runs. Resultado esperado: Pf ≈ 2x10^-3.",
                              "finalVerifications": [
                                "Modelo multi-DOF responde corretamente a excitação unitária.",
                                "Simulações convergem (variação <1% após 5000 runs).",
                                "Pf calculada com precisão e visualizada em curva de fragilidade.",
                                "Análise de sensibilidade identifica top-3 variáveis críticas.",
                                "Recomendações de design baseadas em resultados.",
                                "Relatório documenta todas premissas e limitações."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo estrutural (frequências modais ±5%).",
                                "Correção das distribuições estocásticas e amostragem.",
                                "Eficiência computacional (tempo <2h para 10k runs).",
                                "Qualidade da análise estatística e visualizações.",
                                "Interpretação correta de risco e sensibilidade.",
                                "Clareza e completude do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Distribuições e análise de Monte Carlo.",
                                "Programação Computacional: Python/MATLAB para simulações numéricas.",
                                "Engenharia Sísmica: Espectros de resposta e normas de design.",
                                "Análise de Dados: Estatísticas descritivas e visualização.",
                                "Gestão de Riscos: Decisões baseadas em incerteza."
                              ],
                              "realWorldApplication": "Em projetos de arranha-céus como o Burj Khalifa, simulações Monte Carlo avaliam risco sísmico/vento para otimizar design, garantindo Pf <10^-5/ano e economizando milhões em sobredimensionamento."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.6.3.3",
                            "name": "Interpretar resultados e convergência",
                            "description": "Analisar histogramas, intervalos de confiança e curvas de convergência de simulações Monte Carlo para tomada de decisões em projetos de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Examinar o Histograma da Distribuição Simulada",
                                  "subSteps": [
                                    "Gerar ou carregar o histograma dos resultados da simulação Monte Carlo.",
                                    "Identificar a forma da distribuição (normal, assimétrica, multimodal).",
                                    "Calcular estatísticas descritivas: média, mediana, desvio padrão e assimetria.",
                                    "Comparar o histograma com distribuições teóricas esperadas.",
                                    "Anotar outliers e suas possíveis causas."
                                  ],
                                  "verification": "Histograma plotado corretamente com estatísticas calculadas e anotadas em um relatório.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de programação (Python com Matplotlib/Seaborn ou MATLAB), dados de simulação Monte Carlo.",
                                  "tips": "Use bins adequados (regra de Sturges) para evitar distorções visuais.",
                                  "learningObjective": "Compreender a distribuição empírica dos resultados da simulação.",
                                  "commonMistakes": "Ignorar outliers sem investigação ou usar número inadequado de bins."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar Intervalos de Confiança",
                                  "subSteps": [
                                    "Calcular intervalos de confiança (ex: 95%) para média e percentis chave usando bootstrap ou fórmula analítica.",
                                    "Plotar intervalos no histograma ou em gráfico separado.",
                                    "Avaliar largura dos intervalos para medir incerteza.",
                                    "Comparar intervalos com limites de segurança aceitáveis no projeto.",
                                    "Documentar implicações para variabilidade dos parâmetros."
                                  ],
                                  "verification": "Intervalos calculados e plotados, com interpretação escrita sobre incerteza.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Bibliotecas SciPy/NumPy (Python) ou funções built-in (MATLAB), dados simulados.",
                                  "tips": "Use bootstrap para distribuições não paramétricas quando a normalidade não é assumida.",
                                  "learningObjective": "Quantificar e interpretar a incerteza nos resultados da simulação.",
                                  "commonMistakes": "Confundir intervalo de confiança com intervalo de predição ou usar nível de confiança inadequado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Curvas de Convergência",
                                  "subSteps": [
                                    "Plotar curvas de convergência: média cumulativa vs. número de simulações.",
                                    "Identificar o número de simulações necessárias para estabilização (plateau).",
                                    "Verificar convergência em múltiplas estatísticas (média, variância, percentis).",
                                    "Calcular erro de convergência (ex: variação relativa).",
                                    "Ajustar número de simulações se necessário e reexecutar."
                                  ],
                                  "verification": "Curvas plotadas mostrando estabilização clara, com número mínimo de simulações definido.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código para curvas cumulativas (Python Pandas/MATLAB), histórico de simulações.",
                                  "tips": "Monitore múltiplas métricas para convergência robusta.",
                                  "learningObjective": "Determinar a suficiência do tamanho da amostra na simulação.",
                                  "commonMistakes": "Parar simulação prematuramente sem plateau visível ou ignorar convergência em percentis extremos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Resultados para Tomada de Decisões",
                                  "subSteps": [
                                    "Sintetizar insights do histograma, intervalos e convergência.",
                                    "Avaliar risco de falha (ex: probabilidade de tensão exceder limite).",
                                    "Comparar cenários (sensibilidade a parâmetros).",
                                    "Recomendar ações: otimizar design, adicionar margens de segurança.",
                                    "Documentar relatório com visualizações e conclusões."
                                  ],
                                  "verification": "Relatório final com síntese, decisões justificadas e recomendações.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramentas de relatório (Jupyter Notebook, LaTeX), todas visualizações anteriores.",
                                  "tips": "Use tabelas de decisão para cenários de risco alto/baixo.",
                                  "learningObjective": "Aplicar análises para decisões informadas em engenharia.",
                                  "commonMistakes": "Superestimar precisão sem verificar convergência ou ignorar contexto do projeto."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Sensibilizar Resultados",
                                  "subSteps": [
                                    "Executar análise de sensibilidade variando parâmetros chave.",
                                    "Comparar com métodos analíticos ou simulações determinísticas.",
                                    "Verificar robustez alterando sementes aleatórias.",
                                    "Documentar limitações e suposições.",
                                    "Preparar apresentação para stakeholders."
                                  ],
                                  "verification": "Análise de sensibilidade documentada com validações cruzadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Código de sensibilidade, referências analíticas.",
                                  "tips": "Varie um parâmetro por vez (one-at-a-time) para clareza.",
                                  "learningObjective": "Garantir confiabilidade das interpretações.",
                                  "commonMistakes": "Não testar sensibilidade ou assumir resultados sem validação cruzada."
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para uma viga de concreto sob carga viva variável, analise o histograma de tensões máximas (média 25 MPa, IC 95% [20-30 MPa]), curva de convergência estabilizando em 10.000 runs, e decida aumentar a seção transversal pois P(falha > 40 MPa) = 5%.",
                              "finalVerifications": [
                                "Histograma e curvas de convergência plotados corretamente.",
                                "Intervalos de confiança calculados com interpretação precisa.",
                                "Número de simulações justificado por convergência.",
                                "Probabilidades de falha quantificadas e comparadas a critérios.",
                                "Relatório com decisões acionáveis e limitações.",
                                "Validações de sensibilidade executadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões em histogramas (80%+ acurácia).",
                                "Correta interpretação de intervalos de confiança e incerteza.",
                                "Detecção adequada de convergência (erro <5%).",
                                "Qualidade da síntese para decisões de engenharia.",
                                "Documentação clara com visualizações profissionais.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e bootstrap.",
                                "Programação: Visualização de dados (Matplotlib, ggplot).",
                                "Matemática: Análise de convergência e limites.",
                                "Gestão de Projetos: Tomada de decisão sob incerteza.",
                                "Física: Mecânica estrutural e confiabilidade."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios, interpretar simulações Monte Carlo para avaliar risco de colapso sob ventos ou sismos, otimizando designs para segurança e custo, como no caso da Ponte de Tacoma Narrows ou edifícios altos em zonas sísmicas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 338
          }
        ],
        "totalSkills": 338
      }
    ]
  }
}