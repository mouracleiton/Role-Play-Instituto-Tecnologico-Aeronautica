{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T19:30:52.498Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - DI-37",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 375
    },
    "areas": [
      {
        "id": "10",
        "name": "Engenharia Civil",
        "description": "Área de concentração em Engenharia Civil, abrangendo métodos computacionais e numéricos aplicados.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "DI-37 - Soluções Computacionais de Problemas da Engenharia Civil",
            "description": "Métodos numéricos para problemas da Engenharia Civil: problema de valor inicial e de contorno, método dos resíduos ponderados, condicionamento e matriz de Gram, autovalores e autofunções, otimização e programação matemática, solução de equações não-lineares, ajuste de curvas, redes neurais artificiais, geração de números aleatórios e método de Monte Carlo.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Problemas de Valor Inicial e de Contorno",
                "description": "Formulação e solução numérica de equações diferenciais com condições iniciais e de contorno.",
                "totalSkills": 31,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Problema de Valor Inicial",
                    "description": "Definição e formulação de equações diferenciais ordinárias com condições especificadas no ponto inicial.",
                    "individualConcepts": [
                      {
                        "id": "37.1.1.1.1",
                        "name": "Definição de Problema de Valor Inicial",
                        "description": "Compreensão conceitual do Problema de Valor Inicial (PVI) como um conjunto de equações diferenciais ordinárias (EDOs) acompanhadas de condições iniciais especificadas em um ponto inicial único.",
                        "specificSkills": [
                          {
                            "id": "37.1.1.1.1.1",
                            "name": "Identificar um Problema de Valor Inicial",
                            "description": "Dado um sistema matemático, reconhecer quando se trata de um PVI, distinguindo-o de problemas de valor de contorno ou outros tipos de problemas diferenciais, com foco em condições iniciais no ponto t = t₀.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Formal de Problema de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Leia a definição: Um PVI consiste em uma equação diferencial ordinária (EDO) y' = f(t, y) com condição inicial y(t₀) = y₀, onde t₀ é um ponto específico.",
                                    "Identifique os componentes essenciais: a EDO de primeira ordem e exatamente uma condição inicial no tempo inicial t₀.",
                                    "Anote exemplos canônicos, como decaimento exponencial ou crescimento populacional.",
                                    "Compare com problemas sem condições iniciais para reforçar o que falta.",
                                    "Resuma em suas palavras: 'PVI = EDO + condição única em t₀'."
                                  ],
                                  "verification": "Escreva uma definição precisa em 2-3 frases e compare com fontes confiáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de EDOs (ex: Boyce & DiPrima)",
                                    "Vídeo introdutório sobre PVIs no YouTube",
                                    "Folha de papel e caneta"
                                  ],
                                  "tips": "Use analogias: pense no PVI como 'estado inicial de um sistema dinâmico em um instante específico'.",
                                  "learningObjective": "Definir corretamente os elementos constitutivos de um PVI.",
                                  "commonMistakes": [
                                    "Confundir com equações integrais",
                                    "Ignorar que deve ser condição única",
                                    "Esquecer o foco em t = t₀"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer a Estrutura Matemática de um PVI",
                                  "subSteps": [
                                    "Examine a forma geral: y'(t) = f(t, y(t)), y(t₀) = y₀.",
                                    "Destaque a presença explícita de y(t₀) = valor conhecido.",
                                    "Verifique ordem da EDO: tipicamente primeira ordem para PVIs básicos.",
                                    "Identifique variáveis independentes (t) e dependentes (y).",
                                    "Pratique parsing: sublinhe a EDO e circule a condição inicial em exemplos dados."
                                  ],
                                  "verification": "Parse 3 equações simples e rotule cada componente corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos impressos de EDOs",
                                    "Calculadora simbólica como Wolfram Alpha",
                                    "Notebook Jupyter para visualização"
                                  ],
                                  "tips": "Sempre busque 'y(t₀) =' como sinal claro de PVI.",
                                  "learningObjective": "Extrair e nomear os componentes de uma equação dada como PVI.",
                                  "commonMistakes": [
                                    "Confundir derivadas de ordem superior sem redução",
                                    "Interpretar condições como parâmetros em vez de iniciais",
                                    "Não notar se t₀ é especificado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar PVI de Problemas de Valor de Contorno (PVC) e Outros",
                                  "subSteps": [
                                    "Estude PVC: condições em pontos distintos, ex: y(0)=a, y(1)=b.",
                                    "Compare tabelas: PVI (1 condição em t₀) vs PVC (2+ condições em ts diferentes) vs BVP (boundary value).",
                                    "Analise exemplos mistos: classifique 5 problemas como PVI, PVC ou outro.",
                                    "Entenda implicações: PVIs para evolução temporal única; PVCs para estados estacionários.",
                                    "Crie fluxograma de decisão: 'Condição única em t₀? -> Sim: PVI'."
                                  ],
                                  "verification": "Classifique corretamente uma lista de 5 problemas variados com justificativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela comparativa impressa",
                                    "Software MATLAB/Octave para simulações",
                                    "Artigos sobre EDOs em engenharia"
                                  ],
                                  "tips": "Lembre: PVI é 'inicial' porque começa em um ponto e evolui para frente.",
                                  "learningObjective": "Distinguir PVI de PVC e outros problemas diferenciais com 100% de acurácia.",
                                  "commonMistakes": [
                                    "Achar PVC como PVI se condições coincidirem",
                                    "Ignorar ordem das EDOs",
                                    "Confundir com problemas de autovalores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Contextos de Engenharia Civil",
                                  "subSteps": [
                                    "Selecione problemas reais: vibração de vigas (y'' + ky=0, y(0)=d0, y'(0)=v0 -> reduzir a sistema de PVIs).",
                                    "Classifique 4 cenários de engenharia: fluxo em tubos, deformação inicial em estruturas.",
                                    "Simule numericamente um PVI usando Euler ou RK4 para validar.",
                                    "Discuta ambiguidades: quando um problema pode ser reinterpretado.",
                                    "Autoavalie com quiz: 10 itens de identificação rápida."
                                  ],
                                  "verification": "Resolva e classifique um problema completo de engenharia como PVI.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software como MATLAB ou Python (SciPy)",
                                    "Casos de estudo em engenharia civil",
                                    "Planilha Excel para tracking"
                                  ],
                                  "tips": "Em contextos computacionais, PVIs são base para solvers numéricos como ode45.",
                                  "learningObjective": "Aplicar identificação de PVI em problemas práticos de engenharia.",
                                  "commonMistakes": [
                                    "Não reduzir EDOs de ordem superior a PVIs",
                                    "Omitir condições de velocidade inicial",
                                    "Confundir com condições de equilíbrio estático"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado: dy/dt = -0.1 y, y(0) = 100 (modelo de resfriamento de concreto em cura). Isso é PVI porque possui EDO de 1ª ordem com condição inicial única y(0)=100 em t=0, permitindo solução única para t ≥ 0.",
                              "finalVerifications": [
                                "Classificar corretamente 90% de 10 problemas mistos como PVI ou não.",
                                "Explicar verbalmente a diferença entre PVI e PVC em <1 minuto.",
                                "Identificar componentes em uma EDO complexa de engenharia.",
                                "Criar um PVI simples a partir de descrição verbal.",
                                "Simular numericamente um PVI e verificar consistência inicial.",
                                "Discutir limitações de PVIs em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de condições iniciais (obrigatório).",
                                "Justificativa clara e concisa para cada classificação.",
                                "Capacidade de diferenciar de PVC/BVP com exemplos.",
                                "Aplicação contextual em engenharia civil.",
                                "Uso correto de terminologia matemática.",
                                "Proficiência em verificação numérica básica."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de sistemas com condições iniciais (ex: osciladores harmônicos).",
                                "Programação: Implementação de solvers numéricos (Python/MATLAB ode solvers).",
                                "Engenharia Mecânica: Modelagem de vibrações estruturais.",
                                "Computação Científica: Métodos de Runge-Kutta para PVIs.",
                                "Estatística: Análise de sensibilidade a condições iniciais."
                              ],
                              "realWorldApplication": "Na engenharia civil, PVIs são usados para simular respostas dinâmicas de estruturas a eventos iniciais como terremotos (deslocamento e velocidade iniciais em t=0), permitindo predições de deformações em pontes ou edifícios via software como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "37.1.1.1.1.2",
                            "name": "Diferenciar PVI de Problema de Valor de Contorno",
                            "description": "Comparar e contrastar PVI, onde condições são dadas no ponto inicial, com Problema de Valor de Contorno (PVC), onde condições são especificadas em pontos distintos do domínio, ilustrando com exemplos simples de EDOs de primeira ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de Problema de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Recordar a forma geral de uma EDO de primeira ordem: dy/dx = f(x, y).",
                                    "Identificar que no PVI, uma condição inicial é dada em um único ponto: y(x₀) = y₀.",
                                    "Explicar a existência e unicidade da solução sob condições de Lipschitz.",
                                    "Esboçar a solução qualitativa: a curva passa exatamente pelo ponto inicial.",
                                    "Resolver um exemplo simples: y' = 2y, y(0) = 1 → y = e^{2x}."
                                  ],
                                  "verification": "Escrever a definição de PVI e resolver corretamente um exemplo básico, confirmando y(0) = 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Referência de EDOs (ex: livro ou PDF online)"
                                  ],
                                  "tips": "Visualize a condição inicial como o 'ponto de partida' da solução única.",
                                  "learningObjective": "Definir PVI e reconhecer suas condições iniciais em EDOs de 1ª ordem.",
                                  "commonMistakes": [
                                    "Confundir com condições em múltiplos pontos",
                                    "Ignorar a unicidade da solução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a definição de Problema de Valor de Contorno (PVC)",
                                  "subSteps": [
                                    "Definir PVC: EDO dy/dx = f(x, y) com condições em pontos distintos, ex: y(a) = α e y(b) = β, onde a ≠ b.",
                                    "Explicar que não há 'inicial' único; a solução deve satisfazer ambas as condições nas 'bordas'.",
                                    "Discutir métodos de solução: método de tiro (shooting) ou linearização.",
                                    "Resolver qualitativamente: a curva deve conectar os dois pontos de contorno.",
                                    "Exemplo simples: y' = 0, y(0) = 1, y(1) = 2 → impossível (ilustrar não-existência)."
                                  ],
                                  "verification": "Escrever definição de PVC e identificar por que o exemplo y' = 0 com y(0)=1, y(1)=2 não tem solução.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de plotagem (ex: Desmos ou Python/Matplotlib)"
                                  ],
                                  "tips": "Pense em PVC como 'encaixar' a solução entre duas extremidades fixas.",
                                  "learningObjective": "Definir PVC e contrastar com condições em pontos separados.",
                                  "commonMistakes": [
                                    "Assumir condição inicial única",
                                    "Não notar possível não-existência de solução"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e contrastar PVI e PVC",
                                  "subSteps": [
                                    "Listar diferenças: PVI (1 condição em x₀), PVC (2 condições em x distintos).",
                                    "Comparar soluções: PVI direto via integração; PVC iterativo (shooting).",
                                    "Analisar estabilidade: PVI sensível a y₀; PVC sensível a condições remotas.",
                                    "Tabela comparativa: condições, método, aplicações.",
                                    "Discutir quando usar cada: PVI para evolução temporal, PVC para perfis espaciais."
                                  ],
                                  "verification": "Criar uma tabela comparativa com pelo menos 5 diferenças chave entre PVI e PVC.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para tabela",
                                    "Planilha (Excel ou Google Sheets)"
                                  ],
                                  "tips": "Use mnemônicos: PVI = 'Partida Inicial', PVC = 'Pontos Variados'.",
                                  "learningObjective": "Identificar diferenças fundamentais entre PVI e PVC em termos de condições e resolução.",
                                  "commonMistakes": [
                                    "Equiparar métodos de solução",
                                    "Ignorar contexto de aplicação (tempo vs. espaço)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com exemplos simples de EDOs de primeira ordem",
                                  "subSteps": [
                                    "Exemplo PVI: y' + y = 1, y(0) = 0 → resolver y = 1 - e^{-x}.",
                                    "Exemplo PVC: y' + y = 1, y(0) = 0, y(1) = 0.5 → ajustar via shooting.",
                                    "Plotar soluções e verificar condições.",
                                    "Classificar 3 problemas dados como PVI ou PVC.",
                                    "Discutir implicações computacionais em software (ex: ode45 no MATLAB para PVI)."
                                  ],
                                  "verification": "Resolver ambos exemplos e plotar, confirmando satisfação das condições.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python ou MATLAB para resolução numérica",
                                    "Desmos para plots"
                                  ],
                                  "tips": "Comece com PVI para ganhar confiança antes do PVC mais complexo.",
                                  "learningObjective": "Aplicar conceitos em exemplos concretos e visualizar diferenças.",
                                  "commonMistakes": [
                                    "Erro em integração analítica",
                                    "Não verificar ambas condições no PVC"
                                  ]
                                }
                              ],
                              "practicalExample": "Em modelagem de fluxo em um canal (Engenharia Civil): PVI para evolução temporal do nível d h/dt = -k h, h(0)=10m; PVC para perfil espacial de temperatura em uma viga dh/dx = -q, h(0)=T1, h(L)=T2.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença principal entre PVI e PVC.",
                                "Classificar corretamente 5 problemas como PVI ou PVC.",
                                "Resolver um PVI simples analiticamente.",
                                "Identificar por que um PVC pode requerer método numérico iterativo.",
                                "Plotar soluções e apontar satisfação das condições.",
                                "Discutir uma aplicação real de cada."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de PVI e PVC (exata vs. vaga).",
                                "Clareza na tabela comparativa (completa com exemplos).",
                                "Correção matemática nos exemplos resolvidos.",
                                "Profundidade na discussão de métodos de solução.",
                                "Criatividade nas conexões com aplicações reais.",
                                "Qualidade dos plots e verificações visuais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Condições iniciais em dinâmica (PVI) vs. perfis em termodinâmica (PVC).",
                                "Programação: Implementação de solvers numéricos (odeint em Python).",
                                "Matemática Numérica: Métodos de Runge-Kutta para PVI, shooting para PVC.",
                                "Engenharia de Software: Modelagem em FEM para PVCs em estruturas."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, PVIs modelam evolução temporal de cargas dinâmicas em pontes (ex: vibrações); PVCs definem perfis de tensão em vigas com condições fixas nas extremidades, essenciais em análise estrutural via elementos finitos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "37.1.1.1.1.3",
                            "name": "Reconhecer Aplicações em Engenharia Civil",
                            "description": "Identificar contextos reais em Engenharia Civil, como modelagem de decaimento de tensões em materiais ou dinâmica inicial de vigas, onde PVIs são usados para descrever evolução temporal a partir de condições iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Componentes de Problemas de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Ler a definição formal de PVI: uma EDO com condições iniciais especificadas em t=0.",
                                    "Identificar os elementos chave: equação diferencial ordinária (EDO), função f(t,y), condições iniciais y(0) e y'(0).",
                                    "Diferenciar PVI de Problemas de Valor de Contorno (PVC).",
                                    "Revisar exemplos matemáticos simples, como decaimento exponencial dy/dt = -ky, y(0)=y0.",
                                    "Anotar como PVIs modelam evolução temporal a partir de um estado inicial."
                                  ],
                                  "verification": "Resumir em 3 frases os componentes de um PVI e dar um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de EDOs (ex: Boyce & DiPrima)",
                                    "Vídeo introdutório sobre PVIs no YouTube",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Visualize PVIs como 'previsões' do futuro de um sistema a partir do presente.",
                                  "learningObjective": "Dominar os fundamentos conceituais de PVIs para reconhecimento em contextos aplicados.",
                                  "commonMistakes": [
                                    "Confundir condições iniciais com de contorno",
                                    "Ignorar a dependência temporal explícita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Aplicações Gerais de PVIs em Engenharia",
                                  "subSteps": [
                                    "Pesquisar como PVIs descrevem sistemas dinâmicos em engenharia (ex: circuitos RC, massas-molas).",
                                    "Mapear conceitos físicos: posição inicial, velocidade inicial → condições iniciais.",
                                    "Discutir limitações: PVIs assumem condições bem definidas no instante inicial.",
                                    "Analisar diagrama de fluxo: estado inicial → EDO → solução temporal.",
                                    "Listar 3 aplicações não civis para contraste (ex: dinâmica de fluidos iniciais)."
                                  ],
                                  "verification": "Criar um mapa mental ligando PVIs a 5 aplicações de engenharia geral.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo online sobre PVIs em engenharia",
                                    "Software como MATLAB para plotar soluções simples",
                                    "Papel e caneta para mapa mental"
                                  ],
                                  "tips": "Sempre pergunte: 'Há um estado inicial conhecido evoluindo no tempo?'",
                                  "learningObjective": "Reconhecer padrões de PVIs em problemas dinâmicos de engenharia.",
                                  "commonMistakes": [
                                    "Generalizar PVCs como PVIs",
                                    "Subestimar o papel das condições iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Aplicações Específicas em Engenharia Civil: Decaimento de Tensões",
                                  "subSteps": [
                                    "Estudar modelagem de tensões em materiais: σ(t) com decaimento viscoelástico, dσ/dt = -kσ, σ(0)=σ0.",
                                    "Simular numericamente um caso: tensão inicial em concreto sob carga súbita.",
                                    "Relacionar a experimentos reais: testes de creep em materiais de construção.",
                                    "Desenhar gráfico de evolução temporal da tensão.",
                                    "Explicar por que é PVI: evolução a partir de tensão inicial conhecida."
                                  ],
                                  "verification": "Descrever um modelo matemático para decaimento de tensão e plotar solução.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB ou Python (SciPy) para simulação",
                                    "Artigo sobre viscoelasticidade em concreto",
                                    "Gráficos impressos de exemplos"
                                  ],
                                  "tips": "Use unidades consistentes (Pa, s) para realismo.",
                                  "learningObjective": "Aplicar PVIs ao decaimento de tensões em materiais civis.",
                                  "commonMistakes": [
                                    "Negligenciar não-linearidades reais",
                                    "Confundir tensão com deformação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer PVIs em Dinâmica Inicial de Vigas e Síntese",
                                  "subSteps": [
                                    "Analisar viga sob carga inicial: equação y'''' + k y'' = 0, com y(0), y'(0), y''(0), y'''(0).",
                                    "Simular deflexão inicial em uma viga cantilever.",
                                    "Comparar com dados experimentais de testes de impacto.",
                                    "Identificar em cenários: vigas em pontes após vento súbito.",
                                    "Praticar: dado um problema civil, classificar como PVI ou não."
                                  ],
                                  "verification": "Classificar 3 cenários de vigas como PVIs e justificar.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software ANSYS ou similar para vigas",
                                    "Vídeos de testes dinâmicos de vigas",
                                    "Lista de 5 problemas de exemplo"
                                  ],
                                  "tips": "Foco em 'instante zero' pós-evento inicial.",
                                  "learningObjective": "Reconhecer PVIs em estruturas civis dinâmicas.",
                                  "commonMistakes": [
                                    "Ignorar momentos iniciais",
                                    "Tratar como estático"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma ponte de concreto sob carga de tráfego inicial súbita, modelar a deflexão da viga central como PVI: EI y''''(x,t) + ρ A y_tt = p(x,t), com condições iniciais y(x,0)=0, y_t(x,0)=v0(x) para capturar vibrações iniciais e garantir estabilidade.",
                              "finalVerifications": [
                                "Liste 3 aplicações de PVIs em Eng Civil com equações simplificadas.",
                                "Dada uma descrição, identifique corretamente se é PVI (acertos >80%).",
                                "Explique diferenças entre PVI em tensões vs. vigas.",
                                "Simule um PVI simples e interprete o gráfico temporal.",
                                "Relacione PVI a um projeto real de construção."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes de PVI (EDO + CI).",
                                "Profundidade de exemplos civis (tensões, vigas).",
                                "Capacidade de simulação e visualização.",
                                "Justificativa clara para uso de PVI vs. outros métodos.",
                                "Integração de condições reais (não-lineares, materiais)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução numérica de EDOs (métodos de Euler, Runge-Kutta).",
                                "Física: Mecânica dos sólidos e dinâmica estrutural.",
                                "Computação: Programação em Python/MATLAB para simulações.",
                                "Química dos Materiais: Propriedades viscoelásticas de concreto/aço."
                              ],
                              "realWorldApplication": "Na análise de estabilidade de edifícios após terremotos iniciais, PVIs modelam vibrações residuais de vigas e colunas a partir de deslocamentos e velocidades iniciais, auxiliando engenheiros a prever colapsos e otimizar reforços em projetos de infraestrutura urbana."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "37.1.1.1.2",
                        "name": "Formulação Matemática do Problema de Valor Inicial",
                        "description": "Capacidade de expressar matematicamente um PVI na forma padrão y' = f(t, y), y(t₀) = y₀, incluindo sistemas de EDOs de ordem superior reduzidos a primeira ordem.",
                        "specificSkills": [
                          {
                            "id": "37.1.1.1.2.1",
                            "name": "Escrever a Forma Padrão de um PVI",
                            "description": "Converter uma EDO de ordem n em um sistema de n EDOs de primeira ordem na forma vetorial Y' = F(t, Y), Y(t₀) = Y₀, especificando claramente as condições iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a ordem da EDO e suas derivadas",
                                  "subSteps": [
                                    "Leia a equação diferencial dada e determine sua ordem n (grau da maior derivada presente).",
                                    "Identifique a função desconhecida y(t) e todas as suas derivadas até a ordem n.",
                                    "Anote as condições iniciais fornecidas, como y(t₀), y'(t₀), ..., y^{(n-1)}(t₀).",
                                    "Verifique se a EDO está na forma padrão ou precisa de rearranjo para isolar a derivada de maior ordem.",
                                    "Esboce um diagrama simples mostrando y, y', y'', ..., y^{(n)}."
                                  ],
                                  "verification": "Confirme que a ordem n está corretamente identificada e todas as condições iniciais estão listadas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora básica"
                                  ],
                                  "tips": "Sempre comece contando o número de derivadas; isso define o tamanho do sistema.",
                                  "learningObjective": "Compreender a estrutura da EDO de ordem superior para prepará-la para redução.",
                                  "commonMistakes": "Confundir ordem com o número de condições iniciais ou ignorar condições não especificadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o vetor de estado Y com funções auxiliares",
                                  "subSteps": [
                                    "Defina y₁(t) = y(t), y₂(t) = y'(t), y₃(t) = y''(t), ..., yₙ(t) = y^{(n-1)}(t).",
                                    "Forme o vetor coluna Y(t) = [y₁(t), y₂(t), ..., yₙ(t)]ᵀ.",
                                    "Escreva as condições iniciais correspondentes: Y(t₀) = [y(t₀), y'(t₀), ..., y^{(n-1)}(t₀)]ᵀ.",
                                    "Verifique a dimensionalidade: Y deve ter n componentes.",
                                    "Anotar explicitamente cada y_i em termos das derivadas de y."
                                  ],
                                  "verification": "O vetor Y tem exatamente n entradas, cada uma correspondendo a uma derivada sucessiva de y.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Folha com a EDO original"
                                  ],
                                  "tips": "Use subscritos consistentes (y1, y2, etc.) para evitar confusão com notação de derivadas.",
                                  "learningObjective": "Criar representações vetoriais equivalentes para EDOs de ordem superior.",
                                  "commonMistakes": "Errar a sequência das derivadas (ex: colocar y'' como y2 em vez de y3) ou esquecer a transposta ᵀ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o sistema de EDOs de primeira ordem",
                                  "subSteps": [
                                    "Calcule as derivadas: y₁' = y₂, y₂' = y₃, ..., y_{n-1}' = yₙ.",
                                    "Para yₙ', isole a derivada de ordem n da EDO original e expresse em termos de y₁, ..., yₙ e t.",
                                    "Escreva o vetor F(t, Y) onde a i-ésima componente é y_i' para i=1 a n.",
                                    "Substitua todas as derivadas de y pelas y_i correspondentes na equação original.",
                                    "Simplifique expressões algébricas se necessário."
                                  ],
                                  "verification": "Cada equação é de primeira ordem e o sistema tem n equações independentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para simplificações"
                                  ],
                                  "tips": "Rearranje a EDO para y^{(n)} = f(t, y, y', ..., y^{(n-1)}) antes de substituir.",
                                  "learningObjective": "Transformar EDOs não-lineares ou lineares em sistemas vetoriais acionáveis.",
                                  "commonMistakes": "Não isolar corretamente yₙ' ou deixar termos com derivadas de ordem superior."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever a forma padrão completa do PVI",
                                  "subSteps": [
                                    "Compile o sistema como Y' = F(t, Y), listando explicitamente cada componente de F.",
                                    "Especifique Y(t₀) = Y₀ com valores numéricos ou simbólicos das condições iniciais.",
                                    "Verifique consistência: substitua de volta para ver se recupera a EDO original.",
                                    "Formate neatamente com notação vetorial (coluna ou linha, conforme convenção).",
                                    "Teste com um valor simples de t₀ para validar condições iniciais."
                                  ],
                                  "verification": "A forma final é Y' = F(t, Y), Y(t₀) = Y₀, e reduzindo recupera a EDO original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta"
                                  ],
                                  "tips": "Use MATLAB ou Python para validar simbolicamente se possível.",
                                  "learningObjective": "Finalizar a formulação padrão pronta para métodos numéricos.",
                                  "commonMistakes": "Esquecer a condição inicial ou inverter componentes de Y₀."
                                }
                              ],
                              "practicalExample": "Dada a EDO y'' + 3y' + 2y = sin(t), y(0)=1, y'(0)=0. Defina Y = [y1, y2]ᵀ onde y1=y, y2=y'. Então Y' = [y2, sin(t) - 3y2 - 2y1]ᵀ, Y(0)=[1,0]ᵀ.",
                              "finalVerifications": [
                                "O sistema possui exatamente n EDOs de primeira ordem.",
                                "O vetor Y tem n componentes correspondentes às derivadas sucessivas.",
                                "F(t,Y) está corretamente expresso sem derivadas de ordem superior.",
                                "Condições iniciais Y(t₀)=Y₀ coincidem com as originais.",
                                "Reduzindo o sistema, recupera-se a EDO original.",
                                "Notação vetorial é consistente (coluna ou linha)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da ordem n e derivadas.",
                                "Correção na definição do vetor Y e suas derivadas.",
                                "Isolamento correto de yₙ' em termos de Y e t.",
                                "Consistência das condições iniciais.",
                                "Clareza e formatação da forma final Y'=F(t,Y), Y(t₀)=Y₀.",
                                "Ausência de erros algébricos ou de substituição."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em solvers numéricos como ode45 no MATLAB ou scipy.integrate em Python.",
                                "Física: Modelagem de sistemas dinâmicos em mecânica (ex: osciladores em estruturas).",
                                "Engenharia Computacional: Pré-processamento para métodos de Runge-Kutta ou Euler.",
                                "Álgebra Linear: Representação matricial para casos lineares homogêneos."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, converte equações de vibração de vigas ou cabos de pontes (ex: y'''' + ky = f(t)) em sistemas de 4 EDOs de 1ª ordem para simulações numéricas de estabilidade estrutural sob cargas dinâmicas como vento ou terremotos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "37.1.1.1.2.2",
                            "name": "Formular PVIs a partir de Problemas Físicos",
                            "description": "Traduzir problemas de Engenharia Civil, como movimento de um pêndulo simples ou resfriamento de estruturas, em PVIs explícitas, definindo variáveis dependentes, independentes e condições iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar e descrever o problema físico",
                                  "subSteps": [
                                    "Leia atentamente a descrição do problema físico, como o movimento de um pêndulo simples ou resfriamento de uma estrutura.",
                                    "Identifique as grandezas principais envolvidas (ex.: ângulo θ para pêndulo, temperatura T para resfriamento).",
                                    "Desenhe um diagrama esquemático representando o sistema físico e suas interações.",
                                    "Liste as leis físicas aplicáveis (ex.: segunda lei de Newton para pêndulo, lei de resfriamento de Newton para estruturas).",
                                    "Defina o domínio temporal relevante (ex.: t ≥ 0)."
                                  ],
                                  "verification": "Verifique se possui um diagrama completo e uma lista clara de grandezas e leis físicas anotadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Descrição do problema físico"
                                  ],
                                  "tips": "Use setas no diagrama para indicar forças ou fluxos de calor, facilitando a visualização.",
                                  "learningObjective": "Compreender as componentes físicas e leis governantes do problema.",
                                  "commonMistakes": [
                                    "Ignorar forças dissipativas como atrito",
                                    "Não definir claramente o sistema de referência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a equação diferencial ordinária (EDO)",
                                  "subSteps": [
                                    "Aplique as leis físicas para expressar aceleração ou taxa de variação em termos das grandezas (ex.: para pêndulo, m l θ'' = -m g sinθ).",
                                    "Simplifique para obter a EDO de segunda ordem ou primeira ordem (ex.: θ'' + (g/l) sinθ = 0).",
                                    "Identifique a ordem da EDO e se é linear ou não linear.",
                                    "Expresse a EDO no formato padrão y' = f(t,y) ou y'' = f(t,y,y') se necessário.",
                                    "Confirme unidades consistentes em todos os termos."
                                  ],
                                  "verification": "A EDO derivada deve balancear dimensionalmente e corresponder às leis físicas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabelas de fórmulas físicas",
                                    "Papel para derivações"
                                  ],
                                  "tips": "Comece com o balanço de forças ou energia para evitar erros algébricos.",
                                  "learningObjective": "Traduzir relações físicas em equações matemáticas diferenciais.",
                                  "commonMistakes": [
                                    "Esquecer fatores como comprimento do pêndulo",
                                    "Linearizar prematuramente sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir variáveis dependentes e independentes",
                                  "subSteps": [
                                    "Identifique a variável independente principal (geralmente o tempo t).",
                                    "Defina a(s) variável(s) dependente(s) (ex.: θ(t) para posição, ou T(t) para temperatura).",
                                    "Especifique se há derivadas (ex.: θ'(t) como velocidade angular).",
                                    "Declare o domínio das variáveis (ex.: t ∈ [0, ∞), θ ∈ [-π, π]).",
                                    "Escreva a EDO explicitamente em termos de y(t), onde y é a dependente."
                                  ],
                                  "verification": "Lista clara de variáveis com suas dependências e domínios anotada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para notação matemática"
                                  ],
                                  "tips": "Use y(t) como notação genérica para facilitar generalizações.",
                                  "learningObjective": "Classificar corretamente as variáveis em um modelo dinâmico.",
                                  "commonMistakes": [
                                    "Confundir dependente com independente",
                                    "Não especificar derivadas necessárias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Especificar condições iniciais e formular o PVI completo",
                                  "subSteps": [
                                    "Determine as condições iniciais baseadas no problema (ex.: θ(0) = θ₀, θ'(0) = 0 para pêndulo em repouso).",
                                    "Garanta que haja tantas condições quanto a ordem da EDO.",
                                    "Escreva o PVI no formato: EDO com y(t₀) = y₀, y'(t₀) = y₀' etc.",
                                    "Verifique se as condições são consistentes com o problema físico.",
                                    "Teste dimensionalidade das condições iniciais."
                                  ],
                                  "verification": "O PVI está escrito de forma explícita e pronta para resolução numérica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para formulação final"
                                  ],
                                  "tips": "Sempre use t=0 como ponto inicial para simplicidade.",
                                  "learningObjective": "Completar a formulação com condições iniciais precisas.",
                                  "commonMistakes": [
                                    "Condições insuficientes para a ordem da EDO",
                                    "Valores iniciais incompatíveis fisicamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar a formulação do PVI",
                                  "subSteps": [
                                    "Substitua valores numéricos simples para verificar comportamento qualitativo.",
                                    "Compare com soluções analíticas conhecidas se aplicável (ex.: aproximação linear para pêndulo pequeno).",
                                    "Identifique possíveis singularidades ou restrições.",
                                    "Documente suposições feitas (ex.: ângulo pequeno, sem amortecimento).",
                                    "Revise todo o PVI para clareza e correção."
                                  ],
                                  "verification": "Simulação mental ou cálculo rápido confirma tendências físicas esperadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/MATLAB para teste rápido"
                                  ],
                                  "tips": "Teste com θ₀ pequeno para validar linearização.",
                                  "learningObjective": "Garantir robustez e precisão da formulação.",
                                  "commonMistakes": [
                                    "Ignorar não-linearidades importantes",
                                    "Não testar consistência"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o movimento de um pêndulo simples de comprimento l=1m, liberado de θ(0)=π/6 rad com velocidade inicial zero: θ''(t) + (9.8/1) sin(θ(t)) = 0, θ(0)=π/6, θ'(0)=0. Para resfriamento de uma laje de concreto: T'(t) = -k (T(t) - T_amb), T(0)=T_inicial.",
                              "finalVerifications": [
                                "Pode derivar corretamente a EDO para pêndulo simples e lei de resfriamento.",
                                "Identifica variáveis dependentes/independentes e condições iniciais sem erros.",
                                "Formula PVI completo para dois problemas físicos diferentes.",
                                "Valida dimensionalmente e qualitativamente o PVI.",
                                "Documenta suposições e limitações claramente.",
                                "Explica verbalmente o processo para um colega."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da EDO (100% correto).",
                                "Correta identificação de variáveis e ordem da EDO.",
                                "Condições iniciais consistentes e suficientes.",
                                "Clareza na documentação do PVI (notação padrão).",
                                "Validação qualitativa ou numérica demonstrada.",
                                "Tratamento de não-linearidades quando aplicável."
                              ],
                              "crossCurricularConnections": [
                                "Física Clássica: Leis de Newton e conservação de energia.",
                                "Matemática: Equações Diferenciais Ordinárias (EDOs).",
                                "Programação: Implementação numérica em Python (SciPy) ou MATLAB.",
                                "Engenharia Mecânica: Modelagem de vibrações estruturais.",
                                "Física Computacional: Simulações de dinâmica."
                              ],
                              "realWorldApplication": "Em engenharia civil, formulação de PVIs é essencial para simular vibrações de pontes (pêndulo como modelo), resfriamento de concreto em barragens ou difusão de calor em fundações, permitindo previsões precisas via métodos numéricos para design seguro e eficiente."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.1.1.1.1"
                            ]
                          },
                          {
                            "id": "37.1.1.1.2.3",
                            "name": "Verificar Consistência de Condições Iniciais",
                            "description": "Analisar se as condições iniciais fornecidas são compatíveis com a EDO, verificando continuidade e consistência para garantir existência local de solução pelo Teorema de Picard-Lindelöf.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o Problema de Valor Inicial (PVI) e seus componentes",
                                  "subSteps": [
                                    "Leia a equação diferencial ordinária (EDO) dada: y' = f(t, y).",
                                    "Identifique o ponto inicial (t₀, y₀).",
                                    "Defina o domínio ou região retangular R ao redor de (t₀, y₀), como |t - t₀| ≤ a, |y - y₀| ≤ b.",
                                    "Anote as hipóteses do Teorema de Picard-Lindelöf: f contínua em R e Lipschitz em y.",
                                    "Verifique se (t₀, y₀) pertence a R."
                                  ],
                                  "verification": "Confirme que todos os componentes estão corretamente anotados e o domínio R é explicitamente definido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notas do teorema de Picard-Lindelöf",
                                    "Exemplo do PVI"
                                  ],
                                  "tips": "Escolha a > 0 e b > 0 pequenos o suficiente para cobrir a região de interesse inicial.",
                                  "learningObjective": "Reconhecer e extrair corretamente os elementos essenciais do PVI para análise de existência.",
                                  "commonMistakes": [
                                    "Confundir y' com f(t,y)",
                                    "Não definir explicitamente o retângulo R",
                                    "Ignorar se (t₀, y₀) está dentro de R"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a continuidade de f(t, y) na região R",
                                  "subSteps": [
                                    "Analise o domínio de f(t, y): identifique singularidades ou pontos de descontinuidade.",
                                    "Teste limites em pontos críticos dentro de R, como divisões por zero ou funções não definidas.",
                                    "Use definições ou gráficos para confirmar que f é contínua em todo R.",
                                    "Calcule exemplos numéricos de f em pontos próximos a (t₀, y₀) para validar.",
                                    "Conclua se f satisfaz a hipótese de continuidade."
                                  ],
                                  "verification": "Demonstre com cálculos ou argumentos que lim_{(t,y)→(t',y')} f(t,y) = f(t',y') para todo (t',y') em R.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou software como GeoGebra/Mathematica",
                                    "Tabela de valores de f"
                                  ],
                                  "tips": "Comece verificando o denominador e raízes pares em expressões racionais.",
                                  "learningObjective": "Aplicar critérios de continuidade para funções multivariáveis em contextos de EDOs.",
                                  "commonMistakes": [
                                    "Assumir continuidade sem checar singularidades",
                                    "Verificar apenas em (t₀, y₀)",
                                    "Confundir continuidade com derivabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a condição de Lipschitz em y na região R",
                                  "subSteps": [
                                    "Lembre a definição: existe K > 0 tal que |f(t, y₁) - f(t, y₂)| ≤ K |y₁ - y₂| para todo t em [t₀-a, t₀+a] e y₁, y₂ em [y₀-b, y₀+b].",
                                    "Calcule a derivada parcial ∂f/∂y e verifique se é contínua e limitada em R (critério suficiente).",
                                    "Estime o supremo de |∂f/∂y| em R para obter K.",
                                    "Se ∂f/∂y não existir, use a definição direta com pontos de grade.",
                                    "Conclua se a condição de Lipschitz local é satisfeita."
                                  ],
                                  "verification": "Forneça um valor explícito de K ou prove a existência via derivada limitada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de cálculo simbólico (Wolfram Alpha)",
                                    "Gráficos de ∂f/∂y"
                                  ],
                                  "tips": "Para funções polinomiais ou lineares, é sempre Lipschitz local; foque em não-lineares.",
                                  "learningObjective": "Dominar o critério de Lipschitz para garantir unicidade de soluções.",
                                  "commonMistakes": [
                                    "Usar Lipschitz global em vez de local",
                                    "Esquecer de fixar t na estimativa",
                                    "Não limitar |∂f/∂y| em toda R"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir sobre a consistência das condições iniciais e existência local de solução",
                                  "subSteps": [
                                    "Resuma os resultados das verificações anteriores: continuidade e Lipschitz.",
                                    "Confirme que todas as hipóteses do Teorema de Picard-Lindelöf são atendidas em R.",
                                    "Discuta implicações: existência e unicidade local de solução em algum intervalo |t - t₀| < h.",
                                    "Identifique inconsistências potenciais, como (t₀, y₀) fora do domínio de f.",
                                    "Documente a conclusão final com justificativa."
                                  ],
                                  "verification": "Escreva uma declaração clara: 'As condições são consistentes; existe solução única local' ou contraponto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resumo das verificações anteriores",
                                    "Enunciado do teorema"
                                  ],
                                  "tips": "Se uma hipótese falha, especule sobre existência via Peano, mas foque em Picard-Lindelöf.",
                                  "learningObjective": "Integrar verificações para aplicar teoremas de existência e unicidade.",
                                  "commonMistakes": [
                                    "Ignorar falhas parciais",
                                    "Concluir unicidade sem Lipschitz",
                                    "Não mencionar o intervalo de existência"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o PVI y' = y / (1 + t²), y(0) = 1. Defina R: |t| ≤ 1, |y - 1| ≤ 1. Verifique: f(t,y) = y/(1+t²) é contínua em R (denominador ≥1 >0). ∂f/∂y = 1/(1+t²) ≤1, então K=1 (Lipschitz). Logo, condições iniciais consistentes; solução única local existe.",
                              "finalVerifications": [
                                "Pode identificar corretamente f(t,y), t₀ e y₀ em qualquer PVI dado.",
                                "Verifica continuidade de f sem erros em funções racionais ou com raízes.",
                                "Calcula corretamente ∂f/∂y e estima K para Lipschitz.",
                                "Aplica o teorema de Picard-Lindelöf com todas as hipóteses explicitadas.",
                                "Conclui corretamente sobre consistência mesmo em casos borderline.",
                                "Documenta domínio R adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes do PVI (20%)",
                                "Correção na verificação de continuidade (25%)",
                                "Domínio da condição de Lipschitz com estimativa de K (25%)",
                                "Conclusão lógica e aplicação do teorema (20%)",
                                "Clareza e completude da documentação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Aplicada: Ligação com análise numérica (método de Euler).",
                                "Física: Modelagem de decaimento em estruturas civis (vibrações).",
                                "Programação: Implementação em Python/MATLAB para solvers de EDOs.",
                                "Engenharia Civil: Simulações de fluxo em tubulações ou estabilidade de solos."
                              ],
                              "realWorldApplication": "Em engenharia civil, verifica-se consistência de condições iniciais em modelos de dinâmica de pontes (EDOs para vibrações) para garantir que simulações numéricas (ex: FEM) convergem a soluções únicas, evitando falhas preditivas em projetos sísmicos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.1.1.1.2"
                            ]
                          },
                          {
                            "id": "37.1.1.1.2.4",
                            "name": "Representar PVIs em Software Numérico",
                            "description": "Preparar a formulação de um PVI para implementação em ferramentas como MATLAB, definindo funções f(t,y) e vetores iniciais conforme referências como Chapra & Canale.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e decompor o PVI matemático",
                                  "subSteps": [
                                    "Identifique a equação diferencial ordinária (EDO) dy/dt = f(t,y).",
                                    "Determine as condições iniciais y(t0) = y0.",
                                    "Revise referências como Chapra & Canale para exemplos de PVIs em engenharia civil.",
                                    "Esboce o problema em pseudocódigo.",
                                    "Verifique se o problema é adequado para solvers numéricos como ode45."
                                  ],
                                  "verification": "Diagrama ou notas confirmam decomposição correta de f(t,y) e y0.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Livro Chapra & Canale (capítulos sobre EDOs)",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Comece com problemas lineares simples para praticar.",
                                  "learningObjective": "Decompor um PVI em componentes acionáveis para codificação.",
                                  "commonMistakes": [
                                    "Confundir f(t,y) com a solução y(t)",
                                    "Ignorar dependências de t em f"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a função f(t,y) em MATLAB",
                                  "subSteps": [
                                    "Abra o MATLAB e crie um arquivo .m para a função.",
                                    "Estruture a função como function dydt = f(t,y).",
                                    "Implemente a expressão de f(t,y) usando vetores para y multidimensional.",
                                    "Teste a função com valores de entrada simples.",
                                    "Adicione comentários explicando cada linha."
                                  ],
                                  "verification": "Função executa sem erros e retorna valores esperados para entradas teste.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "MATLAB instalado",
                                    "Documentação MATLAB ode funções"
                                  ],
                                  "tips": "Use inline functions ou arquivos anônimos para prototipagem rápida.",
                                  "learningObjective": "Codificar corretamente a dinâmica do PVI em formato compatível com solvers.",
                                  "commonMistakes": [
                                    "Retornar escalar em vez de vetor para y vetorial",
                                    "Esquecer de tratar t como entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar condições iniciais e parâmetros do solver",
                                  "subSteps": [
                                    "Defina o vetor inicial y0 conforme o problema.",
                                    "Especifique o intervalo de tempo [t0, tf].",
                                    "Selecione o solver apropriado (ex: ode45 para não-rígidos).",
                                    "Configure opções como tolerâncias RelTol e AbsTol.",
                                    "Crie o script principal com ode45(@f, tspan, y0, options)."
                                  ],
                                  "verification": "Script roda e plota solução sem crashes.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "MATLAB",
                                    "Exemplos de documentação ode45"
                                  ],
                                  "tips": "Use odeset() para opções avançadas e evite spans muito longos inicialmente.",
                                  "learningObjective": "Preparar inputs corretos para integração numérica robusta.",
                                  "commonMistakes": [
                                    "y0 com dimensões erradas",
                                    "tspan como vetor em vez de intervalo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, executar e validar a representação",
                                  "subSteps": [
                                    "Execute o script completo e gere plots de y vs t.",
                                    "Compare com solução analítica se disponível.",
                                    "Analise erros numéricos e ajuste tolerâncias.",
                                    "Salve o código com documentação.",
                                    "Teste com variação de parâmetros para sensibilidade."
                                  ],
                                  "verification": "Plots coincidem com expectativas e código é reutilizável.",
                                  "estimatedTime": "30-50 minutos",
                                  "materials": [
                                    "MATLAB com toolboxs numéricos",
                                    "Solução analítica de referência"
                                  ],
                                  "tips": "Sempre plote múltiplas saídas para problemas vetoriais.",
                                  "learningObjective": "Validar a representação numérica contra critérios de precisão.",
                                  "commonMistakes": [
                                    "Não plotar ou visualizar resultados",
                                    "Ignorar warnings do solver"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVI dy/dt = -0.5*y, y(0)=10 (decaimento em reservatório de água contaminada), defina f(t,y) = -0.5*y; use tspan=[0 10], y0=10, ode45. Plote y(t) que deve decair exponencialmente para ~1.87 em t=10.",
                              "finalVerifications": [
                                "Função f(t,y) codificada e testada independentemente.",
                                "Solução numérica converge sem erros excessivos.",
                                "Condições iniciais aplicadas corretamente no plot inicial.",
                                "Código comentado e modular para reutilização.",
                                "Resultados validados contra solução exata ou referência.",
                                "Sensibilidade a parâmetros testada."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática e semântica do código MATLAB (100% funcional).",
                                "Precisão numérica: erro < 1% vs analítico.",
                                "Estrutura modular: função separada do script principal.",
                                "Documentação completa em comentários.",
                                "Eficiência: tempo de execução razoável (<10s para problemas simples).",
                                "Robustez: lida com y vetorial e opções de solver."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais ordinárias e métodos numéricos (Runge-Kutta).",
                                "Programação: Desenvolvimento de funções em MATLAB/Python.",
                                "Engenharia Civil: Modelagem de dinâmica de fluidos e estruturas.",
                                "Física: Conservação de massa/energia em sistemas contínuos.",
                                "Estatística: Análise de erro e validação numérica."
                              ],
                              "realWorldApplication": "Simulação de decaimento de poluentes em rios ou reservatórios hídricos, previsão de assentamentos em fundações sob carga dinâmica, ou análise de vibrações em pontes para manutenção preditiva em engenharia civil."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.1.1.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Problema de Valor de Contorno",
                    "description": "Definição e formulação de equações diferenciais ordinárias com condições especificadas nos limites do intervalo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1.1",
                        "name": "Definição de Problema de Valor de Contorno",
                        "description": "Conceito fundamental que distingue o Problema de Valor de Contorno (PVC) do Problema de Valor Inicial (PVI), enfatizando condições especificadas nos extremos do intervalo de integração.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1.1",
                            "name": "Diferenciar PVC de PVI",
                            "description": "Identificar e explicar as diferenças entre Problema de Valor Inicial (condições no ponto inicial) e Problema de Valor de Contorno (condições nos limites do intervalo), com exemplos simples de equações diferenciais ordinárias (EDOs).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Definição de Problema de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Leia a definição formal de PVI: uma EDO de ordem n com n condições iniciais especificadas no mesmo ponto t = t0.",
                                    "Identifique os componentes: EDO y' = f(t,y), condições y(t0) = y0, y'(t0) = y1, etc.",
                                    "Estude um exemplo básico: y' = y, y(0) = 1.",
                                    "Anote as características únicas: todas condições no ponto inicial.",
                                    "Resuma em suas palavras o propósito do PVI em modelagem dinâmica."
                                  ],
                                  "verification": "Escreva uma definição precisa de PVI e resolva um exemplo simples manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de EDOs (ex: Boyce & DiPrima), caderno, calculadora.",
                                  "tips": "Use analogia com posição e velocidade inicial de um carro para visualizar.",
                                  "learningObjective": "Definir corretamente PVI e identificar suas condições iniciais.",
                                  "commonMistakes": "Confundir ordem da EDO com número de condições; esquecer que condições são no mesmo ponto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Definição de Problema de Valor de Contorno (PVC)",
                                  "subSteps": [
                                    "Leia a definição formal de PVC: EDO de ordem n com n condições especificadas nos limites do intervalo [a,b].",
                                    "Identifique os componentes: EDO y' = f(t,y), condições como y(a) = α, y(b) = β.",
                                    "Estude um exemplo básico: y'' + y = 0, y(0) = 0, y(π) = 0.",
                                    "Anote as características: condições distribuídas nos extremos do intervalo.",
                                    "Resuma o propósito do PVC em problemas estacionários ou de contorno."
                                  ],
                                  "verification": "Escreva uma definição precisa de PVC e identifique condições em um exemplo dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de EDOs, caderno, software como MATLAB para plotar soluções.",
                                  "tips": "Pense em uma corda esticada fixa nas extremidades como modelo físico.",
                                  "learningObjective": "Definir corretamente PVC e distinguir suas condições de contorno.",
                                  "commonMistakes": "Assumir condições sempre homogêneas; confundir com condições iniciais mistas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Explicar as Diferenças Chave entre PVI e PVC",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: localização das condições (inicial vs. limites), tipos de problemas (evolução temporal vs. estacionário).",
                                    "Discuta métodos de solução: PVI usa métodos de Cauchy (Euler, Runge-Kutta); PVC usa método de tiro ou diferenças finitas.",
                                    "Analise estabilidade: PVI bem-posto; PVC pode ser mal-posto se condições não compatíveis.",
                                    "Explique com diagrama: timeline para PVI vs. intervalo espacial para PVC.",
                                    "Pratique verbalizando as diferenças em 1 minuto."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com pelo menos 5 diferenças e explique oralmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel para tabela, exemplos impressos de EDOs, gravador de voz.",
                                  "tips": "Use mnemônicos: PVI = 'Partida Inicial', PVC = 'Pontos de Contorno'.",
                                  "learningObjective": "Listar e explicar pelo menos 5 diferenças fundamentais entre PVI e PVC.",
                                  "commonMistakes": "Ignorar contexto físico (temporal vs. espacial); super-simplificar diferenças como 'só localização'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar com Exemplos Simples de EDOs",
                                  "subSteps": [
                                    "Resolva um PVI: y' - 2y = 0, y(0)=1 (solução y=e^{2t}).",
                                    "Resolva um PVC: y'' + y = 0, y(0)=0, y(1)=sin(1) (verificar solução particular).",
                                    "Classifique 3 EDOs dadas como PVI ou PVC justificando.",
                                    "Discuta por que um problema de engenharia usa PVC em vez de PVI.",
                                    "Crie seu próprio exemplo híbrido e corrija."
                                  ],
                                  "verification": "Resolva corretamente 2 exemplos e classifique 3 problemas adicionais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora simbólica (Wolfram Alpha), software de EDOs (Python/Scipy).",
                                  "tips": "Verifique soluções plotando graficamente para visualização intuitiva.",
                                  "learningObjective": "Aplicar conceitos diferenciando PVI/PVC em exemplos reais de EDOs.",
                                  "commonMistakes": "Erros em condições de contorno levando a soluções triviais; não normalizar EDOs."
                                }
                              ],
                              "practicalExample": "Em Engenharia Civil, modelar a deflexão de uma viga simplesmente apoiada usa PVC: y'' = M(x)/EI, com y(0)=0, y(L)=0 (condições nos apoios). Já o aquecimento transitório de uma barra usa PVI: u_t = k u_xx, u(x,0)=f(x) (condição inicial em t=0).",
                              "finalVerifications": [
                                "Explique verbalmente a diferença principal entre PVI e PVC sem hesitação.",
                                "Classifique corretamente 5 problemas de EDOs como PVI ou PVC.",
                                "Resolva um PVI e um PVC simples com solução analítica.",
                                "Identifique contexto físico apropriado para cada tipo.",
                                "Crie uma tabela comparativa precisa.",
                                "Discuta limitações de cada abordagem em um parágrafo."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa de PVI (100% correto): 20%",
                                "Definição precisa de PVC (100% correto): 20%",
                                "Lista de pelo menos 5 diferenças chave com explicações: 25%",
                                "Exemplos resolvidos corretamente: 20%",
                                "Aplicação contextual em Engenharia Civil: 15%"
                              ],
                              "crossCurricularConnections": [
                                "Física: Leis de Newton (PVI para movimento) vs. equilíbrio estático (PVC).",
                                "Programação: Implementar solvers numéricos (Runge-Kutta para PVI, método de tiro para PVC).",
                                "Matemática Numérica: Estabilidade e convergência de métodos.",
                                "Engenharia de Materiais: Modelos de difusão (PVI temporal) vs. tensão em placas (PVC)."
                              ],
                              "realWorldApplication": "Na análise estrutural de pontes (Engenharia Civil), PVC modela deflexões de vigas com condições nos apoios; PVI modela vibrações dinâmicas pós-terremoto com condições iniciais de deslocamento e velocidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.1.2",
                            "name": "Reconhecer características do PVC",
                            "description": "Listar e descrever as principais características do PVC, como não-univocidade de soluções, necessidade de condições auxiliares e aplicações em problemas de engenharia civil como vigas e cabos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e diferenças básicas do PVC",
                                  "subSteps": [
                                    "Ler a definição formal de Problema de Valor de Contorno (PVC) em uma equação diferencial ordinária (EDO).",
                                    "Comparar PVC com Problema de Valor Inicial (PVI), destacando a posição das condições.",
                                    "Identificar que no PVC as condições são dadas nas extremidades do intervalo.",
                                    "Estudar exemplos simples de EDOs de segunda ordem.",
                                    "Anotar as diferenças em um diagrama comparativo."
                                  ],
                                  "verification": "Criar um diagrama comparativo PVC vs PVI e explicar verbalmente as diferenças.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de EDOs, vídeo introdutório sobre PVC (ex: Khan Academy ou YouTube), papel e caneta.",
                                  "tips": "Use analogias como 'PVI é como prever o futuro a partir do presente; PVC é encaixar o puzzle nas bordas'.",
                                  "learningObjective": "Diferenciar PVC de PVI e reconhecer a estrutura básica de um PVC.",
                                  "commonMistakes": "Confundir condições iniciais com de contorno; ignorar a ordem da EDO."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as principais características teóricas do PVC",
                                  "subSteps": [
                                    "Listar a não-univocidade de soluções sem condições suficientes.",
                                    "Explicar a necessidade de condições auxiliares (ex: duas condições para EDO de 2ª ordem).",
                                    "Discutir a sensibilidade às condições de contorno.",
                                    "Analisar estabilidade e unicidade com o teorema de existência e unicidade.",
                                    "Registrar exemplos matemáticos de PVC mal posto."
                                  ],
                                  "verification": "Escrever uma lista com 5 características e justificativas curtas para cada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Apostila de Soluções Computacionais (DI-37), calculadora simbólica (ex: Wolfram Alpha), caderno.",
                                  "tips": "Lembre-se: número de condições = ordem da EDO para garantir unicidade.",
                                  "learningObjective": "Descrever com precisão as características como não-univocidade e necessidade de condições auxiliares.",
                                  "commonMistakes": "Subestimar a importância da ordem da derivada; confundir com condições iniciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar aplicações do PVC em problemas de Engenharia Civil",
                                  "subSteps": [
                                    "Estudar PVC em vigas (ex: equação de Euler-Bernoulli com condições de apoio).",
                                    "Analisar PVC em cabos (ex: catenária com fixações nas extremidades).",
                                    "Identificar outros exemplos como flambagem de colunas.",
                                    "Resolver um PVC simples numericamente ou analiticamente.",
                                    "Mapear como condições de contorno refletem apoios reais."
                                  ],
                                  "verification": "Desenhar esquemas de uma viga e um cabo com condições de contorno anotadas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de simulação (ex: MATLAB ou Python com SciPy), diagramas de estruturas civis.",
                                  "tips": "Visualize: extremidades fixas = deslocamento e rotação zero.",
                                  "learningObjective": "Associar características do PVC a problemas reais como vigas e cabos.",
                                  "commonMistakes": "Ignorar simplificações lineares em modelos reais; não ligar teoria à prática."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e verificar o reconhecimento das características",
                                  "subSteps": [
                                    "Compilar uma lista completa de características do PVC.",
                                    "Criar um fluxograma de resolução de PVC.",
                                    "Testar com um problema exemplo resolvendo passo a passo.",
                                    "Discutir limitações computacionais em PVCs complexos.",
                                    "Autoavaliar o conhecimento com perguntas de revisão."
                                  ],
                                  "verification": "Produzir um resumo de 1 página com lista, exemplos e fluxograma.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Caderno de resumo, timer para autoavaliação.",
                                  "tips": "Revise com flashcards para fixar termos chave como 'não-univocidade'.",
                                  "learningObjective": "Integrar todas as características em um entendimento coeso.",
                                  "commonMistakes": "Listar características sem exemplos concretos; pular síntese."
                                }
                              ],
                              "practicalExample": "Em uma viga em voladizo de comprimento L, fixa em x=0 e livre em x=L, sujeita a carga uniforme q, o PVC é: EI y'''' = q, com y(0)=0, y'(0)=0, y''(L)=0, y'''(L)=0. Isso ilustra não-univocidade sem condições completas e aplicações em estruturas civis.",
                              "finalVerifications": [
                                "Listar corretamente pelo menos 5 características principais do PVC.",
                                "Explicar não-univocidade com um exemplo matemático.",
                                "Identificar condições auxiliares necessárias para uma EDO de 2ª ordem.",
                                "Descrever aplicações em vigas e cabos com condições de contorno específicas.",
                                "Comparar PVC com PVI em termos de posicionamento de condições.",
                                "Resolver um PVC simples analiticamente ou numericamente."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todas as características principais listadas e descritas.",
                                "Precisão: Definições teóricas corretas sem erros conceituais.",
                                "Profundidade: Exemplos práticos relevantes à Engenharia Civil.",
                                "Clareza: Explicações concisas e bem estruturadas.",
                                "Aplicação: Capacidade de ligar teoria a problemas reais.",
                                "Originalidade: Uso de analogias ou diagramas próprios."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações Diferenciais Ordinárias e Teoremas de Existência.",
                                "Física: Mecânica dos Materiais e Teoria de Vigas.",
                                "Computação: Métodos Numéricos para PVC (ex: Método dos Elementos Finitos).",
                                "Engenharia Mecânica: Análise de Estruturas e Flambagem."
                              ],
                              "realWorldApplication": "No projeto de pontes, edifícios e torres, PVCs modelam o comportamento de vigas, colunas e cabos de suspensão, garantindo estabilidade estrutural sob cargas reais, com condições de contorno representando apoios e fixações."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.1.3",
                            "name": "Classificar tipos de PVC",
                            "description": "Classificar problemas de valor de contorno em lineares e não-lineares, bem como em problemas de contorno de segunda ordem, relacionando com equações elásticas em estruturas civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Fundamental de Problemas de Valor de Contorno (PVC)",
                                  "subSteps": [
                                    "Estude a definição formal de um PVC: uma equação diferencial com condições de contorno especificadas em pontos distintos do domínio.",
                                    "Identifique os componentes chave: equação diferencial ordinária (EDO) ou parcial (EDP), domínio e condições de contorno.",
                                    "Diferencie PVC de Problemas de Valor Inicial (PVI), destacando que PVCs têm condições em fronteiras espaciais.",
                                    "Analise exemplos simples de PVCs em uma dimensão, como a equação de Laplace em uma barra.",
                                    "Registre anotações sobre os tipos de condições de contorno: Dirichlet (valor fixo), Neumann (derivada fixa) e Robin (mistura)."
                                  ],
                                  "verification": "Crie um fluxograma resumindo a definição e componentes de um PVC, e explique verbalmente para um colega.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de EDOs (ex: Boyce & DiPrima)",
                                    "Apostila de Soluções Computacionais em Engenharia Civil",
                                    "Papel e caneta para fluxograma"
                                  ],
                                  "tips": "Use diagramas visuais para representar o domínio e condições de contorno; evite memorização sem compreensão.",
                                  "learningObjective": "Compreender os elementos essenciais de um PVC para basear classificações subsequentes.",
                                  "commonMistakes": [
                                    "Confundir PVC com PVI",
                                    "Ignorar o tipo de equação diferencial (ordinária vs parcial)",
                                    "Não distinguir condições de contorno de condições iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar PVCs em Lineares e Não-Lineares",
                                  "subSteps": [
                                    "Defina linearidade: superposição de soluções e homogeneidade da equação diferencial.",
                                    "Examine critérios para lineares: coeficientes constantes ou funções lineares de y e y'; não-lineares envolvem termos como y^2 ou sen(y).",
                                    "Resolva exemplos lineares: y'' + y = 0 com y(0)=0, y(1)=1.",
                                    "Resolva exemplos não-lineares: y'' + y y' = 0 com condições similares.",
                                    "Crie uma tabela comparativa de propriedades, soluções analíticas e métodos numéricos para cada tipo."
                                  ],
                                  "verification": "Classifique 5 equações de PVC fornecidas como linear ou não-linear, justificando cada uma por escrito.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB ou Python (SymPy para verificação simbólica)",
                                    "Lista de 10 equações de PVC de exemplo",
                                    "Planilha para tabela comparativa"
                                  ],
                                  "tips": "Teste superposição em exemplos duvidosos; pratique com equações reais de engenharia.",
                                  "learningObjective": "Dominar a distinção entre PVC lineares e não-lineares baseada em propriedades matemáticas.",
                                  "commonMistakes": [
                                    "Classificar erroneamente termos não-lineares como lineares",
                                    "Esquecer de verificar dependência não-linear nas condições de contorno",
                                    "Não considerar coeficientes variáveis como potenciais não-lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar PVCs por Ordem, com Ênfase em Segunda Ordem",
                                  "subSteps": [
                                    "Revise ordem de EDOs: maior derivada presente (primeira, segunda, etc.).",
                                    "Analise PVCs de segunda ordem: comuns em problemas elásticos, como y'' = f(x) com duas condições de contorno.",
                                    "Compare com primeira ordem: y' = f(x,y) com uma condição.",
                                    "Estude condições necessárias: n condições para ordem n.",
                                    "Exercite classificação de 5 PVCs mistos, identificando ordem e adequação das condições."
                                  ],
                                  "verification": "Monte um conjunto de 3 PVCs de segunda ordem válidos e invalide um de primeira ordem mal condicionado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exercícios de apostila DI-37",
                                    "Calculadora gráfica ou app de EDOs",
                                    "Folhas de exercícios impressas"
                                  ],
                                  "tips": "Sempre conte o número de condições de contorno para validar a ordem.",
                                  "learningObjective": "Identificar e justificar a ordem de PVCs, focando em segunda ordem relevante para engenharia.",
                                  "commonMistakes": [
                                    "Contar derivadas incorretamente",
                                    "Permitir mais/menos condições que a ordem requer",
                                    "Confundir ordem da EDO com tipo de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Classificações de PVC com Equações Elásticas em Estruturas Civis",
                                  "subSteps": [
                                    "Estude a equação elástica básica: EI y'''' = q(x) para vigas (quarta ordem, mas reduza a segunda ordem via integração).",
                                    "Classifique equações elásticas como PVCs lineares de segunda ordem em deflexão.",
                                    "Aplique classificações: linear para materiais elásticos lineares; não-linear para grandes deformações.",
                                    "Simule um PVC elástico em uma viga engastada: condições de contorno y(0)=y'(0)=0, y(L)=y'(L)=0.",
                                    "Discuta métodos computacionais: diferenças finitas para PVCs lineares de segunda ordem."
                                  ],
                                  "verification": "Classifique e resolva numericamente um PVC elástico simples, plotando a solução.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Python com script de diferenças finitas",
                                    "Exemplo de viga de apostila",
                                    "Gráfico de deflexão de viga"
                                  ],
                                  "tips": "Use unidades consistentes em simulações; relacione com software como ANSYS.",
                                  "learningObjective": "Conectar classificações teóricas de PVC a aplicações práticas em estruturas civis.",
                                  "commonMistakes": [
                                    "Ignorar simplificações de ordem superior para elástica",
                                    "Não relacionar linearidade ao comportamento material",
                                    "Esquecer condições de contorno reais em estruturas"
                                  ]
                                }
                              ],
                              "practicalExample": "Classifique o problema de deflexão de uma viga simplesmente apoiada sob carga uniforme: EI y'''' = q, com y(0)=y(L)=0, y''(0)=y''(L)=0. Integre para PVC de segunda ordem linear: y'' = M(x)/EI com condições de momento zero nas extremidades.",
                              "finalVerifications": [
                                "Classifica corretamente 90% de 10 PVCs mistos como linear/não-linear e por ordem.",
                                "Explica a relação entre PVC de segunda ordem linear e equação de viga elástica.",
                                "Identifica condições de contorno inadequadas em exemplos inválidos.",
                                "Resolve um PVC elástico simples analítica ou numericamente.",
                                "Cria tabela de classificação relacionando a 3 problemas civis reais.",
                                "Discute limitações de PVCs não-lineares em estruturas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção linear/não-linear (40%)",
                                "Correta identificação de ordem e condições (30%)",
                                "Relevância das conexões com engenharia civil (20%)",
                                "Clareza e completude de justificativas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Equações Diferenciais Ordinárias e Parciais",
                                "Física: Mecânica dos Materiais e Teoria de Elasticidade",
                                "Computação: Métodos Numéricos (Diferenças Finitas, Elementos Finitos)",
                                "Engenharia Mecânica: Análise de Tensão e Deformação"
                              ],
                              "realWorldApplication": "Na análise estrutural de pontes e edifícios, classificar PVCs permite escolher métodos numéricos eficientes, como diferenças finitas para vigas lineares elásticas, otimizando projetos contra colapsos como no caso da Ponte Tacoma Narrows."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.1.2",
                        "name": "Formulação Matemática do PVC",
                        "description": "Representação formal das EDOs com condições de contorno, incluindo a forma geral da equação diferencial e as condições especificadas nos limites.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.2.1",
                            "name": "Escrever a forma geral de um PVC",
                            "description": "Formular matematicamente um Problema de Valor de Contorno como y'' + p(x)y' + q(x)y = f(x), com condições y(a) = α e y(b) = β, ou mistas, para intervalos [a,b].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a forma geral de uma EDO linear de segunda ordem",
                                  "subSteps": [
                                    "Identifique os componentes básicos: função desconhecida y(x), derivadas y'(x) e y''(x).",
                                    "Memorize a estrutura padrão: y''(x) + p(x) y'(x) + q(x) y(x) = f(x).",
                                    "Diferencie entre equação homogênea (f(x)=0) e não homogênea (f(x)≠0).",
                                    "Reconheça que p(x), q(x) e f(x) são funções contínuas no intervalo [a,b].",
                                    "Escreva um exemplo simples com coeficientes constantes para fixar."
                                  ],
                                  "verification": "Escreva a forma geral da EDO sem consultar materiais e confira com a definição padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Notas de EDOs lineares",
                                    "Calculadora simbólica opcional"
                                  ],
                                  "tips": "Sempre comece pela derivada de maior ordem para evitar confusões na estrutura.",
                                  "learningObjective": "Compreender e reproduzir a equação diferencial de segunda ordem linear na forma padrão.",
                                  "commonMistakes": [
                                    "Colocar y'' no lado direito",
                                    "Confundir p(x) com q(x)",
                                    "Esquecer parênteses em y'(x)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o intervalo de interesse e as condições de contorno",
                                  "subSteps": [
                                    "Especifique o intervalo fechado [a, b] onde a solução é buscada.",
                                    "Classifique as condições: de Dirichlet (y(a)=α, y(b)=β), Neumann (y'(a)=γ, y'(b)=δ) ou mistas.",
                                    "Garanta que as condições sejam suficientes para unicidade (duas para segunda ordem).",
                                    "Verifique compatibilidade: condições devem ser consistentes com a EDO.",
                                    "Anote exemplos: y(a)=α (deslocamento fixo em a)."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o intervalo e duas condições de contorno para um PVC hipotético.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Exemplos de problemas de engenharia civil"
                                  ],
                                  "tips": "Use diagramas esquemáticos do domínio [a,b] para visualizar as condições.",
                                  "learningObjective": "Identificar e especificar corretamente o domínio e condições de contorno para um PVC.",
                                  "commonMistakes": [
                                    "Usar condições insuficientes (menos de duas)",
                                    "Confundir y(a) com y'(a)",
                                    "Ignorar o intervalo fechado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar a formulação completa do Problema de Valor de Contorno (PVC)",
                                  "subSteps": [
                                    "Combine a EDO com as condições: y'' + p y' + q y = f em [a,b], y(a)=α, y(b)=β.",
                                    "Inclua variações mistas, ex: y(a)=α, y'(b)=β.",
                                    "Escreva em notação matemática formal, destacando todos os elementos.",
                                    "Verifique regularidade: assumir p, q, f contínuos em [a,b].",
                                    "Teste com um caso simples: substitua valores numéricos."
                                  ],
                                  "verification": "Escreva a formulação completa para um exemplo dado e compare com a resposta modelo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor LaTeX online ou papel",
                                    "Tabela de exemplos de PVCs"
                                  ],
                                  "tips": "Use setas ou caixas para separar EDO das condições na escrita.",
                                  "learningObjective": "Formular matematicamente um PVC completo, incluindo EDO e condições.",
                                  "commonMistakes": [
                                    "Esquecer o intervalo [a,b]",
                                    "Misturar condições de Dirichlet e Neumann incorretamente",
                                    "Omitir funções p,q,f"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e praticar a formulação com exemplos reais",
                                  "subSteps": [
                                    "Aplique a um problema físico: ex. viga com carga distribuída.",
                                    "Identifique p,q,f a partir da física (ex. p=0, q=0, f=-w(x)/EI).",
                                    "Escreva três formulações diferentes: homogênea, não homogênea, mista.",
                                    "Discuta existência e unicidade brevemente (teorema de existência).",
                                    "Autoavalie corrigindo erros comuns."
                                  ],
                                  "verification": "Resolva ou verifique um PVC exemplo fornecido, confirmando todos os elementos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de engenharia civil (vigas, cabos)",
                                    "Software como MATLAB para visualização opcional"
                                  ],
                                  "tips": "Comece com casos simples (constantes) antes de funções variáveis.",
                                  "learningObjective": "Aplicar a formulação geral a contextos reais e validar a escrita.",
                                  "commonMistakes": [
                                    "Não especificar unidades ou contexto físico",
                                    "Ignorar hipóteses de regularidade",
                                    "Confundir PVC com PVI"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga simplesmente apoiada de comprimento L=5m com carga distribuída w(x)=x (kN/m), a EDO é y''(x) = x / (EI), com condições y(0)=0 e y(5)=0, onde EI é a rigidez flexural constante. Formulação: y''(x) = x/(EI) para x ∈ [0,5], y(0)=0, y(5)=0.",
                              "finalVerifications": [
                                "Reproduz corretamente a forma geral y'' + p y' + q y = f.",
                                "Especifica o intervalo [a,b] explicitamente.",
                                "Inclui pelo menos duas condições de contorno adequadas.",
                                "Distingue entre condições de Dirichlet, Neumann ou mistas.",
                                "Identifica corretamente funções p(x), q(x), f(x).",
                                "Valida com um exemplo físico simples."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da EDO e condições (100% dos termos presentes).",
                                "Clareza na notação e formatação (uso de símbolos padrão).",
                                "Adequação do número e tipo de condições de contorno.",
                                "Inclusão do intervalo [a,b] e hipóteses de regularidade.",
                                "Capacidade de aplicar a um contexto de engenharia civil.",
                                "Ausência de erros comuns como inversão de derivadas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de equilíbrios em mecânica estrutural.",
                                "Programação: Implementação em métodos numéricos como diferenças finitas.",
                                "Engenharia Mecânica: Análise de deformações em materiais.",
                                "Matemática Numérica: Soluções aproximadas via shooting method.",
                                "Análise Computacional: Integração com FEM (Finite Element Method)."
                              ],
                              "realWorldApplication": "Na engenharia civil, formulações de PVCs são essenciais para modelar deflexões em vigas, tensões em cabos suspensos ou distribuições de temperatura em barragens, permitindo simulações computacionais precisas para projeto seguro de estruturas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.1.2.2",
                            "name": "Especificar condições de contorno",
                            "description": "Definir e aplicar condições de contorno de Dirichlet (valor da função), Neumann (derivada) e Robin (combinação linear), ilustrando com problemas de deflexão de vigas em engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Problemas de Valor de Contorno (PVC)",
                                  "subSteps": [
                                    "Estude a definição de PVC como equações diferenciais com condições especificadas em fronteiras.",
                                    "Revise exemplos de equações elípticas, parabólicas e hiperbólicas relevantes para engenharia civil.",
                                    "Identifique a importância das condições de contorno na unicidade da solução.",
                                    "Analise diagramas de domínios geométricos (1D, 2D) comuns em estruturas civis.",
                                    "Resuma diferenças entre condições iniciais e de contorno."
                                  ],
                                  "verification": "Crie um mapa mental conectando PVC a aplicações em vigas e membranas, com pelo menos 5 nós principais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de EDOs (ex: Boyce & DiPrima)",
                                    "Notas de aula sobre PVC",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use analogias físicas: condições de contorno como 'suportes' que fixam o comportamento da estrutura.",
                                  "learningObjective": "Compreender o papel das condições de contorno na formulação de PVC.",
                                  "commonMistakes": [
                                    "Confundir PVC com PVI",
                                    "Ignorar o tipo de equação diferencial",
                                    "Esquecer impacto na estabilidade numérica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Diferenciar Tipos de Condições de Contorno",
                                  "subSteps": [
                                    "Defina Dirichlet: u(x) = g(x) na fronteira (valor prescrito).",
                                    "Defina Neumann: du/dn = h(x) na fronteira (fluxo ou derivada normal prescrita).",
                                    "Defina Robin: a*u + b*du/dn = f(x) (combinação linear).",
                                    "Classifique exemplos: Dirichlet para temperatura fixa, Neumann para isolante térmico.",
                                    "Derive matematicamente cada tipo a partir de princípios físicos."
                                  ],
                                  "verification": "Escreva fórmulas e 2 exemplos físicos para cada tipo, verificando com referência padrão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Apostila de Matemática Aplicada",
                                    "Software simbólico como Mathematica ou SymPy",
                                    "Quadro branco virtual (ex: Jamboard)"
                                  ],
                                  "tips": "Lembre-se: Dirichlet é 'valor', Neumann é 'inclinação', Robin é 'mistura'.",
                                  "learningObjective": "Distinguir precisamente Dirichlet, Neumann e Robin com fórmulas e interpretações físicas.",
                                  "commonMistakes": [
                                    "Confundir derivada normal com tangencial",
                                    "Aplicar Robin como Dirichlet puro",
                                    "Esquecer coeficientes a e b em Robin"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Condições em Equações Diferenciais Simples",
                                  "subSteps": [
                                    "Resolva uma EDO 2ª ordem com Dirichlet: y'' + y = 0, y(0)=0, y(π)=0.",
                                    "Implemente Neumann: y'(0)=0, y'(π)=0 na mesma EDO.",
                                    "Formule Robin: y'(0) + y(0)=0, y'(π) - y(π)=0.",
                                    "Verifique soluções analíticas e plote gráficos.",
                                    "Discuta condições para existência e unicidade."
                                  ],
                                  "verification": "Obtenha soluções corretas e compare gráficos com soluções esperadas (erro <1%).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python (SciPy)",
                                    "Calculadora gráfica",
                                    "Tabelas de soluções de EDOs"
                                  ],
                                  "tips": "Comece com casos homogêneos para simplicidade antes de não-homogêneos.",
                                  "learningObjective": "Especificar e resolver PVC com diferentes condições de contorno.",
                                  "commonMistakes": [
                                    "Erro de sinal na derivada",
                                    "Condições incompatíveis levando a soluções triviais",
                                    "Não normalizar derivada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com Problemas de Deflexão de Vigas em Engenharia Civil",
                                  "subSteps": [
                                    "Modele a equação de Euler-Bernoulli: EI y'''' = q(x) para viga 1D.",
                                    "Especifique Dirichlet para apoio simples: y=0 na extremidade.",
                                    "Use Neumann para momento nulo: y''=0 (rotacao livre).",
                                    "Aplique Robin para suporte elástico: y' + k y =0.",
                                    "Formule um problema completo de viga engastada e resolva numericamente."
                                  ],
                                  "verification": "Gere gráfico de deflexão e verifique se satisfaz todas as condições nos nós.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software FEA como ANSYS ou código Python (FEniCS)",
                                    "Exemplos de vigas de livros de estruturas",
                                    "Dados reais de viga (comprimento, EI)"
                                  ],
                                  "tips": "Visualize a viga fisicamente com régua para intuir condições.",
                                  "learningObjective": "Traduzir problemas reais de vigas em condições de contorno precisas.",
                                  "commonMistakes": [
                                    "Confundir cisalhamento (y''') com momento (y'')",
                                    "Ignorar sinal de deflexão",
                                    "Condições erradas para engaste vs apoio"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Formulação e Verificação Integrada",
                                  "subSteps": [
                                    "Escolha um problema de viga real (ex: ponte simples apoiada).",
                                    "Especifique todas as condições de contorno com justificativa física.",
                                    "Implemente em código e compare com solução analítica.",
                                    "Varie tipos (Dirichlet+Neumann, Robin) e analise sensibilidade.",
                                    "Documente em relatório com equações e gráficos."
                                  ],
                                  "verification": "Relatório aprovado por auto-revisão ou peer: todas condições corretas e solução convergente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Template de relatório LaTeX",
                                    "Banco de problemas de vigas",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Sempre pergunte: 'Isso reflete o suporte físico real?'",
                                  "learningObjective": "Formular autonomamente PVC para aplicações civis com verificação.",
                                  "commonMistakes": [
                                    "Sobredeterminar o sistema (>ordem da EDO)",
                                    "Usar condição errada para simetria",
                                    "Não validar numericamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga de 5m simplesmente apoiada com carga uniforme q=10kN/m, especifique: Dirichlet y(0)=0, y(5)=0; Neumann y''(0)=0, y''(5)=0. Resolva EI y''''=q, obtendo deflexão máxima y_max= q L^4 /(384 EI) no centro.",
                              "finalVerifications": [
                                "Lista correta de condições para viga engastada (Dirichlet y=y'=0 nas extremidades).",
                                "Solução numérica converge para analítica (erro <0.1%).",
                                "Gráficos mostram satisfação exata nas fronteiras.",
                                "Justificativa física para cada tipo escolhida.",
                                "Relatório documenta 3 cenários variados.",
                                "Auto-teste: resolva problema novo em <30min."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática (100% fórmulas corretas).",
                                "Correta associação a contextos físicos (ex: Dirichlet para deslocamento fixo).",
                                "Qualidade de implementação numérica (convergência demonstrada).",
                                "Criatividade em exemplos de vigas reais.",
                                "Clareza no relatório (equações, gráficos legíveis).",
                                "Profundidade em análise de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Física: Leis de Hooke e equilíbrio estático em estruturas.",
                                "Programação: Implementação de métodos de elementos finitos (FEA).",
                                "Engenharia Mecânica: Análise de tensões e deformações.",
                                "Matemática Numérica: Esquemas de diferenças finitas para PVC.",
                                "Design Computacional: Modelagem em software como SAP2000."
                              ],
                              "realWorldApplication": "Em projetos de pontes e edifícios, especificar condições de contorno corretas em software FEA previne colapsos, como no cálculo de deflexão de vigas em viadutos para garantir segurança sob cargas dinâmicas (tráfego, vento)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.2.1.2.3",
                            "name": "Verificar existência e unicidade",
                            "description": "Discutir teoremas de existência e unicidade para PVC lineares homogêneos, relacionando com autovalores e o papel da matriz de Gram em métodos numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação matemática do PVC linear homogêneo",
                                  "subSteps": [
                                    "Defina o problema de valor de contorno (PVC) linear homogêneo na forma geral: L[u] = 0 com condições de contorno homogêneas.",
                                    "Identifique os operadores diferenciais lineares e as condições de contorno de Dirichlet, Neumann ou mistas.",
                                    "Escreva exemplos simples em 1D, como -u''(x) = λu(x) com u(0)=u(1)=0.",
                                    "Discuta o espaço de funções apropriado (e.g., H^1_0).",
                                    "Verifique linearidade e homogeneidade explicitamente."
                                  ],
                                  "verification": "Escreva a formulação geral e um exemplo específico corretamente, sem erros conceituais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (e.g., 'Numerical Analysis' de Burden), caderno de anotações, calculadora.",
                                  "tips": "Use notação padrão para operadores diferenciais para evitar confusões.",
                                  "learningObjective": "Compreender a estrutura matemática básica do PVC linear homogêneo.",
                                  "commonMistakes": "Confundir PVC com PVI (problemas de valor inicial); ignorar homogeneidade nas condições de contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar teoremas de existência e unicidade",
                                  "subSteps": [
                                    "Enuncie o teorema de Fredholm alternativo para operadores elípticos lineares.",
                                    "Explique condições para existência: índice de Fredholm zero e ortogonalidade.",
                                    "Discuta unicidade: solução única se o problema adjunto tem apenas solução trivial.",
                                    "Relacione com o espectro do operador: autovalores não-zero implicam não-unicidade.",
                                    "Prove um caso simples usando multiplicadores de Lagrange."
                                  ],
                                  "verification": "Enuncie e prove corretamente o teorema para um caso 1D, identificando condições.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Referências teóricas (e.g., Evans 'PDE'), software simbólico como Mathematica para verificação.",
                                  "tips": "Memorize o teorema de Fredholm: existência se e só se ortogonalidade para o adjunto.",
                                  "learningObjective": "Dominar os teoremas fundamentais de existência e unicidade para PVCs.",
                                  "commonMistakes": "Esquecer o papel do problema adjunto; confundir existência com unicidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar existência/unicidade com autovalores",
                                  "subSteps": [
                                    "Defina autovalores e autovetores para operadores diferenciais auto-adjuntos.",
                                    "Mostre que autovalor zero implica não-unicidade (kernel não-trivial).",
                                    "Analise o espectro discreto para problemas com condições de contorno homogêneas.",
                                    "Use expansão em autovetores para soluções: u = sum c_k φ_k.",
                                    "Verifique numericamente autovalores usando método da potência."
                                  ],
                                  "verification": "Calcule autovalores para um PVC exemplo e conclua unicidade.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": "MATLAB ou Python (NumPy/SciPy) para eigenvalores, exemplos de código online.",
                                  "tips": "Sempre normalize autovetores para interpretação física.",
                                  "learningObjective": "Conectar teoremas teóricos com análise espectral.",
                                  "commonMistakes": "Ignorar multiplicidade geométrica; assumir todos autovalores reais sem justificar auto-adjunção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o papel da matriz de Gram em métodos numéricos",
                                  "subSteps": [
                                    "Introduza métodos de Galerkin para discretização do PVC.",
                                    "Construa a matriz de rigidez e massa; defina matriz de Gram como <φ_i, φ_j>.",
                                    "Discuta condicionamento: Gram mal-condicionada afeta precisão numérica.",
                                    "Relacione det(G) ≠ 0 com unicidade na base escolhida.",
                                    "Implemente em código e analise autovalores da matriz discretizada."
                                  ],
                                  "verification": "Construa matriz de Gram para uma base simples e verifique invertibilidade.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": "Python com SciPy para montagem de matrizes, tutoriais de FEM (Finite Element Method).",
                                  "tips": "Escolha bases ortogonais (e.g., Legendre) para Gram diagonal.",
                                  "learningObjective": "Entender impactos numéricos na verificação teórica.",
                                  "commonMistakes": "Confundir Gram com matriz de massa; ignorar dependência na escolha de base."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar a um exemplo concreto e sintetizar",
                                  "subSteps": [
                                    "Escolha PVC: viga em flexão -EI u'''' = 0 com contornos fixos.",
                                    "Verifique existência/unicidade via autovalores.",
                                    "Monte discretização Galerkin e Gram.",
                                    "Simule numericamente e compare com teoria.",
                                    "Conclua sobre condições para solução única."
                                  ],
                                  "verification": "Relatório curto com cálculos, código e conclusões corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python/MATLAB pronto, papel para esboços.",
                                  "tips": "Comece com malha grosseira para insights rápidos.",
                                  "learningObjective": "Integrar teoria e prática para verificação.",
                                  "commonMistakes": "Não relacionar de volta aos teoremas iniciais; erros de implementação numérica."
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever em flexão (PVC: EI u''''(x) = 0, u(0)=u'(0)=0, u''(L)=u'''(L)=0), verifique unicidade: autovalor zero existe apenas para cargas zero, Gram em base polinomial é positiva definida, garantindo solução única trivial.",
                              "finalVerifications": [
                                "Enuncie corretamente teorema de existência/unicidade para PVC linear homogêneo.",
                                "Identifique condições baseadas em autovalores (kernel trivial).",
                                "Construa matriz de Gram para base de 3 funções e verifique det(G) > 0.",
                                "Explique impacto de Gram mal-condicionada em métodos numéricos.",
                                "Aplique a exemplo estrutural e conclua unicidade.",
                                "Discuta limitações para operadores não-auto-adjuntos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na enunciação de teoremas (30%).",
                                "Correta relação com autovalores e espectro (25%).",
                                "Construção e análise de matriz de Gram (20%).",
                                "Aplicação numérica sem erros (15%).",
                                "Síntese interdisciplinar e clareza (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores, matrizes definidas positivas.",
                                "Análise Numérica: métodos espectrais, condicionamento.",
                                "Física/Mecânica: modelagem de vigas e estruturas.",
                                "Programação: implementação em Python/MATLAB para FEM."
                              ],
                              "realWorldApplication": "Em engenharia civil, verificar unicidade em análises estruturais computacionais garante simulações confiáveis de vigas/pilares sob cargas, evitando colapsos por ambiguidades matemáticas em software como ANSYS."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.1.3",
                        "name": "Aplicações em Engenharia Civil",
                        "description": "Exemplos práticos de PVC em problemas computacionais da engenharia civil, conectando à formulação e métodos numéricos como resíduos ponderados.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.3.1",
                            "name": "Formular PVC para vigas",
                            "description": "Modelar a equação de Euler-Bernoulli para deflexão de vigas com condições de contorno fixas ou livres, especificando limites e cargas distribuídas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos da equação de Euler-Bernoulli",
                                  "subSteps": [
                                    "Estudar a equação básica EI d⁴w/dx⁴ = q(x), onde w é a deflexão, E módulo de elasticidade, I momento de inércia, q carga distribuída.",
                                    "Identificar hipóteses: viga esguia, deformação pequena, plano de deformação neutra.",
                                    "Listar condições de contorno comuns: empinada (w=0, dw/dx=0), articulada (w=0, d²w/dx²=0), livre (d²w/dx²=0, d³w/dx³=0).",
                                    "Derivar brevemente a relação momento-cisalhante-deflexão.",
                                    "Exemplificar com viga simples sem carga."
                                  ],
                                  "verification": "Capacidade de escrever a equação EI w'''' = q(x) e listar 4 tipos de condições de contorno corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Resistência dos Materiais (ex: Beer & Johnston), papel e lápis, calculadora.",
                                  "tips": "Use diagramas esquemáticos para visualizar condições de contorno.",
                                  "learningObjective": "Compreender a base teórica da equação diferencial para deflexão de vigas.",
                                  "commonMistakes": "Confundir condições de contorno (ex: empinada vs articulada) ou ignorar hipóteses de validade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir geometria, cargas e condições de contorno da viga",
                                  "subSteps": [
                                    "Especificar comprimento L da viga e orientação (horizontal).",
                                    "Desenhar esquema da viga indicando apoios (fixos, livres, etc.).",
                                    "Definir cargas: pontuais P, distribuídas q(x) (uniforme, triangular).",
                                    "Atribuir condições de contorno em x=0 e x=L (ex: w(0)=0, w'(0)=0 para cantilever).",
                                    "Calcular propriedades seção: I e E."
                                  ],
                                  "verification": "Diagrama completo com apoios, cargas e condições de contorno rotuladas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel milimetrado, régua, software de desenho (ex: GeoGebra ou SketchUp básico).",
                                  "tips": "Sempre normalize x de 0 a L para simplificar limites.",
                                  "learningObjective": "Identificar e documentar todos os parâmetros do problema físico.",
                                  "commonMistakes": "Esquecer reação nos apoios ou condições de contorno inconsistentes com o apoio."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a equação diferencial do PVC",
                                  "subSteps": [
                                    "Escrever a EDO de 4ª ordem: EI w''''(x) = q(x).",
                                    "Integrar sequencialmente para obter w''' (cisalhamento), w'' (momento), w' (rotação), w (deflexão).",
                                    "Aplicar condições de contorno para determinar constantes de integração C1 a C4.",
                                    "Especificar limites de integração e domínio x ∈ [0, L].",
                                    "Simplificar para casos comuns (ex: q constante)."
                                  ],
                                  "verification": "Equação diferencial completa com 4 condições de contorno aplicadas e constantes resolvidas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Caderno de exercícios, Wolfram Alpha ou MATLAB para verificação simbólica.",
                                  "tips": "Integre passo a passo e aplique BCs na ordem correta para evitar erros de sinal.",
                                  "learningObjective": "Construir a formulação matemática exata do PVC.",
                                  "commonMistakes": "Erros de sinal nas derivações (ex: V = -EI w''') ou contagem errada de constantes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e especificar solução numérica/computacional",
                                  "subSteps": [
                                    "Verificar dimensionalidade: unidades consistentes em w, q, etc.",
                                    "Discutir método de solução: analítico para casos simples, numérico (diferenças finitas) para q(x) complexa.",
                                    "Implementar em software: definir malha, BCs e solver.",
                                    "Comparar com solução conhecida (ex: tabela de vigas).",
                                    "Documentar limites de validade (ex: viga esguia)."
                                  ],
                                  "verification": "Solução numérica converge para valor analítico conhecido com erro <1%.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB/Python (SciPy), exemplos de código para EDOs de contorno.",
                                  "tips": "Use bvp4c no MATLAB para PVCs automáticos.",
                                  "learningObjective": "Garantir formulação pronta para implementação computacional.",
                                  "commonMistakes": "Ignorar efeitos de cisalhamento em vigas curtas ou não linearidades."
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de L=5m, E=200GPa, I=1e-4 m⁴, com q(x)=10kN/m uniforme: formular EI w''''=10000, BCs w(0)=w'(0)=0, M(L)=V(L)=0. Solução: w(x) = (q/(24EI))(x⁴ - 4L x³ + 6 L² x²).",
                              "finalVerifications": [
                                "Equação diferencial EI w'''' = q(x) corretamente escrita.",
                                "Quatro condições de contorno independentes especificadas.",
                                "Constantes de integração resolvidas analiticamente.",
                                "Dimensionalidade verificada (deflexão em metros).",
                                "Solução bate com caso padrão de tabela de vigas.",
                                "Preparada para solver numérico sem erros de BC."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação da EDO e BCs (90% peso).",
                                "Completude de parâmetros (geometria, cargas, materiais).",
                                "Correção matemática nas integrações e constantes.",
                                "Validação com exemplo numérico ou analítico.",
                                "Clareza na documentação e diagramas.",
                                "Consideração de limites de aplicabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs lineares de 4ª ordem com BCs.",
                                "Física: Mecânica dos sólidos e equilíbrio estático.",
                                "Computação: Métodos numéricos (diferenças finitas, elementos finitos).",
                                "Engenharia Mecânica: Análise de estruturas similares.",
                                "Programação: Implementação em Python/MATLAB para simulação."
                              ],
                              "realWorldApplication": "No projeto de vigas em edifícios, pontes ou lajes, formular PVCs garante cálculo preciso de deflexões para evitar colapsos, otimizando materiais e conformidade com normas como ABNT NBR 6118."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.1.3.2",
                            "name": "Aplicar PVC em cabos e membranas",
                            "description": "Formular problemas de valor de contorno para catenárias em cabos suspensos ou tensões em membranas, definindo condições nos apoios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a geometria e física de cabos suspensos e membranas",
                                  "subSteps": [
                                    "Estudar a catenária como a curva natural de um cabo flexível sob ação uniforme do peso próprio.",
                                    "Analisar as forças envolvidas: tensão horizontal constante e componente vertical variável.",
                                    "Revisar membranas tensionadas, onde a tensão é uniforme e governa equilíbrios em superfícies.",
                                    "Identificar apoios típicos: fixos em posição (Dirichlet) ou com inclinação prescrita (Neumann).",
                                    "Desenhar diagramas de corpo livre para cabos e membranas."
                                  ],
                                  "verification": "Produzir diagramas rotulados mostrando forças, apoios e elementos geométricos corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de Mecânica dos Materiais ou Estruturas",
                                    "Vídeos sobre catenárias no YouTube"
                                  ],
                                  "tips": "Pense na catenária como o formato de uma corrente pendurada para ganhar intuição visual.",
                                  "learningObjective": "Dominar os princípios físicos que justificam as equações de cabos e membranas.",
                                  "commonMistakes": [
                                    "Confundir catenária com parábola, que é aproximação para vãos longos e flechas pequenas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recordar e derivar as equações diferenciais governantes",
                                  "subSteps": [
                                    "Derivar a EDO para catenária: d/dx [T(y') / sqrt(1+(y')²)] = w, levando a y'' = (w/H) sqrt(1+(y')²), onde H é tensão horizontal.",
                                    "Simplificar para forma padrão: y = (H/w) cosh(wx/H + C).",
                                    "Para membranas, recordar a equação de equilíbrio: ∇·(σ ∇u) = p, ou Laplace para tensão constante: ∇²u = 0.",
                                    "Especificar coordenadas: 1D para cabos (x,y), 2D para membranas (x,y ou polar).",
                                    "Verificar dimensionalidade e unidades das equações."
                                  ],
                                  "verification": "Escrever as EDOs completas com todos os parâmetros simbólicos corretos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como Mathematica/MATLAB",
                                    "Folha de derivadas de EDOs",
                                    "Referência de livros de EDOs aplicadas"
                                  ],
                                  "tips": "Mantenha H constante para simplificação inicial em cabos suspensos uniformes.",
                                  "learningObjective": "Capacitar-se a derivar EDOs de 2ª ordem a partir de balanços de forças.",
                                  "commonMistakes": [
                                    "Esquecer o fator sqrt(1+(y')²) na derivada da tensão na catenária."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir condições de contorno nos apoios",
                                  "subSteps": [
                                    "Identificar apoios: y(0) = y0 e y(L) = yL para posições fixas (Dirichlet).",
                                    "Para inclinações: y'(0) = θ0 e y'(L) = θL (Neumann misturado).",
                                    "Em membranas, condições em contorno: u(xb,yb) = valor prescrito ou ∂u/∂n = fluxo.",
                                    "Garantir compatibilidade: número de condições igual à ordem da EDO.",
                                    "Exemplificar com apoios assimétricos comuns em pontes."
                                  ],
                                  "verification": "Listar condições matemáticas explícitas para um caso dado, checando consistência.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Exemplos de problemas resolvidos de livros de Engenharia Civil"
                                  ],
                                  "tips": "Use condições de Dirichlet para posições conhecidas e Neumann para momentos ou inclinações.",
                                  "learningObjective": "Selecionar e formular condições de contorno adequadas aos apoios reais.",
                                  "commonMistakes": [
                                    "Aplicar condições erradas, como Dirichlet em problemas de fluxo livre."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular o problema de valor de contorno completo e validar",
                                  "subSteps": [
                                    "Combinar EDO + condições iniciais/contorno em um BVP formal.",
                                    "Para cabo: y'' = (w/H) sqrt(1+(y')²), y(0)=0, y(L)=h.",
                                    "Para membrana: ∇²φ = 0 em domínio, φ=0 em bordas fixas.",
                                    "Verificar unicidade e existência da solução.",
                                    "Testar com solução analítica conhecida para catenária padrão."
                                  ],
                                  "verification": "Escrever o BVP completo e confirmar que satisfaz um caso teste simples.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software de EDOs como MATLAB/Octave para verificação numérica",
                                    "Templates de BVP"
                                  ],
                                  "tips": "Normalize variáveis (ex: X=x/L) para simplificar numéricos.",
                                  "learningObjective": "Montar BVPs acionáveis para simulações computacionais.",
                                  "commonMistakes": [
                                    "Não especificar domínio ou condições incompletas levando a soluções não únicas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma ponte pênsil com vão de 100m entre apoios, o apoio esquerdo em y=0 e direito em y=5m. Formule o BVP para a catenária: y''(x) = (ρg/H) √(1 + [y'(x)]²), com y(0)=0, y(100)=5, assumindo peso linear ρg=10kN/m e tensão H a estimar.",
                              "finalVerifications": [
                                "A EDO é de 2ª ordem com exatamente duas condições de contorno.",
                                "Condições refletem posições ou derivadas reais nos apoios.",
                                "Solução teste (analítica ou numérica) satisfaz as condições.",
                                "Unidades consistentes em todos os termos.",
                                "Problema é bem-posto (existência e unicidade).",
                                "Preparado para método numérico como shooting ou finite differences."
                              ],
                              "assessmentCriteria": [
                                "Correção da EDO derivada (100% dos termos presentes).",
                                "Precisão nas condições de contorno (tipos e valores).",
                                "Clareza na formulação escrita (simbólica e descritiva).",
                                "Validação com exemplo numérico simples.",
                                "Identificação de parâmetros físicos realistas.",
                                "Capacidade de generalizar para membranas."
                              ],
                              "crossCurricularConnections": [
                                "Física (Mecânica): Equilíbrio estático e tensões.",
                                "Matemática (EDOs): Problemas de contorno não-lineares.",
                                "Computação: Métodos numéricos (shooting, elementos finitos).",
                                "Engenharia Mecânica: Análise de cabos e estruturas tensionadas."
                              ],
                              "realWorldApplication": "Projeto de pontes suspensas (ex: Golden Gate), viadutos com cabos, ou membranas em estádios (ex: Allianz Arena), onde BVPs definem formas ótimas para minimizar material e maximizar estabilidade."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Método dos Resíduos Ponderados",
                    "description": "Técnica numérica para obter soluções aproximadas minimizando resíduos ponderados em equações diferenciais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Fundamentos do Método dos Resíduos Ponderados",
                        "description": "Introdução aos princípios básicos do método, incluindo a definição de resíduo em equações diferenciais e o papel das funções de peso na minimização de erros aproximados.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Identificar o resíduo em aproximações de soluções",
                            "description": "Calcular o resíduo R(x) = L[u_n(x)] - f(x) para uma aproximação u_n(x) em uma equação diferencial linear L[u] = f, diferenciando soluções exatas de aproximadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação diferencial linear e seus componentes",
                                  "subSteps": [
                                    "Identifique o operador diferencial linear L, que é uma combinação linear de derivadas de u(x).",
                                    "Localize a função f(x), o lado direito da equação L[u] = f(x).",
                                    "Revise exemplos de operadores comuns, como L[u] = u'' + p(x)u' + q(x)u.",
                                    "Anote o domínio do problema (ex: intervalo [a,b]) e condições de contorno.",
                                    "Diferencie solução exata (L[u_exata] = f(x), resíduo zero) de aproximada."
                                  ],
                                  "verification": "Escreva a forma geral de L[u] = f(x) e identifique L e f corretamente para um exemplo dado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro-texto de EDOs",
                                    "Exemplos de equações diferenciais lineares"
                                  ],
                                  "tips": "Sempre expresse L explicitamente para evitar confusões em coeficientes variáveis.",
                                  "learningObjective": "Entender os elementos fundamentais da equação diferencial linear.",
                                  "commonMistakes": [
                                    "Confundir operador L com a função f(x)",
                                    "Ignorar coeficientes variáveis em L",
                                    "Esquecer condições de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e representar a aproximação u_n(x)",
                                  "subSteps": [
                                    "Descreva u_n(x) como uma aproximação polinomial ou em série (ex: u_n(x) = a_0 + a_1 x + ... + a_n x^n).",
                                    "Verifique se u_n satisfaz condições de contorno aproximadas.",
                                    "Calcule derivadas necessárias de u_n(x) até a ordem máxima em L.",
                                    "Escolha uma aproximação simples inicial se não fornecida.",
                                    "Compare u_n com solução exata conhecida, se disponível."
                                  ],
                                  "verification": "Esboce u_n(x) e suas derivadas principais, confirmando satisfação aproximada das condições iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora gráfica",
                                    "Software simbólico como Mathematica ou SymPy",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Use aproximações de baixa ordem (n=1 ou 2) para prática inicial.",
                                  "learningObjective": "Selecionar e preparar uma aproximação adequada para análise de resíduo.",
                                  "commonMistakes": [
                                    "Escolher u_n que não satisfaz condições de contorno",
                                    "Erros em cálculo de derivadas de u_n",
                                    "Usar grau polinomial muito alto desnecessariamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o operador L à aproximação u_n(x)",
                                  "subSteps": [
                                    "Substitua u_n(x) no operador L, computando cada termo diferencial.",
                                    "Calcule derivadas de u_n conforme requerido por L (ex: u_n', u_n'').",
                                    "Some os termos lineares para obter L[u_n(x)].",
                                    "Simplifique a expressão algébricamente.",
                                    "Verifique numericamente em pontos chave do domínio."
                                  ],
                                  "verification": "Obtenha L[u_n(x)] simplificada e teste em x=0 ou x=1 para valores esperados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora simbólica",
                                    "Tabela de derivadas polinomiais"
                                  ],
                                  "tips": "Trabalhe termo a termo para evitar erros de combinação.",
                                  "learningObjective": "Executar a aplicação correta do operador diferencial a uma função aproximada.",
                                  "commonMistakes": [
                                    "Erros de diferenciação (regra da cadeia)",
                                    "Sinais incorretos em termos mistos",
                                    "Não simplificar expressões intermediárias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e interpretar o resíduo R(x)",
                                  "subSteps": [
                                    "Subtraia f(x) de L[u_n(x)] para obter R(x) = L[u_n(x)] - f(x).",
                                    "Simplifique R(x) ao máximo.",
                                    "Avalie o sinal e magnitude de R(x) em pontos do domínio.",
                                    "Identifique regiões onde |R(x)| é grande (alta incerteza na aproximação).",
                                    "Compare com resíduo zero da solução exata."
                                  ],
                                  "verification": "R(x) deve ser zero se u_n for exata; plote ou tabule R(x) para visualização.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfica de funções (ex: Desmos ou MATLAB)",
                                    "Exemplo resolvido de EDO"
                                  ],
                                  "tips": "Norme o resíduo (ex: integral de |R|^2) para quantificação global.",
                                  "learningObjective": "Computar o resíduo e usá-lo para avaliar qualidade da aproximação.",
                                  "commonMistakes": [
                                    "Inverter a subtração (f - L[u_n])",
                                    "Ignorar simplificações que zeram termos",
                                    "Não analisar magnitude qualitativamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação u''(x) + u(x) = 0 em [0, π] com u(0)=0, u(π)=0, use u_n(x) = x(π - x). Calcule L[u_n] = u_n'' + u_n = -2 + x(π - x). Como f(x)=0, R(x) = -2 + x(π - x). O resíduo é parabólico, máximo no meio, indicando erro central.",
                              "finalVerifications": [
                                "Cálculo correto de R(x) para pelo menos dois exemplos independentes.",
                                "Identificação de regiões de alto resíduo no domínio.",
                                "Explicação verbal da relação resíduo-erro de aproximação.",
                                "Comparação qualitativa com solução exata.",
                                "Cálculo de norma do resíduo (ex: máximo ou L2).",
                                "Verificação de que R(x)=0 nas condições de contorno."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática no cálculo de derivadas e operador L (100% correto).",
                                "Clareza na simplificação de expressões algébricas.",
                                "Profundidade na interpretação do resíduo (magnitude, localização de erros).",
                                "Eficiência temporal (conclusão dentro do estimado).",
                                "Criatividade em exemplos adicionais ou normalizações.",
                                "Comunicação clara de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Integração com métodos de Galerkin e elementos finitos.",
                                "Programação: Implementação em Python/MATLAB para plot de resíduos.",
                                "Física: Análise de erros em modelos dinâmicos de estruturas.",
                                "Estatística: Medidas de erro como normas L1/L2 do resíduo.",
                                "Engenharia de Software: Validação de solvers numéricos."
                              ],
                              "realWorldApplication": "Em engenharia civil, no método dos elementos finitos para análise de vigas e placas, o resíduo quantifica erros de malha, guiando refinamentos para simulações precisas de tensões em pontes e edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Escolher funções de peso adequadas",
                            "description": "Selecionar funções de peso w_i(x) baseadas no tipo de problema (ex.: polinômiais para problemas de contorno ou funções delta para colocation), justificando sua influência na convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel das funções de peso no Método dos Resíduos Ponderados (MRP)",
                                  "subSteps": [
                                    "Estudar a formulação geral do MRP: ∫ w_i(x) R(x) dx = 0, onde R(x) é o resíduo.",
                                    "Analisar como w_i(x) modula a importância de diferentes regiões do domínio.",
                                    "Revisar exemplos básicos de problemas de valor inicial (PVI) e de contorno (PVC).",
                                    "Identificar o impacto qualitativo das funções de peso na precisão da solução aproximada.",
                                    "Comparar MRP com método de Galerkin (w_i = funções de base)."
                                  ],
                                  "verification": "Resumir em um parágrafo o papel das funções de peso e listar 2 diferenças para Galerkin.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre MRP",
                                    "Livro de métodos numéricos (ex: Chapra)",
                                    "Artigo introdutório sobre métodos de resíduos"
                                  ],
                                  "tips": "Visualize graficamente w_i(x) sobre o domínio para entender a modulação.",
                                  "learningObjective": "Entender conceitualmente como funções de peso afetam a ponderação dos resíduos.",
                                  "commonMistakes": [
                                    "Confundir funções de peso com funções de base",
                                    "Ignorar o domínio de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar funções de peso comuns e suas aplicações típicas",
                                  "subSteps": [
                                    "Listar funções polinomiais (ex: w_i(x) = 1, x, x^2) para PVC suaves.",
                                    "Estudar funções delta δ(x - x_i) para método de colocation.",
                                    "Explorar funções hierárquicas ou sobremesh para subdomínios.",
                                    "Analisar funções exponenciais ou sigmoides para problemas com gradientes acentuados.",
                                    "Consultar tabela de correspondência: PVI → pesos de Runge-Kutta adaptados; PVC → polinomiais."
                                  ],
                                  "verification": "Criar uma tabela com 5 funções de peso, tipo de problema e exemplo de uso.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabela de referência de métodos weighted residuals",
                                    "Software MATLAB/Python para plotar funções",
                                    "Exercícios resolvidos de livros como Finlayson"
                                  ],
                                  "tips": "Plote as funções w_i(x) em software para visualizar diferenças.",
                                  "learningObjective": "Memorizar e diferenciar funções de peso padrão por classe de problema.",
                                  "commonMistakes": [
                                    "Usar delta em PVC contínuos (perde suavidade)",
                                    "Escolher polinômios de alto grau sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer critérios de seleção baseados no tipo de problema",
                                  "subSteps": [
                                    "Classificar problemas: PVC elípticos → polinomiais crescentes; hiperbólicos → pesos localizados.",
                                    "Avaliar condições de contorno: essenciais → pesos delta nos nós; naturais → pesos uniformes.",
                                    "Considerar propriedades da solução exata: oscilatória → pesos adaptativos.",
                                    "Mapear heurística: colocation para simplicidade computacional; momentos para globalidade.",
                                    "Testar em mini-exemplos numéricos simples."
                                  ],
                                  "verification": "Para 3 problemas dados (PVI, PVC elíptico, hiperbólico), selecionar e justificar w_i(x).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplos de problemas de engenharia civil (vigas, placas)",
                                    "Planilha Excel para classificação",
                                    "Código Python básico para MRP"
                                  ],
                                  "tips": "Priorize o tipo de equação diferencial e condições de contorno primeiro.",
                                  "learningObjective": "Desenvolver regras práticas para mapear problemas a funções de peso.",
                                  "commonMistakes": [
                                    "Ignorar tipo de PDE (elíptico vs parabólico)",
                                    "Selecionar sem considerar custo computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar influência na convergência e validar escolhas",
                                  "subSteps": [
                                    "Estudar teoria: ordem de convergência depende de suavidade de w_i e compatibilidade com solução.",
                                    "Simular numericamente: comparar taxas de convergência com diferentes w_i.",
                                    "Analisar erro: norma L2 ponderada vs não ponderada.",
                                    "Documentar justificativa: 'w_i delta acelera convergência local em colocation'.",
                                    "Refinar escolha iterativamente baseado em testes."
                                  ],
                                  "verification": "Implementar MRP simples e mostrar gráfico de erro vs iterações para 2 escolhas de w_i.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python/MATLAB para MRP (template fornecido)",
                                    "Gráficos de convergência de artigos",
                                    "Ferramenta de plotting (Matplotlib)"
                                  ],
                                  "tips": "Monitore norma do resíduo ponderado como métrica de convergência.",
                                  "learningObjective": "Quantificar e justificar como w_i afeta velocidade e precisão de convergência.",
                                  "commonMistakes": [
                                    "Atribuir convergência só a w_i sem controlar malha",
                                    "Não normalizar resíduos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga em flexão (equação EI y'''' = q(x), PVC), para colocation em 5 pontos, escolha w_i(x) = δ(x - x_i) nos nós de contorno e internos; justifique: converge rapidamente em pontos de interesse sem integração complexa, ideal para engenharia civil prática.",
                              "finalVerifications": [
                                "Lista corretamente 4 tipos de funções de peso e aplicações.",
                                "Justifica escolha para PVC vs PVI em um exemplo.",
                                "Explica impacto na convergência com termo matemático (ex: ordem O(h^k)).",
                                "Simula numericamente diferença de convergência.",
                                "Identifica quando evitar funções delta (ex: soluções suaves)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de problemas e seleção de w_i (80% acerto).",
                                "Qualidade da justificação teórica e prática (clareza e correção).",
                                "Demonstração numérica de influência na convergência (gráficos válidos).",
                                "Profundidade dos substeps em exemplos reais de engenharia.",
                                "Ausência de erros comuns como confusão com métodos de elementos finitos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Análise de erro e convergência.",
                                "Programação Computacional: Implementação em Python/MATLAB.",
                                "Física Aplicada: Modelagem de PDEs em mecânica dos sólidos.",
                                "Otimização: Escolha adaptativa de pesos para minimizar erro."
                              ],
                              "realWorldApplication": "Na análise computacional de estruturas civis como pontes ou barragens, selecionar funções delta para colocation acelera simulações de tensões em pontos críticos, otimizando convergência em softwares como ANSYS ou códigos customizados, reduzindo tempo de projeto."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Formular a minimização do resíduo ponderado",
                            "description": "Estabelecer o funcional de erro ∫ w_i(x) R(x) dx = 0 para i=1 a n, derivando as equações normais do método.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais do resíduo e funções de peso",
                                  "subSteps": [
                                    "Defina o resíduo R(x) como a diferença entre o operador diferencial aplicado à solução aproximada e o termo fonte.",
                                    "Explique as funções de peso w_i(x) como funções de teste que ponderam o resíduo em diferentes regiões.",
                                    "Identifique o número de funções de peso n, igual ao número de parâmetros desconhecidos na aproximação."
                                  ],
                                  "verification": "Escreva definições claras de R(x) e w_i(x) e confirme que n corresponde aos graus de liberdade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de métodos numéricos, caderno e caneta",
                                  "tips": "Use diagramas para visualizar como w_i(x) sobrepõem o domínio.",
                                  "learningObjective": "Compreender os componentes básicos do método dos resíduos ponderados.",
                                  "commonMistakes": "Confundir funções de peso com funções base da aproximação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o funcional de erro",
                                  "subSteps": [
                                    "Escreva o funcional de erro E_i = ∫_Ω w_i(x) R(x) dx para i = 1 a n, onde Ω é o domínio.",
                                    "Expanda R(x) = L[u(x)] - f(x), com u(x) = ∑ c_j φ_j(x) a aproximação.",
                                    "Substitua na integral para obter E_i em termos dos coeficientes c_j.",
                                    "verification]: "
                                  ],
                                  "verification": "Verifique se o funcional está corretamente expresso como integral sobre o domínio com pesos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Caderno, lápis, software simbólico como Mathematica ou papel para integrais.",
                                  "tips": "Mantenha a notação consistente para evitar erros de transcrição.",
                                  "learningObjective": "Construir a expressão matemática do funcional de erro ponderado.",
                                  "commonMistakes": "Esquecer os limites de integração ou o sinal do resíduo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer a condição de minimização",
                                  "subSteps": [
                                    "Imponha a condição de ortogonalidade: E_i = 0 para i = 1 a n.",
                                    "Interprete isso como minimização do erro ponderado no sentido médio.",
                                    "Discuta como isso leva a um sistema de n equações para os n desconhecidos c_j."
                                  ],
                                  "verification": "Confirme que δE_i / δc_j = 0 implica nas condições lineares.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Caderno para anotações conceituais.",
                                  "tips": "Pense em termos de projeção ortogonal no espaço de funções.",
                                  "learningObjective": "Entender o princípio variacional da minimização.",
                                  "commonMistakes": "Confundir minimização com colagem de resíduos (método de collocation)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar as equações normais",
                                  "subSteps": [
                                    "Diferencie E_i com respeito a c_k: ∂E_i/∂c_k = ∫ w_i L[φ_k] dx = ∫ w_i f dx.",
                                    "Escreva em forma matricial: A c = b, onde A_ik = ∫ w_i L[φ_k] dx e b_i = ∫ w_i f dx.",
                                    "Verifique simetria para casos como Galerkin (w_i = φ_i)."
                                  ],
                                  "verification": "Derive explicitamente as equações para um caso simples e resolva o sistema.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora ou MATLAB para matrizes simbólicas, exemplos de EDOs.",
                                  "tips": "Comece com n=1 para validar antes de generalizar.",
                                  "learningObjective": "Obter o sistema algébrico solucionável das equações normais.",
                                  "commonMistakes": "Erro no sinal ao derivar ou integrar por partes incorretamente."
                                }
                              ],
                              "practicalExample": "Para a EDO -u'' + u = 0 em [0,1] com u(0)=0, u(1)=0, aproxime u(x) ≈ c x(1-x). Use w1=1 (submétodo de momentos): derive ∫ R dx=0 para achar c.",
                              "finalVerifications": [
                                "O funcional E_i está corretamente definido com integral de w_i R.",
                                "Condições E_i=0 geram n equações independentes.",
                                "Equações normais estão em forma A c = b.",
                                "Verificação numérica: solução aproximada satisfaz BCs e reduz resíduo.",
                                "Comparação com solução exata mostra convergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação do resíduo R(x).",
                                "Correta imposição das condições de minimização.",
                                "Derivação impecável das equações normais.",
                                "Interpretação física correta do método.",
                                "Habilidade em aplicar a um exemplo concreto.",
                                "Identificação de limitações (ex: escolha de pesos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e métodos de projeção.",
                                "Física: Princípios de minimização de energia em mecânica.",
                                "Computação: Implementação em FEA via código (MATLAB/Python).",
                                "Estatística: Analogia com mínimos quadrados ponderados."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado em elementos finitos para análise de estruturas, onde resíduos ponderados minimizam erros em aproximações de tensões/deformações em vigas e placas sob cargas reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Matriz de Gram e Condicionamento",
                        "description": "Construção da matriz associada ao método e análise de sua estabilidade numérica, considerando autovalores e condicionamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Construir a matriz de Gram",
                            "description": "Montar a matriz G_{ij} = ∫ w_i(x) φ_i(x) φ_j(x) dx para bases φ_k(x), computando integrais analítica ou numericamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o domínio, bases φ_k(x) e funções de peso w_i(x)",
                                  "subSteps": [
                                    "Identificar o intervalo de integração [a, b] do problema de valor de contorno.",
                                    "Escolher uma base de funções φ_k(x) apropriada, como polinômios de Legendre ou monomiais.",
                                    "Definir as funções de peso w_i(x) baseadas no método dos resíduos ponderados, garantindo normalização se necessário.",
                                    "Esboçar graficamente as funções para visualização intuitiva.",
                                    "Documentar as escolhas com justificativa teórica."
                                  ],
                                  "verification": "Verificar se as funções φ_k e w_i satisfazem as condições de ortogonalidade ou completude no domínio.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para esboços",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)"
                                  ],
                                  "tips": "Comece com bases simples (ex: polinômios de grau baixo) para problemas iniciais.",
                                  "learningObjective": "Compreender os componentes fundamentais da matriz de Gram no contexto do método.",
                                  "commonMistakes": [
                                    "Escolher bases não contínuas no domínio",
                                    "Ignorar a dependência de w_i no índice i",
                                    "Definir domínio incorreto do problema original"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher e preparar o método de integração",
                                  "subSteps": [
                                    "Avaliar se a integral ∫ w_i φ_i φ_j dx é tratável analiticamente (ex: polinômios).",
                                    "Se analítica, derivar a antiderivada passo a passo.",
                                    "Se numérica, selecionar método de quadratura (ex: Gauss-Legendre ou Simpson).",
                                    "Configurar pontos de quadratura e pesos no software ou manualmente.",
                                    "Testar o método em uma integral simples para validar precisão."
                                  ],
                                  "verification": "Comparar resultado de uma integral teste com valor exato conhecido (erro < 1e-6).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou Mathematica)",
                                    "Bibliotecas numéricas (SciPy para Python)"
                                  ],
                                  "tips": "Prefira analítico para bases baixas; numérico para funções complexas.",
                                  "learningObjective": "Dominar a decisão entre integração analítica e numérica para eficiência.",
                                  "commonMistakes": [
                                    "Usar quadratura inadequada para o grau das funções",
                                    "Esquecer limites de integração",
                                    "Não normalizar pesos de quadratura"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar os elementos individuais G_ij",
                                  "subSteps": [
                                    "Calcular G_ii para i=1 a n (elementos diagonais).",
                                    "Calcular G_ij para i < j e usar simetria G_ji = G_ij.",
                                    "Registrar cada integral com fórmula ou valores numéricos.",
                                    "Automatizar computação em loop se n > 3, usando código.",
                                    "Verificar simetria cruzando G_ij e G_ji."
                                  ],
                                  "verification": "Conferir que G_ij = G_ji para todos i,j e que diagonais são positivas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Excel ou Jupyter Notebook",
                                    "Código Python/MATLAB pronto para loops"
                                  ],
                                  "tips": "Implemente uma função reutilizável para calcular integrais genéricas.",
                                  "learningObjective": "Executar cálculos precisos dos elementos da matriz.",
                                  "commonMistakes": [
                                    "Erro de sinal nas funções",
                                    "Índices trocados i e j",
                                    "Arredondamento excessivo em numérico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a matriz G e realizar verificações iniciais",
                                  "subSteps": [
                                    "Organizar os elementos em uma matriz n x n simétrica.",
                                    "Calcular o determinante ou autovalores para checar condicionamento.",
                                    "Comparar com matriz identidade se bases ortogonais.",
                                    "Visualizar a matriz como heatmap.",
                                    "Documentar o processo completo em relatório."
                                  ],
                                  "verification": "Matriz deve ser simétrica positiva definida (autovalores > 0).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de álgebra linear (NumPy, MATLAB)",
                                    "Ferramenta de visualização (Seaborn)"
                                  ],
                                  "tips": "Use cond( G ) < 1e10 como limite para bom condicionamento.",
                                  "learningObjective": "Assemblar e validar a matriz de Gram completa.",
                                  "commonMistakes": [
                                    "Posicionar elementos incorretamente",
                                    "Ignorar fator de escala nas funções",
                                    "Não checar positividez"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o problema -u''=f em [0,1], u(0)=u(1)=0, use n=2, φ1(x)=x(1-x), φ2(x)=x^2(1-x), w_i(x)=1. Compute G11=∫φ1^2 dx=1/30, G12=∫φ1 φ2 dx=1/105, etc., resultando em G = [[1/30, 1/105], [1/105, 1/140]].",
                              "finalVerifications": [
                                "Matriz G é simétrica (G_ij = G_ji para todo i,j).",
                                "Elementos diagonais G_ii > 0 (positiva definida).",
                                "Condicionamento cond(G) < 1e12.",
                                "Resultados coincidem com computação alternativa (analítica vs numérica).",
                                "Norma Frobenius da matriz faz sentido para as bases escolhidas.",
                                "Autovalores todos positivos."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos elementos G_ij (erro relativo < 1%).",
                                "Correta identificação de simetria e propriedades.",
                                "Justificativa adequada da escolha de bases e método.",
                                "Eficiência computacional (tempo e recursos).",
                                "Relatório claro com fórmulas, código e visualizações.",
                                "Análise de condicionamento incluída."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: propriedades de matrizes simétricas positivas definidas.",
                                "Cálculo Numérico: métodos de quadratura e integração numérica.",
                                "Programação: implementação de loops e funções em Python/MATLAB.",
                                "Análise Matemática: espaços de Hilbert e produtos internos.",
                                "Engenharia Computacional: preparação para métodos de elementos finitos."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, a matriz de Gram é essencial no método de Galerkin para análise de estruturas (ex: vigas, placas), resolvendo equações diferenciais de equilíbrio via soluções computacionais aproximadas, otimizando projetos de pontes e edifícios."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Avaliar o condicionamento da matriz",
                            "description": "Calcular o número de condicionamento cond(G) = ||G|| ||G^{-1}|| usando autovalores, identificando problemas de ill-conditioning em bases mal escolhidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de normas matriciais e número de condicionamento",
                                  "subSteps": [
                                    "Defina norma matricial ||G||_2 como o maior valor singular (σ_max).",
                                    "Explique que para matrizes simétricas positivas definidas como a Matriz de Gram G, ||G||_2 = λ_max (maior autovalor).",
                                    "Descreva cond(G) = ||G||_2 * ||G^{-1}||_2 = λ_max / λ_min, onde λ_min é o menor autovalor positivo.",
                                    "Discuta ill-conditioning: cond(G) >> 1 indica sensibilidade numérica alta.",
                                    "Relacione com bases mal escolhidas em métodos de resíduos ponderados."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos e dê um exemplo verbal de matriz ill-condicionada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de álgebra linear, notas de aula sobre Matriz de Gram, calculadora.",
                                  "tips": "Lembre-se: cond(G) = 1 significa G é perfeitamente condicionada; valores >10^3 são perigosos numericamente.",
                                  "learningObjective": "Entender a definição matemática e implicações do número de condicionamento.",
                                  "commonMistakes": "Confundir norma 2 com norma Frobenius; ignorar que G é simétrica positiva."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir ou obter a Matriz de Gram G e calcular seus autovalores",
                                  "subSteps": [
                                    "Construa G = Φ^T Φ, onde Φ são funções base no método dos resíduos ponderados.",
                                    "Use software para computar autovalores: eig() no MATLAB ou np.linalg.eig() no Python.",
                                    "Ordene autovalores: λ1 ≥ λ2 ≥ ... ≥ λn > 0.",
                                    "Verifique se todos autovalores são positivos (G positiva definida).",
                                    "Registre λ_max e λ_min."
                                  ],
                                  "verification": "Liste os autovalores ordenados e confirme λ_min > 0 com tolerância 1e-10.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software: MATLAB/Python com NumPy/SciPy, matriz Φ de exemplo (2x2 ou 3x3).",
                                  "tips": "Escolha bases ortogonais para testar cond(G)=1 como baseline.",
                                  "learningObjective": "Dominar o cálculo prático de autovalores para matrizes de Gram.",
                                  "commonMistakes": "Não ordenar autovalores; usar autovetores em vez de valores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o número de condicionamento cond(G)",
                                  "subSteps": [
                                    "Compute cond(G) = λ_max / λ_min.",
                                    "Calcule ||G||_2 ≈ λ_max e ||G^{-1}||_2 ≈ 1/λ_min para validação.",
                                    "Compare com cálculo direto de cond() no software.",
                                    "Teste com base mal escolhida: funções lineares dependentes próximas.",
                                    "Registre cond(G) em notação científica."
                                  ],
                                  "verification": "Confirme que cond(G) do software matches λ_max/λ_min dentro de 1% de erro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo software do Step 2, funções base mal condicionadas (ex: φ1=x, φ2=x+εx^2).",
                                  "tips": "Use log10(cond) para escalas grandes; cond>10^6 é crítico em precisão dupla.",
                                  "learningObjective": "Aplicar fórmula cond(G) = ||G|| ||G^{-1}|| via autovalores.",
                                  "commonMistakes": "Dividir λ_min / λ_max em vez de inverso; ignorar arredondamento numérico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o condicionamento e identificar problemas de ill-conditioning",
                                  "subSteps": [
                                    "Classifique: cond<10 bem condicionada; 10-100 moderada; >100 ill-condicionada.",
                                    "Identifique causas: bases lineares dependentes ou mal escaladas.",
                                    "Simule erro: perturbe G e veja amplificação em soluções.",
                                    "Sugira remédios: ortogonalização (Gram-Schmidt) ou bases hierárquicas.",
                                    "Documente relatório com cond e recomendações."
                                  ],
                                  "verification": "Escreva parágrafo explicando se G é ill-condicionada e por quê, com evidências numéricas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software para simulação de perturbações, template de relatório.",
                                  "tips": "Sempre cheque ratio de autovalores consecutivos para detecção precoce.",
                                  "learningObjective": "Avaliar impactos práticos e propor soluções para ill-conditioning.",
                                  "commonMistakes": "Subestimar cond pequeno como problema; não testar perturbações."
                                }
                              ],
                              "practicalExample": "Para G = [[100, 99.9], [99.9, 100]] (bases quase colineares), autovalores ≈199.9 e 0.1, cond(G)≈1999. Ruído de 1e-6 amplifica 2000x na solução, demonstrando ill-conditioning em análise estrutural.",
                              "finalVerifications": [
                                "Cálculo de cond(G) correto para 2 matrizes teste (uma bem, uma mal condicionada).",
                                "Interpretação precisa: identificar ill-conditioning se cond>1000.",
                                "Simulação de erro mostra amplificação proporcional a cond(G).",
                                "Relatório inclui λ_max, λ_min e recomendações.",
                                "Código/software reproduzível sem erros.",
                                "Verificação manual para matriz 2x2 bate com software."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro <1% em cond(G).",
                                "Compreensão conceitual: explicação correta de fórmula via autovalores.",
                                "Análise qualitativa: identificação correta de causas e impactos.",
                                "Uso de ferramentas: código limpo e comentado.",
                                "Criatividade: sugestões práticas para melhorar condicionamento.",
                                "Documentação: relatório claro e completo."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: estabilidade de algoritmos de inversão.",
                                "Física/Engenharia: estabilidade em elementos finitos e dinâmica estrutural.",
                                "Programação: implementação eficiente de eigendecomposição.",
                                "Estatística: análise de variância em regressão com bases colineares."
                              ],
                              "realWorldApplication": "Em engenharia civil, avaliar cond(G) previne erros catastróficos em simulações de estruturas via métodos de resíduos ponderados, como previsão de deformações em pontes com malhas mal condicionadas, evitando colapsos por amplificação numérica."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Analisar autovalores e autofunções",
                            "description": "Determinar autovalores e autofunções da matriz de Gram para avaliar ortogonalidade e convergência do método em problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Matriz de Gram e Autovalores",
                                  "subSteps": [
                                    "Defina a matriz de Gram como G_{ij} = <φ_i, φ_j> para funções base φ no espaço de resíduos ponderados.",
                                    "Explique o papel da matriz de Gram na avaliação de ortogonalidade das funções base.",
                                    "Revise a definição de autovalores λ e autofunções v de uma matriz A onde Av = λv.",
                                    "Discuta como autovalores reais e positivos indicam matriz definida positiva (ortogonalidade).",
                                    "Estude o número de condicionamento cond(G) = λ_max / λ_min para convergência do método."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e forneça um exemplo simples de matriz 2x2.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de métodos numéricos (ex: Burden & Faires)",
                                    "Notebook com Python/NumPy ou MATLAB",
                                    "Notas de aula sobre métodos dos resíduos ponderados"
                                  ],
                                  "tips": "Use diagramas para visualizar inner products; foque em propriedades simétricas da Gram.",
                                  "learningObjective": "Compreender a relação entre matriz de Gram, ortogonalidade e autovalores.",
                                  "commonMistakes": [
                                    "Confundir inner product com produto escalar euclidiano",
                                    "Ignorar normalização das funções base",
                                    "Esquecer que Gram é sempre simétrica e semi-definida positiva"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Matriz de Gram para um Problema Específico",
                                  "subSteps": [
                                    "Selecione um problema de valor de contorno em engenharia civil (ex: equação de Laplace para tensão em placa).",
                                    "Escolha funções base φ_i (ex: polinômios ou funções hat).",
                                    "Calcule os inner products <φ_i, φ_j> = ∫_Ω w(x) φ_i(x) φ_j(x) dx numericamente ou analiticamente.",
                                    "Monte a matriz G com elementos G_{ij}.",
                                    "Verifique simetria e positividez semi-definida inicial."
                                  ],
                                  "verification": "Gere a matriz G e confirme G = G^T e trace(G) > 0.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de integração numérica (SciPy/quad)",
                                    "Definição do problema de contorno (ex: viga cantilever)",
                                    "Calculadora simbólica (SymPy)"
                                  ],
                                  "tips": "Use quadratura Gauss para integrais; comece com baixa dimensão (n=3-5).",
                                  "learningObjective": "Construir corretamente a matriz de Gram para funções base não-ortogonais.",
                                  "commonMistakes": [
                                    "Erro em limites de integração do domínio Ω",
                                    "Peso w(x) incorreto",
                                    "Funções base não satisfazendo condições de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Autovalores e Autofunções",
                                  "subSteps": [
                                    "Use biblioteca eig (NumPy.linalg.eig ou MATLAB eig) para decompor G = V Λ V^{-1}.",
                                    "Ordene autovalores em ordem decrescente: λ1 ≥ λ2 ≥ ... ≥ λn.",
                                    "Identifique autofunções correspondentes e normalize-as.",
                                    "Verifique numericamente: G v_i ≈ λ_i v_i para cada i.",
                                    "Calcule o raio espectral ρ = max|λ| (deve ser <1 para convergência em alguns métodos)."
                                  ],
                                  "verification": "Confirme erro residual ||G v - λ v|| < 1e-10 para todos autovetores.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "MATLAB ou Octave",
                                    "Jupyter Notebook para plots"
                                  ],
                                  "tips": "Para matrizes grandes, use eigsh para autovalores esparsos; plote espectro.",
                                  "learningObjective": "Computar e validar autovalores/autofunções da Gram.",
                                  "commonMistakes": [
                                    "Não ordenar autovalores",
                                    "Confundir autovalores com autovetores",
                                    "Numérica instabilidade em matrizes mal-condicionadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Ortogonalidade, Condicionamento e Convergência",
                                  "subSteps": [
                                    "Verifique todos λ_i > 0 para definida positiva (ortogonalidade perfeita se δ_{ij}).",
                                    "Calcule cond(G) = λ_max / λ_min; cond < 10^3 indica bom condicionamento.",
                                    "Avalie convergência: taxa ≈ 1 - 1/cond(G); pequeno λ_min implica lentidão.",
                                    "Compare com Gram identidade (ortogonais: λ_i=1).",
                                    "Proponha melhorias: orthogonalização (Gram-Schmidt) se cond alto."
                                  ],
                                  "verification": "Produza relatório com cond(G), min/max λ e recomendação de convergência.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel para métricas",
                                    "Gráficos de espectro de autovalores"
                                  ],
                                  "tips": "Log-plot de λ para visualizar gap espectral; mire cond < 100.",
                                  "learningObjective": "Interpretar autovalores para propriedades do método.",
                                  "commonMistakes": [
                                    "Interpretar λ negativos como ortogonais",
                                    "Ignorar λ=0 (dependência linear)",
                                    "Confundir cond com trace"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar Análise a um Caso de Engenharia Civil",
                                  "subSteps": [
                                    "Aplique a um problema real: ex: análise modal de viga com resíduos ponderados.",
                                    "Recomputa iterações do método e correlacione com cond(G).",
                                    "Simule cenários: adicione ruído ou refine malha e reavalie.",
                                    "Documente impacto na precisão da solução.",
                                    "Conclua com thresholds para aceitação (ex: cond < 500)."
                                  ],
                                  "verification": "Mostre que baixa cond leva a <5% erro em solução aproximada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código completo do método dos resíduos",
                                    "Dados de benchmark (ex: FEM software)"
                                  ],
                                  "tips": "Automatize com script; teste sensibilidade a peso w(x).",
                                  "learningObjective": "Integrar análise em fluxo de solução numérica.",
                                  "commonMistakes": [
                                    "Não validar contra solução exata",
                                    "Overfitting a um caso",
                                    "Ignorar custo computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma placa retangular sob carga distribuída (equação de Poisson), use funções hat lineares como base. Construa G 4x4, encontre λ = [1.2, 0.8, 0.3, 0.01], cond=120. Conclusão: moderadamente condicionado, converge em ~20 iterações; melhore com bases hierárquicas.",
                              "finalVerifications": [
                                "Todos autovalores reais e positivos?",
                                "Autofunções formam base ortonormal (V^T V = I)?",
                                "cond(G) calculado corretamente e <10^6?",
                                "Interpretação de convergência alinhada com teoria (ρ<1)?",
                                "Recomendações práticas para melhorar condicionamento?",
                                "Validação numérica com erro residual baixo?"
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de G, λ e v (erro <1e-8).",
                                "Interpretação correta de ortogonalidade e condicionamento.",
                                "Uso apropriado de ferramentas numéricas.",
                                "Análise de impacto na convergência do método.",
                                "Relatório claro com gráficos e conclusões acionáveis.",
                                "Identificação de erros comuns e mitigação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise modal e vibrações em estruturas civis.",
                                "Computação: Algoritmos e decomposição espectral (PCA em dados).",
                                "Matemática Aplicada: Espaços de Hilbert e operadores auto-adjuntos.",
                                "Estatística: Análise de variância via autovalores."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios, analisa condicionamento da Gram em métodos como Galerkin para prever tempo de convergência em simulações FEM, otimizando malhas e bases para designs seguros e eficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Aplicação e Implementação Numérica",
                        "description": "Resolução de sistemas resultantes, aplicação a problemas de valor inicial/contorno e técnicas de otimização associadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Resolver sistemas lineares do método",
                            "description": "Aplicar decomposição LU ou métodos iterativos para resolver G c = b, onde b_i = ∫ w_i(x) φ_i(x) f(x) dx, obtendo coeficientes c.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar matriz G e vetor b do Método dos Resíduos Ponderados",
                                  "subSteps": [
                                    "Definir funções de peso w_i(x), base φ_i(x) e função fonte f(x) no domínio do problema.",
                                    "Discretizar o domínio em pontos de integração (ex: Gauss-Legendre).",
                                    "Calcular G_{ij} = ∫ w_i(x) L[φ_j(x)] dx ou similar, onde L é o operador diferencial.",
                                    "Calcular b_i = ∫ w_i(x) φ_i(x) f(x) dx usando quadratura numérica.",
                                    "Armazenar G como matriz esparsa/densa e b como vetor."
                                  ],
                                  "verification": "Verificar se G é simétrica positiva definida (para Galerkin) e b possui valores coerentes com f(x).",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com NumPy/SciPy, MATLAB ou papel para protótipo; tabela de quadratura Gauss.",
                                  "tips": "Use funções vetoriais para integração eficiente em múltiplos i,j.",
                                  "learningObjective": "Montar corretamente os componentes do sistema linear do método.",
                                  "commonMistakes": "Erro na formulação de G (confundir com ∫ φ_i φ_j); integração imprecisa em singularidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher método de resolução baseado nas propriedades de G",
                                  "subSteps": [
                                    "Analisar tamanho de G (pequeno <100x100: LU; grande/esparso: iterativo).",
                                    "Para LU: Verificar condicionamento com cond(G).",
                                    "Para iterativos: Escolher Gauss-Seidel, Jacobi ou Conjugado Gradiente se simétrica.",
                                    "Definir tolerância (ex: 1e-6) e máximo de iterações.",
                                    "Preparar pré-condicionadores se necessário (ex: diagonal para iterativos)."
                                  ],
                                  "verification": "Documentar escolha com justificativa (ex: nnz(G)/n^2 > 0.1 para denso).",
                                  "estimatedTime": "1 hora",
                                  "materials": "Bibliotecas SciPy.linalg ou MATLAB; spy plot para visualização de esparsidade.",
                                  "tips": "Sempre teste condicionamento antes de LU para evitar instabilidade numérica.",
                                  "learningObjective": "Selecionar método ótimo baseado em características do sistema.",
                                  "commonMistakes": "Usar LU em matrizes grandes/esparsas (alto custo computacional); ignorar assimetria."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar decomposição LU ou método iterativo",
                                  "subSteps": [
                                    "Para LU: Computar decomposição G = LU com pivotamento parcial.",
                                    "Resolver Ly = b por substituição frontal.",
                                    "Resolver Uc = y por substituição reversa.",
                                    "Para iterativos: Inicializar c^0 = 0, iterar até ||Gc^k - b|| < tol.",
                                    "Monitorar convergência em cada iteração."
                                  ],
                                  "verification": "Comparar c com solução conhecida para problema teste pequeno.",
                                  "estimatedTime": "3 horas",
                                  "materials": "SciPy.linalg.lu_factor/solve ou scipy.sparse.linalg; código Python/MATLAB.",
                                  "tips": "Implemente logging de resíduos para debug de convergência.",
                                  "learningObjective": "Executar numericamente a resolução do sistema.",
                                  "commonMistakes": "Pivotamento esquecido em LU causando NaN; tolerância muito frouxa em iterativos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Obter e pós-processar coeficientes c",
                                  "subSteps": [
                                    "Extrair vetor c final da resolução.",
                                    "Calcular aproximação u(x) ≈ ∑ c_i φ_i(x).",
                                    "Avaliar resíduo R(x) = L[u(x)] - f(x).",
                                    "Computar normas de erro (L2, max).",
                                    "Visualizar u(x) e comparar com solução exata se disponível."
                                  ],
                                  "verification": "||Gc - b|| / ||b|| < 1e-8 para precisão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Matplotlib/Plots para gráficos; funções de base pré-definidas.",
                                  "tips": "Salve c em arquivo para reutilização em análises sensibilidade.",
                                  "learningObjective": "Interpretar coeficientes no contexto da aproximação.",
                                  "commonMistakes": "Escala errada em φ_i causando overflow; pós-processamento sem normalização."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar a solução",
                                  "subSteps": [
                                    "Verificar equilíbrio de energia ou condições de contorno.",
                                    "Testar convergência variando número de graus de liberdade.",
                                    "Comparar tempo de CPU de LU vs iterativo.",
                                    "Ajustar parâmetros (tol, pré-cond) para melhorar.",
                                    "Documentar relatório com métricas."
                                  ],
                                  "verification": "Curva de convergência decrescente; erro < 1%.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Timer em código; solução analítica de referência.",
                                  "tips": "Use problemas benchmark de literatura para validação.",
                                  "learningObjective": "Garantir robustez e confiabilidade da solução numérica.",
                                  "commonMistakes": "Não testar malha refinada; ignorar tempo de computação em relatórios."
                                }
                              ],
                              "practicalExample": "Em uma viga de Euler-Bernoulli com carga distribuída f(x)=q0 sin(πx/L), use Galerkin (w_i=φ_i) com φ_i = sin(iπx/L), n=5 modos. Compute G e b via Gauss-Legendre, resolva com LU em Python: G resulta tridiagonal dominante, c obtido em <1s, u(x) approxima deflexão com erro L2<0.5%.",
                              "finalVerifications": [
                                "||Gc - b||_2 / ||b||_2 < 1e-8.",
                                "Convergência em <100 iterações para métodos iterativos.",
                                "Condição de G < 1e6 para estabilidade.",
                                "Solução satisfaz condições de contorno essenciais.",
                                "Erro de aproximação u(x) < 1% vs exata.",
                                "Tempo de execução razoável (<1min para n=100)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução (normas de erro).",
                                "Eficiência computacional (tempo e memória).",
                                "Correta implementação do método escolhido.",
                                "Validação com testes múltiplos.",
                                "Documentação clara de passos e resultados.",
                                "Escolha justificada de parâmetros (tol, método)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Análise de erros e estabilidade.",
                                "Programação Computacional: Uso de bibliotecas lineares.",
                                "Física/Mecânica: Formulação de EDP em Engenharia Civil.",
                                "Estatística: Análise de convergência e incertezas."
                              ],
                              "realWorldApplication": "Na análise estrutural de pontes ou edifícios, resolve sistemas de milhares de eqs. para deformações sob cargas sísmicas, permitindo simulações FEM eficientes em software como ANSYS ou códigos customizados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Aplicar a problemas de valor inicial e contorno",
                            "description": "Implementar o método para EDPs como u'' + u = 0 com condições de contorno u(0)=0, u(1)=1, usando bases polinomiais e funções de peso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema e selecionar aproximação trial",
                                  "subSteps": [
                                    "Identifique a EDP: u''(x) + u(x) = 0 no domínio [0,1].",
                                    "Especifique condições de contorno: u(0) = 0, u(1) = 1.",
                                    "Escolha funções base polinomiais que incorporem ou aproximem as condições de contorno, e.g., φ₁(x) = x(1 - x/2), φ₂(x) = x²(1 - x/3).",
                                    "Defina a aproximação trial: u_N(x) ≈ ∑_{i=1}^N c_i φ_i(x) + u_particular(x) se necessário.",
                                    "Selecione funções de peso w_j(x), preferencialmente w_j = φ_j para método de Galerkin."
                                  ],
                                  "verification": "Verifique se as funções base satisfazem aproximadamente as condições de contorno avaliando u_N(0) e u_N(1).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Jupyter Notebook ou papel/caneta",
                                    "Livro de métodos numéricos para EDPs",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Use bases que zerem em x=0 para simplificar u(0)=0; ajuste para u(1)=1 via coeficientes.",
                                  "learningObjective": "Formular matematicamente o problema de valor de contorno para aplicação do método dos resíduos ponderados.",
                                  "commonMistakes": "Ignorar condições de contorno nas bases, levando a sistemas singulares; escolher N muito alto inicialmente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as equações dos resíduos ponderados",
                                  "subSteps": [
                                    "Calcule o resíduo R(x) = u_N''(x) + u_N(x).",
                                    "Formule as equações: ∫[0,1] w_j(x) R(x) dx = 0 para j=1 a N.",
                                    "Compute derivadas segunda das bases: φ_i''(x).",
                                    "Monte os elementos da matriz rígida K_{ji} = ∫ w_j φ_i'' dx + ∫ w_j φ_i dx.",
                                    "Calcule o vetor de carga F_j = -∫ w_j f(x) dx se houver termo fonte (aqui f=0)."
                                  ],
                                  "verification": "Confirme que as integrais são computadas corretamente comparando com cálculos simbólicos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "SymPy ou Mathematica para integrais simbólicas",
                                    "Tabela de integrais polinomiais"
                                  ],
                                  "tips": "Integre por partes para termos de segunda derivada: ∫ w u'' = [w u'] - ∫ w' u' + ∫ w'' u.",
                                  "learningObjective": "Derivar o sistema de equações lineares a partir do princípio dos resíduos ponderados.",
                                  "commonMistakes": "Erros em integração por partes; confundir funções de peso com bases trial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar e resolver o sistema linear",
                                  "subSteps": [
                                    "Construa a matriz K (N x N) e vetor F (N x 1) numericamente.",
                                    "Incorpore condições de contorno essenciais ajustando linhas da matriz ou usando penalização.",
                                    "Resolva K c = F para os coeficientes c_i usando solver linear.",
                                    "Avalie a solução aproximada u_N(x) em pontos de grade.",
                                    "Compare com solução exata u(x) = sin(x)/sin(1)."
                                  ],
                                  "verification": "Verifique se det(K) ≠ 0 e ||K c - F|| < 1e-10.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Matplotlib para plotar u_N vs exata"
                                  ],
                                  "tips": "Use np.linalg.solve para sistemas pequenos; condicione a matriz com np.linalg.cond.",
                                  "learningObjective": "Implementar numericamente a resolução do sistema oriundo do método.",
                                  "commonMistakes": "Matrriz singular por bases linearmente dependentes; não tratar BCs não-homogêneas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e analisar a solução",
                                  "subSteps": [
                                    "Plote u_N(x) e solução exata; compute erro L2 = sqrt(∫ (u_N - u)^2 dx).",
                                    "Avalie u_N(0) e u_N(1) para checar BCs.",
                                    "Teste convergência variando N de 2 a 5.",
                                    "Analise taxa de convergência (esperada O(h^2) para polinômios lineares).",
                                    "Documente resultados em relatório com gráficos e tabelas."
                                  ],
                                  "verification": "Erro em BCs < 1e-6 e erro L2 decrescente com N.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python/Matplotlib/NumPy",
                                    "Template de relatório LaTeX ou Markdown"
                                  ],
                                  "tips": "Use trapz ou simps para integrais numéricas de erro.",
                                  "learningObjective": "Validar a implementação através de análises de erro e convergência.",
                                  "commonMistakes": "Escala errada nos plots ocultando erros; ignorar oscilações de Gibbs perto de BCs."
                                }
                              ],
                              "practicalExample": "Implemente o método de Galerkin para resolver u'' + u = 0 em [0,1] com u(0)=0, u(1)=1, usando N=3 bases polinomiais cúbicas ajustadas às BCs. Compare u_N(0.5) ≈ 0.7456 (exata sin(0.5)/sin(1)) e plote a solução.",
                              "finalVerifications": [
                                "u_N(0) ≈ 0 e u_N(1) ≈ 1 dentro de tolerância 1e-5.",
                                "Erro L∞ máximo < 2% da amplitude da solução.",
                                "Convergência observada ao dobrar N.",
                                "Matriz K simétrica positiva definida para Galerkin.",
                                "Código reproduzível gera mesmos resultados."
                              ],
                              "assessmentCriteria": [
                                "Correta derivação das equações residuais ponderadas.",
                                "Implementação numérica precisa sem erros de programação.",
                                "Análise de erro e convergência documentada.",
                                "Uso apropriado de bases polinomiais e pesos.",
                                "Relatório claro com plots e interpretações.",
                                "Tratamento correto das condições de contorno."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Métodos espectrais e elementos finitos.",
                                "Programação Computacional: Solvers lineares em Python/NumPy.",
                                "Física/Engenharia Mecânica: EDPs elípticas em equilíbrio estático.",
                                "Análise de Dados: Avaliação de erros e visualização."
                              ],
                              "realWorldApplication": "Na engenharia civil, aplica-se a problemas de deflexão de vigas (u'''' = p(x)) ou fluxo em meios porosos (∇²u = f), onde métodos de resíduos ponderados formam a base de softwares FEM como ANSYS para análise estrutural."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Otimizar soluções com programação matemática",
                            "description": "Usar ferramentas como MATLAB para minimizar resíduos ponderados em problemas não-lineares, integrando ajuste de curvas e análise de erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema de otimização matemática",
                                  "subSteps": [
                                    "Identificar variáveis de decisão (parâmetros do modelo não-linear).",
                                    "Definir a função objetivo como soma de resíduos ponderados: ∑ w_i * (y_i - f(x_i, θ))^2.",
                                    "Especificar pesos w_i baseados em incertezas experimentais.",
                                    "Listar restrições físicas e de contorno do problema de engenharia civil.",
                                    "Testar formulação com dados sintéticos simples."
                                  ],
                                  "verification": "Função objetivo implementada em pseudocódigo e validada manualmente com exemplo numérico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação do problema",
                                    "Papel e caneta para esboços",
                                    "Referências teóricas sobre resíduos ponderados"
                                  ],
                                  "tips": "Priorize pesos inversamente proporcionais à variância dos dados para maior robustez.",
                                  "learningObjective": "Compreender a estrutura matemática de problemas de minimização de resíduos em contextos não-lineares.",
                                  "commonMistakes": [
                                    "Definir pesos uniformes ignorando variabilidade dos dados",
                                    "Omitir restrições que levam a soluções infactíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o ambiente e funções no MATLAB",
                                  "subSteps": [
                                    "Instalar e abrir MATLAB com toolbox de otimização.",
                                    "Definir função anônima ou arquivo .m para o modelo não-linear f(x, θ).",
                                    "Criar função objetivo 'residuosPonderados' com pesos e dados reais.",
                                    "Configurar opções do solver (fmincon) com tolerâncias adequadas.",
                                    "Preparar vetores iniciais de chute para θ."
                                  ],
                                  "verification": "Funções executadas sem erros e plot de resíduos iniciais gerado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB com Optimization Toolbox",
                                    "Dados experimentais do problema (ex: deflexão de viga)"
                                  ],
                                  "tips": "Use 'optimoptions' para ativar gradientes numéricos se analíticos não estiverem disponíveis.",
                                  "learningObjective": "Dominar a preparação de scripts MATLAB para otimização não-linear.",
                                  "commonMistakes": [
                                    "Chutes iniciais ruins levando a convergência local",
                                    "Não escalar variáveis para evitar problemas numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar otimização e integrar ajuste de curvas",
                                  "subSteps": [
                                    "Chamar fmincon com função objetivo, chute inicial e restrições.",
                                    "Gerar plots de curvas ajustadas vs. dados observados.",
                                    "Calcular métricas de ajuste: R², RMSE ponderado.",
                                    "Analisar resíduos para detectar padrões (plots Q-Q ou residuals vs. fitted).",
                                    "Ajustar pesos iterativamente se necessário."
                                  ],
                                  "verification": "Solução convergida com resíduos abaixo de 5% do range de dados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Script MATLAB preparado",
                                    "Dados de entrada formatados em .mat"
                                  ],
                                  "tips": "Monitore o histórico de iterações com 'OutputFcn' para debug.",
                                  "learningObjective": "Aplicar solvers de otimização para ajuste de curvas não-lineares com pesos.",
                                  "commonMistakes": [
                                    "Ignorar avisos de não-convergência",
                                    "Sobreajuste validado apenas visualmente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar análise de erro e refinar solução",
                                  "subSteps": [
                                    "Computar intervalos de confiança via bootstrap ou Hessiana.",
                                    "Avaliar sensibilidade dos parâmetros a variações nos dados.",
                                    "Comparar com soluções analíticas ou benchmarks.",
                                    "Documentar relatório com plots e métricas finais.",
                                    "Iterar otimização se erros excederem critérios."
                                  ],
                                  "verification": "Relatório gerado com análise de erro quantitativa e qualitativa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Statistics Toolbox no MATLAB",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use 'nlparci' para intervalos de confiança em ajustes não-lineares.",
                                  "learningObjective": "Integrar análise de erro para validar otimizações em problemas reais.",
                                  "commonMistakes": [
                                    "Confundir erro de ajuste com erro de previsão",
                                    "Não testar com subconjuntos de dados out-of-sample"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um experimento de deflexão de viga sob carga distribuída, otimize os parâmetros elásticos E e I minimizando resíduos ponderados entre dados experimentais e o modelo diferencial não-linear, usando MATLAB para obter E = 30 GPa e I = 1.2e-4 m⁴ com RMSE < 0.5 mm.",
                              "finalVerifications": [
                                "Resíduos ponderados minimizados com norma < 1e-3.",
                                "R² do ajuste > 0.95 para curvas experimentais.",
                                "Convergência confirmada sem avisos de solver.",
                                "Intervalos de confiança dos parâmetros < 10% do valor estimado.",
                                "Plots de resíduos aleatórios sem padrões sistemáticos.",
                                "Solução satisfaz todas restrições físicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da minimização (redução > 90% nos resíduos iniciais).",
                                "Correta implementação de pesos e não-linearidades.",
                                "Qualidade da análise de erro (métricas e plots).",
                                "Eficiência computacional (tempo < 5 min por iteração).",
                                "Documentação clara com código reproduzível.",
                                "Validação cruzada com dados independentes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-convexa e álgebra linear.",
                                "Estatística: Análise de regressão ponderada e inferência.",
                                "Programação: Desenvolvimento de scripts numéricos avançados.",
                                "Física/Engenharia: Modelagem de problemas de valor inicial em estruturas."
                              ],
                              "realWorldApplication": "Na engenharia civil, otimiza parâmetros de modelos constitutivos em simulações FEM para previsão precisa de deformações em pontes e edifícios, reduzindo custos de protótipos e melhorando segurança estrutural."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Matriz de Gram e Condicionamento",
                    "description": "Conceitos de condicionamento numérico e construção da matriz de Gram em métodos de aproximação para problemas de contorno.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Condicionamento Numérico",
                        "description": "Conceitos fundamentais de condicionamento em sistemas lineares numéricos, incluindo o número de condicionamento e seu impacto na precisão e estabilidade das soluções para problemas de valor inicial e de contorno.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Calcular normas de matrizes",
                            "description": "Aplicar normas matriciais como norma L2 (espectral), norma de Frobenius e norma infinito para avaliar propriedades de matrizes em contextos numéricos de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Normas Matriciais",
                                  "subSteps": [
                                    "Revise a definição de norma matricial como uma medida de 'tamanho' de uma matriz.",
                                    "Estude as propriedades das normas: positividade, homogeneidade e desigualdade triangular.",
                                    "Identifique os tipos principais: norma de Frobenius (L2 euclidiana), norma infinito (máxima soma de linha) e norma espectral L2 (maior valor singular).",
                                    "Relacione normas com condicionamento numérico: κ(A) ≈ ||A|| * ||A⁻¹||.",
                                    "Discuta aplicações em engenharia civil, como estabilidade em matrizes de rigidez."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as três normas e sua relação com condicionamento, com exemplos simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de álgebra linear (ex: Strang), notas de aula, calculadora científica"
                                  ],
                                  "tips": "Use analogias com normas vetoriais para facilitar a compreensão.",
                                  "learningObjective": "Dominar definições e propriedades das normas matriciais e seu papel no condicionamento.",
                                  "commonMistakes": [
                                    "Confundir norma L2 matricial com norma L2 vetorial",
                                    "Ignorar propriedades como submultiplicatividade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Norma de Frobenius",
                                  "subSteps": [
                                    "Lembre a fórmula: ||A||_F = sqrt(∑_{i,j} |a_{ij}|^2).",
                                    "Para uma matriz dada, compute a soma dos quadrados dos elementos absolutos.",
                                    "Aplique sqrt à soma obtida.",
                                    "Verifique com software: use NumPy (np.linalg.norm(A, 'fro')) ou MATLAB (norm(A, 'fro')).",
                                    "Compare resultado manual com computacional."
                                  ],
                                  "verification": "Calcule ||A||_F para uma matriz 3x3 e confirme precisão com pelo menos 4 casas decimais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis, Python com NumPy ou MATLAB",
                                    "Matriz de exemplo impressa"
                                  ],
                                  "tips": "Quadrados os elementos facilita; use tabela para organizar soma.",
                                  "learningObjective": "Executar cálculo preciso da norma de Frobenius manualmente e via software.",
                                  "commonMistakes": [
                                    "Esquecer sqrt final",
                                    "Usar valores não absolutos em matrizes complexas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Norma Infinito e Relacionar com Outras",
                                  "subSteps": [
                                    "Defina norma infinito: ||A||_∞ = max_i (∑_j |a_{ij}|) (maior soma absoluta de linhas).",
                                    "Para cada linha, some valores absolutos e encontre o máximo.",
                                    "Compare com norma 1: max_j (∑_i |a_{ij}|).",
                                    "Implemente em código: np.linalg.norm(A, np.inf).",
                                    "Avalie relação com condicionamento usando ||A||_∞ * ||A⁻¹||_∞."
                                  ],
                                  "verification": "Compute ||A||_∞ para a mesma matriz do step anterior e discuta diferenças com Frobenius.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora, Jupyter Notebook com NumPy",
                                    "Matriz de rigidez exemplo"
                                  ],
                                  "tips": "Ordene linhas por soma para identificar máximo rapidamente.",
                                  "learningObjective": "Dominar cálculo da norma infinito e suas vantagens computacionais.",
                                  "commonMistakes": [
                                    "Somar colunas em vez de linhas",
                                    "Não usar absolutos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a Norma Espectral L2 e Aplicar em Condicionamento",
                                  "subSteps": [
                                    "Defina ||A||_2 = sqrt(λ_max(A^T A)), onde λ_max é o maior autovalor.",
                                    "Compute A^T A manualmente para matriz pequena.",
                                    "Encontre autovalores (use qr ou software).",
                                    "Implemente: np.linalg.norm(A, 2) ou svd.",
                                    "Calcule número de condicionamento κ_2(A) e interprete: >10^3 indica ill-condicionado."
                                  ],
                                  "verification": "Para matriz exemplo, calcule ||A||_2, κ_2 e classifique condicionamento.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python/NumPy/SciPy para autovalores",
                                    "Documentação SVD",
                                    "Matriz 2x2 de Gram"
                                  ],
                                  "tips": "Para matrizes simétricas, use autovalores de A diretamente.",
                                  "learningObjective": "Aplicar norma L2 em análise de condicionamento numérico.",
                                  "commonMistakes": [
                                    "Confundir com norma Frobenius (aproximação para grandes matrizes)",
                                    "Erro em transposição A^T"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez 2x2 de uma viga em engenharia civil: A = [[4, -2], [-2, 4]]. Calcule ||A||_F ≈ 5.477, ||A||_∞ = 6, ||A||_2 ≈ 6. Calcule κ_2(A) ≈ 1 (bem condicionado). Use NumPy para verificar e discuta implicações em FEM.",
                              "finalVerifications": [
                                "Calcule corretamente as três normas para matrizes 2x2 e 3x3 fornecidas.",
                                "Explique diferenças entre normas e quando usar cada uma.",
                                "Compute κ(A) usando normas L2 e infinito, interpretando resultados.",
                                "Implemente funções em Python para normas e valide com np.linalg.norm.",
                                "Identifique matriz ill-condicionada (ex: Hilbert) via normas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos manuais (erro < 0.01).",
                                "Correta implementação computacional com validação.",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Interpretação correta de condicionamento em contexto.",
                                "Eficiência no uso de software e detecção de erros numéricos.",
                                "Aplicação prática a matrizes de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores e SVD.",
                                "Programação Numérica: implementação em Python/MATLAB.",
                                "Análise Numérica: estabilidade e erro de arredondamento.",
                                "Engenharia Computacional: FEM e matrizes de Gram.",
                                "Física: normas em vetores de deslocamento/força."
                              ],
                              "realWorldApplication": "Em simulações FEM para estruturas civis, normas matriciais avaliam condicionamento de matrizes de rigidez, previnindo erros numéricos em análises de tensão/deformação sob cargas dinâmicas, garantindo precisão em projetos de pontes e edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Determinar o número de condicionamento",
                            "description": "Calcular o número de condicionamento cond(A) = ||A|| * ||A^{-1}|| usando decomposição em autovalores e interpretar valores elevados como indicadores de ill-condicionamento em aproximações numéricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Normas e Decomposição em Autovalores",
                                  "subSteps": [
                                    "Defina o número de condicionamento cond(A) = ||A|| * ||A^{-1}|| para norma 2 (espectral).",
                                    "Explique que, para matrizes normais ou simétricas positivas definidas, ||A||_2 = max|λ_i| e ||A^{-1}||_2 = 1 / min|λ_i|, onde λ_i são autovalores.",
                                    "Discuta a importância: valores altos indicam ill-condicionamento, sensibilidade a erros em aproximações numéricas.",
                                    "Revise eigen-decomposição: A = Q Λ Q^{-1}, onde Λ é diagonal com autovalores.",
                                    "Identifique quando usar norma 2 em contextos de engenharia civil (ex.: matrizes de rigidez)."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos e forneça um exemplo verbal de ill-condicionamento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de álgebra linear (ex.: Strang), calculadora científica, notas de aula."
                                  ],
                                  "tips": "Use diagramas para visualizar eigen-decomposição.",
                                  "learningObjective": "Entender a base teórica do condicionamento numérico via autovalores.",
                                  "commonMistakes": "Confundir norma espectral com outras normas (ex.: Frobenius); ignorar propriedades da matriz (normalidade)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os Autovalores e Autovetores da Matriz A",
                                  "subSteps": [
                                    "Formule a equação característica det(A - λI) = 0.",
                                    "Resolva o polinômio característico para encontrar λ_i.",
                                    "Para cada λ_i, resolva (A - λ_i I)v = 0 para autovetores v_i.",
                                    "Normalize os autovetores se necessário para formar Q ortogonal.",
                                    "Verifique a decomposição: multiplique Q Λ Q^{-1} e confira se obtém A."
                                  ],
                                  "verification": "Confirme que A ≈ Q Λ Q^{-1} com erro < 10^{-6}.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB/Python (NumPy/SciPy), papel e lápis para matrizes pequenas."
                                  ],
                                  "tips": "Para matrizes 2x2, resolva analiticamente; use funções como eig() para maiores.",
                                  "learningObjective": "Dominar o cálculo prático de eigen-decomposição.",
                                  "commonMistakes": "Erros aritméticos no polinômio; autovetores não normalizados levando a Q não ortogonal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar as Normas Espectrais ||A||_2 e ||A^{-1}||_2",
                                  "subSteps": [
                                    "Identifique λ_max = máximo |λ_i| e λ_min = mínimo |λ_i| (não zero).",
                                    "Calcule ||A||_2 = λ_max.",
                                    "Para A^{-1}, note que seus autovalores são 1/λ_i, então ||A^{-1}||_2 = 1 / λ_min.",
                                    "Compute cond(A) = λ_max / λ_min.",
                                    "Teste numericamente com software para validação."
                                  ],
                                  "verification": "Compare cond(A) calculado manualmente com norm(A,2)*norm(inv(A),2) no software.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/MATLAB com funções norm() e eig(), matriz de exemplo."
                                  ],
                                  "tips": "Assuma matriz simétrica positiva definida comum em engenharia.",
                                  "learningObjective": "Aplicar autovalores para calcular normas e condicionamento.",
                                  "commonMistakes": "Usar λ_min absoluto incorreto; esquecer de verificar invertibilidade (λ_i ≠ 0)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o Número de Condicionamento e Avaliar Ill-Condicionamento",
                                  "subSteps": [
                                    "Classifique: cond(A) < 10^2 bem condicionado; > 10^6 ill-condicionado.",
                                    "Discuta impactos: erros em soluções de Ax=b amplificados por cond(A).",
                                    "Sugira remediações: escalonamento, pré-condicionadores.",
                                    "Aplique a uma matriz de rigidez em engenharia civil.",
                                    "Documente achados em relatório curto."
                                  ],
                                  "verification": "Explique verbalmente por que cond(A) alto causa problemas numéricos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de matrizes de engenharia civil, software de simulação (ex.: ANSYS docs)."
                                  ],
                                  "tips": "Relacione com estabilidade numérica em métodos iterativos.",
                                  "learningObjective": "Interpretar resultados no contexto de problemas reais.",
                                  "commonMistakes": "Ignorar contexto da aplicação; superestimar condicionamento sem normalização."
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez 2x2 A = [[2, -1], [-1, 2]] (viga simples). Autovalores: λ1=1, λ2=3. cond(A) = 3/1 = 3 (bem condicionado). Se perturbada para [[2.01, -1], [-1, 1.99]], λ1≈0.01, λ2≈3, cond≈300 (ill-condicionado, sensível a ruído).",
                              "finalVerifications": [
                                "Cálculo de cond(A) coincide com software (±0.01 erro).",
                                "Interpretação correta: cond>10^4 indica ill-condicionamento.",
                                "Eigen-decomposição verificada: ||A - QΛQ^{-1}|| < 10^{-10}.",
                                "Explicação verbal de impacto em aproximações numéricas.",
                                "Relatório inclui classificações e sugestões de melhoria.",
                                "Teste com matriz 3x3 adicional confirma método."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de autovalores/autovetores (erro <1%).",
                                "Correta aplicação da fórmula cond(A) = max|λ|/min|λ|.",
                                "Interpretação qualitativa e quantitativa adequada.",
                                "Uso correto de software para validação.",
                                "Identificação de erros comuns e remediações.",
                                "Relatório claro com exemplos contextualizados."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Métodos iterativos (Gauss-Seidel) afetados por condicionamento.",
                                "Programação Computacional: Implementação em Python/MATLAB para eigen-decomposição.",
                                "Física/Engenharia Mecânica: Matrizes de rigidez em elementos finitos.",
                                "Estatística: Sensibilidade em regressão linear.",
                                "Otimização: Condicionamento em gradiente descendente."
                              ],
                              "realWorldApplication": "Em simulações de estruturas civis via elementos finitos (ex.: pontes), matrizes de rigidez mal condicionadas levam a erros em deslocamentos/forças; detectar cond(A)>10^6 permite refinamento da malha ou escalonamento para precisão em softwares como SAP2000."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Analisar impacto do condicionamento em soluções",
                            "description": "Avaliar como o condicionamento afeta a propagação de erros em métodos numéricos para problemas de valor de contorno, relacionando com estabilidade em simulações de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos do condicionamento numérico",
                                  "subSteps": [
                                    "Defina o número de condicionamento κ(A) para uma matriz A como κ(A) = ||A|| * ||A⁻¹||.",
                                    "Explique a relação entre κ(A) e a propagação de erros relativos: |δx|/|x| ≈ κ(A) * (|δb|/|b| ou |δA|/|A|).",
                                    "Classifique matrizes como bem condicionadas (κ ≈ 1) ou mal condicionadas (κ >> 1).",
                                    "Discuta normas comuns: norma 2 (singular values), norma ∞ (máxima linha).",
                                    "Calcule κ para matrizes 2x2 simples usando software ou manualmente."
                                  ],
                                  "verification": "Resuma em um parágrafo como o condicionamento afeta soluções lineares e forneça um exemplo numérico com κ > 100.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), MATLAB/Python com NumPy/SciPy, calculadora.",
                                  "tips": "Use a norma 2 para problemas de autovalores em simulações estruturais.",
                                  "learningObjective": "Identificar e calcular o número de condicionamento para sistemas lineares.",
                                  "commonMistakes": "Confundir condicionamento com rank da matriz; ignorar a escolha da norma."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar problemas de valor de contorno e suas discretizações",
                                  "subSteps": [
                                    "Formule um problema típico: -u''(x) = f(x), u(0)=a, u(L)=b.",
                                    "Aplique diferenças finitas centrais para gerar o sistema Ax = b com malha uniforme h = L/(n+1).",
                                    "Observe que A é tridiagonal: [1, -2, 1]/h².",
                                    "Analise autovalores de A: λ_k ≈ (2/h²)(1 - cos(kπ/(n+1))).",
                                    "Calcule cond(A) ≈ (π²/(h² log h)) para malhas finas."
                                  ],
                                  "verification": "Gere e exiba a matriz A para n=10 e n=100, confirmando estrutura tridiagonal.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (NumPy para matrizes, SciPy para autovalores), papel e lápis para derivação.",
                                  "tips": "Comece com n pequeno para depuração antes de malhas finas.",
                                  "learningObjective": "Construir e analisar matrizes de discretização para BVP.",
                                  "commonMistakes": "Esquecer fator 1/h² nos autovalores; usar condições erradas nas bordas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar propagação de erros devido ao condicionamento",
                                  "subSteps": [
                                    "Perturbe b com ruído gaussiano ε ~ 10^{-10} (precisão máquina).",
                                    "Resolva Ax = b e Ax = b + ε, compare erros ||x - x_pert|| / ||x||.",
                                    "Repita para perturbações em A (ex: arredondamento em entradas).",
                                    "Plote log(erro) vs log(1/h) mostrando amplificação κ * ε.",
                                    "Compare com solução exata via método analítico ou refinar malha."
                                  ],
                                  "verification": "Demonstre que erro observado ≈ κ(A) * ε máquina para h→0.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB/Python (soluções lineares com lu_solve ou backslash), gráficos com Matplotlib.",
                                  "tips": "Use cond() built-in para validar cálculos manuais.",
                                  "learningObjective": "Quantificar como condicionamento amplifica erros em BVP.",
                                  "commonMistakes": "Não normalizar erros relativos; ignorar perda de precisão em solvers."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com estabilidade em simulações de engenharia civil",
                                  "subSteps": [
                                    "Modele uma viga em flexão: EI u'''' = q(x), discretize com elementos finitos simples.",
                                    "Identifique matrizes de rigidez K mal condicionadas para malhas finas ou elementos alongados.",
                                    "Simule colapso numérico: perturbações levam a deslocamentos irreais.",
                                    "Discuta mitigação: pré-condicionadores, refinamento adaptativo, escalonamento.",
                                    "Compare com casos reais: análise de pontes ou barragens."
                                  ],
                                  "verification": "Relatório curto: 'Em uma simulação de viga com h=0.01, κ=10^6 levou a erros >10% em tensões.'",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software FEA básico (ex: FEniCS Python, ou ANSYS student), artigos sobre estabilidade numérica.",
                                  "tips": "Escalone unidades consistentes (m, N) para reduzir κ artificial.",
                                  "learningObjective": "Conectar condicionamento teórico a falhas práticas em engenharia.",
                                  "commonMistakes": "Subestimar impacto em elementos finitos vs diferenças finitas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar análise e propor melhorias",
                                  "subSteps": [
                                    "Resuma: κ cresce como 1/h², erros saturam em máquina ε.",
                                    "Teste pré-condicionadores: diagonal de A ou ILU.",
                                    "Avalie trade-off: precisão vs custo computacional.",
                                    "Documente em um gráfico de erro vs h com curvas teóricas.",
                                    "Proponha guidelines para simulações civis: monitorar κ < 10^8."
                                  ],
                                  "verification": "Crie um checklist de boas práticas para análise condicionada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "SciPy sparse solvers, Jupyter notebook para relatório.",
                                  "tips": "Sempre verifique resíduo ||Ax - b|| < tol.",
                                  "learningObjective": "Desenvolver estratégias para soluções estáveis.",
                                  "commonMistakes": "Achar que refinar malha sempre melhora; ignorar custo O(n³)."
                                }
                              ],
                              "practicalExample": "Considere resolver -u'' = π² sin(πx) em [0,1], u(0)=u(1)=0 (u_exata = sin(πx)). Use diferenças finitas com n=100 (h=0.01). κ(A)≈10^4. Perturbe b com 10^{-12}, observe erro em u ≈ 10^{-8}, amplificado por κ. Em engenharia: simulação de viga com cargas perturbadas leva a tensões erradas de 0.1%, crítico para segurança.",
                              "finalVerifications": [
                                "Calcula corretamente κ(A) para matriz tridiagonal de BVP.",
                                "Simula propagação de erros e matches com teoria κ*ε.",
                                "Identifica instabilidades em exemplos de engenharia civil.",
                                "Propõe pelo menos duas estratégias de mitigação.",
                                "Gera gráficos de erro vs h mostrando saturação.",
                                "Relaciona verbalmente condicionamento a estabilidade real."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de condicionamento (erro <5%).",
                                "Correta interpretação de amplificação de erros (qualitativa e quantitativa).",
                                "Relevância das conexões com aplicações civis (exemplos concretos).",
                                "Profundidade dos substeps executados (todos com evidências).",
                                "Criatividade em mitigação e verificações finais.",
                                "Clareza em relatórios e gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de autovalores e normas matriciais.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física: Equações diferenciais em mecânica estrutural.",
                                "Estatística: Análise de erros e ruído gaussiano."
                              ],
                              "realWorldApplication": "Em simulações de engenharia civil, como análise modal de pontes (ex: Golden Gate), mal condicionamento em matrizes de rigidez causa vibrações fictícias, levando a redesenhos caros. Monitorar κ garante estabilidade, evitando falhas como no colapso da ponte Tacoma Narrows devido a modelos imprecisos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Matriz de Gram",
                        "description": "Construção e propriedades da matriz de Gram em métodos de aproximação por resíduos ponderados para problemas de contorno, utilizando produtos internos de funções base.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Definir produto interno em espaços funcionais",
                            "description": "Estabelecer produtos internos ponderados em espaços de funções L2 para bases de aproximação em problemas diferenciais de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Espaços Funcionais L2",
                                  "subSteps": [
                                    "Revise a definição de espaço L2(Ω) como funções quadrado-integráveis em um domínio Ω.",
                                    "Estude normas e propriedades de completude no espaço L2.",
                                    "Explore exemplos de funções em L2 relevantes para engenharia civil, como deslocamentos em vigas.",
                                    "Identifique condições de contorno típicas em problemas diferenciais.",
                                    "Pratique identificando funções pertencentes ou não a L2."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave de L2 e forneça um exemplo de função não-L2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Funcional (ex: Brezis), notas de aula sobre PDEs, software MATLAB para plotar funções"
                                  ],
                                  "tips": "Visualize funções graficamente para intuitar integrabilidade.",
                                  "learningObjective": "Definir e caracterizar espaços L2 com exemplos contextualizados.",
                                  "commonMistakes": "Confundir L2 com Lp para p≠2; ignorar o domínio Ω."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Produto Interno Padrão em L2",
                                  "subSteps": [
                                    "Defina o produto interno padrão ⟨f,g⟩ = ∫_Ω f(x)g(x) dx.",
                                    "Verifique propriedades: simetria, linearidade, definitude positiva.",
                                    "Calcule produtos internos para funções polinomiais simples em [0,1].",
                                    "Discuta ortogonalidade e bases ortonormais em L2.",
                                    "Aplique a funções de teste em problemas de valor inicial."
                                  ],
                                  "verification": "Calcule ⟨sin(πx), cos(πx)⟩ em [0,1] e prove ortogonalidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora simbólica (Wolfram Alpha), papel e lápis para integrais"
                                  ],
                                  "tips": "Use simetria de intervalos para simplificar integrais.",
                                  "learningObjective": "Estabelecer e validar o produto interno padrão em L2.",
                                  "commonMistakes": "Esquecer fator de normalização ou limites de integração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Produtos Internos Ponderados",
                                  "subSteps": [
                                    "Geralize para ⟨f,g⟩_w = ∫_Ω f(x)g(x) w(x) dx, onde w(x)>0 é peso.",
                                    "Escolha pesos comuns em engenharia civil (ex: w(x)=ρ(x) para densidade).",
                                    "Verifique que ainda satisfaz propriedades de produto interno.",
                                    "Compare com padrão: quando w=1.",
                                    "Calcule exemplos com w(x)=x em [0,1]."
                                  ],
                                  "verification": "Mostre que ⟨f,g⟩_w define norma equivalente e calcule para f=x, g=1, w=x.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software SymPy ou Mathematica para integrais ponderadas"
                                  ],
                                  "tips": "Pense em w como distribuindo 'importância' no domínio.",
                                  "learningObjective": "Construir e validar produtos internos ponderados.",
                                  "commonMistakes": "Permitir w(x)≤0, violando definitude."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Bases de Aproximação e Matriz de Gram",
                                  "subSteps": [
                                    "Defina base {φ_i} em L2 e compute G_{ij} = ⟨φ_i, φ_j⟩_w.",
                                    "Construa matriz de Gram para base polinomial em problema de viga.",
                                    "Discuta condicionamento: bases mal condicionadas levam a instabilidade numérica.",
                                    "Ligue a aproximação de soluções de PDEs (ex: equação de Euler-Bernoulli).",
                                    "Implemente numericamente em código simples."
                                  ],
                                  "verification": "Construa matriz 2x2 de Gram para {1,x} com w=1 em [0,1] e avalie det(G).",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy, exemplos de código para integrais numéricas"
                                  ],
                                  "tips": "Use quadratura Gauss para integrais numéricas eficientes.",
                                  "learningObjective": "Usar produto interno para formar matriz de Gram em aproximações.",
                                  "commonMistakes": "Índices errados na matriz; esquecer peso na computação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Contextualizar em Problemas Diferenciais de Engenharia Civil",
                                  "subSteps": [
                                    "Aplique a problema de viga: defina espaço funcional para deslocamentos w(x).",
                                    "Estabeleça produto interno com peso da rigidez EI(x).",
                                    "Compute Gram para bases de elementos finitos lineares.",
                                    "Analise impacto no condicionamento para malhas refinadas.",
                                    "Simule erro de aproximação."
                                  ],
                                  "verification": "Defina ⟨u,v⟩ para u''=f em viga cantilever e compute Gram para 2 DOFs.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "FEniCS ou código FEM básico, artigos sobre métodos espectrais"
                                  ],
                                  "tips": "Comece com 1D para simplicidade antes de 2D/3D.",
                                  "learningObjective": "Integrar produto interno em soluções computacionais de PDEs civis.",
                                  "commonMistakes": "Ignorar condições de contorno na escolha da base."
                                }
                              ],
                              "practicalExample": "Em análise de uma viga simply supported sob carga distribuída, defina espaço L2(0,L) com peso w(x)=EI(x). Para base {1, x(L-x)}, compute ⟨φ1,φ1⟩_w = ∫ EI(x) dx, ⟨φ1,φ2⟩_w = ∫ EI(x) x(L-x) dx, etc., formando G para projeção da solução.",
                              "finalVerifications": [
                                "Defina corretamente ⟨f,g⟩_w para funções dadas e peso arbitrário.",
                                "Construa matriz de Gram 3x3 para base polinomial com w(x)=1+x.",
                                "Prove ortogonalidade de base Legendre ponderada.",
                                "Implemente código Python para Gram numérica em malha 1D.",
                                "Identifique quando produto ponderado melhora condicionamento.",
                                "Aplique a um PDE simples e verifique simetria positiva definida."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição exata de L2 e produto interno (30%).",
                                "Habilidade computacional: cálculos corretos de integrais (25%).",
                                "Compreensão aplicada: ligação correta a matriz Gram e PDEs (20%).",
                                "Análise crítica: discussão de condicionamento e erros (15%).",
                                "Criatividade: exemplo original em engenharia civil (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Energia potencial em estruturas (variacional).",
                                "Computação: Integração numérica e álgebra linear esparsa.",
                                "Estatística: Produtos internos em regressão kernel.",
                                "Engenharia Mecânica: Modos vibracionais com massas variáveis."
                              ],
                              "realWorldApplication": "Em simulações FEM para pontes ou edifícios, define produtos internos ponderados por propriedades materiais variáveis (ex: concreto armado com seções irregulares), garantindo bases de aproximação estáveis e precisas para prever deformações sob cargas sísmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Construir a matriz de Gram",
                            "description": "Montar a matriz G com elementos G_ij = ∫ φ_i(x) φ_j(x) w(x) dx para funções base φ_i em métodos como Galerkin para equações de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir as funções base e parâmetros iniciais",
                                  "subSteps": [
                                    "Identificar o problema de contorno e escolher funções base φ_i(x) adequadas (ex: polinomiais, funções de Fourier ou Legendre)",
                                    "Determinar o número de funções n para a aproximação",
                                    "Definir o domínio de integração [a, b] e as condições de contorno relevantes",
                                    "Verificar se as funções base satisfazem as condições de contorno essenciais",
                                    "Documentar as expressões explícitas das φ_i(x)"
                                  ],
                                  "verification": "Lista completa de funções base φ_i(x) com expressões matemáticas e gráfico opcional plotado",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis ou editor de equações (LaTeX/Mathematica)",
                                    "Livro de Métodos Elementos Finitos (ex: Zienkiewicz)",
                                    "Software de plotagem (MATLAB/Python/Mathematica)"
                                  ],
                                  "tips": "Prefira funções ortogonais para melhorar o condicionamento da matriz",
                                  "learningObjective": "Selecionar e documentar funções base apropriadas para o método de Galerkin",
                                  "commonMistakes": [
                                    "Escolher funções que não satisfazem condições de contorno",
                                    "Usar número excessivo de funções sem justificativa computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificar o peso w(x) e preparar a integração",
                                  "subSteps": [
                                    "Definir a função peso w(x) baseada no problema (ex: w(x)=1 para forma padrão)",
                                    "Confirmar o intervalo de integração e simetrias possíveis",
                                    "Escolher método de integração: analítico se possível, ou numérico (Gauss-Legendre, Simpson)",
                                    "Implementar ou esboçar a fórmula G_ij = ∫_a^b φ_i(x) φ_j(x) w(x) dx",
                                    "Testar integral para i=j (elemento diagonal) manualmente"
                                  ],
                                  "verification": "Fórmula explícita de w(x) e esquema de integração documentado com exemplo de um elemento",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou Mathematica)",
                                    "Tabelas de quadratura numérica",
                                    "Notebook Jupyter para prototipagem"
                                  ],
                                  "tips": "Use simetria G_ij = G_ji para reduzir computações pela metade",
                                  "learningObjective": "Preparar corretamente os componentes da integral de Gram para computação eficiente",
                                  "commonMistakes": [
                                    "Ignorar o peso w(x) não-uniforme em problemas com densidade variável",
                                    "Escolher método numérico inadequado para o domínio"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os elementos individuais G_ij",
                                  "subSteps": [
                                    "Implementar loop duplo para i=1 a n, j=1 a n (otimizar para j>=i)",
                                    "Computar cada integral usando método escolhido (analítico ou numérico com 10-20 pontos)",
                                    "Armazenar valores em uma matriz n x n inicializada com zeros",
                                    "Verificar simetria: G_ij ≈ G_ji dentro de tolerância 1e-10",
                                    "Calcular traço e normas para inspeção preliminar"
                                  ],
                                  "verification": "Matriz parcial com todos elementos computados e simetria confirmada",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "SymPy para integrais simbólicas",
                                    "Editor de código (VS Code)"
                                  ],
                                  "tips": "Vectorize computações em Python/MATLAB para eficiência com n>10",
                                  "learningObjective": "Executar cálculos precisos dos elementos da matriz de Gram",
                                  "commonMistakes": [
                                    "Erros de indexação em loops (off-by-one)",
                                    "Precisão insuficiente em quadratura numérica levando a assimetria"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar, validar e analisar a matriz de Gram",
                                  "subSteps": [
                                    "Preencher a matriz completa G usando os elementos calculados",
                                    "Verificar propriedades: simétrica positiva definida (autovalores >0)",
                                    "Calcular número de condicionamento cond(G) = σ_max/σ_min",
                                    "Comparar com valores teóricos conhecidos para funções ortogonais",
                                    "Exportar matriz em formato legível (LaTeX ou CSV)"
                                  ],
                                  "verification": "Matriz G final com relatório de propriedades (simetria, autovalores, cond)",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NumPy/SciPy para eigenvalores e cond",
                                    "LaTeX para tabela da matriz"
                                  ],
                                  "tips": "Se cond > 1e6, considere funções base melhor condicionadas",
                                  "learningObjective": "Validar a matriz construída e interpretá-la no contexto do método",
                                  "commonMistakes": [
                                    "Não verificar definitude positiva",
                                    "Ignorar problemas de condicionamento numérico"
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver -u''(x) = π² sin(πx) em [0,1] com u(0)=u(1)=0 usando Galerkin com n=3 funções base φ1=sin(πx), φ2=sin(2πx), φ3=sin(3πx) e w(x)=1. Compute G_ij = ∫0^1 sin(iπx) sin(jπx) dx, resultando em G diagonal com 0.5 na diagonal devido à ortogonalidade.",
                              "finalVerifications": [
                                "Matriz G é simétrica com tolerância <1e-12",
                                "Todos autovalores positivos confirmando definitude semi-definida",
                                "Número de condicionamento <1e4 para n<=5",
                                "Elementos diagonais G_ii >0 e consistentes com normas das φ_i",
                                "Reprodução exata de exemplo conhecido (ex: ortogonalidade)",
                                "Código ou cálculos reproduzíveis por terceiro"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica dos elementos G_ij (erro <1e-8)",
                                "Eficiência computacional (tempo <1min para n=10)",
                                "Correta verificação de propriedades matriciais",
                                "Documentação clara com fórmulas e código comentado",
                                "Análise de condicionamento e sugestões de melhoria",
                                "Aplicação correta ao contexto de Galerkin"
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Quadratura e decomposição espectral",
                                "Programação Computacional: Vetorização e otimização de loops",
                                "Física/Mecânica: Formulação fraca em problemas elásticos",
                                "Álgebra Linear: Propriedades de matrizes simétricas positivas definidas",
                                "Estatística: Integração Monte Carlo como alternativa numérica"
                              ],
                              "realWorldApplication": "Na análise de elementos finitos para simulação de estruturas civis, como vigas e placas sob cargas dinâmicas, onde a matriz de Gram surge na formulação Galerkin para aproximar soluções de equações diferenciais elípticas/parabólicas, essencial para software como ANSYS ou Abaqus em projetos de pontes e edifícios."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Relacionar matriz de Gram com condicionamento",
                            "description": "Analisar o condicionamento da matriz de Gram em função da escolha das bases e seu papel na convergência de métodos de resíduos ponderados para problemas de valor de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e construção da matriz de Gram",
                                  "subSteps": [
                                    "Revise o conceito de produto interno em espaços de funções L2 para problemas de valor de contorno.",
                                    "Construa a matriz de Gram G_ij = ∫ φ_i(x) φ_j(x) dx, onde {φ_i} são funções base.",
                                    "Verifique propriedades: simétrica, definida positiva se bases linearmente independentes.",
                                    "Calcule exemplos simples com bases monomiais em [0,1].",
                                    "Compare com bases ortogonais como Legendre."
                                  ],
                                  "verification": "Construa e exiba a matriz G para uma base de 3 funções monomiais e compute seus autovalores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas sobre espaços de Hilbert",
                                    "Software como Python (NumPy/SciPy) ou MATLAB",
                                    "Tabela de polinômios de Legendre"
                                  ],
                                  "tips": "Sempre normalize o intervalo de integração para evitar erros numéricos em integrais.",
                                  "learningObjective": "Ser capaz de definir, construir e verificar propriedades da matriz de Gram em contextos de EDP.",
                                  "commonMistakes": "Esquecer de normalizar o produto interno ou usar bases não contínuas para PVC."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o condicionamento de matrizes e sua medição",
                                  "subSteps": [
                                    "Defina o número de condição cond(G) = ||G||_2 * ||G^{-1}||_2 usando norma espectral.",
                                    "Relacione cond(G) com a razão entre maior e menor autovalor (gap espectral).",
                                    "Compute cond(G) numericamente via decomposição SVD ou autovalores.",
                                    "Interprete valores: cond < 10^2 bom, >10^6 problemático para precisão numérica.",
                                    "Teste com G de bases mal condicionadas (ex: monomiais elevadas)."
                                  ],
                                  "verification": "Calcule cond(G) para uma matriz de Gram de ordem 4 e interprete seu valor.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação NumPy para np.linalg.cond",
                                    "Exemplos de matrizes mal condicionadas",
                                    "Calculadora gráfica ou Jupyter Notebook"
                                  ],
                                  "tips": "Use SVD para condicionamento estável em matrizes grandes; evite inversão direta.",
                                  "learningObjective": "Calcular e interpretar o condicionamento de uma matriz de Gram.",
                                  "commonMistakes": "Confundir norma 2 com norma Frobenius ou ignorar escala das funções base."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar o impacto da escolha de bases no condicionamento da matriz de Gram",
                                  "subSteps": [
                                    "Compare bases não ortogonais (monomiais) vs ortogonais (Chebyshev/Legendre) em cond(G).",
                                    "Analise geometricamente: bases quase lineares aumentam cond(G) por pequenos ângulos.",
                                    "Varie o grau das bases e plote cond(G) vs grau.",
                                    "Discuta escalonamento/pré-condicionamento para mitigar mau condicionamento.",
                                    "Simule em PVC simples: escolha base que minimize cond(G)."
                                  ],
                                  "verification": "Gere plots de cond(G) para monomiais vs Legendre até grau 5 e discuta diferenças.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Código Python para integração quadratura (SciPy quad)",
                                    "Biblioteca SymPy para simbólico",
                                    "Gráficos Matplotlib"
                                  ],
                                  "tips": "Escolha bases ortogonais ao domínio do problema para cond(G) ≈1.",
                                  "learningObjective": "Relacionar escolha de bases com variação no condicionamento da matriz de Gram.",
                                  "commonMistakes": "Não considerar o domínio exato do PVC, levando a integrais incorretas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar condicionamento com convergência em métodos de resíduos ponderados",
                                  "subSteps": [
                                    "Revise métodos de resíduos ponderados (ex: Galerkin, collocation) para PVC: Ax = b com A envolvendo G.",
                                    "Explique como alto cond(G) amplifica erros em iterações (ex: CG, GMRES).",
                                    "Analise taxa de convergência: depende de sqrt(cond(G)) em métodos de gradiente conjugado.",
                                    "Simule um PVC -u''=f, compare iterações com bases bem/mal condicionadas.",
                                    "Conclua: bases otimizadas aceleram convergência em simulações de engenharia."
                                  ],
                                  "verification": "Implemente método de resíduos ponderados para PVC e compare número de iterações para duas bases.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código base para métodos iterativos (SciPy sparse.linalg)",
                                    "Problema teste: equação de Poisson 1D",
                                    "Documentação de pré-condicionadores"
                                  ],
                                  "tips": "Monitore resíduo em cada iteração para quantificar impacto do condicionamento.",
                                  "learningObjective": "Analisar como condicionamento afeta convergência numérica em PVC.",
                                  "commonMistakes": "Ignorar efeitos de arredondamento que mascaram problemas de condicionamento."
                                }
                              ],
                              "practicalExample": "Para o PVC -u''(x) = π² sin(πx) em [0,1] com u(0)=u(1)=0, use base monomial {1,x,x²} vs Legendre. Compute G, cond(G)≈10³ vs ≈1, e resolva via resíduos ponderados com GMRES: monomial requer >50 iterações, Legendre <10.",
                              "finalVerifications": [
                                "Construa G e calcule cond(G) para duas bases diferentes em um PVC.",
                                "Explique verbalmente como cond(G) alto afeta estabilidade numérica.",
                                "Simule convergência de método iterativo e compare curvas de resíduo.",
                                "Identifique base ótima para minimizar cond(G) em domínio [0,1].",
                                "Discuta trade-offs: precisão vs custo computacional de bases ortogonais.",
                                "Verifique solução numérica contra exata com erro L2 <10^{-6}."
                              ],
                              "assessmentCriteria": [
                                "Correção na construção e cálculo de cond(G) (30%).",
                                "Profundidade na análise de impacto da escolha de bases (25%).",
                                "Precisão na simulação de convergência e interpretação (20%).",
                                "Uso adequado de ferramentas numéricas sem erros de implementação (15%).",
                                "Clareza em plots, explicações e conclusões (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores, SVD e normas de matrizes.",
                                "Análise Numérica: estabilidade de métodos iterativos e pré-condicionadores.",
                                "Matemática Aplicada: espaços de Sobolev para EDPs em engenharia.",
                                "Programação Científica: implementação em Python/MATLAB para simulações.",
                                "Física/Engenharia: modelagem de difusão/tensão em estruturas civis."
                              ],
                              "realWorldApplication": "Em análises de elementos finitos para projetos de pontes ou barragens (Engenharia Civil), otimizar bases na matriz de Gram reduz tempo de simulação de dias para horas, melhorando precisão em predições de deformações sob cargas dinâmicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.4",
                            "name": "Aplicar em métodos de aproximação",
                            "description": "Implementar numericamente a matriz de Gram em aproximações para problemas de contorno, usando integração numérica e avaliando condicionamento em softwares como MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o Problema de Contorno e Definir a Base de Aproximação",
                                  "subSteps": [
                                    "Escolha um problema de valor de contorno (BVP) simples, como -u''(x) = f(x) com u(0)=u(1)=0.",
                                    "Selecione uma base de funções {φ_i(x)} i=1 a n, como polinômios de Legendre ou senos.",
                                    "Escreva a aproximação u_n(x) = ∑ c_i φ_i(x) e derive os coeficientes via método de Galerkin ou momentos.",
                                    "Identifique os integrais necessários para a matriz Gram G_{ij} = ∫ φ_i φ_j dx e vetor de carga b_i = ∫ f φ_i dx.",
                                    "Defina o domínio de integração [a,b] e pontos de Gauss para integração numérica."
                                  ],
                                  "verification": "Verifique se a formulação leva a G c = b, com G simétrica positiva definida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de EDP numéricas, MATLAB instalado, documento com BVP exemplo.",
                                  "tips": "Comece com n=3-5 funções para simplicidade; use bases ortogonais se possível para G diagonal.",
                                  "learningObjective": "Compreender a conexão entre métodos de aproximação espectral e matriz Gram em BVPs.",
                                  "commonMistakes": "Esquecer condições de contorno homogêneas; escolher base não satisfazendo BCs automaticamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Integração Numérica para Elementos da Matriz Gram",
                                  "subSteps": [
                                    "Defina funções φ_i(x) em MATLAB como funções anônimas.",
                                    "Implemente quadratura de Gauss-Legendre com 5-10 pontos para calcular ∫ φ_i φ_j w(x) dx.",
                                    "Crie loops para preencher G(n x n) e b(n x 1), usando quadgk ou função personalizada.",
                                    "Teste com caso conhecido: integrais analíticos para validar precisão numérica.",
                                    "Ajuste tolerância de integração para 1e-10."
                                  ],
                                  "verification": "Compare valores numéricos com integrais exatos; erro relativo < 1e-8.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB, funções de integração (integral(), gaussquad.m se disponível).",
                                  "tips": "Vetorize computações para eficiência; pré-compute nós e pesos de Gauss.",
                                  "learningObjective": "Dominar integração numérica adaptativa para produtos de funções base em métodos espectrais.",
                                  "commonMistakes": "Pontos de Gauss insuficientes perto de singularidades; não normalizar pesos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar e Resolver o Sistema Linear G c = b",
                                  "subSteps": [
                                    "Use backslash ou mldivide para resolver c = G \\ b.",
                                    "Implemente a função aproximada u_n(x) = φ(x)' * c.",
                                    "Plote u_n(x) vs solução exata (se disponível) em malha fina.",
                                    "Calcule norma L2 do erro: sqrt(∫ (u_n - u)^2 dx) via integração numérica.",
                                    "Aumente n e observe convergência."
                                  ],
                                  "verification": "Erro L2 diminui com n crescente; solução satisfaz BCs numericamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB com plot e norm funções.",
                                  "tips": "Use condest(G) prévio para checar se G é bem condicionada antes de resolver.",
                                  "learningObjective": "Aplicar resolução de sistemas lineares em contextos de aproximação funcional.",
                                  "commonMistakes": "Resolver sem checar simetria de G; ignorar overflow em n grande."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Condicionamento da Matriz Gram e Otimizar",
                                  "subSteps": [
                                    "Calcule cond(G) = condest(G) ou svd(G).",
                                    "Analise autovalores: min/max ratio.",
                                    "Teste sensibilidade: perturbe b com ruído e observe ||c|| mudança.",
                                    "Experimente bases ortonormais para reduzir cond(G).",
                                    "Documente cond vs n e sugira pré-condicionadores como ILU."
                                  ],
                                  "verification": "cond(G) < 1e12 para n<20; gráfico de cond(n) log-log.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB funções cond, eig, svd.",
                                  "tips": "Bases de Fourier sen/cos naturalmente têm G diagonal (cond=1).",
                                  "learningObjective": "Interpretar e mitigar ill-conditioning em matrizes Gram de métodos espectrais.",
                                  "commonMistakes": "Confundir cond com rank; não log-plot para tendências."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar em Problema de Engenharia Civil Real",
                                  "subSteps": [
                                    "Aplique a um BVP de viga: EI u'''' = q(x), com BCs de apoio simples.",
                                    "Escolha base φ_i satisfazendo BCs (polinômios de viga).",
                                    "Integre para G (quádrupla para 4ª ordem) e resolva.",
                                    "Compare com solução FEM comercial ou analítica.",
                                    "Avalie cond e erro em deflexões máximas."
                                  ],
                                  "verification": "Erro em deflexão max < 1%; cond aceitável para design prático.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB, dados de viga real (comprimento, EI, q(x)=constante).",
                                  "tips": "Reduza ordem diferenciando BCs para método de Galerkin fraco.",
                                  "learningObjective": "Transferir método para aplicações estruturais em Engenharia Civil.",
                                  "commonMistakes": "Base não capturando modos altos; integração imprecisa em 4D."
                                }
                              ],
                              "practicalExample": "Em uma viga de concreto armado de 5m, EI=1e6 kNm², carga distribuída q(x)=10 kN/m. Use n=6 funções φ_i(x)=(1-x/L)^2 * P_i(2x/L-1) para BCs u(0)=u(L)=0, u''(0)=u''(L)=0. Calcule G via Gauss 8 pts, resolva para c, plote deflexão max=0.013m vs exata 0.0125m, cond(G)=150.",
                              "finalVerifications": [
                                "Código MATLAB executa sem erros e reproduz resultados em <5s para n=10.",
                                "Erro L2 da aproximação <1e-4 para n=8.",
                                "cond(G) reportado corretamente e <1e10.",
                                "Solução satisfaz BCs com tolerância 1e-6.",
                                "Gráficos mostram convergência e comparam com exata.",
                                "Análise de sensibilidade a ruído numérico realizada."
                              ],
                              "assessmentCriteria": [
                                "Precisão da integração numérica (erro relativo <1e-8).",
                                "Correta montagem e resolução do sistema Gc=b.",
                                "Análise quantitativa de condicionamento (cond, autovalores).",
                                "Convergência demonstrada com n variável.",
                                "Aplicação válida a BVP de engenharia com interpretação.",
                                "Código limpo, comentado e eficiente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura e análise de erros.",
                                "Programação Computacional: MATLAB para álgebra linear.",
                                "Física/Mecânica: Equações diferenciais em estruturas.",
                                "Estatística: Análise de sensibilidade e Monte Carlo para ruído."
                              ],
                              "realWorldApplication": "Na análise preliminar de vigas e lajes em projetos civis, usando métodos espectrais para prototipagem rápida antes de FEM detalhado, otimizando design contra vibrações e deflexões excessivas em pontes ou edifícios altos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Método dos Resíduos Ponderados",
                "description": "Técnica aproximada para resolver equações diferenciais, minimizando resíduos com funções de peso.",
                "totalSkills": 51,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Conceito de Resíduo",
                    "description": "Medida do erro entre a equação diferencial exata e a solução aproximada.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1.1",
                        "name": "Definição Geral de Resíduo",
                        "description": "O resíduo é definido como a medida quantitativa do erro cometido ao substituir a solução aproximada u_n(x) na equação diferencial exata L[u] = f(x), resultando em R(x) = L[u_n(x)] - f(x). Representa o desvio da aproximação em relação à solução exata.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1.1",
                            "name": "Identificar a expressão do resíduo",
                            "description": "Reconhecer e escrever a forma geral do resíduo R(x) = L[u_n(x)] - f(x) para uma equação diferencial linear ou não-linear, onde L é o operador diferencial e f(x) é o termo forçante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma geral da equação diferencial",
                                  "subSteps": [
                                    "Leia atentamente a equação diferencial fornecida.",
                                    "Identifique o operador diferencial L, incluindo derivadas e coeficientes associados.",
                                    "Localize o termo forçante f(x) no lado direito da equação.",
                                    "Verifique se a equação está na forma L[u(x)] = f(x), mesmo para casos não-lineares.",
                                    "Anote separadamente as expressões de L e f(x)."
                                  ],
                                  "verification": "Reescreva a equação destacando explicitamente L[u] e f(x).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplo de equação diferencial impresso ou digital"
                                  ],
                                  "tips": "L pode incluir termos não-lineares como u²; foque na estrutura geral.",
                                  "learningObjective": "Reconhecer e decompor os componentes L e f(x) de uma equação diferencial.",
                                  "commonMistakes": "Confundir coeficientes constantes do operador com o termo forçante f(x)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a função de aproximação u_n(x)",
                                  "subSteps": [
                                    "Localize a função aproximada u_n(x) no enunciado do problema.",
                                    "Verifique os parâmetros livres ou funções base usadas em u_n(x).",
                                    "Confirme o domínio de definição de x para u_n(x).",
                                    "Expresse u_n(x) de forma explícita, substituindo parâmetros se necessário.",
                                    "Anote u_n(x) para uso posterior."
                                  ],
                                  "verification": "Escreva u_n(x) corretamente e verifique se satisfaz condições de contorno aproximadas.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Lista de funções trial comuns"
                                  ],
                                  "tips": "u_n(x) é tipicamente um polinômio ou combinação de funções seno/cosseno em métodos numéricos.",
                                  "learningObjective": "Selecionar e registrar a aproximação u_n(x) usada no método.",
                                  "commonMistakes": "Confundir u_n(x) com a solução exata u(x)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o operador diferencial L à aproximação u_n(x)",
                                  "subSteps": [
                                    "Calcule as derivadas necessárias de u_n(x) conforme exigido por L.",
                                    "Aplique cada termo do operador L (derivadas, multiplicações, integrações se aplicável).",
                                    "Some todos os componentes para formar L[u_n(x)].",
                                    "Simplifique a expressão algébricamente.",
                                    "Verifique o cálculo derivando novamente um termo simples."
                                  ],
                                  "verification": "Compare L[u_n(x)] com um cálculo manual passo a passo ou ferramenta simbólica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de álgebra simbólica como SymPy (opcional)"
                                  ],
                                  "tips": "Use a regra da cadeia para termos compostos e verifique derivadas por diferenciação numérica.",
                                  "learningObjective": "Executar corretamente a aplicação do operador L sobre u_n(x).",
                                  "commonMistakes": "Erros em derivadas de segunda ou maior ordem; esquecer fatores de multiplicação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar e simplificar a expressão do resíduo R(x)",
                                  "subSteps": [
                                    "Escreva a fórmula geral R(x) = L[u_n(x)] - f(x).",
                                    "Substitua as expressões calculadas de L[u_n(x)] e f(x).",
                                    "Realize a subtração termo a termo.",
                                    "Simplifique a expressão resultante.",
                                    "Verifique se R(x) tende a zero onde a aproximação é boa."
                                  ],
                                  "verification": "Confirme que R(x) = 0 se u_n(x) for a solução exata.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis"
                                  ],
                                  "tips": "O resíduo quantifica o erro local da aproximação; sinal correto é crucial.",
                                  "learningObjective": "Construir a expressão completa e correta do resíduo.",
                                  "commonMistakes": "Inverter o sinal (escrever f(x) - L[u_n(x)]); não simplificar fully."
                                }
                              ],
                              "practicalExample": "Considere a equação -u''(x) + u(x) = x em [0,1], com u(0)=u(1)=0. Aproximação u_n(x) = x(1-x). Operador L[u] = -u'' + u, f(x)=x. Derivadas: u_n' = 1-2x, u_n'' = -2. L[u_n] = -(-2) + x(1-x) = 2 + x - x². Resíduo R(x) = 2 + x - x² - x = 2 - x².",
                              "finalVerifications": [
                                "Identifica corretamente L e f(x) em pelo menos 3 equações diferentes.",
                                "Escreve R(x) sem erros aritméticos para o exemplo prático.",
                                "Explica o significado do resíduo como medida de erro da aproximação.",
                                "Verifica que R(x)=0 nas condições de contorno aproximadas.",
                                "Simplifica R(x) a uma forma mínima.",
                                "Aplica o conceito a uma EDO não-linear simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição de L e f(x) (100% correto).",
                                "Correção no cálculo de derivadas e L[u_n(x)] (sem erros).",
                                "Expressão final de R(x) exata e simplificada.",
                                "Clareza na documentação dos passos intermediários.",
                                "Tempo total dentro de 40 minutos.",
                                "Capacidade de generalizar para EDOs de ordem superior."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de operadores diferenciais e análise funcional.",
                                "Física: Modelagem de vibrações e deformações em estruturas civis.",
                                "Programação: Implementação numérica em Python ou MATLAB para métodos de elementos finitos.",
                                "Engenharia Mecânica: Soluções aproximadas em dinâmica de estruturas."
                              ],
                              "realWorldApplication": "Na engenharia civil, o conceito de resíduo é fundamental no Método dos Resíduos Ponderados (como Galerkin) para simulações computacionais de problemas estruturais, como análise de vigas, placas e fundações, permitindo soluções aproximadas eficientes para equações diferenciais parciais complexas em softwares de elementos finitos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.1.2",
                            "name": "Calcular resíduo para equação diferencial simples",
                            "description": "Aplicar a definição para computar o resíduo em uma equação diferencial de primeira ou segunda ordem com solução aproximada polinomial ou por séries.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Geral de Resíduo",
                                  "subSteps": [
                                    "Revise a forma geral de uma equação diferencial: L(u) = f, onde L é o operador diferencial.",
                                    "Defina o resíduo R(x) = L(u_h) - f, com u_h sendo a solução aproximada polinomial ou por séries.",
                                    "Explique o significado: R(x) quantifica o erro local da aproximação em cada ponto x.",
                                    "Discuta exemplos simples de operadores L para EDOs de 1ª ou 2ª ordem, como d²/dx² ou d/dx."
                                  ],
                                  "verification": "Escreva a definição de resíduo para uma EDO de 2ª ordem e dê um exemplo verbal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas de aula sobre Método dos Resíduos Ponderados",
                                    "Livro-texto de Equações Diferenciais"
                                  ],
                                  "tips": [
                                    "Visualize R(x) como o 'desvio' da aproximação da equação exata; zero indica solução exata."
                                  ],
                                  "learningObjective": "Dominar o conceito teórico de resíduo como medida de erro local.",
                                  "commonMistakes": [
                                    "Confundir resíduo com norma global do erro; resíduo é ponto a ponto.",
                                    "Esquecer que f pode incluir termos de contorno ou fonte."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Equação Diferencial e a Solução Aproximada",
                                  "subSteps": [
                                    "Escreva explicitamente a EDO de 1ª ou 2ª ordem, incluindo condições de contorno.",
                                    "Selecione uma aproximação u_h: polinomial (ex: u_h = a + b x + c x²) ou série de potências (ex: sum_{n=0}^N c_n x^n).",
                                    "Verifique se u_h satisfaz condições de contorno essenciais.",
                                    "Liste os coeficientes desconhecidos em u_h.",
                                    "Determine o domínio x ∈ [a, b]."
                                  ],
                                  "verification": "Confirme que u_h atende às condições de contorno e anote L e f claramente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora gráfica ou software como MATLAB/SymPy"
                                  ],
                                  "tips": [
                                    "Comece com aproximações de baixa ordem (grau 1 ou 2) para simplicidade inicial."
                                  ],
                                  "learningObjective": "Preparar os componentes necessários para o cálculo do resíduo.",
                                  "commonMistakes": [
                                    "Ignorar condições de contorno na escolha de u_h.",
                                    "Escolher u_h incompatível com a ordem da EDO."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o Resíduo Substituindo a Aproximação",
                                  "subSteps": [
                                    "Calcule as derivadas necessárias de u_h até a ordem da EDO (ex: u_h', u_h'' para 2ª ordem).",
                                    "Substitua u_h e suas derivadas no operador L(u_h).",
                                    "Subtraia o termo f para obter R(x) = L(u_h) - f.",
                                    "Simplifique a expressão algébrica de R(x), expandindo polinômios se aplicável.",
                                    "Avalie R(x) em pontos específicos do domínio para inspeção numérica."
                                  ],
                                  "verification": "Derive R(x) passo a passo e verifique derivadas diferenciando novamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica (ex: Wolfram Alpha)",
                                    "Planilha para avaliação numérica"
                                  ],
                                  "tips": [
                                    "Use regras de derivação em cadeia para séries; fatorize R(x) para insights."
                                  ],
                                  "learningObjective": "Executar o cálculo matemático preciso do resíduo.",
                                  "commonMistakes": [
                                    "Erro em derivadas de polinômios (ex: derivada de x^n é n x^{n-1}).",
                                    "Esquecer sinal ao subtrair f."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Interpretar o Resultado do Resíduo",
                                  "subSteps": [
                                    "Confira se R(x) = 0 nos pontos onde u_h é exato (ex: contornos).",
                                    "Plote ou tabule R(x) no domínio para visualizar magnitude e sinal.",
                                    "Compare ||R|| (norma L2 ou máxima) com tolerâncias aceitáveis.",
                                    "Discuta como minimizar R ajustando coeficientes de u_h.",
                                    "Registre observações sobre regiões de maior resíduo."
                                  ],
                                  "verification": "R(x) deve ser contínuo e pequeno; valide com solução exata se conhecida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de plotagem (ex: Python Matplotlib, Excel)",
                                    "Solução exata conhecida para validação"
                                  ],
                                  "tips": [
                                    "Norma L2 de R: ∫ R² dx; use para quantificar erro global aproximado."
                                  ],
                                  "learningObjective": "Analisar a qualidade da aproximação via resíduo.",
                                  "commonMistakes": [
                                    "Interpretar R grande como falha total sem contexto de norma.",
                                    "Não checar unidades consistentes em R."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a EDO -u''(x) + u(x) = 1 em [0,1] com u(0)=u(1)=0, use aproximação polinomial u_h(x) = 4x(1-x). Calcule: u_h''(x) = -8, L(u_h) = 8 + 4x(1-x), R(x) = 8 + 4x - 4x² - 1 = 7 + 4x - 4x². Avalie R(0.5) ≈ 5.",
                              "finalVerifications": [
                                "R(x) = 0 nas condições de contorno essenciais.",
                                "Derivadas de u_h calculadas corretamente.",
                                "Expressão de R(x) simplificada e sem erros algébricos.",
                                "R(x) avaliado em pelo menos 3 pontos do domínio.",
                                "Magnitude de R consistente com grau da aproximação.",
                                "Interpretação qualitativa do resíduo fornecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de derivadas e substituição (100% correto).",
                                "Clareza e organização dos passos algébricos.",
                                "Correta aplicação da definição de resíduo.",
                                "Análise qualitativa/quantitativa adequada do resultado.",
                                "Uso apropriado de aproximações polinomiais ou séries.",
                                "Ausência de erros dimensionais ou de sinal."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Integração com métodos de Galerkin e elementos finitos.",
                                "Física: Modelagem de vibrações em estruturas civis via EDOs.",
                                "Programação: Implementação computacional em Python/MATLAB para automação.",
                                "Estatística: Análise de erro e normas para validação numérica."
                              ],
                              "realWorldApplication": "Em engenharia civil, calcular resíduos em soluções aproximadas por elementos finitos é essencial para análise de tensões em vigas, placas e fundações, garantindo precisão em simulações de cargas sísmicas ou dinâmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.1.3",
                            "name": "Interpretar o significado de resíduo nulo",
                            "description": "Explicar que R(x) = 0 em todo o domínio implica que u_n(x) é a solução exata da equação diferencial, independentemente das condições de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Geral de Resíduo",
                                  "subSteps": [
                                    "Relembre a equação diferencial original L[u] = f(x).",
                                    "Defina o resíduo R(x) = L[u_n(x)] - f(x), onde u_n(x) é a aproximação.",
                                    "Explique que R(x) mede o erro da aproximação.",
                                    "Discuta como em métodos de resíduos ponderados, integrais de R(x) com funções peso são minimizados.",
                                    "Identifique exemplos onde R(x) é pequeno mas não zero."
                                  ],
                                  "verification": "Escreva a fórmula de R(x) e dê um exemplo numérico simples onde R(x) ≠ 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas de aula sobre método dos resíduos ponderados, calculadora ou software como MATLAB.",
                                  "tips": "Use notação consistente para operador L para evitar confusão.",
                                  "learningObjective": "Compreender o papel do resíduo como indicador de erro na aproximação.",
                                  "commonMistakes": "Confundir resíduo com erro nas condições de contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Caso de Resíduo Nulo R(x) = 0",
                                  "subSteps": [
                                    "Considere a condição R(x) = 0 para todo x no domínio.",
                                    "Substitua na definição: L[u_n(x)] - f(x) = 0 implica L[u_n(x)] = f(x).",
                                    "Interprete isso como u_n(x) satisfazendo exatamente a equação diferencial.",
                                    "Discuta o que 'em todo o domínio' significa matematicamente.",
                                    "Verifique graficamente plotando R(x) = 0."
                                  ],
                                  "verification": "Derive que R(x) = 0 leva a L[u_n] = f e confirme com uma equação simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e lápis para derivações, software de plotagem como Python/Matplotlib.",
                                  "tips": "Pense em R(x) como uma função zero idêntica, não apenas em pontos discretos.",
                                  "learningObjective": "Reconhecer que resíduo nulo equivale à satisfação exata da EDO.",
                                  "commonMistakes": "Achar que R(x)=0 só em pontos de colocation, ignorando o domínio contínuo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Implicações para Solução Exata e Condições de Contorno",
                                  "subSteps": [
                                    "Explique que se R(x)=0 em todo domínio, u_n(x) é solução exata da EDO.",
                                    "Discuta independência das condições de contorno: a EDO é satisfeita antes de aplicá-las.",
                                    "Compare com métodos onde condições de contorno afetam a aproximação.",
                                    "Analise se u_n(x) ainda precisa satisfazer condições de contorno separadamente.",
                                    "Dê um contraexemplo onde R(x)=0 mas condições de contorno não são atendidas."
                                  ],
                                  "verification": "Escreva uma declaração clara: 'R(x)=0 implica u_n exata da EDO, independente de BCs' e justifique.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos de EDOs de engenharia civil (e.g., viga em flexão), quadro branco.",
                                  "tips": "Separe EDO do problema de contorno completo.",
                                  "learningObjective": "Diferenciar satisfação da EDO das condições de contorno.",
                                  "commonMistakes": "Supor que R(x)=0 garante solução completa do BVP."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar com Exemplo Prático",
                                  "subSteps": [
                                    "Escolha uma EDO simples: u'' + u = 0.",
                                    "Encontre solução exata u(x) = A cos(x) + B sin(x).",
                                    "Compute R(x) para u_n(x) = u(x) exata e veja R=0.",
                                    "Aplique condições de contorno arbitrárias e confirme R=0 persiste.",
                                    "Compare com aproximação polinomial onde R≠0."
                                  ],
                                  "verification": "Calcule R(x) numericamente/graficamente e confirme nulidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software numérico (MATLAB, Python com SymPy/NumPy), exemplos impressos.",
                                  "tips": "Use soluções analíticas conhecidas para validação rápida.",
                                  "learningObjective": "Aplicar o conceito de resíduo nulo em um contexto concreto.",
                                  "commonMistakes": "Esquecer de verificar em todo o domínio, só em pontos."
                                }
                              ],
                              "practicalExample": "Considere a EDO u''(x) = 0 no domínio [0,1], solução exata u(x) = x. Usando u_n(x) = x como aproximação, R(x) = u_n''(x) - 0 = 0 em todo [0,1]. Mudando condições de contorno u(0)=0, u(1)=2 não altera R(x)=0, confirmando u_n exata da EDO.",
                              "finalVerifications": [
                                "Explica verbalmente que R(x)=0 implica solução exata da EDO.",
                                "Identifica corretamente em um gráfico onde R(x) é nulo.",
                                "Distingue satisfação da EDO de condições de contorno.",
                                "Aplica o conceito a uma nova EDO simples.",
                                "Discute limitações em problemas reais onde soluções exatas são raras.",
                                "Verifica R(x)=0 computacionalmente em um exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e interpretação de R(x)=0 (30%).",
                                "Clareza na distinção entre EDO e condições de contorno (25%).",
                                "Uso correto de exemplos matemáticos (20%).",
                                "Profundidade na análise de implicações (15%).",
                                "Comunicação clara e estruturada (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de equações diferenciais e soluções exatas.",
                                "Física: Modelagem de sistemas lineares em mecânica estrutural.",
                                "Programação: Implementação numérica de resíduos em FEM.",
                                "Engenharia: Validação de modelos computacionais em simulações."
                              ],
                              "realWorldApplication": "Em análises de estruturas civis via elementos finitos, um resíduo nulo em uma aproximação valida que o modelo captura exatamente a física subjacente, útil para calibração de software antes de aplicar cargas reais e condições de suporte complexas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.1.2",
                        "name": "Resíduo em Problemas de Valor Inicial (PVI)",
                        "description": "No contexto de problemas de valor inicial, o resíduo mede o erro local na equação diferencial, sendo minimizado ou ponderado para melhorar a aproximação em intervalos iniciais especificados.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.2.1",
                            "name": "Formular resíduo para PVI",
                            "description": "Construir o resíduo para um PVI como y'' + p(x)y' + q(x)y = f(x) com condições y(x0)=y0, y'(x0)=y0', usando aproximação u_n(x).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o operador diferencial e a estrutura do PVI",
                                  "subSteps": [
                                    "Analise a equação diferencial dada: y'' + p(x)y' + q(x)y = f(x)",
                                    "Identifique o ponto inicial x0 e as condições iniciais y(x0) = y0, y'(x0) = y0'",
                                    "Escreva o operador diferencial L[y] = y'' + p(x)y' + q(x)y",
                                    "Confirme que se trata de um PVI de segunda ordem linear",
                                    "Anote funções p(x), q(x) e f(x) explicitamente"
                                  ],
                                  "verification": "Verifique se o operador L está corretamente escrito e as condições iniciais listadas em um papel ou software",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Software de álgebra simbólica como SymPy ou Mathematica (opcional)"
                                  ],
                                  "tips": "Sempre comece pelo operador L para evitar confusão nas derivadas de ordem superior",
                                  "learningObjective": "Compreender a forma padrão do PVI e isolar o operador diferencial L",
                                  "commonMistakes": [
                                    "Confundir condições iniciais com condições de contorno",
                                    "Esquecer termos p(x) ou q(x) variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e parametrizar a aproximação u_n(x)",
                                  "subSteps": [
                                    "Escolha uma base de funções, como polinômios de grau n: u_n(x) = a0 + a1(x-x0) + ... + an(x-x0)^n",
                                    "Incorpore as condições iniciais para reduzir parâmetros: u_n(x0) = y0 e u_n'(x0) = y0'",
                                    "Expresse os coeficientes livres (ex: a2 a an) como variáveis desconhecidas",
                                    "Verifique se u_n satisfaz as condições iniciais exata ou aproximadamente",
                                    "Escreva u_n(x) explicitamente em termos de coeficientes livres"
                                  ],
                                  "verification": "Substitua x=x0 em u_n e u_n' para confirmar que igualam y0 e y0'",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Planilha ou software para expansão de polinômios"
                                  ],
                                  "tips": "Use expansão de Taylor ao redor de x0 para facilitar satisfação das CI",
                                  "learningObjective": "Construir uma aproximação trial function que respeite as condições iniciais do PVI",
                                  "commonMistakes": [
                                    "Não satisfazer as CI, levando a resíduo inconsistente",
                                    "Escolher grau n muito baixo para precisão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular derivadas da aproximação u_n(x)",
                                  "subSteps": [
                                    "Compute a primeira derivada u_n'(x) diferenciando termo a termo",
                                    "Compute a segunda derivada u_n''(x) a partir de u_n'(x)",
                                    "Verifique as derivadas em x=x0 para confirmar u_n'(x0)=y0'",
                                    "Expresse todas as derivadas em termos dos mesmos coeficientes livres",
                                    "Simplifique expressões algébricas se possível"
                                  ],
                                  "verification": "Diferencie numericamente ou simbolicamente e compare com derivadas manuais em pontos teste",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de diferenciação como Wolfram Alpha ou Python/SymPy"
                                  ],
                                  "tips": "Mantenha polinômios expandidos para evitar erros em produtos como p(x)u_n'",
                                  "learningObjective": "Dominar o cálculo de derivadas analíticas para funções aproximadas paramétricas",
                                  "commonMistakes": [
                                    "Erros de sinal em derivações",
                                    "Confundir ordens de derivadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e simplificar o resíduo R(x)",
                                  "subSteps": [
                                    "Substitua u_n, u_n', u_n'' no operador: R(x) = u_n'' + p(x)u_n' + q(x)u_n - f(x)",
                                    "Expanda todos os termos e colete como função de x e coeficientes livres",
                                    "Simplifique R(x) algebraicamente, identificando termos residuais",
                                    "Verifique se R(x0) ≈ 0 considerando as CI (deve ser pequeno)",
                                    "Escreva a forma final do resíduo para uso no método dos resíduos ponderados"
                                  ],
                                  "verification": "Substitua valores numéricos conhecidos e confirme R próximo de zero onde equação é satisfeita",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software para simplificação simbólica"
                                  ],
                                  "tips": "Agrupe termos por potências de (x-x0) para análise posterior",
                                  "learningObjective": "Formular o resíduo exato como R(x) = L[u_n(x)] - f(x)",
                                  "commonMistakes": [
                                    "Esquecer o sinal de -f(x)",
                                    "Não expandir produtos p(x)u_n' corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVI y'' + 4y = 0, y(0)=1, y'(0)=0, use u_2(x) = 1 + a2 x^2. Calcule u_2''=2a2, R(x)=2a2 + 4(1 + a2 x^2). Simplifique R(x)=2a2 + 4 + 4a2 x^2.",
                              "finalVerifications": [
                                "R(x) está na forma L[u_n] - f(x)?",
                                "u_n satisfaz y(x0)=y0 e y'(x0)=y0'?",
                                "Derivadas u_n' e u_n'' calculadas corretamente?",
                                "Termos p(x), q(x), f(x) incorporados adequadamente?",
                                "R(x) simplificado sem erros algébricos?",
                                "Verificação numérica em x0 mostra R(x0)≈0?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do operador L (100%)",
                                "Correta parametrização de u_n respeitando CI (90-100%)",
                                "Exatidão nas derivadas calculadas (95%)",
                                "Formação correta e simplificada de R(x) (100%)",
                                "Capacidade de aplicar em exemplo prático sem erros",
                                "Tempo de execução dentro do estimado total (2 horas)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Integração com métodos de Galerkin ou collocation",
                                "Programação: Implementação em Python/MATLAB para automação de resíduos",
                                "Física: Modelagem de osciladores harmônicos ou vibrações em estruturas",
                                "Engenharia Computacional: Pré-processamento para FEM em vigas",
                                "Estatística: Análise de erro residual em aproximações"
                              ],
                              "realWorldApplication": "Em Engenharia Civil, formular resíduos para PVIs modela deflexão de vigas sob carga (ex: y'''' = w(x)/EI), permitindo soluções computacionais aproximadas no método dos elementos finitos para análise estrutural eficiente em projetos de pontes e edifícios."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2.2",
                            "name": "Avaliar impacto das condições iniciais no resíduo",
                            "description": "Analisar como as condições de valor inicial afetam o resíduo e sua distribuição ao longo do domínio de integração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o conceito de resíduo em Problemas de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Defina resíduo como a diferença entre a solução numérica aproximada e a equação diferencial exata.",
                                    "Explique como condições iniciais (CI) definem y(0) ou valores em t=0 para EDOs de primeira ordem.",
                                    "Discuta o papel do resíduo na avaliação de precisão em métodos como resíduos ponderados.",
                                    "Identifique como CI propagam erros ao longo do domínio de integração [a,b].",
                                    "Estude fórmulas matemáticas: resíduo R(t) = L[y_n(t)] - f(t,y(t)), onde L é o operador diferencial."
                                  ],
                                  "verification": "Resuma em um parágrafo como CI afetam R(t) e forneça um exemplo matemático simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de métodos numéricos, notas de aula sobre PVI, calculadora simbólica (ex: SymPy).",
                                  "tips": "Use diagramas de fase para visualizar propagação de erros desde CI.",
                                  "learningObjective": "Compreender a definição e dependência do resíduo nas condições iniciais.",
                                  "commonMistakes": "Confundir resíduo com erro global; ignorar que CI afetam toda a solução, não só o início."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar um modelo PVI simples com condições iniciais variáveis",
                                  "subSteps": [
                                    "Escolha uma EDO de teste: dy/dt = -ky + f(t), y(0) = y0 (ex: decaimento em engenharia estrutural).",
                                    "Defina domínio de integração: t ∈ [0,10], com passos h=0.1.",
                                    "Varie CI: y0 = [0.5, 1.0, 1.5] para simular cenários reais como cargas iniciais em vigas.",
                                    "Implemente solução exata analítica para comparação: y(t) = e^{-kt} y0 + integral de f.",
                                    "Prepare código computacional em Python/MATLAB para calcular aproximações."
                                  ],
                                  "verification": "Gere tabela com 3 conjuntos de CI e soluções exatas em pontos chave (t=0,5,10).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/SciPy, MATLAB ou Jupyter Notebook, EDO solver built-in.",
                                  "tips": "Comece com k=0.1 e f(t)=0 para simplicidade, depois adicione forcing term.",
                                  "learningObjective": "Preparar um benchmark controlado para análise de impacto de CI.",
                                  "commonMistakes": "Escolher EDOs rígidos sem solver adaptativo; não normalizar unidades de t e y."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular resíduos para diferentes condições iniciais",
                                  "subSteps": [
                                    "Aplique método dos resíduos ponderados para aproximar y_n(t) com cada y0.",
                                    "Compute resíduo ponto a ponto: R_i = |L[y_n(t_i)] - f(t_i, y_n(t_i))|.",
                                    "Calcule estatísticas: média, desvio padrão, máximo de |R| ao longo do domínio.",
                                    "Repita para 3-5 variações de y0 (±10%, ±20% da nominal).",
                                    "Armazene dados em arrays para análise comparativa."
                                  ],
                                  "verification": "Produza planilha com resíduos médios e max para cada CI, destacando diferenças.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python/MATLAB customizado para resíduos ponderados, planilhas Excel.",
                                  "tips": "Use pesos gaussianos nos resíduos para simular método real; vetorize cálculos.",
                                  "learningObjective": "Quantificar numericamente o impacto das CI no resíduo.",
                                  "commonMistakes": "Não dividir por norma da solução (erro relativo); ignorar acumulação de erros truncamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e visualizar distribuição do resíduo ao longo do domínio",
                                  "subSteps": [
                                    "Plote R(t) vs t para cada CI em gráficos sobrepostos.",
                                    "Analise padrões: resíduo cresce/decresce? Oscilações perto de CI?",
                                    "Compute correlação entre Δy0 e ΔR (ex: coeficiente de Pearson).",
                                    "Discuta sensibilidade: ∂R/∂y0 qualitativamente ou via derivadas numéricas.",
                                    "Conclua sobre distribuição: uniforme, concentrado no início/fim?"
                                  ],
                                  "verification": "Crie relatório com 3 plots e tabela de correlações, explicando tendências.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matplotlib/Plotly para gráficos, software de análise estatística.",
                                  "tips": "Use log-escala para |R| se variar ordens de magnitude; adicione intervalos de confiança.",
                                  "learningObjective": "Interpretar visual e estatisticamente o impacto das CI na distribuição do resíduo.",
                                  "commonMistakes": "Atribuir variações só a CI sem checar estabilidade numérica; plots sem legendas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar impactos e recomendações para engenharia civil",
                                  "subSteps": [
                                    "Resuma: CI imprecisas amplificam R no domínio downstream em sistemas instáveis.",
                                    "Proponha mitigação: sensibilidade analysis, CI robustas via medições.",
                                    "Compare com solução exata: impacto relativo em erro total.",
                                    "Documente thresholds: se max|R| > 1e-3, recalibrar CI.",
                                    "Prepare apresentação com key insights."
                                  ],
                                  "verification": "Escreva conclusão de 200 palavras com 2 recomendações acionáveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto, slides PowerPoint/Keynote.",
                                  "tips": "Relacione a casos reais como vibrações em pontes onde CI = deformação inicial.",
                                  "learningObjective": "Aplicar análise para decisões em simulações computacionais.",
                                  "commonMistakes": "Generalizar de um exemplo; ignorar contexto de resíduos ponderados."
                                }
                              ],
                              "practicalExample": "Em simulação de uma viga cantilever sob carga dinâmica (EDO: m y'' + c y' + k y = F(t)), varie y(0)=deslocamento inicial [0, 0.01m, 0.02m]. Compute resíduos no método ponderado ao longo t=[0,5]s. Observe que y0=0.02m dobra max|R| em t=5s devido a propagação instável.",
                              "finalVerifications": [
                                "Plots mostram R(t) proporcional a Δy0 em todos casos testados.",
                                "Correlação >0.8 entre CI e média de |R|.",
                                "Análise identifica domínio onde R é mais sensível (ex: t>2s).",
                                "Recomendações incluem tolerância para CI baseada em max|R|<1e-4.",
                                "Relatório compara com solução exata com erro <5%.",
                                "Código reproduz resultados em <1min de execução."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Resíduos calculados corretamente com erro <1e-6 vs exato.",
                                "Análise: Interpretação clara de padrões de distribuição de R(t).",
                                "Visualização: Gráficos informativos com escalas adequadas e legendas.",
                                "Quantificação: Estatísticas (média, std, max) reportadas para todas CI.",
                                "Aplicação: Liga achados a contexto de engenharia civil.",
                                "Completude: Todos steps executados com verificações passadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de sensibilidade e EDOs lineares.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Estatística: Correlação e análise de variância em resíduos.",
                                "Física: Dinâmica de sistemas com CI em estruturas civis."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios, simulações FEM usam PVI para vibrações; avaliar impacto de CI (ex: vento inicial) no resíduo garante precisão preditiva, evitando superestimação de fadiga estrutural e otimizando designs seguros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.1.3",
                        "name": "Resíduo em Problemas de Valor de Contorno (PVC)",
                        "description": "Em problemas de valor de contorno, o resíduo é complementado pelas condições de contorno residuais, medindo erros tanto na equação diferencial quanto nas fronteiras do domínio.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.3.1",
                            "name": "Definir resíduo composto em PVC",
                            "description": "Combinar o resíduo diferencial R(x) com resíduos de contorno R_a = u_n(a) - g_a e R_b = u_n(b) - g_b para um PVC em [a,b].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Resíduo Diferencial R(x)",
                                  "subSteps": [
                                    "Relembrar a forma geral de um Problema de Valor de Contorno (PVC): operado diferencial L[u] = f(x) em [a, b] com condições de contorno u(a) = g_a e u(b) = g_b.",
                                    "Definir o resíduo diferencial R(x) = L[u_n(x)] - f(x), onde u_n(x) é uma aproximação numérica da solução exata u(x).",
                                    "Interpretar R(x) como a medida do erro local cometido pela aproximação na satisfação da equação diferencial.",
                                    "Derivar um exemplo simples: para L[u] = -u'', calcular R(x) = -u_n''(x) - f(x).",
                                    "Discutir propriedades: R(x) deve tender a zero para convergência."
                                  ],
                                  "verification": "Escrever corretamente a fórmula de R(x) e explicá-la em palavras próprias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Notas sobre equações diferenciais e PVC",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Visualize R(x) como o 'desvio' da aproximação da equação real; desenhe gráficos para intuição.",
                                  "learningObjective": "Formular e interpretar o resíduo diferencial em um PVC.",
                                  "commonMistakes": [
                                    "Confundir R(x) com o erro global || Esquecer o operador L na definição || Ignorar o domínio [a,b]"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os Resíduos de Contorno R_a e R_b",
                                  "subSteps": [
                                    "Examinar as condições de contorno: u(a) = g_a e u(b) = g_b.",
                                    "Definir R_a = u_n(a) - g_a, o erro na condição de contorno em x = a.",
                                    "Definir R_b = u_n(b) - g_b, o erro na condição de contorno em x = b.",
                                    "Explicar que R_a e R_b capturam violações nas fronteiras do domínio.",
                                    "Verificar unidades: R_a e R_b têm as mesmas unidades que u(x)."
                                  ],
                                  "verification": "Calcular R_a e R_b para uma aproximação u_n(x) = x(1-x) com g_a = 0, g_b = 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para cálculos",
                                    "Exemplo de PVC simples anotado"
                                  ],
                                  "tips": "Lembre-se: resíduos de contorno são avaliados apenas nos pontos a e b, não no interior.",
                                  "learningObjective": "Identificar e calcular resíduos de contorno em PVCs.",
                                  "commonMistakes": [
                                    "Inverter a ordem: g_a - u_n(a) || Aplicar resíduos de contorno no interior do domínio || Ignorar normalização se aplicável"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o Resíduo Composto",
                                  "subSteps": [
                                    "Combinar os resíduos: resíduo composto R_composto = {R(x), R_a, R_b}.",
                                    "Descrever R_composto como o conjunto que engloba erros diferenciais e de contorno.",
                                    "Explicar seu papel no Método dos Resíduos Ponderados (MRP): minimizar R_composto via pesos.",
                                    "Escrever notação formal: R_composto[u_n] = (R(x) para x ∈ [a,b], R_a em a, R_b em b).",
                                    "Discutir equilíbrio: R_composto zero implica solução exata."
                                  ],
                                  "verification": "Escrever a definição completa de R_composto e justificar a combinação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Referência ao MRP",
                                    "Exemplos prévios de R(x), R_a, R_b"
                                  ],
                                  "tips": "Pense no resíduo composto como um 'vetor de erros' completo para o PVC.",
                                  "learningObjective": "Definir precisamente o resíduo composto integrando todos os componentes.",
                                  "commonMistakes": [
                                    "Omitir um dos resíduos || Tratar R_composto como soma escalar || Confundir com norma do resíduo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar o Conceito",
                                  "subSteps": [
                                    "Escolher um PVC exemplo: -u'' = π² sin(πx) em [0,1], u(0)=u(1)=0; solução exata u=sin(πx).",
                                    "Aproximar u_n(x) = x(1-x)/2; calcular R(x), R_a=0, R_b=0.",
                                    "Computar R_composto e discutir magnitude.",
                                    "Analisar como MRP usa R_composto para refinar u_n.",
                                    "Generalizar para PVCs de ordem superior."
                                  ],
                                  "verification": "Calcular R_composto para o exemplo e interpretar resultados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/MATLAB",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Use aproximações polinomiais simples para prática inicial.",
                                  "learningObjective": "Aplicar definição de resíduo composto em um PVC concreto.",
                                  "commonMistakes": [
                                    "Erro em derivadas ao calcular R(x) || Esquecer condições exatas || Superestimar convergência"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVC -u''(x) = 1 em [0,1] com u(0)=0, u(1)=0 (solução exata u(x)=x(1-x)/2). Aproximação inicial u_n(x)=0. Calcule: R(x)=-1, R_a=0, R_b=0. Assim, R_composto = {-1 para x∈[0,1], 0, 0}. No MRP, pesos refinam u_n minimizando isso.",
                              "finalVerifications": [
                                "Definir corretamente R(x), R_a e R_b com fórmulas exatas.",
                                "Combinar em R_composto sem omissões.",
                                "Calcular R_composto para um PVC exemplo dado.",
                                "Explicar papel no MRP.",
                                "Identificar quando R_composto=0.",
                                "Discutir limitações em PVCs não lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática (fórmulas corretas: 30%)",
                                "Compreensão conceitual (interpretação de erros: 25%)",
                                "Cálculos em exemplo prático (exatidão numérica: 20%)",
                                "Conexão com MRP (relevância: 15%)",
                                "Clareza na explicação escrita (comunicação: 10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Normas e minimização de resíduos.",
                                "Programação: Implementar cálculo de R_composto em Python/MATLAB.",
                                "Física: Modelagem de equações diferenciais em mecânica estrutural.",
                                "Estatística: Análise de erros em aproximações.",
                                "Engenharia de Software: Validação de solvers numéricos."
                              ],
                              "realWorldApplication": "Em análises de elementos finitos (FEM) para estruturas civis, como vigas e lajes, o resíduo composto valida precisão de simulações, garantindo segurança em projetos de pontes e edifícios ao minimizar erros em condições de contorno e equações de equilíbrio."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3.2",
                            "name": "Calcular e plotar resíduo em PVC",
                            "description": "Computar numericamente o resíduo para uma aproximação em um PVC de segunda ordem e visualizá-lo para avaliar a qualidade da solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Problema de Valor de Contorno (PVC) de Segunda Ordem e Sua Aproximação Numérica",
                                  "subSteps": [
                                    "Escolha um PVC de segunda ordem padrão, como -u''(x) + p(x)u'(x) + q(x)u(x) = f(x) em [a,b] com condições u(a)=α e u(b)=β.",
                                    "Defina a malha numérica uniforme com N pontos internos, h = (b-a)/(N+1).",
                                    "Implemente a discretização por diferenças finitas centrais para derivadas de segunda ordem: u''(x_i) ≈ (u_{i-1} - 2u_i + u_{i+1})/h².",
                                    "Resolva o sistema linear Au = f aproximado para obter a solução numérica u_h.",
                                    "Valide a implementação comparando com solução exata conhecida, se disponível."
                                  ],
                                  "verification": "Verifique se o sistema linear é resolvido corretamente e u_h satisfaz as condições de contorno com tolerância 1e-10.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Software de programação (Python com NumPy/SciPy ou MATLAB)",
                                    "Papel e lápis para derivação manual",
                                    "Exemplo de PVC com solução exata (ex: u'' + u = 0)"
                                  ],
                                  "tips": [
                                    "Comece com N pequeno (ex: 10) para depuração rápida.",
                                    "Use funções vetorizadas para eficiência.",
                                    "Salve u_h em array para reutilização."
                                  ],
                                  "learningObjective": "Configurar corretamente um PVC e sua solução aproximada numérica.",
                                  "commonMistakes": [
                                    "Erro nas condições de contorno (fantasma incorreto)",
                                    "Malha não uniforme acidentalmente",
                                    "Inversão errada da matriz A"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Formulação da Expressão do Resíduo",
                                  "subSteps": [
                                    "Recorde a definição: Resíduo R(x_i) = L[u_h](x_i) - f(x_i), onde L é o operador diferencial.",
                                    "Expresse R_i ≈ [ (u_{i-1} - 2u_i + u_{i+1})/h² + p_i (u_{i+1} - u_{i-1})/(2h) + q_i u_i ] - f_i para PVC geral.",
                                    "Para PVC simples como -u''=f, R_i = - (u_{i-1} - 2u_i + u_{i+1})/h² - f_i.",
                                    "Normalize o resíduo se necessário: ||R||_∞ = max |R_i|, ou norma L2.",
                                    "Teste a fórmula em um ponto conhecido manualmente."
                                  ],
                                  "verification": "Calcule R manualmente para i=2 em malha pequena e compare com código.",
                                  "estimatedTime": "45 minutos - 1 hora",
                                  "materials": [
                                    "Folha de derivações matemáticas",
                                    "Código do Step 1",
                                    "Documentação de diferenças finitas"
                                  ],
                                  "tips": [
                                    "Mantenha consistência na indexação (i=1 a N).",
                                    "Evite divisão por h=0.",
                                    "Anote a fórmula exata para referência."
                                  ],
                                  "learningObjective": "Formular precisamente o resíduo local para a aproximação numérica.",
                                  "commonMistakes": [
                                    "Sinal errado no operador diferencial",
                                    "Omitir termos de primeira derivada",
                                    "Confundir u_h com solução exata"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Cálculo Numérico do Resíduo",
                                  "subSteps": [
                                    "Crie um array para R com tamanho N, inicializado em zero.",
                                    "Loop ou vetorize o cálculo de R_i para i=1 a N usando u_h e f na malha.",
                                    "Compute normas: máximo, L2 (sqrt(sum R_i² / N)), e média absoluta.",
                                    "Trate pontos de contorno: para PVC Dirichlet, R não definido em bordas, foque em internos.",
                                    "Otimize para N grande (ex: 1000) e meça tempo de execução."
                                  ],
                                  "verification": "Para exemplo conhecido, ||R||_∞ < 1e-3 para h=0.1; compare com teoria de convergência O(h²).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python/MATLAB com loops vetorizados",
                                    "Bibliotecas NumPy/MATLAB para normas",
                                    "Relógio para timing"
                                  ],
                                  "tips": [
                                    "Use broadcasting para vetorização.",
                                    "Debug com print de R em pontos selecionados.",
                                    "Salve R em variável para plotting."
                                  ],
                                  "learningObjective": "Calcular eficientemente o resíduo em toda a malha numérica.",
                                  "commonMistakes": [
                                    "Índices fora de bounds no loop",
                                    "Esquecimento de fator 1/h²",
                                    "Norma errada (L1 vs L2)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar o Resíduo e Avaliar a Qualidade da Solução",
                                  "subSteps": [
                                    "Gere eixos x = a + (i+0.5)h para plotting em centros de células.",
                                    "Plote R(x) vs x com matplotlib/plot: linha contínua, marque máximo.",
                                    "Adicione solução exata u_exact e erro |u_h - u_exact| no mesmo gráfico.",
                                    "Analise: oscilações indicam modo fantasma; magnitude decresce com refinamento h.",
                                    "Gere relatório: tabela com ||R|| para diferentes h."
                                  ],
                                  "verification": "Plot mostra R próximo de zero (<1e-4), decrescendo com 1/h²; sem picos anômalos.",
                                  "estimatedTime": "45 minutos - 1 hora",
                                  "materials": [
                                    "Matplotlib ou MATLAB plotting",
                                    "Dados de múltiplas malhas (h=0.2,0.1,0.05)",
                                    "Template de relatório LaTeX/Word"
                                  ],
                                  "tips": [
                                    "Use logscale para y se R varia ordens.",
                                    "Legend e labels claros.",
                                    "Salve figura em alta resolução."
                                  ],
                                  "learningObjective": "Visualizar e interpretar o resíduo para validar precisão numérica.",
                                  "commonMistakes": [
                                    "Eixo x errado (pontos vs centros)",
                                    "Escala inadequada escondendo picos",
                                    "Confundir resíduo com erro global"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVC -u''(x) = π² sin(πx) em [0,1], u(0)=u(1)=0 (solução exata u=sin(πx)). Use diferenças finitas com N=20 (h=0.05). Compute R_i e plote: espere ||R||_∞ ≈ O(10^{-3}), confirmando convergência quadrática.",
                              "finalVerifications": [
                                "Resíduo calculado corretamente em todos pontos internos com norma máxima <1e-3 para h=0.1.",
                                "Plot gerado mostra R oscilante mas amortecido, próximo de zero.",
                                "Análise qualitativa identifica qualidade: bom se max|R| <<1, ruim se >0.1.",
                                "Comparação com refinamento h: norma cai como O(h²).",
                                "Código executa sem erros para N=1000 em <1s.",
                                "Relatório inclui fórmula, normas e interpretação."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática da fórmula de resíduo (100% correção).",
                                "Eficiência e vetorização do código (tempo <0.1s para N=1000).",
                                "Qualidade visual do plot (escalas, labels, múltiplas curvas).",
                                "Interpretação correta da magnitude/forma do resíduo.",
                                "Validação com solução exata e análise de convergência.",
                                "Documentação clara no código e relatório."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação de métodos de diferenças finitas.",
                                "Visualização de Dados: Plotagem e análise gráfica com Python/MATLAB.",
                                "Análise de Erros: Normas e convergência em métodos numéricos.",
                                "Estatística: Cálculo de normas L∞, L2 para quantificação de erro.",
                                "Engenharia Computacional: Validação de modelos em simulações FEM."
                              ],
                              "realWorldApplication": "Em análises estruturais de edifícios (ex: vigas sob carga), calcular resíduo em modelos discretos (finite differences/elements) avalia precisão da previsão de tensões/deformações, evitando falhas em projetos reais como pontes ou barragens."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3.3",
                            "name": "Relacionar resíduo com método dos resíduos ponderados",
                            "description": "Explicar como o resíduo é usado no método dos resíduos ponderados, onde integrais de R(x) multiplicado por funções peso são zeradas para determinar coeficientes da aproximação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Resíduo em Aproximações Numéricas",
                                  "subSteps": [
                                    "Revise a definição de resíduo R(x) como a diferença entre a equação diferencial exata e a aproximação assumida: R(x) = L[u(x)] - f(x), onde L é o operador diferencial.",
                                    "Identifique tipos de aproximações, como trial functions u(x) ≈ Σ c_i φ_i(x), onde φ_i são funções base.",
                                    "Calcule R(x) para um exemplo simples, como y'' - y = 0 aproximado por um polinômio linear.",
                                    "Discuta por que R(x) ≠ 0 em aproximações e sua importância em métodos variacionais.",
                                    "Esboce graficamente R(x) para visualizar erros de aproximação em problemas de valor de contorno (PVC)."
                                  ],
                                  "verification": "Escreva a expressão de R(x) para um PVC dado e verifique se ela captura as condições de contorno.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Texto sobre métodos numéricos (ex: livro de análise numérica)"
                                  ],
                                  "tips": "Comece com funções trial simples para evitar confusão; foque em PVCs lineares primeiro.",
                                  "learningObjective": "Definir e calcular o resíduo R(x) em contextos de aproximação para PVCs.",
                                  "commonMistakes": [
                                    "Confundir resíduo com erro de truncamento",
                                    "Ignorar condições de contorno no cálculo de R(x)",
                                    "Usar funções trial que não satisfazem PVCs essenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Método dos Resíduos Ponderados",
                                  "subSteps": [
                                    "Explique o princípio: minimizar R(x) em média ponderada, definindo funções peso w_i(x).",
                                    "Estude variantes como Collocation (w_i = δ(x - x_i)), Subdomínio e Galerkin (w_i = φ_i).",
                                    "Derive a condição geral: ∫_Ω R(x) w_i(x) dx = 0 para i = 1 a n.",
                                    "Compare com método dos momentos (w_i = 1, x, x², etc.).",
                                    "Discuta convergência: quanto mais funções base e pesos adequados, melhor a aproximação."
                                  ],
                                  "verification": "Liste 3 variantes do método e escreva a integral de ponderação para cada uma.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Folha de exercícios",
                                    "Software de simbólico como Mathematica ou Python SymPy (opcional)",
                                    "Notas de aula sobre EDOs"
                                  ],
                                  "tips": "Use diagramas para ilustrar domínios de integração Ω em PVCs.",
                                  "learningObjective": "Entender o papel das funções peso na minimização média do resíduo.",
                                  "commonMistakes": [
                                    "Confundir pesos com funções base",
                                    "Esquecer limites de integração no domínio físico",
                                    "Assumir pesos arbitrários sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular as Equações do Método e Relacionar com Resíduo",
                                  "subSteps": [
                                    "Substitua u(x) ≈ Σ c_j φ_j(x) em R(x), obtendo R(x; {c_j}).",
                                    "Escreva o sistema: Σ_j c_j ∫ w_i L[φ_j] dx = ∫ w_i f dx para cada i.",
                                    "Verifique como zerar integrais ponderadas determina os coeficientes c_j.",
                                    "Aplique a um PVC simples: y'' + π² y = 0, y(0)=0, y(1)=1, com φ1 = x, φ2 = x(1-x).",
                                    "Resolva o sistema linear resultante manualmente."
                                  ],
                                  "verification": "Derive o sistema 2x2 de equações para o exemplo e resolva para c1, c2.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Papel quadriculado",
                                    "Tabela de integrais indefinidas"
                                  ],
                                  "tips": "Integre por partes para operadores diferenciais; verifique simetria em Galerkin.",
                                  "learningObjective": "Formular e resolver o sistema que relaciona R(x) diretamente aos coeficientes via pesos.",
                                  "commonMistakes": [
                                    "Erro em substituição de trial functions",
                                    "Inversão incorreta do sinal nas integrais",
                                    "Não normalizar funções base"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Avaliar a Aproximação",
                                  "subSteps": [
                                    "Calcule a solução aproximada u(x) = Σ c_j φ_j(x) e plote contra solução exata.",
                                    "Avalie ||R(x)|| em normas L2 ponderada para medir qualidade.",
                                    "Discuta refinamento: adicionar mais termos φ_i melhora zeramento médio de R(x).",
                                    "Relacione com aplicações em Engenharia Civil, como EDPs em vigas ou fluxo.",
                                    "Simule numéricamente em software para validar."
                                  ],
                                  "verification": "Compare u(x) aproximada com exata em 3 pontos e compute norma do resíduo.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Python/MATLAB para plotagem (opcional)",
                                    "Gráficos impressos de soluções exatas"
                                  ],
                                  "tips": "Use normas ponderadas para PVCs com pesos não-uniformes.",
                                  "learningObjective": "Interpretar como o zeramento de integrais ponderadas leva a coeficientes ótimos.",
                                  "commonMistakes": [
                                    "Interpretar c_j como valores exatos",
                                    "Ignorar efeitos de contorno nas normas",
                                    "Sobreestimar convergência sem refinamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o PVC y'' + y = 0, y(0)=0, y(1)=0 (solução exata y=0 trivial; ajuste para y(1)=1). Aproxime com u(x) = c1 x + c2 x(1-x), Galerkin w1=x, w2=x(1-x). Compute R(x) = u'' + u, resolva ∫0^1 R wi dx=0, obtenha c1≈0.5, c2≈-0.25, u(x)≈0.5x -0.25x(1-x), verificando bom ajuste.",
                              "finalVerifications": [
                                "Explicar verbalmente como R(x) é 'zerado em média' pelos pesos.",
                                "Derivar sistema para um PVC dado com 2 funções base.",
                                "Calcular coeficientes e plotar u(x) vs. exata.",
                                "Identificar variante do método usada (ex: Galerkin).",
                                "Discutir limitação se R(x) não converge uniformemente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de R(x) e sua relação com pesos (30%)",
                                "Correção na formulação das integrais e resolução do sistema (40%)",
                                "Clareza na interpretação de coeficientes e qualidade da aproximação (20%)",
                                "Uso adequado de exemplos e verificações numéricas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Métodos Espectrais",
                                "Física: Modelagem de EDPs em Mecânica dos Sólidos",
                                "Computação: Implementação em FEM (Finite Element Method)",
                                "Engenharia: Análise Estrutural de Vigas e Placas"
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usado em softwares de análise finita (ex: ANSYS) para aproximar deslocamentos em vigas sob carga, onde resíduos ponderados garantem equilíbrio médio das equações de elasticidade, otimizando projetos de pontes e edifícios."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Funções de Peso",
                    "description": "Funções escolhidas para ponderar o resíduo, garantindo ortogonalidade em um espaço funcional.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Definição e Propósito das Funções de Peso",
                        "description": "As funções de peso são funções auxiliares selecionadas no método dos resíduos ponderados para multiplicar o resíduo da equação diferencial, permitindo a projeção do erro em um espaço funcional específico.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Identificar a definição de funções de peso",
                            "description": "Explicar o papel das funções de peso no método dos resíduos ponderados, diferenciando-as das funções de aproximação e destacando sua função de ponderar o resíduo para minimizar o erro global.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos do Método dos Resíduos Ponderados",
                                  "subSteps": [
                                    "Leia a definição do método dos resíduos ponderados como uma técnica numérica para resolver equações diferenciais aproximando a solução e minimizando resíduos ponderados.",
                                    "Identifique os componentes principais: função exata, aproximação trial, resíduo e funções de ponderação.",
                                    "Estude a fórmula geral: ∫ w(x) * R(x) dΩ = 0, onde R é o resíduo.",
                                    "Anote exemplos de aplicações em engenharia civil, como análise de vigas ou placas.",
                                    "Resuma em um diagrama as etapas do método."
                                  ],
                                  "verification": "Crie um fluxograma do método e explique verbalmente para um colega.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de métodos numéricos (ex: Zienkiewicz), vídeo introdutório no YouTube sobre Weighted Residual Methods.",
                                  "tips": "Comece pelo método de Galerkin como caso especial para fixar ideias.",
                                  "learningObjective": "Compreender o framework geral onde funções de peso operam.",
                                  "commonMistakes": "Confundir resíduos ponderados com mínimos quadrados sem ponderação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Funções de Aproximação (Trial Functions)",
                                  "subSteps": [
                                    "Defina funções de aproximação como bases polinomiais ou funções de forma que representam a solução aproximada u_h(x) = ∑ c_i φ_i(x).",
                                    "Estude exemplos: funções lineares φ(x) = x em [0,1], ou hermitianas em elementos finitos.",
                                    "Calcule um resíduo simples: para -u''=1 em [0,1], u_h= x(1-x)/2, R = 1 - u_h''.",
                                    "Discuta como φ_i são escolhidas para satisfazer condições de contorno essenciais.",
                                    "Compare com métodos espectrais onde φ são trigonométricas."
                                  ],
                                  "verification": "Derive o resíduo para uma aproximação linear simples e plote-o.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software como MATLAB ou Python (NumPy/Matplotlib) para plotar funções, notas de aula.",
                                  "tips": "Visualize funções graficamente para intuitivamente ver sua suavidade.",
                                  "learningObjective": "Distinguir funções usadas para aproximar a solução dos resíduos.",
                                  "commonMistakes": "Achar que funções de aproximação já ponderam resíduos (elas não)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Funções de Peso e Seu Papel Principal",
                                  "subSteps": [
                                    "Defina funções de peso w_j(x) como funções test que multiplicam o resíduo para formar equações fracas: ∫ w_j R dΩ = 0.",
                                    "Explique seu propósito: ponderar regiões do domínio onde o resíduo é mais crítico, minimizando erro global.",
                                    "Estude casos: w_j = δ (collocation), w_j = 1 (least squares), w_j = φ_j (Galerkin).",
                                    "Calcule um exemplo: para o problema anterior, w=1 leva a erro médio zero.",
                                    "Anote: funções de peso controlam a distribuição do erro."
                                  ],
                                  "verification": "Escreva a definição em suas palavras e dê 3 exemplos de funções de peso.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Artigo ou capítulo sobre métodos de resíduos ponderados, caderno para cálculos.",
                                  "tips": "Pense em w_j como 'lentes' focando no erro onde importa mais.",
                                  "learningObjective": "Identificar precisamente o que são funções de peso e sua função de ponderação.",
                                  "commonMistakes": "Confundir com funções de aproximação, achando que são a mesma coisa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Funções de Peso de Aproximação e Analisar Minimização de Erro",
                                  "subSteps": [
                                    "Compare: φ_i aproximam u (espaço trial), w_j testam R (espaço de teste).",
                                    "Em Galerkin, φ_i = w_i; em outros, não (ex: Petrov-Galerkin).",
                                    "Simule numericamente: resolva -u''=1 com diferentes w e compare erros L2 e L∞.",
                                    "Discuta como ponderação minimiza erro global: w alta onde erro potencial é alto.",
                                    "Conclua com tabela de diferenças: propósito, escolha, impacto no erro."
                                  ],
                                  "verification": "Preencha uma tabela comparativa e discuta impactos em um problema de viga.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB/Python script pronto para simulação, tabela em Excel.",
                                  "tips": "Use códigos open-source de elementos finitos para testar variações.",
                                  "learningObjective": "Diferenciar claramente e explicar minimização de erro global.",
                                  "commonMistakes": "Ignorar que em métodos não-Galerkin w ≠ φ, levando a confusão."
                                }
                              ],
                              "practicalExample": "Em análise de uma viga em flexão (EI u'''' = q), aproxime u_h com funções cúbicas φ_i. Calcule resíduo R, aplique w_j = φ_j (Galerkin) para montar matriz de rigidez, resolvendo para coeficientes que minimizam ∫ φ_j R dx = 0, simulando deslocamentos reais com erro ponderado mínimo.",
                              "finalVerifications": [
                                "Defina funções de peso em uma frase precisa.",
                                "Diferencie de funções de aproximação com um exemplo.",
                                "Explique como ponderam resíduo para minimizar erro global.",
                                "Identifique 2 métodos onde w ≠ φ.",
                                "Calcule ∫ w R dx para um caso simples e verifique =0."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: menciona ponderação de resíduo e minimização global (peso 30%).",
                                "Diferenciação clara de funções de aproximação (peso 25%).",
                                "Exemplos corretos e contexto de engenharia civil (peso 20%).",
                                "Compreensão matemática via fórmula ou simulação (peso 15%).",
                                "Aplicação a cenários reais sem confusões comuns (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica e métodos variationais.",
                                "Física: Mecânica estrutural e princípios de equilíbrio.",
                                "Computação: Implementação em FEM software como ANSYS ou FEniCS.",
                                "Estatística: Conceitos de mínimos quadrados ponderados."
                              ],
                              "realWorldApplication": "Na análise de estruturas civis como pontes ou edifícios via elementos finitos, funções de peso no método dos resíduos ponderados (base do FEM) permitem modelar comportamentos complexos com precisão, otimizando projetos para resistir a cargas reais minimizando erros de previsão de deformações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Reconhecer o propósito em problemas de valor inicial e de contorno",
                            "description": "Aplicar o conceito de funções de peso a problemas de valor inicial e de contorno em engenharia civil, como equações diferenciais em vigas ou difusão de calor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Problemas de Valor Inicial (IVP) e de Contorno (BVP)",
                                  "subSteps": [
                                    "Defina IVP como problemas onde condições iniciais são dadas, como posição e velocidade inicial em vibrações de vigas.",
                                    "Defina BVP como problemas com condições em limites espaciais, como deflexões fixas nas extremidades de uma viga.",
                                    "Identifique exemplos em engenharia civil: IVP em difusão de calor transitória; BVP em equações de equilíbrio estático de vigas.",
                                    "Compare diferenças: IVP foca no tempo inicial; BVP em fronteiras espaciais.",
                                    "Revise equações diferenciais ordinárias (EDO) e parciais (EDP) comuns nesses contextos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre IVP e BVP com um exemplo de viga.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de EDO/EDP, vídeo introdutório sobre IVP/BVP (ex: Khan Academy), caderno para anotações.",
                                  "tips": "Use diagramas para visualizar condições de contorno em vigas.",
                                  "learningObjective": "Diferenciar IVP e BVP e identificá-los em contextos de engenharia civil.",
                                  "commonMistakes": "Confundir condições iniciais com de contorno; ignorar o domínio (tempo vs. espaço)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Método dos Resíduos Ponderados e o Conceito de Resíduos",
                                  "subSteps": [
                                    "Explique o método: aproxima soluções exatas de EDP/EDO minimizando resíduos (diferença entre equação exata e aproximada).",
                                    "Defina resíduo R como R = L(u) - f, onde u é aproximação, L operador diferencial, f termo fonte.",
                                    "Discuta por que resíduos não são zero em aproximações numéricas, como em elementos finitos.",
                                    "Apresente funções de peso w_i: multiplicam o resíduo para formar integrais ponderadas.",
                                    "Mostre a forma geral: ∫ w_i R dΩ = 0 para i=1 a n."
                                  ],
                                  "verification": "Esboce a equação do resíduo ponderado para uma EDO simples e identifique w_i.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python para plotar resíduos, slides ou PDF sobre método dos resíduos ponderados.",
                                  "tips": "Comece com métodos simples como Collocation (w_i = delta) antes de pesos gerais.",
                                  "learningObjective": "Entender resíduos e como funções de peso os minimizam em aproximações.",
                                  "commonMistakes": "Achar que resíduo zero significa solução exata; confundir com método de Galerkin."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer o Propósito das Funções de Peso em IVP e BVP",
                                  "subSteps": [
                                    "Em IVP: funções de peso enforce condições iniciais, como Dirac delta para condições puntuales em tempo.",
                                    "Em BVP: pesos incorporam condições de contorno essenciais/naturais, ex: pesos que decayem perto de limites fixos em vigas.",
                                    "Discuta propósitos: melhorar convergência, satisfazer condições de contorno automaticamente, aumentar precisão local.",
                                    "Exemplo: em viga de Euler-Bernoulli, pesos ajudam a ponderar resíduos perto de suportes.",
                                    "Compare métodos: Least Squares (w=1), Galerkin (w=funções base), Subdomain."
                                  ],
                                  "verification": "Identifique em um diagrama de viga como pesos ponderam resíduos em contornos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Artigo acadêmico sobre Weighted Residuals em engenharia estrutural, simulador online de EDPs.",
                                  "tips": "Visualize pesos como 'importância' dada a regiões do domínio.",
                                  "learningObjective": "Reconhecer como funções de peso garantem satisfação de condições IVP/BVP.",
                                  "commonMistakes": "Ignorar que pesos diferentes levam a métodos distintos; superestimar universalidade de um tipo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Exemplos de Engenharia Civil",
                                  "subSteps": [
                                    "Exemplo IVP: difusão de calor em fundação; use peso delta para condição inicial de temperatura.",
                                    "Exemplo BVP: viga sob carga uniforme; pesos lineares para condições de apoio simply supported.",
                                    "Implemente numericamente uma aproximação simples com 2-3 termos.",
                                    "Analise como mudança de pesos afeta precisão nos contornos.",
                                    "Discuta limitações: escolha de pesos impacta estabilidade em problemas não-lineares."
                                  ],
                                  "verification": "Resolva um BVP simples de viga e verifique resíduos ponderados próximos a zero nos limites.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB ou Python (SciPy para solvers), dados de exemplo de viga (comprimento L=10m, EI=constante).",
                                  "tips": "Teste com poucos graus de liberdade para ver impacto dos pesos.",
                                  "learningObjective": "Aplicar reconhecimento do propósito em cenários reais de engenharia civil.",
                                  "commonMistakes": "Não normalizar pesos; ignorar unidades em integrais."
                                }
                              ],
                              "practicalExample": "Em uma viga de concreto simply supported (BVP) sob carga distribuída q(x), use funções de peso lineares w1=1-x/L e w2=x/L para ponderar o resíduo da equação EI u'''' - q = 0, garantindo deflexão zero nas extremidades x=0 e x=L, resultando em aproximação cúbica precisa para deflexões máximas.",
                              "finalVerifications": [
                                "Explique o papel das funções de peso em enforce condições de contorno em uma viga.",
                                "Identifique se um problema de difusão de calor em uma parede é IVP ou BVP e sugira pesos adequados.",
                                "Diferencie propósitos de pesos em Galerkin vs. Collocation para IVP.",
                                "Verifique numericamente se resíduos ponderados são mínimos em limites.",
                                "Descreva como pesos melhoram precisão em aproximações polinomiais.",
                                "Compare solução com pesos vs. sem em um exemplo simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre IVP e BVP (80% acerto em exemplos).",
                                "Correta formulação de integrais de resíduos ponderados (sem erros sintáticos).",
                                "Identificação correta do propósito de pesos em contextos civis (ex: vigas, calor).",
                                "Análise qualitativa/quantitativa de impacto de pesos na solução.",
                                "Criatividade em sugestões de pesos para problemas não padronizados.",
                                "Clareza em explicações e diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais e métodos numéricos (Galerkin, elementos finitos).",
                                "Física: Mecânica estrutural e transferência de calor.",
                                "Programação: Implementação em Python/MATLAB para solvers de EDP.",
                                "Engenharia Mecânica: Vibrações e dinâmica (IVPs em sistemas transitórios).",
                                "Ciências Computacionais: Otimização e minimização de resíduos."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios, engenheiros usam funções de peso no software de elementos finitos (ex: ANSYS) para modelar deflexões de vigas com condições de contorno reais, prevendo falhas e otimizando designs contra cargas sísmicas ou térmicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Diferenciar funções de peso de funções de aproximação",
                            "description": "Comparar funções de peso com funções de aproximação (como polinômios ou funções de Galerkin), explicando como as primeiras garantem a integração ponderada do resíduo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Método dos Resíduos Ponderados (MRP)",
                                  "subSteps": [
                                    "Estude a definição do MRP: minimizar o resíduo integral ponderado para aproximar soluções de EDOs ou EDPs.",
                                    "Identifique a equação geral: ∫ w(x) R(u) dΩ = 0, onde w(x) é a função de peso e R(u) é o resíduo.",
                                    "Revise tipos de MRP: Galerkin (w = funções de aproximação), Collocation, Subdomínios e Least Squares.",
                                    "Anote as vantagens do MRP em problemas da engenharia civil, como análise estrutural.",
                                    "Desenhe um diagrama esquemático do processo MRP."
                                  ],
                                  "verification": "Capacidade de explicar verbalmente ou por escrito a equação geral do MRP e listar 3 tipos principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de métodos numéricos (ex: Chapra), notas de aula, quadro branco.",
                                  "tips": "Comece com exemplos simples de EDOs para visualizar o resíduo.",
                                  "learningObjective": "Compreender o papel central do resíduo ponderado no MRP.",
                                  "commonMistakes": "Confundir MRP com Método dos Elementos Finitos (MEF); lembrar que MRP é precursor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Funções de Aproximação",
                                  "subSteps": [
                                    "Defina funções de aproximação: base para representar a solução aproximada u_h(x) = Σ c_i φ_i(x), como polinômios ou funções de Galerkin.",
                                    "Estude propriedades: completude, continuidade e capacidade de representar soluções exatas no limite.",
                                    "Examine exemplos: polinômios lineares/quadráticos em 1D, funções hat em Galerkin.",
                                    "Calcule uma aproximação simples para u'' + u = 0 em [0,1] usando 2 polinômios.",
                                    "Registre como elas definem o espaço de soluções trial."
                                  ],
                                  "verification": "Derivar manualmente u_h(x) para um problema simples e plotar as funções base.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Matlab/Python/Mathematica), papel e lápis para cálculos.",
                                  "tips": "Use funções ortogonais para melhor convergência; visualize graficamente.",
                                  "learningObjective": "Dominar o papel das funções de aproximação na expansão da solução.",
                                  "commonMistakes": "Escolher bases não completas, levando a soluções imprecisas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Funções de Peso",
                                  "subSteps": [
                                    "Defina funções de peso: w_i(x) usadas para ponderar o resíduo, formando equações ∫ w_i R(u_h) dΩ = 0.",
                                    "Compare com funções de aproximação: em Galerkin, w_i = φ_i; em outros métodos, diferem.",
                                    "Estude propósitos: garantir estabilidade, precisão local ou integração exata.",
                                    "Implemente pesos constantes (Subdomínios) vs. delta (Collocation) em um exemplo.",
                                    "Calcule o impacto de diferentes w(x) no resíduo para o mesmo problema do Step 2."
                                  ],
                                  "verification": "Mostrar matematicamente como pesos alteram as equações do sistema.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora simbólica (SymPy/Wolfram), exemplos numéricos prontos.",
                                  "tips": "Pondere mais onde o resíduo é maior para melhor precisão.",
                                  "learningObjective": "Entender como pesos controlam a minimização do resíduo.",
                                  "commonMistakes": "Achar que pesos sempre iguais às aproximações; testar métodos não-Galerkin."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e Comparar as Duas Funções",
                                  "subSteps": [
                                    "Liste diferenças chave: aproximações definem u_h; pesos testam o resíduo.",
                                    "Crie tabela comparativa: propósito, escolha típica, impacto na matriz rígida.",
                                    "Aplique em exemplo: resolva -u''=1 em [0,1] com Galerkin (w=φ) vs. Collocation (w=delta).",
                                    "Analise resultados: convergência, precisão e estabilidade.",
                                    "Discuta quando usar cada configuração no contexto de engenharia civil."
                                  ],
                                  "verification": "Produzir tabela e gráficos comparando soluções com diferentes escolhas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha ou código Python para simulação, gráficos comparativos.",
                                  "tips": "Use casos onde Galerkin falha (oscilações) para destacar pesos especializados.",
                                  "learningObjective": "Diferenciar claramente os papéis e impactos distintos.",
                                  "commonMistakes": "Ignorar que em Galerkin elas coincidem, mas conceitualmente diferem."
                                }
                              ],
                              "practicalExample": "Em análise de vigas (engenharia civil), para resolver d²v/dx² = M(x)/EI, use funções de aproximação polinomiais para v_h(x), mas funções de peso delta em pontos de interesse (suportes) para precisão local em reações.",
                              "finalVerifications": [
                                "Explicar a equação MRP com pesos e aproximações distintas.",
                                "Identificar corretamente funções de peso vs. aproximação em um código fornecido.",
                                "Comparar soluções numéricas de Galerkin vs. outro MRP.",
                                "Listar 3 cenários onde pesos ≠ aproximações melhoram resultados.",
                                "Derivar sistema de equações para um problema 1D simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara entre papéis (80% peso).",
                                "Exemplos matemáticos corretos e cálculos sem erros.",
                                "Análise qualitativa/quantitativa de impactos na solução.",
                                "Uso apropriado de terminologia técnica (resíduo ponderado, trial/test functions).",
                                "Criatividade em aplicações reais de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Integração numérica para avaliação de resíduos.",
                                "Programação: Implementação em Python/Matlab para automação.",
                                "Física/Engenharia Mecânica: Modelagem de EDPs em estruturas.",
                                "Estatística: Análise de erro e convergência de métodos."
                              ],
                              "realWorldApplication": "Na simulação de estruturas civis via MEF (extensão do MRP), funções de peso adaptativas melhoram precisão em regiões críticas como juntas ou cargas concentradas, otimizando projetos de pontes e edifícios contra falhas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Critérios de Escolha das Funções de Peso",
                        "description": "Critérios baseados em simplicidade computacional, condicionamento numérico e propriedades de ortogonalidade para selecionar funções de peso adequadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Avaliar critérios de simplicidade e eficiência computacional",
                            "description": "Analisar como escolher funções de peso simples (ex: constantes) para reduzir complexidade em implementações numéricas, considerando o condicionamento da matriz de Gram.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de simplicidade e eficiência computacional",
                                  "subSteps": [
                                    "Definir simplicidade como o uso de funções com poucos parâmetros e cálculos diretos.",
                                    "Explicar eficiência computacional como minimização de operações aritméticas e iterações.",
                                    "Identificar métricas chave: tempo de execução, uso de memória e estabilidade numérica.",
                                    "Relacionar com métodos numéricos em engenharia civil, como resíduos ponderados.",
                                    "Discutir trade-offs entre simplicidade e precisão."
                                  ],
                                  "verification": "Resumir em 3 frases os conceitos e fornecer exemplos de funções complexas vs. simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de métodos numéricos (ex: Burden & Faires)",
                                    "Notebook para anotações",
                                    "Artigo sobre complexidade computacional"
                                  ],
                                  "tips": "Use analogias cotidianas, como comparar uma calculadora simples a um supercomputador.",
                                  "learningObjective": "Entender as bases teóricas para avaliar simplicidade e eficiência.",
                                  "commonMistakes": "Confundir simplicidade com baixa precisão; ignorar custo computacional em larga escala."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar funções de peso simples, como constantes",
                                  "subSteps": [
                                    "Descrever funções de peso constantes (w_i = c) e sua implementação.",
                                    "Calcular manualmente o impacto em uma equação de resíduos ponderados simples.",
                                    "Comparar com funções lineares ou quadráticas em termos de operações por iteração.",
                                    "Implementar um exemplo básico em Python ou MATLAB para medir tempo.",
                                    "Verificar redução de complexidade algorítmica (O(n) vs. O(n^2))."
                                  ],
                                  "verification": "Executar código que demonstre tempo de execução 20% menor com constantes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ambiente de programação (Python/MATLAB)",
                                    "Exemplo de código de resíduos ponderados",
                                    "Cronômetro para benchmarks"
                                  ],
                                  "tips": "Comece com vetores pequenos (n=10) e escale para n=1000 para ver diferenças.",
                                  "learningObjective": "Dominar a escolha e implementação de funções simples.",
                                  "commonMistakes": "Esquecer normalização da constante; assumir eficiência sem benchmark."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar o condicionamento da matriz de Gram",
                                  "subSteps": [
                                    "Explicar o que é a matriz de Gram (G = A^T W A, onde W é diagonal de pesos).",
                                    "Calcular o número de condicionamento (cond(G) = ||G|| * ||G^{-1}||).",
                                    "Simular impacto de pesos constantes vs. variáveis no cond(G).",
                                    "Usar SVD ou eigenvalores para medir ill-conditioning.",
                                    "Discutir como pesos simples melhoram estabilidade numérica."
                                  ],
                                  "verification": "Gerar matrizes e calcular cond(G) < 10^6 para pesos constantes.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Biblioteca NumPy/SciPy",
                                    "Documentação sobre SVD",
                                    "Planilha Excel para cálculos manuais"
                                  ],
                                  "tips": "Monitore eigenvalores extremos; evite matrizes singulares nos testes.",
                                  "learningObjective": "Analisar estabilidade numérica influenciada por funções de peso.",
                                  "commonMistakes": "Ignorar simetria positiva definida; usar normas inadequadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar critérios e realizar avaliação comparativa",
                                  "subSteps": [
                                    "Definir critérios quantitativos: tempo, cond(G), precisão residual.",
                                    "Comparar cenários: constantes vs. outras funções em problema real.",
                                    "Documentar trade-offs em tabela (simplicidade, eficiência, condicionamento).",
                                    "Recomendar escolha baseada em contexto (ex: simulações rápidas).",
                                    "Testar sensibilidade a ruído numérico."
                                  ],
                                  "verification": "Produzir relatório com gráficos de comparação e recomendação justificada.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Software de plotagem (Matplotlib)",
                                    "Dados de benchmark",
                                    "Template de relatório"
                                  ],
                                  "tips": "Priorize métricas ponderadas; valide com literatura.",
                                  "learningObjective": "Aplicar critérios de forma holística para decisões informadas.",
                                  "commonMistakes": "Superestimar ganhos sem validação; negligenciar escalabilidade."
                                }
                              ],
                              "practicalExample": "Em uma análise de pórtico estrutural usando método dos resíduos ponderados, implemente pesos constantes (w=1) para resolver o sistema Ax=b. Meça tempo de convergência e cond(G), comparando com pesos quadráticos baseados em resíduos, demonstrando redução de 40% no tempo e cond(G) de 10^8 para 10^5.",
                              "finalVerifications": [
                                "Explicar verbalmente por que constantes reduzem complexidade O(n).",
                                "Calcular cond(G) corretamente para dois cenários.",
                                "Identificar quando simplicidade prevalece sobre precisão.",
                                "Benchmarkar código com variação de n=100 a 10k.",
                                "Recomendar função para problema específico de engenharia civil.",
                                "Discutir limitações em matrizes mal-condicionadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de métricas de simplicidade e eficiência (80%).",
                                "Correta análise de impacto no cond(G) com cálculos validados (90%).",
                                "Uso de benchmarks quantitativos em exemplos (85%).",
                                "Integração holística de trade-offs em recomendação (95%).",
                                "Clareza em relatórios e visualizações (80%).",
                                "Aplicação contextual a problemas de engenharia civil (90%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Análise de eigenvalores e SVD.",
                                "Programação Computacional: Otimização de algoritmos e profiling.",
                                "Matemática Numérica: Estabilidade e erro de arredondamento.",
                                "Engenharia de Software: Trade-offs de design em simulações."
                              ],
                              "realWorldApplication": "Em simulações de estruturas civis (ex: pontes sob carga dinâmica), usar pesos constantes acelera iterações em software como ANSYS ou códigos customizados, reduzindo tempo de projeto de horas para minutos, mantendo precisão aceitável e evitando crashes por ill-conditioning em grandes malhas finitas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Considerar o impacto no condicionamento numérico",
                            "description": "Explicar a relação entre funções de peso, autovalores da matriz de Gram e estabilidade numérica em soluções computacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do Condicionamento Numérico",
                                  "subSteps": [
                                    "Defina o número de condicionamento de uma matriz A como κ(A) = ||A|| * ||A⁻¹||.",
                                    "Explique como valores altos de κ indicam sensibilidade a perturbações numéricas.",
                                    "Discuta o papel dos autovalores na decomposição SVD e no cálculo de κ.",
                                    "Calcule κ para matrizes diagonais simples usando software.",
                                    "Analise exemplos de matrizes mal-condicionadas em problemas de engenharia."
                                  ],
                                  "verification": "Resolva um sistema linear com ruído e compare soluções exata e aproximada; verifique se κ > 10¹² indica instabilidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro 'Numerical Linear Algebra' de Trefethen; MATLAB ou Python (NumPy/SciPy); planilha com exemplos de matrizes.",
                                  "tips": "Sempre normalize as matrizes antes de calcular κ para comparações justas.",
                                  "learningObjective": "Compreender como o condicionamento afeta a precisão de soluções computacionais.",
                                  "commonMistakes": "Confundir κ com determinante; ignorar normas adequadas (use norma 2 para autovalores)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Funções de Peso e a Matriz de Gram",
                                  "subSteps": [
                                    "Defina funções de peso w(x) no Método dos Resíduos Ponderados (MRP).",
                                    "Construa a matriz de Gram G = ∫ w(x) φ_i(x) φ_j(x) dx para bases φ.",
                                    "Implemente integração numérica para calcular G com diferentes w(x) (ex: w=1, w=1/x).",
                                    "Visualize G para funções polinomiais de grau baixo.",
                                    "Compare G para pesos uniformes vs. não-uniformes."
                                  ],
                                  "verification": "Gere G para dois pesos diferentes e confirme simetria positiva definida via autovalores positivos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software MATLAB/Python com quadgk/quad; documentação de MRP em Engenharia Civil.",
                                  "tips": "Use Gauss-Lobatto para integração exata em polinômios.",
                                  "learningObjective": "Relacionar funções de peso à estrutura da matriz de Gram no MRP.",
                                  "commonMistakes": "Esquecer normalização L2 das bases φ; usar integração trapezoidal imprecisa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Autovalores da Matriz de Gram e Condicionamento",
                                  "subSteps": [
                                    "Calcule autovalores λ de G para várias w(x).",
                                    "Compute κ(G) = λ_max / λ_min e observe variação com w.",
                                    "Estude o espectro de autovalores: razão condição vs. suavidade de w.",
                                    "Simule perturbações em G e meça erro em soluções de sistemas Gα = b.",
                                    "Grafique κ(G) vs. parâmetro de peso (ex: expoente em w(x)=x^α)."
                                  ],
                                  "verification": "Para w mal escolhida, demonstre que ||x_exata - x_num|| / ||x_exata|| > 10^{-6} apesar de precisão máquina.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Eigen solvers em MATLAB (eig) ou Python (scipy.linalg.eig); scripts Jupyter para plots.",
                                  "tips": "Ordene autovalores decrescentemente para identificar λ_min rapidamente.",
                                  "learningObjective": "Quantificar como w afeta o espectro de G e κ(G).",
                                  "commonMistakes": "Não verificar diagonal dominância; confundir autovalores de G com os de A original."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Impacto na Estabilidade Numérica e Critérios de Escolha",
                                  "subSteps": [
                                    "Explique estabilidade: soluções MRP estáveis se κ(G) baixo.",
                                    "Defina critérios: escolher w minimizando κ(G) ou maximizando λ_min.",
                                    "Teste em problema real: aproximação de solução exata em viga (Eng. Civil).",
                                    "Compare estabilidade para w=1, w=1/√x, w adaptativa.",
                                    "Documente trade-offs: precisão local vs. global."
                                  ],
                                  "verification": "Em simulação de MRP para equação diferencial, confirme convergência sem oscilações para w ótima.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Código MRP pronto (GitHub repositórios de FEM); problemas benchmark de Engenharia Civil.",
                                  "tips": "Use pré-condicionadores se κ alto para testes.",
                                  "learningObjective": "Aplicar análise para selecionar w otimizando estabilidade.",
                                  "commonMistakes": "Ignorar custo computacional de w complexas; superestimar impacto sem testes numéricos."
                                }
                              ],
                              "practicalExample": "Em análise de uma viga cantilever com carga distribuída, use MRP com bases polinomiais. Para w(x)=1, κ(G)=10^5 leva a oscilações na solução; mude para w(x)=(1-x/L)^2, reduz κ para 10^2, estabilizando a aproximação numérica.",
                              "finalVerifications": [
                                "Calcule κ(G) para 3 funções de peso e explique qual é melhor.",
                                "Simule MRP com ruído gaussiano e meça erro relativo <10^{-8}.",
                                "Identifique autovalor mínimo e justifique impacto na estabilidade.",
                                "Compare soluções analítica vs. numérica para problema 1D.",
                                "Discuta em relatório por que w não-uniforme melhora condicionamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de κ e relação com autovalores (80% correto).",
                                "Cálculos numéricos exatos com evidência de código/execução.",
                                "Análise qualitativa clara ligando w, G, κ e estabilidade.",
                                "Uso apropriado de exemplos reais de Eng. Civil.",
                                "Identificação de pelo menos 2 critérios práticos de escolha de w.",
                                "Ausência de erros comuns como confusão de normas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição espectral e SVD.",
                                "Computação Científica: Análise de erros e estabilidade de algoritmos.",
                                "Engenharia Computacional: Pré-condicionamento em FEM.",
                                "Matemática Aplicada: Análise funcional e espaços de Sobolev."
                              ],
                              "realWorldApplication": "Na simulação de estruturas civis via Elementos Finitos Ponderados, escolher w otimizando κ(G) previne falhas numéricas em projetos de pontes longas, reduzindo erros de 20% em predições de deformação e economizando iterações computacionais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Selecionar funções baseadas em ortogonalidade",
                            "description": "Identificar funções de peso que promovam ortogonalidade no espaço funcional, como funções de Legendre ou Chebyshev, para otimizar a convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de ortogonalidade em espaços funcionais",
                                  "subSteps": [
                                    "Defina o produto interno em espaços funcionais e sua relação com ortogonalidade.",
                                    "Explique por que a ortogonalidade minimiza interações entre funções base, acelerando a convergência.",
                                    "Revise o papel das funções de peso no Método dos Resíduos Ponderados (MRP).",
                                    "Identifique condições matemáticas para ortogonalidade: ∫ w_i(x) w_j(x) φ(x) dx = 0 para i ≠ j.",
                                    "Discuta impacto na convergência de soluções aproximadas em problemas de Engenharia Civil."
                                  ],
                                  "verification": "Resuma em 3 frases o que é ortogonalidade e sua importância no MRP; confira com referência padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de métodos numéricos (ex: 'Métodos Numéricos' de Chapra), papel e lápis, calculadora.",
                                  "tips": "Use analogia com vetores ortogonais em R^n para visualizar melhor.",
                                  "learningObjective": "Dominar a definição e benefícios da ortogonalidade funcional no contexto do MRP.",
                                  "commonMistakes": "Confundir ortogonalidade com independência linear; ignorar o papel da função de peso."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar funções de Legendre e suas propriedades ortogonais",
                                  "subSteps": [
                                    "Derive ou memorize os polinômios de Legendre até ordem 3-4.",
                                    "Verifique ortogonalidade com peso w(x)=1 no intervalo [-1,1]: ∫ P_m(x) P_n(x) dx = 0 (m≠n).",
                                    "Aplique em MRP: use como funções de peso para aproximar soluções de EDOs.",
                                    "Calcule coeficientes de expansão para uma função teste simples.",
                                    "Analise convergência em problemas de contorno comuns em estruturas."
                                  ],
                                  "verification": "Compute manualmente a integral de ortogonalidade para P1 e P2; resultado deve ser zero.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabelas de polinômios de Legendre, software como MATLAB ou Python (SymPy), quadro branco.",
                                  "tips": "Comece com baixas ordens para construir intuição antes de generalizar.",
                                  "learningObjective": "Aplicar funções de Legendre como pesos ortogonais em MRP para otimizar convergência.",
                                  "commonMistakes": "Esquecer normalização; usar intervalo errado (deve ser [-1,1])."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar funções de Chebyshev e critérios de seleção",
                                  "subSteps": [
                                    "Revise polinômios de Chebyshev do primeiro e segundo tipo com peso w(x)=1/√(1-x²).",
                                    "Compare com Legendre: Chebyshev minimiza erro máximo (útil para convergência uniforme).",
                                    "Defina critérios de escolha: Legendre para erro L2, Chebyshev para erro máximo em Engenharia Civil.",
                                    "Selecione função baseada no problema: ex. Chebyshev para tensões em vigas com variações extremas.",
                                    "Implemente numéricamente a integral de ortogonalidade para validação."
                                  ],
                                  "verification": "Escolha corretamente Legendre vs Chebyshev para um problema dado e justifique em parágrafo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software numérico (MATLAB/Python), tabelas de Chebyshev, exemplos de problemas estruturais.",
                                  "tips": "Visualize graficamente as funções para entender oscilações de Chebyshev.",
                                  "learningObjective": "Discernir e selecionar funções de peso ortogonais baseadas em normas de erro.",
                                  "commonMistakes": "Ignorar o peso específico de Chebyshev; superestimar convergência sem testar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar seleção de funções em um problema prático e analisar convergência",
                                  "subSteps": [
                                    "Escolha um problema simples: aproximação de deflexão em viga cantilever via MRP.",
                                    "Implemente MRP com Legendre e Chebyshev como pesos; compare resíduos.",
                                    "Meça taxa de convergência plotando erro vs número de termos.",
                                    "Otimize escolha: selecione a que converge mais rápido para o caso.",
                                    "Documente trade-offs: precisão vs custo computacional."
                                  ],
                                  "verification": "Gere gráfico de convergência mostrando superioridade da escolha ortogonal; erro <5%.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/Python/SciPy, dados do problema (equação de Euler-Bernoulli), computador.",
                                  "tips": "Use quadratura numérica para integrais se analítico for complexo.",
                                  "learningObjective": "Integrar seleção de funções ortogonais para otimizar soluções numéricas em Engenharia Civil.",
                                  "commonMistakes": "Não normalizar funções; escolher função errada sem justificar norma de erro."
                                }
                              ],
                              "practicalExample": "Em análise de viga cantilever sob carga uniforme, use MRP com funções de Legendre como pesos para aproximar a deflexão y(x). Com 4 termos, o erro L2 cai 70% vs funções não-ortogonais, permitindo simulação eficiente de colapsos estruturais.",
                              "finalVerifications": [
                                "Defina ortogonalidade e cite 2 exemplos de funções de peso.",
                                "Compute integral de ortogonalidade para Legendre P1-P2.",
                                "Selecione corretamente Chebyshev para problema com erro máximo crítico.",
                                "Compare convergência em código numérico com gráfico.",
                                "Explique otimização em contexto de Engenharia Civil.",
                                "Identifique 3 critérios para escolha de funções ortogonais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ortogonalidade (90% correto).",
                                "Cálculos de integrais sem erros (>95% exatidão).",
                                "Justificativa lógica para seleção de funções (clara e baseada em normas).",
                                "Análise de convergência com evidências numéricas/gráficas.",
                                "Aplicação correta em exemplo prático de viga.",
                                "Identificação de erros comuns e avoidance."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Funcional e Polinômios Ortogonais.",
                                "Física: Mecânica Estrutural e Equações Diferenciais.",
                                "Computação: Métodos Numéricos e Programação Científica (MATLAB/Python).",
                                "Engenharia: Análise de Elementos Finitos (pré-requisito para FEM)."
                              ],
                              "realWorldApplication": "Na simulação de estruturas civis como pontes ou edifícios, selecionar funções de Chebyshev em MRP otimiza convergência em software de análise, reduzindo tempo de computação em 50% para predizer falhas sob cargas dinâmicas, essencial para projetos sísmicos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Garantia de Ortogonalidade e Aplicações Práticas",
                        "description": "Uso das funções de peso para assegurar que os resíduos ponderados sejam ortogonais, levando a sistemas lineares bem condicionados em contextos de engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Verificar ortogonalidade no espaço funcional",
                            "description": "Demonstrar matematicamente como as funções de peso garantem a ortogonalidade dos resíduos via produto interno no espaço funcional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de espaços funcionais e produto interno",
                                  "subSteps": [
                                    "Definir espaço funcional como um conjunto de funções equipado com operações de soma e multiplicação por escalar.",
                                    "Explicar o produto interno em espaços funcionais: <f, g> = ∫_Ω f(x) g(x) w(x) dx, onde w(x) é uma função de peso.",
                                    "Discutir ortogonalidade: duas funções f e g são ortogonais se <f, g> = 0.",
                                    "Relacionar com vetores em espaços euclidianos para analogia intuitiva.",
                                    "Identificar o papel das funções de peso na definição do produto interno."
                                  ],
                                  "verification": "Escrever as definições de produto interno e ortogonalidade em um caderno e confirmar com uma referência bibliográfica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de métodos numéricos (ex: Zienkiewicz), caderno, acesso à internet para fórmulas.",
                                  "tips": "Pense em funções como 'vetores infinitos' para visualizar melhor a ortogonalidade.",
                                  "learningObjective": "Compreender a estrutura matemática de espaços funcionais e a noção de ortogonalidade via produto interno.",
                                  "commonMistakes": "Confundir produto interno funcional com multiplicação pontual de funções; ignorar a função de peso w(x)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o problema no Método dos Resíduos Ponderados",
                                  "subSteps": [
                                    "Estabelecer a equação diferencial modelo: L[u] = f em domínio Ω, com condições de contorno.",
                                    "Introduzir aproximação trial: u_h(x) = ∑_{i=1}^N a_i φ_i(x), onde φ_i são funções base.",
                                    "Calcular o resíduo: R(x) = L[u_h] - f(x).",
                                    "Definir funções de peso w_j(x), j=1 a N.",
                                    "Explicar a essência do método: minimizar o resíduo de forma ponderada."
                                  ],
                                  "verification": "Esboçar a fórmula do resíduo R(x) para uma equação simples e listar 3 funções de peso comuns (ex: Galerkin, collocation).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Caderno, lápis, software simbólico como Mathematica ou SymPy (opcional).",
                                  "tips": "Use uma equação simples como -u'' = 1 para praticar o cálculo do resíduo.",
                                  "learningObjective": "Formular matematicamente o resíduo no contexto do método dos resíduos ponderados.",
                                  "commonMistakes": "Esquecer condições de contorno na definição de u_h; confundir funções trial com funções de teste."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar a garantia de ortogonalidade via funções de peso",
                                  "subSteps": [
                                    "Estabelecer a condição do método: ∫_Ω R(x) w_j(x) dx = 0 para j=1 a N.",
                                    "Mostrar que isso equivale a <R, w_j> = 0, ou seja, R é ortogonal a cada w_j no produto interno.",
                                    "Derivar o sistema algébrico: ∑_i a_i ∫_Ω L[φ_i] w_j dx = ∫_Ω f w_j dx.",
                                    "Explicar como as w_j spanam um subespaço, garantindo ortogonalidade no espaço funcional relevante.",
                                    "Discutir casos especiais: Galerkin (w_j = φ_j) leva a simetria."
                                  ],
                                  "verification": "Derivar explicitamente a condição <R, w_j> = 0 e reescrever como equação matricial.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Caderno com régua para integrais, calculadora simbólica ou papel quadriculado.",
                                  "tips": "Integre por partes se necessário para simplificar L[φ_i].",
                                  "learningObjective": "Provar matematicamente que as funções de peso impõem ortogonalidade dos resíduos.",
                                  "commonMistakes": "Trocar o sinal do resíduo; omitir limites de integração ou função de peso."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar numericamente e interpretar a ortogonalidade",
                                  "subSteps": [
                                    "Escolher um exemplo numérico simples e discretizar o domínio.",
                                    "Calcular coeficientes a_i resolvendo o sistema.",
                                    "Computar ∫ R w_j dx numericamente e confirmar que é próximo de zero.",
                                    "Analisar o erro de aproximação e como a ortogonalidade o minimiza.",
                                    "Generalizar para aplicações em Engenharia Civil."
                                  ],
                                  "verification": "Implementar em Python/MATLAB e plotar |<R, w_j>| < 1e-10 para todos j.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, exemplo prático impresso.",
                                  "tips": "Use malha uniforme inicial para depuração rápida.",
                                  "learningObjective": "Validar a teoria através de verificação computacional.",
                                  "commonMistakes": "Erro numérico por malha grosseira; não normalizar resíduos."
                                }
                              ],
                              "practicalExample": "Para a equação de Poisson -u''(x) = π² sin(πx) em [0,1], u(0)=u(1)=0. Aproximação u_h = a1 sin(πx), w1 = sin(πx) (Galerkin). Resíduo R = -a1 π² sin(πx) - π² sin(πx). Condição: ∫_0^1 R sin(πx) dx = 0 leva a a1 = 1, exata. Verifique <R, w1> = 0.",
                              "finalVerifications": [
                                "Deriva corretamente a condição de ortogonalidade <R, w_j> = 0.",
                                "Resolve o sistema algébrico para um exemplo com N=2 funções base.",
                                "Confirma numericamente que os produtos internos são zero dentro de tolerância 1e-8.",
                                "Explica o impacto da escolha de w_j na precisão da solução.",
                                "Identifica quando a ortogonalidade falha (ex: subespaço incompleto)."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação (40%)",
                                "Clareza e precisão nas fórmulas e passos (25%)",
                                "Qualidade da verificação numérica (20%)",
                                "Profundidade na interpretação da ortogonalidade (10%)",
                                "Uso adequado de notação e analogias (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Funcional e Espaços de Hilbert",
                                "Física: Mecânica Continua e Equações Diferenciais",
                                "Computação: Métodos Numéricos e Programação Científica",
                                "Engenharia Mecânica: Elementos Finitos em Estruturas"
                              ],
                              "realWorldApplication": "Em análises de elementos finitos para simular tensões em vigas e lajes de edifícios, a ortogonalidade garante que os resíduos sejam minimizados no subespaço de aproximação, melhorando a precisão preditiva de falhas estruturais em projetos civis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Implementar em métodos específicos como Galerkin e Collocation",
                            "description": "Aplicar funções de peso em métodos como Galerkin (peso = funções de aproximação) e Collocation (peso = delta de Dirac), resolvendo problemas de engenharia civil numericamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Métodos dos Resíduos Ponderados",
                                  "subSteps": [
                                    "Estude a formulação geral do método dos resíduos ponderados: ∫ R( x ) w( x ) dx = 0, onde R é o resíduo.",
                                    "Identifique funções de peso para Galerkin (w = funções de aproximação φ_i) e Collocation (w = δ(x - x_j)).",
                                    "Revise problemas modelo em engenharia civil, como equações diferenciais para deformação em vigas.",
                                    "Derive matematicamente a ortogonalidade garantida por funções de peso adequadas.",
                                    "Compare diferenças entre Galerkin (fraco) e Collocation (pontual)."
                                  ],
                                  "verification": "Resuma em um diagrama as diferenças entre Galerkin e Collocation, incluindo equações chave.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de métodos numéricos (ex: Zienkiewicz), notas de aula, software como MATLAB ou Python (NumPy/SciPy).",
                                  "tips": "Use analogias visuais: Galerkin como 'média ponderada suave', Collocation como 'pontos de amostragem exatos'.",
                                  "learningObjective": "Compreender a base teórica das funções de peso para garantir ortogonalidade nos métodos.",
                                  "commonMistakes": "Confundir funções de aproximação com funções de peso em Galerkin; ignorar propriedades de delta de Dirac."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método de Galerkin Numericamente",
                                  "subSteps": [
                                    "Escolha um problema simples: resolver -u''(x) = f(x) em [0,1] com condições de contorno u(0)=u(1)=0.",
                                    "Selecione funções de base φ_i (ex: polinômios lineares ou quadráticos).",
                                    "Formule o sistema matricial: K a = F, onde K_ij = ∫ φ_i φ_j dx, F_i = ∫ φ_i f dx.",
                                    "Monte e resolva o sistema usando código em Python/MATLAB.",
                                    "Plote a solução aproximada vs. exata para validar."
                                  ],
                                  "verification": "Execute o código e verifique se o erro L2 é < 1% para malha fina.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com NumPy, SciPy, Matplotlib; ou MATLAB; problema de exemplo em PDF.",
                                  "tips": "Use integração numérica (quadraturas de Gauss) para eficiência em K_ij.",
                                  "learningObjective": "Aplicar funções de peso iguais às de aproximação para formular e resolver via Galerkin.",
                                  "commonMistakes": "Esquecer integração por partes na formulação fraca; malha insuficiente levando a oscilações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Método de Collocation Numericamente",
                                  "subSteps": [
                                    "Use o mesmo problema do Step 2, mas com pontos de colocation x_j internos.",
                                    "Aproxime u(x) ≈ Σ a_i φ_i(x), imponha R(x_j) = 0 para N pontos.",
                                    "Formule o sistema A a = b, onde A_ji = R(φ_i em x_j).",
                                    "Codifique e resolva o sistema linear.",
                                    "Compare soluções Galerkin vs. Collocation em gráfico."
                                  ],
                                  "verification": "Confirme que resíduos em pontos de colocation são próximos de zero (erro < 10^-6).",
                                  "estimatedTime": "3 horas",
                                  "materials": "Mesmo ambiente de programação do Step 2; tabela de pontos de colocation (ex: Chebyshev).",
                                  "tips": "Escolha pontos de colocation longe das extremidades para estabilidade.",
                                  "learningObjective": "Implementar pesos delta de Dirac para condições pontuais exatas.",
                                  "commonMistakes": "Pontos de colocation coincidentes com nós de contorno; não tratar singularidades em delta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Problemas de Engenharia Civil e Validar",
                                  "subSteps": [
                                    "Adapte para problema real: equação de Euler-Bernoulli para viga sob carga distribuída.",
                                    "Implemente ambos métodos para o problema da viga.",
                                    "Calcule deslocamentos, momentos e cortantes.",
                                    "Analise convergência variando número de graus de liberdade.",
                                    "Documente código e resultados em relatório."
                                  ],
                                  "verification": "Solução coincide com solução analítica ou FEM comercial dentro de 5%.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Software FEA (opcional: ANSYS student); dados de viga real (comprimento, EI, q(x)).",
                                  "tips": "Inicie com malha grosseira e refine iterativamente.",
                                  "learningObjective": "Resolver problemas práticos de engenharia civil usando ambos métodos.",
                                  "commonMistakes": "Ignorar condições de contorno reais; escala numérica inadequada em unidades."
                                }
                              ],
                              "practicalExample": "Resolva a deflexão de uma viga simplesmente apoiada de 5m sob carga uniforme q=10kN/m (EI=1e6 kNm²). Use 4 elementos: compare deflexão máxima via Galerkin (esperado ~0.013m) e Collocation.",
                              "finalVerifications": [
                                "Código executa sem erros e produz soluções consistentes para ambos métodos.",
                                "Erros de aproximação diminuem com refinamento da malha.",
                                "Resíduos são ortogonais (Galerkin) ou nulos nos pontos (Collocation).",
                                "Gráficos mostram convergência e comparação com solução exata.",
                                "Relatório explica escolhas de funções de peso e resultados.",
                                "Teste sensibilidade a parâmetros (ex: número de DOFs)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação teórica (equações corretas: 30%).",
                                "Funcionalidade e robustez do código (25%).",
                                "Análise de resultados e convergência (20%).",
                                "Aplicação contextual a engenharia civil (15%).",
                                "Clareza da documentação e verificações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica e álgebra linear (sistemas lineares).",
                                "Programação: Desenvolvimento de solvers em Python/MATLAB.",
                                "Física: Mecânica dos sólidos e equações diferenciais.",
                                "Engenharia de Software: Validação e testes numéricos."
                              ],
                              "realWorldApplication": "Análise preliminar de estruturas civis como pontes e edifícios, onde Galerkin é usado em FEM para precisão global e Collocation em otimização rápida de pontos críticos de tensão."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Analisar exemplos com software numérico",
                            "description": "Usar ferramentas como MATLAB para simular funções de peso em problemas de valor de contorno, avaliando precisão e convergência com base na bibliografia (Chapra, Kincaid).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de software e definir o problema de valor de contorno",
                                  "subSteps": [
                                    "Instalar e abrir o MATLAB ou Octave como alternativa gratuita.",
                                    "Definir a equação diferencial do problema, ex: y'' + y = 0 com condições y(0)=0, y(π)=0.",
                                    "Selecionar funções de peso apropriadas (ex: funções de Legendre ou delta de Dirac).",
                                    "Consultar bibliografia (Chapra cap. 28, Kincaid cap. 10) para formulação teórica.",
                                    "Criar script inicial com variáveis globais para parâmetros do problema."
                                  ],
                                  "verification": "Script inicial executa sem erros e exibe equação e condições de contorno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB/Octave instalado, PDF dos livros Chapra e Kincaid (ou acesso online), editor de script.",
                                  "tips": "Use 'clear all; clc;' no início do script para evitar resíduos de sessões anteriores.",
                                  "learningObjective": "Entender e preparar a base teórica e computacional para simulações de métodos de resíduos ponderados.",
                                  "commonMistakes": "Definir condições de contorno incorretas; ignorar unidades ou domínio do problema."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método dos resíduos ponderados com funções de peso no MATLAB",
                                  "subSteps": [
                                    "Discretizar o domínio em N pontos usando malha uniforme.",
                                    "Definir funções de base (ex: polinômios lineares) e funções de peso (ex: constantes ou quadráticas).",
                                    "Montar a matriz de rigidez e vetor de carga via integração numérica (quadgk ou trapz).",
                                    "Aplicar condições de contorno essenciais para modificar o sistema linear.",
                                    "Resolver o sistema Ax = b usando '\\' (backslash) e plotar solução aproximada."
                                  ],
                                  "verification": "Sistema resolvido gera gráfico da solução que satisfaz condições de contorno aproximadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB com toolbox Symbolic (opcional), exemplos de código de repositórios como GitHub para métodos numéricos.",
                                  "tips": "Teste com N baixo (ex: 5) primeiro para depuração rápida.",
                                  "learningObjective": "Implementar numericamente o método garantindo ortogonalidade via escolha de pesos.",
                                  "commonMistakes": "Erro na indexação da malha; integração imprecisa levando a matriz singular."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular variações de funções de peso e analisar convergência",
                                  "subSteps": [
                                    "Implementar loop para variar número de elementos N (ex: 5 a 100).",
                                    "Testar diferentes funções de peso (ex: peso=1, peso=x, funções de Legendre).",
                                    "Calcular erro de discretização comparando com solução exata (ex: y=sin(x)).",
                                    "Plotar gráficos de convergência: log(|erro|) vs log(N) e ordem de convergência.",
                                    "Exportar dados para tabela ( writetable ) para análise posterior."
                                  ],
                                  "verification": "Gráficos mostram convergência (pendente negativa em log-log) para pelo menos duas funções de peso.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Solução analítica conhecida do problema, funções plot e semilogx.",
                                  "tips": "Use hold on para sobrepor curvas de diferentes pesos no mesmo gráfico.",
                                  "learningObjective": "Avaliar impacto das funções de peso na taxa de convergência do método.",
                                  "commonMistakes": "Escala errada nos eixos log; não normalizar erro adequadamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar precisão e validar contra bibliografia",
                                  "subSteps": [
                                    "Calcular normas de erro (L2, L∞) para cada simulação.",
                                    "Comparar resultados com exemplos de Chapra (ex: problema de viga) e Kincaid (equações elípticas).",
                                    "Analisar sensibilidade a ruído ou condições de contorno imprecisas.",
                                    "Documentar observações em relatório dentro do script (comentários ou fprintf).",
                                    "Otimizar código para eficiência (vetorização em vez de loops)."
                                  ],
                                  "verification": "Relatório gerado lista erros <1e-4 para N>50 e cita similaridades com bibliografia.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplos específicos dos capítulos citados, calculadora para normas manuais.",
                                  "tips": "Use norm() para erros L2; max(abs()) para L∞.",
                                  "learningObjective": "Interpretar resultados numéricos em contexto teórico da bibliografia.",
                                  "commonMistakes": "Ignorar efeitos de precisão de máquina; comparações sem normalização."
                                }
                              ],
                              "practicalExample": "Simule y'' + π² y = 0 em [0,1] com y(0)=0, y(1)=0 (solução exata y=sin(πx)). Use pesos constantes e lineares, refine malha até erro L2 < 1e-5, plote convergência e compare com Figura 28.5 de Chapra.",
                              "finalVerifications": [
                                "Solução numérica converge monotonicamente com refinamento da malha.",
                                "Funções de peso diferentes alteram ordem de convergência observável em log-log.",
                                "Erros reportados coincidem com benchmarks bibliográficos (±10%).",
                                "Código executa em <5s para N=100 e é reproduzível.",
                                "Relatório inclui gráficos, tabelas e conclusões sobre ortogonalidade.",
                                "Validação com solução exata em pelo menos 3 pontos independentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro L2 < 1e-4 para N=50.",
                                "Correção teórica: Escolha de pesos garante ortogonalidade (resíduos médios ~0).",
                                "Eficiência computacional: Tempo de execução escalável com N.",
                                "Análise qualitativa: Discussão de convergência alinhada à bibliografia.",
                                "Qualidade do código: Comentado, vetorizado, sem warnings.",
                                "Visualização: Gráficos claros com legendas e escalas adequadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Integração numérica e resolução de sistemas lineares.",
                                "Programação: Boas práticas em MATLAB (loops, plotting, otimização).",
                                "Física/Engenharia: Modelagem de EDOs em estruturas civis (vibrações, deflexões).",
                                "Estatística: Análise de erro e regressão log-log para ordem de convergência."
                              ],
                              "realWorldApplication": "Em engenharia civil, analisar deflexão de vigas sob carga usando método de resíduos ponderados no MATLAB para validar projetos de pontes ou edifícios, prevendo falhas por convergência lenta em malhas grosseiras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Formulação Geral do Método",
                    "description": "Condição de que a integral do resíduo ponderado seja zero para determinar coeficientes da aproximação.",
                    "individualConcepts": [
                      {
                        "id": "37.1.1.1",
                        "name": "Resíduo da Aproximação",
                        "description": "O resíduo é a diferença entre o operador diferencial aplicado à equação original e o valor obtido pela função de aproximação, representando o erro local da solução aproximada em problemas de valor inicial ou de contorno.",
                        "specificSkills": [
                          {
                            "id": "37.1.1.1.1",
                            "name": "Definir o resíduo em equações diferenciais",
                            "description": "Identificar e expressar matematicamente o resíduo R(x) = L[u(x)] - f(x), onde L é o operador diferencial, u(x) é a aproximação e f(x) o termo fonte, para problemas de valor inicial (PVI) ou de valor de contorno (PVC).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Equações Diferenciais",
                                  "subSteps": [
                                    "Estude a forma geral de uma equação diferencial linear: L[u(x)] = f(x), onde L é o operador diferencial.",
                                    "Identifique os componentes: u(x) como solução exata ou aproximação, f(x) como termo fonte.",
                                    "Diferencie entre Problemas de Valor Inicial (PVI) e Problemas de Valor de Contorno (PVC).",
                                    "Anote exemplos simples de operadores L, como d²/dx² + d/dx.",
                                    "Pratique identificando L, u e f em 2-3 equações dadas."
                                  ],
                                  "verification": "Liste corretamente L, u(x) e f(x) para uma equação exemplo sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de EDOs (capítulo de operadores diferenciais)",
                                    "Folha de papel e caneta",
                                    "Vídeo tutorial sobre operadores diferenciais (Khan Academy)"
                                  ],
                                  "tips": "Comece com EDOs de segunda ordem comuns em engenharia civil para familiaridade.",
                                  "learningObjective": "Compreender os componentes básicos de uma equação diferencial e seu operador.",
                                  "commonMistakes": [
                                    "Confundir u(x) com f(x)",
                                    "Ignorar condições de contorno em PVC"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Conceito de Resíduo em Aproximações",
                                  "subSteps": [
                                    "Defina resíduo como a diferença entre o operador aplicado à aproximação e o termo fonte: R(x) = L[u_approx(x)] - f(x).",
                                    "Explique por que R(x) ≠ 0 para aproximações (não exatas).",
                                    "Discuta o objetivo: minimizar R(x) em métodos numéricos como resíduos ponderados.",
                                    "Esboce graficamente R(x) para uma aproximação polinomial simples.",
                                    "Compare resíduo zero (solução exata) vs. resíduo não-zero."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que R(x) representa e por que é usado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem como Desmos ou MATLAB",
                                    "Exemplos de EDOs impressos",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Visualize R(x) plotando L[u_approx] e f(x) no mesmo gráfico.",
                                  "learningObjective": "Graspar o significado físico/matemático do resíduo como medida de erro.",
                                  "commonMistakes": [
                                    "Pensar que R(x) é sempre zero",
                                    "Confundir com erro de truncamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Matematicamente o Resíduo para uma Equação Dada",
                                  "subSteps": [
                                    "Dada uma EDO como u'' + u' = f(x), identifique L = d²/dx² + d/dx.",
                                    "Escolha uma aproximação u_approx(x), ex: polinômio de grau 1.",
                                    "Calcule L[u_approx(x)] passo a passo: derivadas e substituição.",
                                    "Subtraia f(x) para obter R(x).",
                                    "Simplifique a expressão final de R(x)."
                                  ],
                                  "verification": "Calcule R(x) para uma EDO exemplo e verifique se coincide com a solução esperada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica (Wolfram Alpha)",
                                    "Papel quadriculado",
                                    "Exercícios pré-selecionados de EDOs"
                                  ],
                                  "tips": "Use notação clara para derivadas (u' para du/dx) para evitar confusões.",
                                  "learningObjective": "Capacitar-se a construir a expressão exata de R(x) manualmente.",
                                  "commonMistakes": [
                                    "Erro em derivadas de u_approx",
                                    "Esquecer termos no operador L"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Definição em Contextos de PVI e PVC",
                                  "subSteps": [
                                    "Para PVI: defina condições iniciais u(0)=a, u'(0)=b e compute R(x) ignorando condições por enquanto.",
                                    "Para PVC: defina condições de contorno u(0)=a, u(1)=b e ajuste u_approx para satisfazê-las.",
                                    "Calcule R(x) em ambos os casos com a mesma EDO.",
                                    "Compare como condições afetam a escolha de u_approx e assim R(x).",
                                    "Registre diferenças chave entre PVI e PVC na formulação do resíduo."
                                  ],
                                  "verification": "Resolva e compare R(x) para um PVI e um PVC equivalentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para verificação numérica",
                                    "Exemplos de PVI/PVC da engenharia civil"
                                  ],
                                  "tips": "Em PVC, u_approx deve satisfazer condições de contorno exatamente para métodos de Galerkin.",
                                  "learningObjective": "Diferenciar e aplicar a definição de resíduo em problemas com condições variadas.",
                                  "commonMistakes": [
                                    "Aplicar condições de contorno no cálculo de R(x)",
                                    "Ignorar impacto das condições na aproximação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a EDO de viga em flexão: u''''(x) = f(x), com PVC u(0)=u(L)=0, u''(0)=u''(L)=0. Aproximação u_approx(x) = a x (L - x). Calcule L[u_approx] = 24a, então R(x) = 24a - f(x). Isso mede o erro na modelagem da deformação da viga.",
                              "finalVerifications": [
                                "Defina corretamente R(x) = L[u(x)] - f(x) sem hesitação.",
                                "Calcule R(x) para uma EDO de segunda ordem em menos de 5 minutos.",
                                "Explique a diferença de resíduo em PVI vs PVC com exemplo.",
                                "Identifique L, u_approx e f(x) em uma equação complexa.",
                                "Gere um gráfico de R(x) para uma aproximação dada.",
                                "Discuta por que minimizar R(x) é crucial em métodos numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes (L, u, f): 100% correto.",
                                "Correção matemática no cálculo de R(x): sem erros de derivada.",
                                "Profundidade na explicação conceitual: inclui medida de erro.",
                                "Aplicação contextual a PVI/PVC: exemplos relevantes.",
                                "Criatividade em exemplos práticos: ligado a engenharia civil.",
                                "Clareza na comunicação: expressões matemáticas legíveis."
                              ],
                              "crossCurricularConnections": [
                                "Física: Resíduo como força residual em equilíbrio dinâmico.",
                                "Programação: Implementar cálculo de R(x) em Python/MATLAB para simulações.",
                                "Engenharia Mecânica: Modelagem de vibrações com resíduos em métodos espectrais.",
                                "Estatística: Resíduo similar a resíduos em regressão linear."
                              ],
                              "realWorldApplication": "Na engenharia civil, definir o resíduo é essencial para simular deformações em vigas e placas usando métodos de elementos finitos ou resíduos ponderados, permitindo otimizar estruturas contra falhas sob cargas reais, como em pontes ou edifícios altos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "37.1.1.1.2",
                            "name": "Calcular o resíduo para aproximações polinomiais",
                            "description": "Calcular explicitamente o resíduo para uma aproximação u(x) = ∑ c_i φ_i(x), onde φ_i são funções base, em equações diferenciais lineares de segunda ordem típicas da engenharia civil, como equações de vigas ou difusão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a Equação Diferencial Linear e o Operador Diferencial L",
                                  "subSteps": [
                                    "Leia e interprete a equação diferencial linear de segunda ordem típica da engenharia civil, como a equação de Euler-Bernoulli para vigas (EI u''''(x) = q(x)) ou equação de difusão (u''(x) - k u(x) = f(x)).",
                                    "Identifique o operador diferencial L, expressando-o na forma geral L[u] = a2 u'' + a1 u' + a0 u + ... = f(x).",
                                    "Anote os coeficientes constantes ou funções conhecidas e o termo fonte f(x).",
                                    "Confirme que a equação é linear e homogênea ou não-homogênea.",
                                    "Esboce o domínio do problema (ex: [0, L] para uma viga)."
                                  ],
                                  "verification": "Escreva explicitamente o operador L[u] e verifique se L[u] = f(x) reproduz a equação original.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de equação de viga ou difusão",
                                    "Calculadora para coeficientes"
                                  ],
                                  "tips": [
                                    "Comece sempre pela forma padrão para evitar confusões com notação.",
                                    "Use subscritos para diferenciar coeficientes variáveis."
                                  ],
                                  "learningObjective": "Compreender a estrutura matemática da equação diferencial e isolar o operador L para aplicação posterior.",
                                  "commonMistakes": [
                                    "Confundir derivadas de quarta ordem em vigas com segunda ordem.",
                                    "Ignorar coeficientes variáveis como EI(x) em vigas reais.",
                                    "Esquecer o termo fonte f(x)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Definir Funções Base Polinomiais φ_i(x)",
                                  "subSteps": [
                                    "Escolha um conjunto de funções base polinomiais adequadas, como φ1(x) = 1, φ2(x) = x, φ3(x) = x^2, até o grau desejado (geralmente 2-4 para aproximações iniciais).",
                                    "Verifique que as funções base satisfazem condições de contorno aproximadas, se aplicável (ex: φ(0)=0 para viga engastada).",
                                    "Defina a aproximação trial u(x) = ∑_{i=1}^N c_i φ_i(x), onde c_i são coeficientes desconhecidos.",
                                    "Escreva explicitamente u(x) para N=3, por exemplo: u(x) ≈ c1 + c2 x + c3 x^2.",
                                    "Liste as derivadas necessárias de φ_i até a ordem máxima de L (ex: até 4ª derivada para vigas)."
                                  ],
                                  "verification": "Escreva u(x) e suas derivadas até a ordem requerida, substituindo valores numéricos simples para checar.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha quadriculada",
                                    "Tabela de polinômios de Legendre ou Taylor para inspiração",
                                    "Software como Mathematica ou Python para derivadas simbólicas (opcional)"
                                  ],
                                  "tips": [
                                    "Escolha bases ortogonais como polinômios de Legendre para melhor convergência em intervalos [-1,1].",
                                    "Normalize as bases para φ_i(0)=1 ou similar."
                                  ],
                                  "learningObjective": "Selecionar funções base polinomiais que formem uma aproximação flexível e computacionalmente tratável.",
                                  "commonMistakes": [
                                    "Usar polinômios de grau muito alto sem motivo, levando a ill-conditioning.",
                                    "Não considerar condições de contorno nas bases.",
                                    "Erros em derivadas de ordens altas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Operador L Aplicado à Aproximação u(x)",
                                  "subSteps": [
                                    "Compute as derivadas de u(x) = ∑ c_i φ_i(x) até a ordem máxima: u'(x) = ∑ c_i φ_i'(x), u''(x) = ∑ c_i φ_i''(x), etc.",
                                    "Substitua nas componentes do operador L: por exemplo, para L[u] = u'' + u, calcule L[u](x) = ∑ c_i (φ_i''(x) + φ_i(x)).",
                                    "Para equações de vigas (L[u] = (EI u'')''), compute derivadas passo a passo: primeiro u'', multiplique por EI, então derive duas vezes.",
                                    "Simplifique expressões algébricas, agrupando termos por c_i: L[u](x) = ∑ d_i(x) c_i, onde d_i(x) = L[φ_i](x).",
                                    "Verifique dimensionalmente: unidades de L[u] devem coincidir com f(x)."
                                  ],
                                  "verification": "Substitua c_i=1 um por um e verifique se L[φ_i] está correto comparando com cálculo manual.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou papel para derivadas",
                                    "Exemplos resolvidos de L[φ_i] para vigas",
                                    "Python/SymPy para automação (opcional)"
                                  ],
                                  "tips": [
                                    "Use a regra de Leibniz para derivadas de produtos em EI(x) u''(x).",
                                    "Mantenha c_i simbólicos até o final."
                                  ],
                                  "learningObjective": "Aplicar o operador diferencial linear à soma finita de funções base, obtendo uma expressão linear em c_i.",
                                  "commonMistakes": [
                                    "Erros de sinal em derivadas pares/ímpares.",
                                    "Confundir índices i ao somar ∑ c_i L[φ_i].",
                                    "Esquecer multiplicação por coeficientes como EI."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar e Analisar o Resíduo R(x)",
                                  "subSteps": [
                                    "Defina o resíduo como R(x) = L[u(x)] - f(x), substituindo a expressão de L[u].",
                                    "Expresse R(x) = ∑ c_i L[φ_i](x) - f(x), destacando dependência nos coeficientes c_i.",
                                    "Avalie R(x) em pontos específicos ou integre para medir magnitude (ex: ∫ R^2 dx pequeno indica boa aproximação).",
                                    "Para um exemplo numérico, assuma valores para c_i e f(x), e plote R(x) para visualização.",
                                    "Discuta como minimizar R(x) via ponderação no método dos resíduos ponderados."
                                  ],
                                  "verification": "Para c_i escolhidos arbitrariamente, compute R(x) e confirme que R=0 quando u(x) é a solução exata conhecida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gráficos de f(x) e φ_i",
                                    "Software de plotagem como MATLAB ou Python Matplotlib"
                                  ],
                                  "tips": [
                                    "O resíduo mede o erro local; zero em nós de Gauss é ideal em métodos ponderados.",
                                    "Normalize R por ||f|| para comparação."
                                  ],
                                  "learningObjective": "Calcular explicitamente o resíduo como métrica de erro da aproximação polinomial.",
                                  "commonMistakes": [
                                    "Inverter o sinal: R = f - L[u] em vez de L[u] - f.",
                                    "Esquecer de subtrair f(x) após L[u].",
                                    "Não simplificar algebraicamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de flexão de viga EI u''''(x) = q(x) = 1 (carga uniforme) em [0,1], use u(x) ≈ c1 (1 - x^2) + c2 x^3. Compute derivadas: u''(x) ≈ -2 c1 + 6 c2 x, u''''(x) ≈ 0 (pois polinômio grau 3). Assim L[u] = 0, R(x) = 0 - 1 = -1, indicando necessidade de bases de grau maior.",
                              "finalVerifications": [
                                "Pode derivar corretamente L[u(x)] para uma aproximação polinomial dada.",
                                "Calcula R(x) = L[u] - f sem erros algébricos em exemplos de vigas e difusão.",
                                "Identifica quando R(x) é pequeno o suficiente para engenharia (erro <1%).",
                                "Aplica o processo a uma nova EDL de segunda ordem.",
                                "Explica o papel do resíduo na iteração do método dos resíduos ponderados.",
                                "Verifica dimensionalmente todas as expressões."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas derivadas de ordens múltiplas das funções base.",
                                "Correta linearização de L[u] em termos de c_i.",
                                "Simplicidade e clareza na expressão final de R(x).",
                                "Uso apropriado de bases polinomiais para o problema específico.",
                                "Análise qualitativa do resíduo (magnitude, zeros esperados).",
                                "Ausência de erros dimensionais ou de sinal."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Integração no método de Galerkin ou elementos finitos.",
                                "Programação Computacional: Implementação em Python/SymPy para automação de resíduos.",
                                "Física/Mecânica dos Sólidos: Modelagem de deformações em vigas e placas.",
                                "Análise Estatística: Medição de erro via norma L2 do resíduo.",
                                "Engenharia de Software: Validação numérica de solvers de EDL."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, como dimensionamento de vigas em pontes ou edifícios, o cálculo do resíduo para aproximações polinomiais permite avaliar a precisão de soluções analíticas aproximadas antes de refinar com métodos numéricos como elementos finitos, otimizando tempo e recursos computacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "37.1.1.1.3",
                            "name": "Interpretar o significado físico do resíduo",
                            "description": "Explicar como o resíduo quantifica o erro de truncamento na aproximação e sua relação com a precisão da solução numérica em contextos de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de resíduo na aproximação numérica",
                                  "subSteps": [
                                    "Revise a equação diferencial que está sendo aproximada pelo método dos resíduos ponderados.",
                                    "Defina o resíduo como a diferença entre a equação exata e a aproximada: R = L(u) - L(u_h), onde u_h é a solução aproximada.",
                                    "Identifique os componentes do resíduo em uma formulação geral.",
                                    "Calcule um resíduo simples para uma função teste conhecida.",
                                    "Discuta como o resíduo mede a violação da equação diferencial pela aproximação."
                                  ],
                                  "verification": "Capacidade de escrever a definição matemática do resíduo e calcular para um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta; equação diferencial exemplo (ex: equação de Poisson).",
                                  "tips": "Comece com casos unidimensionais para simplificar o entendimento.",
                                  "learningObjective": "Entender o resíduo como medida da inconsistência da aproximação com a equação governante.",
                                  "commonMistakes": "Confundir resíduo com erro global; ignorar os pesos na formulação ponderada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Relacionar o resíduo ao erro de truncamento",
                                  "subSteps": [
                                    "Explique o erro de truncamento como consequência da discretização (ex: diferenças finitas ou elementos finitos).",
                                    "Mostre matematicamente como o resíduo captura termos de ordem superior no desenvolvimento de Taylor.",
                                    "Compare o resíduo local com o erro global de truncamento.",
                                    "Analise como minimizar o resíduo reduz o erro de truncamento.",
                                    "Realize uma análise de convergência qualitativa."
                                  ],
                                  "verification": "Derivação de uma relação qualitativa ou quantitativa entre resíduo e erro de truncamento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de métodos numéricos; software como MATLAB ou Python para plotar resíduos.",
                                  "tips": "Use expansões em série de Taylor para visualizar os termos truncados.",
                                  "learningObjective": "Estabelecer a conexão direta entre resíduo e precisão da discretização.",
                                  "commonMistakes": "Achar que resíduo zero implica solução exata; negligenciar dependência da malha."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o significado físico do resíduo em contextos de engenharia civil",
                                  "subSteps": [
                                    "Associe o resíduo a desequilíbrios físicos, como forças residuais em estruturas.",
                                    "Exemplo: em análise de vigas, resíduo representa forças não equilibradas devido à aproximação.",
                                    "Discuta implicações em estabilidade e deformações.",
                                    "Visualize o resíduo como 'desvio' da lei física real.",
                                    "Compare com experimentos físicos onde erros de medição geram resíduos semelhantes."
                                  ],
                                  "verification": "Explicação verbal ou escrita do resíduo como 'força fictícia' em um problema estrutural.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Diagramas de vigas ou placas; simulador FEM simples (ex: FreeFEM).",
                                  "tips": "Pense no resíduo como uma 'força de erro' que o método busca minimizar.",
                                  "learningObjective": "Traduzir o conceito matemático em interpretação física intuitiva.",
                                  "commonMistakes": "Interpretar resíduo apenas matematicamente, sem ligação física; superestimar magnitude."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar a relação do resíduo com a precisão da solução numérica",
                                  "subSteps": [
                                    "Quantifique como normas do resíduo (L1, L2, L∞) correlacionam com erro na solução.",
                                    "Estude refinamento de malha e redução do resíduo.",
                                    "Defina critérios de parada baseados em tolerância de resíduo.",
                                    "Analise trade-offs entre precisão e custo computacional.",
                                    "Teste em um problema real de engenharia civil."
                                  ],
                                  "verification": "Gráfico de resíduo vs. erro para diferentes malhas, mostrando convergência.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de elementos finitos (ex: ANSYS Student ou código Python); dados de malha.",
                                  "tips": "Monitore o resíduo em iterações para guiar decisões de precisão.",
                                  "learningObjective": "Usar o resíduo como indicador prático de confiabilidade da solução numérica.",
                                  "commonMistakes": "Ignorar resíduos locais altos em regiões críticas; confundir com erro de arredondamento."
                                }
                              ],
                              "practicalExample": "Em uma viga simplesmente apoiada sob carga uniforme modelada pela equação de Euler-Bernoulli, calcule o resíduo em nós da malha usando elementos finitos. Interprete um resíduo de 10^-3 N/m como uma força residual que causa deformação extra de 0.1 mm, afetando a precisão do projeto.",
                              "finalVerifications": [
                                "Explicar corretamente o resíduo como quantificador de erro de truncamento.",
                                "Relacionar resíduo físico a desequilíbrios em estruturas civis.",
                                "Identificar como reduzir resíduo melhora precisão numérica.",
                                "Calcular e interpretar resíduo em um exemplo simples.",
                                "Discutir limites de uso do resíduo como métrica de erro.",
                                "Propor critério de tolerância baseado em contexto físico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática e física do resíduo (30%).",
                                "Correta ligação com erro de truncamento e precisão (25%).",
                                "Exemplos contextualizados em engenharia civil (20%).",
                                "Análise qualitativa/quantitativa de impacto (15%).",
                                "Clareza na comunicação e uso de exemplos práticos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Análise de erros e convergência.",
                                "Física: Equilíbrio de forças e leis constitutivas.",
                                "Programação: Implementação de solvers FEM com monitoramento de resíduo.",
                                "Estatística: Normas e métricas de erro probabilístico."
                              ],
                              "realWorldApplication": "Na análise de pontes ou barragens via elementos finitos, o resíduo guia o refinamento da malha para garantir que deformações previstas sejam precisas dentro de 1%, evitando super ou subdimensionamento com custos elevados ou riscos de falha."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "37.1.1.2",
                        "name": "Funções de Ponderação",
                        "description": "As funções de ponderação φ_i(x) são escolhidas para enfraquecer o resíduo em regiões críticas do domínio, levando à condição de ortogonalidade no espaço de funções.",
                        "specificSkills": [
                          {
                            "id": "37.1.1.2.1",
                            "name": "Selecionar funções de ponderação adequadas",
                            "description": "Escolher funções de peso como polinômios de Legendre, funções delta ou funções teste contínuas para diferentes tipos de problemas diferenciais em engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Tipos de Funções de Ponderação e Suas Propriedades Fundamentais",
                                  "subSteps": [
                                    "Estude as definições de polinômios de Legendre, funções delta e funções teste contínuas.",
                                    "Analise as propriedades matemáticas chave: ortogonalidade para Legendre, localização para delta, suavidade para funções teste.",
                                    "Compare visualmente as funções usando gráficos em software como MATLAB ou Python (Matplotlib).",
                                    "Revise exemplos teóricos de aplicação em EDOs e EDPs simples.",
                                    "Anote as condições de contorno e regularidade associadas a cada tipo."
                                  ],
                                  "verification": "Crie um quadro comparativo com propriedades e gere gráficos de pelo menos duas funções.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de métodos numéricos (ex: Burden & Faires)",
                                    "Software MATLAB/Python com bibliotecas NumPy/SciPy",
                                    "Artigos sobre método dos resíduos ponderados"
                                  ],
                                  "tips": "Comece com funções de baixa ordem para visualização intuitiva.",
                                  "learningObjective": "Identificar e descrever propriedades essenciais de cada função de ponderação.",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade de Legendre com delta (não ortogonal)",
                                    "Ignorar a necessidade de suavidade em problemas com soluções regulares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Características do Problema Diferencial Específico",
                                  "subSteps": [
                                    "Classifique o problema: EDO ou EDP, linear ou não-linear, condições de contorno (Dirichlet, Neumann, etc.).",
                                    "Avalie a regularidade da solução esperada (suave, descontínua, com singularidades).",
                                    "Determine o domínio geométrico e tipo de malha (estruturada ou não).",
                                    "Liste restrições computacionais: precisão desejada, custo de integração.",
                                    "Examine casos de engenharia civil como vigas, placas ou fluxo em solos."
                                  ],
                                  "verification": "Escreva um relatório curto descrevendo o problema com classificação e características chave.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de problemas de engenharia civil (ex: equação de Euler-Bernoulli)",
                                    "Planilhas ou notes para classificação"
                                  ],
                                  "tips": "Use fluxogramas para mapear características do problema.",
                                  "learningObjective": "Classificar problemas diferenciais quanto a adequação de funções de ponderação.",
                                  "commonMistakes": [
                                    "Subestimar impacto de singularidades",
                                    "Ignorar condições de contorno mistas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Prós, Contras e Adequação de Cada Função ao Problema",
                                  "subSteps": [
                                    "Para polinômios de Legendre: avalie convergência espectral em soluções suaves.",
                                    "Para funções delta: teste precisão em capturar picos ou cargas localizadas.",
                                    "Para funções teste contínuas: verifique estabilidade em problemas com gradientes íngremes.",
                                    "Calcule métricas qualitativas: taxa de convergência, custo computacional.",
                                    "Simule um problema toy simples com cada função usando código básico."
                                  ],
                                  "verification": "Preencha uma tabela de decisão com prós/contras e pontuação para o problema alvo.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código Python/MATLAB para simulações simples",
                                    "Tabelas de referência de métodos weighted residuals"
                                  ],
                                  "tips": "Priorize métricas relevantes ao contexto de engenharia civil.",
                                  "learningObjective": "Comparar funções de ponderação com base em critérios quantitativos e qualitativos.",
                                  "commonMistakes": [
                                    "Superestimar precisão de delta em soluções suaves",
                                    "Não considerar overhead computacional de Legendre"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e Justificar a Função de Ponderação Adequada",
                                  "subSteps": [
                                    "Escolha a função baseada na tabela de decisão e simulações.",
                                    "Escreva uma justificativa detalhada ligando características do problema à escolha.",
                                    "Teste sensibilidade variando parâmetros da função.",
                                    "Documente alternativas rejeitadas e razões.",
                                    "Prepare um resumo para implementação em código maior."
                                  ],
                                  "verification": "Produza um relatório final com escolha, justificativa e código de protótipo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Template de relatório",
                                    "Ambiente de programação"
                                  ],
                                  "tips": "Use linguagem quantitativa na justificativa (ex: 'reduz erro em 30%').",
                                  "learningObjective": "Tomar decisões informadas e defender escolhas técnicas.",
                                  "commonMistakes": [
                                    "Escolha sem justificativa quantitativa",
                                    "Ignorar trade-offs custo-benefício"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma análise de viga em flexão (equação de Euler-Bernoulli) com carga pontual, selecione funções delta para capturar precisamente a discontinuidade no momento fletor, implementando em Python com integração numérica para validar a solução contra analítica.",
                              "finalVerifications": [
                                "Pode listar e descrever três tipos principais de funções de ponderação.",
                                "Classifica corretamente um problema de engenharia civil quanto a regularidade.",
                                "Justifica escolha com pelo menos duas métricas (ex: convergência, custo).",
                                "Implementa protótipo simples em código que roda sem erros.",
                                "Identifica quando Legendre é superior a delta em soluções suaves.",
                                "Compara resultados simulados com soluções exatas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de propriedades das funções (30%)",
                                "Adequação da classificação do problema (20%)",
                                "Profundidade da análise prós/contras (20%)",
                                "Qualidade da justificativa e simulação (20%)",
                                "Clareza e completude do relatório (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Integração de métodos espectrais e Galerkin.",
                                "Programação Computacional: Implementação em Python/MATLAB para FEM.",
                                "Física Aplicada: Modelagem de estruturas em mecânica dos sólidos.",
                                "Análise de Dados: Avaliação de erros e convergência numérica."
                              ],
                              "realWorldApplication": "Na simulação de barragens ou pontes via elementos finitos, selecionar funções delta para cargas localizadas (ex: terremotos) garante precisão em zonas críticas, otimizando projetos de engenharia civil para segurança e economia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "37.1.1.2.2",
                            "name": "Explicar o papel das funções de ponderação",
                            "description": "Descrever como as funções φ_i garantem que o resíduo seja ortogonal às funções base, minimizando o erro global na aproximação da solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de resíduo na aproximação numérica",
                                  "subSteps": [
                                    "Defina o resíduo como a diferença entre a equação exata e sua aproximação: R = L(u_N) - f, onde u_N é a solução aproximada.",
                                    "Explique por que o resíduo não é zero em métodos aproximados devido à discretização.",
                                    "Discuta a importância de minimizar o resíduo para melhorar a precisão da solução.",
                                    "Identifique exemplos simples de resíduos em equações diferenciais ordinárias.",
                                    "Esboce graficamente um resíduo não nulo em uma aproximação polinomial."
                                  ],
                                  "verification": "Escreva a definição de resíduo e dê um exemplo numérico simples, confirmando que R ≠ 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de métodos numéricos (capítulo sobre resíduos)"
                                  ],
                                  "tips": "Visualize o resíduo como um 'erro local' que precisa ser controlado globalmente.",
                                  "learningObjective": "Entender o resíduo como medida de erro na aproximação de soluções diferenciais.",
                                  "commonMistakes": "Confundir resíduo com erro absoluto da solução; resíduo é erro na equação, não na solução."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de ortogonalidade no método dos resíduos ponderados",
                                  "subSteps": [
                                    "Defina ortogonalidade: duas funções φ_i e R são ortogonais se ∫ φ_i R dx = 0.",
                                    "Explique que impor ortogonalidade força o resíduo a ser perpendicular ao espaço de aproximação.",
                                    "Discuta como isso é análogo à projeção ortogonal em álgebra linear.",
                                    "Mostre a condição matemática: ∑ ∫ φ_i R dx = 0 para i = 1 a N.",
                                    "Diferencie ortogonalidade de aniquilação total do resíduo."
                                  ],
                                  "verification": "Formule a condição de ortogonalidade para um caso com N=1 e verifique com integrais simbólicas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica (Wolfram Alpha)",
                                    "Folha de exercícios sobre integrais"
                                  ],
                                  "tips": "Pense em vetores: projeção minimiza o erro quando residual é perpendicular à base.",
                                  "learningObjective": "Compreender ortogonalidade como mecanismo para minimizar erro de forma ponderada.",
                                  "commonMistakes": "Achar que ortogonalidade torna resíduo zero; é apenas em subespaços específicos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o papel das funções de ponderação φ_i",
                                  "subSteps": [
                                    "Descreva φ_i como funções base escolhidas para ponderar o resíduo (ex: polinomiais, funções de splines).",
                                    "Mostre como φ_i definem o 'peso' dado a diferentes regiões do domínio.",
                                    "Explique que a escolha de φ_i = funções base (Galerkin) ou φ_i = δ (Collocation) altera o método.",
                                    "Derive a equação fraca: encontrar u_N tal que (φ_i, R) = 0 para todo i.",
                                    "Analise como φ_i garantem equilíbrio global do erro."
                                  ],
                                  "verification": "Escreva a formulação geral com φ_i e identifique seu papel na equação resultante.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Apostila de Método dos Resíduos Ponderados",
                                    "Software MATLAB para plotar funções base"
                                  ],
                                  "tips": "Escolha φ_i suaves para problemas com derivadas altas para estabilidade numérica.",
                                  "learningObjective": "Identificar φ_i como chaves para ortogonalizar resíduo e minimizar erro global.",
                                  "commonMistakes": "Ignorar que φ_i podem diferir das funções base; isso define variantes do método."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a minimização do erro global",
                                  "subSteps": [
                                    "Demonstre que as condições ∫ φ_i R dx = 0 minimizam a norma ponderada do resíduo.",
                                    "Compare com norma L2: para Galerkin, é minimização em ||R||_φ.",
                                    "Discuta convergência: erro diminui com refinamento de φ_i.",
                                    "Avalie impacto em estabilidade e precisão da solução aproximada.",
                                    "Conclua com vantagens sobre métodos não ponderados."
                                  ],
                                  "verification": "Resolva um sistema simples e compute norma do resíduo antes/depois das condições.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python ou MATLAB para simulação numérica",
                                    "Exemplos resolvidos de equações diferenciais"
                                  ],
                                  "tips": "Use norma energia para problemas elásticos em engenharia civil.",
                                  "learningObjective": "Explicar como φ_i levam à minimização ótima do erro na aproximação.",
                                  "commonMistakes": "Confundir minimização local (collocation) com global (Galerkin)."
                                }
                              ],
                              "practicalExample": "Considere a equação -u'' + u = 1 em [0,1] com u(0)=u(1)=0. Aproxime u_N = x(1-x) ∑_{i=1}^N u_i x^{i-1}. Defina φ_i = x(1-x) x^{i-1} (Galerkin). Impõe ∫ φ_i (-u_N'' + u_N -1) dx =0, resolvendo para u_i e verificando resíduo ortogonal.",
                              "finalVerifications": [
                                "Definir corretamente resíduo e sua ortogonalidade às φ_i.",
                                "Explicar matematicamente o papel de φ_i na formulação.",
                                "Identificar variantes do método baseadas em escolha de φ_i.",
                                "Demonstrar minimização de erro com exemplo numérico.",
                                "Diferenciar de métodos como momentos ou subdomain.",
                                "Plotar resíduo e confirmar ortogonalidade via integrais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ortogonalidade e resíduo (30%)",
                                "Clareza na explicação do papel minimizador de φ_i (25%)",
                                "Uso correto de notação matemática e derivações (20%)",
                                "Exemplo prático resolvido com verificação (15%)",
                                "Identificação de erros comuns e limitações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Projeções ortogonais e espaços de Hilbert.",
                                "Cálculo: Integrais fracas e produtos internos.",
                                "Física: Princípio dos trabalhos virtuais em mecânica.",
                                "Computação: Implementação em Elementos Finitos (FEM).",
                                "Estatística: Minimização de erros quadráticos ponderados."
                              ],
                              "realWorldApplication": "Em análises de elementos finitos para simular tensões em pontes e edifícios, onde funções de ponderação garantem precisão na aproximação de deslocamentos, otimizando projetos civis contra falhas estruturais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "37.1.1.3",
                        "name": "Condição da Integral do Resíduo Ponderado Zero",
                        "description": "A formulação geral impõe que a integral do produto do resíduo pela função de ponderação sobre o domínio seja nula, gerando equações para os coeficientes c_i e relacionando-se à matriz de Gram.",
                        "specificSkills": [
                          {
                            "id": "37.1.1.3.1",
                            "name": "Formular a condição integral ∫ R φ_i dx = 0",
                            "description": "Escrever e derivar a equação ∫_Ω R(x) φ_i(x) dx = 0 para i=1 a N, onde Ω é o domínio, aplicando integração por partes se necessário para PVC.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Método dos Resíduos Ponderados",
                                  "subSteps": [
                                    "Revise a equação diferencial governante L(u) = f em um domínio Ω com condições de contorno.",
                                    "Identifique o operador diferencial L, a solução exata u e a aproximação u_h.",
                                    "Defina o resíduo R(x) = L(u_h) - f como a medida do erro local.",
                                    "Explique o papel das funções de peso φ_i(x) na distribuição do erro.",
                                    "Discuta a motivação: minimizar o resíduo ponderado para soluções aproximadas."
                                  ],
                                  "verification": "Resuma em suas palavras o que é o resíduo e por que usamos pesos; compare com método de Galerkin.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de métodos numéricos (ex: Zienkiewicz), caderno e caneta.",
                                  "tips": "Desenhe o domínio Ω e marque onde o resíduo é calculado.",
                                  "learningObjective": "Entender a base teórica do método e o conceito de resíduo.",
                                  "commonMistakes": "Confundir resíduo com erro global; resíduo é local e não zero em aproximações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Resíduo R(x) e as Funções de Peso φ_i(x)",
                                  "subSteps": [
                                    "Escolha um problema exemplo, como -u'' + u = f em [0,1] com PVC u(0)=0, u(1)=0.",
                                    "Aproxime u_h(x) = Σ u_j ψ_j(x), onde ψ_j são funções base.",
                                    "Calcule R(x) = -u_h'' + u_h - f explicitamente.",
                                    "Selecione φ_i(x) = ψ_i(x) para versão de Galerkin ou φ_i polinomiais.",
                                    "Verifique ortogonalidade: as φ_i devem ser linealmente independentes."
                                  ],
                                  "verification": "Escreva R(x) para u_h de grau 1 e confirme que não é zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora simbólica (ex: Mathematica ou papel), tabela de funções base.",
                                  "tips": "Comece com problemas 1D simples para visualizar o resíduo.",
                                  "learningObjective": "Saber calcular o resíduo para uma aproximação dada.",
                                  "commonMistakes": "Esquecer termos de contorno no operador L; sempre incluir f(x)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a Condição Integral ∫_Ω R(x) φ_i(x) dx = 0",
                                  "subSteps": [
                                    "Escreva a integral para i=1 a N: ∫_Ω R(x) φ_i(x) dx = 0.",
                                    "Expanda R(x) na integral: ∫_Ω [L(u_h) - f] φ_i dx = 0.",
                                    "Reorganize para Σ u_j ∫_Ω L(ψ_j) φ_i dx = ∫_Ω f φ_i dx.",
                                    "Confirme que isso gera N equações para N incógnitas u_j.",
                                    "Discuta subcategorias: collocation (φ_i delta), subdomain, least-squares."
                                  ],
                                  "verification": "Derive o sistema matricial A u = b e verifique dimensões NxN.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de álgebra (ex: SymPy), exemplos de problemas de engenharia civil.",
                                  "tips": "Use índices i,j consistentemente para evitar confusão matricial.",
                                  "learningObjective": "Escrever corretamente a condição de resíduo zero ponderado.",
                                  "commonMistakes": "Invertar limites de integração ou esquecer o domínio Ω completo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Integração por Partes para Problemas de Valor de Contorno (PVC)",
                                  "subSteps": [
                                    "Identifique termos que requerem integração por partes, ex: ∫ u'' φ dx.",
                                    "Aplique fórmula: ∫ u'' φ = [u' φ]_∂Ω - ∫ u' φ' dx, incorporando condições de contorno.",
                                    "Continue para segunda ordem: ∫ u'' φ = [u' φ - u φ']_∂Ω + ∫ u φ'' dx.",
                                    "Substitua condições de Dirichlet/Neumann nas fronteiras ∂Ω.",
                                    "Obtenha a forma fraca: forma bilinear a(u_h, φ_i) = l(φ_i).",
                                    "Verifique simetria para Galerkin."
                                  ],
                                  "verification": "Compare a forma forte e fraca; resolva numericamente para u_h.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Papel quadriculado, referência de FEM (ex: Hughes 'The Finite Element Method').",
                                  "tips": "Sempre anote termos de contorno explicitamente antes de descartar.",
                                  "learningObjective": "Derivar a forma fraca usando integração por partes.",
                                  "commonMistakes": "Descartar incorretamente termos de contorno; verificar [ ]_∂Ω = 0 apenas se PVC homogênea."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Interpretar a Formulação Completa",
                                  "subSteps": [
                                    "Monte o sistema completo para N=2 e resolva u_h.",
                                    "Compare u_h com solução exata ou analítica.",
                                    "Analise convergência variando N.",
                                    "Discuta estabilidade e precisão para problemas de engenharia civil.",
                                    "Documente a formulação geral para reutilização."
                                  ],
                                  "verification": "Erro L2 < 5% para malha fina; sistema bem condicionado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python/MATLAB para resolução numérica.",
                                  "tips": "Teste com f(x)=sin(πx) para soluções conhecidas.",
                                  "learningObjective": "Aplicar e validar a condição em um exemplo completo.",
                                  "commonMistakes": "Escolher funções base que não satisfazem contornos essenciais."
                                }
                              ],
                              "practicalExample": "Para a equação de difusão em uma viga civil: -k u'' = q(x) em Ω=[0,L], u(0)=0, u'(L)=0. Aproxime u_h = (1-x/L)^2 Σ u_j x^j. Calcule R = -k u_h'' - q, imponha ∫_0^L R φ_i dx=0 com φ_i = x^i, aplique partes para obter matriz de rigidez.",
                              "finalVerifications": [
                                "A integral ∫_Ω R φ_i dx é zero para cada i=1..N.",
                                "Sistema resultante tem N equações e N incógnitas.",
                                "Termos de contorno incorporados corretamente via partes.",
                                "Matriz é simétrica se Galerkin e operador auto-adjunto.",
                                "Solução u_h satisfaz condições essenciais.",
                                "Erro de aproximação diminui com refinamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de R(x) e φ_i(x) (20%)",
                                "Correção na escrita da integral e expansão (25%)",
                                "Aplicação correta de integração por partes (25%)",
                                "Geração válida do sistema linear Au=b (15%)",
                                "Interpretação física/engenharia da formulação (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e álgebra linear para montagem matricial.",
                                "Física: Equações diferenciais em mecânica dos sólidos (vigas, placas).",
                                "Computação: Implementação numérica em FEM codes (ex: FEniCS).",
                                "Engenharia: Análise estrutural em softwares como ANSYS.",
                                "Estatística: Análise de erro e convergência de métodos aproximados."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos para análise de tensões em pontes ou barragens, onde a formulação garante equilíbrio global aproximado, permitindo prever falhas estruturais sem solução exata analítica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "37.1.1.3.2",
                            "name": "Derivar o sistema linear para coeficientes",
                            "description": "Transformar as condições integrais em um sistema linear A c = b, onde A é a matriz de Gram com elementos ∫ φ_i L[φ_j] dx, e resolver para os coeficientes da aproximação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer a aproximação e definir o resíduo",
                                  "subSteps": [
                                    "Expresse a solução aproximada como u(x) ≈ ∑_{j=1}^n c_j φ_j(x), onde φ_j são funções base lineares independentes.",
                                    "Defina o operador diferencial L e a equação L[u] = f.",
                                    "Calcule o resíduo R(x) = L[u(x)] - f(x).",
                                    "Verifique que R(x) ≠ 0 em geral, justificando a necessidade do método.",
                                    "Escolha funções base φ_j adequadas ao problema (ex.: polinômios ou funções hat)."
                                  ],
                                  "verification": "Confirme que a expressão de u(x) está correta e R(x) é explicitamente definida em termos de c_j.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora simbólica (opcional como SymPy ou Mathematica)",
                                  "tips": "Comece com n=2 para simplicidade visual.",
                                  "learningObjective": "Compreender a base da aproximação espectral/galerkin.",
                                  "commonMistakes": "Confundir funções base φ_j com funções de ponderação w_i."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a condição dos resíduos ponderados",
                                  "subSteps": [
                                    "Escreva a condição ∫_Ω φ_i(x) R(x) dx = 0 para i=1 a n, onde φ_i são funções de ponderação.",
                                    "Substitua R(x) = L[∑ c_j φ_j] - f na integral.",
                                    "Expanda L[∑ c_j φ_j] = ∑ c_j L[φ_j], assumindo linearidade de L.",
                                    "Reescreva como ∑_{j=1}^n c_j ∫ φ_i L[φ_j] dx = ∫ φ_i f dx.",
                                    "Identifique os termos como elementos de uma matriz e vetor."
                                  ],
                                  "verification": "A equação deve estar na forma ∑ c_j A_{ij} = b_i, com A_{ij} e b_i claros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, software para integração simbólica",
                                  "tips": "Use propriedades de linearidade de L para evitar expansões desnecessárias.",
                                  "learningObjective": "Dominar a origem da condição de ortogonalidade do resíduo.",
                                  "commonMistakes": "Esquecer a linearidade de L ou inverter i e j nos índices."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz de Gram A e o vetor b",
                                  "subSteps": [
                                    "Defina A_{ij} = ∫_Ω φ_i(x) L[φ_j(x)] dx para i,j=1 a n.",
                                    "Calcule b_i = ∫_Ω φ_i(x) f(x) dx para i=1 a n.",
                                    "Verifique se A é simétrica quando φ_i = φ_j (propriedade de Gram).",
                                    "Monte explicitamente A e b para um caso n=2 com intervalos conhecidos.",
                                    "Discuta condições para A ser definida positiva (ex.: φ_j ortonormais)."
                                  ],
                                  "verification": "Escreva A e b em forma matricial explícita e confira simetria.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de cálculo ou MATLAB/SymPy para integrais",
                                  "tips": "Integre por partes se L envolver derivadas para simplificar.",
                                  "learningObjective": "Reconhecer A como matriz de Gram generalizada.",
                                  "commonMistakes": "Inverter índices A_{ij} vs A_{ji} ou esquecer limites de integração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar e resolver o sistema linear A c = b",
                                  "subSteps": [
                                    "Escreva o sistema na forma matricial A c = b, onde c = [c1, ..., cn]^T.",
                                    "Verifique invertibilidade de A (ex.: determinante ≠ 0).",
                                    "Resolva para c usando eliminação gaussiana ou decomposição LU.",
                                    "Substitua c de volta em u(x) para obter a aproximação final.",
                                    "Avalie a precisão comparando com solução exata se disponível."
                                  ],
                                  "verification": "c deve satisfazer A c = b com erro numérico < 10^{-6}.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora matricial ou Python/NumPy",
                                  "tips": "Use funções base ortogonais para diagonalizar A.",
                                  "learningObjective": "Aplicar resolução de sistemas lineares em contexto físico.",
                                  "commonMistakes": "Ignorar condições de contorno nas funções φ_j."
                                }
                              ],
                              "practicalExample": "Para -u'' = 1 em [0,1] com u(0)=u(1)=0, use φ1(x)=x(1-x), φ2(x)=x^2(1-x). Compute A_{ij}=∫ φ_i φ_j'' dx (após integração por partes), b_i=∫ φ_i dx, resolva A c = b para u(x) ≈ c1 φ1 + c2 φ2.",
                              "finalVerifications": [
                                "A é simétrica e definida positiva.",
                                "Todos elementos de A c coincidem com b dentro de tolerância numérica.",
                                "Aproximação u(x) satisfaz condições de contorno.",
                                "Resíduo R(x) é ortogonal a todas φ_i.",
                                "Energia do erro ∫ R^2 dx é mínima.",
                                "Solução converge ao refinar malha (aumentar n)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da forma A c = b (100% dos passos corretos).",
                                "Cálculo correto de integrais para A e b em exemplo numérico.",
                                "Identificação de propriedades de A (simetria, positividade).",
                                "Resolução correta do sistema com verificação de resíduos.",
                                "Explicação clara da relação com método de Galerkin.",
                                "Uso adequado de integração por partes para operadores diferenciais."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Matrizes de Gram e autovalores.",
                                "Cálculo: Integrais definidas e integração por partes.",
                                "Análise Numérica: Métodos de elementos finitos e spectral.",
                                "Física: Princípio dos trabalhos virtuais em mecânica.",
                                "Programação: Implementação em Python/NumPy para automação."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado no método dos elementos finitos para análise de estruturas (ex.: calcular deslocamentos em vigas sob carga via matriz de rigidez K c = F, onde K é análogo a A)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "37.1.1.3.3",
                            "name": "Analisar condicionamento via autovalores",
                            "description": "Avaliar a condicionamento da matriz de Gram através de seus autovalores e autofunções, relacionando com a estabilidade numérica da solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a formação e propriedades da matriz de Gram no método dos resíduos ponderados",
                                  "subSteps": [
                                    "Revise a formulação do método dos resíduos ponderados e identifique onde a matriz de Gram surge (integral do produto das funções de ponderação).",
                                    "Derive explicitamente a matriz de Gram G para funções de base lineares ou quadráticas em um elemento finito simples.",
                                    "Verifique se a matriz de Gram é simétrica e positiva definida, calculando seus elementos para um caso 1D.",
                                    "Discuta o papel da matriz de Gram na equação do sistema: K u = G^{-1} f.",
                                    "Compare com matrizes de massa em métodos de elementos finitos."
                                  ],
                                  "verification": "Escreva a expressão analítica da matriz de Gram para um elemento de comprimento h e confirme simetria.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de métodos numéricos (ex: Zienkiewicz), caderno de anotações, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Comece com funções de ponderação constantes para simplificar.",
                                  "learningObjective": "Entender o origem e propriedades espectrais iniciais da matriz de Gram.",
                                  "commonMistakes": "Confundir matriz de Gram com matriz de rigidez; ignorar dependência no malhamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular autovalores e autofunções da matriz de Gram",
                                  "subSteps": [
                                    "Construa uma matriz de Gram numérica para um problema de malha com 3-5 nós.",
                                    "Use software para decompor em autovalores: eig(G) em MATLAB ou numpy.linalg.eig em Python.",
                                    "Ordene os autovalores em ordem crescente e identifique λ_min e λ_max.",
                                    "Calcule as autofunções associadas e visualize-as graficamente se possível.",
                                    "Valide numericamente: verifique G v = λ v para o maior autovalor."
                                  ],
                                  "verification": "Liste todos autovalores e confirme que a soma dos autovalores equals trace(G).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (NumPy, SciPy), MATLAB ou Octave; matriz de exemplo salva em arquivo .csv.",
                                  "tips": "Use precisão dupla e evite malhas muito refinadas inicialmente.",
                                  "learningObjective": "Dominar o cálculo espectral da matriz de Gram.",
                                  "commonMistakes": "Erro numérico em malhas irregulares; não ordenar autovalores corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar o número de condicionamento usando autovalores",
                                  "subSteps": [
                                    "Defina cond(G) = λ_max / λ_min para matriz simétrica positiva definida.",
                                    "Calcule cond(G) para diferentes refinamentos de malha e registre valores.",
                                    "Compare cond(G) com normas: verifique se cond_2(G) ≈ ||G||_2 * ||G^{-1}||_2.",
                                    "Analise o espectro: identifique gaps entre autovalores.",
                                    "Teste sensibilidade: perturbe G ligeiramente e reavalie cond."
                                  ],
                                  "verification": "Gere tabela com cond(G) para h=1, 0.5, 0.1 e discuta tendência.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel ou Jupyter Notebook para tabulação; código Python pronto.",
                                  "tips": "Logaritme o cond para visualização em escala.",
                                  "learningObjective": "Quantificar condicionamento via espectro autovalor.",
                                  "commonMistakes": "Usar λ_min=0 (não positiva definida); ignorar autovalores próximos de zero."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar condicionamento com estabilidade numérica da solução",
                                  "subSteps": [
                                    "Simule solução do sistema G u = b com ruído em b e G.",
                                    "Meça erro relativo em u: ||u_exato - u_num|| / ||u_exato||.",
                                    "Correlacione erro com cond(G): espere erro amplificado por cond.",
                                    "Analise impacto das autofunções: modos mal condicionados dominam erro.",
                                    "Proponha mitigação: pré-condicionadores espectrais baseados em autovalores."
                                  ],
                                  "verification": "Plote erro vs log(cond(G)) e confirme relação linear.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Código Python com solvers lineares (scipy.linalg.solve); dados de benchmark.",
                                  "tips": "Use b como autofunção para testar modos específicos.",
                                  "learningObjective": "Conectar teoria espectral à prática numérica.",
                                  "commonMistakes": "Não adicionar ruído realista; confundir condicionamento com ill-condição total."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e generalizar para problemas reais",
                                  "subSteps": [
                                    "Resuma achados: como malha afeta cond(G)?",
                                    "Discuta implicações para convergência do método dos resíduos ponderados.",
                                    "Compare com outros métodos (Galerkin, colocation).",
                                    "Estenda para 2D/3D: preveja piora no condicionamento.",
                                    "Documente relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Escreva parágrafo explicando 'por que autovalores pequenos causam instabilidade'.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramenta de plotagem (Matplotlib); template de relatório.",
                                  "tips": "Use escalas log para spectros.",
                                  "learningObjective": "Aplicar análise a contextos de engenharia civil.",
                                  "commonMistakes": "Generalizar sem evidência; ignorar custos computacionais."
                                }
                              ],
                              "practicalExample": "Considere uma viga 1D de comprimento L=1 com malha uniforme de 4 elementos. Funções de base lineares geram G 4x4. Compute eig(G): λ = [0.083, 0.25, 0.417, 0.583], cond(G)=7.02. Adicione ruído 1e-10 em rhs: erro em u amplifica por ~7x, demonstrando instabilidade.",
                              "finalVerifications": [
                                "Autovalores calculados corretamente e ordenados.",
                                "Número de condicionamento matches fórmula espectral.",
                                "Simulação de erro numérico correlaciona com cond(G).",
                                "Identificados modos críticos (autofunções com λ pequeno).",
                                "Relatório inclui gráficos de espectro e erro.",
                                "Propostas de melhoria (ex: refinamento adaptativo) justificadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos autovalores (erro <1e-10).",
                                "Correta interpretação de cond(G) e relação com estabilidade (80% acerto em simulações).",
                                "Qualidade dos substeps executados (todos completos e documentados).",
                                "Uso adequado de software e validações numéricas.",
                                "Profundidade da análise de impacto em engenharia (conexões claras).",
                                "Clareza no relatório final com visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição espectral e propriedades de matrizes simétricas.",
                                "Análise Numérica: Estabilidade de solvers lineares e pré-condicionadores.",
                                "Programação Computacional: Implementação de eigendecomposição em Python/MATLAB.",
                                "Engenharia Estrutural: Aplicação em análise de elementos finitos para vigas/placas."
                              ],
                              "realWorldApplication": "Em simulações FEM para estruturas civis (pontes, edifícios), análise de cond(G) previne erros em predições de deslocamentos sob cargas dinâmicas, evitando colapsos por imprecisão numérica em softwares como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Método de Galerkin",
                    "description": "Caso especial onde funções de peso coincidem com as funções base da aproximação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Definição e Fundamentos do Método de Galerkin",
                        "description": "Conceito central do método de Galerkin como caso especial do método dos resíduos ponderados, onde as funções de peso são idênticas às funções base da aproximação.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Identificar a relação com o método dos resíduos ponderados",
                            "description": "Explicar como o método de Galerkin surge quando as funções de peso wi(x) coincidem com as funções base φi(x) na aproximação u(x) ≈ Σ ci φi(x), resultando na forma ∫ wi (L[u] - f) dx = 0 para i=1 a n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação geral do Método dos Resíduos Ponderados (MRP)",
                                  "subSteps": [
                                    "Leia a definição do MRP: para resolver Lu = f, aproximamos u ≈ u_h e impomos ∫ wi (L[u_h] - f) dx = 0 para i=1 a n.",
                                    "Identifique os componentes chave: operador L, funções de peso wi(x), domínio de integração.",
                                    "Anote exemplos de escolha de wi: constantes (collocation), delta de Dirac (subdomínio), etc.",
                                    "Compare com outros métodos de resíduos para destacar a generalidade do MRP.",
                                    "Escreva a equação em forma matricial genérica."
                                  ],
                                  "verification": "Escreva corretamente a equação fundamental do MRP em um papel ou documento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de métodos numéricos (ex: Zienkiewicz), caderno e caneta, acesso a notas de aula"
                                  ],
                                  "tips": "Use diagramas para visualizar as funções wi atuando como 'pesos' nos resíduos.",
                                  "learningObjective": "Compreender a estrutura matemática geral do MRP e seus parâmetros livres.",
                                  "commonMistakes": [
                                    "Confundir wi com funções base φi prematuramente",
                                    "Esquecer o sinal negativo no resíduo R = L[u_h] - f"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a aproximação trial function no contexto do MRP",
                                  "subSteps": [
                                    "Defina a aproximação u_h(x) ≈ Σ_{i=1}^n c_i φ_i(x), onde φ_i são funções base lineares/independentes.",
                                    "Substitua u_h na equação diferencial Lu_h = f + R, destacando o resíduo R.",
                                    "Discuta propriedades das φ_i: completude, continuidade, suporte local (ex: polinômios em elementos finitos).",
                                    "Calcule L[u_h] explicitamente para um operador simples como d²/dx².",
                                    "Verifique ortogonalidade ou propriedades das φ_i."
                                  ],
                                  "verification": "Substitua u_h na forma Lu_h e isole o resíduo R em uma equação escrita.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de matemática simbólica como Mathematica ou papel para cálculos",
                                    "Exemplos de funções base (hat functions)"
                                  ],
                                  "tips": "Comece com n=1 para simplicidade antes de generalizar para n.",
                                  "learningObjective": "Dominar a inserção da aproximação trial no resíduo do MRP.",
                                  "commonMistakes": [
                                    "Escolher φ_i não lineares independentes",
                                    "Ignorar condições de contorno na aproximação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar o caso especial: wi(x) = φ_i(x)",
                                  "subSteps": [
                                    "Escolha wi(x) = φ_i(x) na equação MRP: ∫ φ_i (L[Σ c_j φ_j] - f) dx = 0.",
                                    "Expanda o termo L[Σ c_j φ_j] e reorganize em forma Σ c_j ∫ φ_i L[φ_j] dx = ∫ φ_i f dx.",
                                    "Reconheça a simetria: matriz rígida K_{ij} = ∫ φ_i L[φ_j] dx e vetor de carga F_i = ∫ φ_i f dx.",
                                    "Compare com definições padrão do método de Galerkin.",
                                    "Teste com um exemplo numérico simples (n=2)."
                                  ],
                                  "verification": "Derive a forma matricial K c = F a partir da escolha wi=φ_i.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para verificação numérica",
                                    "Tabela de integrais pré-computadas"
                                  ],
                                  "tips": "Integre por partes se L for diferencial de segunda ordem para simetria.",
                                  "learningObjective": "Reconhecer como a escolha wi=φ_i gera a formulação de Galerkin.",
                                  "commonMistakes": [
                                    "Não expandir corretamente o operador L sobre a soma",
                                    "Confundir índices i e j na matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Consolidar a relação MRP-Galerkin e suas implicações",
                                  "subSteps": [
                                    "Resuma: Galerkin é MRP com wi=φ_i, levando a 'resíduos ortogonais às bases'.",
                                    "Discuta vantagens: simetria da matriz, convergência ótima para problemas elípticos.",
                                    "Compare com outros MRP (ex: Petrov-Galerkin onde wi ≠ φ_i).",
                                    "Aplique a um problema de engenharia civil simples (viga em flexão).",
                                    "Registre diferenças em precisão e estabilidade."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que Galerkin é um caso particular do MRP.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo introdutório sobre FEM",
                                    "Exemplo resolvido de viga"
                                  ],
                                  "tips": "Use analogia: wi como 'juízes' que pesam resíduos; em Galerkin, juízes=protagonistas.",
                                  "learningObjective": "Identificar e justificar a relação conceitual e matemática entre MRP e Galerkin.",
                                  "commonMistakes": [
                                    "Pensar que Galerkin é mais geral que MRP",
                                    "Ignorar que Galerkin requer φ_i no espaço de soluções"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere resolver -u''(x) = π² sin(πx) em [0,1] com u(0)=u(1)=0. Use n=2, φ1(x)=x(1-x)x, φ2(x)=x(1-x)(2x-1). No MRP geral, escolha wi arbitrárias. Defina wi=φi para obter Galerkin: resolva Kc=F onde K11=∫φ1(-φ1'')dx etc., obtendo coeficientes ci e u_h aproximada.",
                              "finalVerifications": [
                                "Escreva corretamente a condição MRP com wi=φi.",
                                "Derive a matriz rígida e vetor de carga para um operador dado.",
                                "Explique verbalmente a ortogonalidade dos resíduos em Galerkin.",
                                "Compare resultados numéricos de Galerkin vs. collocation para o exemplo prático.",
                                "Identifique quando usar Galerkin em problemas de engenharia."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática da relação wi=φi → Galerkin (90% correto).",
                                "Capacidade de expandir e reorganizar a integral MRP em forma matricial.",
                                "Compreensão conceitual: distinguir MRP geral de casos especiais.",
                                "Aplicação correta em exemplo numérico com erro <5%.",
                                "Explicação clara de vantagens do Galerkin (simetria, convergência).",
                                "Identificação de erros comuns em derivações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Espaços de Hilbert e ortogonalidade em análise funcional.",
                                "Programação: Implementação de FEM em Python (biblioteca FEniCS).",
                                "Física: Formulações variacionais em mecânica dos sólidos.",
                                "Engenharia de Software: Abstrações em solvers numéricos."
                              ],
                              "realWorldApplication": "No Método dos Elementos Finitos (MEF) para análise estrutural em engenharia civil, como simulação de tensões em pontes ou barragens, onde Galerkin garante matrizes simétricas eficientes para grandes sistemas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Formular a equação integral de Galerkin",
                            "description": "Derivar a equação ∫ φi (L[Σ cj φj] - f) dx = 0, levando ao sistema linear K c = F, onde Kij = ∫ φi L[φj] dx e Fi = ∫ φi f dx.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o problema diferencial e a aproximação de Galerkin",
                                  "subSteps": [
                                    "Identifique o operador diferencial L[u] = f no domínio Ω.",
                                    "Defina a solução exata u(x) e a aproximação u_h(x) = Σ c_j φ_j(x), onde φ_j são funções base.",
                                    "Explique o princípio de Galerkin: usar funções de teste φ_i iguais às funções base.",
                                    "Discuta condições de contorno essenciais e naturais.",
                                    "Esboce o domínio e as funções base simples (ex: lineares em 1D)."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o problema e a aproximação, confirmando que u_h está no espaço de funções finito-dimensional.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou software de desenho (ex: GeoGebra)",
                                    "Referência ao problema modelo (ex: -u''=f em [0,1])"
                                  ],
                                  "tips": "Comece com um problema 1D simples para visualização intuitiva.",
                                  "learningObjective": "Compreender a base teórica da aproximação de Galerkin.",
                                  "commonMistakes": [
                                    "Confundir funções base com funções de teste",
                                    "Ignorar condições de contorno no espaço de aproximação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a equação residual e multiplicar pelo peso de teste",
                                  "subSteps": [
                                    "Calcule o residual R[u_h] = L[Σ c_j φ_j] - f.",
                                    "Multiplique o residual pela função de peso φ_i: φ_i R[u_h] = 0.",
                                    "Expanda: φ_i (L[Σ c_j φ_j] - f) = 0.",
                                    "Verifique a simetria para problemas auto-adjuntos.",
                                    "Integre sobre o domínio: ∫_Ω φ_i (L[Σ c_j φ_j] - f) dx = 0."
                                  ],
                                  "verification": "Escreva a equação ∫ φ_i (L[u_h] - f) dx = 0 corretamente para um operador L simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Exemplo de EDP escrito (ex: equação de Poisson)"
                                  ],
                                  "tips": "Use integração por partes se L envolver derivadas de segunda ordem.",
                                  "learningObjective": "Derivar a forma integral ponderada do residual.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo no residual",
                                    "Não expandir a soma Σ c_j"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Discretizar a equação integral em componentes matriciais",
                                  "subSteps": [
                                    "Distribua a soma: Σ c_j ∫ φ_i L[φ_j] dx - ∫ φ_i f dx = 0.",
                                    "Defina K_{ij} = ∫_Ω φ_i L[φ_j] dx.",
                                    "Defina F_i = ∫_Ω φ_i f dx.",
                                    "Reescreva como Σ_j K_{ij} c_j = F_i para todo i.",
                                    "Verifique dimensionalidade: K é n x n se houver n funções base."
                                  ],
                                  "verification": "Monte explicitamente K e F para 2 funções base e um f simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (ex: SymPy, Mathematica)",
                                    "Tabela de funções base φ1, φ2"
                                  ],
                                  "tips": "Para L simétrico, K será simétrica, facilitando computação.",
                                  "learningObjective": "Transformar a equação integral em sistema linear K c = F.",
                                  "commonMistakes": [
                                    "Inverter índices de K_{ij}",
                                    "Confundir F_i com ∫ f φ_i ao invés de ∫ φ_i f"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar condições de contorno e finalizar o sistema",
                                  "subSteps": [
                                    "Identifique graus de liberdade afetados por condições essenciais.",
                                    "Imponha u_h nos nós de contorno via modificação de K e F.",
                                    "Para condições naturais, elas emergem automaticamente na formulação.",
                                    "Escreva o sistema final K c = F pronto para resolução.",
                                    "Teste com um exemplo numérico pequeno (n=2)."
                                  ],
                                  "verification": "Resolva o sistema para um caso teste e compare com solução exata aproximada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz 2x2 exemplo",
                                    "Solver linear simples (ex: Python NumPy)"
                                  ],
                                  "tips": "Use penalização ou eliminação para condições essenciais.",
                                  "learningObjective": "Completar a formulação considerando contornos reais.",
                                  "commonMistakes": [
                                    "Aplicar condições essenciais incorretamente, levando a singularidade em K",
                                    "Ignorar contribuições de contorno em F"
                                  ]
                                }
                              ],
                              "practicalExample": "Para -u'' = 1 em [0,1] com u(0)=0, u(1)=0, use φ1(x)=x, φ2(x)=x(1-x). Derive ∫ φ_i (-(Σ c_j φ_j)'' -1) dx =0, compute K_{ij}=∫ φ_i φ_j'' dx (após partes), obtenha K c = F e resolva c.",
                              "finalVerifications": [
                                "Escreve corretamente ∫ φ_i (L[Σ c_j φ_j] - f) dx = 0.",
                                "Define K_{ij} = ∫ φ_i L[φ_j] dx e F_i = ∫ φ_i f dx.",
                                "Montagem de K e F para um problema 1D com 2 DOFs.",
                                "Aplica condições de contorno essenciais corretamente.",
                                "Verifica simetria de K para operadores auto-adjuntos.",
                                "Resolve sistema pequeno e plota u_h vs u exata."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da equação integral (100% dos termos corretos).",
                                "Correta definição e indexação de K_{ij} e F_i.",
                                "Tratamento adequado de condições de contorno.",
                                "Exemplo prático resolvido sem erros numéricos.",
                                "Explicação clara do processo em termos verbais.",
                                "Identificação de propriedades como simetria ou positividade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e espaços de Sobolev.",
                                "Programação: Implementação em FEM codes (ex: FEniCS, deal.II).",
                                "Física: Modelagem de elastostática ou difusão.",
                                "Engenharia Mecânica: Análise de elementos finitos em estruturas.",
                                "Estatística: Erro de aproximação e convergência."
                              ],
                              "realWorldApplication": "Na engenharia civil, formulação de Galerkin é base para software de Elementos Finitos (ex: ANSYS) em análise de vigas, placas e fundações, simulando tensões em pontes ou edifícios sob cargas reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Selecionar funções base adequadas",
                            "description": "Escolher funções base φi(x) polinomiais ou outras que satisfaçam condições de contorno essenciais no domínio do problema de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o problema e identificar condições de contorno essenciais",
                                  "subSteps": [
                                    "Revise a formulação do problema de engenharia civil (ex: equação diferencial para deformação em vigas ou placas).",
                                    "Identifique condições de contorno essenciais (Dirichlet: deslocamentos prescritos) versus naturais (Neumann: forças ou momentos).",
                                    "Esboce o domínio geométrico e anote todas as condições essenciais nos limites.",
                                    "Classifique o problema quanto à ordem da derivada nas condições (ex: primeira ou segunda ordem).",
                                    "Documente as condições em uma tabela: posição, tipo e valor prescrito."
                                  ],
                                  "verification": "Confirme que todas as condições essenciais estão listadas corretamente e coincidem com o problema original.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Formulação matemática do problema, papel e lápis ou software de desenho (ex: GeoGebra).",
                                  "tips": "Destaque condições essenciais em negrito para evitar confusão com naturais.",
                                  "learningObjective": "Compreender e diferenciar condições de contorno essenciais no contexto do Método de Galerkin.",
                                  "commonMistakes": "Confundir condições essenciais com naturais, levando a funções base inadequadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o tipo de funções base apropriadas",
                                  "subSteps": [
                                    "Escolha polinômios se o domínio for simples e condições lineares (ex: φi(x) = x^i para condições em x=0).",
                                    "Considere funções trigonométricas ou exponenciais para domínios periódicos ou condições específicas.",
                                    "Avalie funções de Legendre ou Chebyshev para propriedades ortogonais em intervalos finitos.",
                                    "Verifique compatibilidade: funções devem ser C^k contínuas onde k é a ordem das derivadas na fraqueza.",
                                    "Liste 3-5 candidatos e justifique com base nas condições identificadas."
                                  ],
                                  "verification": "Lista de tipos de funções com justificativa escrita para cada, alinhada às condições.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabelas de funções ortogonais (livro de métodos numéricos ou online), calculadora simbólica (ex: Mathematica ou SymPy).",
                                  "tips": "Priorize funções que naturalmente satisfazem múltiplas condições para reduzir o número de termos.",
                                  "learningObjective": "Selecionar famílias de funções base compatíveis com o problema de engenharia civil.",
                                  "commonMistakes": "Escolher funções muito complexas desnecessariamente, complicando os cálculos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir funções base específicas φi(x) que satisfaçam as condições",
                                  "subSteps": [
                                    "Para cada condição essencial, imponha φi(limite) = 0 ou valor prescrito.",
                                    "Construa combinações lineares: φi(x) = ψi(x) - soma coeficientes para ajustar condições.",
                                    "Exemplo: para viga engastada em x=0 (u=0, u'=0), use φi(x) = x^2 (1 - a_i x + b_i x^2).",
                                    "Gere funções para i=1 a N (grau de aproximação), garantindo linear independência.",
                                    "Teste numericamente em pontos chave para confirmação."
                                  ],
                                  "verification": "Substitua φi(x) nas condições essenciais e verifique se todas são satisfeitas (erro < 1e-6).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de álgebra simbólica (MATLAB, Python com SymPy), planilha para coeficientes.",
                                  "tips": "Comece com o número mínimo de funções e adicione refinamento iterativamente.",
                                  "learningObjective": "Construir funções base personalizadas que incorporam condições de contorno.",
                                  "commonMistakes": "Esquecer uma condição, resultando em não-satisfação e instabilidade numérica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar propriedades das funções base selecionadas",
                                  "subSteps": [
                                    "Confirme completude: as funções devem aproximar soluções suaves no espaço de funções admissíveis.",
                                    "Verifique independência linear: matriz de Gram-Schmidt ou determinante não-zero.",
                                    "Avalie ortogonalidade ou condicionamento da matriz de rigidez esperada.",
                                    "Teste estabilidade: compute normas e cond numbers para diferentes N.",
                                    "Compare com soluções analíticas conhecidas em problemas teste."
                                  ],
                                  "verification": "Relatório com métricas: independência confirmada e condicionamento < 1e4.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software numérico (MATLAB, NumPy), exemplos de problemas benchmark.",
                                  "tips": "Use plotagens de φi(x) para visualmente inspecionar sobreposição mínima.",
                                  "learningObjective": "Garantir que as funções base sejam adequadas para convergência no Método de Galerkin.",
                                  "commonMistakes": "Funções linearmente dependentes, levando a matrizes singulares."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e validar a seleção final",
                                  "subSteps": [
                                    "Compile todas as φi(x) em uma tabela com expressões explícitas.",
                                    "Simule um problema simples com as funções e compare com solução exata.",
                                    "Ajuste se necessário baseado em erros de aproximação.",
                                    "Escreva relatório justificando a escolha para o contexto de engenharia civil.",
                                    "Prepare para integração no código de Galerkin."
                                  ],
                                  "verification": "Simulação bem-sucedida com erro relativo < 5% em problema teste.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código de implementação básica do Método de Galerkin, relatório template.",
                                  "tips": "Salve funções em formato simbólico para reutilização em problemas semelhantes.",
                                  "learningObjective": "Finalizar e validar a seleção de funções base para uso prático.",
                                  "commonMistakes": "Não documentar, dificultando reprodutibilidade."
                                }
                              ],
                              "practicalExample": "Em uma viga engastada em x=0 e livre em x=L sob carga uniforme, condições essenciais: u(0)=0, u'(0)=0. Selecione φ1(x)=x^2, φ2(x)=x^3, φ3(x)=x^2(x-L), verificando φi(0)=0, φi'(0)=0 para todos i.",
                              "finalVerifications": [
                                "Todas funções base satisfazem exatamente as condições essenciais nos limites.",
                                "Conjunto é linearmente independente (determinante da matriz de base ≠0).",
                                "Convergência observada ao aumentar N em problema teste.",
                                "Matriz de rigidez bem-condicionada (cond < 1e5).",
                                "Solução aproximada coincide com analítica em pelo menos 3 pontos chave.",
                                "Documentação completa com expressões e justificativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de condições essenciais (100% corretas).",
                                "Adequação das funções escolhidas (todas condições satisfeitas).",
                                "Justificativa técnica clara e concisa.",
                                "Verificações numéricas incluídas com resultados quantitativos.",
                                "Eficiência: número mínimo de funções para precisão desejada.",
                                "Integração com contexto de engenharia civil demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e espaços de Sobolev.",
                                "Física: Mecânica dos sólidos e condições de contorno reais.",
                                "Programação: Implementação em Python/MATLAB para validação.",
                                "Engenharia Mecânica: Similaridades em análise de elementos finitos."
                              ],
                              "realWorldApplication": "Na análise de estruturas civis como pontes ou edifícios, seleção correta de funções base no Método de Galerkin garante precisão em simulações pré-FEM, otimizando projetos contra falhas por vibrações ou cargas dinâmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Aplicação a Problemas de Valor de Contorno",
                        "description": "Implementação do método de Galerkin em problemas diferenciais de valor de contorno comuns na engenharia civil, como equações de difusão ou equilíbrio estrutural.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Discretizar problemas de valor de contorno",
                            "description": "Aplicar o método a um problema modelo como -u'' + u = f em [0,1] com u(0)=u(1)=0, usando funções base sinais ou polinomiais que incorporam condições de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema de valor de contorno e derivar a forma fraca",
                                  "subSteps": [
                                    "Escreva a equação diferencial -u'' + u = f em [0,1] com condições u(0)=u(1)=0.",
                                    "Multiplique por função teste v que satisfaz v(0)=v(1)=0 e integre por partes o termo u''.",
                                    "Obtenha a forma bilinear a(u,v) = ∫(u' v' + u v) dx = ∫ f v dx.",
                                    "Verifique que as condições de contorno são naturalmente incorporadas."
                                  ],
                                  "verification": "Forma fraca escrita corretamente: a(u,v) = (u',v') + (u,v) = (f,v), com normas L2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, calculadora, referência de EDP (ex: livro de Brenner-Scott).",
                                  "tips": "Lembre-se de que integração por partes é ∫ u'' v = -∫ u' v' + [u' v] boundaries, que some zero pelas BCs.",
                                  "learningObjective": "Dominar a transição de forma forte para fraca no método de Galerkin.",
                                  "commonMistakes": "Esquecer o sinal negativo na integração por partes ou não impor BCs nas funções teste."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar funções base que incorporam as condições de contorno",
                                  "subSteps": [
                                    "Escolha base senoidal: φ_i(x) = sin(i π x) para i=1 a N, que satisfaz φ_i(0)=φ_i(1)=0.",
                                    "Alternativa: base polinomial como φ_1(x)=x(1-x), φ_2(x)=x^2(1-x)^2, etc., ortogonalizados se necessário.",
                                    "Defina aproximação u_h(x) = Σ u_i φ_i(x), v_h = Σ v_j φ_j(x).",
                                    "Confirme que todas φ_i satisfazem BCs homogêneas."
                                  ],
                                  "verification": "Todas funções base φ_i(0)=0 e φ_i(1)=0, e são linearmente independentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, software de plotagem (Matlab/Python) para visualizar bases.",
                                  "tips": "Senos são ortogonais, facilitando matriz diagonal em alguns casos; teste com N=2 primeiro.",
                                  "learningObjective": "Entender escolha de espaços conformes para métodos de elementos finitos/Galerkin.",
                                  "commonMistakes": "Usar funções que não zeram nas extremidades, violando espaço de funções admissíveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar o sistema matricial via Galerkin",
                                  "subSteps": [
                                    "Compute K_ij = a(φ_j, φ_i) = ∫ φ_j' φ_i' dx + ∫ φ_j φ_i dx.",
                                    "Compute F_i = ∫ f φ_i dx.",
                                    "Use quadratura numérica (ex: Gauss-Legendre) para integrais se analítico difícil.",
                                    "Monte matriz K NxN e vetor F Nx1."
                                  ],
                                  "verification": "Matriz K simétrica e positiva definida (teste autovalores >0).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (NumPy/SciPy para integrais), ou Matlab; tabela de pontos Gauss.",
                                  "tips": "Para senos, muitas integrais são analíticas: ∫ sin(mπx) sin(nπx) = 0.5 δ_mn.",
                                  "learningObjective": "Implementar discretização Galerkin computacionalmente.",
                                  "commonMistakes": "Índices trocados em K_ij vs K_ji, ou esquecimento do termo de massa ∫ φ_j φ_i."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o sistema linear e pós-processar a solução",
                                  "subSteps": [
                                    "Resolva Ku = F usando solver direto (ex: lu_factor) ou iterativo.",
                                    "Avalie u_h(x) em pontos de grade: u_h(x_k) = Σ u_i φ_i(x_k).",
                                    "Plote u_h vs x e compare com solução exata se conhecida.",
                                    "Calcule erro L2: ||u - u_h|| / ||u|| < tolerância."
                                  ],
                                  "verification": "Solução u_h converge monotonicamente com N crescente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python/Matlab com solvers lineares, script pronto para plotagem.",
                                  "tips": "Use condnumber(K) para checar condicionamento; refine malha se mal-condicionado.",
                                  "learningObjective": "Aplicar solvers numéricos e validar aproximações.",
                                  "commonMistakes": "Solver falha por K singular (devido a base mal escolhida); normalizar bases."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e analisar a discretização",
                                  "subSteps": [
                                    "Verifique resíduos: || -u_h'' + u_h - f || pequeno em norma.",
                                    "Teste convergência: erro O(1/N^2) para base polinomial linear.",
                                    "Analise sensibilidade a f ou N.",
                                    "Documente código e resultados."
                                  ],
                                  "verification": "Resíduo global < 1e-6 e BCs satisfeitas numericamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código do passo anterior, ferramenta de diferenciação numérica.",
                                  "tips": "Use sympy para solução exata em casos simples para benchmark.",
                                  "learningObjective": "Avaliar precisão e robustez da discretização.",
                                  "commonMistakes": "Ignorar oscilações de Gibbs em bases senoidais de alta frequência."
                                }
                              ],
                              "practicalExample": "Para f(x) = π² sin(π x) + sin(π x), solução exata u(x)=sin(π x). Use N=4 bases sin(i π x), i=1..4. Monte K (analiticamente: K_ii=(i²π² +1)/2 ), resolva, plote u_h vs u exata, erro L2 ~1e-4.",
                              "finalVerifications": [
                                "Forma fraca corretamente derivada sem termos de contorno.",
                                "Matriz K simétrica positiva definida com autovalores positivos.",
                                "Solução u_h(0) ≈0 e u_h(1)≈0 dentro de 1e-10.",
                                "Resíduo R_h = -u_h'' + u_h - f tem norma L2 <1e-5.",
                                "Convergência observada ao dobrar N.",
                                "Código reproduzível compartilha resultados idênticos."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação da forma bilinear a(u,v).",
                                "Funções base adequadamente escolhidas e BCs incorporadas.",
                                "Matrriz K e F computados sem erros de integração.",
                                "Solução numérica precisa e validada contra exata.",
                                "Análise de erro e convergência documentada.",
                                "Clareza no código e explicações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Funcional e Espaços de Sobolev.",
                                "Programação: Implementação Numérica com Python/NumPy.",
                                "Física: Modelos de Elastostática em Mecânica dos Sólidos.",
                                "Engenharia: Elementos Finitos para Análise Estrutural."
                              ],
                              "realWorldApplication": "Discretização de equações de equilíbrio em vigas ou barras em Engenharia Civil, como calcular deflexões em uma viga simplesmente apoiada sob carga distribuída, essencial para projeto de estruturas seguras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Montar a matriz de rigidez e vetor de carga",
                            "description": "Calcular elementos da matriz Kij = ∫ φi (-d²/dx² + 1) φj dx e vetor Fi = ∫ φi f dx, integrando numericamente se necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e funções de base",
                                  "subSteps": [
                                    "Identifique o domínio do problema (ex: [0, L]) e condições de contorno.",
                                    "Escolha funções de base φi(x) lineares ou quadráticas adequadas (ex: φ1 = 1 - x/L, φ2 = x/L).",
                                    "Defina a função de carga f(x) e o operador diferencial (-d²/dx² + 1).",
                                    "Esboce as funções φi e f(x) graficamente para visualização.",
                                    "Verifique ortogonalidade ou propriedades das funções de base."
                                  ],
                                  "verification": "Lista completa de φi, f(x), domínio e esboços confirmados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)"
                                  ],
                                  "tips": "Comece com funções lineares para simplicidade em problemas 1D.",
                                  "learningObjective": "Compreender a discretização do problema via funções de base no método de Galerkin.",
                                  "commonMistakes": [
                                    "Escolher funções que não satisfazem condições de contorno essenciais.",
                                    "Ignorar o operador +1 no diferencial."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular integrais da matriz de rigidez Kij e vetor de carga Fi",
                                  "subSteps": [
                                    "Escreva Kij = ∫[0,L] φi(x) * (-d²φj/dx² + φj(x)) dx.",
                                    "Escreva Fi = ∫[0,L] φi(x) * f(x) dx.",
                                    "Identifique termos separáveis: ∫ φi (-d²φj/dx²) dx + ∫ φi φj dx.",
                                    "Use integração por partes para o termo de segunda derivada, aplicando condições de contorno.",
                                    "Anote limites de integração e funções explícitas."
                                  ],
                                  "verification": "Expressões matemáticas de Kij e Fi escritas corretamente com todos os termos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Tabela de integrais indefinidas"
                                  ],
                                  "tips": "Integre por partes: ∫ u dv = uv - ∫ v du, com u=φi, dv= -d²φj/dx² dx.",
                                  "learningObjective": "Derivar as formas fracas dos integrais no método de Galerkin.",
                                  "commonMistakes": [
                                    "Esquecer integração por partes ou condições de contorno nos termos de fronteira.",
                                    "Confundir φi e φj nos índices."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular integrais analiticamente ou numericamente",
                                  "subSteps": [
                                    "Para funções lineares, compute analiticamente cada ∫ φi φj dx e ∫ φi dφj/dx dx.",
                                    "Calcule derivadas: dφj/dx e d²φj/dx².",
                                    "Some contribuições para cada Kij (i,j=1 a n).",
                                    "Se analítico complexo, discretize o domínio em pontos de Gauss e use quadratura numérica.",
                                    "Implemente em código simples (ex: loop para soma de integrais trapezoidais)."
                                  ],
                                  "verification": "Valores numéricos de todos Kij e Fi calculados e tabulados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para integrais numéricas",
                                    "Folha de cálculo Excel"
                                  ],
                                  "tips": "Para n=2, matriz 2x2: calcule K11, K12, K21, K22 explicitamente.",
                                  "learningObjective": "Executar computação precisa de integrais elementares.",
                                  "commonMistakes": [
                                    "Erros de sinal na segunda derivada.",
                                    "Usar limites errados na integração numérica."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e verificar a matriz de rigidez K e vetor F",
                                  "subSteps": [
                                    "Preencha a matriz K simétrica com elementos Kij.",
                                    "Monte vetor F com componentes Fi.",
                                    "Verifique simetria de K (Kij = Kji).",
                                    "Confira unidades consistentes (ex: K em N/m, F em N).",
                                    "Teste com caso conhecido (ex: f(x)=constante) para valores esperados."
                                  ],
                                  "verification": "Matriz K e vetor F montados, simétricos e com valores plausíveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha ou código Python para matriz",
                                    "Exemplo resolvido de referência"
                                  ],
                                  "tips": "Use NumPy para montagem automática em código.",
                                  "learningObjective": "Assemblar sistema discreto pronto para resolução.",
                                  "commonMistakes": [
                                    "Índices trocados ao preencher matriz.",
                                    "Ignorar simetria esperada."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e preparar para resolução do sistema",
                                  "subSteps": [
                                    "Aplique condições de contorno essenciais modificando K e F.",
                                    "Verifique se K é definida positiva (autovalores >0).",
                                    "Compare com solução analítica para problema simples.",
                                    "Documente todos os passos em relatório.",
                                    "Salve matriz e vetor para solver linear."
                                  ],
                                  "verification": "Sistema validado contra caso teste, relatório completo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Solver de autovalores (MATLAB eig ou Python numpy.linalg)",
                                    "Problema teste conhecido"
                                  ],
                                  "tips": "Para validação, use equação -u'' + u = 1 com u(0)=u(1)=0.",
                                  "learningObjective": "Garantir robustez da montagem antes da solução.",
                                  "commonMistakes": [
                                    "Não aplicar BCs corretamente, levando a singularidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma barra de comprimento L=1m com f(x)=1 (carga uniforme), funções lineares φ1=1-x, φ2=x. Compute K = [[2/3, -1/2], [-1/2, 2/3]] + [[1/3, 1/6], [1/6, 1/3]] e F=[1/3, 1/3], usando integração exata.",
                              "finalVerifications": [
                                "Matriz K é simétrica e positiva definida.",
                                "Vetor F corresponde à projeção de f nas funções de base.",
                                "Valores coincidem com cálculo manual para n=2.",
                                "Integração numérica converge para analítica com mais pontos.",
                                "Sistema resolvido dá deslocamentos coerentes com física.",
                                "Relatório documenta todos os elementos computados."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos integrais (erro <1%).",
                                "Correta aplicação de integração por partes e BCs.",
                                "Simetria e propriedades de K verificadas.",
                                "Uso apropriado de métodos numéricos quando necessário.",
                                "Clareza na documentação e código.",
                                "Validação contra caso conhecido."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e métodos numéricos de quadratura.",
                                "Programação: Implementação em Python/MATLAB para automação.",
                                "Física: Equações diferenciais em mecânica estrutural.",
                                "Engenharia de Software: Modularidade no código de montagem FEM."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos (FEM) para estruturas civis, como vigas ou barramento sob cargas distribuídas, formando a base para solvers comerciais como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Resolver o sistema linear resultante",
                            "description": "Usar métodos numéricos para resolver K c = F e reconstruir a solução aproximada u(x) ≈ Σ ci φi(x), validando com soluções exatas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o sistema linear Kc = F",
                                  "subSteps": [
                                    "Revise a discretização do problema de valor de contorno usando funções base φi(x).",
                                    "Calcule os elementos da matriz de rigidez K_ij = ∫ φi' φj' dx para o operador diferencial.",
                                    "Calcule o vetor de carga F_i = ∫ φi f dx, onde f é a função fonte.",
                                    "Aplique condições de contorno essenciais ajustando K e F adequadamente.",
                                    "Verifique simetria e positiva definitude de K para problemas elípticos."
                                  ],
                                  "verification": "Confirme que K é simétrica e definida positiva; dimensões de K e F coincidem com o número de graus de liberdade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e calculadora; software como MATLAB ou Python (SymPy/NumPy) para integrais simbólicas.",
                                  "tips": "Use funções base lineares ou quadráticas simples para testes iniciais para facilitar cálculos manuais.",
                                  "learningObjective": "Montar corretamente a matriz K e vetor F a partir da formulação de Galerkin.",
                                  "commonMistakes": "Esquecer de integrar por partes corretamente; não aplicar condições de contorno levando a sistemas singulares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver o sistema linear Kc = F numericamente",
                                  "subSteps": [
                                    "Escolha um solver apropriado: eliminação de Gauss para matrizes pequenas, decomposição LU ou iterativos (CG) para grandes.",
                                    "Implemente ou use função built-in para fatorar K = LU ou resolver diretamente.",
                                    "Execute a resolução para obter os coeficientes c.",
                                    "Verifique resíduos r = Kc - F com norma ||r|| < 1e-10.",
                                    "Analise condicionamento de K usando cond(K) para avaliar estabilidade."
                                  ],
                                  "verification": "Norma do resíduo ||Kc - F|| / ||F|| < 1e-8; solução converge em poucas iterações se iterativo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy (scipy.linalg.solve); MATLAB.",
                                  "tips": "Pré-condicione K se mal-condicionada; use solvers esparsos para eficiência em problemas reais.",
                                  "learningObjective": "Aplicar métodos numéricos robustos para resolver sistemas lineares oriundos de métodos variacionais.",
                                  "commonMistakes": "Usar solvers inadequados para matrizes não-simétricas; ignorar escalonamento levando a erros numéricos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconstruir a solução aproximada u(x) ≈ Σ ci φi(x)",
                                  "subSteps": [
                                    "Defina uma malha de pontos de avaliação x_eval no domínio.",
                                    "Para cada x_eval, compute u_approx(x) = sum_{i=1}^N c_i * φ_i(x).",
                                    "Implemente funções base φi(x) explicitamente (ex: hat functions para lineares).",
                                    "Plote ou tabule u_approx(x) para visualização.",
                                    "Calcule derivadas ou outras quantidades de interesse se necessário."
                                  ],
                                  "verification": "u_approx satisfaz condições de contorno: u(0) ≈ 0, u(1) ≈ 0 dentro de tolerância.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com Matplotlib para plotagem; planilha Excel para casos simples.",
                                  "tips": "Vetorialize a soma em código para eficiência; use meshgrid para avaliação 2D se extensão.",
                                  "learningObjective": "Reconstruir soluções aproximadas a partir de coeficientes de Galerkin.",
                                  "commonMistakes": "Erro na definição de suporte das funções base levando a sobreposições incorretas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a solução aproximada com a exata",
                                  "subSteps": [
                                    "Obtenha ou derive a solução exata u_exact(x) para o problema modelo.",
                                    "Compute erro em norma L2: ∫ (u_approx - u_exact)^2 dx ≈ 1/N para convergência.",
                                    "Calcule erro máximo ||u_approx - u_exact||_∞ em pontos de avaliação.",
                                    "Plote u_approx vs u_exact e resíduos.",
                                    "Refine a malha (aumente N) e verifique ordem de convergência esperada (O(h^2) para lineares)."
                                  ],
                                  "verification": "Erro L2 diminui com refinamento; convergência observada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem; solução analítica conhecida.",
                                  "tips": "Use problemas com soluções exatas conhecidas como -u''=π² sin(πx), u(0)=u(1)=0.",
                                  "learningObjective": "Avaliar precisão e convergência da aproximação de Galerkin.",
                                  "commonMistakes": "Comparar em pontos inadequados; ignorar normalização de erros."
                                }
                              ],
                              "practicalExample": "Para -u''(x) = π² sin(πx) em [0,1], u(0)=u(1)=0, use 3 funções base lineares. K = [[2,-1,0],[-1,2,-1],[0,-1,2]]/h, resolva para c, reconstrua u(x) e compare com u_exact=sin(πx). Erro L2 ~0.01.",
                              "finalVerifications": [
                                "Kc = F satisfeito com resíduo <1e-10.",
                                "u_approx(0)=u_approx(1)=0 dentro de 1e-6.",
                                "Erro L2 < 5% da norma de u_exact.",
                                "Convergência observada ao dobrar número de elementos.",
                                "Visualização gráfica confirma similaridade com exata.",
                                "Condicionamento de K <1e6."
                              ],
                              "assessmentCriteria": [
                                "Correção na montagem de K e F (peso 25%).",
                                "Solução numérica precisa e eficiente (peso 25%).",
                                "Reconstrução suave de u(x) (peso 20%).",
                                "Validação quantitativa com erros reportados (peso 20%).",
                                "Análise de convergência e discussão (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/MATLAB.",
                                "Álgebra Linear: Solvers e propriedades de matrizes.",
                                "Física/Mecânica: Modelagem de equações diferenciais em estruturas.",
                                "Estatística: Análise de erros e convergência."
                              ],
                              "realWorldApplication": "Em engenharia civil, resolve sistemas de elementos finitos para análise de vigas, placas e fundações, prevendo deformações e tensões em estruturas reais sob cargas distribuídas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Propriedades e Análise Numérica",
                        "description": "Análise de condicionamento, matriz de Gram e estabilidade do método de Galerkin em contextos computacionais para engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Analisar a matriz de Gram",
                            "description": "Relacionar a matriz de Gram Gij = ∫ φi φj dx com o condicionamento do sistema, identificando ortogonalidade das funções base para melhorar a estabilidade numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e o propósito da matriz de Gram",
                                  "subSteps": [
                                    "Revise a definição matemática: Gij = ∫ φi(x) φj(x) dx sobre o domínio.",
                                    "Identifique o contexto no método de Galerkin: matriz associada ao produto interno das funções base.",
                                    "Explique verbalmente o papel da matriz de Gram na formulação do sistema Ax = b.",
                                    "Diferencie produto escalar contínuo de discreto em aproximações numéricas.",
                                    "Discuta propriedades simétricas e positivas definidas da matriz G."
                                  ],
                                  "verification": "Escreva a fórmula da matriz de Gram e explique seu papel em uma frase para um colega.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz)",
                                    "Folha de papel e calculadora",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Visualize o produto interno como uma medida de 'similaridade' entre funções base.",
                                  "learningObjective": "Dominar a definição e o significado físico-matemático da matriz de Gram no contexto de Galerkin.",
                                  "commonMistakes": [
                                    "Confundir com matriz de rigidez",
                                    "Ignorar limites de integração",
                                    "Esquecer normalização das funções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de Gram para funções base dadas",
                                  "subSteps": [
                                    "Escolha funções base simples (ex: φ1 = 1, φ2 = x em [0,1]).",
                                    "Calcule cada elemento Gij analiticamente: ∫ φi φj dx.",
                                    "Monte a matriz G completa e verifique simetria (Gij = Gji).",
                                    "Implemente o cálculo numericamente usando quadratura gaussiana.",
                                    "Compare resultados analíticos e numéricos para validar."
                                  ],
                                  "verification": "Produza a matriz G para φ1=x, φ2=1-x em [0,1] e confirme det(G) > 0.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou MATLAB/Python",
                                    "Tabela de integrais indefinidas",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use simetria para calcular apenas triângulo superior e transpor.",
                                  "learningObjective": "Capacitar o cálculo explícito da matriz de Gram para bases polinomiais.",
                                  "commonMistakes": [
                                    "Erros em limites de integração",
                                    "Não normalizar domínio",
                                    "Cálculo incorreto de integrais duplas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o condicionamento da matriz de Gram",
                                  "subSteps": [
                                    "Calcule autovalores e autovetores de G usando software.",
                                    "Defina e compute o número de condicionamento cond(G) = λ_max / λ_min.",
                                    "Interprete valores: cond ≈1 (bem condicionado), cond >>1 (mal condicionado).",
                                    "Varie as funções base e observe impacto no cond(G).",
                                    "Discuta implicações para estabilidade numérica na solução do sistema."
                                  ],
                                  "verification": "Para uma G mal condicionada, identifique λ_min e explique risco de ill-conditioning.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ou Python (NumPy/Eigen)",
                                    "Documentação de svd() ou eig()"
                                  ],
                                  "tips": "Use decomposição SVD para condicionamento robusto em matrizes não simétricas.",
                                  "learningObjective": "Relacionar condicionamento da matriz de Gram com estabilidade do solver linear.",
                                  "commonMistakes": [
                                    "Confundir cond com traço",
                                    "Ignorar autovalores negativos",
                                    "Não escalar matriz adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar ortogonalidade das funções base e seus benefícios",
                                  "subSteps": [
                                    "Defina ortogonalidade: ∫ φi φj dx = 0 para i ≠ j, levando G = I (identidade).",
                                    "Compare G para bases não-ortogonais (ex: monomiais) vs. ortogonais (ex: Legendre).",
                                    "Demonstre que ortogonalidade implica cond(G)=1 (ideal).",
                                    "Discuta pré-condicionadores inspirados em Gram para melhorar estabilidade.",
                                    "Aplique em um exemplo numérico: resolva sistema com e sem ortogonalidade."
                                  ],
                                  "verification": "Construa G ortogonal e confirme cond(G)=1; resolva Ax=b sem erros numéricos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Funções de Legendre tabuladas",
                                    "Código Python para integração e eigen"
                                  ],
                                  "tips": "Escolha bases ortogonais weighadas para domínios específicos em Engenharia Civil.",
                                  "learningObjective": "Compreender como ortogonalidade otimiza condicionamento e estabilidade numérica.",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade com normalização",
                                    "Usar bases ortogonais sem peso",
                                    "Ignorar dependência do domínio"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um elemento finito 1D para barra em Engenharia Civil, use φ1 = 1 - ξ, φ2 = ξ (ξ em [0,1]). Calcule G = [[1/3, 1/6], [1/6, 1/3]], cond(G)≈3. Substitua por funções Legendre ortogonais: G=I, cond=1, reduzindo erros em simulações de deformação.",
                              "finalVerifications": [
                                "Calcular corretamente G para bases polinomiais lineares e quadráticas.",
                                "Avaliar cond(G) e classificar como bem/mal condicionado.",
                                "Explicar verbalmente o impacto da ortogonalidade na estabilidade.",
                                "Implementar código para análise automática de G.",
                                "Identificar bases ortogonais adequadas para problemas civis.",
                                "Comparar soluções numéricas com/s em bases não-ortogonais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos analíticos de G (erro <1%).",
                                "Interpretação correta de cond(G) e riscos numéricos.",
                                "Uso apropriado de ferramentas computacionais.",
                                "Capacidade de sugerir melhorias via ortogonalidade.",
                                "Clareza na explicação de relações com estabilidade.",
                                "Aplicação contextual a problemas de Engenharia Civil."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores, SVD e condicionamento de matrizes.",
                                "Cálculo Numérico: integração quadratura e estabilidade de solvers.",
                                "Física/Mecânica: produtos internos em espaços de Hilbert para FEM.",
                                "Programação: implementação em Python/MATLAB para análise matricial.",
                                "Otimização: pré-condicionadores baseados em Gram-Schmidt."
                              ],
                              "realWorldApplication": "Em simulações FEM de estruturas civis (ex: pontes, barragens), analisar G melhora precisão em malhas irregulares, reduzindo tempo computacional e erros de arredondamento em softwares como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Avaliar condicionamento e autovalores",
                            "description": "Calcular o número de condicionamento de K e discutir autovalores para prever precisão da solução em problemas de grande escala.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de condicionamento e autovalores",
                                  "subSteps": [
                                    "Defina o número de condicionamento cond(K) = ||K|| * ||K^{-1}|| e sua relação com a sensibilidade da solução.",
                                    "Explique autovalores como raízes do polinômio característico det(K - λI) = 0.",
                                    "Discuta como a razão entre o maior e menor autovalor (cond(K)) afeta a precisão numérica.",
                                    "Revise propriedades de matrizes simétricas positivas definidas em contextos de Galerkin.",
                                    "Identifique impactos em problemas de grande escala, como ill-conditioning."
                                  ],
                                  "verification": "Resuma os conceitos em um parágrafo coerente e responda a 3 perguntas de verificação conceitual.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Álgebra Linear (ex: Strang), notas de aula sobre Método de Galerkin.",
                                  "tips": "Use analogias como 'condicionamento alto é como uma estrutura instável que amplifica erros pequenos'.",
                                  "learningObjective": "Dominar definições e relações teóricas entre condicionamento, autovalores e estabilidade numérica.",
                                  "commonMistakes": "Confundir cond(K) com autovalores absolutos; ignorar normalização de normas (ex: 2-norma)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o número de condicionamento de uma matriz K",
                                  "subSteps": [
                                    "Construa ou obtenha uma matriz K de exemplo de um problema de Galerkin (ex: 4x4 para uma treliça simples).",
                                    "Calcule ||K||_2 usando norma espectral (maior autovalor de K^T K, mas para simétrica é sqrt(λ_max)).",
                                    "Inverta K numericamente e calcule ||K^{-1}||_2.",
                                    "Multiplique para obter cond(K) e compare com razão λ_max / λ_min.",
                                    "Teste com diferentes malhas para observar variação."
                                  ],
                                  "verification": "Produza cálculo exato para matriz 3x3 e cond(K) < 10^6 indica bom condicionamento.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy (np.linalg.cond), MATLAB, calculadora matricial.",
                                  "tips": "Sempre use norma 2 para problemas de autovalores; verifique simetria de K.",
                                  "learningObjective": "Executar cálculo preciso de cond(K) usando software e interpretação manual.",
                                  "commonMistakes": "Usar norma errada (ex: Frobenius em vez de 2); não verificar se K é singular."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar autovalores e seus espectros",
                                  "subSteps": [
                                    "Calcule autovalores e autovetores de K usando decomposição espectral.",
                                    "Identifique λ_max e λ_min; plote espectro de autovalores.",
                                    "Avalie distribuição (clusterizada ou espalhada) para prever ill-conditioning.",
                                    "Discuta modos de vibração ou rigidez associados a autovetores.",
                                    "Compare com refinamento de malha em problemas FEM."
                                  ],
                                  "verification": "Gere plot de autovalores e explique por que λ_min pequeno causa problemas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python (np.linalg.eig), MATLAB eig(), papel para esboços.",
                                  "tips": "Autovalores devem ser positivos para K positiva definida; ordene-os para análise.",
                                  "learningObjective": "Interpretar espectro de autovalores para diagnosticar condicionamento.",
                                  "commonMistakes": "Interpretar autovetores sem normalização; ignorar autovalores complexos (não ocorrem em simétricas reais)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prever precisão da solução em problemas de grande escala",
                                  "subSteps": [
                                    "Simule um problema grande (n=100) com K mal condicionada via refinamento h.",
                                    "Calcule erro relativo ||x - x_exact|| / ||x_exact|| vs cond(K).",
                                    "Discuta pré-condicionadores (ex: diagonal) para reduzir cond(K).",
                                    "Avalie impacto em iterações de solucionadores (ex: CG no Galerkin).",
                                    "Conclua com recomendações para engenharia civil (malha adaptativa)."
                                  ],
                                  "verification": "Demonstre que cond(K) > 10^12 leva a perda de precisão em double precision.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python/SciPy para FEM simples (scipy.sparse.linalg), dados de malha estrutural.",
                                  "tips": "Use sparse matrices para escala; monitore resíduos em iterações.",
                                  "learningObjective": "Aplicar análise para prever e mitigar erros numéricos em simulações reais.",
                                  "commonMistakes": "Subestimar crescimento de cond(K) com refinamento (O(h^{-2})); não considerar arredondamento."
                                }
                              ],
                              "practicalExample": "Em uma análise de treliça 2D com 10 nós (K 20x20), calcule cond(K)=10^5 devido a λ_min=10^{-3}, simulando erro amplificado de 10^{-5} (máquina) para 1% em deslocamentos, resolvido com pré-condicionador diagonal reduzindo cond para 10^3.",
                              "finalVerifications": [
                                "Calcula cond(K) corretamente para matriz 5x5 de exemplo.",
                                "Interpreta espectro de autovalores e identifica causa de ill-conditioning.",
                                "Prevê erro relativo > cond(K) * eps_machine.",
                                "Sugere pelo menos 2 estratégias para melhorar condicionamento.",
                                "Aplica análise a um problema FEM simples de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos de cond(K) e autovalores (erro < 1%).",
                                "Profundidade na discussão de implicações para precisão (cobertura de bounds teóricos).",
                                "Uso correto de software com código reproduzível e plots claros.",
                                "Identificação de erros comuns e soluções em contextos de grande escala.",
                                "Conexão explícita com Método de Galerkin e estabilidade.",
                                "Recomendações práticas viáveis para engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição espectral e normas matriciais.",
                                "Programação Numérica: Uso de bibliotecas SciPy/NumPy para eigendecomposição esparsa.",
                                "Física/Estruturas: Modos de vibração ligados a autovetores de K.",
                                "Estatística: Análise de componentes principais (PCA) via autovalores."
                              ],
                              "realWorldApplication": "Em simulações FEM de pontes ou barragens via Método de Galerkin, avaliar cond(K) previne falhas numéricas em malhas finas (milhões DOFs), garantindo precisão em análises sísmicas ou de colapso, otimizando tempo computacional com pré-condicionadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Matriz de Gram",
                    "description": "Matriz resultante dos produtos internos das funções base, usada para resolver o sistema linear.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Produtos Internos das Funções Base",
                        "description": "Conceito fundamental que define o produto interno entre funções base no contexto do método dos resíduos ponderados, essencial para a formação da matriz de Gram.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Definir produto interno em espaços de funções",
                            "description": "Explicar o produto interno <φ_i, φ_j> = ∫ φ_i(x) φ_j(x) w(x) dx, onde w(x) é a função peso, e sua importância na ortogonalidade das funções base no método dos resíduos ponderados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de produto interno em espaços vetoriais finitos",
                                  "subSteps": [
                                    "Revise a definição de produto interno em espaços euclidianos: <u,v> = soma u_i v_i.",
                                    "Identifique propriedades: simetria, linearidade e definitude positiva.",
                                    "Discuta ortogonalidade: <u,v> = 0 implica vetores ortogonais.",
                                    "Exemplo simples com vetores R^2.",
                                    "Relacione com norma: ||u|| = sqrt(<u,u>)."
                                  ],
                                  "verification": "Escreva as propriedades do produto interno e dê um exemplo de vetores ortogonais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, notas de álgebra linear",
                                  "tips": "Use analogias geométricas como ângulo entre vetores para fixar o conceito.",
                                  "learningObjective": "Entender as bases do produto interno como generalização do produto escalar.",
                                  "commonMistakes": "Confundir com produto vetorial ou esquecer a definitude positiva."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Generalizar o produto interno para espaços de funções infinitos",
                                  "subSteps": [
                                    "Defina espaço de funções L2: funções quadrado-integráveis.",
                                    "Apresente produto interno padrão: <f,g> = ∫ f(x) g(x) dx sobre domínio Ω.",
                                    "Verifique propriedades no contexto contínuo.",
                                    "Discuta convergência da integral.",
                                    "Exemplo com funções constantes."
                                  ],
                                  "verification": "Escreva a fórmula para L2 e prove simetria para funções simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora, software simbólico como Mathematica ou papel para integrais",
                                  "tips": "Pense em funções como 'vetores infinitos' com coordenadas contínuas.",
                                  "learningObjective": "Estender o conceito discreto para o contínuo em espaços funcionais.",
                                  "commonMistakes": "Ignorar condições de integrabilidade ou limites do domínio."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar a função peso w(x) no produto interno",
                                  "subSteps": [
                                    "Explique o papel de w(x): peso para enfatizar regiões do domínio.",
                                    "Defina fórmula completa: <φ_i, φ_j> = ∫ φ_i(x) φ_j(x) w(x) dx.",
                                    "Discuta escolhas comuns de w(x), ex: w(x)=1 (caso padrão).",
                                    "Calcule exemplo numérico simples.",
                                    "Verifique propriedades com w(x)."
                                  ],
                                  "verification": "Calcule <φ_i, φ_j> para funções base polinomiais com w(x) dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, calculadora, tabela de integrais",
                                  "tips": "w(x) é como 'métrica' no espaço funcional; teste com w(x)>0 sempre.",
                                  "learningObjective": "Dominar a definição ponderada e seu impacto na métrica.",
                                  "commonMistakes": "Esquecer w(x) na integral ou usar w(x)<0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com ortogonalidade e método dos resíduos ponderados",
                                  "subSteps": [
                                    "Defina ortogonalidade: <φ_i, φ_j> = 0 para i≠j.",
                                    "Explique matriz de Gram: G_ij = <φ_i, φ_j>.",
                                    "Descreva uso no método dos resíduos ponderados para aproximar soluções de EDEs.",
                                    "Discuta importância: bases ortogonais simplificam projeções.",
                                    "Exemplo em problema de engenharia civil simples."
                                  ],
                                  "verification": "Construa matriz de Gram para 2 funções base e identifique ortogonalidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Papel, software como MATLAB para matrizes",
                                  "tips": "Ortogonalidade diagonaliza a matriz, facilitando inversões.",
                                  "learningObjective": "Compreender aplicação prática na formação da matriz de rigidez.",
                                  "commonMistakes": "Confundir resíduos ponderados com mínimos quadrados sem peso."
                                }
                              ],
                              "practicalExample": "Considere funções base φ1(x) = 1, φ2(x) = x no domínio [0,1] com w(x) = 1. Então <φ1,φ1> = ∫0^1 1*1*1 dx = 1; <φ1,φ2> = ∫0^1 1*x*1 dx = 0.5; <φ2,φ2> = ∫0^1 x*x*1 dx = 1/3. Matriz de Gram: [[1, 0.5], [0.5, 1/3]].",
                              "finalVerifications": [
                                "Escrever corretamente a fórmula <φ_i, φ_j> = ∫ φ_i(x) φ_j(x) w(x) dx.",
                                "Calcular produto interno para funções polinomiais simples.",
                                "Construir matriz de Gram 2x2.",
                                "Explicar verbalmente o papel de w(x) na ortogonalidade.",
                                "Identificar bases ortogonais via produto interno nulo.",
                                "Relacionar com método dos resíduos ponderados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula e notação matemática.",
                                "Correção em cálculos de integrais ponderadas.",
                                "Compreensão conceitual de propriedades e ortogonalidade.",
                                "Capacidade de construir matriz de Gram.",
                                "Explicação clara da importância em métodos numéricos.",
                                "Identificação de erros comuns em exemplos."
                              ],
                              "crossCurrularConnections": [
                                "Álgebra Linear: Produto escalar e bases ortogonais.",
                                "Análise Numérica: Quadratura gaussiana para integrais.",
                                "Física: Espaços de Hilbert em mecânica quântica.",
                                "Engenharia Computacional: Elementos finitos e Galerkin."
                              ],
                              "realWorldApplication": "No método dos resíduos ponderados para soluções aproximadas de equações diferenciais em engenharia civil, como análise de vigas e placas, onde o produto interno define a matriz de rigidez, permitindo simulações precisas de deformações estruturais sob cargas reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Calcular produtos internos numericamente",
                            "description": "Aplicar integração numérica (ex.: quadratura de Gauss) para computar elementos <φ_i, φ_j> em problemas de valor inicial ou de contorno da engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o produto interno e selecionar método de integração numérica",
                                  "subSteps": [
                                    "Identifique as funções base φ_i(x) e φ_j(x) e o peso w(x) no domínio [a,b].",
                                    "Escolha o método de quadratura, como Gauss-Legendre com n pontos, baseado na precisão necessária.",
                                    "Determine o número de pontos n para convergência adequada (ex.: n=3-5 para polinômios baixos).",
                                    "Mapeie o intervalo [a,b] para [-1,1] se necessário usando transformação linear.",
                                    "Documente a fórmula aproximada: <φ_i, φ_j> ≈ Σ w_k φ_i(ξ_k) φ_j(ξ_k) |Jacobiano|."
                                  ],
                                  "verification": "Confirme que o método escolhido e os parâmetros estão documentados e o mapeamento está correto comparando com integral exata simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de quadratura de Gauss (tabelas de pontos/pesos), software como MATLAB/Python (opcional), papel e lápis.",
                                  "tips": "Comece com n baixo para testes rápidos e aumente para precisão.",
                                  "learningObjective": "Compreender a discretização do produto interno via integração numérica.",
                                  "commonMistakes": "Esquecer o peso w(x) ou o Jacobiano no mapeamento de intervalos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter pontos e pesos de Gauss",
                                  "subSteps": [
                                    "Consulte tabela ou compute pontos ξ_k e pesos w_k para o número de pontos escolhido (ex.: n=3: ξ=[-√(3/5),0,√(3/5)], w=[5/9,8/9,5/9]).",
                                    "Aplique transformação afim x = (b-a)/2 * ξ + (a+b)/2 para mapear para [a,b].",
                                    "Atualize pesos: w_k' = w_k * (b-a)/2.",
                                    "Verifique simetria e soma dos pesos ≈ comprimento do intervalo.",
                                    "Armazene em arrays ou tabela para uso posterior."
                                  ],
                                  "verification": "Some os pesos transformados e confirme que igualam (b-a); teste com função constante 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabelas de Gauss-Legendre (online ou livro), calculadora ou Python (numpy.polynomial.legendre.leggauss).",
                                  "tips": "Use bibliotecas prontas para evitar erros de cálculo manual.",
                                  "learningObjective": "Dominar a preparação de nós e pesos para quadratura.",
                                  "commonMistakes": "Erro no fator de escala do Jacobiano (b-a)/2."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar funções base nos pontos de Gauss",
                                  "subSteps": [
                                    "Para cada par (i,j), compute φ_i(ξ_k') e φ_j(ξ_k') em todos os pontos transformados ξ_k'.",
                                    "Multiplique pelas funções: ψ_k = φ_i(ξ_k') * φ_j(ξ_k') * w(ξ_k').",
                                    "Registre valores em uma matriz [n x número de pares] ou compute diretamente.",
                                    "Verifique continuidade e suavidade das funções base nos pontos.",
                                    "Use software para automação se múltiplos pares."
                                  ],
                                  "verification": "Plote ou liste valores; compare com valores analíticos conhecidos para um par simples.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software numérico (MATLAB, Python com NumPy/SciPy), funções base definidas.",
                                  "tips": "Vetorize computações em software para eficiência.",
                                  "learningObjective": "Executar avaliação precisa das bases nos nós de integração.",
                                  "commonMistakes": "Avaliar funções erradas ou em pontos não transformados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar soma ponderada e formar elemento da matriz de Gram",
                                  "subSteps": [
                                    "Calcule <φ_i, φ_j> ≈ Σ_{k=1}^n w_k' * φ_i(ξ_k') * φ_j(ξ_k') * w(ξ_k').",
                                    "Repita para todos pares (i,j) para preencher a matriz G[i,j].",
                                    "Confirme simetria: G[i,j] = G[j,i].",
                                    "Compare com integral exata se disponível para validar precisão.",
                                    "Armazene matriz completa."
                                  ],
                                  "verification": "Matriz simétrica positiva definida; erro relativo < 1e-6 vs. exato para teste.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou código para soma (Excel/Python loop ou matrix multiply).",
                                  "tips": "Implemente como produto matricial: G = Φ^T W Φ, onde Φ é matriz de avaliações.",
                                  "learningObjective": "Finalizar o cálculo numérico do produto interno.",
                                  "commonMistakes": "Índices errados em loops ou esquecer multiplicação pelo peso."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar a aproximação",
                                  "subSteps": [
                                    "Aumente n e recompute para checar convergência (erro diminui).",
                                    "Teste com problema conhecido (ex.: polinômios Legendre exatos).",
                                    "Analise erro de truncamento da quadratura.",
                                    "Documente precisão alcançada e limitações.",
                                    "Integre na matriz de Gram completa do método."
                                  ],
                                  "verification": "Convergência observada com n crescente; uso bem-sucedido em solver simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código iterativo, gráficos de convergência.",
                                  "tips": "Monitore norma do erro para decisão de n ótimo.",
                                  "learningObjective": "Avaliar e otimizar a precisão numérica.",
                                  "commonMistakes": "Parar com n baixo, levando a instabilidade na solução."
                                }
                              ],
                              "practicalExample": "Para viga em [0,L=10] com φ1(x)=1, φ2(x)=x/L, w(x)=1, use Gauss n=3. Pontos transformados: ξ'≈[1.07,5,8.93], pesos ajustados. Compute <φ1,φ2>≈0 (devido a ortogonalidade aproximada), montando G[1,2].",
                              "finalVerifications": [
                                "Matriz de Gram simétrica e positiva semi-definida.",
                                "Erro relativo vs. integral exata < 0.1% para teste conhecido.",
                                "Convergência confirmada aumentando n.",
                                "Elementos diagonais positivos e coerentes com normas das bases.",
                                "Integração bem-sucedida em código reutilizável.",
                                "Sem NaN ou valores explosivos."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica (erro <1e-4).",
                                "Correta implementação de mapeamento e pesos.",
                                "Eficiência computacional (vetorização).",
                                "Validação com múltiplos n.",
                                "Documentação clara do processo.",
                                "Aplicação correta em contexto de resíduos ponderados."
                              ],
                              "crossCurricularConnections": [
                                "Métodos Numéricos: Fundamentos de quadratura e erro de integração.",
                                "Álgebra Linear: Construção e propriedades de matrizes de Gram.",
                                "Engenharia Computacional: Base para Elementos Finitos (FEM).",
                                "Análise Numérica: Estabilidade e condicionamento.",
                                "Física/Mecânica: Modelagem de problemas de contorno em estruturas."
                              ],
                              "realWorldApplication": "Em análise estrutural de edifícios via Método dos Elementos Finitos (FEM), computar rigidez/massa matrices para simular vibrações ou cargas em pontes/vigas, otimizando projetos civis contra falhas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Identificar funções base comuns",
                            "description": "Reconhecer e listar funções base polinomiais, trigonométricas ou de splines usadas em problemas de engenharia civil, como vigas ou difusão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Funções Base no Método dos Resíduos Ponderados",
                                  "subSteps": [
                                    "Defina funções base como funções que formam uma base para o espaço de soluções aproximadas em métodos numéricos.",
                                    "Explique o papel delas na construção da Matriz de Gram via produtos internos.",
                                    "Identifique critérios para escolha de funções base: simplicidade, completude e adequação ao problema.",
                                    "Revise o método dos resíduos ponderados e sua relação com funções base.",
                                    "Anote exemplos genéricos de problemas onde funções base são essenciais."
                                  ],
                                  "verification": "Escreva uma definição clara e liste 3 critérios de escolha em um documento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de métodos numéricos (ex: Chapra), notas de aula sobre DI-37, papel e caneta.",
                                  "tips": "Use analogia com vetores em álgebra linear para visualizar funções base.",
                                  "learningObjective": "Entender o fundamento teórico das funções base.",
                                  "commonMistakes": "Confundir funções base com funções de aproximação global sem considerar o contexto do método."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Funções Base Polinomiais",
                                  "subSteps": [
                                    "Liste polinômios de Legendre, Chebyshev e potências simples (1, x, x²).",
                                    "Descreva propriedades: ortogonalidade e estabilidade numérica.",
                                    "Aplique em problemas de vigas: forme funções para deslocamento em elementos finitos.",
                                    "Calcule um produto interno simples entre dois polinômios.",
                                    "Compare vantagens em domínios finitos."
                                  ],
                                  "verification": "Resolva um cálculo de produto interno e liste 3 polinômios com aplicações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB ou Python (SymPy), tabela de polinômios ortogonais.",
                                  "tips": "Comece com polinômios de baixa ordem para visualizar comportamentos.",
                                  "learningObjective": "Reconhecer e listar polinômios como funções base comuns.",
                                  "commonMistakes": "Ignorar normalização, levando a matrizes de Gram mal-condicionadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Funções Base Trigonométricas e Splines",
                                  "subSteps": [
                                    "Descreva séries de Fourier (senos e cossenos) para problemas periódicos como vibrações.",
                                    "Explique splines cúbicos: continuidade C¹ ou C² para modelagem suave em difusão.",
                                    "Identifique uso em difusão: splines para perfis de temperatura irregulares.",
                                    "Compare com polinômios: trigonométricas para domínios periódicos, splines para suavidade local.",
                                    "Esboce uma spline cúbica em um domínio [0,1]."
                                  ],
                                  "verification": "Desenhe ou codifique um exemplo de spline e liste 2 aplicações trigonométricas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Gráficos interativos online (Desmos), código Python para splines (SciPy).",
                                  "tips": "Visualize graficamente para entender suavidade vs. oscilações de polinômios.",
                                  "learningObjective": "Diferenciar e identificar funções trigonométricas e splines.",
                                  "commonMistakes": "Usar trigonométricas em domínios não-periódicos, causando Gibbs phenomenon."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Contextos de Engenharia Civil",
                                  "subSteps": [
                                    "Analise problema de viga: identifique polinômios para equação de Euler-Bernoulli.",
                                    "Para difusão em solos: liste splines para condições de contorno irregulares.",
                                    "Compile uma tabela: tipo de função, problema, razões de escolha.",
                                    "Simule um produto interno com funções base escolhidas.",
                                    "Crie um fluxograma para seleção de funções base."
                                  ],
                                  "verification": "Produza uma tabela com 5 exemplos de identificação correta.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigos sobre FEM em engenharia civil, Excel ou Jupyter Notebook.",
                                  "tips": "Relacione sempre com o domínio físico do problema para escolha intuitiva.",
                                  "learningObjective": "Aplicar reconhecimento em cenários reais de engenharia.",
                                  "commonMistakes": "Escolher funções inadequadas ao problema, como splines em domínios periódicos."
                                }
                              ],
                              "practicalExample": "Em uma viga engastada de 5m com carga distribuída, identifique funções base polinomiais cúbicas (1, ξ, ξ², ξ³ onde ξ=x/L) para aproximar o deslocamento w(x), verificando ortogonalidade via produto interno ∫w_i w_j dx.",
                              "finalVerifications": [
                                "Liste corretamente 5 funções base comuns com suas aplicações.",
                                "Explique diferenças entre polinomiais, trigonométricas e splines.",
                                "Identifique funções adequadas para viga e difusão sem erros.",
                                "Calcule um produto interno simples sem falhas numéricas.",
                                "Crie uma tabela de seleção contextualizada.",
                                "Descreva 3 critérios de escolha verbalmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação (90% correto em exemplos).",
                                "Compreensão de propriedades (ortogonalidade, suavidade).",
                                "Adequação ao contexto de engenharia civil.",
                                "Capacidade de listar e justificar escolhas.",
                                "Ausência de confusões entre tipos de funções.",
                                "Habilidade em visualizar e esboçar funções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e álgebra linear (produtos internos).",
                                "Física: Mecânica estrutural e transferência de calor (equações diferenciais).",
                                "Programação: Implementação em Python/MATLAB para FEM.",
                                "Engenharia de Materiais: Modelagem de comportamentos não-lineares com splines."
                              ],
                              "realWorldApplication": "Em software como ANSYS ou SAP2000, engenheiros civis usam essas funções base para meshing eficiente em análises de vigas e simulações de difusão em barragens, otimizando projetos contra falhas estruturais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Construção da Matriz de Gram",
                        "description": "Processo de montagem da matriz G cujos elementos são os produtos internos das funções base, resultando em um sistema linear para aproximar soluções de equações diferenciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Montar a matriz de Gram G_ij",
                            "description": "Construir a matriz simétrica G_ij = <φ_i, φ_j> para n funções base, ilustrando com exemplo de 3 funções em um problema de valor de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o domínio, o produto interno e as funções base",
                                  "subSteps": [
                                    "Identifique o intervalo ou domínio do problema de valor de contorno (ex: [0, L]).",
                                    "Defina o produto interno <f, g> = ∫_Ω f(x) g(x) w(x) dx, onde w(x) é o peso (geralmente 1).",
                                    "Selecione n funções base φ_i(x) ortogonais ou não, contínuas e satisfazendo condições de contorno (ex: φ1=1, φ2=x, φ3=x^2 para n=3 em [0,1]).",
                                    "Liste as funções explicitamente e verifique se são linearmente independentes.",
                                    "Anote as condições de contorno que as funções devem satisfazer."
                                  ],
                                  "verification": "Confirme que todas φ_i satisfazem as condições de contorno e o produto interno está corretamente definido por escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de cálculo simbólico (opcional, como SymPy ou Mathematica)"
                                  ],
                                  "tips": "Comece com funções polinomiais simples para facilitar cálculos iniciais.",
                                  "learningObjective": "Compreender o papel das funções base no método dos resíduos ponderados.",
                                  "commonMistakes": [
                                    "Escolher funções que não satisfazem condições de contorno",
                                    "Ignorar o peso w(x) no produto interno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os elementos da diagonal principal G_ii",
                                  "subSteps": [
                                    "Para cada i de 1 a n, compute G_ii = <φ_i, φ_i> = ∫_Ω [φ_i(x)]^2 w(x) dx.",
                                    "Resolva a integral analiticamente se possível (ex: para φ1=1 em [0,1], G11=∫0^1 1 dx =1).",
                                    "Use integração numérica (ex: quadratura de Gauss) se analítica for complexa.",
                                    "Registre o valor exato ou aproximado com precisão de 4 casas decimais.",
                                    "Verifique se G_ii > 0 para todas i (propriedade de norma)."
                                  ],
                                  "verification": "Todos G_ii são positivos e cálculos batem com verificação manual simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora gráfica",
                                    "Python com NumPy/SciPy para integração numérica"
                                  ],
                                  "tips": "Aproveite simetria: foque em i ≤ j primeiro.",
                                  "learningObjective": "Dominar o cálculo de normas das funções base via produto interno.",
                                  "commonMistakes": [
                                    "Erros em limites de integração",
                                    "Esquecer o fator w(x)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os elementos fora da diagonal G_ij para i ≠ j",
                                  "subSteps": [
                                    "Para cada par i < j, compute G_ij = <φ_i, φ_j> = ∫_Ω φ_i(x) φ_j(x) w(x) dx.",
                                    "Use a simetria: defina G_ji = G_ij.",
                                    "Exemplo: para φ1=1, φ2=x em [0,1], G12=∫0^1 x dx = 1/2.",
                                    "Registre valores em uma tabela preliminar.",
                                    "Valide com um cálculo cruzado (ex: recalcule um elemento aleatório)."
                                  ],
                                  "verification": "G_ij = G_ji para todos pares e valores coerentes com diagonal.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha de cálculo Excel ou Python Jupyter Notebook"
                                  ],
                                  "tips": "Automatize com loop em código se n>3 para evitar erros manuais.",
                                  "learningObjective": "Aplicar produto interno para elementos não-diagonais.",
                                  "commonMistakes": [
                                    "Assimetria nos cálculos",
                                    "Confundir índices i e j"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a matriz G, verificar propriedades e ilustrar com exemplo",
                                  "subSteps": [
                                    "Organize os elementos em uma matriz n x n simétrica: G = [G_ij]_{i,j=1 to n}.",
                                    "Exemplo completo para n=3: G = [[1, 0.5, 1/3], [0.5, 1/3, 0.25], [1/3, 0.25, 1/5]].",
                                    "Verifique simetria (G = G^T), definitude semi-definida positiva (autovalores ≥0).",
                                    "Teste com software: compute autovalores para confirmação.",
                                    "Documente o processo em um relatório curto com o exemplo."
                                  ],
                                  "verification": "Matriz final é simétrica e todos autovalores não-negativos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB ou Python com NumPy para eigenvalues"
                                  ],
                                  "tips": "Use LaTeX ou Markdown para formatação da matriz.",
                                  "learningObjective": "Construir e validar a matriz de Gram completa.",
                                  "commonMistakes": [
                                    "Erro de transcrição de elementos",
                                    "Não verificar simetria"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um problema de valor de contorno -u''=f em [0,1] com u(0)=u(1)=0, use φ1= x(1-x), φ2= x^2(1-x), φ3= x(1-x)^2. Compute G_ij = ∫0^1 φ_i φ_j dx, resultando em G = [[1/30, 1/105, 1/140], [1/105, 1/140, 1/315], [1/140, 1/315, 1/140]].",
                              "finalVerifications": [
                                "Matriz G é simétrica (G_ij = G_ji para todo i,j).",
                                "Elementos diagonais G_ii > 0.",
                                "Autovalores de G são todos não-negativos.",
                                "Cálculos batem com exemplo padrão (ex: polinomiais em [0,1]).",
                                "Funções base satisfazem condições de contorno.",
                                "Integral total conservada (ex: row sums coerentes)."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de integrais (erro < 1e-4).",
                                "Correta identificação de simetria e propriedades positivas.",
                                "Escolha adequada de funções base para o contexto.",
                                "Documentação clara com exemplo ilustrativo.",
                                "Validação computacional de autovalores.",
                                "Eficiência no número de steps e substeps."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Produtos internos e matrizes definidas positivas.",
                                "Cálculo: Integração analítica e numérica.",
                                "Análise Numérica: Quadratura e métodos espectrais.",
                                "Programação: Implementação em Python/SciPy para automação.",
                                "Física: Espaços de Hilbert em mecânica quântica."
                              ],
                              "realWorldApplication": "Na engenharia civil, a matriz de Gram é essencial no método de Galerkin para análise de estruturas (ex: elementos finitos em vigas e placas), aproximando soluções de EDP para tensões e deformações em barragens ou edifícios sob carga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Implementar em software numérico",
                            "description": "Codificar em MATLAB ou Python a formação da matriz de Gram para funções base discretizadas, usando loops ou vetores para eficiência computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de programação e definir funções base discretizadas",
                                  "subSteps": [
                                    "Instale e abra o ambiente: Python com NumPy/SciPy ou MATLAB.",
                                    "Defina o número de funções base (ex: N=5) e pontos de discretização (ex: M=100).",
                                    "Crie vetores ou matrizes para representar as funções base φ_i(x) em pontos x_j discretos.",
                                    "Gere os pontos x_j uniformemente no intervalo de interesse (ex: [0,1]).",
                                    "Implemente funções para avaliar φ_i em x_j, como polinômios de Legendre discretizados."
                                  ],
                                  "verification": "Execute o código inicial e confirme que matrizes de funções base (Φ de tamanho N x M) são geradas corretamente sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (NumPy, SciPy), MATLAB; editor de código (Jupyter, Spyder).",
                                  "tips": "Use np.linspace() em Python ou linspace() em MATLAB para pontos uniformes.",
                                  "learningObjective": "Entender e preparar dados discretizados para computação da matriz de Gram.",
                                  "commonMistakes": "Índices errados em loops (off-by-one); não normalizar o domínio de x."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar formação da matriz de Gram usando loops explícitos",
                                  "subSteps": [
                                    "Inicialize matriz G de tamanho N x N com zeros.",
                                    "Use loop duplo for i in 1:N, for j in 1:N: G[i,j] = integral aproximada de φ_i * φ_j.",
                                    "Aproxime integral por soma: sum(φ_i(x_k) * φ_j(x_k) * Δx) sobre k=1:M.",
                                    "Implemente em código: em Python, for i in range(N): for j in range(N): G[i,j] = np.sum(Phi[i,:] * Phi[j,:] * dx).",
                                    "Garanta simetria: G[i,j] = G[j,i] explicitamente se necessário."
                                  ],
                                  "verification": "Imprima G e verifique se é simétrica (G == G.T) e elementos positivos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código do Step 1; funções np.dot() ou sum() em Python, dot() em MATLAB.",
                                  "tips": "Calcule dx = (b-a)/M uma vez fora dos loops para eficiência.",
                                  "learningObjective": "Codificar computação matricial básica via loops para inner products discretos.",
                                  "commonMistakes": "Esquecer multiplicar por Δx na soma de Riemann; loops lentos para N grande."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Otimizar implementação usando operações vetoriais",
                                  "subSteps": [
                                    "Substitua loops por produto matricial: G = (Phi @ Phi.T) * dx em Python/NumPy.",
                                    "Em MATLAB: G = (Phi * Phi') * dx.",
                                    "Compare tempos de execução: use timeit() em Python ou tic/toc em MATLAB.",
                                    "Ajuste para funções base ortogonais se aplicável, verificando diagonal de G.",
                                    "Adicione comentários explicando vectorização vs. loops."
                                  ],
                                  "verification": "Execute ambas versões; confirme G idêntica e versão vetorial >10x mais rápida.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código dos Steps 1-2; módulos timeit (Python), profile viewer (MATLAB).",
                                  "tips": "Vectorize sempre que possível: NumPy/MATLAB otimizam BLAS internamente.",
                                  "learningObjective": "Dominar técnicas de eficiência computacional em álgebra linear numérica.",
                                  "commonMistakes": "Erro de broadcasting em multiplications; confundir Phi @ Phi.T com Phi.T @ Phi."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, validar e documentar a implementação",
                                  "subSteps": [
                                    "Teste com N=3 funções base conhecidas (ex: 1, x, x^2 em [0,1]).",
                                    "Calcule G analiticamente para comparação (ex: integrais exatas).",
                                    "Verifique condutas: det(G) > 0, trace(G) coerente com normas.",
                                    "Adicione função para plotar funções base e heatmap de G.",
                                    "Escreva docstring com uso, parâmetros e exemplo."
                                  ],
                                  "verification": "Erro relativo ||G_num - G_anal|| / ||G_anal|| < 1e-10.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código completo; SymPy/MATLAB Symbolic para analítico; matplotlib/plot.",
                                  "tips": "Use asserts para testes unitários: assert np.allclose(G_num, G_anal).",
                                  "learningObjective": "Garantir robustez e precisão em implementações numéricas.",
                                  "commonMistakes": "Não checar normalização das funções base; ignorar erros de arredondamento."
                                }
                              ],
                              "practicalExample": "Para funções base φ1=1, φ2=x, φ3=x^2 em [0,1] com M=100 pontos: G_loop = [[1/1, 1/2, 1/3], [1/2, 1/3, 1/4], [1/3, 1/4, 1/5]] aproximadamente. Código Python: Phi = np.array([[1]*100, np.linspace(0,1,100), np.linspace(0,1,100)**2]); dx=0.01; G = (Phi @ Phi.T) * dx. Resultado deve coincidir com integrais exatas.",
                              "finalVerifications": [
                                "Código executa sem erros para N<=20, M<=1000.",
                                "Matriz G é simétrica e definida positiva (autovalores >0).",
                                "Versão vetorizada é pelo menos 5x mais rápida que loops.",
                                "Erro numérico vs. analítico <1e-8.",
                                "Função é reutilizável com parâmetros N, M, phi_func.",
                                "Documentação inclui exemplo de uso."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro relativo na Gram matrix <1e-10.",
                                "Eficiência: Tempo vetorizado vs. loops reduzido >90%.",
                                "Corretude: Simetria e positividade da matriz.",
                                "Robustez: Funciona para diferentes N/M sem crashes.",
                                "Clareza: Código comentado, modular e legível.",
                                "Otimização: Uso efetivo de vectorização.",
                                "Validação: Testes incluídos com resultados esperados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Inner products e ortogonalidade.",
                                "Cálculo Numérico: Quadratura de Riemann e erros de truncamento.",
                                "Programação: Estruturas de controle, vectorização e profiling.",
                                "Engenharia Computacional: Bases para métodos de elementos finitos.",
                                "Estatística: Matrizes de covariância em dados discretos."
                              ],
                              "realWorldApplication": "Em engenharia civil, a matriz de Gram é usada no Método dos Resíduos Ponderados para aproximação de soluções em problemas de contorno (ex: vigas, placas), otimizando simulações FEM em software como ANSYS ou códigos customizados para análise estrutural eficiente."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Aplicação e Propriedades da Matriz de Gram",
                        "description": "Uso da matriz de Gram no método dos resíduos ponderados para resolver sistemas lineares, incluindo análise de condicionamento e relação com autovalores.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Resolver sistema linear com matriz de Gram",
                            "description": "Formar e resolver G c = b, onde b envolve o resíduo ponderado, aplicando em exemplo de equação diferencial da engenharia civil como equilíbrio de vigas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o problema e definir funções de base para o exemplo de viga",
                                  "subSteps": [
                                    "Identifique o problema de equilíbrio de vigas como uma equação diferencial, ex: EI y'''' = q(x) para viga com carga distribuída q(x).",
                                    "Escolha funções de base apropriadas, como polinômios de Legendre ou Hermite (ex: φ1(x) = 1, φ2(x) = x, φ3(x) = x^2).",
                                    "Defina o domínio da viga (ex: 0 ≤ x ≤ L) e condições de contorno (simplesmente apoiada: y(0)=y(L)=0).",
                                    "Aproxime a solução y(x) ≈ Σ c_i φ_i(x).",
                                    "Calcule o resíduo R(x) = EI (Σ c_i φ_i''''(x)) - q(x)."
                                  ],
                                  "verification": "Confirme que as funções de base satisfazem condições de contorno aproximadas e resíduo é definido corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora gráfica",
                                    "Software simbólico como Mathematica ou SymPy"
                                  ],
                                  "tips": "Comece com 2-3 funções de base para simplicidade; visualize a viga esboçando o domínio.",
                                  "learningObjective": "Compreender a formulação do método dos resíduos ponderados para EDOs em engenharia.",
                                  "commonMistakes": "Escolher funções que não capturam o comportamento físico (ex: ignorar simetria da viga)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de Gram G",
                                  "subSteps": [
                                    "Defina G_{ij} = ∫[0,L] φ_i(x) φ_j(x) w(x) dx, onde w(x) é peso (geralmente 1 para Galerkin).",
                                    "Expanda as funções de base e compute integrais analiticamente ou numericamente.",
                                    "Para exemplo: viga L=1, φ1=1-x^2, φ2=x-x^3; calcule G11, G12, etc.",
                                    "Monte a matriz simétrica G (nxn para n bases).",
                                    "Verifique simetria e positiva definitude (determinante >0)."
                                  ],
                                  "verification": "G é simétrica e todos elementos diagonais positivos; teste com n=2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de integração numérica (MATLAB/Octave)",
                                    "Tabela de integrais indefinidas"
                                  ],
                                  "tips": "Use simetria da viga para simplificar integrais; normalize funções para G próximo à identidade.",
                                  "learningObjective": "Dominar a construção da matriz de Gram como produto interno no espaço de funções.",
                                  "commonMistakes": "Erros em limites de integração ou esquecimento do peso w(x)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o vetor b com resíduo ponderado",
                                  "subSteps": [
                                    "Defina b_i = ∫[0,L] R(x) φ_i(x) w(x) dx, mas como R depende de c, linearize: b_i = ∫[0,L] f(x) φ_i(x) dx para forma fraca.",
                                    "Para equilíbrio de viga, use integração por partes para b_i = [termos de contorno] + ∫ q(x) φ_i(x) dx.",
                                    "Compute numericamente para q(x)=constante (ex: q=1).",
                                    "Inclua condições de contorno fracas nos termos de borda.",
                                    "Verifique dimensionalidade: b tem unidades consistentes com G c."
                                  ],
                                  "verification": "b é vetor coluna compatível com G; valores fazem sentido físico (ex: positivos para cargas descendentes).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel para integrais numéricas",
                                    "Python com NumPy/SciPy"
                                  ],
                                  "tips": "Integração por partes reduz ordem da derivada; anote termos de contorno explicitamente.",
                                  "learningObjective": "Aplicar projeção do resíduo no espaço de teste para formar o lado direito.",
                                  "commonMistakes": "Ignorar termos de contorno em b, levando a soluções inconsistentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o sistema G c = b e validar a solução",
                                  "subSteps": [
                                    "Use eliminação gaussiana ou decomposição LU para resolver por c.",
                                    "Implemente em software: defina G e b, resolva c = G\\b.",
                                    "Aplique c para plotar y(x) ≈ Σ c_i φ_i(x).",
                                    "Compare com solução exata (ex: para viga uniforme, y(x)=q x (L^3 - 2 L x^2 + x^3)/24 EI).",
                                    "Calcule norma do erro ||R|| e refine com mais bases se necessário."
                                  ],
                                  "verification": "Solução converge (erro <5%); c não contém valores absurdos (ex: infinitos).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB, Python (NumPy.linalg.solve)",
                                    "GNU Octave gratuito"
                                  ],
                                  "tips": "Condicione G com cond(G)<1e6; use pivoteamento para estabilidade.",
                                  "learningObjective": "Resolver sistemas lineares oriundos de métodos variationais e validar numericamente.",
                                  "commonMistakes": "Má numeração de índices em G ou b; não checar condicionamento levando a c impreciso."
                                }
                              ],
                              "practicalExample": "Para uma viga simplesmente apoiada de comprimento L=5m, EI=1e6 N.m², carga uniforme q(x)=10 kN/m: use 3 funções Hermite cúbicas para aproximar deflexão y(x). Compute G (3x3), b (3x1), resolva c, plote y(x) e compare com y_exata(x) = (q/(24 EI)) x (L^3 - 2 L x^2 + x^3). Erro máximo <2%.",
                              "finalVerifications": [
                                "Matriz G é simétrica positiva definida (autovalores >0).",
                                "Vetor b incorpora corretamente carga e contornos.",
                                "Solução c gera y(x) que satisfaz approx. y(0)=y(L)=0 e y''(0)=y''(L)=0.",
                                "Erro de resíduo ∫ R² dx < 1% do total.",
                                "Comparação gráfica com solução analítica converge com mais bases.",
                                "Teste de sensibilidade: perturbe q em 10%, verifique linearidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão da montagem de G e b (erro <1e-3 em elementos).",
                                "Correta resolução do sistema (norma residual |G c - b| <1e-6).",
                                "Validação física: deflexão máxima razoável (ex: < L/360).",
                                "Eficiência computacional: tempo <5min para n=5.",
                                "Relatório inclui plots e análise de erro.",
                                "Generalização: adapte para carga triangular."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Resolução de sistemas e propriedades de Gram-Schmidt.",
                                "Cálculo Numérico: Integração quadratura e condicionamento de matrizes.",
                                "Mecânica dos Sólidos: Teoria de vigas de Euler-Bernoulli.",
                                "Programação: Implementação em Python/MATLAB para automação.",
                                "Física Computacional: Métodos espectrais em simulações."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado em software como ANSYS ou SAP2000 para análise preliminar de vigas/pontes complexas, otimizando malhas finitas; ex: projeto de viadutos onde soluções analíticas falham, reduzindo tempo de simulação em 50% para protótipos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Analisar condicionamento da matriz",
                            "description": "Calcular o número de condicionamento cond(G) = ||G|| ||G^{-1}||, identificar ill-condicionamento devido a funções base não ortogonais e propor melhorias como Gram-Schmidt.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de normas matriciais e número de condicionamento",
                                  "subSteps": [
                                    "Defina norma de matriz ||A|| como medida de 'tamanho', focando em norma 2 (espectral) e norma de Frobenius.",
                                    "Explique o número de condicionamento cond(A) = ||A|| * ||A^{-1}|| e seu significado: valores altos indicam sensibilidade a perturbações.",
                                    "Discuta propriedades: cond(A) >= 1, cond(I) = 1, e impacto em soluções de sistemas lineares.",
                                    "Relacione com matrizes de Gram G_{ij} = <φ_i, φ_j>, onde ill-condicionamento surge de bases não ortogonais.",
                                    "Estude exemplos simples de matrizes mal condicionadas."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos e calcule cond para uma matriz 2x2 identidade (deve ser 1).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de álgebra linear (ex: Strang), calculadora, papel e lápis.",
                                  "tips": "Use norma 2 para simplicidade em contextos espectrais; visualize com autovalores.",
                                  "learningObjective": "Dominar definições e interpretações de normas e condicionamento em matrizes de Gram.",
                                  "commonMistakes": "Confundir norma de vetor com norma de matriz; ignorar que cond depende da norma escolhida."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o número de condicionamento cond(G) para uma matriz de Gram",
                                  "subSteps": [
                                    "Construa uma matriz de Gram G simples de ordem 2x2 com funções base não ortogonais (ex: φ1(x)=1, φ2(x)=x em [0,1]).",
                                    "Calcule ||G|| usando norma 2: maior autovalor de G^T G (ou diretamente para simétrica).",
                                    "Encontre G^{-1} via fórmula explícita ou decomposição LU.",
                                    "Calcule ||G^{-1}|| similarmente e multiplique para obter cond(G).",
                                    "Repita com norma Frobenius para comparação."
                                  ],
                                  "verification": "Obtenha cond(G) numérico < 10^3 para matriz bem condicionada e valide com software.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software como MATLAB/Python (NumPy/SciPy), planilha Excel para cálculos manuais.",
                                  "tips": "Para matrizes pequenas, use determinante e adjunta para inversa; verifique simetria positiva definida.",
                                  "learningObjective": "Executar cálculo preciso de cond(G) = ||G|| ||G^{-1}||.",
                                  "commonMistakes": "Erro numérico em inversa devido a arredondamento; escolher norma inconsistente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar ill-condicionamento devido a funções base não ortogonais",
                                  "subSteps": [
                                    "Analise autovalores de G: razão maior/menor autovalor ≈ cond(G).",
                                    "Compare G para bases ortogonais (diagonal, cond=1) vs. não ortogonais (off-diagonal altos).",
                                    "Simule perturbações em coeficientes e observe erro amplificado em soluções Ax=b.",
                                    "Identifique padrões: bases lineares dependentes ou mal escaladas causam cond alto.",
                                    "Quantifique: cond > 10^6 indica ill-condicionamento severo."
                                  ],
                                  "verification": "Para uma G com cond>10^4, mostre propagação de erro em solução de sistema.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python com NumPy/MATLAB, exemplos de funções base polinomiais.",
                                  "tips": "Plote autovalores para visualização; use cond() built-in para checagem.",
                                  "learningObjective": "Diagnosticar causas de ill-condicionamento em matrizes de Gram.",
                                  "commonMistakes": "Atribuir ill-condicionamento só a tamanho da matriz, ignorando ortogonalidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Propor e aplicar melhorias via processo de Gram-Schmidt",
                                  "subSteps": [
                                    "Revise algoritmo Gram-Schmidt: ortogonalize {φ_i} para {ψ_i} com ψ1=φ1, ψ_{k} = φ_k - proj_{span(ψ1..ψ_{k-1})} φ_k.",
                                    "Construa nova matriz de Gram G' para bases ortogonais (deve ser diagonal).",
                                    "Calcule cond(G') e compare com original.",
                                    "Implemente numericamente, lidando com instabilidade (use QR modificado se necessário).",
                                    "Aplique em contexto: reescrita de resíduos ponderados com bases melhoradas."
                                  ],
                                  "verification": "Redução de cond(G') para ~1 e erro numérico diminuído em simulação.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código Python/MATLAB para Gram-Schmidt, funções base exemplo.",
                                  "tips": "Normalizar bases iniciais para evitar overflow; prefira Householder para estabilidade.",
                                  "learningObjective": "Implementar Gram-Schmidt para mitigar ill-condicionamento.",
                                  "commonMistakes": "Perda de ortogonalidade por erros de arredondamento em implementações clássicas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e validar melhorias no condicionamento",
                                  "subSteps": [
                                    "Compare cond(G) vs cond(G') quantitativamente.",
                                    "Teste estabilidade: adicione ruído gaussiano e resolva sistemas.",
                                    "Analise impacto em método dos resíduos ponderados: convergência mais rápida.",
                                    "Documente trade-offs: custo computacional de ortogonalização.",
                                    "Generalize para bases maiores em Engenharia Civil."
                                  ],
                                  "verification": "Relatório com tabelas: cond antes/depois, erros relativos <10^{-10}.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de plotagem (Matplotlib), relatório template.",
                                  "tips": "Use log-scale para cond altos; valide com múltiplas normas.",
                                  "learningObjective": "Validar eficácia de melhorias em condicionamento.",
                                  "commonMistakes": "Ignorar custo de Gram-Schmidt para matrizes grandes (O(n^3))."
                                }
                              ],
                              "practicalExample": "Considere aproximação de solução u(x) = sin(πx) em [0,1] pelo método dos resíduos ponderados com base {1, x}. Compute G = [[1, 0.5], [0.5, 1/3]], encontre cond(G)≈24 (ill-condicionado). Aplique Gram-Schmidt: ψ1=1, ψ2=x-0.5, G' diagonal com cond≈1. Resolva sistema e compare erros.",
                              "finalVerifications": [
                                "Cálculo correto de cond(G) para exemplo dado coincide com software.",
                                "Identificação precisa de causa: sobreposição de funções base.",
                                "Implementação de Gram-Schmidt produz bases ortogonais (inner products zero off-diagonal).",
                                "Redução de cond >90% após ortogonalização.",
                                "Análise de estabilidade mostra erro relativo <10^{-12} pós-melhoria.",
                                "Relatório resume passos com gráficos de autovalores."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de normas e inversa (erro <1%).",
                                "Correta interpretação de ill-condicionamento (razão autovalores).",
                                "Implementação funcional de Gram-Schmidt sem perda ortogonalidade.",
                                "Comparação quantitativa clara de cond antes/depois.",
                                "Aplicação contextual ao método dos resíduos ponderados.",
                                "Clareza em documentação e avoidance de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposições QR e SVD para condicionamento.",
                                "Cálculo Numérico: Estabilidade de algoritmos e análise de erro.",
                                "Engenharia Computacional: Otimização em FEM e métodos espectrais.",
                                "Física: Bases ortogonais em expansões de Fourier para ondas.",
                                "Programação: Implementação eficiente em Python/MATLAB."
                              ],
                              "realWorldApplication": "Em análise estrutural de vigas (Engenharia Civil), matrizes de Gram surgem em métodos de elementos finitos com bases polinomiais não ortogonais, causando instabilidade numérica em simulações de grandes deformações; Gram-Schmidt melhora precisão em predições de colapso sob cargas dinâmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Relacionar com autovalores e autofunções",
                            "description": "Explicar como autovalores de G indicam estabilidade numérica e como autofunções relacionam-se à base ortogonal no método dos resíduos ponderados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Autovalores e Autofunções",
                                  "subSteps": [
                                    "Defina autovalor λ e autofunção v para uma matriz A onde A v = λ v.",
                                    "Explique propriedades chave: soma dos autovalores é o traço de A; produto é o determinante.",
                                    "Discuta matrizes simétricas positivas definidas: todos autovalores reais e positivos.",
                                    "Revise decomposição espectral: A = Q Λ Q^T para matrizes simétricas.",
                                    "Pratique com uma matriz 2x2 simples para calcular autovalores e autofunções."
                                  ],
                                  "verification": "Resolva um problema de autovalores para uma matriz simétrica 2x2 e verifique se A v = λ v.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de álgebra linear (ex: Strang), calculadora ou software como MATLAB/Python (NumPy).",
                                  "tips": "Sempre normalize as autofunções para facilitar comparações de ortogonalidade.",
                                  "learningObjective": "Compreender a definição e propriedades básicas de autovalores e autofunções em matrizes simétricas.",
                                  "commonMistakes": "Confundir autovalor com autofunção; esquecer que para simétricas, autofunções são ortogonais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e Analisar a Matriz de Gram G no Método dos Resíduos Ponderados",
                                  "subSteps": [
                                    "Lembre o método dos resíduos ponderados: encontrar u tal que (r, w_i) = 0 para funções peso w_i.",
                                    "Defina G_{ij} = ∫ φ_i φ_j dx, onde φ são funções base (ortogonais ou não).",
                                    "Construa G para um espaço de 2-3 funções base simples (ex: polinômios Legendre).",
                                    "Verifique simetria e positiva definitude de G.",
                                    "Discuta como G surge da inner product na base não-ortogonal."
                                  ],
                                  "verification": "Construa G para duas funções base e confirme G = G^T e x^T G x > 0 para x ≠ 0.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software simbólico (SymPy ou Mathematica), papel e lápis para integração manual.",
                                  "tips": "Use funções base polinomiais simples no intervalo [-1,1] para cálculos analíticos fáceis.",
                                  "learningObjective": "Entender a origem e propriedades da matriz de Gram G no contexto do método.",
                                  "commonMistakes": "Esquecer limites de integração ou normalização das funções base."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Autovalores e Autofunções da Matriz G",
                                  "subSteps": [
                                    "Use equação característica det(G - λ I) = 0 para encontrar autovalores.",
                                    "Resolva (G - λ I) v = 0 para cada autofunção.",
                                    "Normalize e verifique ortogonalidade: v_i · v_j = δ_{ij}.",
                                    "Analise: autovalores > 0 indicam G positiva definida (estável numericamente).",
                                    "Compare com base original: autofunções diagonalizam G."
                                  ],
                                  "verification": "Para uma G 2x2, liste autovalores, autofunções ortogonais e confirme diagonalização.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB/Python (eig função), planilha Excel para casos pequenos.",
                                  "tips": "Para matrizes maiores, use decomposição QR iterativa manualmente para insight.",
                                  "learningObjective": "Dominar o cálculo e interpretação de autovalores/autofunções de G.",
                                  "commonMistakes": "Não verificar ortogonalidade pós-normalização; ignorar multiplicidade algébrica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Autovalores/Autofunções à Estabilidade e Base Ortogonal",
                                  "subSteps": [
                                    "Explique: autovalores pequenos → ill-conditioned G → instabilidade numérica em solvers.",
                                    "Autovalores grandes/pequenos indicam direção de 'má conduta' na base.",
                                    "Mostre como autofunções de G formam base ortogonal no espaço inner product.",
                                    "No método: usar base eigen para orthogonalizar e melhorar estabilidade.",
                                    "Simule solver com G condicionado vs diagonalizado."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como λ_min afeta passos de tempo em simulações dinâmicas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código Python para cond number = λ_max/λ_min e teste de solver (ex: CG).",
                                  "tips": "Meça condição de G antes/depois orthogonalização para visualização.",
                                  "learningObjective": "Conectar autovalores de G à estabilidade numérica e autofunções à base ortogonal.",
                                  "commonMistakes": "Confundir estabilidade algébrica com numérica; ignorar escala das funções base."
                                }
                              ],
                              "practicalExample": "Considere duas funções base φ1(x)=1, φ2(x)=x no [-1,1]. G = [[2,0],[0,2/3]]. Autovalores: 2 e 2/3. Autofunções: [1,0] e [0,1] (já ortogonais). Se base não-ortogonal, ex: φ2=x+0.1, G fica ill-conditioned (λ_max/λ_min >10), causando erros em solve Au=b.",
                              "finalVerifications": [
                                "Calcula corretamente autovalores e autofunções para G 2x2.",
                                "Explica impacto de autovalores na condição de G e estabilidade.",
                                "Descreve como autofunções orthogonalizam a base original.",
                                "Identifica quando G é positiva definida via autovalores.",
                                "Aplica decomposição em um mini-problema de resíduos ponderados.",
                                "Discute trade-offs numéricos em bases não-ortogonais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de autovalores/autofunções (erro <1%).",
                                "Compreensão conceitual: explica estabilidade via λ_min >0.",
                                "Clareza na relação autofunções-base ortogonal.",
                                "Uso correto de terminologia (inner product, positiva definida).",
                                "Criatividade em exemplo prático com interpretação.",
                                "Identificação de erros numéricos potenciais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração (autovetores de rigidez/massa).",
                                "Computação: Algoritmos eigen (Lanczos para grandes matrizes FEM).",
                                "Estatística: Matriz de covariância e PCA (análogo à Gram).",
                                "Matemática Aplicada: Teoria espectral em EDOs elípticas."
                              ],
                              "realWorldApplication": "Em análise estrutural via elementos finitos (ex: pontes em software como ANSYS), autovalores de G indicam se a malha/base funções causa instabilidade numérica em solvers iterativos, evitando divergência; autofunções guiam orthogonalização para simulações precisas de deformações sob carga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.6",
                    "name": "Aplicação a Problemas de Contorno",
                    "description": "Adaptação do método para equações diferenciais com condições de contorno.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.6.1",
                        "name": "Problemas de Valor de Contorno (BVP)",
                        "description": "Compreensão dos problemas de valor de contorno em equações diferenciais ordinárias (EDOs), diferenciando-os de problemas de valor inicial (IVP), e sua relevância na engenharia civil para modelagem de estruturas e fluxos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.1.1",
                            "name": "Identificar problemas de valor de contorno",
                            "description": "Reconhecer e classificar equações diferenciais com condições especificadas em pontos distintos do domínio, como em vigas ou perfis de temperatura em paredes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Problemas de Valor Inicial (IVP) e Valor de Contorno (BVP)",
                                  "subSteps": [
                                    "Defina um problema de valor inicial (IVP): condições iniciais especificadas em um único ponto.",
                                    "Defina um problema de valor de contorno (BVP): condições especificadas em pontos distintos do domínio.",
                                    "Estude exemplos simples de EDOs de segunda ordem.",
                                    "Compare diagramas de domínio para IVP (t=0) vs. BVP (x=0 e x=L).",
                                    "Revise a notação matemática padrão para BVPs."
                                  ],
                                  "verification": "Explique a diferença entre IVP e BVP em suas próprias palavras e dê um exemplo de cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de EDOs (ex: Boyce & DiPrima), notas de aula, quadro branco.",
                                  "tips": "Use desenhos para visualizar o domínio e pontos de condições.",
                                  "learningObjective": "Compreender a distinção fundamental entre IVP e BVP.",
                                  "commonMistakes": "Confundir condições iniciais com contorno; ignorar o domínio espacial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Condições de Contorno em Equações Diferenciais",
                                  "subSteps": [
                                    "Analise a EDO e localize as condições dadas (ex: u(0)=a, u(L)=b).",
                                    "Verifique se as condições estão em extremos do intervalo [a,b].",
                                    "Classifique como Dirichlet (valores da função), Neumann (derivadas) ou misto.",
                                    "Pratique com 3-5 equações exemplo de livros ou aulas.",
                                    "Anote padrões comuns em problemas físicos."
                                  ],
                                  "verification": "Classifique corretamente 5 equações fornecidas como BVP ou não.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exercícios de EDOs, calculadora simbólica (ex: Mathematica ou Python SymPy).",
                                  "tips": "Sempre pergunte: 'As condições estão nos dois fins?'",
                                  "learningObjective": "Reconhecer a presença de condições de contorno em EDOs.",
                                  "commonMistakes": "Não notar condições em derivadas; assumir todas EDOs são IVPs."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar BVPs a Contextos Físicos em Engenharia Civil",
                                  "subSteps": [
                                    "Estude o problema de deflexão de vigas: EDO y'' = f(x), y(0)=0, y(L)=0.",
                                    "Analise perfis de temperatura em paredes: k u'' = 0, u(0)=T1, u(L)=T2.",
                                    "Identifique BVPs em outros cenários como fluxo em tubos ou tensão em cabos.",
                                    "Desenhe esquemas físicos com condições destacadas.",
                                    "Compare com problemas reais de projetos civis."
                                  ],
                                  "verification": "Descreva um problema físico como BVP e justifique as condições.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Diagramas de vigas e paredes térmicas, software de simulação (ex: MATLAB).",
                                  "tips": "Pense em 'suportes' ou 'temperaturas fixas' como contornos.",
                                  "learningObjective": "Associar BVPs a aplicações práticas em Engenharia Civil.",
                                  "commonMistakes": "Ignorar o contexto físico; confundir com problemas dinâmicos (tempo)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar e Documentar Problemas de Valor de Contorno",
                                  "subSteps": [
                                    "Crie uma tabela de classificação: tipo de EDO, condições, aplicação física.",
                                    "Pratique classificação de 5 problemas mistos (Dirichlet/Neumann).",
                                    "Verifique unicidade e existência básica (teorema de existência para BVPs lineares).",
                                    "Documente um BVP completo com notação padrão.",
                                    "Resolva analiticamente um BVP simples para validação."
                                  ],
                                  "verification": "Classifique e documente corretamente um BVP novo fornecido.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Planilha Excel ou LaTeX para tabelas, solucionador de EDOs.",
                                  "tips": "Use abreviações: D para Dirichlet, N para Neumann.",
                                  "learningObjective": "Classificar BVPs de forma sistemática e precisa.",
                                  "commonMistakes": "Classificação errada de condições mistas; omitir ordem da EDO."
                                }
                              ],
                              "practicalExample": "Em uma viga de comprimento L com carga uniforme q, a equação é EI y'''' = q, com condições y(0)=0, y''(0)=0, y(L)=0, y''(L)=0. Isso é um BVP de quarta ordem com condições de apoio simples nas extremidades.",
                              "finalVerifications": [
                                "Diferencie corretamente IVP de BVP em 90% dos casos.",
                                "Identifique condições de contorno em problemas físicos descritos.",
                                "Classifique tipos de BVPs (Dirichlet, Neumann, misto).",
                                "Relacione BVPs a pelo menos 3 aplicações em Engenharia Civil.",
                                "Documente um BVP completo com justificativa.",
                                "Explique por que condições em pontos distintos definem BVP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção IVP/BVP (peso 25%).",
                                "Correta identificação de condições de contorno (peso 25%).",
                                "Classificação precisa de tipos de BVPs (peso 20%).",
                                "Conexão com contextos físicos reais (peso 15%).",
                                "Clareza na documentação e exemplos (peso 10%).",
                                "Ausência de erros comuns como confusão de domínio (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Equações Diferenciais Ordinárias.",
                                "Física: Mecânica dos Materiais e Transferência de Calor.",
                                "Computação: Métodos Numéricos (ex: Método dos Resíduos Ponderados).",
                                "Engenharia Mecânica: Análise de estruturas similares.",
                                "Estatística: Verificação de soluções numéricas."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, identificar BVPs é essencial para modelar deflexões em vigas de pontes ou perfis de temperatura em paredes isolantes, permitindo simulações computacionais precisas com métodos como Resíduos Ponderados para otimizar projetos e evitar falhas estruturais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.2",
                            "name": "Formular condições de contorno",
                            "description": "Especificar condições de Dirichlet, Neumann ou mistas em problemas de engenharia civil, garantindo a adequação ao problema físico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os tipos fundamentais de condições de contorno",
                                  "subSteps": [
                                    "Estudar a definição de condição de Dirichlet: valor fixo da solução na fronteira (ex.: u(0) = a).",
                                    "Analisar condição de Neumann: derivada normal fixa na fronteira (ex.: du/dn = g, representando fluxo).",
                                    "Explorar condições mistas: combinação de Dirichlet e Neumann em diferentes fronteiras.",
                                    "Revisar exemplos em problemas de BVP como equação de Laplace ou Poisson.",
                                    "Diferenciar condições essenciais (Dirichlet) de naturais (Neumann) no método dos resíduos ponderados."
                                  ],
                                  "verification": "Resumir em um quadro comparativo os três tipos com fórmulas e interpretações físicas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de EDOs (ex.: Boyce & DiPrima)",
                                    "Notas de aula sobre método dos resíduos ponderados",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Use diagramas esquemáticos de domínios 1D/2D para visualizar fronteiras.",
                                  "learningObjective": "Identificar e diferenciar corretamente Dirichlet, Neumann e mistas.",
                                  "commonMistakes": "Confundir Neumann com derivada total em vez de normal; ignorar periodicidade em problemas cíclicos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o problema físico e identificar fronteiras relevantes",
                                  "subSteps": [
                                    "Descrever o problema de engenharia civil (ex.: fluxo em reservatório, deflexão de viga).",
                                    "Delimitar o domínio geométrico e listar todas as fronteiras (ex.: Γ1, Γ2).",
                                    "Mapear condições físicas: fixo (deslocamento zero), livre (tensão zero), fluxo imposto.",
                                    "Classificar cada fronteira como Dirichlet, Neumann ou mista com base na física.",
                                    "Esboçar o domínio com anotações das condições físicas."
                                  ],
                                  "verification": "Produzir um diagrama anotado do domínio com classificações físicas confirmadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Diagrama do problema físico",
                                    "Software de desenho (ex.: Draw.io)",
                                    "Referências de engenharia civil"
                                  ],
                                  "tips": "Sempre pergunte: 'O que acontece fisicamente na fronteira?' para guiar a classificação.",
                                  "learningObjective": "Mapear corretamente condições físicas às fronteiras do problema.",
                                  "commonMistakes": "Omitir fronteiras internas ou simétricas; superestimar simetria sem justificativa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular as condições matemáticas adequadas",
                                  "subSteps": [
                                    "Escrever a equação diferencial do BVP (ex.: -u'' = f em [0,1]).",
                                    "Especificar condições: ex. u(0)=0 (Dirichlet), u'(1)=q (Neumann).",
                                    "Para mistas: combinar em fronteiras parciais (ex.: u=0 em ΓD, ∂u/∂n=0 em ΓN).",
                                    "Verificar unidades e consistência dimensional das condições.",
                                    "Expressar em notação compatível com método dos resíduos ponderados (essenciais vs. naturais)."
                                  ],
                                  "verification": "Escrever o BVP completo com condições e testar unicidade qualitativa.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Caderno de equações",
                                    "Software simbólico (ex.: Mathematica ou SymPy)",
                                    "Tabela de condições padrão"
                                  ],
                                  "tips": "Padronize notação: use n para normal externa e especifique direção.",
                                  "learningObjective": "Traduzir física em fórmulas matemáticas precisas e consistentes.",
                                  "commonMistakes": "Escrever derivada errada (u' vs. ∂u/∂n); inconsistência em condições homogêneas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar adequação e documentar as condições",
                                  "subSteps": [
                                    "Simular solução analítica aproximada ou numérica para verificar comportamento.",
                                    "Comparar com solução física esperada (ex.: simetria, máximo na fronteira).",
                                    "Documentar justificativa física para cada condição escolhida.",
                                    "Testar sensibilidade: alterar uma condição e observar impacto.",
                                    "Preparar para implementação no método dos resíduos ponderados."
                                  ],
                                  "verification": "Relatório curto confirmando que condições levam a solução física coerente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software numérico (ex.: MATLAB, Python com FEniCS)",
                                    "Exemplo resolvido de BVP"
                                  ],
                                  "tips": "Use testes de convergência para validar; refine malhas perto de fronteiras críticas.",
                                  "learningObjective": "Garantir que condições sejam fisicamente adequadas e numericamente estáveis.",
                                  "commonMistakes": "Ignorar il-condicionamento (ex.: todas Neumann sem compatibilidade); validação superficial."
                                }
                              ],
                              "practicalExample": "Em uma viga de concreto simplesmente apoiada sob carga distribuída, formule condições: Dirichlet u(0)=u(L)=0 nas extremidades (deslocamento zero) e Neumann du/dx=0 no meio se simétrica (rotação zero por simetria).",
                              "finalVerifications": [
                                "Todas fronteiras do domínio possuem condições especificadas.",
                                "Condições distinguem corretamente essenciais e naturais para o método.",
                                "Fórmulas matemáticas são dimensionalmente consistentes.",
                                "Solução qualitativa atende expectativas físicas (ex.: máximo interno).",
                                "Documentação inclui justificativas físicas explícitas.",
                                "Teste numérico simples confirma unicidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de tipos de condições (Dirichlet/Neumann/mistas).",
                                "Adequação física demonstrada com argumentos claros.",
                                "Correção matemática das expressões formuladas.",
                                "Completude: todas fronteiras cobertas sem ambiguidades.",
                                "Validação através de verificação qualitativa/numérica.",
                                "Clareza na documentação e diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de equações diferenciais e existência/unicidade de soluções.",
                                "Física: Mecânica dos sólidos e transferência de calor em estruturas civis.",
                                "Computação: Implementação em métodos numéricos como elementos finitos.",
                                "Engenharia Mecânica: Análise de tensões e deformações em materiais."
                              ],
                              "realWorldApplication": "Na análise de barragens hidrelétricas, condições de Dirichlet modelam deslocamentos fixos na base rochosa, enquanto Neumann representa cargas hidrostáticas nas faces, essencial para prever falhas estruturais via simulações computacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.3",
                            "name": "Diferenciar BVP de IVP",
                            "description": "Comparar problemas de valor inicial (condições em t=0) com BVPs (condições em extremos do intervalo), destacando desafios numéricos como instabilidade em IVPs marchantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Problemas de Valor Inicial (IVP)",
                                  "subSteps": [
                                    "Defina IVP como problemas de EDOs com condições iniciais especificadas em um ponto inicial (geralmente t=0).",
                                    "Identifique características: soluções marcham para frente no tempo ou direção, usando métodos como Euler ou Runge-Kutta.",
                                    "Estude exemplos simples: equação y' = -y com y(0)=1.",
                                    "Analise estabilidade: soluções sensíveis a erros iniciais em marchas para frente.",
                                    "Registre diferenças com problemas analíticos exatos."
                                  ],
                                  "verification": "Resolva um IVP simples numericamente e compare com solução exata, verificando erro < 1%.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de EDOs (ex: Boyce-DiPrima)",
                                    "Python/MATLAB com bibliotecas scipy.integrate",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Comece com EDOs de primeira ordem para simplicidade antes de ordens superiores.",
                                  "learningObjective": "Compreender a definição e métodos de solução de IVPs.",
                                  "commonMistakes": [
                                    "Confundir condições iniciais com de contorno.",
                                    "Ignorar instabilidade numérica em passos grandes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Problemas de Valor de Contorno (BVP)",
                                  "subSteps": [
                                    "Defina BVP como problemas de EDOs com condições especificadas nos extremos do intervalo [a,b].",
                                    "Identifique necessidade de métodos de contorno: shooting method ou finite differences.",
                                    "Estude exemplos: y'' + y = 0 com y(0)=0, y(π)=0.",
                                    "Compare com IVPs: soluções bidirecionais ou iterativas.",
                                    "Implemente um solver básico para BVP linear."
                                  ],
                                  "verification": "Implemente shooting method para um BVP e obtenha convergência em <10 iterações.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software MATLAB/Python (scipy.solve_bvp)",
                                    "Tutoriais online sobre shooting method",
                                    "Folhas de exercícios de BVPs"
                                  ],
                                  "tips": "Use normalização para melhorar convergência em problemas não-lineares.",
                                  "learningObjective": "Dominar definição e técnicas iniciais de solução de BVPs.",
                                  "commonMistakes": [
                                    "Aplicar métodos de IVP diretamente, causando divergência.",
                                    "Esquecer linearidade nas aproximações iniciais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Fundamentais entre IVP e BVP",
                                  "subSteps": [
                                    "Liste diferenças: condições (inicial vs. contorno), direção de marcha (unidirecional vs. bidirecional).",
                                    "Discuta desafios numéricos: instabilidade em IVPs longos vs. sensibilidade a chutes em BVPs.",
                                    "Crie tabela comparativa: estabilidade, métodos, complexidade computacional.",
                                    "Analise impacto no Método dos Resíduos Ponderados: pesos para condições de contorno.",
                                    "Resolva o mesmo problema como IVP e BVP para visualizar diferenças."
                                  ],
                                  "verification": "Crie e preencha tabela comparativa com pelo menos 5 diferenças chave, validada por simulação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela",
                                    "Código fonte de solvers IVP/BVP",
                                    "Artigos sobre MRP para BVPs"
                                  ],
                                  "tips": "Visualize soluções graficamente para intuir instabilidades.",
                                  "learningObjective": "Identificar e articular diferenças matemáticas e numéricas entre IVP e BVP.",
                                  "commonMistakes": [
                                    "Subestimar impacto das condições de contorno na escolha do método.",
                                    "Confundir 'marcha' com direção arbitrária."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Desafios Numéricos e Aplicações no MRP",
                                  "subSteps": [
                                    "Estude instabilidade em IVPs: exemplo de equação rígida com passos explícitos.",
                                    "Discuta MRP para BVPs: ponderação de resíduos em extremos do domínio.",
                                    "Implemente MRP simples para BVP vs. IVP no contexto de vigas em engenharia civil.",
                                    "Avalie precisão: compare resíduos ponderados entre abordagens.",
                                    "Conclua com quando usar cada tipo no contexto computacional."
                                  ],
                                  "verification": "Simule MRP em BVP de viga, verificando resíduos < 10^-4 nos nós.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Python para MRP",
                                    "Exemplos de EDOs em estruturas civis",
                                    "Referências: 'Numerical Methods for Engineers'"
                                  ],
                                  "tips": "Teste com malhas finitas para validar convergência.",
                                  "learningObjective": "Aplicar conceitos a desafios numéricos reais no MRP.",
                                  "commonMistakes": [
                                    "Não ponderar corretamente resíduos de contorno.",
                                    "Usar h fixo grande, amplificando instabilidades."
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de vigas (engenharia civil): IVP para propagação de onda em viga com condição inicial de deslocamento zero e velocidade unitária em t=0; BVP para deformação estática y'' = carga com y(0)=0 (apoio simples) e y(L)=0 (apoio simples). Implemente MRP para BVP e observe necessidade de iterações vs. marcha direta no IVP.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave entre IVP e BVP.",
                                "Classificar corretamente 5 problemas dados como IVP ou BVP.",
                                "Implementar solver numérico para um BVP simples com convergência.",
                                "Identificar instabilidade em IVP marchante com h=0.1.",
                                "Aplicar MRP a BVP de engenharia civil com resíduos baixos.",
                                "Criar tabela comparativa precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de IVP/BVP (90% correto).",
                                "Compreensão de desafios numéricos (exemplos corretos).",
                                "Implementação funcional de solvers (sem erros fatais).",
                                "Análise comparativa profunda (tabela com >5 itens).",
                                "Aplicação contextualizada em MRP/engenharia civil.",
                                "Criatividade em verificações e exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação de solvers em Python/MATLAB.",
                                "Física/Mecânica: Modelagem de EDOs em dinâmicas de estruturas.",
                                "Matemática Aplicada: Teoria de estabilidade de soluções diferenciais.",
                                "Engenharia Computacional: Integração com FEM para problemas de contorno.",
                                "Análise de Dados: Visualização gráfica de soluções e erros."
                              ],
                              "realWorldApplication": "Na engenharia civil, BVPs modelam deformações estáticas em vigas/pilas com apoios fixos (condições de contorno), resolvidos via MRP para precisão em projetos de pontes; IVPs para respostas dinâmicas a terremotos (marcha temporal inicial), evitando instabilidades numéricas em simulações de colapso."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.2",
                        "name": "Adaptação do Método dos Resíduos Ponderados para BVPs",
                        "description": "Modificação do método dos resíduos ponderados (método de Galerkin ou momentos ponderados) para incorporar condições de contorno, utilizando funções de peso que satisfazem as restrições de contorno.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.2.1",
                            "name": "Selecionar funções de peso adequadas",
                            "description": "Escolher funções de teste ou peso que zerem nas fronteiras para condições de Dirichlet, ou suas derivadas para Neumann, adaptando ao problema de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o problema de valor de contorno (BVP) e classificar condições de fronteira",
                                  "subSteps": [
                                    "Leia a equação diferencial e identifique o domínio (ex: [0, L]).",
                                    "Liste todas as fronteiras (ex: x=0, x=L) e suas condições: Dirichlet (valor fixo de u), Neumann (valor fixo de u') ou mistas.",
                                    "Classifique cada fronteira: essencial (Dirichlet) ou natural (Neumann).",
                                    "Anote o número de condições e verifique consistência com a ordem da EDO.",
                                    "Desenhe um diagrama esquemático do domínio com condições anotadas."
                                  ],
                                  "verification": "Crie um resumo escrito ou tabela com classificação de cada fronteira confirmada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, enunciado do problema, calculadora.",
                                  "tips": "Sempre priorize condições essenciais (Dirichlet) para funções que devem zerar nelas.",
                                  "learningObjective": "Identificar e classificar corretamente tipos de condições de contorno em BVPs.",
                                  "commonMistakes": "Confundir Neumann (derivatives) com Dirichlet (valores); ignorar condições mistas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher funções base apropriadas para aproximação da solução",
                                  "subSteps": [
                                    "Selecione uma base de funções lisas no domínio (ex: polinômios, senos/cossenos, splines).",
                                    "Garanta que funções base satisfaçam condições homogêneas triviais se possível.",
                                    "Defina o número de funções base (N) baseado na precisão desejada.",
                                    "Teste continuidade e derivabilidade necessária para a EDO.",
                                    "Esboce ou plote 2-3 funções base iniciais."
                                  ],
                                  "verification": "Verifique se as funções base são linearmente independentes e cumprem requisitos de suavidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de plotagem (MATLAB/Python/Mathematica), papel.",
                                  "tips": "Comece com bases simples como polinômios de Legendre para intervalos finitos.",
                                  "learningObjective": "Selecionar funções base que se adaptem ao domínio e à ordem da EDO.",
                                  "commonMistakes": "Escolher funções que não zeram em fronteiras essenciais; usar N muito pequeno."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir funções de peso baseadas nas condições de contorno",
                                  "subSteps": [
                                    "Para Dirichlet em uma fronteira: escolha pesos w_i que sejam zero nessa fronteira (w_i(boundary)=0).",
                                    "Para Neumann: escolha pesos onde a derivada normal seja zero (w_i'(boundary)=0).",
                                    "Use as mesmas funções base para pesos em métodos como Galerkin, ajustando para BCs.",
                                    "Construa explicitamente w_i(x) = phi_i(x) * produto de fatores que zeram em Dirichlet.",
                                    "Verifique analiticamente w_i e w_i' nas fronteiras relevantes."
                                  ],
                                  "verification": "Calcule w_i e derivadas em todas as fronteiras e confirme zeros onde necessário.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software simbólico (SymPy/MATLAB Symbolic), caderno de anotações.",
                                  "tips": "Para Dirichlet duplo: use senos sin(nπx/L); para misto, multiplique por (x-a) ou similar.",
                                  "learningObjective": "Construir funções de peso que incorporem automaticamente as condições de contorno.",
                                  "commonMistakes": "Aplicar zero de função para Neumann (deve ser derivada); esquecer derivadas em condições naturais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar as funções de peso no método dos resíduos ponderados",
                                  "subSteps": [
                                    "Formule a aproximação u_N(x) = sum c_j phi_j(x).",
                                    "Compute resíduos R(x) = L(u_N) - f(x).",
                                    "Integre ∫ w_i R dx = 0 para i=1 a N e monte o sistema.",
                                    "Resolva o sistema matricial para coeficientes c_j.",
                                    "Compare solução com condições de contorno exatas."
                                  ],
                                  "verification": "Sistema resulta em matriz não-singular e solução satisfaz BCs dentro de tolerância 1e-6.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB/Python para resolução numérica, solver linear.",
                                  "tips": "Use normalização para condicionar melhor a matriz; teste com N=2 primeiro.",
                                  "learningObjective": "Integrar funções de peso no método e validar numericamente.",
                                  "commonMistakes": "Não normalizar pesos levando a ill-conditioned matrices; ignorar verificação de BCs."
                                }
                              ],
                              "practicalExample": "Para -u''=1 em [0,1], u(0)=0 (Dirichlet), u'(1)=0 (Neumann): Escolha w_i(x) = sin((i+1/2)πx) para w_i(0)=0 e w_i'(1)=0. Aproxime u_N = sum c_j w_j, resolva ∫ w_i (-u_N'' -1) dx=0, obtendo solução parabólica aproximada.",
                              "finalVerifications": [
                                "Funções w_i zeram nas fronteiras Dirichlet.",
                                "Derivadas w_i' zeram nas fronteiras Neumann.",
                                "Sistema de equações resulta em matriz simétrica positiva definida.",
                                "Solução u_N satisfaz BCs com erro <1%.",
                                "Resíduos ponderados ∫ w_i R dx ≈0 para todos i.",
                                "Convergência ao aumentar N."
                              ],
                              "assessmentCriteria": [
                                "Classificação correta de BCs (100% precisão).",
                                "Funções w_i cumprem zeros/derivadas exatos (verificação analítica).",
                                "Sistema montado sem erros algébricos.",
                                "Solução numérica converge e respeita BCs.",
                                "Explicação clara da escolha de w_i.",
                                "Eficiência computacional (tempo de setup <2h)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e espaços de Sobolev.",
                                "Programação: Implementação numérica em Python/MATLAB (álgebra linear).",
                                "Física: Modelagem de difusão/tensão em sólidos.",
                                "Engenharia Mecânica: Elementos finitos (Galerkin é caso especial)."
                              ],
                              "realWorldApplication": "Em simulações de estruturas civis, como análise de vigas com apoios fixos (Dirichlet) e livres (Neumann), seleciona pesos para modelar deflexões precisas sem impor BCs manualmente, acelerando solvers FEM em software como ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.1"
                            ]
                          },
                          {
                            "id": "10.1.2.6.2.2",
                            "name": "Formular o funcional de resíduo",
                            "description": "Construir a integral do resíduo multiplicado pela função de peso sobre o domínio, incorporando as condições de contorno essenciais e naturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e classificar as condições de contorno do problema BVP",
                                  "subSteps": [
                                    "Escreva a equação diferencial governante L(u) = f no domínio Ω.",
                                    "Liste todas as condições de contorno especificadas nos limites ∂Ω.",
                                    "Classifique as condições de contorno como essenciais (Dirichlet, u prescrito) ou naturais (Neumann ou Robin, derivadas prescritas).",
                                    "Verifique se as condições essenciais devem ser satisfeitas pela aproximação da solução.",
                                    "Documente o domínio Ω e os limites relevantes."
                                  ],
                                  "verification": "Confirme que todas as BCs estão listadas e classificadas corretamente em um diagrama ou tabela.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência do problema BVP",
                                    "Software de desenho como Draw.io (opcional)"
                                  ],
                                  "tips": "Sempre comece pelo problema físico para contextualizar as BCs; desenhe o domínio para visualização.",
                                  "learningObjective": "Compreender a distinção entre BCs essenciais e naturais no contexto de métodos de resíduos ponderados.",
                                  "commonMistakes": [
                                    "Confundir BCs essenciais com naturais",
                                    "Ignorar BCs em limites múltiplos",
                                    "Não especificar o domínio corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a aproximação da solução e calcular o resíduo",
                                  "subSteps": [
                                    "Escolha funções de aproximação (trial functions) que satisfaçam automaticamente as BCs essenciais.",
                                    "Escreva a solução aproximada como u_h = ∑ c_i φ_i(x), onde φ_i incorporam BCs essenciais.",
                                    "Substitua u_h na equação diferencial para obter o resíduo R = L(u_h) - f.",
                                    "Simplifique a expressão algébrica de R, identificando termos dependentes dos coeficientes c_i.",
                                    "Verifique se R → 0 quando u_h é a solução exata."
                                  ],
                                  "verification": "Calcule R para um caso trivial (solução exata conhecida) e confirme que é zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica como SymPy ou Mathematica",
                                    "Papel para derivações",
                                    "Exemplo de problema simples"
                                  ],
                                  "tips": "Use funções polinomiais ou modais que zerem nas BCs essenciais para simplificar.",
                                  "learningObjective": "Construir uma aproximação admissível e computar o resíduo associado.",
                                  "commonMistakes": [
                                    "Não satisfazer BCs essenciais na aproximação",
                                    "Erros algébricos na substituição de u_h",
                                    "Esquecer termos não lineares se aplicável"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar funções de peso e incorporar BCs naturais",
                                  "subSteps": [
                                    "Escolha funções de peso w_i baseadas no método (ex: Galerkin w_i = φ_i; ou subdomain).",
                                    "Para BCs naturais, identifique os termos de superfície ∫_Γ_n w * (termo natural) dΓ.",
                                    "Garanta que w_i não precisem satisfazer BCs essenciais (exceto em métodos específicos).",
                                    "Escreva a forma fraca preliminar incluindo contribuições de domínio e contorno.",
                                    "Defina o número de funções de peso igual ao número de graus de liberdade."
                                  ],
                                  "verification": "Confirme que as w_i são linearmente independentes e adequadas ao espaço de funções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de funções base (polinomiais, trigonométricas)",
                                    "Software de álgebra computacional"
                                  ],
                                  "tips": "Para Galerkin, use as mesmas φ_i como w_i para simetria; teste com 2-3 funções.",
                                  "learningObjective": "Selecionar pesos que capturem o comportamento do resíduo adequadamente.",
                                  "commonMistakes": [
                                    "Usar pesos que violam simetria do método",
                                    "Esquecer termos de contorno naturais",
                                    "Número incorreto de funções w_i"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir o funcional de resíduo completo",
                                  "subSteps": [
                                    "Formule a integral de domínio: ∫_Ω w_i * R dΩ.",
                                    "Adicione termos de BCs naturais: + ∫_∂Ω_n w_i * g_n dΓ, onde g_n é o fluxo prescrito.",
                                    "Escreva o sistema: ∫_Ω w_i * R dΩ + termos BC naturais = 0 para i=1 a n.",
                                    "Expanda em termos dos coeficientes c_j para obter o sistema matricial.",
                                    "Verifique dimensionalidade e consistência com o problema físico."
                                  ],
                                  "verification": "O funcional deve colapsar para zero quando u_h = u exata, incluindo BCs.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "SymPy ou MATLAB para integração simbólica",
                                    "Papel para expansão matricial"
                                  ],
                                  "tips": "Integre por partes se necessário para formas fracas; anote limites de integração explicitamente.",
                                  "learningObjective": "Montar o funcional integral que incorpora domínio e contornos corretamente.",
                                  "commonMistakes": [
                                    "Erros nos limites de integração",
                                    "Omitir termos de BC naturais",
                                    "Sinais incorretos nos fluxos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o BVP -u'' + u = 0 em [0,1], u(0)=0 (essencial), u'(1)=0 (natural): Aproxime u_h = c1 x + c2 x^2 (satisfaz u(0)=0). Resíduo R = - (2c2 + 2c1 x + c2 x^2) + (c1 x + c2 x^2). Com w1= x, w2= x^2 (Galerkin), funcional: ∫0^1 w_i R dx + w_i(1)*0 = 0.",
                              "finalVerifications": [
                                "O funcional é zero para a solução exata u=0.",
                                "BC essencial é satisfeita por u_h.",
                                "Termos de BC natural estão corretamente incluídos.",
                                "O sistema resultante tem tamanho n x n (n=graus de liberdade).",
                                "Integrações são computáveis analiticamente para teste.",
                                "Coeficientes c_i levam a aproximação física razoável."
                              ],
                              "assessmentCriteria": [
                                "Classificação precisa de BCs essenciais/naturais (20%)",
                                "Aproximação u_h satisfaz BCs essenciais (20%)",
                                "Resíduo R calculado corretamente (20%)",
                                "Funções de peso adequadas e funcional integral completo (25%)",
                                "Verificação de consistência e dimensionalidade (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais e métodos variationais (Galerkin como base para FEM).",
                                "Física: Modelagem de problemas elásticos ou de difusão com BCs mistas.",
                                "Computação: Implementação numérica em Python/MATLAB para integração e resolução matricial.",
                                "Engenharia: Análise de vigas ou placas em estruturas civis."
                              ],
                              "realWorldApplication": "Em engenharia civil, formulação de funcionais de resíduo é essencial para simulações numéricas de estruturas (ex: análise de tensões em vigas com apoios fixos e livres usando métodos de elementos finitos derivados de resíduos ponderados)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.1"
                            ]
                          },
                          {
                            "id": "10.1.2.6.2.3",
                            "name": "Aplicar aproximação polinomial",
                            "description": "Expandir a solução aproximada em base polinomial ou funções próprias, projetando o resíduo para obter equações algébricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formulação do Problema de Contorno e Escolha da Base Polinomial",
                                  "subSteps": [
                                    "Identifique o problema de valor de contorno (BVP) no formato L[u] = f, com condições de contorno especificadas.",
                                    "Escolha uma base polinomial adequada, como polinômios de Legendre ou monomiais truncados, considerando o domínio [a,b].",
                                    "Defina o grau N da aproximação polinomial u_N(x) = ∑_{k=0}^N c_k φ_k(x), onde φ_k são as funções base.",
                                    "Verifique compatibilidade das condições de contorno com a base escolhida.",
                                    "Ajuste a base para satisfazer condições de contorno essenciais, se aplicável."
                                  ],
                                  "verification": "Confirme que a aproximação inicial satisfaz as condições de contorno e que os coeficientes c_k estão livres para otimização.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel ou software como MATLAB/Python (SymPy ou NumPy), referência ao problema BVP específico.",
                                  "tips": "Comece com N baixo (ex: 2-3) para testar; use polinômios ortogonais para melhor convergência.",
                                  "learningObjective": "Compreender como formular uma aproximação polinomial para BVPs no método dos resíduos ponderados.",
                                  "commonMistakes": "Escolher base incompatível com condições de contorno, levando a sistemas singulares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Cálculo do Resíduo da Equação Diferencial",
                                  "subSteps": [
                                    "Substitua a aproximação u_N(x) no operador diferencial L[u_N] - f.",
                                    "Compute o resíduo R_N(x) = L[u_N(x)] - f(x) analiticamente ou simbolicamente.",
                                    "Expresse R_N(x) em termos da base polinomial: R_N(x) = ∑_{k=0}^N r_k φ_k(x).",
                                    "Simplifique expressões derivando termos necessários (ex: integrais de φ_k).",
                                    "Valide o resíduo em pontos de Gauss para verificação numérica inicial."
                                  ],
                                  "verification": "O resíduo deve ser zero nas condições de contorno satisfeitas; plote R_N(x) para visual inspeção.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora simbólica (SymPy, Mathematica) ou software numérico (MATLAB), definições das funções base.",
                                  "tips": "Use expansão em série para facilitar; armazene coeficientes r_k simbolicamente.",
                                  "learningObjective": "Calcular precisamente o resíduo gerado pela aproximação polinomial.",
                                  "commonMistakes": "Erros em derivações diferenciais ou substituição incorreta de coeficientes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projeção do Resíduo Usando Funções de Peso",
                                  "subSteps": [
                                    "Escolha funções de peso w_j(x), tipicamente as mesmas da base φ_j para método de Galerkin.",
                                    "Projete o resíduo: integre ∫_a^b w_j(x) R_N(x) dx = 0 para j=0 a N.",
                                    "Compute as integrais momento: ∑_{k=0}^N c_k ∫ w_j L[φ_k] dx = ∫ w_j f dx.",
                                    "Formule a matriz de rigidez A_{jk} = ∫ w_j L[φ_k] dx e vetor de carga b_j = ∫ w_j f dx.",
                                    "Integre numericamente se analítico for complexo (quadratura de Gauss)."
                                  ],
                                  "verification": "Verifique simetria/ortogonalidade da matriz A se base ortogonal for usada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de integração numérica (SciPy, MATLAB quad), tabelas de integrais de polinômios.",
                                  "tips": "Para polinômios de Legendre, use propriedades de ortogonalidade para simplificar A.",
                                  "learningObjective": "Implementar a projeção do resíduo para gerar equações algébricas.",
                                  "commonMistakes": "Inversão errada de limites de integração ou esquecimento de fatores de normalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolução do Sistema Algébrico e Verificação da Solução",
                                  "subSteps": [
                                    "Monte o sistema linear A c = b, onde c é o vetor de coeficientes.",
                                    "Resolva para c usando decomposição LU ou métodos iterativos.",
                                    "Reconstrua u_N(x) = ∑ c_k φ_k(x).",
                                    "Compare u_N(x) com solução exata (se conhecida) ou refine N para convergência.",
                                    "Avalie o erro L2: ||R_N|| ou ||u_N - u_exata||."
                                  ],
                                  "verification": "Norma do resíduo < 1e-6 e satisfação das condições de contorno dentro de tolerância.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Solver linear (NumPy linalg.solve, MATLAB backslash), plotador (Matplotlib).",
                                  "tips": "Condicione a matriz A checando cond(A); aumente N se mal-condicionada.",
                                  "learningObjective": "Resolver e validar a solução aproximada obtida via resíduos ponderados.",
                                  "commonMistakes": "Não verificar condicionamento numérico, levando a soluções instáveis."
                                }
                              ],
                              "practicalExample": "Resolva o BVP -u''(x) = π² sin(πx) em [0,1] com u(0)=u(1)=0, usando aproximação polinomial de grau 3 com base monomial ajustada. Solução exata: u(x)=sin(πx). Compute resíduo, projete com w_j=φ_j, resolva A c = b e plote u_3(x) vs. exata.",
                              "finalVerifications": [
                                "Resíduo projetado é zero para todos os pesos (∫ w_j R_N dx = 0).",
                                "Condições de contorno satisfeitas: |u_N(a)-g1| < 1e-8 e |u_N(b)-g2| < 1e-8.",
                                "Convergência observada ao aumentar N (erro diminui).",
                                "Matriz A é simétrica positiva definida.",
                                "Erro relativo L2 < 1%.",
                                "Solução física coerente (ex: monotonicidade em problemas de deformação)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação da aproximação e resíduo (80% pesos).",
                                "Correção na projeção e montagem do sistema (15% pesos).",
                                "Eficiência numérica e verificação de erros (5% pesos).",
                                "Clareza na documentação de passos e resultados.",
                                "Capacidade de refinar para maior precisão.",
                                "Interpretação física da solução em contexto de engenharia."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Métodos espectrais e elementos finitos.",
                                "Programação Computacional: Implementação em Python/MATLAB para automação.",
                                "Física Aplicada: Equações diferenciais em mecânica de sólidos.",
                                "Análise Numérica: Estudo de estabilidade e convergência de métodos aproximados."
                              ],
                              "realWorldApplication": "Em engenharia civil, aplica-se para análise aproximada de deformações em vigas ou placas sob cargas distribuídas, onde soluções exatas são inviáveis, permitindo simulações rápidas em software de elementos finitos para projeto de estruturas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.3",
                        "name": "Resolução Numérica e Matriz de Gram",
                        "description": "Construção e resolução do sistema linear resultante do método, envolvendo a matriz de Gram para condicionamento e análise de autovalores em contextos de engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.3.1",
                            "name": "Construir a matriz de Gram",
                            "description": "Calcular os elementos da matriz de Gram como integrais dos produtos das funções base, avaliando numericamente via quadratura de Gauss.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos teóricos da matriz de Gram no Método dos Resíduos Ponderados",
                                  "subSteps": [
                                    "Estude a definição da matriz de Gram como G_{ij} = ∫_Ω φ_i(x) φ_j(x) w(x) dx, onde φ são funções base e w o peso.",
                                    "Identifique o contexto do problema de contorno em Engenharia Civil, como equações diferenciais para vigas ou difusão.",
                                    "Revise propriedades: simetria, positiva definida e dependência do domínio Ω.",
                                    "Esboce um exemplo analítico simples para um caso 1D com duas funções base lineares.",
                                    "Anote as condições de contorno relevantes para o problema."
                                  ],
                                  "verification": "Resuma em um parágrafo as propriedades chave e forneça um esboço matemático correto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de métodos numéricos (ex: Burden & Faires)",
                                    "Caderno para anotações",
                                    "Acesso a documentação do método dos resíduos ponderados"
                                  ],
                                  "tips": "Use analogias com projeções ortogonais para intuitar a matriz.",
                                  "learningObjective": "Compreender o papel matemático e físico da matriz de Gram na formulação fraca.",
                                  "commonMistakes": [
                                    "Confundir com matriz de massa em FEM",
                                    "Ignorar o peso w(x)",
                                    "Esquecer normalização das bases"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir funções base e discretizar o domínio",
                                  "subSteps": [
                                    "Escolha funções base φ_i adequadas ao problema (ex: polinômios de Legendre ou lineares para elementos finitos).",
                                    "Defina o domínio Ω e condições de contorno (ex: [0,L] para viga cantilever).",
                                    "Selecione o número de funções base N (iniciar com N=3-5 para teste).",
                                    "Implemente uma função para avaliar φ_i(x) e φ_j(x) em pontos quaisquer.",
                                    "Plote as funções base para visualização intuitiva."
                                  ],
                                  "verification": "Gere plots das funções base e confirme que satisfazem condições de contorno.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com Matplotlib e NumPy",
                                    "Software como MATLAB ou Jupyter Notebook"
                                  ],
                                  "tips": "Comece com bases ortogonais para simplificar, depois generalize.",
                                  "learningObjective": "Selecionar e implementar bases apropriadas para o problema específico.",
                                  "commonMistakes": [
                                    "Bases que não satisfazem contornos essenciais",
                                    "Escolha de N muito grande inicialmente",
                                    "Não plotar para inspeção visual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e implementar quadratura de Gauss para integrais numéricos",
                                  "subSteps": [
                                    "Escolha ordem da quadratura (ex: 3-5 pontos para precisão inicial).",
                                    "Obtenha nós e pesos de Gauss-Legendre para o intervalo padrão [-1,1].",
                                    "Mapeie o domínio físico Ω para o elemento de referência via transformação jacobiana.",
                                    "Implemente função integrand(x) = φ_i(x) * φ_j(x) * w(x).",
                                    "Teste a quadratura em um integral conhecido analítico para validar."
                                  ],
                                  "verification": "Compare resultado numérico de integral teste com valor exato (erro < 1e-6).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Biblioteca SciPy (quad, gauss quadrature)",
                                    "Tabelas de nós/pesos Gauss ou função geradora"
                                  ],
                                  "tips": "Use scipy.special.roots_legendre para automação.",
                                  "learningObjective": "Dominar avaliação numérica precisa de integrais via quadratura.",
                                  "commonMistakes": [
                                    "Esquecer jacobiano na transformação de variáveis",
                                    "Ordem baixa causando aliasing",
                                    "Não testar com casos simples"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular elementos da matriz e montar estrutura final",
                                  "subSteps": [
                                    "Loop duplo sobre i,j de 1 a N para computar G_{ij} via quadratura.",
                                    "Armazene em matriz NxN (verifique simetria: G_{ij} ≈ G_{ji}).",
                                    "Aplique escalonamento se necessário (ex: fator de normalização).",
                                    "Implemente em código reutilizável com parâmetros modulares.",
                                    "Calcule autovalores para confirmar positiva definida."
                                  ],
                                  "verification": "Matriz simétrica com todos autovalores > 0 e cond(M) < 1e12.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "NumPy para arrays e eigvals",
                                    "Código dos steps anteriores"
                                  ],
                                  "tips": "Exploit simetria computando apenas triângulo superior.",
                                  "learningObjective": "Construir matriz de Gram computacionalmente robusta.",
                                  "commonMistakes": [
                                    "Loop ineficiente O(N^2) sem vetorização",
                                    "Erro de precisão em nós Gauss",
                                    "Não checar condicionamento"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar a matriz de Gram",
                                  "subSteps": [
                                    "Compare com cálculo analítico para caso simples.",
                                    "Teste sensibilidade à ordem de quadratura e N.",
                                    "Integre em solver completo do sistema G a = b.",
                                    "Documente código com comentários e exemplos.",
                                    "Otimize para problemas reais (ex: malha adaptativa)."
                                  ],
                                  "verification": "Solução converge para caso analítico conhecido.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Casos teste analíticos",
                                    "Profiler de código (ex: %timeit)"
                                  ],
                                  "tips": "Salve matriz em formato persistente para reutilização.",
                                  "learningObjective": "Garantir robustez e precisão na implementação final.",
                                  "commonMistakes": [
                                    "Validação insuficiente",
                                    "Ignorar custo computacional para N grande",
                                    "Falta de modularidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de comprimento L=1m com equação v''=1 (carga uniforme), use 3 funções base lineares φ1=x, φ2=x^2, φ3=x^3 ajustadas em contorno v(0)=v'(0)=0. Compute G com quadratura Gauss 4 pontos, resultando em matriz [[0.25, 0.2, 0.2], [0.2, 0.2, 0.25], [0.2, 0.25, 0.4]] aproximada.",
                              "finalVerifications": [
                                "Matriz é simétrica com tolerância 1e-10.",
                                "Todos autovalores positivos (matriz definida positiva).",
                                "Convergência ao refinar quadratura (erro <1%).",
                                "Integração bem-sucedida no solver G a = b.",
                                "Código roda em <1s para N=10.",
                                "Reprodutibilidade em diferentes plataformas."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica dos integrais (erro relativo <1e-5).",
                                "Corretude matemática (simetria e positiva definitude).",
                                "Eficiência computacional (O(N^2) otimizado).",
                                "Robustez a diferentes domínios e bases.",
                                "Clareza e modularidade do código.",
                                "Validação com casos analíticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura e autovalores.",
                                "Programação: Vetorização NumPy/SciPy.",
                                "Física/Mecânica: Formulações fracas em EDOs de vigas.",
                                "Engenharia Computacional: Pré-condicionadores para sistemas lineares."
                              ],
                              "realWorldApplication": "Em análise estrutural de pontes ou edifícios, a matriz de Gram é essencial para solvers numéricos eficientes no Método dos Resíduos Ponderados, permitindo simulações rápidas de deformações sob cargas reais, otimizando projetos civis com precisão e baixo custo computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.2"
                            ]
                          },
                          {
                            "id": "10.1.2.6.3.2",
                            "name": "Resolver o sistema linear",
                            "description": "Aplicar métodos diretos (Gauss) ou iterativos para solucionar o sistema Ax=b obtido, verificando condicionamento via autovalores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Montar o sistema linear Ax=b e verificar condicionamento inicial",
                                  "subSteps": [
                                    "Identifique a matriz A (matriz de Gram do método dos resíduos ponderados) e o vetor b a partir do problema de contorno.",
                                    "Calcule os autovalores de A usando decomposição ou software numérico.",
                                    "Avalie o número de condicionamento cond(A) = |λ_max / λ_min| para determinar se A é bem condicionada (cond < 10^4).",
                                    "Se mal condicionada, considere pré-condicionadores ou refinamento da malha.",
                                    "Documente as dimensões de A e propriedades espectrais."
                                  ],
                                  "verification": "Confirme que cond(A) foi calculado corretamente comparando com solução analítica ou software padrão.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Matriz de Gram do contexto anterior",
                                    "Software numérico (MATLAB, Python com NumPy/SciPy)",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use funções prontas como eig() no MATLAB para autovalores iniciais, mas entenda o algoritmo por trás.",
                                  "learningObjective": "Compreender a origem e estabilidade do sistema linear derivado do método dos resíduos ponderados.",
                                  "commonMistakes": [
                                    "Ignorar autovalores negativos ou complexos",
                                    "Confundir autovalores com autovetores",
                                    "Não normalizar a malha para melhorar condicionamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver o sistema usando método direto: Eliminação de Gauss",
                                  "subSteps": [
                                    "Aplique pivotamento parcial para evitar divisão por zero.",
                                    "Execute eliminação forward para triangularizar A.",
                                    "Realize substituição backward para obter x.",
                                    "Calcule o resíduo r = b - A x e verifique ||r|| < 10^-10.",
                                    "Compare tempo de execução com método iterativo."
                                  ],
                                  "verification": "A solução x satisfaz Ax ≈ b com erro relativo < 10^-8.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Implementação em Python/MATLAB",
                                    "Sistema de teste 3x3 ou 10x10",
                                    "Documentação de algoritmos numéricos"
                                  ],
                                  "tips": "Sempre use pivotamento para estabilidade numérica em matrizes mal condicionadas.",
                                  "learningObjective": "Dominar o método direto de Gauss para soluções exatas em sistemas de tamanho moderado.",
                                  "commonMistakes": [
                                    "Esquecer pivotamento levando a instabilidade",
                                    "Erros de arredondamento em substituição backward",
                                    "Não verificar resíduo final"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar método iterativo para resolução (ex: Gauss-Seidel adaptado a resíduos ponderados)",
                                  "subSteps": [
                                    "Inicialize x^{(0)} com vetor zero ou chute inicial físico.",
                                    "Itere: x^{(k+1)} = D^{-1}(b - (L+U)x^{(k)}) até ||x^{(k+1)} - x^{(k)}|| < tol.",
                                    "Monitore convergência via resíduo ponderado do método original.",
                                    "Ajuste parâmetros de relaxação ω se necessário para aceleração.",
                                    "Compare número de iterações com método direto."
                                  ],
                                  "verification": "Convergência em < 100 iterações com tol = 10^-6.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Código iterativo em Python loop",
                                    "Gráficos de convergência (matplotlib)"
                                  ],
                                  "tips": "Escolha ω ≈ 1.5-1.9 para aceleração em matrizes simétricas positivas definidas.",
                                  "learningObjective": "Aplicar métodos iterativos eficientes para sistemas grandes oriundos de problemas de contorno.",
                                  "commonMistakes": [
                                    "Chute inicial ruim prolongando iterações",
                                    "Não checar simetria/diagonal-dominância para convergência",
                                    "Tolerância muito frouxa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar solução final e analisar sensibilidade",
                                  "subSteps": [
                                    "Compute autovalores exatos da solução e confirme espectro positivo.",
                                    "Calcule erro relativo entre soluções direto e iterativo.",
                                    "Analise sensibilidade: perturbe b em 1% e observe Δx.",
                                    "Valide contra solução analítica para problema pequeno.",
                                    "Gere relatório com gráficos de resíduo vs iteração."
                                  ],
                                  "verification": "Erros < 10^-6 e condicionamento consistente com teoria.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Soluções de ambos métodos",
                                    "Ferramentas de plotagem"
                                  ],
                                  "tips": "Use norma 2 para erros e resíduos para precisão robusta.",
                                  "learningObjective": "Garantir confiabilidade da solução numérica via verificações múltiplas.",
                                  "commonMistakes": [
                                    "Aceitar solução sem checar resíduo",
                                    "Ignorar efeitos de condicionamento em perturbações",
                                    "Comparar apenas soluções finais sem convergência"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga de contorno com 4 nós (sistema 4x4), monte A via matriz de Gram dos resíduos ponderados para equação de Laplace. Resolva Ax=b com Gauss (x = [0.1, 0.3, 0.5, 0.2]) e Gauss-Seidel (converge em 15 iterações), confirmando cond(A)=25 e resíduo 10^-12.",
                              "finalVerifications": [
                                "Autovalores de A são positivos e cond(A) < 10^6.",
                                "Soluções direto e iterativo coincidem em 6 dígitos.",
                                "Resíduo ||Ax - b|| / ||b|| < 10^-8.",
                                "Convergência iterativa monitorada e estável.",
                                "Solução física coerente com contornos do problema.",
                                "Relatório inclui tempos de CPU e gráficos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução (erro relativo < 10^-6).",
                                "Correta implementação de pivotamento e iterações.",
                                "Análise de condicionamento via autovalores precisa.",
                                "Eficiência: <50 iterações para iterativo em n=100.",
                                "Relatório claro com verificações e conclusões.",
                                "Código limpo e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição espectral e normas de matriz.",
                                "Programação Numérica: Implementação em Python/MATLAB.",
                                "Engenharia Estrutural: Aplicação em elementos finitos para vigas/placas.",
                                "Física Computacional: Soluções de EDP por métodos de Galerkin.",
                                "Análise de Dados: Visualização de convergência e sensibilidade."
                              ],
                              "realWorldApplication": "Na análise de estruturas civis via método dos elementos finitos, resolver Ax=b (milhões de eqs.) para tensões em pontes ou edifícios, usando iterativos para eficiência em supercomputadores e verificando condicionamento para evitar colapsos por erros numéricos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.2"
                            ]
                          },
                          {
                            "id": "10.1.2.6.3.3",
                            "name": "Implementar em software numérico",
                            "description": "Codificar o método em MATLAB ou Python, testando em problemas de engenharia civil como deflexão de vigas com contornos fixos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e discretizar o domínio",
                                  "subSteps": [
                                    "Escolha o problema de engenharia civil, como deflexão de viga engastada em ambas as extremidades com carga uniforme q(x).",
                                    "Defina a equação diferencial: EI * d⁴u/dx⁴ = q(x), com condições de contorno u(0)=u'(0)=u(L)=u'(L)=0.",
                                    "Discretize o domínio em N elementos finitos ou pontos nodais (ex: N=20).",
                                    "Defina funções de aproximação (ex: polinômios lineares ou quadráticos) e funções de peso.",
                                    "Calcule comprimento da viga L, módulo EI e carga q."
                                  ],
                                  "verification": "Verifique se a malha discretizada está correta plotando os nós e elementos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python com NumPy e Matplotlib; ou MATLAB.",
                                  "tips": "Use intervalos uniformes para simplicidade inicial.",
                                  "learningObjective": "Entender a formulação matemática e discretização do problema de contorno.",
                                  "commonMistakes": "Ignorar condições de contorno essenciais ou escolher malha muito grosseira."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular resíduos e montar matriz de Gram",
                                  "subSteps": [
                                    "Implemente a aproximação da solução u_h(x) = sum c_i * phi_i(x), onde phi_i são funções base.",
                                    "Calcule o resíduo R(x) = EI * u_h''''(x) - q(x).",
                                    "Defina funções de peso w_j(x) (ex: mesmas phi_i para Galerkin).",
                                    "Monte a matriz de Gram A_ij = ∫ w_i * L[phi_j] dx, onde L é o operador diferencial.",
                                    "Use integração numérica (Gauss-Lobatto) para elementos.",
                                    "Incorpore condições de contorno via penalização ou remoção de graus de liberdade."
                                  ],
                                  "verification": "Confira se a matriz A é simétrica positiva definida imprimindo seus primeiros elementos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python: NumPy para matrizes, SciPy para integração; MATLAB equivalente.",
                                  "tips": "Implemente funções para calcular integrais locais por elemento antes de montar global.",
                                  "learningObjective": "Dominar a formulação do Método dos Resíduos Ponderados e montagem da matriz rígida.",
                                  "commonMistakes": "Erro na ordem de derivação do operador ou esquecimento de fatores EI."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar vetor de carga e resolver o sistema",
                                  "subSteps": [
                                    "Calcule o vetor de carga b_i = ∫ w_i * q(x) dx.",
                                    "Aplique condições de contorno: fixe graus de liberdade correspondentes a u e u' nas extremidades.",
                                    "Resolva o sistema linear A c = b usando solver direto (ex: np.linalg.solve).",
                                    "Verifique condicionamento da matriz com np.linalg.cond(A).",
                                    "Extraia coeficientes c e reconstrua u_h(x)."
                                  ],
                                  "verification": "O sistema resolve sem erros e ||A c - b|| < 1e-10.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "NumPy para solvers lineares; MATLAB backslash operator.",
                                  "tips": "Use sparse matrices para N grande com SciPy.sparse.",
                                  "learningObjective": "Implementar resolução numérica eficiente do sistema oriundo do método.",
                                  "commonMistakes": "Não impor corretamente condições de contorno, levando a soluções instáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e visualizar resultados",
                                  "subSteps": [
                                    "Compare com solução analítica para viga engastada: u(x) conhecida para q constante.",
                                    "Calcule erro L2: ∫ (u_h - u_exata)^2 dx.",
                                    "Plote deflexão u(x), momento e cortante ao longo da viga.",
                                    "Teste convergência refinando a malha (N=10,20,40).",
                                    "Analise tempo de CPU e escalabilidade."
                                  ],
                                  "verification": "Erro < 1% para N=20 e convergência observada nos plots.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Matplotlib para plots; solução analítica em fórmula ou função.",
                                  "tips": "Salve figuras em PDF para relatórios.",
                                  "learningObjective": "Avaliar precisão e validar implementação contra benchmarks.",
                                  "commonMistakes": "Plots em escala errada ocultando erros ou comparação com solução errada."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e generalizar o código",
                                  "subSteps": [
                                    "Torne o código modular: funções para discretização, montagem, solve e plot.",
                                    "Adicione suporte a cargas arbitrárias q(x) e geometrias.",
                                    "Implemente tratamento de contornos gerais (mistos).",
                                    "Adicione logging de erros e warnings.",
                                    "Teste em outro problema, como placa ou fluxo."
                                  ],
                                  "verification": "Código roda para novos parâmetros sem modificações manuais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Git para versionamento; pytest para testes unitários.",
                                  "tips": "Use classes para o solver completo.",
                                  "learningObjective": "Criar código reutilizável e robusto para análises numéricas.",
                                  "commonMistakes": "Código hard-coded para um problema específico."
                                }
                              ],
                              "practicalExample": "Implemente em Python o Método dos Resíduos Ponderados para uma viga de L=10m, EI=1e6 Nm², q=1000 N/m, engastada em x=0 e x=L. Use 20 elementos lineares. Compare deflexão máxima com solução analítica u_max = q L^4 / (384 EI) ≈ 0.0026 m.",
                              "finalVerifications": [
                                "Código executa sem erros para N=20 e produz u(x) suave.",
                                "Erro relativo em deflexão máxima < 0.5%.",
                                "Matriz de Gram é simétrica e bem condicionada (cond < 1e6).",
                                "Convergência quadrática ao refinar malha.",
                                "Plots mostram deflexão, momento e cisalhamento corretos.",
                                "Tempo de execução < 1s para N=100."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução numérica vs. analítica (erro L2 < 1e-3).",
                                "Correta implementação de condições de contorno.",
                                "Eficiência computacional (uso de solvers otimizados).",
                                "Clareza e modularidade do código (comentários e funções).",
                                "Validação com testes de convergência.",
                                "Visualizações informativas e precisas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Integração numérica e métodos espectrais.",
                                "Programação: Estruturas de dados matriciais e OOP.",
                                "Física: Mecânica dos Materiais e Teoria de Vigas.",
                                "Engenharia de Software: Testes unitários e validação.",
                                "Análise de Dados: Plots e análise de erro."
                              ],
                              "realWorldApplication": "Análise preliminar de estruturas em projetos de edifícios e pontes, onde soluções analíticas são inviáveis para geometrias complexas; otimização de software proprietário como ANSYS ou SAP2000 para simulações customizadas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.2"
                            ]
                          },
                          {
                            "id": "10.1.2.6.3.4",
                            "name": "Analisar erros e convergência",
                            "description": "Avaliar precisão da solução via norma do resíduo, refinando malha ou ordem polinomial, relacionando com referências bibliográficas como Chapra e Canale.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular o resíduo da solução aproximada",
                                  "subSteps": [
                                    "Implemente a equação diferencial e condições de contorno do problema.",
                                    "Obtenha a solução numérica usando o método dos resíduos ponderados (ex: Galerkin).",
                                    "Compute o resíduo R(x) = L[u_h(x)] - f(x), onde u_h é a aproximação e L o operador diferencial.",
                                    "Avalie o resíduo em pontos nodais ou de Gauss.",
                                    "Armazene valores para análise subsequente."
                                  ],
                                  "verification": "Verifique se o resíduo é calculado corretamente comparando com uma solução analítica simples conhecida.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Software numérico (MATLAB/Python com NumPy/SciPy)",
                                    "Referência: Chapra e Canale, Capítulo 20",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use funções vetorizadas para eficiência computacional em malhas grandes.",
                                  "learningObjective": "Compreender o conceito de resíduo como medida de erro local na aproximação numérica.",
                                  "commonMistakes": [
                                    "Confundir resíduo com erro exato (resíduo é computável, erro não)",
                                    "Ignorar condições de contorno no cálculo",
                                    "Escolha inadequada de pontos de avaliação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar precisão via normas do resíduo",
                                  "subSteps": [
                                    "Defina normas relevantes: L1 (∫|R| dx), L2 (√∫R² dx), L∞ (max|R|).",
                                    "Integre numericamente as normas usando quadratura de Gauss.",
                                    "Compare normas com tolerâncias pré-definidas (ex: ||R||₂ < 10^{-6}).",
                                    "Registre normas para diferentes refinamentos iniciais.",
                                    "Interprete: norma pequena indica boa precisão local/global."
                                  ],
                                  "verification": "Calcule normas para um problema teste e confirme valores contra solução exata.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python/MATLAB para integração numérica",
                                    "Chapra e Canale, Seção sobre análise de erro"
                                  ],
                                  "tips": "Prefira norma L2 para problemas de energia em engenharia civil.",
                                  "learningObjective": "Selecionar e computar normas apropriadas para quantificar precisão da solução.",
                                  "commonMistakes": [
                                    "Usar norma errada para o contexto (ex: L∞ para erros suaves)",
                                    "Não normalizar pelo tamanho do domínio",
                                    "Arredondamento numérico em integrações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar estudo de convergência por refinamento",
                                  "subSteps": [
                                    "Refine a malha uniformemente (h-refinement: halve h) ou aumente ordem polinomial (p-refinement).",
                                    "Resolva o problema para 3-4 níveis de refinamento.",
                                    "Calcule normas do resíduo para cada nível.",
                                    "Estime taxa de convergência: log(||R_{k+1}|| / ||R_k||) / log(h_{k+1}/h_k).",
                                    "Plote log(norma) vs log(h) para verificar ordem teórica."
                                  ],
                                  "verification": "Observe redução exponencial da norma com refinamento.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Solver FEM simples (FEniCS ou código customizado)",
                                    "Gráficos em Matplotlib"
                                  ],
                                  "tips": "Monitore tempo de CPU para trade-off precisão vs custo.",
                                  "learningObjective": "Executar h/p-refinement e quantificar convergência empírica.",
                                  "commonMistakes": [
                                    "Refinamento não uniforme levando a aliasing",
                                    "Poucos níveis de refinamento para estatística confiável",
                                    "Confundir convergência com consistência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e decidir refinamentos",
                                  "subSteps": [
                                    "Analise gráficos de convergência: verifique se atinge ordem esperada (ex: 2 para linear).",
                                    "Identifique platôs ou oscilações indicando problemas (ex: malha poluída).",
                                    "Decida: refinar mais, trocar elementos ou modelo físico.",
                                    "Compare com solução de referência (alta resolução ou analítica).",
                                    "Documente thresholds para aceitação em projetos reais."
                                  ],
                                  "verification": "Produza relatório com gráficos mostrando convergência abaixo de tolerância.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas de plotagem",
                                    "Templates de relatório LaTeX"
                                  ],
                                  "tips": "Use log-log plots para clareza em ordens de magnitude.",
                                  "learningObjective": "Interpretar estudos de convergência para decisões de modelagem.",
                                  "commonMistakes": [
                                    "Ignorar efeitos de contorno em convergência global",
                                    "Aceitar normas sem contexto físico",
                                    "Sobre-refinar desnecessariamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Relacionar análise com referências bibliográficas",
                                  "subSteps": [
                                    "Consulte Chapra e Canale: revise definições de resíduo e normas.",
                                    "Compare resultados com exemplos de problemas de contorno (ex: Capítulo 28).",
                                    "Identifique limitações do método (ex: locking em FEM).",
                                    "Pesquise papers recentes em engenharia civil para validação.",
                                    "Incorpore citações em relatório final."
                                  ],
                                  "verification": "Cite pelo menos 3 referências justificando escolhas metodológicas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro Chapra e Canale (2ª ed.)",
                                    "Google Scholar para 'Galerkin convergence civil engineering'"
                                  ],
                                  "tips": "Use Zotero para gerenciamento de referências.",
                                  "learningObjective": "Conectar prática numérica com teoria estabelecida.",
                                  "commonMistakes": [
                                    "Citar sem ler contexto",
                                    "Ignorar evoluções pós-Chapra",
                                    "Generalizações sem validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um problema de viga em flexão (d⁴w/dx⁴ = q/EI), use Galerkin com polinômios lineares em 10 elementos. Calcule ||R||₂ = 1.2e-3; refine para 20 elementos, obtendo 3.1e-4 (ordem ~2); pare em ||R||₂ < 1e-5 para projeto de ponte.",
                              "finalVerifications": [
                                "Calcula corretamente resíduo e 3 normas para solução dada.",
                                "Executa h-refinement e estima taxa de convergência com erro <10%.",
                                "Interpreta platô em gráfico como necessidade de p-refinement.",
                                "Decide refinamento baseado em tolerância física (ex: deformação <1mm).",
                                "Cita Chapra e Canale corretamente em contexto de resíduos ponderados.",
                                "Produz relatório com plots e conclusões acionáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de resíduo/normas (90% acurácia).",
                                "Qualidade do estudo de convergência (pelo menos 4 níveis, gráfico log-log).",
                                "Interpretação física correta dos resultados.",
                                "Uso adequado de referências (relevância e citação).",
                                "Eficiência computacional demonstrada (tempo vs precisão).",
                                "Clareza no relatório (estrutura, visualizações)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Análise de erro em EDOs/EQPs.",
                                "Programação: Implementação em Python/MATLAB para solvers FEM.",
                                "Estatística: Regressão log-log para taxas de convergência.",
                                "Física Aplicada: Validação em mecânica dos sólidos.",
                                "Gestão de Projetos: Trade-offs custo-benefício em simulações."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos para análise estrutural de edifícios e pontes, análise de erros garante precisão em predições de tensões/deformações, evitando falhas catastróficas e otimizando designs sustentáveis."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Condicionamento e Matriz de Gram",
                "description": "Análise do condicionamento de sistemas lineares e uso da matriz de Gram para processos ortogonais.",
                "totalSkills": 44,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Número de Condicionamento de Matrizes",
                    "description": "Definição e cálculo do número de condicionamento de uma matriz, medindo a sensibilidade da solução de sistemas lineares a perturbações.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Definição do Número de Condicionamento",
                        "description": "Conceito fundamental que define o número de condicionamento κ(A) de uma matriz A como a razão entre a norma da matriz e a norma de sua inversa, κ(A) = ||A|| * ||A^{-1}||, medindo a sensibilidade da solução de sistemas lineares Ax = b a pequenas perturbações em A ou b.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Definir o número de condicionamento",
                            "description": "Explicar formalmente a definição de κ(A) para matrizes quadradas invertíveis, destacando que valores próximos de 1 indicam bom condicionamento e valores elevados indicam ill-condicionamento, com exemplos simples como matriz identidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Condicionamento Numérico",
                                  "subSteps": [
                                    "Pesquise a definição básica de condicionamento em problemas lineares Ax = b.",
                                    "Identifique que o condicionamento mede a sensibilidade da solução x a perturbações em A ou b.",
                                    "Diferencie condicionamento bem-condicionado (estável) de mal-condicionado (instável).",
                                    "Revise normas de vetores e matrizes como base para o número de condicionamento.",
                                    "Discuta por que matrizes quadradas invertíveis são necessárias."
                                  ],
                                  "verification": "Explique em suas palavras o que significa uma matriz bem-condicionada e dê um exemplo intuitivo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de álgebra linear",
                                    "Notas de aula sobre normas",
                                    "Calculadora"
                                  ],
                                  "tips": "Use analogias como uma ponte estável (bem-condicionada) vs. instável (mal-condicionada).",
                                  "learningObjective": "Compreender intuitivamente o impacto do condicionamento na estabilidade numérica.",
                                  "commonMistakes": "Confundir condicionamento com invertibilidade; lembre-se que toda invertível tem κ finito, mas pode ser grande."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente o Número de Condicionamento κ(A)",
                                  "subSteps": [
                                    "Estude a fórmula κ(A) = ||A|| * ||A⁻¹|| para norma matricial consistente.",
                                    "Aprenda que κ(A) ≥ 1 para qualquer norma, com igualdade para matrizes isométricas.",
                                    "Memorize que κ(A) = 1 implica A ortogonal (norma 2).",
                                    "Derive brevemente por que κ mede amplificação de erros relativos.",
                                    "Escreva a definição em notação matemática precisa."
                                  ],
                                  "verification": "Escreva a fórmula de κ(A) e prove que κ(A) ≥ 1 usando propriedades de normas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para derivações",
                                    "Software como MATLAB ou Python (NumPy) para testar normas"
                                  ],
                                  "tips": "Sempre especifique a norma usada, como ||.||₂ para norma espectral.",
                                  "learningObjective": "Dominar a definição matemática exata de κ(A) e suas propriedades fundamentais.",
                                  "commonMistakes": "Esquecer que κ depende da norma; não use normas inconsistentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular κ(A) para Exemplos Simples",
                                  "subSteps": [
                                    "Calcule κ(I) para matriz identidade n×n, onde ||I|| = ||I⁻¹|| = 1, logo κ=1.",
                                    "Escolha uma matriz diagonal D = diag(1, ε) com ε pequeno e compute κ(D) ≈ 1/ε.",
                                    "Use norma 2: κ₂(A) = σ_max / σ_min, onde σ são valores singulares.",
                                    "Implemente cálculo em software para matriz 2×2 ill-condicionada.",
                                    "Compare resultados com diferentes normas (1, 2, ∞)."
                                  ],
                                  "verification": "Compute κ₂ para A = [[1,0],[0,0.01]] e confirme κ≈100.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Python/MATLAB com funções norm() e inv()"
                                  ],
                                  "tips": "Para norma 2, use SVD para eficiência em matrizes grandes.",
                                  "learningObjective": "Aplicar a definição para calcular κ em casos concretos.",
                                  "commonMistakes": "Erro numérico em inversão direta; prefira SVD para precisão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Valores de κ(A) e Identificar Ill-Condicionamento",
                                  "subSteps": [
                                    "Classifique: κ≈1 (excelente), κ<10 (bom), κ>1000 (ruim).",
                                    "Analise exemplo: matriz identidade (bom) vs. Hilbert (ill-condicionado).",
                                    "Discuta implicações: erro relativo amplificado por κ * máquina_eps.",
                                    "Crie gráfico de κ vs. estabilidade para diferentes matrizes.",
                                    "Resuma regras práticas para engenharia computacional."
                                  ],
                                  "verification": "Interprete κ=10^6 como altamente ill-condicionado e sugira precauções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos gerados em software",
                                    "Tabela de exemplos de matrizes"
                                  ],
                                  "tips": "Registre κ sempre que resolver sistemas lineares em simulações.",
                                  "learningObjective": "Interpretar κ para decisões práticas em computação numérica.",
                                  "commonMistakes": "Ignorar que κ grande não impede solução, mas reduz precisão."
                                }
                              ],
                              "practicalExample": "Para uma matriz de rigidez em análise estrutural de uma viga: A = [[2, -1], [-1, 2]], compute κ₂(A) ≈ 3.41 (bem-condicionado), garantindo precisão em simulações FEM apesar de cargas perturbadas.",
                              "finalVerifications": [
                                "Defina κ(A) corretamente sem consultar notas.",
                                "Calcule κ para matriz identidade e uma diagonal ill-condicionada.",
                                "Explique por que κ(I)=1 e o que significa κ>10^6.",
                                "Compare κ em normas 2 e ∞ para uma matriz 2×2.",
                                "Identifique uma matriz real-world ill-condicionada e sugira remédio."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula matemática de κ(A) (20%)",
                                "Correção nos cálculos de exemplos (30%)",
                                "Interpretação adequada de valores de κ (20%)",
                                "Uso correto de normas e propriedades (15%)",
                                "Aplicação contextual em engenharia (10%)",
                                "Clareza na explicação verbal/escrita (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Normas e valores singulares.",
                                "Cálculo Numérico: Análise de erros em solvers lineares.",
                                "Engenharia Civil: Estabilidade em métodos de elementos finitos (FEM).",
                                "Física: Sensibilidade em sistemas dinâmicos modelados por matrizes.",
                                "Programação: Implementação em Python/MATLAB para análise numérica."
                              ],
                              "realWorldApplication": "Em simulações de estruturas civis via FEM, um alto κ na matriz de rigidez leva a erros amplificados em deformações preditas sob cargas incertas; engenheiros verificam κ para validar modelos antes de decisões de projeto."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Identificar o propósito da medida de condicionamento",
                            "description": "Descrever como o condicionamento quantifica a amplificação de erros relativos na solução de sistemas lineares, relacionando com a estabilidade numérica em problemas de engenharia civil como análise estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Sistemas Lineares e Fontes de Erro",
                                  "subSteps": [
                                    "Revise a forma geral de um sistema linear Ax = b, onde A é a matriz de coeficientes.",
                                    "Identifique fontes comuns de erro: arredondamento numérico, perturbações em b ou A.",
                                    "Calcule exemplos simples de erros absolutos e relativos em soluções exatas vs. aproximadas.",
                                    "Discuta impacto de erros pequenos em entradas vs. saídas amplificadas.",
                                    "Compare sistemas bem-condicionados (erros pouco amplificados) vs. mal-condicionados."
                                  ],
                                  "verification": "Resuma em um parágrafo as fontes de erro e forneça um exemplo numérico simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de álgebra linear, calculadora ou software como MATLAB/Python (NumPy).",
                                  "tips": "Use matrizes 2x2 para visualização intuitiva antes de escalar.",
                                  "learningObjective": "Identificar e quantificar erros em sistemas lineares básicos.",
                                  "commonMistakes": "Confundir erro absoluto com relativo; ignorar propagação de erros em A e b."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Erro Relativo e Amplificação",
                                  "subSteps": [
                                    "Defina erro relativo: ||δx|| / ||x|| para solução x e perturbada x+δx.",
                                    "Analise fórmula aproximada: ||δx|| / ||x|| ≈ κ(A) * (||δb|| / ||b|| + ||δA|| / ||A||), onde κ é o condicionamento.",
                                    "Compute erro relativo para matrizes com diferentes condições (ex: identidade vs. mal-condicionada).",
                                    "Gráfico de amplificação de erros vs. κ(A).",
                                    "Teste com perturbações pequenas (10^-6) e observe saídas."
                                  ],
                                  "verification": "Gere gráfico ou tabela mostrando amplificação para κ=1, 10^3, 10^6.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software NumPy/MATLAB, exemplos de matrizes (Hilbert para mal-condicionada).",
                                  "tips": "Norma 2 ou infinito para simplicidade; foque em interpretação qualitativa.",
                                  "learningObjective": "Relacionar amplificação de erros relativos ao fator de condicionamento.",
                                  "commonMistakes": "Esquecer termo de δA; assumir κ=1 sempre (matrizes bem-condicionadas)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Calcular o Número de Condicionamento κ(A)",
                                  "subSteps": [
                                    "Defina κ(A) = ||A|| * ||A^{-1}|| para norma compatível.",
                                    "Explique propósito: medida de sensibilidade da solução a perturbações.",
                                    "Calcule κ para matrizes simples: identidade (κ=1), shear (alto κ).",
                                    "Interprete: κ=1 (perfeito), κ>10^6 (numéricamente instável).",
                                    "Discuta limites computacionais em precisão de ponto flutuante."
                                  ],
                                  "verification": "Calcule κ para 3 matrizes e classifique cada uma como bem/mal-condicionada.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Calculadora matricial, função cond() no MATLAB/Python.",
                                  "tips": "Use norma 2 para engenharia; verifique simetria positiva definida em estruturas.",
                                  "learningObjective": "Entender κ(A) como quantificador quantitativo do propósito de condicionamento.",
                                  "commonMistakes": "Confundir κ com det(A)=0 (singularidade extrema); ignorar norma escolhida."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Estabilidade Numérica de Análise Estrutural",
                                  "subSteps": [
                                    "Relacione com matriz de rigidez K em [K]{u} = {F}.",
                                    "Simule perturbações em propriedades materiais ou geometria afetando K.",
                                    "Avalie impacto em deslocamentos u (erros amplificados por κ(K)).",
                                    "Discuta implicações: projetos seguros requerem κ baixo para confiabilidade.",
                                    "Compare com métodos analíticos vs. FEM numérico."
                                  ],
                                  "verification": "Analise matriz de rigidez 2x2 de viga e compute κ com perturbação.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Software FEA básico (ex: exemplo em ANSYS ou código Python para truss).",
                                  "tips": "Comece com estrutura 1D simples; foque em interpretação engenheirística.",
                                  "learningObjective": "Conectar condicionamento à estabilidade em problemas de engenharia civil.",
                                  "commonMistakes": "Subestimar erros em malhas finitas; ignorar pré-condicionadores."
                                }
                              ],
                              "practicalExample": "Considere uma treliça simples com matriz de rigidez K 3x3 mal-condicionada devido a membros quase colineares. Perturbe forças F em 0.1% e observe deslocamentos u amplificados em 1000% se κ(K)=10^4, demonstrando risco em análise estrutural real.",
                              "finalVerifications": [
                                "Explicar em 2 minutos o propósito de κ(A) sem fórmulas.",
                                "Classificar matrizes como bem/mal-condicionadas com justificativa.",
                                "Prever qualitativamente amplificação de erro para κ=10^5.",
                                "Relacionar a um exemplo de ponte ou edifício.",
                                "Identificar quando ignorar condicionamento leva a falhas numéricas.",
                                "Discutir trade-offs entre precisão e custo computacional."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: correto entendimento de amplificação de erros (30%).",
                                "Exemplos numéricos: cálculos corretos e interpretações (25%).",
                                "Aplicação contextual: ligação clara com engenharia civil (20%).",
                                "Profundidade: cobertura de sub-passos e dicas (15%).",
                                "Clareza: explicações concisas e sem jargão desnecessário (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física/Estática: estabilidade de estruturas e equilíbrios lineares.",
                                "Computação: análise numérica, algoritmos de solução (Gauss, iterativos).",
                                "Matemática: normas matriciais e análise de erros.",
                                "Estatística: propagação de incertezas em medições experimentais."
                              ],
                              "realWorldApplication": "Em análise de pontes via Método dos Elementos Finitos, alto condicionamento da matriz global pode amplificar erros de modelagem (ex: variações em Young modulus), levando a superestimação de tensões e risco de falha estrutural; engenheiros usam κ para validar modelos antes de construção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Diferenciar condicionamento forward e backward",
                            "description": "Explicar a distinção entre erros forward (na solução x) e backward (em A ou b), usando a definição para ilustrar que κ(A) limita o erro relativo forward por κ(A) vezes o erro backward.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Erros Forward e Backward",
                                  "subSteps": [
                                    "Defina erro forward como a diferença relativa entre a solução exata x e a solução computada \\hat{x}, i.e., ||\\hat{x} - x|| / ||x||.",
                                    "Defina erro backward como a perturbação relativa nos dados de entrada, i.e., ||\\Delta A|| / ||A|| ou ||\\Delta b|| / ||b||, tal que A\\hat{x} = (A + \\Delta A)\\hat{x} + \\Delta b.",
                                    "Identifique que o erro forward afeta a saída, enquanto o backward mede estabilidade do algoritmo em relação a perturbações nos inputs.",
                                    "Compare com analogia: forward é erro no resultado final; backward é 'quanto o problema mudou para justificar o resultado'.",
                                    "Anote exemplos qualitativos de cenários onde cada um ocorre."
                                  ],
                                  "verification": "Escreva definições precisas e compare-as em uma tabela; confira com referência padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de álgebra numérica (ex: Golub & Van Loan)",
                                    "Bloco de notas",
                                    "Calculadora simbólica (ex: SymPy online)"
                                  ],
                                  "tips": "Use notação matemática consistente; foque em relatividade dos erros.",
                                  "learningObjective": "Distinguir conceitualmente erros forward e backward em problemas lineares Ax=b.",
                                  "commonMistakes": [
                                    "Confundir forward com absoluto em vez de relativo",
                                    "Ignorar que backward é sobre estabilidade algorítmica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar a Definição do Número de Condicionamento κ(A)",
                                  "subSteps": [
                                    "Calcule κ(A) = ||A|| * ||A^{-1}|| para norma escolhida (ex: norma 2).",
                                    "Explique que κ(A) ≥ 1 mede sensibilidade do problema a perturbações.",
                                    "Compute κ(A) para matrizes bem e mal condicionadas (ex: identidade vs. Hilbert 2x2).",
                                    "Discuta limites: κ(A)=1 implica A unitariamente invariante; κ grande indica ill-conditioned.",
                                    "Verifique propriedades: κ(αA)=κ(A), κ(AB) ≤ κ(A)κ(B)."
                                  ],
                                  "verification": "Calcule κ para duas matrizes de exemplo e interprete valores (ex: κ<10 bom; >1000 ruim).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software MATLAB/Python (NumPy/SciPy)",
                                    "Matrizes de teste pré-definidas"
                                  ],
                                  "tips": "Use norma espectral para insights; evite normas inconsistentes.",
                                  "learningObjective": "Dominar cálculo e interpretação de κ(A) como amplificador de erros.",
                                  "commonMistakes": [
                                    "Esquecer multiplicar por ||A^{-1}||",
                                    "Usar norma errada sem especificar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Relação entre Erros Forward e Backward via κ(A)",
                                  "subSteps": [
                                    "Parta de A x = b exato e solução computada \\hat{x} com A \\hat{x} ≈ b + \\Delta b.",
                                    "Mostre ||\\hat{x} - x|| / ||x|| ≤ κ(A) * (||\\Delta A|| / ||A|| + ||\\Delta b|| / ||b||).",
                                    "Prove usando desigualdades de normas: ||x|| ≤ ||A^{-1}|| ||b|| e substitua.",
                                    "Ilustre que κ(A) amplifica erro backward em até κ(A) vezes no forward error.",
                                    "Discuta cenários: algoritmo backward stable + problema bem condicionado → forward pequeno."
                                  ],
                                  "verification": "Derive a inequação em papel e verifique com contraexemplo se κ=1 implica forward=backward.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para derivação",
                                    "Referência: Trefethen & Bau, Numerical Linear Algebra"
                                  ],
                                  "tips": "Assuma normas compatíveis; normalize b para simplificar.",
                                  "learningObjective": "Entender matematicamente como κ(A) liga forward e backward errors.",
                                  "commonMistakes": [
                                    "Omitir termos relativos",
                                    "Confundir bounds com igualdades"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Distinção em um Exemplo Numérico Simples",
                                  "subSteps": [
                                    "Escolha A = [[1,1],[1,1+ε]] com ε pequeno (mal condicionada), b=[3,3+δ].",
                                    "Compute x exato, \\hat{x} via eliminação gaussiana com ruído.",
                                    "Meça erros forward e backward; calcule κ(A) e verifique bound.",
                                    "Repita com A identidade (bem condicionada) para contraste.",
                                    "Gráfice erros vs. ε para visualizar amplificação por κ."
                                  ],
                                  "verification": "Confirme numericamente que forward error ≈ κ * backward error.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python/Jupyter com NumPy",
                                    "Gráficos via Matplotlib"
                                  ],
                                  "tips": "Use ε=1e-6; machine epsilon ~1e-16.",
                                  "learningObjective": "Aplicar distinção para diagnosticar problemas numéricos.",
                                  "commonMistakes": [
                                    "Não perturbar corretamente para backward",
                                    "Ignorar scaling de normas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise estrutural de uma treliça simples, resolva K u = f onde K é matriz de rigidez mal condicionada (κ~10^6). Um pequeno erro de arredondamento no input (backward ~1e-15) causa deslocamentos errados em 1% (forward ~1e-9), mostrando amplificação por κ. Diferencie: forward afeta precisão de u; backward mede robustez do solver.",
                              "finalVerifications": [
                                "Explique verbalmente a distinção sem consultar notas.",
                                "Derive o bound forward ≤ κ * backward em <5 min.",
                                "Identifique em código qual erro é forward/backward para um sistema dado.",
                                "Preveja comportamento para κ=10^3 e backward=1e-14.",
                                "Diferencie de estabilidade forward (algoritmo) vs. problema.",
                                "Aplique a um exemplo novo não visto."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusão.",
                                "Derivação matemática: passos lógicos e normas consistentes.",
                                "Interpretação numérica: cálculos exatos com bound verificado.",
                                "Aplicação contextual: liga a engenharia civil adequadamente.",
                                "Clareza explicativa: usa exemplos e analogias eficazes.",
                                "Profundidade: discute limitações do bound (ex: não sharp sempre)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Similar a propagação de variância em regressão linear.",
                                "Física: Erros em simulações FEM de estruturas (matrizes de rigidez).",
                                "Computação: Análise de estabilidade em solvers de PDEs.",
                                "Otimização: Condicionamento em gradientes para métodos de Newton."
                              ],
                              "realWorldApplication": "Na engenharia civil, ao simular deformações em barragens via elementos finitos, matrizes mal condicionadas (alta κ devido a geometria alongada) amplificam erros de arredondamento (backward) em previsões de falha (forward error), guiando escolha de pré-condicionadores para manter precisão estrutural."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Normas de Matrizes no Cálculo do Condicionamento",
                        "description": "Normas matriciais compatíveis usadas para computar κ(A), como norma 1 (coluna máxima), norma infinito (linha máxima), norma 2 (espectral, via autovalores) e norma de Frobenius, com ênfase na independência do valor exato de κ em relação à norma escolhida para matrizes bem comportadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Calcular normas matriciais básicas",
                            "description": "Computar ||A||_1, ||A||_∞ e ||A||_F para matrizes 2x2 ou 3x3, explicando fórmulas: máximo de somas de colunas absolutas para norma 1, máximo de somas de linhas para norma ∞, e raiz da soma de quadrados de elementos para Frobenius.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as definições e fórmulas das normas matriciais básicas",
                                  "subSteps": [
                                    "Estude a definição da norma 1: máximo das somas dos valores absolutos das colunas.",
                                    "Analise a norma infinito: máximo das somas dos valores absolutos das linhas.",
                                    "Revise a norma de Frobenius: raiz quadrada da soma dos quadrados de todos os elementos da matriz.",
                                    "Compare as três normas com exemplos vetoriais simples para intuitar diferenças.",
                                    "Anote as fórmulas em seu próprio papel para fixação."
                                  ],
                                  "verification": "Escreva as três fórmulas corretamente de memória e identifique qual norma usa máximo por colunas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Referência de álgebra linear (livro ou PDF)"
                                  ],
                                  "tips": "Visualize as normas como 'tamanhos' da matriz; associe norma 1 a colunas e infinito a linhas.",
                                  "learningObjective": "Dominar as fórmulas exatas e o significado geométrico das normas ||A||_1, ||A||_∞ e ||A||_F.",
                                  "commonMistakes": [
                                    "Confundir soma de colunas com linhas",
                                    "Esquecer valores absolutos",
                                    "Confundir Frobenius com norma euclidiana simples sem raiz"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a norma 1 e norma infinito para matrizes 2x2",
                                  "subSteps": [
                                    "Escolha uma matriz 2x2 exemplo: A = [[1, -2], [3, 4]].",
                                    "Para norma 1: some absolutos de cada coluna (col1: |1|+|3|=4; col2: |-2|+|4|=6) e pegue máximo (6).",
                                    "Para norma ∞: some absolutos de cada linha (linha1: |1|+|-2|=3; linha2: |3|+|4|=7) e pegue máximo (7).",
                                    "Repita com outra matriz 2x2 aleatória gerada por você.",
                                    "Verifique cálculos trocando linhas/colunas intencionalmente para testar compreensão."
                                  ],
                                  "verification": "Os resultados para A devem ser ||A||_1 = 6 e ||A||_∞ = 7; confirme com calculadora.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre liste somas intermediárias para evitar erros aritméticos.",
                                  "learningObjective": "Aplicar fórmulas de normas induzidas para matrizes pequenas com precisão.",
                                  "commonMistakes": [
                                    "Não usar módulo nos negativos",
                                    "Somar máximo por elemento em vez de por linha/coluna"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a norma de Frobenius e praticar em matrizes 3x3",
                                  "subSteps": [
                                    "Para a matriz A 2x2 anterior, calcule Frobenius: soma quadrados (1+4+9+16=30), raiz ≈5.477.",
                                    "Crie uma matriz 3x3 exemplo: B = [[1,0,2],[ -1,3,0],[2,1,-1]].",
                                    "Calcule ||B||_F: soma quadrados todos elementos (1+0+4 +1+9+0 +4+1+1=21), raiz ≈4.583.",
                                    "Recalcule normas 1 e ∞ para B para prática integrada.",
                                    "Compare valores numéricos das três normas."
                                  ],
                                  "verification": "Confira ||A||_F ≈5.477 e ||B||_F ≈4.583; valores exatos via sqrt(30) e sqrt(21).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora com funções sqrt",
                                    "Papel",
                                    "Opcional: Python/NumPy para verificação"
                                  ],
                                  "tips": "Use soma de quadrados como familiar (similar a energia em vetores).",
                                  "learningObjective": "Computar norma Frobenius independentemente e integrá-la com outras normas.",
                                  "commonMistakes": [
                                    "Esquecer raiz quadrada",
                                    "Somar quadrados sem absolutos (mas não precisa para F)",
                                    "Erro em contagem de elementos 3x3"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar consistência e preparar para condicionamento",
                                  "subSteps": [
                                    "Para matrizes A e B, liste todas normas e verifique propriedades (ex: ||A||_F ≤ sqrt(mn) * max| a_ij |).",
                                    "Calcule normas para uma matriz diagonal simples e observe padrões.",
                                    "Discuta verbalmente ou por escrito como normas relacionam ao condicionamento (cond(A) ≥ ||A|| * ||A^{-1}||).",
                                    "Resolva exercício: encontre normas para matriz identidade 2x2 (todas=1 ou sqrt(2) para F).",
                                    "Autoavalie erros comuns identificados."
                                  ],
                                  "verification": "Normas da identidade: ||I||_1=1, ||I||_∞=1, ||I||_F=sqrt(2)≈1.414.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel",
                                    "Referência rápida de fórmulas"
                                  ],
                                  "tips": "Lembre: normas medem 'tamanho'; usadas para bound erros em engenharia.",
                                  "learningObjective": "Integrar cálculos em contexto de análise numérica e condicionamento.",
                                  "commonMistakes": [
                                    "Ignorar contexto de engenharia",
                                    "Confundir com normas vetoriais puras"
                                  ]
                                }
                              ],
                              "practicalExample": "Matriz A = [[2, -1], [1, 3]] (de sistema de equações em estruturas). ||A||_1 = max(3,4)=4; ||A||_∞ = max(3,4)=4; ||A||_F = sqrt(4+1+1+9)=sqrt(15)≈3.873. Use para estimar cond(A) ≈ ||A|| * ||A^{-1}||.",
                              "finalVerifications": [
                                "Calculou corretamente as três normas para duas matrizes 2x2 e uma 3x3 independentes.",
                                "Explicou verbalmente as diferenças entre normas 1, ∞ e F.",
                                "Identificou e corrigiu um erro comum simulado (ex: sem absolutos).",
                                "Relacionou normas ao número de condicionamento.",
                                "Verificou cálculos com software ou manualmente sem discrepâncias.",
                                "Listou fórmulas de memória sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão aritmética nos cálculos (100% correto).",
                                "Compreensão conceitual: explicação clara das fórmulas.",
                                "Eficiência: somas intermediárias mostradas.",
                                "Aplicação contextual: ligação com condicionamento.",
                                "Criatividade: exemplos próprios gerados.",
                                "Autoavaliação: identificação de erros potenciais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar funções em Python/NumPy para normas (linalg.norm).",
                                "Física/Engenharia: Normas em vetores de forças ou deslocamentos estruturais.",
                                "Análise Numérica: Uso em estabilidade de métodos iterativos.",
                                "Estatística: Similar a desvios em matrizes de covariância."
                              ],
                              "realWorldApplication": "Em engenharia civil, calcular normas de matrizes de rigidez para avaliar condicionamento numérico em simulações FEM (Finite Element Method), previnindo erros de arredondamento em análises de estruturas como pontes ou edifícios sob cargas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Entender a norma espectral (2)",
                            "description": "Definir ||A||_2 como a raiz quadrada do maior autovalor de A^T A, relacionando com o número de condicionamento κ_2(A) = σ_max / σ_min, onde σ são valores singulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de autovalores e autovetores",
                                  "subSteps": [
                                    "Defina autovalor λ e autovetor v tal que Av = λv para matriz A quadrada.",
                                    "Explique o polinômio característico det(A - λI) = 0 e como resolvê-lo.",
                                    "Discuta propriedades de matrizes simétricas positivas definidas, onde autovalores são reais e positivos.",
                                    "Calcule autovalores para uma matriz 2x2 simples, como [[2,1],[1,2]].",
                                    "Verifique ortogonalidade de autovetores para matrizes simétricas."
                                  ],
                                  "verification": "Resolva corretamente o polinômio característico de uma matriz 2x2 e liste autovalores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel, calculadora ou Python com NumPy (np.linalg.eig).",
                                  "tips": "Use decomposição para matrizes pequenas; software acelera para maiores.",
                                  "learningObjective": "Compreender a base teórica de autovalores necessária para normas espectrais.",
                                  "commonMistakes": "Confundir autovalor (escalar) com autovetor (vetor); esquecer normalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e analisar a matriz A^T A",
                                  "subSteps": [
                                    "Compute A^T, a transposta de A, trocando linhas por colunas.",
                                    "Multiplique A^T A, resultando em matriz simétrica positiva semi-definida.",
                                    "Prove que autovalores de A^T A são não-negativos (λ ≥ 0).",
                                    "Exemplo: Para A = [[1,0],[0,2]], compute A^T A = [[1,0],[0,4]].",
                                    "Discuta independência linear dos autovetores."
                                  ],
                                  "verification": "Construa A^T A para matriz dada e confirme simetria (A^T A = (A^T A)^T).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matriz de exemplo impressa, MATLAB ou Jupyter Notebook.",
                                  "tips": "A^T A captura 'energia' das colunas de A; visualize como produto interno.",
                                  "learningObjective": "Entender por que A^T A é chave para normas induzidas por vetores.",
                                  "commonMistakes": "Erro em transposição (confundir linhas/colunas); multiplicação matricial incorreta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a norma espectral ||A||_2",
                                  "subSteps": [
                                    "Defina ||A||_2 = sqrt(λ_max), onde λ_max é o maior autovalor de A^T A.",
                                    "Relacione com norma vetorial euclidiana: ||A||_2 = sup_{||x||=1} ||Ax||_2.",
                                    "Calcule para A = [[3,0],[0,4]]: A^T A = [[9,0],[0,16]], λ_max=16, ||A||_2=4.",
                                    "Compare com outras normas (ex: norma de Frobenius).",
                                    "Prove submultiplicatividade: ||AB||_2 ≤ ||A||_2 ||B||_2."
                                  ],
                                  "verification": "Calcule ||A||_2 para matriz 2x2 e confirme com definição sup.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software NumPy/MATLAB (np.linalg.norm(A, 2)), calculadora.",
                                  "tips": "||A||_2 é o 'ganho máximo' de A; teste com vetores unitários.",
                                  "learningObjective": "Dominar definição precisa da norma espectral.",
                                  "commonMistakes": "Esquecer raiz quadrada (usar λ_max diretamente); confundir com autovalor de A."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir valores singulares e relação com norma",
                                  "subSteps": [
                                    "Defina valores singulares σ_i = sqrt(λ_i) de A^T A, ordenados σ_1 ≥ σ_2 ≥ ... ≥ 0.",
                                    "Explique SVD: A = U Σ V^T, onde σ_max = ||A||_2, σ_min é o menor não-zero.",
                                    "Calcule SVD parcial para matriz diagonal.",
                                    "Relacione: ||A||_2 = σ_max(A).",
                                    "Discuta rank(A) = número de σ_i > 0."
                                  ],
                                  "verification": "Liste σ_i para A^T A exemplo e confirme σ_max = ||A||_2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (np.linalg.svd), notas sobre SVD.",
                                  "tips": "SVD generaliza autodecomposição; foque em diags de Σ.",
                                  "learningObjective": "Conectar norma espectral aos valores singulares.",
                                  "commonMistakes": "Confundir σ_i com autovalores de A (não de A^T A); ignorar σ_min=0 para singular."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Relacionar com número de condicionamento κ_2(A)",
                                  "subSteps": [
                                    "Defina κ_2(A) = ||A||_2 ||A^{-1}||_2 = σ_max / σ_min (para A invertível).",
                                    "Explique impacto: κ grande amplifica erros em soluções Ax=b.",
                                    "Calcule para A = [[1,1],[1,1+ε]], observe κ → ∞ quando ε→0.",
                                    "Interprete: κ=1 (ortogonal), κ>1 il-condicionado.",
                                    "Discuta em contexto numérico: evite κ>10^6 em MEF."
                                  ],
                                  "verification": "Compute κ_2 para matriz exemplo usando σ_max/σ_min.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplos de matrizes mal-condicionadas, software para SVD.",
                                  "tips": "Teste estabilidade invertendo A e resolvendo sistemas.",
                                  "learningObjective": "Aplicar norma espectral ao condicionamento matricial.",
                                  "commonMistakes": "Usar σ de A ao invés de A^T A; esquecer A^{-1} para σ_min."
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 2], [3, 4]] (matriz de transformação em análise estrutural). Compute A^T A = [[10, 14], [14, 20]]. Autovalores: ≈27.37 e 2.63. ||A||_2 ≈ sqrt(27.37) ≈ 5.23. SVD dá σ_max≈5.23, σ_min≈0.89, κ_2≈5.86. Verifique numericamente com ||Ax||/||x|| max.",
                              "finalVerifications": [
                                "Defina corretamente ||A||_2 em termos de autovalor máximo de A^T A.",
                                "Calcule ||A||_2 e valores singulares para matriz 2x2 fornecida.",
                                "Explique relação σ_i = sqrt(λ_i) e identifique σ_max = ||A||_2.",
                                "Compute κ_2(A) = σ_max / σ_min e interprete valor (ex: κ=1 bem-condicionado).",
                                "Prove que ||A||_2 ≥ ||A||_F / sqrt(n) para matriz nxn.",
                                "Aplique a uma matriz de rigidez simples em engenharia."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual na definição de ||A||_2 e relação com SVD (70%).",
                                "Correção em cálculos numéricos de autovalores/singulares (20%).",
                                "Capacidade de interpretação e ligação com condicionamento (10%).",
                                "Clareza na explicação de propriedades (simetria, positividade).",
                                "Uso adequado de software para verificação.",
                                "Identificação de erros comuns em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Autovalores, SVD e decomposições.",
                                "Cálculo Numérico: Estabilidade e erros de arredondamento.",
                                "Programação Computacional: Implementação em Python/MATLAB.",
                                "Engenharia Estrutural: Condicionamento em MEF e matrizes de rigidez.",
                                "Física: Normas em espaços vetoriais euclidianos."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, ao resolver sistemas K u = f (matriz de rigidez K em Método dos Elementos Finitos), alto κ_2(K) causa instabilidade numérica, amplificando erros de discretização ou carga; usar pré-condicionadores baseados em SVD melhora precisão em simulações de pontes ou barragens."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Comparar diferentes normas",
                            "description": "Analisar como κ varia ligeiramente entre normas para a mesma matriz, com exemplos numéricos mostrando que κ_2 ≤ κ_1 ≤ n κ_2 para matrizes n x n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições das Normas de Matriz 1 e 2",
                                  "subSteps": [
                                    "Defina a norma 1 (norma máxima de colunas): ||A||_1 = max_j Σ_i |a_ij|.",
                                    "Defina a norma 2 (norma espectral): ||A||_2 = maior valor singular de A, ou sqrt(λ_max(A^T A)).",
                                    "Explique a relação entre normas para vetores induzidas: propriedades submultiplicativas.",
                                    "Liste propriedades chave: ||I||_p = 1 para qualquer p, e compatibilidade com normas vetoriais.",
                                    "Compare com norma Frobenius brevemente para contexto."
                                  ],
                                  "verification": "Escreva as fórmulas das normas 1 e 2 corretamente e calcule ||I||_1 e ||I||_2 para matriz identidade 2x2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora, referência de livro de álgebra linear (ex: Strang).",
                                  "tips": "Lembre-se que norma 1 é fácil de calcular por colunas; norma 2 requer autovalores.",
                                  "learningObjective": "Compreender precisamente as definições matemáticas das normas 1 e 2 para matrizes.",
                                  "commonMistakes": "Confundir norma 1 de matriz com norma 1 de vetor; esquecer que norma 2 é sqrt do maior autovalor de A^T A."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Normas e Inversas para uma Matriz Exemplo Simples",
                                  "subSteps": [
                                    "Escolha uma matriz A 2x2 mal condicionada, ex: A = [[1, 1], [1, 1.0001]].",
                                    "Calcule ||A||_1 e ||A||_2 manualmente.",
                                    "Encontre A^{-1} e calcule ||A^{-1}||_1 e ||A^{-1}||_2.",
                                    "Verifique det(A) ≠ 0 e compute numericamente com ferramenta se possível.",
                                    "Registre valores exatos ou aproximados."
                                  ],
                                  "verification": "Confirme que κ_1 = ||A||_1 ||A^{-1}||_1 e κ_2 = ||A||_2 ||A^{-1}||_2 foram calculados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora científica, Python/MATLAB (opcional com numpy.linalg.norm), papel.",
                                  "tips": "Use expansão de Laplace para inversa pequena; normalize matriz se necessário.",
                                  "learningObjective": "Aplicar cálculos de normas e inversas para obter números de condicionamento iniciais.",
                                  "commonMistakes": "Erro em cálculo de inversa; usar norma errada (ex: Frobenius em vez de 2)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar κ_1 e κ_2 Numericamente para Múltiplas Matrizes",
                                  "subSteps": [
                                    "Teste com A 2x2 acima: compute κ_1 ≈ 2000, κ_2 ≈ 1000.",
                                    "Teste matriz 3x3, ex: Hilbert-like mal condicionada.",
                                    "Observe κ_2 ≤ κ_1 em ambos casos.",
                                    "Aumente para n=3 e verifique fator n: κ_1 ≤ 3 κ_2?",
                                    "Tabule resultados em tabela comparativa."
                                  ],
                                  "verification": "Crie tabela mostrando κ_2 ≤ κ_1 ≤ n κ_2 para pelo menos duas matrizes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha Excel ou Python script para normas, matrizes impressas.",
                                  "tips": "Use np.linalg.cond(A, p=1) e p=2 no NumPy para validação rápida.",
                                  "learningObjective": "Observar empiricamente a variação de κ entre normas com exemplos numéricos.",
                                  "commonMistakes": "Escolher matrizes bem condicionadas (κ≈1), onde diferenças são sutis; arredondamentos numéricos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar e Provar a Desigualdade Teórica κ_2 ≤ κ_1 ≤ n κ_2",
                                  "subSteps": [
                                    "Lembre desigualdades de normas: ||A||_2 ≤ ||A||_1 ≤ sqrt(n) ||A||_2 para norma F, mas foque em 1 e 2.",
                                    "Prove κ_2 ≤ κ_1 usando ||.||_2 ≤ ||.||_1 para operadores.",
                                    "Mostre ||A||_1 ≤ n ||A||_∞ e relações para κ.",
                                    "Derive κ_1 ≤ n κ_2 citando teorema padrão (ex: Golub-Van Loan).",
                                    "Aplique a matrizes de Gram em contexto civil."
                                  ],
                                  "verification": "Escreva prova curta ou passos lógicos confirmando a desigualdade para n x n.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de referência (ex: Numerical Linear Algebra), notas anteriores.",
                                  "tips": "Busque 'norm equivalence matrix conditioning' online para lembrete rápido.",
                                  "learningObjective": "Entender e demonstrar rigorosamente por que κ varia ligeiramente entre normas.",
                                  "commonMistakes": "Confundir normas vetoriais com matriciais; ignorar dimensão n na desigualdade."
                                }
                              ],
                              "practicalExample": "Para A = [[1,1],[1,1+ε]] com ε=10^{-6}, n=2: ||A||_1≈2, ||A^{-1}||_1≈10^6, κ_1≈2e6; ||A||_2≈1+ε/2, ||A^{-1}||_2≈1/ε, κ_2≈1e6. Note κ_2 < κ_1 < 2 κ_2.",
                              "finalVerifications": [
                                "Calcule κ_1 e κ_2 para três matrizes diferentes e confirme κ_2 ≤ κ_1.",
                                "Verifique desigualdade κ_1 ≤ n κ_2 para n=2,3.",
                                "Explique verbalmente por que κ_2 é preferida em teoria.",
                                "Aplique a uma matriz de rigidez 2D simples.",
                                "Identifique norma mais conservadora para bound de erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de normas (erro <1%).",
                                "Correta identificação de κ_2 ≤ κ_1 ≤ n κ_2 em exemplos.",
                                "Explicação clara da variação entre normas.",
                                "Uso apropriado de ferramentas numéricas.",
                                "Conexão com condicionamento em problemas reais.",
                                "Ausência de erros comuns em inversas ou normas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar normas em Python/MATLAB.",
                                "Álgebra Linear: Autovalores e SVD para norma 2.",
                                "Estatística: Condicionamento em regressão linear.",
                                "Engenharia Computacional: Análise de elementos finitos."
                              ],
                              "realWorldApplication": "Em análise estrutural de edifícios (Engenharia Civil), matrizes de rigidez de elementos finitos são mal condicionadas; comparar κ_1 e κ_2 ajuda a escolher solvers numéricos estáveis, evitando amplificação de erros de arredondamento em simulações de tensões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Cálculo e Interpretação do Número de Condicionamento",
                        "description": "Procedimentos computacionais para obter κ(A) via inversão ou decomposição SVD, e interpretação prática da sensibilidade em soluções de sistemas lineares na engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Calcular κ(A) manualmente para matrizes pequenas",
                            "description": "Resolver passo a passo: calcular A^{-1} por Gauss-Jordan, aplicar normas escolhidas e multiplicar, para matrizes 2x2 exemplificando κ=1 (ortogonais) vs κ>10^3 (ill-condicionadas).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e preparar matrizes de exemplo 2x2",
                                  "subSteps": [
                                    "Escolha uma matriz ortogonal 2x2, como A = [[1/sqrt(2), 1/sqrt(2)], [-1/sqrt(2), 1/sqrt(2)]] (rotação normalizada).",
                                    "Escolha uma matriz ill-condicionada, como B = [[1, 0], [0, 0.001]] ou [[1,1],[1,1.001]].",
                                    "Verifique dimensões e propriedades iniciais (determinante ≠ 0).",
                                    "Anote as matrizes em papel para Gauss-Jordan.",
                                    "Defina a norma a usar: norma infinito (máxima soma de linha absoluta) para cálculo manual simples."
                                  ],
                                  "verification": "Matrizes anotadas corretamente com det(A) ≠ 0 e normas definidas; confira multiplicando A * A^T ≈ I para ortogonal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis",
                                    "Calculadora básica"
                                  ],
                                  "tips": [
                                    "Use matrizes simétricas positivas definidas para ill-conditioned reais.",
                                    "Normalize para evitar frações grandes."
                                  ],
                                  "learningObjective": "Preparar exemplos concretos para ilustrar extremos de condicionamento (κ≈1 vs κ>>1).",
                                  "commonMistakes": [
                                    "Escolher matriz singular (det=0)",
                                    "Ignorar normalização para κ=1",
                                    "Usar normas inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular A^{-1} usando eliminação Gauss-Jordan",
                                  "subSteps": [
                                    "Forme [A | I] para a matriz 2x2 (I identidade 2x2).",
                                    "Aplique operações elementares: pivoteamento, eliminação para transformar A em I.",
                                    "Registre passos: subtraia múltiplos de linhas, divida pivôs.",
                                    "A parte direita torna-se A^{-1}; verifique A * A^{-1} = I.",
                                    "Repita para ambas matrizes (ortogonal e ill-conditioned)."
                                  ],
                                  "verification": "Multiplique A * resultado = I (com tolerância 10^{-3}); confira manualmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para multiplicações"
                                  ],
                                  "tips": [
                                    "Faça cópias para não errar operações reversíveis.",
                                    "Pivoteie sempre para estabilidade."
                                  ],
                                  "learningObjective": "Dominar Gauss-Jordan para inversas exatas em baixas dimensões.",
                                  "commonMistakes": [
                                    "Esquecer identidade inicial",
                                    "Erros aritméticos em frações",
                                    "Não verificar A * A^{-1} = I"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular normas ||A||_∞ e ||A^{-1}||_∞",
                                  "subSteps": [
                                    "Para ||A||_∞: some valores absolutos por linha, pegue o máximo.",
                                    "Exemplo A ortogonal: cada linha soma √2/√2 + √2/√2 ≈1-2.",
                                    "Para A^{-1}: repita o processo na inversa.",
                                    "Note: para ortogonal, ||A^{-1}|| ≈ ||A|| ≈1; para ill-conditioned, ||A^{-1}|| >>1.",
                                    "Calcule para ambas matrizes e anote valores exatos/decimais."
                                  ],
                                  "verification": "Recalcule somas de linhas para confirmar; compare com norma esperada (κ=1 implica iguais).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para somas"
                                  ],
                                  "tips": [
                                    "Use |x| para negativos.",
                                    "Para ill-conditioned, espere discrepâncias grandes em elementos de A^{-1}."
                                  ],
                                  "learningObjective": "Aplicar norma infinito manualmente e relacionar com condicionamento.",
                                  "commonMistakes": [
                                    "Esquecer valores absolutos",
                                    "Confundir norma linha vs coluna",
                                    "Arredondar cedo demais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar κ(A) = ||A||_∞ * ||A^{-1}||_∞ e interpretar",
                                  "subSteps": [
                                    "Multiplique as duas normas para cada matriz.",
                                    "Para ortogonal: espere κ≈1 (bem condicionada).",
                                    "Para ill-conditioned: espere κ>10^3 (sensível a erros).",
                                    "Compare: discuta implicações (erros amplificados em Ax=b).",
                                    "Documente resultados em tabela: Matriz | ||A|| | ||A^{-1}|| | κ."
                                  ],
                                  "verification": "κ ortogonal ≈1 e κ ill >1000; verifique consistência com teoria.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para tabela"
                                  ],
                                  "tips": [
                                    "Teste com ε pequeno em diagonal para κ grande.",
                                    "Lembre: κ≥1 sempre."
                                  ],
                                  "learningObjective": "Interpretar κ como medida de sensibilidade numérica.",
                                  "commonMistakes": [
                                    "Multiplicar errado",
                                    "Interpretar κ<1",
                                    "Ignorar que norma afeta valor exato"
                                  ]
                                }
                              ],
                              "practicalExample": "Matriz ortogonal A = [[0.707, 0.707], [-0.707, 0.707]] → A^{-1}=A^T, ||A||_∞≈1.414, κ≈2 (próximo 1). Matriz ill B=[[1,0],[0,0.001]] → A^{-1}=[[1,0],[0,1000]], ||B||_∞=1, ||B^{-1}||_∞=1000, κ=1000 (ill-conditioned).",
                              "finalVerifications": [
                                "Calculou A^{-1} corretamente via Gauss-Jordan para ambas matrizes.",
                                "Normas ||A||_∞ e ||A^{-1}||_∞ precisas até 3 casas decimais.",
                                "κ≈1 para ortogonal e κ>10^3 para ill-conditioned.",
                                "Verificou A * A^{-1} = I.",
                                "Explicou verbalmente por que κ mede condicionamento.",
                                "Identificou elementos grandes em A^{-1} para ill-conditioned."
                              ],
                              "assessmentCriteria": [
                                "Precisão aritmética nos cálculos de inversa e normas (erro <1%).",
                                "Correta aplicação de Gauss-Jordan sem erros de pivoteamento.",
                                "Interpretação qualitativa de κ (bem vs mal condicionada).",
                                "Uso consistente da mesma norma em A e A^{-1}.",
                                "Documentação clara de passos e tabela final.",
                                "Tempo respeitado com verificações incluídas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: autovalores e decomposição SVD para normas exatas.",
                                "Computação Numérica: estabilidade em solvers como Cholesky.",
                                "Engenharia Estrutural: condicionamento em matrizes de rigidez de elementos finitos.",
                                "Física: estabilidade em simulações dinâmicas de estruturas.",
                                "Programação: implementação em Python/MATLAB para validação."
                              ],
                              "realWorldApplication": "Em análise de estruturas civis, matrizes de rigidez mal condicionadas (κ>10^3) em malhas finitas causam erros amplificados em deformações sob cargas, levando a projetos inseguros; cálculo manual ajuda a diagnosticar antes de simulações computacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Usar software para cálculo de condicionamento",
                            "description": "Implementar em MATLAB ou Python (numpy.linalg.cond) o cálculo de κ para diferentes normas, testando matrizes de rigidez em estruturas civis e interpretando resultados como cond(M) < 10^6 para precisão numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de software para cálculos numéricos",
                                  "subSteps": [
                                    "Instalar Python e bibliotecas necessárias (NumPy, SciPy) ou abrir MATLAB.",
                                    "Criar um novo script ou notebook Jupyter para o projeto.",
                                    "Importar módulos relevantes: import numpy as np em Python ou usar funções built-in no MATLAB.",
                                    "Testar a instalação com um cálculo simples de norma de uma matriz pequena.",
                                    "Definir uma convenção para normas (ex: '1', '2', 'inf')"
                                  ],
                                  "verification": "Executar um teste simples de np.linalg.norm(np.eye(2)) e confirmar saída esperada (1.0 para norma 2).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python 3.x com NumPy instalado; ou MATLAB; Jupyter Notebook opcional.",
                                  "tips": "Use ambientes virtuais como conda para evitar conflitos de dependências.",
                                  "learningObjective": "Configurar corretamente ferramentas computacionais para análise matricial.",
                                  "commonMistakes": "Esquecer de importar NumPy; usar versões incompatíveis de Python."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar ou carregar matrizes de rigidez de estruturas civis",
                                  "subSteps": [
                                    "Pesquisar e selecionar uma matriz de rigidez exemplo de uma estrutura simples (ex: trave com 2 graus de liberdade).",
                                    "Implementar ou copiar código para montar a matriz K (ex: para uma trave: K = [[12EI/L^3, 6EI/L^2], [6EI/L^2, 4EI/L]]).",
                                    "Criar variações: matriz bem condicionada (quadrada simétrica positiva definida) e mal condicionada (adicionar pequeno ruído).",
                                    "Salvar matrizes em variáveis: K_bem = ...; K_mal = ...",
                                    "Visualizar matrizes com np.linalg.eigvals para checar autovalores positivos."
                                  ],
                                  "verification": "Imprimir shape e autovalores das matrizes; confirmar que são simétricas e positivas definidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código fonte de exemplos de matrizes de rigidez (de livros como Bathe 'Finite Element Procedures'); editor de código.",
                                  "tips": "Use unidades consistentes (ex: E=200GPa, L=1m) para realismo.",
                                  "learningObjective": "Entender origem física de matrizes de rigidez em engenharia civil.",
                                  "commonMistakes": "Matrizes não simétricas; autovalores negativos indicando instabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar cálculo do número de condicionamento para múltiplas normas",
                                  "subSteps": [
                                    "Definir função custom: def condicao(M, norma): return np.linalg.cond(M, p=norma).",
                                    "Calcular para normas 1, 2, inf: kappa1 = condicao(K_bem, 1); etc.",
                                    "Repetir para matrizes bem e mal condicionadas.",
                                    "Armazenar resultados em dicionário ou tabela: resultados = {'K_bem': [kappa1, kappa2, kappa_inf], ...}.",
                                    "Comparar com cálculo manual aproximado (max/min autovalor para norma 2)."
                                  ],
                                  "verification": "Resultados cond(K_bem) ≈1 para identidade; cond(K_mal) >>1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Documentação NumPy linalg.cond; MATLAB equivalente cond(A,p).",
                                  "tips": "Norma 2 é spectral, use para interpretação física em autovalores.",
                                  "learningObjective": "Aplicar funções de álgebra linear para métricas de condicionamento.",
                                  "commonMistakes": "Confundir normas (p=2 é default); matrizes singulares causando erro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e validar critérios de precisão numérica",
                                  "subSteps": [
                                    "Analisar: se cond(M) < 10^6, considerar numericamente estável.",
                                    "Classificar matrizes: 'bem condicionada' se kappa < 10^3; 'moderada' 10^3-10^6; 'ruim' >10^6.",
                                    "Testar impacto: resolver Kx=b com ruído e medir erro relativo.",
                                    "Gerar relatório: plotar barras de kappa por norma e matriz.",
                                    "Documentar thresholds para estruturas civis (ex: evitar kappa>10^8 em FEM)."
                                  ],
                                  "verification": "Relatório escrito com classificações e plots salvos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Matplotlib para plots; exemplos de sistemas lineares de estruturas.",
                                  "tips": "Sempre normalize matrizes se necessário para comparação.",
                                  "learningObjective": "Interpretar condicionamento no contexto de precisão em simulações estruturais.",
                                  "commonMistakes": "Ignorar norma usada na interpretação; thresholds arbitrários sem justificativa."
                                }
                              ],
                              "practicalExample": "Para uma trave cantilever de L=5m, E=200GPa, I=0.01m^4: K_bem = np.array([[1200, 300], [300, 100]]); K_mal = K_bem + 1e-6*np.random.rand(2,2). Calcule cond(K_bem,2)≈1.2 (bem), cond(K_mal,2)>10^8 (ruim, impreciso para FEM).",
                              "finalVerifications": [
                                "Códigos executam sem erros para 3 normas e 2 matrizes.",
                                "Resultados cond <10^6 para matriz bem condicionada.",
                                "Interpretação correta: impacto em precisão numérica documentado.",
                                "Plots ou tabela de resultados gerados e salvos.",
                                "Threshold 10^6 aplicado e justificado para engenharia civil.",
                                "Comparação manual vs função built-in coincide dentro de 1%."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de condicionamento (erro <0.1%).",
                                "Correta geração de matrizes de rigidez realistas.",
                                "Interpretação física adequada dos valores de kappa.",
                                "Uso correto de múltiplas normas e documentação.",
                                "Qualidade do relatório e visualizações.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Uso de NumPy/MATLAB em scripts.",
                                "Análise Numérica: Estabilidade de sistemas lineares.",
                                "Engenharia de Estruturas: Matrizes de rigidez em MEF.",
                                "Matemática Aplicada: Normas matriciais e autovalores.",
                                "Gestão de Projetos: Validação numérica em simulações."
                              ],
                              "realWorldApplication": "Em análises de elementos finitos (FEM) para pontes e edifícios, verificar cond(K)<10^6 garante soluções precisas sem amplificação de erros de arredondamento, evitando falhas em predições de deformações e tensões."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.3",
                            "name": "Interpretar impactos na sensibilidade",
                            "description": "Analisar cenários: para κ≈1, solução estável; para κ=10^k, perda de k dígitos precisão; relacionar com problemas reais como análise de pórticos onde matrizes mal condicionadas surgem de geometrias singulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Número de Condicionamento e sua Relação com Estabilidade",
                                  "subSteps": [
                                    "Defina o número de condicionamento κ(A) como o produto das normas da matriz A e sua inversa A^{-1}.",
                                    "Explique que κ ≈ 1 indica uma matriz bem condicionada com solução estável a pequenas perturbações.",
                                    "Descreva que valores altos de κ, como κ = 10^k, implicam perda aproximada de k dígitos de precisão na solução numérica.",
                                    "Discuta como perturbações em dados de entrada são amplificadas na saída pela razão κ.",
                                    "Compare com estabilidade em sistemas lineares Ax = b."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o impacto qualitativo de κ baixo vs. alto em um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre normas de matrizes",
                                    "Calculadora científica",
                                    "Software MATLAB ou Python (opcional)"
                                  ],
                                  "tips": "Sempre relacione κ com a amplificação relativa de erros: ||δx||/||x|| ≤ κ * ||δb||/||b||.",
                                  "learningObjective": "Dominar a interpretação qualitativa de κ como medida de sensibilidade numérica.",
                                  "commonMistakes": [
                                    "Confundir κ com o determinante da matriz",
                                    "Ignorar que κ mede sensibilidade relativa, não absoluta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Cenários Numéricos com Diferentes Valores de κ",
                                  "subSteps": [
                                    "Selecione matrizes de teste: uma identidade (κ≈1) e uma mal condicionada (ex: Hilbert 4x4, κ≈10^5).",
                                    "Calcule κ para cada matriz usando normas (ex: norma 2 via autovalores).",
                                    "Simule perturbações pequenas em b (ex: 10^{-10}) e observe amplificação em x.",
                                    "Registre a perda de precisão: compare dígitos corretos em soluções exata vs. perturbada.",
                                    "Plote gráficos de erro relativo vs. log(κ) para visualização."
                                  ],
                                  "verification": "Gere tabela comparativa mostrando perda de dígitos para κ=1, 10^2, 10^4.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software NumPy/Python ou MATLAB",
                                    "Matrizes de exemplo pré-definidas",
                                    "Planilha Excel para tabelas"
                                  ],
                                  "tips": "Use svd() para calcular normas espectrais precisamente em software.",
                                  "learningObjective": "Quantificar a perda de precisão diretamente ligada a log10(κ).",
                                  "commonMistakes": [
                                    "Usar aritmética exata em vez de flutuante",
                                    "Perturbar A em vez de apenas b"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar Interpretação de κ com Problemas Computacionais Reais",
                                  "subSteps": [
                                    "Identifique causas de alto κ: colinearidade de vetores, geometrias singulares em matrizes de rigidez.",
                                    "Aplique a matrizes de sistemas estruturais: monte K para um pórtico simples.",
                                    "Calcule κ(K) e interprete: se κ>10^6, espere instabilidade numérica.",
                                    "Teste refinamento: adicione rigidez artificial ou pivoteamento para reduzir κ.",
                                    "Avalie impacto em forças internas e deslocamentos sob cargas perturbadas."
                                  ],
                                  "verification": "Explique em relatório como alto κ afeta precisão em um pórtico exemplo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software FEA como SAP2000 ou código Python para matrizes de rigidez",
                                    "Exemplos de pórticos 2D"
                                  ],
                                  "tips": "Verifique singularidade com det(K)≈0 antes de κ.",
                                  "learningObjective": "Conectar teoria de condicionamento a falhas computacionais em ED.",
                                  "commonMistakes": [
                                    "Assumir que alto κ sempre significa singularidade",
                                    "Ignorar escala das normas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Interpretações e Estratégias de Mitigação",
                                  "subSteps": [
                                    "Resuma regras: κ<10^3 OK para double precision; >10^12 requer cuidado.",
                                    "Desenvolva checklist para diagnóstico: compute κ, rank, autovalores extremos.",
                                    "Proponha mitigações: regularização, pré-condicionadores, reformulação geométrica.",
                                    "Avalie trade-offs: precisão vs. custo computacional.",
                                    "Documente lições para projetos futuros em análise estrutural."
                                  ],
                                  "verification": "Crie um fluxograma de decisão para 'alto κ detectado'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel/diagrama digital",
                                    "Resumo dos passos anteriores"
                                  ],
                                  "tips": "Priorize autovalores min/max para estimativa rápida de κ.",
                                  "learningObjective": "Formular abordagens práticas para lidar com sensibilidade em cenários reais.",
                                  "commonMistakes": [
                                    "Recomendar inversão direta para mitigar (piora κ)",
                                    "Subestimar impacto de round-off em grandes κ"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um pórtico plano com barras quase colineares (ângulo 1°), a matriz de rigidez K resulta em κ≈10^8 devido a autovalor mínimo pequeno. Uma perturbação de 10^{-12} em cargas leva a perda de 8 dígitos em deslocamentos, causando erro de 1% em forças, o que pode invalidar projeto de fundações.",
                              "finalVerifications": [
                                "Explica corretamente perda de k dígitos para κ=10^k.",
                                "Identifica geometrias singulares como causa de alto κ em pórticos.",
                                "Simula cenário com κ alto e quantifica amplificação de erro.",
                                "Propõe pelo menos duas mitigações viáveis.",
                                "Relaciona interpretação a precisão em double precision (16 dígitos).",
                                "Cria tabela comparativa de cenários κ baixo/alto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na quantificação de perda de precisão (log10(κ)).",
                                "Correta identificação de causas estruturais de mal condicionamento.",
                                "Qualidade da simulação numérica com perturbações realistas.",
                                "Profundidade na conexão com aplicações em Engenharia Civil.",
                                "Criatividade e viabilidade das estratégias de mitigação.",
                                "Clareza na comunicação via relatórios ou diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Análise de erros em álgebra linear.",
                                "Física Estrutural: Matrizes de rigidez em Método dos Elementos Finitos.",
                                "Programação Computacional: Uso de SVD e normas em Python/MATLAB.",
                                "Estatística: Sensibilidade em modelos paramétricos."
                              ],
                              "realWorldApplication": "Na análise de pórticos altos ou pontes com geometrias esbeltas, alto κ de matrizes de rigidez pode levar a erros em simulações FEM, resultando em dimensionamento inseguro de elementos. Engenheiros usam interpretação de κ para validar modelos, aplicar regularização e evitar falhas como colapso prematuro por imprecisão numérica."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.4",
                            "name": "Relacionar com autovalores e SVD",
                            "description": "Explicar que para norma 2, κ(A) = |λ_max| / |λ_min| de A^T A, e usar decomposição SVD para computar cond sem inversão, evitando instabilidades numéricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a relação do número de condicionamento com autovalores de A^T A",
                                  "subSteps": [
                                    "Recordar que o número de condicionamento na norma 2 é κ₂(A) = ||A||₂ ⋅ ||A⁻¹||₂",
                                    "Derivar que ||A||₂ = √(λ_max(AᵀA)), onde λ_max é o maior autovalor de AᵀA",
                                    "Mostrar que ||A⁻¹||₂ = 1 / √(λ_min(AᵀA))",
                                    "Concluir que κ₂(A) = √(λ_max(AᵀA) / λ_min(AᵀA)) = |λ_max| / |λ_min| para autovalores positivos",
                                    "Explicar por que usar AᵀA: garante matriz simétrica positiva definida"
                                  ],
                                  "verification": "Derivar a fórmula κ₂(A) = √(λ_max / λ_min) de AᵀA em um caderno ou documento, confirmando com uma referência teórica",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de álgebra linear (ex: Strang)",
                                    "Caderno ou editor de texto",
                                    "Python com NumPy para verificação opcional"
                                  ],
                                  "tips": "Sempre compute autovalores de AᵀA, não de A diretamente, pois A pode não ser diagonalizável",
                                  "learningObjective": "Compreender a base teórica ligando condicionamento à norma 2 e autovalores de AᵀA",
                                  "commonMistakes": [
                                    "Confundir com outras normas (ex: norma 1 ou ∞)",
                                    "Esquecer a raiz quadrada na derivação",
                                    "Assumir autovalores de A em vez de AᵀA"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Decomposição em Valores Singulares (SVD)",
                                  "subSteps": [
                                    "Definir SVD: Para qualquer matriz A m×n, A = U Σ Vᵀ, onde U e V são ortogonais, Σ diagonal com valores singulares σ_i ≥ 0",
                                    "Relacionar valores singulares: σ_i = √(λ_i(AᵀA)), ordenados σ₁ ≥ σ₂ ≥ ... ≥ σ_min",
                                    "Explicar normas via SVD: ||A||₂ = σ₁ (maior valor singular), ||A⁻¹||₂ = 1 / σ_n (menor valor singular, se A quadrada invertível)",
                                    "Derivar κ₂(A) = σ₁ / σ_n diretamente dos valores singulares",
                                    "Comparar: não requer inversão de A, apenas SVD"
                                  ],
                                  "verification": "Escrever a decomposição SVD e derivar κ₂(A) = σ_max / σ_min, verificando com um exemplo 2×2 manual",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Referência SVD (ex: documentação NumPy)",
                                    "Calculadora ou papel para exemplo manual"
                                  ],
                                  "tips": "Valores singulares são sempre reais e não-negativos, facilitando o cálculo",
                                  "learningObjective": "Dominar SVD e sua conexão direta com normas e condicionamento",
                                  "commonMistakes": [
                                    "Confundir valores singulares com autovalores",
                                    "Esquecer ordenação decrescente dos σ_i",
                                    "Aplicar SVD só a matrizes quadradas (funciona para retangulares)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar cálculo de condicionamento usando SVD",
                                  "subSteps": [
                                    "Selecionar uma matriz A relevante (ex: matriz de rigidez simplificada)",
                                    "Computar SVD de A usando software: obter Σ e extrair σ_max e σ_min",
                                    "Calcular κ₂(A) = σ_max / σ_min",
                                    "Comparar com método autovalores: compute eig(AᵀA) e verifique √(λ_max/λ_min) ≈ σ_max/σ_min",
                                    "Testar estabilidade: adicionar ruído pequeno e recomputar"
                                  ],
                                  "verification": "Executar código que imprime κ via SVD e autovalores, confirmando valores iguais dentro de tolerância 1e-10",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com NumPy e SciPy",
                                    "Jupyter Notebook",
                                    "Matriz exemplo: A = np.array([[1, 0], [0, 1e-6]])"
                                  ],
                                  "tips": "Use np.linalg.svd(A, compute_uv=False) para só valores singulares, mais eficiente",
                                  "learningObjective": "Aplicar SVD computacionalmente para calcular condicionamento de forma precisa",
                                  "commonMistakes": [
                                    "Usar np.linalg.cond() sem entender (é baseado em SVD)",
                                    "Ignorar underflow em σ_min pequeno",
                                    "Comparar sem normalizar tolerâncias numéricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar vantagens numéricas do SVD sobre autovalores",
                                  "subSteps": [
                                    "Discutir instabilidades: calcular ||A⁻¹||₂ requer inversão, sensível a erros de arredondamento",
                                    "Explicar estabilidade SVD: algoritmos robustos (ex: Golub-Reinsch), trabalha com AᵀA implicitamente sem formá-la",
                                    "Comparar em matriz mal-condicionada: mostrar discrepâncias numéricas entre métodos",
                                    "Concluir: SVD evita inversão e é padrão em bibliotecas (MATLAB cond, NumPy)",
                                    "Aplicar a contexto: em engenharia civil, matrizes de Gram em MEF"
                                  ],
                                  "verification": "Relatório curto comparando erros relativos em 2 métodos para matriz com cond ~1e6",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python do step 3",
                                    "Artigo sobre estabilidade SVD (ex: Wikipedia ou Trefethen)"
                                  ],
                                  "tips": "Para matrizes grandes, SVD é O(mn²), viável em problemas reais de engenharia",
                                  "learningObjective": "Reconhecer por que SVD é preferido para condicionamento numérico estável",
                                  "commonMistakes": [
                                    "Subestimar erros em autovalores para matrizes não-simétricas",
                                    "Ignorar que AᵀA amplifica erros de A",
                                    "Confundir precisão condicional com absoluta"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz de Gram aproximada em análise estrutural: A = np.array([[1.0, 0.999], [0.999, 1.0]]). Compute SVD: σ_max ≈ 1.999, σ_min ≈ 0.001, κ₂(A) ≈ 1999. Via autovalores de AᵀA: λ_max ≈ 3.996, λ_min ≈ 0.001, √(λ_max/λ_min) ≈ 1999. Adicione ruído 1e-10: SVD mantém precisão, autovalores/inversão divergem.",
                              "finalVerifications": [
                                "Deriva corretamente κ₂(A) = σ_max / σ_min via SVD",
                                "Computa SVD e autovalores de AᵀA para matriz exemplo, valores coincidem",
                                "Explica relação σ_i = √λ_i(AᵀA)",
                                "Demonstra superioridade numérica do SVD em código com ruído",
                                "Aplica a uma matriz de contexto em engenharia civil"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação de fórmulas (100%)",
                                "Precisão computacional: erro <1e-8 entre métodos",
                                "Clareza na explicação de vantagens numéricas",
                                "Uso adequado de software (código reproduzível)",
                                "Conexão com contexto de condicionamento em problemas civis",
                                "Identificação de erros comuns e mitigação"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores, decomposições",
                                "Análise Numérica: estabilidade, erros de arredondamento",
                                "Programação Científica: NumPy/SciPy para SVD",
                                "Engenharia Computacional: MEF e matrizes de rigidez"
                              ],
                              "realWorldApplication": "Em soluções computacionais de problemas de engenharia civil, como análise de elementos finitos para estruturas, matrizes de rigidez ou Gram podem ser mal-condicionadas devido a malha fina ou geometrias esguias; usar SVD para avaliar κ₂(A) permite detectar instabilidades numéricas precocemente, evitando erros em solvers lineares e garantindo precisão em simulações de tensões/deformações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Análise de Sistemas Lineares Mal Condicionados",
                    "description": "Estudo dos efeitos do mau condicionamento em sistemas lineares, incluindo amplificação de erros numéricos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Número de Condicionamento de Matrizes",
                        "description": "Conceito fundamental para medir a sensibilidade de um sistema linear Ax = b a perturbações em A ou b, definido como o produto das normas da matriz e sua inversa.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Calcular normas de matrizes",
                            "description": "Aplicar normas como a norma 2 (espectral), norma 1 e norma infinito para avaliar o tamanho de matrizes em sistemas lineares, utilizando decomposição em autovalores para norma 2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Normas de Matrizes",
                                  "subSteps": [
                                    "Defina norma de matriz como uma medida do 'tamanho' ou magnitude de uma matriz A.",
                                    "Revise normas vetoriais induzidas: norma 1 (soma absoluta das colunas), norma infinito (soma absoluta das linhas) e norma 2 (valor singular máximo).",
                                    "Explique a norma espectral (norma 2) como a raiz quadrada do maior autovalor de A^T A.",
                                    "Discuta relevância em sistemas lineares: normas avaliam estabilidade e condicionamento.",
                                    "Compare com normas de Frobenius para contextualização."
                                  ],
                                  "verification": "Resuma em suas palavras as três normas principais e dê um exemplo simples de cada uma.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Notas de aula sobre normas",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use analogias: norma 1 como 'altura máxima da torre', infinito como 'largura máxima'.",
                                  "learningObjective": "Identificar e diferenciar as normas 1, 2 e infinito de matrizes.",
                                  "commonMistakes": [
                                    "Confundir norma de vetor com norma de matriz",
                                    "Ignorar que normas são induzidas por normas vetoriais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Normas 1 e Infinito Manualmente",
                                  "subSteps": [
                                    "Para norma 1: encontre o máximo da soma dos valores absolutos por coluna.",
                                    "Exemplo: Para A = [[1,2],[3,4]], calcule colunas: |1|+|3|=4, |2|+|4|=6 → ||A||_1 = 6.",
                                    "Para norma infinito: máximo da soma dos valores absolutos por linha.",
                                    "Exemplo: Linhas: |1|+|2|=3, |3|+|4|=7 → ||A||_∞ = 7.",
                                    "Pratique com matriz 3x3 aleatória, verificando simetria em matrizes quadradas.",
                                    "Automatize com pseudocódigo simples."
                                  ],
                                  "verification": "Calcule normas 1 e ∞ para duas matrizes fornecidas e confira com software.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Planilha Excel ou Python (NumPy) para verificação"
                                  ],
                                  "tips": "Sempre tome módulo absoluto antes de somar para evitar cancelamentos.",
                                  "learningObjective": "Executar cálculos precisos das normas 1 e infinito.",
                                  "commonMistakes": [
                                    "Esquecer valores absolutos",
                                    "Somar linhas para norma 1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Norma 2 (Espectral) via Decomposição em Autovalores",
                                  "subSteps": [
                                    "Construa A^T A para matriz não-simétrica.",
                                    "Encontre autovalores de A^T A resolvendo equação característica det(λI - A^T A)=0.",
                                    "Identifique o maior autovalor λ_max positivo.",
                                    "Calcule ||A||_2 = sqrt(λ_max).",
                                    "Para matrizes simétricas, use autovalores diretos de A.",
                                    "Use software para matrizes grandes: eig() no MATLAB ou numpy.linalg.eig()."
                                  ],
                                  "verification": "Para uma matriz dada, compute A^T A, seus autovalores e confirme ||A||_2.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software: MATLAB/Octave/Python (NumPy/SciPy)",
                                    "Matriz de exemplo 2x2 ou 3x3"
                                  ],
                                  "tips": "Autovalores de A^T A são quadrados dos valores singulares; foque no maior.",
                                  "learningObjective": "Aplicar decomposição em autovalores para norma espectral.",
                                  "commonMistakes": [
                                    "Usar autovalores de A diretamente sem A^T A",
                                    "Confundir autovalores negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Normas em Análise de Condicionamento de Sistemas Lineares",
                                  "subSteps": [
                                    "Calcule κ(A) = ||A|| * ||A^{-1}|| usando normas consistentes.",
                                    "Interprete: κ ≈ 1 bem condicionado; κ >>1 mal condicionado.",
                                    "Exemplo em Engenharia Civil: matriz de rigidez de estrutura, verifique sensibilidade a erros.",
                                    "Compare normas 1, 2 e ∞ no mesmo exemplo.",
                                    "Discuta impactos em solução numérica (ex: eliminação gaussiana).",
                                    "Gere relatório com valores e conclusões."
                                  ],
                                  "verification": "Analise condicionamento de uma matriz de engenharia e proponha melhorias.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matriz de rigidez exemplo (Eng. Civil)",
                                    "Software computacional"
                                  ],
                                  "tips": "Prefira norma 2 para precisão espectral em problemas físicos.",
                                  "learningObjective": "Integrar normas para avaliar condicionamento em contextos reais.",
                                  "commonMistakes": [
                                    "Usar normas diferentes para A e A^{-1}",
                                    "Ignorar inversa computacionalmente instável"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez de uma treliça 2D: A = [[2, -1], [-1, 2]]. Calcule ||A||_1 = 3, ||A||_∞ = 3, ||A||_2 = sqrt(3) ≈ 1.732 via autovalores de A (simétrica). Condicionamento κ_2 ≈ 1 (bem condicionado).",
                              "finalVerifications": [
                                "Calcule corretamente normas 1, ∞ e 2 para matrizes 2x2 e 3x3.",
                                "Explique relação entre norma 2 e autovalores de A^T A.",
                                "Avalie condicionamento de uma matriz mal condicionada (ex: κ > 10^6).",
                                "Implemente cálculos em código Python/MATLAB.",
                                "Interprete resultados em contexto de estabilidade numérica.",
                                "Compare normas em relatório curto."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos manuais (±0.01 erro relativo).",
                                "Correta identificação de fórmulas e decomposições.",
                                "Uso apropriado de software com validação manual.",
                                "Interpretação física/engenharia dos resultados.",
                                "Clareza em relatórios e exemplos.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/NumPy para autovalores.",
                                "Física/Engenharia: Análise de estabilidade em estruturas civis.",
                                "Estatística: Normas em regressão linear e mínimos quadrados.",
                                "Otimização: Normas em gradientes e convergência de algoritmos."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, calcular normas de matrizes de rigidez detecta sistemas mal condicionados, previnindo erros em simulações FEM (Finite Element Method) que podem levar a projetos estruturais inseguros sob cargas reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Determinar autovalores e autovetores",
                            "description": "Resolver o problema de autovalores para calcular a norma espectral de uma matriz simétrica positiva definida, essencial para o número de condicionamento cond(A) = ||A|| * ||A^{-1}||.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar propriedades de matrizes simétricas positivas definidas",
                                  "subSteps": [
                                    "Defina matriz simétrica: A = A^T.",
                                    "Verifique positiva definida: todos autovalores positivos e x^T A x > 0 para x ≠ 0.",
                                    "Lembre que autovalores são reais e positivos para tais matrizes.",
                                    "Discuta relevância para norma espectral: ||A||_2 = maior autovalor.",
                                    "Exemplo simples: matriz identidade."
                                  ],
                                  "verification": "Liste 3 propriedades chave e verifique em uma matriz 2x2 exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora básica",
                                  "tips": "Use transposição para confirmar simetria rapidamente.",
                                  "learningObjective": "Compreender pré-requisitos teóricos para autovalores em matrizes SPD.",
                                  "commonMistakes": "Confundir simétrica com diagonalizável sem verificar positiva definida."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular e montar a equação característica",
                                  "subSteps": [
                                    "Escreva det(A - λI) = 0.",
                                    "Para matriz 2x2 ou 3x3, expanda o determinante manualmente.",
                                    "Use software como Python/NumPy para matrizes maiores.",
                                    "Identifique polinômio característico.",
                                    "Plote ou estime raízes reais positivas."
                                  ],
                                  "verification": "Escreva corretamente a equação para uma matriz dada e resolva numericamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software NumPy/MATLAB ou papel para expansão manual",
                                  "tips": "Para 2x2, fórmula fechada: λ = (tr(A) ± sqrt(tr(A)^2 - 4 det(A)))/2.",
                                  "learningObjective": "Dominar formulação da equação para encontrar autovalores.",
                                  "commonMistakes": "Esquecer o sinal negativo em A - λI."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver para autovalores e calcular norma espectral",
                                  "subSteps": [
                                    "Resolva o polinômio para λ_max e λ_min.",
                                    "Confirme todos λ > 0.",
                                    "Calcule ||A||_2 = λ_max.",
                                    "Para A^{-1}, note que autovalores são 1/λ_i, então ||A^{-1}||_2 = 1/λ_min.",
                                    "Compute cond(A) = λ_max / λ_min."
                                  ],
                                  "verification": "Calcule λ_max, λ_min e cond(A) para matriz exemplo com erro < 1%.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora científica ou Python com numpy.linalg.eigvals",
                                  "tips": "Sempre ordene autovalores decrescentemente para identificar máximo.",
                                  "learningObjective": "Aplicar soluções para normas e condicionamento.",
                                  "commonMistakes": "Usar autovalor menor como norma espectral."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar autovetores correspondentes",
                                  "subSteps": [
                                    "Para cada λ, resolva (A - λI)v = 0.",
                                    "Encontre base do kernel.",
                                    "Normalize v para ||v||=1.",
                                    "Verifique A v = λ v.",
                                    "Confirme ortogonalidade para simétricas."
                                  ],
                                  "verification": "Autovetores normalizados satisfazem equação com tolerância 10^{-6}.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software para solver linear ou Gauss-Jordan manual",
                                  "tips": "Use pivoteamento para sistemas pequenos.",
                                  "learningObjective": "Calcular autovetores e validar.",
                                  "commonMistakes": "Não normalizar ou ignorar ortogonalidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar no contexto de condicionamento",
                                  "subSteps": [
                                    "Reconstrua A = Q Λ Q^T (diagonalização).",
                                    "Compare cond(A) com ||A||_F para insights.",
                                    "Analise impacto de cond alto em solvers lineares.",
                                    "Teste estabilidade numérica com perturbações.",
                                    "Documente processo completo."
                                  ],
                                  "verification": "Diagonalização reconstrói A com erro < 10^{-4}.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python/MATLAB para verificação numérica",
                                  "tips": "Use eig() full para automação.",
                                  "learningObjective": "Integrar autovalores/autovetores ao condicionamento em engenharia.",
                                  "commonMistakes": "Interpretar cond baixo como sempre bom (depende do contexto)."
                                }
                              ],
                              "practicalExample": "Para A = [[5, 4], [4, 5]] (SPD), encontre λ1=9, λ2=1, autovetores [1/sqrt(2), 1/sqrt(2)] e [1/sqrt(2), -1/sqrt(2)], cond(A)=9.",
                              "finalVerifications": [
                                "Todos autovalores reais e positivos confirmados.",
                                "Autovetores ortonormais e verificados com A v = λ v.",
                                "Norma espectral ||A||_2 = λ_max calculada corretamente.",
                                "cond(A) = λ_max / λ_min coincide com definição.",
                                "Diagonalização reconstrói A com precisão numérica.",
                                "Análise de estabilidade para sistema linear mal condicionado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na equação característica (>95% correção).",
                                "Cálculo correto de autovalores e norma espectral.",
                                "Autovetores normalizados e ortogonais.",
                                "Interpretação correta de cond(A) no contexto.",
                                "Uso eficiente de ferramentas computacionais.",
                                "Identificação de erros numéricos potenciais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos de vibração em estruturas (autovetores como modos).",
                                "Computação: Algoritmos QR para eigendecomposição eficiente.",
                                "Estatística: Análise de componentes principais (PCA).",
                                "Otimização: Gradientes em métodos de Newton para SPD."
                              ],
                              "realWorldApplication": "Na engenharia civil, analisar rigidez de estruturas: matriz de rigidez SPD, cond alto indica mal condicionamento em FEM, levando a erros em simulações de tensões e deslocamentos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Calcular o número de condicionamento cond(A)",
                            "description": "Computar cond_2(A) = |λ_max| / |λ_min| para matrizes simétricas e interpretar valores altos (cond > 10^4) como indicativo de mau condicionamento em implementações numéricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar se a matriz A é simétrica",
                                  "subSteps": [
                                    "Confirme que A = A^T, ou seja, a_{ij} = a_{ji} para todos i, j.",
                                    "Escreva a matriz A explicitamente em uma ferramenta computacional.",
                                    "Execute o teste de simetria: compute A - A^T e verifique se resulta em matriz nula.",
                                    "Registre qualquer discrepância numérica devido a precisão de ponto flutuante.",
                                    "Documente a confirmação para prosseguir."
                                  ],
                                  "verification": "A - A^T ≈ 0 (norma Frobenius < 10^{-12}).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A de exemplo (ex: matriz de rigidez 3x3)",
                                    "Software: MATLAB, Python (NumPy) ou Octave"
                                  ],
                                  "tips": "Use tolerâncias numéricas para simetria aproximada em dados reais.",
                                  "learningObjective": "Entender a propriedade de simetria necessária para usar cond_2 via autovalores.",
                                  "commonMistakes": "Ignorar assimetrias pequenas causadas por arredondamentos numéricos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os autovalores da matriz A",
                                  "subSteps": [
                                    "Implemente ou use função built-in para decomposição espectral (eig em MATLAB/Python).",
                                    "Garanta que A seja simétrica positiva definida se aplicável para autovalores reais.",
                                    "Ordene os autovalores em ordem crescente: λ1 ≤ λ2 ≤ ... ≤ λn.",
                                    "Verifique se todos autovalores são reais (propriedade de matrizes simétricas).",
                                    "Armazene o vetor de autovalores para uso posterior."
                                  ],
                                  "verification": "Autovalores reais e ordenados corretamente; valide com A * v = λ * v para um vetor próprio.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software com função eig (NumPy.linalg.eigvals, MATLAB eig)",
                                    "Matriz A confirmada simétrica"
                                  ],
                                  "tips": "Para matrizes grandes, use métodos iterativos como Lanczos para eficiência.",
                                  "learningObjective": "Dominar o cálculo de autovalores para matrizes simétricas.",
                                  "commonMistakes": "Confundir autovalores com autovetores ou não ordená-los."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar os autovalores máximo e mínimo absolutos",
                                  "subSteps": [
                                    "Localize λ_max = max(|λ_i|) e λ_min = min(|λ_i|), considerando valores absolutos.",
                                    "Para matrizes simétricas positivas definidas, use λ_max e λ_min diretamente (sem abs se positivos).",
                                    "Registre os índices dos autovalores extremos.",
                                    "Confirme que λ_min > 0 para evitar divisão por zero.",
                                    "Calcule preliminarmente a razão |λ_max| / |λ_min|."
                                  ],
                                  "verification": "λ_max e λ_min identificados corretamente comparando com lista ordenada.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Vetor de autovalores do Step 2",
                                    "Calculadora ou script simples"
                                  ],
                                  "tips": "Sempre use valores absolutos para generalidade, mesmo em casos positivos.",
                                  "learningObjective": "Selecionar corretamente os autovalores extremos para condicionamento.",
                                  "commonMistakes": "Esquecer valores absolutos ou usar λ_min sem verificar sinal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar e interpretar o número de condicionamento cond_2(A)",
                                  "subSteps": [
                                    "Calcule cond_2(A) = |λ_max| / |λ_min|.",
                                    "Compare com threshold: cond > 10^4 indica mau condicionamento.",
                                    "Analise implicações: perda de precisão em solvers lineares (ex: até log10(cond) dígitos perdidos).",
                                    "Gere relatório com valor exato e interpretação qualitativa.",
                                    "Teste sensibilidade alterando A ligeiramente."
                                  ],
                                  "verification": "Valor de cond calculado coincide com função built-in (cond(A,'2') em MATLAB).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "λ_max e λ_min do Step 3",
                                    "Software para cond() built-in opcional"
                                  ],
                                  "tips": "Logaritme o cond para entender dígitos de precisão: digits ≈ 16 - log10(cond).",
                                  "learningObjective": "Calcular cond_2 e interpretar seu impacto numérico.",
                                  "commonMistakes": "Dividir sem absolutos ou ignorar interpretação (ex: cond=1 é bem condicionado)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com exemplo prático e generalizar",
                                  "subSteps": [
                                    "Aplique a um exemplo de matriz de rigidez em engenharia civil.",
                                    "Compare cond com normas outras (ex: 1-norma) para consistência.",
                                    "Discuta pré-condicionadores para mitigar alto cond.",
                                    "Documente lições para matrizes mal condicionadas reais.",
                                    "Salve script reutilizável."
                                  ],
                                  "verification": "Exemplo resolvido corretamente; interpretação alinhada com literatura.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplo prático (matriz fornecida)",
                                    "Referências: livros de álgebra numérica"
                                  ],
                                  "tips": "Use escalonamento para reduzir cond em problemas reais.",
                                  "learningObjective": "Aplicar e contextualizar o condicionamento em cenários reais.",
                                  "commonMistakes": "Não testar com matrizes conhecidas (ex: identidade tem cond=1)."
                                }
                              ],
                              "practicalExample": "Considere A = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]] (matriz de rigidez 1D). Autovalores: ≈[0.5858, 2, 3.4142]. cond_2(A) = 3.4142 / 0.5858 ≈ 5.83 (bem condicionado). Agora, escale A por 10^6: cond permanece igual, mas em ponto flutuante, amplifica erros.",
                              "finalVerifications": [
                                "Cálculo de cond_2(A) matches função built-in com precisão < 10^{-10}.",
                                "Interpretação correta: cond > 10^4 sinalizado como mau.",
                                "Teste de simetria passa com tolerância adequada.",
                                "Autovalores reais e ordenados validados.",
                                "Relatório inclui implicações numéricas (dígitos perdidos).",
                                "Exemplo prático resolvido sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de autovalores e cond_2 (erro < 1%).",
                                "Correta identificação de simetria e extremos absolutos.",
                                "Interpretação qualitativa e quantitativa precisa.",
                                "Uso adequado de ferramentas computacionais sem bugs.",
                                "Documentação clara de passos e resultados.",
                                "Generalização para aplicações em engenharia."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/MATLAB para análise de dados.",
                                "Física/Engenharia Mecânica: Matrizes de rigidez em elementos finitos.",
                                "Estatística: Análise de variância em modelos lineares.",
                                "Otimização: Impacto de cond em métodos gradiente conjugado."
                              ],
                              "realWorldApplication": "Em análise estrutural de edifícios (Engenharia Civil), matrizes de rigidez de malhas finitas podem ter cond > 10^6 devido a elementos alongados, causando falhas em solvers como Cholesky; pré-condicionamento ou refinamento de malha é essencial para precisão em simulações sísmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Amplificação de Erros Numéricos",
                        "description": "Estudo de como erros de arredondamento ou perturbações são amplificados em sistemas mal condicionados, limitados pelo número de condicionamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Analisar erro relativo em soluções",
                            "description": "Derivar e aplicar a relação ||δx|| / ||x|| ≤ cond(A) * (||δb|| / ||b|| + ||δA|| / ||A||), demonstrando amplificação de erros de entrada para saída.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Normas e Número de Condição",
                                  "subSteps": [
                                    "Defina normas vetoriais (ex: norma 2, infinito) e matriciais.",
                                    "Calcule cond(A) = ||A|| * ||A⁻¹|| para uma matriz A.",
                                    "Interprete cond(A) como medida de sensibilidade a perturbações.",
                                    "Compare cond(A) para matrizes bem e mal condicionadas.",
                                    "Pratique com exemplos 2x2 simples."
                                  ],
                                  "verification": "Resolva 3 matrizes exemplo e liste seus cond(A) com interpretação correta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora científica, software MATLAB/Octave ou Python (NumPy), notas de aula sobre normas.",
                                  "tips": "Use norma 2 para vetores e norma induzida para matrizes para consistência.",
                                  "learningObjective": "Compreender e calcular normas e cond(A) como base para análise de erros.",
                                  "commonMistakes": "Confundir norma vetorial com matricial; ignorar que cond(A) ≥ 1 sempre."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Bound para Perturbações em b (δb)",
                                  "subSteps": [
                                    "Comece com Ax = b e A(x + δx) = b + δb.",
                                    "Subtraia: A δx = δb, então ||δx|| ≤ ||A⁻¹|| ||δb||.",
                                    "Divida por ||x||: ||δx||/||x|| ≤ ||A⁻¹|| ||A|| (||δb||/||b||) * (||b||/||Ax||).",
                                    "Simplifique assumindo ||Ax|| ≈ ||b|| para bound aproximado.",
                                    "Estabeleça ||δx||/||x|| ≤ cond(A) * ||δb||/||b||."
                                  ],
                                  "verification": "Escreva a derivação passo a passo em papel ou LaTeX, verificando desigualdades.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, lápis, livro-texto de álgebra numérica (ex: Golub-Van Loan).",
                                  "tips": "Mantenha todas as normas consistentes (ex: todas norma 2).",
                                  "learningObjective": "Derivar matematicamente a amplificação de erros em b para solução x.",
                                  "commonMistakes": "Esquecer de dividir por ||x|| ou ||b||; inverter ||A|| e ||A⁻¹||."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender Derivação para Perturbações em A (δA)",
                                  "subSteps": [
                                    "Considere (A + δA)(x + δx) = b + δb.",
                                    "Expanda e isole termos: δAx + A δx + δA δx ≈ δb.",
                                    "Negligencie termo quadrático pequeno: ||δx|| ≤ ||A⁻¹|| (||δb|| + ||δA|| ||x||).",
                                    "Normalize: ||δx||/||x|| ≤ cond(A) (||δb||/||b|| + ||δA||/||A||).",
                                    "Discuta aproximações e condições de validade (||δA|| pequeno)."
                                  ],
                                  "verification": "Complete a derivação e teste com desigualdade triangular em um exemplo simbólico.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software simbólico (SymPy Python), quadro branco para derivação.",
                                  "tips": "Use aproximação de primeiro ordem para perturbações pequenas.",
                                  "learningObjective": "Incorporar erros em A à bound de erro relativo completo.",
                                  "commonMistakes": "Ignorar termo δA δx; não normalizar por ||A|| corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Demonstrar Amplificação Numérica",
                                  "subSteps": [
                                    "Escolha matriz mal condicionada (ex: Hilbert 4x4 ou sistema estrutural).",
                                    "Perturbe b e A com ruído relativo pequeno (1e-6).",
                                    "Resolva sistemas originais e perturbados, calcule erros relativos.",
                                    "Compare com bound teórico cond(A) * (erros entrada).",
                                    "Plote gráficos de erro vs. cond(A)."
                                  ],
                                  "verification": "Gere relatório com cálculos, erros observados ≤ bound teórico.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/Python (NumPy/SciPy), dados de exemplo (matrizes Hilbert).",
                                  "tips": "Use qr() ou lu() para resolver; cond() para número de condição.",
                                  "learningObjective": "Validar teoricamente bounds através de experimentos numéricos.",
                                  "commonMistakes": "Usar solver instável; perturbações grandes violando aproximações."
                                }
                              ],
                              "practicalExample": "Em análise de uma treliça simples (sistema 3x3 mal condicionado), perturbe cargas (δb/||b||=1e-5) e rigidez (δA/||A||=1e-6). Com cond(A)=1e4, erro relativo em deslocamentos x amplifica para ~1e-1, mostrando risco em simulações de engenharia civil.",
                              "finalVerifications": [
                                "Derivação completa da bound escrita corretamente.",
                                "Cálculo de cond(A) para 2 matrizes exemplo preciso.",
                                "Simulação numérica mostra erro saída ≥ erro entrada por fator cond(A).",
                                "Interpretação verbal da amplificação em contexto real.",
                                "Identificação de quando bound é tight vs. loose.",
                                "Gráfico de erros vs. perturbações gerado."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (sem erros algébricos).",
                                "Correta normalização de erros relativos.",
                                "Validação numérica com erros observados consistentes com bound.",
                                "Interpretação qualitativa da sensibilidade.",
                                "Uso apropriado de normas consistentes.",
                                "Clareza na documentação e plots."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de propagação de erros em medições.",
                                "Programação: Implementação numérica em Python/MATLAB para álgebra linear.",
                                "Física: Modelagem de sistemas dinâmicos em estruturas civis.",
                                "Probabilidade: Erros como ruído gaussiano em simulações."
                              ],
                              "realWorldApplication": "Na engenharia civil, ao simular deformações em pontes sob cargas incertas, altos cond(A) em matrizes de rigidez amplificam erros de entrada (medições imprecisas), podendo levar a sub ou superestimação de segurança; análise previne falhas como em colapsos por modelagem ruim."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Simular erros em sistemas mal condicionados",
                            "description": "Implementar em software (ex: MATLAB) um sistema com cond(A) alto, introduzir perturbações pequenas em b e observar amplificação no erro da solução x.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e criar uma matriz A mal condicionada",
                                  "subSteps": [
                                    "Instale e abra o MATLAB ou Octave.",
                                    "Defina uma matriz A com alto número de condição, como A = [1, 1; 1, 1 + 1e-10] para um sistema 2x2.",
                                    "Gere uma solução exata x_true = [1; 2] e compute b_exact = A * x_true.",
                                    "Calcule cond(A) usando a função cond(A) para confirmar que é alto (>>1)."
                                  ],
                                  "verification": "Verifique se cond(A) > 1e10 e b_exact foi gerado corretamente comparando A * x_true ≈ b_exact.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MATLAB ou Octave instalado",
                                    "Documentação de funções MATLAB: cond(), eye(), rand()"
                                  ],
                                  "tips": "Use eps (machine epsilon) para criar perturbações realistas; comece com matrizes pequenas (2x2 ou 3x3) para depuração fácil.",
                                  "learningObjective": "Entender como construir sistemas lineares mal condicionados e medir seu condicionamento.",
                                  "commonMistakes": [
                                    "Usar matrizes bem condicionadas por engano (ex: identidade)",
                                    "Esquecer de normalizar ou escalar A",
                                    "Confundir cond(A) com det(A)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver o sistema exato Ax = b_exact",
                                  "subSteps": [
                                    "Use x_exact = A \\ b_exact para obter a solução numérica.",
                                    "Calcule o erro relativo exato: norm(x_exact - x_true)/norm(x_true).",
                                    "Armazene x_exact e o erro como referência.",
                                    "Plote ou exiba os valores para visualização inicial."
                                  ],
                                  "verification": "Erro relativo deve ser próximo de zero (ex: <1e-12) em precisão de máquina.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "MATLAB com funções de álgebra linear: mldivide (\\)",
                                    "Função norm()"
                                  ],
                                  "tips": "Sempre use x_true conhecida para benchmark; evite soluções simbólicas para simular cenários reais.",
                                  "learningObjective": "Aplicar solvers lineares e quantificar erros numéricos em sistemas ideais.",
                                  "commonMistakes": [
                                    "Usar inv(A)*b em vez de A\\b (menos eficiente e propenso a erros)",
                                    "Ignorar normalização de vetores",
                                    "Não salvar x_true para comparações futuras"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir perturbação pequena em b e resolver o sistema perturbado",
                                  "subSteps": [
                                    "Crie b_perturbed = b_exact + delta * norm(b_exact), onde delta = 1e-6 (pequena).",
                                    "Resolva x_perturbed = A \\ b_perturbed.",
                                    "Calcule erro relativo perturbado: norm(x_perturbed - x_true)/norm(x_true).",
                                    "Compare amplificação: erro_perturbed / |delta| deve ser ≈ cond(A)."
                                  ],
                                  "verification": "Confirme que a perturbação em b é pequena (||delta_b|| / ||b|| < 1e-5), mas erro em x é grande (>> delta).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo ambiente MATLAB",
                                    "Função randn() ou eps para gerar delta aleatória"
                                  ],
                                  "tips": "Varie delta (1e-8 a 1e-3) em um loop para observar o comportamento; use gráficos para visualizar amplificação.",
                                  "learningObjective": "Simular propagação de erros de entrada para saída em sistemas mal condicionados.",
                                  "commonMistakes": [
                                    "Perturbação muito grande (invalida 'pequena')",
                                    "Comparar com x_exact em vez de x_true",
                                    "Não escalar perturbação relativa a norm(b)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e visualizar a amplificação de erros",
                                  "subSteps": [
                                    "Compute o bound teórico: cond(A) * (||delta_b|| / ||b||).",
                                    "Crie gráficos: erro vs. log(delta), cond(A) vs. tamanho da matriz.",
                                    "Teste com matrizes maiores (ex: Hilbert matrix via gallery('hilb',n)).",
                                    "Documente observações em um relatório ou script comentado."
                                  ],
                                  "verification": "Gráficos mostram amplificação linear com log(cond(A)); bound teórico é respeitado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Funções plot(), semilogy(), gallery()",
                                    "Script MATLAB salvo"
                                  ],
                                  "tips": "Use gallery('hilb',5) para exemplos prontos mal condicionados; exporte figuras para relatórios.",
                                  "learningObjective": "Interpretar numericamente o teorema de condicionamento e validar teoricamente.",
                                  "commonMistakes": [
                                    "Ignorar efeitos de precisão de máquina em cond(A) muito alto",
                                    "Não logar escalas nos gráficos",
                                    "Confundir erro relativo com absoluto"
                                  ]
                                }
                              ],
                              "practicalExample": "Em MATLAB: A = [1 1; 1 1+1e-10]; x_true = [1;2]; b = A*x_true; cond_A = cond(A); b_pert = b + 1e-6*randn(2,1)*norm(b); x_pert = A\\b_pert; erro_amp = norm(x_pert - x_true)/norm(x_true) / 1e-6; fprintf('Amplificação: %g vs cond(A): %g', erro_amp, cond_A); // Saída mostra amplificação ≈ cond(A) ≈ 1e10.",
                              "finalVerifications": [
                                "cond(A) calculado corretamente e é alto (>1e8).",
                                "Erro em x_perturbed é amplificado pelo fator cond(A) em relação a delta_b.",
                                "Gráficos mostram relação log-linear entre perturbação e erro.",
                                "Solução exata tem erro numérico desprezível.",
                                "Testes com múltiplas perturbações confirmam consistência.",
                                "Script roda sem erros e é reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de A mal condicionado (cond(A) alto).",
                                "Correta quantificação de erros relativos e amplificação.",
                                "Uso apropriado de funções MATLAB e visualizações claras.",
                                "Interpretação teórica correta (ligação com teorema de condicionamento).",
                                "Código limpo, comentado e com testes variados.",
                                "Análise de sensibilidade a diferentes tamanhos de matriz."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso de solvers lineares e análise de estabilidade.",
                                "Análise Numérica: Teorema de condicionamento e bounds de erro.",
                                "Engenharia Civil: Modelagem de estruturas sensíveis (ex: vigas esbeltas).",
                                "Estatística: Propagação de incertezas em medições.",
                                "Física Computacional: Simulações com ruído em equações diferenciais."
                              ],
                              "realWorldApplication": "Na análise estrutural de edifícios altos, pequenas incertezas em cargas de vento (b) podem amplificar erros em deslocamentos (x), levando a projetos inseguros; simulações ajudam a validar modelos finitos e escolher pré-condicionadores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Interpretar estabilidade numérica",
                            "description": "Classificar sistemas como bem ou mal condicionados com base em cond(A) e prever perda de precisão em dígitos decimais ≈ log10(cond(A)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Número de Condicionamento",
                                  "subSteps": [
                                    "Defina o número de condicionamento cond(A) como a medida de sensibilidade de Ax=b a perturbações em A ou b.",
                                    "Aprenda que cond(A) = ||A|| * ||A^{-1}||, onde ||.|| é uma norma matricial compatível (ex: norma 2).",
                                    "Estude que cond(A) ≥ 1 sempre, e cond(A)=1 indica matriz perfeitamente condicionada.",
                                    "Revise exemplos simples: matriz identidade tem cond=1; matrizes triangulares superiores mal escaladas têm cond alto.",
                                    "Explore relação com autovalores: para norma 2, cond(A) = |λ_max| / |λ_min|."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que cond(A) representa e dê um exemplo onde cond(A)=1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear Numérica (ex: Golub & Van Loan)",
                                    "Notebook com Python/Octave para exemplos",
                                    "Vídeo tutorial sobre normas matriciais"
                                  ],
                                  "tips": "Sempre normalize as matrizes para evitar confusões com escalas diferentes.",
                                  "learningObjective": "Compreender a definição e interpretação básica do número de condicionamento.",
                                  "commonMistakes": [
                                    "Confundir cond(A) com det(A)",
                                    "Ignorar que cond(A) é adimensional",
                                    "Achar que cond pequeno sempre significa boa solução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Número de Condicionamento",
                                  "subSteps": [
                                    "Implemente cálculo de cond(A) usando decomposição SVD: cond(A) = σ1 / σn, onde σ são valores singulares.",
                                    "Pratique com normas Frobenius e infinito para comparação.",
                                    "Use software: em Python, numpy.linalg.cond(A, p=2).",
                                    "Calcule manualmente para matrizes 2x2: ex A = [[1,1],[1,1+ε]], cond≈1/ε.",
                                    "Compare cond para matrizes bem e mal escaladas."
                                  ],
                                  "verification": "Calcule cond(A) para 3 matrizes dadas e verifique com software (erro <1%).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Matrizes de exemplo impressas ou em spreadsheet",
                                    "Calculadora matricial online"
                                  ],
                                  "tips": "Use p=2 para precisão em análise numérica; evite p='fro' para interpretação de estabilidade.",
                                  "learningObjective": "Dominar o cálculo prático de cond(A) usando métodos numéricos.",
                                  "commonMistakes": [
                                    "Usar norma errada sem justificar",
                                    "Não inverter A corretamente",
                                    "Esquecer de lidar com matrizes singulares (cond=inf)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar Sistemas como Bem ou Mal Condicionados",
                                  "subSteps": [
                                    "Estabeleça critérios: cond(A)<10^3 = bem condicionado; 10^3-10^6 = moderado; >10^6 = mal condicionado.",
                                    "Analise impacto: para cond=10^k, erro relativo na solução pode amplificar até k vezes.",
                                    "Classifique matrizes de Gram em contextos civis (ex: rigidez de treliças).",
                                    "Discuta pivoteamento e pré-condicionadores como mitigadores.",
                                    "Pratique classificação com 5 matrizes de tamanhos variados."
                                  ],
                                  "verification": "Classifique corretamente 5 sistemas lineares fornecidos como bem/mal condicionados com justificativa.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Conjunto de matrizes de teste (ex: Hilbert matrices)",
                                    "Tabela de critérios de condicionamento",
                                    "Software para SVD"
                                  ],
                                  "tips": "Considere o hardware: double precision tem ~15 dígitos; cond>10^8 perde toda precisão.",
                                  "learningObjective": "Aplicar thresholds práticos para classificar condicionamento.",
                                  "commonMistakes": [
                                    "Usar thresholds absolutos sem contexto de precisão máquina",
                                    "Ignorar norma usada",
                                    "Classificar baseado só em det(A)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prever Perda de Precisão em Dígitos Decimais",
                                  "subSteps": [
                                    "Lembre fórmula: perda de dígitos ≈ log10(cond(A)) + log10(ε_machine), onde ε_machine≈10^{-16}.",
                                    "Simplifique para double: perda ≈ log10(cond(A)).",
                                    "Calcule para exemplos: cond=10^6 → perda de 6 dígitos.",
                                    "Simule numericamente: resolva Ax=b com ruído e meça erro relativo ||δx||/||x|| ≈ cond(A) * ||δb||/||b||.",
                                    "Interprete em engenharia: perda >3 dígitos é inaceitável para projetos civis."
                                  ],
                                  "verification": "Preveja perda para 4 casos e valide com simulação numérica (erro previsão <10%).",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Código Python para simulação de erros",
                                    "Tabela log10 de potências de 10",
                                    "Exemplos de matrizes mal condicionadas"
                                  ],
                                  "tips": "Sempre reporte log10(cond) para dígitos perdidos diretamente.",
                                  "learningObjective": "Quantificar e prever impacto do condicionamento na precisão.",
                                  "commonMistakes": [
                                    "Esquecer log10(ε_machine)",
                                    "Confundir perda relativa com absoluta",
                                    "Não simular para validar"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise estrutural de uma treliça civil, dada matriz de rigidez A (5x5) com cond(A)=10^5 via SVD. Classifique como mal condicionado (moderado a alto). Preveja perda de ~5 dígitos: com cargas medidas a 4 dígitos, deslocamentos terão apenas ~1 dígito confiável. Simule adicionando ruído 10^{-4} em b e observe amplificação no erro de x.",
                              "finalVerifications": [
                                "Classifica corretamente um sistema com cond(A)=10^2 como bem condicionado.",
                                "Calcula log10(cond(A))=4.3 e prevê perda de 4 dígitos com justificativa.",
                                "Simula erro amplificado em Ax=b e relaciona a cond(A).",
                                "Identifica matriz de Gram mal condicionada em contexto civil.",
                                "Explica por que pivoteamento LU ajuda mas não resolve mal condicionamento.",
                                "Valida cond(A) com duas normas diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de cond(A): erro <5% vs software padrão.",
                                "Classificação consistente com thresholds contextualizados (ex: engenharia tolera até 10^4).",
                                "Previsão de perda de precisão alinhada com fórmula log10(cond(A)).",
                                "Uso correto de simulações numéricas para validação.",
                                "Explicações claras ligando teoria a prática civil.",
                                "Identificação de erros comuns em pelo menos 3 cenários."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso de NumPy/SciPy para SVD e cond.",
                                "Estatística: Análise de erros relativos e propagação de incertezas.",
                                "Física/Engenharia Mecânica: Estabilidade em sistemas de equilíbrios (treliças).",
                                "Matemática Aplicada: Autovalores e normas em Álgebra Linear.",
                                "Computação Científica: Impacto de precisão máquina em simulações FEM."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, ao resolver sistemas de rigidez de edifícios altos via método dos elementos finitos, um cond(A)>10^6 indica que pequenas imprecisões em medições de material amplificam erros em deslocamentos previstos, podendo levar a projetos inseguros; engenheiros usam isso para decidir por refinamento de malha ou regularização."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Aplicações em Engenharia Civil e Matriz de Gram",
                        "description": "Análise de sistemas mal condicionados oriundos de problemas de engenharia civil, como análise estrutural, e uso da matriz de Gram para avaliar ortogonalidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Construir matriz de Gram",
                            "description": "Calcular G = A^T A para um conjunto de vetores coluna de A, identificando condicionamento via autovalores de G em métodos de elementos finitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz A com vetores coluna",
                                  "subSteps": [
                                    "Identifique os vetores coluna que representam funções de base ou deslocamentos nodais no contexto de elementos finitos.",
                                    "Determine as dimensões da matriz A (m linhas por n colunas, onde m é o número de pontos de Gauss e n o número de graus de liberdade).",
                                    "Preencha a matriz A com os valores dos vetores, garantindo que sejam vetores coluna.",
                                    "Verifique a normalização ou orthogonalidade inicial dos vetores, se aplicável.",
                                    "Documente as unidades e o contexto físico dos vetores."
                                  ],
                                  "verification": "Confirme que A é uma matriz m x n com vetores coluna corretamente posicionados e sem erros de digitação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e calculadora",
                                    "Software como MATLAB, Python (NumPy) ou Octave"
                                  ],
                                  "tips": "Use funções de base lineares ou quadráticas típicas em elementos finitos para exemplos iniciais.",
                                  "learningObjective": "Compreender como representar um conjunto de vetores em uma matriz para análise de Gram.",
                                  "commonMistakes": [
                                    "Confundir vetores linha com coluna",
                                    "Ignorar dimensões incompatíveis",
                                    "Omitir normalização quando requerida"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a transposta da matriz A^T",
                                  "subSteps": [
                                    "Troque linhas por colunas e colunas por linhas da matriz A para obter A^T (n x m).",
                                    "Verifique manualmente para matrizes pequenas (2x2 ou 3x3) comparando elementos.",
                                    "Implemente computacionalmente usando funções como transpose() em NumPy ou ' em MATLAB.",
                                    "Confirme simetria se A for quadrada, mas note que geralmente não é.",
                                    "Salve A^T em uma variável separada para uso posterior."
                                  ],
                                  "verification": "Multiplique um vetor teste por A e A^T para validar dimensões e resultados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de álgebra linear (NumPy, MATLAB)",
                                    "Planilha Excel para verificação manual"
                                  ],
                                  "tips": "Lembre-se: (A^T)^T = A; teste isso para validação.",
                                  "learningObjective": "Dominar o conceito e cálculo da transposta matricial no contexto de produtos internos.",
                                  "commonMistakes": [
                                    "Erro de sinal em elementos negativos",
                                    "Confundir A com A^T",
                                    "Dimensões invertidas incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o produto matricial G = A^T * A",
                                  "subSteps": [
                                    "Verifique compatibilidade dimensional: colunas de A^T = linhas de A (n x n resulta em G quadrada).",
                                    "Calcule elemento a elemento para matrizes pequenas: G_ij = soma_k (A^T_ik * A_kj).",
                                    "Use multiplicação matricial computacional para eficiência.",
                                    "Confirme que G é simétrica (G = G^T) e positiva semi-definida.",
                                    "Interprete G como matriz de produtos internos dos vetores coluna."
                                  ],
                                  "verification": "Verifique simetria comparando G_ij com G_ji e autovalores não-negativos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software NumPy/MATLAB",
                                    "Calculadora matricial online"
                                  ],
                                  "tips": "Para grandes n, use algoritmos otimizados; evite loops manuais em código.",
                                  "learningObjective": "Executar multiplicação matricial e reconhecer G como matriz de Gram.",
                                  "commonMistakes": [
                                    "Multiplicação na ordem errada (A A^T em vez de A^T A)",
                                    "Erros aritméticos em somas",
                                    "Ignorar precisão numérica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar condicionamento via autovalores de G",
                                  "subSteps": [
                                    "Calcule os autovalores de G usando decomposição espectral (eig() em software).",
                                    "Identifique o maior (λ_max) e menor (λ_min) autovalores positivos.",
                                    "Compute o número de condicionamento κ = λ_max / λ_min.",
                                    "Classifique o condicionamento: κ < 10^3 bom, >10^6 mal condicionado.",
                                    "Discuta implicações para estabilidade em métodos de elementos finitos."
                                  ],
                                  "verification": "Simule perturbação em A e verifique impacto na solução via G.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Bibliotecas SciPy/NumPy para autovalores",
                                    "Documentação de elementos finitos"
                                  ],
                                  "tips": "Autovalores zero indicam dependência linear nos vetores.",
                                  "learningObjective": "Avaliar estabilidade numérica usando espectro de autovalores de G.",
                                  "commonMistakes": [
                                    "Confundir autovalores com autovetores",
                                    "Usar norma errada para condicionamento",
                                    "Ignorar autovalores próximos de zero"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga de Euler-Bernoulli com 2 elementos, considere vetores de forma φ1 = [1, ξ]^T e φ2 = [1, ξ^2]^T em pontos de Gauss ξ=±1/√3. Construa A = [φ1(ξ1), φ2(ξ1); φ1(ξ2), φ2(ξ2)], compute G = A^T A e verifique κ ≈ 10^4 indicando mal condicionamento devido a polinômios não ortogonais.",
                              "finalVerifications": [
                                "G é simétrica e possui autovalores reais não-negativos.",
                                "Número de condicionamento κ calculado corretamente.",
                                "Identificação precisa de vetores linearmente dependentes se λ_min ≈ 0.",
                                "Reprodução correta de G para exemplo conhecido.",
                                "Discussão válida de impactos em elementos finitos.",
                                "Código ou cálculo manual sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de A^T A (erro < 10^-10).",
                                "Correta interpretação de autovalores para condicionamento.",
                                "Uso apropriado de ferramentas computacionais.",
                                "Análise qualitativa de mal condicionamento em contexto civil.",
                                "Documentação clara de passos e verificações.",
                                "Identificação de pelo menos 2 implicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição espectral e normas matriciais.",
                                "Programação Numérica: Implementação eficiente em Python/MATLAB.",
                                "Mecânica Computacional: Estabilidade em FEM para estruturas.",
                                "Otimização: Redução de condicionamento via orthogonalização.",
                                "Física: Produtos internos em espaços de funções."
                              ],
                              "realWorldApplication": "Na análise de estruturas civis via elementos finitos (ex: pontes ou edifícios), a matriz de Gram avalia o condicionamento da matriz de rigidez, previnindo erros numéricos em simulações de grandes deformações ou vibrações, otimizando malhas e funções de base para precisão em softwares como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Analisar mal condicionamento em estruturas",
                            "description": "Examinar matrizes de rigidez em análise de vigas ou pórticos, calculando cond(K) e propondo pré-condicionadores para melhorar solvência numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos de condicionamento numérico em matrizes de rigidez",
                                  "subSteps": [
                                    "Estude a definição de número de condição cond(K) = ||K|| * ||K^{-1}||",
                                    "Revise normas de matrizes (2-norma, norma de Frobenius) aplicáveis a matrizes simétricas positivas definidas",
                                    "Analise impactos de mal condicionamento: sensibilidade a perturbações, lentidão em solvers iterativos",
                                    "Explore causas em estruturas: elementos esbeltos, malha irregular em FEM",
                                    "Pratique cálculo manual de cond(K) para matriz 2x2 simples"
                                  ],
                                  "verification": "Resuma em um parágrafo os efeitos de cond(K) > 10^6 em análises estruturais",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), MATLAB/Python com NumPy",
                                  "tips": "Use autovalores para cond(K) ≈ λ_max / λ_min em matrizes SPD",
                                  "learningObjective": "Definir e interpretar cond(K) em contexto de EDOS estruturais",
                                  "commonMistakes": "Confundir norma de vetor com norma de matriz; ignorar propriedades SPD de K"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montar matriz de rigidez K para uma estrutura simples (viga ou pórtico)",
                                  "subSteps": [
                                    "Escolha uma viga biapoiada com 2 elementos finitos lineares",
                                    "Calcule matrizes locais de rigidez ke para cada elemento (EA/L, etc.)",
                                    "Monte K global via transformação de coordenadas e superposição",
                                    "Aplique condições de contorno (remova graus de liberdade fixos)",
                                    "Verifique simetria e positiva definitude de K"
                                  ],
                                  "verification": "Gere K numérica e confirme det(K) > 0 e simetria exata",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software FEM simples (ex: Ftool, MATLAB script), papel milimetrado",
                                  "tips": "Padronize unidades (kN, m) para evitar erros de escala",
                                  "learningObjective": "Construir K realista para estruturas 1D/2D",
                                  "commonMistakes": "Esquecer renumeração de nós pós-contorno; escalas inconsistentes entre elementos"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e interpretar cond(K) para detectar mal condicionamento",
                                  "subSteps": [
                                    "Implemente cálculo de cond(K) via SVD ou autovalores (svd(K) ou eig(K))",
                                    "Varie parâmetros: comprimento elementos, módulo elasticidade, para induzir mal condicionamento",
                                    "Compare cond(K) com thresholds (ex: >10^12 indica mal condicionamento grave)",
                                    "Plote autovalores para visualizar clustering perto de zero",
                                    "Registre sensibilidade: perturbe cargas e compare deslocamentos"
                                  ],
                                  "verification": "Obtenha cond(K) > 10^10 e demonstre erro relativo >1% em solução",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python (NumPy, SciPy.linalg), MATLAB, Jupyter Notebook",
                                  "tips": "Use cond('2') para norma espectral precisa",
                                  "learningObjective": "Quantificar e diagnosticar mal condicionamento em K estrutural",
                                  "commonMistakes": "Usar norma errada (inf vs 2); não perturbar corretamente para teste de sensibilidade"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Propor e testar pré-condicionadores para melhorar solvência",
                                  "subSteps": [
                                    "Escolha pré-condicionadores: diagonal (IDD), incompleto Cholesky (ILU)",
                                    "Implemente M^{-1}K ≈ I via pcg ou gmres",
                                    "Compare iterações e tempo de CPU com/s em solver sem pré-condicionador",
                                    "Ajuste tolerâncias e parâmetros (fill-in para ILU)",
                                    "Avalie redução em cond(M^{-1}K)"
                                  ],
                                  "verification": "Reduza número de iterações em >50% com pré-condicionador",
                                  "estimatedTime": "90 minutos",
                                  "materials": "SciPy sparse.linalg (cg, gmres), MATLAB pcg",
                                  "tips": "Comece com diagonal simples; teste em K esparsa para realismo",
                                  "learningObjective": "Aplicar pré-condicionadores iterativos em problemas estruturais",
                                  "commonMistakes": "Aplicar pré-condicionador denso em K grande; ignorar breakdown em ILU"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar análise em estrutura mais complexa e sintetizar resultados",
                                  "subSteps": [
                                    "Aplique a um pórtico 2D com 4 barras",
                                    "Gere relatório: cond(K), pré-condicionador escolhido, métricas de performance",
                                    "Discuta trade-offs: precisão vs custo computacional",
                                    "Simule falha: remova pré-condicionador e observe divergência",
                                    "Documente lições para malhas não-uniformes"
                                  ],
                                  "verification": "Relatório com gráficos de convergência e tabela comparativa",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Script customizado, LaTeX/Google Docs para relatório",
                                  "tips": "Use sparse matrices desde o início para escalabilidade",
                                  "learningObjective": "Integrar análise de condicionamento em workflow FEM",
                                  "commonMistakes": "Sobre-generalizar de exemplo simples; negligenciar overhead do pré-condicionador"
                                }
                              ],
                              "practicalExample": "Em uma viga biapoiada de 10m com elementos de 1m e 9m (malha irregular), monte K, calcule cond(K) ≈ 10^15 devido a elementos esbeltos, aplique pré-condicionador diagonal reduzindo iterações de 2000+ para 50 em pcg para deslocamentos sob carga distribuída.",
                              "finalVerifications": [
                                "cond(K) calculado corretamente com norma 2",
                                "Pré-condicionador reduz cond efetiva e iterações",
                                "Solução coincide com analítica em caso benchmark",
                                "Relatório identifica causas estruturais do mal condicionamento",
                                "Gráficos mostram convergência acelerada",
                                "Teste de sensibilidade confirma estabilidade"
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de cond(K) (±5% erro relativo)",
                                "Adequação do pré-condicionador (redução >40% iterações)",
                                "Correta montagem de K para estrutura exemplo",
                                "Interpretação física do mal condicionamento",
                                "Clareza no relatório com visualizações",
                                "Tratamento de esparsidade e eficiência computacional"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Decomposições SVD e autovalores",
                                "Programação: Manipulação de matrizes esparsas em Python/MATLAB",
                                "Física Estrutural: Teoria de vigas/pórticos e FEM",
                                "Otimização: Métodos iterativos conjugados",
                                "Estatística: Análise de erro e sensibilidade numérica"
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios altos, onde malhas FEM irregulares levam a K mal condicionada, pré-condicionadores aceleram simulações, permitindo iterações rápidas em otimização de design e verificação sísmica em software como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.2",
                              "10.1.3.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Definição e Construção da Matriz de Gram",
                    "description": "Construção da matriz de Gram a partir de vetores e suas propriedades de simetria e semi-definida positiva.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Definição da Matriz de Gram",
                        "description": "Compreensão formal da matriz de Gram como uma matriz quadrada cujos elementos são produtos internos entre vetores de um conjunto base, fundamental para análise de condicionamento em problemas de engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Identificar a definição formal",
                            "description": "Explicar que a matriz de Gram G para vetores v1, v2, ..., vn é definida como G_ij = <vi, vj>, onde <.,.> é o produto interno, e relacionar com espaços vetoriais em R^n ou funções em problemas de valores de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Conceito de Produto Interno",
                                  "subSteps": [
                                    "Defina o produto interno em espaços euclidianos como <u, v> = soma u_i * v_i para vetores em R^n.",
                                    "Discuta propriedades: simetria (<u,v> = <v,u>), linearidade e positividade (<v,v> >= 0).",
                                    "Diferencie produto interno de produto escalar em contextos gerais.",
                                    "Exemplo simples: calcule <[1,2], [3,4]> = 1*3 + 2*4 = 11.",
                                    "Relacione com norma: ||v|| = sqrt(<v,v>)."
                                  ],
                                  "verification": "Escreva a definição e propriedades do produto interno e compute corretamente dois exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de álgebra linear ou notas online"
                                  ],
                                  "tips": [
                                    "Lembre-se: produto interno mede ângulo e similaridade entre vetores.",
                                    "Use notação <.,.> consistentemente."
                                  ],
                                  "learningObjective": "Compreender o produto interno como base para a matriz de Gram.",
                                  "commonMistakes": [
                                    "Confundir com multiplicação matricial.",
                                    "Esquecer a simetria ou definitude positiva."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Definição Formal da Matriz de Gram",
                                  "subSteps": [
                                    "Leia a definição: Para vetores v1, ..., vn, G_ij = <vi, vj>.",
                                    "Note que G é simétrica e positiva semidefinida.",
                                    "Entenda que G captura informações de inner products de um conjunto de vetores.",
                                    "Escreva a matriz explicitamente para n=2: G = [[<v1,v1>, <v1,v2>], [<v2,v1>, <v2,v2>]].",
                                    "Discuta independência linear via det(G) != 0."
                                  ],
                                  "verification": "Escreva a definição formal de G_ij e prove simetria.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Calculadora para inner products"
                                  ],
                                  "tips": [
                                    "Índices i,j começam em 1.",
                                    "G é sempre simétrica devido à propriedade do inner product."
                                  ],
                                  "learningObjective": "Memorizar e reproduzir a definição exata da matriz de Gram.",
                                  "commonMistakes": [
                                    "Usar produto matricial em vez de inner product.",
                                    "Confundir G com matriz de covariância."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Matriz de Gram para Vetores em R^n",
                                  "subSteps": [
                                    "Escolha vetores v1 = [1,0], v2 = [1,1] em R^2.",
                                    "Calcule todos <vi,vj>: <v1,v1>=1, <v1,v2>=1, <v2,v2>=2.",
                                    "Monte G = [[1,1],[1,2]].",
                                    "Verifique simetria e positivos: autovalores >0.",
                                    "Geralize para n=3 com vetores ortogonais."
                                  ],
                                  "verification": "Construa G corretamente para um conjunto dado de 3 vetores e verifique propriedades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software como MATLAB/Octave ou Python (NumPy)",
                                    "Papel para rascunho"
                                  ],
                                  "tips": [
                                    "Automatize com loop for i,j in código para prática.",
                                    "Sempre normalize vetores para insights."
                                  ],
                                  "learningObjective": "Aplicar a definição para computar G em espaços finitos.",
                                  "commonMistakes": [
                                    "Erro aritmético em inner products.",
                                    "Não simetrizar a matriz."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com Espaços de Funções e Aplicações em Engenharia",
                                  "subSteps": [
                                    "Estenda para funções: <f,g> = integral f(x)g(x) dx em problemas de contorno.",
                                    "Exemplo: funções base em método de elementos finitos (MEF).",
                                    "Discuta condicionamento: G mal-condicionada se vetores quase dependentes.",
                                    "Relacione com engenharia civil: rigidez em MEF usa matrizes de Gram.",
                                    "Compare R^n (discreto) vs. funções (contínuo)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a extensão para funções e um exemplo em contorno.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de MEF",
                                    "Gráficos de funções base (online)"
                                  ],
                                  "tips": [
                                    "Pense em discretização: funções viram vetores em malha.",
                                    "Condicionamento afeta solvers numéricos."
                                  ],
                                  "learningObjective": "Conectar definição formal a contextos reais em engenharia civil.",
                                  "commonMistakes": [
                                    "Ignorar normalização em inner products funcionais.",
                                    "Confundir com matriz de massa em MEF."
                                  ]
                                }
                              ],
                              "practicalExample": "Para v1 = [1, 1, 0], v2 = [1, 0, 1] em R^3: Compute <v1,v1>=2, <v1,v2>=1, <v2,v2>=2, resultando em G = [[2,1],[1,2]]. Verifique det(G)=3>0 (linearmente independentes). Em MEF, isso representa inner products de funções de forma em viga.",
                              "finalVerifications": [
                                "Define corretamente G_ij = <vi, vj>.",
                                "Constrói G simétrica para vetores dados.",
                                "Identifica propriedades (simetria, PSD).",
                                "Relaciona com R^n e espaços funcionais.",
                                "Explica papel em condicionamento numérico.",
                                "Aplica em exemplo de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100%).",
                                "Correção em cálculos de inner products (90%+).",
                                "Demonstração de propriedades matemáticas.",
                                "Conexão clara com contextos de engenharia.",
                                "Criatividade em exemplos práticos.",
                                "Ausência de erros comuns em notação."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores e decomposição.",
                                "Análise Numérica: condicionamento e Cholesky.",
                                "Programação: implementação em Python/NumPy.",
                                "Engenharia Computacional: MEF e solvers.",
                                "Física: inner products em mecânica."
                              ],
                              "realWorldApplication": "Na engenharia civil, matrizes de Gram surgem em métodos de elementos finitos para montar matrizes de rigidez, avaliando condicionamento em simulações de estruturas sob cargas, otimizando malhas para precisão numérica em projetos de pontes e edifícios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Reconhecer contexto de uso",
                            "description": "Identificar aplicações da matriz de Gram no condicionamento de sistemas lineares, como no método dos resíduos ponderados para problemas de valor inicial e de contorno em engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e construção da matriz de Gram",
                                  "subSteps": [
                                    "Estudar a definição formal da matriz de Gram como G = Φ^T Φ, onde Φ é a matriz de funções base.",
                                    "Calcular exemplos simples de matriz de Gram para bases ortogonais e não ortogonais.",
                                    "Analisar propriedades como simetria positiva definida e sua relação com produtos internos.",
                                    "Explorar o determinante da matriz de Gram como medida de independência linear das bases.",
                                    "Comparar matriz de Gram com matriz identidade em bases ortonormais."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a construção de uma matriz de Gram para duas funções base e verificar se o aluno identifica corretamente suas propriedades.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang), software MATLAB ou Python (NumPy), exemplos de funções base impressos"
                                  ],
                                  "tips": "Use funções trigonométricas simples como sen(x) e cos(x) para visualização intuitiva.",
                                  "learningObjective": "Compreender a estrutura matemática da matriz de Gram como base para condicionamento.",
                                  "commonMistakes": [
                                    "Confundir com transposta simples sem produto interno",
                                    "Ignorar a simetria positiva definida"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o condicionamento de sistemas lineares",
                                  "subSteps": [
                                    "Definir número de condicionamento κ(A) = ||A|| * ||A^{-1}|| e sua interpretação geométrica.",
                                    "Relacionar o condicionamento ruim com bases mal condicionadas via determinante pequeno da Gram.",
                                    "Simular numericamente o impacto de condicionamento em soluções de Ax = b com ruído.",
                                    "Estudar como a matriz de Gram afeta a estabilidade em métodos de projeção.",
                                    "Analisar exemplos onde Gram mal condicionada amplifica erros de arredondamento."
                                  ],
                                  "verification": "Resolver um sistema mal condicionado antes/depois de Gram e comparar erros relativos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB/Python com funções cond() ou np.linalg.cond(), matrizes de teste"
                                  ],
                                  "tips": "Comece com bases quase lineares dependentes para ver κ explodir.",
                                  "learningObjective": "Identificar como Gram influencia a estabilidade numérica de sistemas lineares.",
                                  "commonMistakes": [
                                    "Achar que condicionamento só depende de dimensão, ignorando ortogonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o método dos resíduos ponderados",
                                  "subSteps": [
                                    "Descrever o método como minimização de resíduos ponderados por normas induzidas por Gram.",
                                    "Derivar a formulação para problemas de valor inicial (IVP) como equações diferenciais ordinárias.",
                                    "Estender para problemas de valor de contorno (BVP) em EDOs com bases de Galerkin.",
                                    "Implementar um exemplo numérico simples em código para IVP como y' + y = 0.",
                                    "Verificar como Gram entra na solução via ponderação dos resíduos."
                                  ],
                                  "verification": "Implementar e rodar código que usa Gram no método, comparando com solução exata.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código-fonte Python/MATLAB para método dos resíduos, documentação SciPy"
                                  ],
                                  "tips": "Use pesos unitários inicialmente para simplificar e depois introduza Gram.",
                                  "learningObjective": "Reconhecer o papel pivotal da Gram na ponderação de resíduos.",
                                  "commonMistakes": [
                                    "Confundir resíduos ponderados com mínimos quadrados padrão",
                                    "Esquecer normalização das bases"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar aplicações em engenharia civil",
                                  "subSteps": [
                                    "Mapear IVPs/BVPs em engenharia: deformação de vigas (EDOs), fluxo em barragens (equações elípticas).",
                                    "Analisar casos reais: condicionamento em simulações FEM para estruturas civis.",
                                    "Pesquisar artigos ou casos onde Gram melhora precisão em métodos numéricos civis.",
                                    "Discutir limitações: quando Gram leva a ill-condicionamento em malhas finas.",
                                    "Criar um fluxograma de decisão para usar Gram em problemas civis específicos."
                                  ],
                                  "verification": "Listar e justificar 3 aplicações específicas em engenharia civil com diagramas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Artigos IEEE/ASCE sobre FEM em civil, software ANSYS ou FEniCS introdutório"
                                  ],
                                  "tips": "Foque em problemas lineares elásticos para conexão direta.",
                                  "learningObjective": "Aplicar conceitualmente Gram a contextos reais de engenharia civil.",
                                  "commonMistakes": [
                                    "Generalizar demais sem exemplos concretos",
                                    "Ignorar contexto numérico vs. analítico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de deformação de uma viga cantilever sob carga distribuída (BVP: EI y'''' = q(x)), use bases polinomiais para aproximação Galerkin. Calcule a matriz de Gram para condicionar o sistema, reduzindo erros em 50% em malhas grosseiras, verificando resíduos ponderados mínimos.",
                              "finalVerifications": [
                                "O aluno lista corretamente 3 aplicações da Gram em IVPs/BVPs civis.",
                                "Explica o impacto de Gram no condicionamento com exemplo numérico.",
                                "Identifica quando evitar bases que geram Gram ill-condicionada.",
                                "Descreve verbalmente o método dos resíduos ponderados envolvendo Gram.",
                                "Cria um diagrama conectando Gram a um problema civil real.",
                                "Compara precisão com/sem Gram em simulação simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de Gram e condicionamento (30%)",
                                "Profundidade de aplicações: exemplos civis relevantes e justificados (25%)",
                                "Habilidade numérica: cálculos/simulações sem erros graves (20%)",
                                "Conexões interdisciplinares: links com métodos numéricos (15%)",
                                "Clareza de expressão: explicações lógicas e fluxogramas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: produtos internos e ortogonalidade",
                                "Cálculo Numérico: estabilidade e métodos espectrais",
                                "Física/Mecânica: modelagem de EDOs em estruturas",
                                "Programação: implementação em Python/MATLAB para FEM",
                                "Estatística: interpretação de determinantes como variâncias"
                              ],
                              "realWorldApplication": "Na análise estrutural de pontes (ex: Ponte Rio-Niterói), a matriz de Gram condicionaliza sistemas FEM para EDOs de flexão, permitindo simulações precisas de tensões sob vento/sísmos, evitando colapsos por erros numéricos em softwares como SAP2000."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Diferenciar de outras matrizes",
                            "description": "Comparar a matriz de Gram com matrizes de covariância ou Hessiana, destacando seu papel específico na ortogonalização e análise espectral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definição e propriedades fundamentais da Matriz de Gram",
                                  "subSteps": [
                                    "Defina a matriz de Gram como G = A^T A, onde A é uma matriz cujas colunas são vetores.",
                                    "Liste propriedades chave: simétrica, semidefinida positiva, autovalores não-negativos.",
                                    "Discuta seu papel na verificação de independência linear (rank(G) = n se vetores independentes).",
                                    "Exemplo simples: Compute G para dois vetores em R^2.",
                                    "Relacione com produto interno e norma euclidiana."
                                  ],
                                  "verification": "Construa manualmente a matriz de Gram para um conjunto de 3 vetores e verifique se é simétrica e positiva semidefinida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, calculadora ou Python/NumPy para verificação numérica",
                                  "tips": "Sempre normalize vetores antes para facilitar interpretação dos autovalores.",
                                  "learningObjective": "Compreender a construção e propriedades intrínsecas da matriz de Gram.",
                                  "commonMistakes": "Confundir com A A^T (outra forma de Gram para linhas); ignorar que é sempre simétrica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Matriz de Covariância e suas características",
                                  "subSteps": [
                                    "Defina como Σ = (1/n) X^T X - μ μ^T, onde X são dados centralizados.",
                                    "Liste propriedades: simétrica, usada em PCA para variância.",
                                    "Compare dimensões: tipicamente n x n para n variáveis.",
                                    "Exemplo: Compute covariância para dados de sensores de deformação em uma viga.",
                                    "Discuta autovalores representando variâncias principais."
                                  ],
                                  "verification": "Gere um dataset simples de 10 pontos em 2D, centralize e compute Σ; verifique autovalores positivos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com NumPy e Pandas, ou MATLAB",
                                  "tips": "Sempre centralize os dados primeiro para evitar viés de média.",
                                  "learningObjective": "Identificar como a covariância captura variabilidade em dados multivariados.",
                                  "commonMistakes": "Esquecer de dividir por n ou usar dados não-centralizados; confundir com matriz de correlação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Matriz Hessiana e seu contexto em otimização",
                                  "subSteps": [
                                    "Defina H como matriz de segundas derivadas parciais de uma função f(x).",
                                    "Propriedades: simétrica se f twice continuously differentiable, usada no teste de segunda ordem.",
                                    "Exemplo: Compute Hessiana para f(x,y) = x^2 + y^2 + xy em otimização estrutural.",
                                    "Relacione com curvatura e convergência em métodos como Newton.",
                                    "Discuta autovalores: positivos para mínimo local."
                                  ],
                                  "verification": "Derive H para uma função quadrática simples e teste definitividade positiva.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Caderno para derivadas, SymPy (Python) para automação",
                                  "tips": "Use simetria para simplificar cálculos de elementos off-diagonal.",
                                  "learningObjective": "Entender o papel da Hessiana na análise de funções multivariáveis.",
                                  "commonMistakes": "Confundir com gradiente (primeiras derivadas); assumir sempre definida positiva."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar as matrizes e destacar papéis na ortogonalização e análise espectral",
                                  "subSteps": [
                                    "Compare origens: Gram de produtos internos, Covariância de dados estatísticos, Hessiana de derivadas.",
                                    "Diferenças chave: Gram para ortogonalidade (QR decomposition), Covariância para PCA, Hessiana para otimização.",
                                    "Na análise espectral: autovalores de Gram para energias de projeção, covariância para variâncias, Hessiana para estabilidade.",
                                    "Exemplo comparativo: Use mesmo conjunto de vetores para as três matrizes.",
                                    "Conclua: Gram única para bases ortogonais em métodos numéricos."
                                  ],
                                  "verification": "Escreva um relatório de 1 página listando 5 diferenças e 2 similaridades, com exemplos numéricos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha ou Jupyter Notebook para computações paralelas",
                                  "tips": "Crie uma tabela comparativa para visualizar diferenças rapidamente.",
                                  "learningObjective": "Diferenciar precisamente os usos e destacar superioridade da Gram em ortogonalização.",
                                  "commonMistakes": "Equiparar Gram a Covariância por similaridade na forma; ignorar contexto não-estatístico da Gram."
                                }
                              ],
                              "practicalExample": "Em análise de estruturas civis, considere vetores de modos de vibração de uma ponte. Construa a matriz de Gram para ortogonalizar modos (verificar independência), compare com covariância de dados de acelerômetros (análise de variância sísmica) e Hessiana de função de energia potencial (otimização de design contra colapso).",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças fundamentais entre Gram, Covariância e Hessiana.",
                                "Computar as três matrizes para um conjunto de vetores de 3D e discutir autovalores.",
                                "Identificar quando usar Gram para ortogonalização em um problema de engenharia.",
                                "Listar 2 aplicações espectrais únicas da Gram vs. outras.",
                                "Resolver um exercício: Dado A, distinguir G de Σ para dados de A."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e propriedades de cada matriz (80% corretas).",
                                "Clareza na comparação, com exemplos concretos (mínimo 3 diferenças destacadas).",
                                "Uso correto de terminologia (ortogonalização, análise espectral).",
                                "Demonstração prática via código ou cálculo manual sem erros.",
                                "Conexão explícita ao contexto de engenharia civil computacional.",
                                "Profundidade na discussão de autovalores e definitividade."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Matriz de covariância em análise de dados multivariados e PCA.",
                                "Cálculo Avançado: Hessiana em otimização não-linear e métodos de Newton.",
                                "Física Aplicada: Análise espectral em dinâmica de estruturas e vibrações.",
                                "Computação Científica: Decomposição QR via Gram-Schmidt em simulações FEM."
                              ],
                              "realWorldApplication": "Na engenharia civil computacional, a matriz de Gram ortogonaliza bases em elementos finitos para análise modal eficiente de edifícios, diferenciando-se da covariância (usada em modelagem de incertezas sísmicas) e Hessiana (otimização de formas resistentes), melhorando precisão em simulações de vento e terremotos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Construção da Matriz de Gram a partir de Vetores",
                        "description": "Processo passo a passo para calcular a matriz de Gram dada uma base de vetores, incluindo implementação computacional simples.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Calcular produtos internos",
                            "description": "Computar o produto interno <vi, vj> para pares de vetores em R^n, considerando normas euclidianas ou ponderadas para problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e fórmulas do produto interno",
                                  "subSteps": [
                                    "Revise a definição do produto interno euclidiano: <vi, vj> = ∑_{k=1}^n vi_k * vj_k para vetores em R^n.",
                                    "Estude a variação ponderada: <vi, vj>_W = ∑_{k=1}^n w_k * vi_k * vj_k, onde w é vetor de pesos positivos.",
                                    "Identifique contextos em engenharia civil onde pesos representam áreas de seção ou densidades.",
                                    "Escreva as fórmulas em um papel e memorize as propriedades (simetria, linearidade).",
                                    "Diferencie de normas: ||v||^2 = <v,v>."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre produto euclidiano e ponderado, com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Calculadora",
                                    "Livro de álgebra linear ou notas de aula sobre matriz de Gram"
                                  ],
                                  "tips": "Visualize o produto interno como uma medida de similaridade angular entre vetores.",
                                  "learningObjective": "Dominar as fórmulas e quando usar cada tipo de produto interno.",
                                  "commonMistakes": [
                                    "Confundir produto interno com produto vetorial (que resulta em vetor)",
                                    "Usar pesos negativos ou zero inadvertidamente",
                                    "Esquecer o índice de soma de k=1 a n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e representar os vetores vi e vj",
                                  "subSteps": [
                                    "Escreva os vetores vi e vj explicitamente como listas de componentes em R^n.",
                                    "Verifique dimensões: ambos devem ter o mesmo n (ex: n=3 para 3D em estruturas).",
                                    "Defina o vetor de pesos w se aplicável (ex: áreas de barras em treliça).",
                                    "Normalise ou verifique se vetores estão na mesma base coordenada.",
                                    "Crie uma tabela com índices k, vi_k, vj_k e w_k (se houver)."
                                  ],
                                  "verification": "Confirme que a tabela está completa e dimensões coincidem; sem erros de transcrição.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel quadriculado",
                                    "Exemplo de vetores de um problema de engenharia civil"
                                  ],
                                  "tips": "Use notação de linha ou coluna consistente para evitar confusão matricial.",
                                  "learningObjective": "Preparar dados vetoriais de forma organizada para computação precisa.",
                                  "commonMistakes": [
                                    "Transcrever componentes incorretamente",
                                    "Usar dimensões diferentes",
                                    "Ignorar unidades físicas dos componentes (ex: metros vs. Newtons)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os termos individuais e somar o produto interno",
                                  "subSteps": [
                                    "Para cada k de 1 a n, compute o termo: vi_k * vj_k (euclidiano) ou w_k * vi_k * vj_k (ponderado).",
                                    "Registre cada termo em uma coluna da tabela.",
                                    "Some todos os termos: resultado é <vi, vj>.",
                                    "Arredonde se necessário, mantendo precisão decimal adequada (ex: 4 casas).",
                                    "Repita o cálculo manualmente uma segunda vez para validação."
                                  ],
                                  "verification": "O resultado da soma deve coincidir na segunda computação; teste com norma própria.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabela preparada do step 2"
                                  ],
                                  "tips": "Compute em pares de termos para reduzir erros de soma cumulativos.",
                                  "learningObjective": "Executar o cálculo aritmético com precisão e eficiência.",
                                  "commonMistakes": [
                                    "Erro aritmético em multiplicações",
                                    "Soma incorreta de termos",
                                    "Esquecer multiplicar por w_k em ponderado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar o resultado e interpretá-lo no contexto de engenharia civil",
                                  "subSteps": [
                                    "Verifique propriedades: <vi,vi> >=0, <vi,vj>=<vj,vi>, bilinearidade em exemplos simples.",
                                    "Calcule ângulo: cosθ = <vi,vj> / (||vi|| ||vj||) se aplicável.",
                                    "Interprete: em matriz de Gram, diagonal é energia/norma quadrada; off-diagonal mede acoplamento.",
                                    "Aplique a vetores reais: ex: deslocamentos em nós de estrutura.",
                                    "Documente o resultado com unidades (ex: N*m para forças e deslocamentos)."
                                  ],
                                  "verification": "Explique como o valor afeta a construção da matriz de Gram em um problema estrutural.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software como MATLAB ou Python (opcional para verificação)",
                                    "Exemplo de treliça ou viga"
                                  ],
                                  "tips": "Use software para validar cálculo manual em casos complexos.",
                                  "learningObjective": "Validar e contextualizar o produto interno em aplicações práticas.",
                                  "commonMistakes": [
                                    "Ignorar sinal negativo (ortogonalidade)",
                                    "Não verificar simetria",
                                    "Desconsiderar contexto físico das componentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma treliça 2D, vi = [2.5, 1.8] m (deslocamentos em nós i), vj = [1.2, 3.0] m (deslocamentos em nós j), pesos w = [1.0, 0.5] (áreas relativas). Produto ponderado: 1.0*2.5*1.2 + 0.5*1.8*3.0 = 3.0 + 2.7 = 5.7 m². Isso mede trabalho virtual entre modos de deformação.",
                              "finalVerifications": [
                                "Calcule corretamente <vi,vj> para o exemplo prático sem erros aritméticos.",
                                "Diferencie e aplique fórmula ponderada vs. euclidiana em um novo par de vetores.",
                                "Verifique propriedades do produto interno em pelo menos dois casos.",
                                "Interprete o valor numérico em termos de ortogonalidade ou acoplamento estrutural.",
                                "Construa entrada (i,j) de uma matriz de Gram 2x2 simples.",
                                "Explique impacto em condicionamento numérico para solvers de EDPs."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo: 100% correto em termos e soma.",
                                "Completude da preparação: tabela organizada sem erros de transcrição.",
                                "Validação adequada: uso de propriedades e segunda checagem.",
                                "Interpretação contextual: ligação clara com engenharia civil.",
                                "Eficiência temporal: conclusão dentro do tempo estimado total (80 min).",
                                "Clareza na documentação: fórmulas, tabelas e explicações legíveis."
                              ],
                              "crossCurricularConnections": [
                                "Física: Trabalho escalar como produto interno de força e deslocamento.",
                                "Estatística: Similaridade cosseno em análise de dados multivariados.",
                                "Computação: Kernels em machine learning para similaridade vetorial.",
                                "Matemática Aplicada: Base para SVD e ortogonalização em métodos numéricos."
                              ],
                              "realWorldApplication": "Na análise estrutural de edifícios via método dos elementos finitos, produtos internos constroem a matriz de Gram para ortonormalizar funções de forma, melhorando condicionamento de sistemas lineares e precisão em simulações de vibrações sísmicas ou cargas dinâmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Montar a matriz explicitamente",
                            "description": "Construir a matriz G preenchendo elementos G_ij com produtos internos, para conjuntos de 2 a 5 vetores, e verificar dimensionalidade n x n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os vetores e determinar as dimensões",
                                  "subSteps": [
                                    "Receba o conjunto de vetores {v1, v2, ..., vn} onde n está entre 2 e 5.",
                                    "Confirme que todos os vetores estão no mesmo espaço vetorial (ex: R^m).",
                                    "Liste os componentes de cada vetor explicitamente.",
                                    "Defina n como o número de vetores e verifique se a matriz será n x n.",
                                    "Anote a dimensão m do espaço para validar produtos internos."
                                  ],
                                  "verification": "Lista completa de vetores com componentes corretos e n identificado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para dimensões"
                                  ],
                                  "tips": "Sempre rotule os vetores como v1, v2, etc., para evitar confusão.",
                                  "learningObjective": "Compreender a entrada de dados para construção da matriz de Gram.",
                                  "commonMistakes": [
                                    "Confundir o número de vetores (n) com a dimensão do espaço (m)",
                                    "Omitir componentes de vetores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os produtos internos G_ij = <vi, vj>",
                                  "subSteps": [
                                    "Comece pela diagonal: calcule G_ii = <vi, vi> = ||vi||^2 para i=1 a n.",
                                    "Calcule os elementos acima da diagonal: G_ij = <vi, vj> para i < j.",
                                    "Use a simetria: G_ji = G_ij para i > j.",
                                    "Registre cada produto interno em uma tabela auxiliar.",
                                    "Verifique cálculos com soma de produtos componentes: <u,v> = sum(u_k * v_k)."
                                  ],
                                  "verification": "Tabela com todos G_ij calculados corretamente, incluindo simetria.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha para tabela de produtos"
                                  ],
                                  "tips": "Calcule apenas i <= j e copie para simetria para economizar tempo.",
                                  "learningObjective": "Dominar o cálculo preciso de produtos internos entre vetores.",
                                  "commonMistakes": [
                                    "Erro aritmético em somas",
                                    "Usar produto vetorial em vez de escalar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz G preenchendo os elementos",
                                  "subSteps": [
                                    "Crie uma matriz vazia n x n.",
                                    "Preencha a diagonal com G_ii.",
                                    "Preencha a parte superior com G_ij (i<j).",
                                    "Preencha a parte inferior com G_ji = G_ij.",
                                    "Escreva a matriz final em formato tabular ou linha por linha."
                                  ],
                                  "verification": "Matriz n x n preenchida com todos elementos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado para matriz"
                                  ],
                                  "tips": "Use índices i (linha) e j (coluna) consistentemente.",
                                  "learningObjective": "Montar matrizes simétricas a partir de produtos internos.",
                                  "commonMistakes": [
                                    "Trocar linhas e colunas",
                                    "Violar simetria G_ij != G_ji"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar dimensionalidade e propriedades da matriz",
                                  "subSteps": [
                                    "Confirme que a matriz tem exatamente n linhas e n colunas.",
                                    "Verifique simetria: G_ij == G_ji para todos i,j.",
                                    "Confirme que elementos diagonais são positivos (||vi||^2 > 0 se vi != 0).",
                                    "Calcule o traço (soma diagonal) e compare com soma de normas quadradas.",
                                    "Teste um produto interno aleatório para validação cruzada."
                                  ],
                                  "verification": "Relatório de verificações todas passadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora para traço"
                                  ],
                                  "tips": "Simetria é chave: transpose deve igualar a original.",
                                  "learningObjective": "Validar a correção da matriz de Gram.",
                                  "commonMistakes": [
                                    "Ignorar vetores nulos na diagonal",
                                    "Erros de transposição"
                                  ]
                                }
                              ],
                              "practicalExample": "Para n=3 vetores em R^3: v1=[1,0,0], v2=[1,1,0], v3=[1,1,1]. Calcule: <v1,v1>=1, <v1,v2>=1, <v1,v3>=1, <v2,v2>=2, <v2,v3>=2, <v3,v3>=3. Matriz G = [[1,1,1],[1,2,2],[1,2,3]].",
                              "finalVerifications": [
                                "Matriz é simétrica (G = G^T).",
                                "Dimensionalidade exata n x n.",
                                "Elementos diagonais positivos.",
                                "Todos G_ij coincidem com <vi,vj> recalculados.",
                                "Traço(G) = soma ||vi||^2.",
                                "Sem erros aritméticos em pelo menos 80% dos elementos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de produtos internos (100% correto).",
                                "Correta identificação de n e dimensionalidade.",
                                "Manutenção da simetria na matriz.",
                                "Verificações finais documentadas.",
                                "Eficiência: cálculos otimizados (i<=j).",
                                "Clareza na apresentação da matriz."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Extensão para autovalores da matriz de Gram.",
                                "Programação: Implementar em Python/NumPy com np.dot().",
                                "Física: Produtos escalares em mecânica vetorial.",
                                "Engenharia Computacional: Pré-condicionadores em solvers lineares."
                              ],
                              "realWorldApplication": "Em engenharia civil, a matriz de Gram é construída explicitamente para ortogonalizar vetores de deslocamentos nodais em métodos de elementos finitos, garantindo bases ortonormais para análise modal de estruturas, como pontes ou edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Implementar em pseudocódigo",
                            "description": "Escrever pseudocódigo ou código MATLAB simples para gerar a matriz de Gram a partir de uma matriz de vetores colunares V, usando G = V' * V ou equivalente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Requisitos da Matriz de Gram",
                                  "subSteps": [
                                    "Revise a definição matemática: a matriz de Gram G é definida como G = V^T * V, onde V é uma matriz m x n com n vetores colunares unitários ou não.",
                                    "Identifique as dimensões: V (m x n) resulta em G (n x n), simétrica e positiva semidefinida.",
                                    "Analise a notação em pseudocódigo: usar ' ou transpose() para transposição, e * para multiplicação matricial.",
                                    "Defina suposições: V é entrada válida, m >= n, sem verificações de erro avançadas."
                                  ],
                                  "verification": "Explique oralmente ou por escrito as dimensões de G e o significado de V^T * V.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas de aula sobre matriz de Gram",
                                    "Documentação básica de álgebra linear",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Visualize V como colunas sendo vetores; G_ij é produto escalar entre coluna i e j.",
                                  "learningObjective": "Dominar o conceito matemático e notacional para implementação precisa.",
                                  "commonMistakes": [
                                    "Confundir V como matriz de linhas em vez de colunas",
                                    "Ignorar que G é simétrica",
                                    "Esquecer dimensões de saída"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Estruturas de Dados e Inicializações no Pseudocódigo",
                                  "subSteps": [
                                    "Declare a variável de entrada V como matriz 2D (ex: input V[m][n]).",
                                    "Detecte ou assuma dimensões: m = rows(V), n = cols(V).",
                                    "Inicialize G como matriz n x n zerada (ex: G = zeros(n, n)).",
                                    "Planeje computação de VT como transposição de V (n x m)."
                                  ],
                                  "verification": "Esboço escrito das declarações com dimensões corretas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel ou editor de pseudocódigo",
                                    "Exemplo simples de matriz V 3x2"
                                  ],
                                  "tips": "Use pseudocódigo genérico como 'V = input_matrix()' para portabilidade.",
                                  "learningObjective": "Estruturar dados corretamente para operações matriciais eficientes.",
                                  "commonMistakes": [
                                    "Declarar G com dimensões erradas (ex: m x m)",
                                    "Não inicializar G",
                                    "Assumir V quadrada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Computação da Transposição e Multiplicação",
                                  "subSteps": [
                                    "Escreva VT = transpose(V) ou V' para obter a matriz transposta.",
                                    "Implemente G = matrix_multiply(VT, V) ou diretamente G = V' * V.",
                                    "Para clareza, opcionalmente use loops duplos: for i=1 to n, for j=1 to n, G[i][j] = dot(V[:,i], V[:,j]).",
                                    "Garanta que a sintaxe seja legível e similar a MATLAB."
                                  ],
                                  "verification": "Pseudocódigo executável manualmente com exemplo pequeno sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora matricial online ou MATLAB trial",
                                    "Pseudocódigo template"
                                  ],
                                  "tips": "Prefira notação vetorial compacta G = V' * V para simplicidade, fallback para loops se necessário.",
                                  "learningObjective": "Traduzir operação matemática em instruções computacionais acionáveis.",
                                  "commonMistakes": [
                                    "Usar V * V em vez de V' * V",
                                    "Erro em índices de loop (0 vs 1-based)",
                                    "Confundir multiplicação escalar com matricial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Verificar e Refinar o Pseudocódigo",
                                  "subSteps": [
                                    "Teste com V exemplo: V = [[1,2],[3,4],[5,6]]; espere G = [[35,44],[44,56]].",
                                    "Verifique propriedades: G simétrica, diagonal = ||coluna||^2.",
                                    "Corrija erros, adicione comentários explicativos.",
                                    "Documente saída: display(G)."
                                  ],
                                  "verification": "Execução manual ou simulação produz G correto e propriedades validadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo numérico impresso",
                                    "Ferramenta de validação como Octave online"
                                  ],
                                  "tips": "Sempre teste com caso 2x2 primeiro para depuração rápida.",
                                  "learningObjective": "Garantir robustez e correção através de validação prática.",
                                  "commonMistakes": [
                                    "Não verificar simetria",
                                    "Ignorar casos m < n",
                                    "Erros de arredondamento em testes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Finalizar e Documentar o Pseudocódigo Completo",
                                  "subSteps": [
                                    "Compile o pseudocódigo full: inputs, computação, output.",
                                    "Adicione comentários para cada linha chave.",
                                    "Opcional: adapte para MATLAB syntax exata.",
                                    "Salve como snippet reutilizável."
                                  ],
                                  "verification": "Pseudocódigo legível, comentado e testado em pelo menos 2 exemplos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Guia de estilo pseudocódigo"
                                  ],
                                  "tips": "Use blocos maiúsculos para estruturas (IF, FOR) para clareza.",
                                  "learningObjective": "Produzir código profissional, documentado e pronto para uso.",
                                  "commonMistakes": [
                                    "Falta de comentários",
                                    "Sintaxe inconsistente",
                                    "Não testar múltiplos casos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para V = [[1, 2], [3, 4], [5, 6]] (3x2 matriz com colunas v1=[1;3;5], v2=[2;4;6]):\nPseudocódigo:\nV = input(3x2)\nVT = transpose(V)  // 2x3\nG = VT * V  // 2x2\n// Resultado: G = [[1+9+25, 2+12+30], [2+12+30, 4+16+36]] = [[35,44],[44,56]]\nVerificação: G(1,1)=||v1||^2=35, simétrica.",
                              "finalVerifications": [
                                "Pseudocódigo produz matriz G de dimensões n x n correta.",
                                "G é simétrica: G = G^T dentro de tolerância numérica.",
                                "Elementos diagonais iguais às normas ao quadrado das colunas de V.",
                                "Testado com pelo menos dois exemplos numéricos (pequeno e médio).",
                                "Sem erros de sintaxe ou lógica em simulação manual.",
                                "Comentários explicam transposição e multiplicação.",
                                "Adaptável diretamente para MATLAB sem mudanças."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: uso preciso de V^T * V.",
                                "Clareza e legibilidade: pseudocódigo indentado e comentado.",
                                "Eficiência: preferência por multiplicação matricial vetorial sobre loops.",
                                "Validação: inclusão de testes e verificações de propriedades.",
                                "Generalidade: funciona para qualquer m >= n válida.",
                                "Documentação: objetivos e suposições explicitados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: produto escalar e propriedades de Gram.",
                                "Programação Computacional: manipulação de arrays multidimensionais em MATLAB/Python.",
                                "Engenharia Civil: condicionamento em análise estrutural e FEM.",
                                "Matemática Numérica: estabilidade em decomposições QR/PCA.",
                                "Física: projeções ortogonais em mecânica dos sólidos."
                              ],
                              "realWorldApplication": "Em engenharia civil, a matriz de Gram é essencial para análise modal de estruturas (ex: vibrações em pontes), condicionamento de sistemas em simulações FEM no MATLAB, e otimização de bases de vetores em modelagem de cargas sísmicas, melhorando precisão numérica em softwares como ANSYS ou custom scripts."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Propriedades de Simetria e Semi-definida Positiva",
                        "description": "Análise das propriedades intrínsecas da matriz de Gram, incluindo simetria e semi-definida positiva, e suas implicações no condicionamento numérico.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Demonstrar simetria",
                            "description": "Provar que G é simétrica (G_ij = G_ji) devido à simetria do produto interno, e verificar numericamente em exemplos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição da Matriz de Gram e Propriedades do Produto Interno",
                                  "subSteps": [
                                    "Defina a matriz de Gram G para um conjunto de vetores {v1, v2, ..., vn} como G_ij = <vi, vj>, onde < , > é o produto interno.",
                                    "Liste as propriedades bilineares do produto interno: simetria (<u,v> = <v,u>), linearidade e definitude positiva.",
                                    "Explique por que a simetria do produto interno é fundamental para a estrutura da matriz G.",
                                    "Esboce uma matriz G de 2x2 para visualização inicial.",
                                    "Confirme que o produto interno é simétrico em espaços euclidianos reais."
                                  ],
                                  "verification": "Escreva as definições e propriedades em um papel ou documento, garantindo que a simetria esteja destacada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, caneta, livro-texto ou notas sobre álgebra linear.",
                                  "tips": "Use notação consistente: <vi, vj> para produto interno.",
                                  "learningObjective": "Compreender a base teórica que leva à simetria da matriz G.",
                                  "commonMistakes": "Confundir produto interno com produto escalar sem simetria em espaços complexos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar Analiticamente a Simetria de G",
                                  "subSteps": [
                                    "Considere elementos genéricos G_ij = <vi, vj> e G_ji = <vj, vi>.",
                                    "Aplique a propriedade de simetria do produto interno: <vi, vj> = <vj, vi>.",
                                    "Conclua que G_ij = G_ji para todo i, j.",
                                    "Estenda para i = j, mostrando que a diagonal é real e positiva.",
                                    "Discuta implicações: G é simétrica e hermitiana em casos reais."
                                  ],
                                  "verification": "Escreva a prova formal em duas linhas e verifique se não há suposições extras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, calculadora simbólica opcional (SymPy ou Mathematica).",
                                  "tips": "Mantenha a prova concisa, focando apenas na igualdade direta.",
                                  "learningObjective": "Dominar a prova teórica da simetria usando propriedades axiomáticas.",
                                  "commonMistakes": "Esquecer de considerar o caso i=j ou assumir simetria sem justificativa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Numericamente com um Exemplo Concreto",
                                  "subSteps": [
                                    "Escolha vetores simples em R^2: v1 = [1, 0], v2 = [1, 1].",
                                    "Calcule produtos internos: <v1,v1> = 1, <v1,v2> = 1, <v2,v1> = 1, <v2,v2> = 2.",
                                    "Construa a matriz G = [[1,1], [1,2]] e observe G12 = G21.",
                                    "Use software para confirmar: implemente em Python com NumPy.",
                                    "Teste com vetores normalizados para precisão numérica."
                                  ],
                                  "verification": "Gere a matriz e confirme que é simétrica com tolerância de 1e-10.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy (ou MATLAB), computador.",
                                  "tips": "Sempre imprima a matriz com formatação para visualizar simetria.",
                                  "learningObjective": "Aplicar a teoria em cálculo numérico para validação.",
                                  "commonMistakes": "Erros de arredondamento; use np.dot() corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Generalizar a Simetria",
                                  "subSteps": [
                                    "Verifique simetria em um exemplo 3x3 com vetores de engenharia civil (ex: deslocamentos nodais).",
                                    "Discuta impacto na condicionamento: simetria facilita decomposições (Cholesky).",
                                    "Compare com matrizes não-simétricas e suas desvantagens computacionais.",
                                    "Resuma a prova e exemplo em um relatório curto.",
                                    "Teste robustez com vetores colineares."
                                  ],
                                  "verification": "Confirme simetria em múltiplos exemplos e anote observações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de álgebra linear, exemplos de vetores estruturais.",
                                  "tips": "Use transpose() no software para checagem rápida: G == G.T.",
                                  "learningObjective": "Conectar simetria a aplicações computacionais em engenharia.",
                                  "commonMistakes": "Ignorar efeitos numéricos em grandes matrizes."
                                }
                              ],
                              "practicalExample": "Em análise de estruturas civis, considere vetores de deslocamentos nodais v1=[1,0,0], v2=[0.5,1,0]. Calcule G: <v1,v1>=1, <v1,v2>=0.5, <v2,v1>=0.5, <v2,v2>=1.25. Matriz G=[[1,0.5],[0.5,1.25]] é simétrica, confirmando rigidificação simétrica.",
                              "finalVerifications": [
                                "G_ij = G_ji para todos i,j em prova analítica.",
                                "Matriz numérica satisfaz G == G.T com tolerância numérica.",
                                "Diagonal de G é positiva para vetores linearmente independentes.",
                                "Código Python/MATLAB reproduz simetria sem erros.",
                                "Exemplo de engenharia civil valida propriedade.",
                                "Prova cobre casos i=j e i≠j."
                              ],
                              "assessmentCriteria": [
                                "Clareza e correção da prova analítica (30%).",
                                "Precisão dos cálculos numéricos e código (25%).",
                                "Profundidade dos subpassos e verificações (20%).",
                                "Conexão com contexto de engenharia civil (15%).",
                                "Identificação de erros comuns e tips aplicados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Produto interno em mecânica vetorial e energia cinética.",
                                "Computação: Algoritmos de decomposição simétrica (LDL^T) em solvers.",
                                "Matemática: Teoria de autovalores para semi-definida positiva.",
                                "Engenharia Mecânica: Análise modal de estruturas vibrantes."
                              ],
                              "realWorldApplication": "Na engenharia civil, matrizes de Gram simétricas surgem em métodos de elementos finitos para análise estática de pontes e edifícios, permitindo solvers eficientes como Cholesky, reduzindo tempo computacional em simulações de condicionamento estrutural."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Verificar semi-definida positiva",
                            "description": "Mostrar que todos os autovalores de G são não-negativos (x^T G x = ||P x||^2 >= 0, onde P é a projeção), e calcular autovalores para confirmação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais",
                                  "subSteps": [
                                    "Relembre a definição de Matriz de Gram G para um conjunto de vetores {v1, ..., vn}: G_ij = <vi, vj>.",
                                    "Defina matriz semi-definida positiva: todos autovalores λ ≥ 0 ou x^T G x ≥ 0 para todo x.",
                                    "Entenda a interpretação geométrica: G representa inner products no span dos vetores.",
                                    "Esboce um exemplo simples com 2 vetores em R^2 para visualização.",
                                    "Confirme que G é simétrica por propriedades de inner product."
                                  ],
                                  "verification": "Liste definições corretas e exemplo esboçado sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Caderno, lápis, calculadora básica",
                                  "tips": "Use notação consistente para inner product < , >.",
                                  "learningObjective": "Compreender as bases teóricas da Matriz de Gram e semi-definidade positiva.",
                                  "commonMistakes": "Confundir Gram com matriz de covariância; ignorar simetria."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar x^T G x ≥ 0",
                                  "subSteps": [
                                    "Expanda x^T G x = sum_{i,j} x_i x_j <vi, vj> = <sum x_i vi, sum x_j vj> = ||P x||^2, onde P x = sum x_i vi.",
                                    "Note que ||P x||^2 ≥ 0 para qualquer x, pois norma ao quadrado é não-negativa.",
                                    "Conclua que G é semi-definida positiva pela forma quadrática.",
                                    "Teste com vetor x unitário para verificar numericamente.",
                                    "Discuta igualdade a zero quando x está no kernel (linearmente dependente)."
                                  ],
                                  "verification": "Derivação escrita completa e teste numérico com resultado ≥0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Caderno, software como Python (NumPy) para inner products",
                                  "tips": "Visualize P x como combinação linear no subespaço spanned pelos vi.",
                                  "learningObjective": "Derivar e provar a propriedade semi-definida positiva via norma.",
                                  "commonMistakes": "Esquecer o sinal positivo na norma; confundir P x com x."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Autovalores de G",
                                  "subSteps": [
                                    "Escolha um exemplo concreto: vetores v1 = [1,0], v2 = [1,1] em R^2.",
                                    "Construa G = [[<v1,v1>, <v1,v2>], [<v2,v1>, <v2,v2>]] = [[1,1],[1,2]].",
                                    "Resolva det(G - λI) = 0 para autovalores: λ^2 - 3λ +1 =0 → λ=(3±√5)/2 >0.",
                                    "Calcule autovetores para confirmação (opcional).",
                                    "Generalize: autovalores de G são não-negativos por construção."
                                  ],
                                  "verification": "Autovalores calculados corretamente e todos ≥0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora gráfica ou Python/MATLAB para eigenvals",
                                  "tips": "Use sympy para soluções exatas em Python.",
                                  "learningObjective": "Computar autovalores explicitamente para validar a propriedade.",
                                  "commonMistakes": "Erro em cálculo de determinante; assumir autovalores negativos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Sintetizar",
                                  "subSteps": [
                                    "Teste x^T G x para múltiplos x aleatórios e confirme ≥0.",
                                    "Compare autovalores com prova teórica.",
                                    "Discuta implicações: G usada em mínimos quadrados sem penalidade negativa.",
                                    "Resuma prova em 3 bullet points.",
                                    "Identifique casos onde G é definida positiva (autovalores >0)."
                                  ],
                                  "verification": "Testes numéricos passam e resumo correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software NumPy para testes múltiplos",
                                  "tips": "Gere x randômicos para robustez.",
                                  "learningObjective": "Consolidar verificação teórica e numérica.",
                                  "commonMistakes": "Testar apenas x com x^T G x =0; ignorar degenerescência."
                                }
                              ],
                              "practicalExample": "Para v1=[1,0], v2=[1,1], G=[[1,1],[1,2]]. Autovalores ≈0.382, 2.618 (ambos >0). Para x=[1,1], x^T G x = ||[2,1]||^2=5>0.",
                              "finalVerifications": [
                                "Todos autovalores calculados ≥0.",
                                "x^T G x ≥0 para 5 vetores x teste.",
                                "Derivação de ||P x||^2 completa e correta.",
                                "Exemplo numérico consistente com teoria.",
                                "Resumo da prova em termos claros.",
                                "Identificação correta de kernel se aplicável."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação teórica (30%).",
                                "Correção dos cálculos de autovalores (25%).",
                                "Qualidade dos testes numéricos (20%).",
                                "Clareza na explicação e resumo (15%).",
                                "Uso correto de notação matemática (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Energia cinética em bases não-ortogonais (forma quadrática positiva).",
                                "Otimização: Hessiana semi-definida em problemas de mínimos quadrados.",
                                "Estatística: Matriz de covariância em PCA (autovalores não-negativos).",
                                "Informática: Algoritmos de SVD para Gram matrices."
                              ],
                              "realWorldApplication": "Em engenharia civil, matrizes de Gram surgem em análise finita de elementos (rigidez em bases oblíquas), garantindo estabilidade numérica em solvers de sistemas lineares para simulações estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Relacionar com condicionamento",
                            "description": "Explicar como propriedades da Gram impactam o número de condicionamento κ(G) = λ_max / λ_min, relevante para estabilidade em soluções computacionais de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar propriedades fundamentais da Matriz de Gram",
                                  "subSteps": [
                                    "Defina a Matriz de Gram G = A^T A, onde A é a matriz cujas colunas são vetores base.",
                                    "Explique a propriedade de simetria: prove que G^T = G.",
                                    "Demonstre que G é semi-definida positiva (SDP): para qualquer vetor x ≠ 0, x^T G x ≥ 0.",
                                    "Liste consequências: autovalores reais e não-negativos.",
                                    "Discuta rank(G) ≤ rank(A) e nulidade."
                                  ],
                                  "verification": "Resuma as três propriedades principais (simetria, SDP, autovalores) em uma tabela comparativa.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang), MATLAB ou Python (NumPy) para exemplos",
                                    "Folha de papel para provas"
                                  ],
                                  "tips": "Use vetores simples em R^2 para visualizar simetria e SDP.",
                                  "learningObjective": "Compreender como simetria e SDP garantem autovalores reais e não-negativos.",
                                  "commonMistakes": [
                                    "Confundir Gram com A A^T",
                                    "Ignorar que autovalores podem ser zero se rank < n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir autovalores e o número de condicionamento κ(G)",
                                  "subSteps": [
                                    "Defina autovalores λ de G: resolva det(G - λI) = 0.",
                                    "Identifique λ_max (maior autovalore) e λ_min (menor autovalor positivo).",
                                    "Formule o número de condicionamento κ(G) = λ_max / λ_min.",
                                    "Explique que κ(G) ≥ 1, e κ=1 se G é múltiplo da identidade.",
                                    "Calcule κ para uma Gram diagonal simples."
                                  ],
                                  "verification": "Calcule autovalores e κ para uma matriz 2x2 simétrica SDP fornecida.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Calculadora ou software (MATLAB eig(), numpy.linalg.eig)",
                                    "Exemplos de matrizes pré-definidas"
                                  ],
                                  "tips": "Ordene autovalores em ordem decrescente para identificar max/min facilmente.",
                                  "learningObjective": "Dominar a definição e cálculo de κ(G) via autovalores.",
                                  "commonMistakes": [
                                    "Usar norma 2 em vez de autovalores para κ",
                                    "Incluir λ=0 no λ_min se singular"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar impacto das propriedades da Gram no condicionamento",
                                  "subSteps": [
                                    "Explique como simetria garante autovalores reais (sem parte imaginária).",
                                    "Discuta como SDP força λ ≥ 0, evitando λ_min negativo que pioraria κ.",
                                    "Relacione ângulos entre vetores de A: vetores ortogonais → G diagonal → baixo κ.",
                                    "Mostre que vetores quase colineares → λ_max >> λ_min → alto κ.",
                                    "Compare com matrizes não-simétricas ou indefinidas."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que propriedades de G melhoram estabilidade vs. matrizes gerais.",
                                  "estimatedTime": "40 min",
                                  "materials": [
                                    "Gráficos de autovalores para diferentes configurações de vetores",
                                    "Software para plotar espectro"
                                  ],
                                  "tips": "Visualize com plot de autovalores em escala log para ver spread.",
                                  "learningObjective": "Conectar propriedades espectrais de G diretamente a κ(G).",
                                  "commonMistakes": [
                                    "Atribuir baixo κ só à simetria, ignorando ortogonalidade",
                                    "Confundir κ com trace ou det"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar relevância para estabilidade em soluções computacionais",
                                  "subSteps": [
                                    "Descreva problemas em engenharia civil: resolver G x = b em otimização ou FEM.",
                                    "Explique amplificação de erros: ||δx|| / ||x|| ≤ κ(G) ||δb|| / ||b||.",
                                    "Discuta ill-conditioning: κ > 10^6 causa falha numérica em ponto flutuante.",
                                    "Sugira mitigação: pré-condicionadores ou bases ortogonais.",
                                    "Simule numericamente um caso com alto vs. baixo κ."
                                  ],
                                  "verification": "Simule e compare resíduos de solução para G bem/mal condicionada.",
                                  "estimatedTime": "50 min",
                                  "materials": [
                                    "Python/MATLAB script para solver com ruído",
                                    "Dados de exemplo de viga em FEM"
                                  ],
                                  "tips": "Adicione ruído gaussiano pequeno a b e meça erro relativo em x.",
                                  "learningObjective": "Aplicar conceito de condicionamento a estabilidade numérica real.",
                                  "commonMistakes": [
                                    "Ignorar precisão de máquina (eps ~1e-16)",
                                    "Usar solver exato em vez de iterativo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar com exemplo integrado e síntese",
                                  "subSteps": [
                                    "Construa G para vetores de deslocamentos em uma treliça simples.",
                                    "Calcule autovalores, κ e avalie estabilidade.",
                                    "Modifique vetores para piorar/melhorar condicionamento e reavalie.",
                                    "Sintetize: 'Propriedades de G controlam spread de λ, assim κ e estabilidade'.",
                                    "Registre insights em um relatório curto."
                                  ],
                                  "verification": "Produza relatório com cálculos, κ valores e conclusões sobre impacto.",
                                  "estimatedTime": "35 min",
                                  "materials": [
                                    "Exemplo de treliça 2D com coordenadas",
                                    "Solver numérico"
                                  ],
                                  "tips": "Escolha vetores quase paralelos para demonstrar alto κ dramaticamente.",
                                  "learningObjective": "Integrar todos conceitos em análise prática.",
                                  "commonMistakes": [
                                    "Erros de arredondamento em eig sem usar eigvals precisos",
                                    "Não normalizar vetores"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma treliça simples com dois elementos: vetores de rigidez A = [v1, v2] onde v1 = [1, 0]^T, v2 = [1, 0.01]^T (quase colineares). Compute G = A^T A, autovalores ≈ [2, 0.0001], κ ≈ 20000. Resolva G x = b com b ruidoso; erro amplificado prova instabilidade. Ortogonalize v2 → κ=1, erro mínimo.",
                              "finalVerifications": [
                                "Calcule corretamente κ(G) para Gram 3x3 dada.",
                                "Explique verbalmente como SDP afeta λ_min.",
                                "Identifique causa de alto κ em exemplo de vetores colineares.",
                                "Simule erro amplificado em solver com κ>10^4.",
                                "Proponha uma melhoria (ex: QR para ortogonalizar).",
                                "Resuma impacto em estabilidade FEM."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de propriedades de G (simetria/SDP): 20%.",
                                "Correção no cálculo de autovalores e κ: 25%.",
                                "Profundidade na análise de impacto em λ_max/λ_min: 20%.",
                                "Clareza na explicação de estabilidade numérica: 20%.",
                                "Qualidade do exemplo prático e simulação: 15%."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Teoria espectral e decomposição.",
                                "Análise Numérica: Condicionamento e estabilidade de algoritmos.",
                                "Engenharia Civil: Modelagem FEM e análise estrutural.",
                                "Computação Científica: Implementação em Python/MATLAB.",
                                "Física: Princípios de rigidez e equilíbrio em estruturas."
                              ],
                              "realWorldApplication": "Em simulações FEM para pontes ou edifícios, uma Matriz de Gram mal condicionada (devido a malha distorcida) causa erros acumulados em predições de tensões, levando a projetos inseguros ou recalls caros; engenheiros usam κ para validar meshes antes de otimização."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Processo de Ortogonalização de Gram-Schmidt",
                    "description": "Aplicação da matriz de Gram no algoritmo de Gram-Schmidt para gerar bases ortogonais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Matriz de Gram",
                        "description": "A matriz de Gram é uma matriz simétrica positiva definida construída a partir de um conjunto de vetores linearmente independentes, definida como G = AᵀA, onde A é a matriz cujas colunas são os vetores da base. Ela captura os produtos internos entre os vetores e é fundamental para avaliar o condicionamento e aplicar o processo de Gram-Schmidt.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Calcular a matriz de Gram para um conjunto de vetores",
                            "description": "Dado um conjunto de vetores linearmente independentes em ℝⁿ, computar a matriz G cujas entradas g_{ij} = <v_i, v_j>, o produto interno escalar entre v_i e v_j, e verificar sua simetria e positividade definida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o conjunto de vetores e revisar o produto interno",
                                  "subSteps": [
                                    "Liste os vetores linearmente independentes em ℝⁿ, representando-os como colunas de uma matriz V (m vetores, n dimensões).",
                                    "Confirme a linear independência básica (ex: rank(V) = m).",
                                    "Defina o produto interno padrão: <u, v> = Σ u_i * v_i para i=1 a n.",
                                    "Padronize a notação: v_1, v_2, ..., v_m."
                                  ],
                                  "verification": "Vetores listados em matriz V com dimensões claras e produto interno definido por escrito.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Matriz de vetores impressa ou digital"
                                  ],
                                  "tips": "Use vetores coluna para consistência com notação matricial.",
                                  "learningObjective": "Identificar e preparar corretamente os insumos para o cálculo da matriz de Gram.",
                                  "commonMistakes": [
                                    "Usar produto vetorial em vez de escalar.",
                                    "Esquecer de verificar linear independência inicial.",
                                    "Representar vetores como linhas inconsistemente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os elementos da diagonal principal",
                                  "subSteps": [
                                    "Para cada i=1 a m, calcule g_{ii} = <v_i, v_i> = ||v_i||² = Σ (v_i_k)² para k=1 a n.",
                                    "Registre cada norma ao quadrado com precisão decimal.",
                                    "Verifique que todos g_{ii} > 0 (devido à independência).",
                                    "Anote em uma tabela diagonal preliminar.",
                                    "Use fórmula expandida para vetores pequenos."
                                  ],
                                  "verification": "Todos g_{ii} calculados e positivos, listados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha Excel ou Python para soma de quadrados (opcional)"
                                  ],
                                  "tips": "Calcule manualmente para n≤3 para prática; automatize para n maior.",
                                  "learningObjective": "Dominar o cálculo das normas ao quadrado como base para positividade.",
                                  "commonMistakes": [
                                    "Erro aritmético em somas de quadrados.",
                                    "Confundir com norma euclidiana (esquecer o quadrado).",
                                    "g_{ii}=0 indicando dependência."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os elementos off-diagonal (parte superior)",
                                  "subSteps": [
                                    "Para cada i < j, calcule g_{ij} = <v_i, v_j> = Σ v_i_k * v_j_k para k=1 a n.",
                                    "Preencha a triangular superior da matriz.",
                                    "Use propriedades: g_{ji} = g_{ij} para simetria automática.",
                                    "Verifique cálculos cruzados com um exemplo aleatório.",
                                    "Registre com 4 casas decimais para precisão."
                                  ],
                                  "verification": "Triangular superior preenchida com produtos internos corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabela de vetores"
                                  ],
                                  "tips": "Aproveite simetria para evitar recálculos desnecessários.",
                                  "learningObjective": "Aplicar produto interno entre vetores distintos para simetria.",
                                  "commonMistakes": [
                                    "Erro no índice de soma (off-by-one).",
                                    "Não usar simetria, duplicando trabalho.",
                                    "Confundir v_i com v_j nos termos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a matriz completa e verificar simetria",
                                  "subSteps": [
                                    "Monte a matriz G m x m preenchendo g_{ji} = g_{ij} para i > j.",
                                    "Verifique simetria: G = G^T, checando g_{ij} == g_{ji} para todos i≠j.",
                                    "Calcule traço(G) = Σ g_{ii} > 0.",
                                    "Escreva G explicitamente.",
                                    "Confirme dimensões m x m."
                                  ],
                                  "verification": "Matriz G simétrica escrita e traço positivo confirmado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de matriz como MATLAB (opcional)"
                                  ],
                                  "tips": "Transponha mentalmente para checagem rápida de simetria.",
                                  "learningObjective": "Construir e validar a simetria inerente da matriz de Gram.",
                                  "commonMistakes": [
                                    "Erro de transposição ao copiar off-diagonal.",
                                    "Esquecer de preencher inferior.",
                                    "Dimensões erradas (confundir m com n)."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar positividade definida",
                                  "subSteps": [
                                    "Calcule todos os menores principais: det(G_k) > 0 para k=1 a m (G_k = submatriz kxk superior esquerda).",
                                    "Para m=2: verifique g11>0 e det(G)>0.",
                                    "Teste quadratic form: para x≠0, x^T G x >0 (ex: x=e_i, dá g_{ii}>0).",
                                    "Use Cholesky ou autovalores se ferramentas disponíveis.",
                                    "Conclua com base na independência linear."
                                  ],
                                  "verification": "Todos menores principais positivos confirmados por cálculo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para determinantes",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Comece com menores 1x1 e 2x2; use Sylvester para geral.",
                                  "learningObjective": "Validar positividade definida essencial para aplicações numéricas.",
                                  "commonMistakes": [
                                    "Erro em cálculo de determinante.",
                                    "Confundir semi-definida com definida.",
                                    "Ignorar último menor principal."
                                  ]
                                }
                              ],
                              "practicalExample": "Para v1 = [1, 0]^T, v2 = [1, 1]^T em ℝ²: g11 = <v1,v1> = 1, g12 = <v1,v2> = 1, g21=1, g22=2. G = [[1,1],[1,2]]. Simetria: sim. Positividade: g11=1>0, det(G)=1>0.",
                              "finalVerifications": [
                                "Matriz G é simétrica (g_{ij} = g_{ji} para todo i,j).",
                                "Todos elementos diagonais g_{ii} > 0.",
                                "Todos menores principais têm determinante positivo.",
                                "Traço(G) > 0.",
                                "Forma quadrática x^T G x > 0 para x unitário de teste.",
                                "Dimensões corretas: m x m onde m = número de vetores."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos produtos internos (erro < 0.01).",
                                "Correta verificação de simetria sem discrepâncias.",
                                "Cálculo completo e correto de menores principais.",
                                "Explicação clara da positividade definida.",
                                "Eficiência: aproveitamento da simetria para menos cálculos.",
                                "Apresentação organizada da matriz final."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: base para ortogonalização Gram-Schmidt.",
                                "Cálculo Numérico: condicionamento de matrizes em solvers lineares.",
                                "Programação: implementação em Python/NumPy para vetores grandes.",
                                "Física: produtos internos em mecânica vetorial e energia cinética.",
                                "Engenharia Civil: análise de estruturas via elementos finitos."
                              ],
                              "realWorldApplication": "Na engenharia civil, a matriz de Gram é crucial no processo de Gram-Schmidt para melhorar o condicionamento de matrizes de rigidez em simulações de elementos finitos, evitando instabilidades numéricas em análises estruturais de pontes e edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Interpretar propriedades da matriz de Gram",
                            "description": "Analisar as entradas diagonais (normas quadradas dos vetores) e extra-diagonais (projeções mútuas), relacionando-as ao ângulo entre vetores e ao condicionamento da base original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e construção da matriz de Gram",
                                  "subSteps": [
                                    "Lembre-se que a matriz de Gram G é definida como G_{ij} = <u_i, u_j> para uma base {u1, ..., un}.",
                                    "Calcule manualmente a matriz G para um conjunto simples de vetores em R^2.",
                                    "Identifique os elementos G_{ii} (diagonais) e G_{ij} (i≠j) extra-diagonais.",
                                    "Verifique a simetria de G (G = G^T) e sua positividade definida.",
                                    "Discuta o papel de G no processo de Gram-Schmidt."
                                  ],
                                  "verification": "Construa G corretamente para vetores dados e confirme simetria e positividade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Software como MATLAB ou Python (NumPy)"
                                  ],
                                  "tips": "Sempre normalize os vetores de entrada para facilitar cálculos iniciais.",
                                  "learningObjective": "Compreender a estrutura fundamental da matriz de Gram e suas propriedades básicas.",
                                  "commonMistakes": [
                                    "Confundir produto interno com produto escalar euclidiano",
                                    "Esquecer a simetria da matriz",
                                    "Não verificar positividade definida"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar elementos diagonais como normas quadradas",
                                  "subSteps": [
                                    "Calcule G_{ii} = ||u_i||^2 para cada vetor da base.",
                                    "Relacione G_{ii} com o comprimento do vetor u_i no espaço euclidiano.",
                                    "Compare normas entre vetores para avaliar escalas relativas na base.",
                                    "Discuta implicações para bases mal condicionadas (normas muito desiguais).",
                                    "Visualize geometricamente: vetores longos têm diagonais maiores."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que G_{11} representa a norma quadrada de u1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos vetoriais (software como GeoGebra)",
                                    "Exemplos numéricos impressos"
                                  ],
                                  "tips": "Use vetores unitários como benchmark para normas ideais iguais a 1.",
                                  "learningObjective": "Associar diagonais da matriz G às magnitudes dos vetores originais.",
                                  "commonMistakes": [
                                    "Interpretar G_{ii} como norma linear em vez de quadrada",
                                    "Ignorar unidades ou escalas nos vetores",
                                    "Confundir com autovalores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar elementos extra-diagonais como projeções mútuas e ângulos",
                                  "subSteps": [
                                    "Calcule G_{ij} = <u_i, u_j> = ||u_i|| ||u_j|| cos θ_{ij} para i≠j.",
                                    "Extraia o cosseno do ângulo θ_{ij} dividindo G_{ij} por sqrt(G_{ii} G_{jj}).",
                                    "Interprete valores: próximo de 0 (ortogonais), próximo de ±sqrt(G_{ii}G_{jj}) (alinhados).",
                                    "Calcule ângulos para todos pares e visualize em gráfico polar.",
                                    "Relacione projeções com o processo de Gram-Schmidt (subtração de projeções)."
                                  ],
                                  "verification": "Para uma G dada, compute corretamente todos os ângulos θ_{ij} e valide com produto escalar direto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou Python script para ângulos"
                                  ],
                                  "tips": "Sempre verifique se |G_{ij}| ≤ sqrt(G_{ii} G_{jj}) pela desigualdade de Cauchy-Schwarz.",
                                  "learningObjective": "Conectar extra-diagonais a medidas geométricas de não-ortogonalidade.",
                                  "commonMistakes": [
                                    "Esquecer o sinal do cosseno (projeções positivas/negativas)",
                                    "Dividir incorretamente para obter cos θ",
                                    "Ignorar normalização nas normas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar propriedades da matriz G ao condicionamento da base",
                                  "subSteps": [
                                    "Calcule o determinante det(G) e relacione com volume do paralelótopo formado pelos vetores.",
                                    "Estime o número de condição cond(G) ≈ cond(A)^2 onde A tem colunas u_i.",
                                    "Analise autovalores de G: pequenos indicam direções quase dependentes.",
                                    "Compare cond(G) alto (base mal condicionada) vs. baixo (quase ortonormal).",
                                    "Aplique em exemplo: base mal condicionada vs. boa."
                                  ],
                                  "verification": "Para uma base dada, compute cond(G) e explique impacto no condicionamento original.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software MATLAB/Python para autovalores e condição",
                                    "Tabela de exemplos de bases"
                                  ],
                                  "tips": "Use log(cond(G)) para escalas numéricas e evite overflow em normas grandes.",
                                  "learningObjective": "Integrar interpretações para avaliar estabilidade numérica da base.",
                                  "commonMistakes": [
                                    "Confundir cond(G) com cond da base original",
                                    "Ignorar que det(G)=0 implica dependência linear",
                                    "Não relacionar com estabilidade de Gram-Schmidt"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere vetores em R^2: u1 = [1, 0], u2 = [1, 1]. Então G = [[1, 1], [1, 2]]. Diagonais: ||u1||^2=1, ||u2||^2=2 (u2 mais longo). Extra-diagonais: <u1,u2>=1, cos θ = 1/sqrt(2) ≈ 0.707 (45°). cond(G) ≈ 2.618 (moderado), indicando base razoavelmente condicionada.",
                              "finalVerifications": [
                                "Explique corretamente o significado de um elemento diagonal grande.",
                                "Calcule ângulo entre dois vetores a partir de G_{ij} com precisão.",
                                "Identifique se extra-diagonais zero implicam ortogonalidade.",
                                "Avalie qualitativamente o condicionamento de uma G com autovalores 100 e 0.01.",
                                "Relacione det(G) baixo a dependência linear.",
                                "Aplique interpretação em uma matriz G 3x3 fornecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de normas, projeções e ângulos (erro <5%).",
                                "Correta associação de propriedades geométricas e algébricas.",
                                "Explicações claras relacionando G ao condicionamento.",
                                "Uso apropriado de desigualdades (Cauchy-Schwarz, etc.).",
                                "Identificação de implicações numéricas/estabilidade.",
                                "Visualizações ou exemplos concretos fornecidos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores e decomposição espectral de G.",
                                "Geometria Analítica: ângulos e volumes em espaços vetoriais.",
                                "Programação Numérica: implementação de Gram-Schmidt estável.",
                                "Física: produtos internos em mecânica vetorial (forças, momentos).",
                                "Otimização: análise de condicionamento em métodos de mínimos quadrados."
                              ],
                              "realWorldApplication": "Na engenharia civil, ao analisar elementos finitos para estruturas, a matriz de Gram avalia o condicionamento de bases de funções de forma, prevenindo erros numéricos em simulações de tensão/deformação em softwares como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Relacionar matriz de Gram com condicionamento",
                            "description": "Calcular o número de condicionamento cond(G) = ||G|| * ||G⁻¹|| e interpretá-lo como medida de quão 'mal-condicionada' está a base original, impactando a estabilidade numérica do Gram-Schmidt.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Número de Condicionamento de Matrizes",
                                  "subSteps": [
                                    "Revise a definição de norma de matriz (ex: norma espectral ||A||_2 = maior valor singular).",
                                    "Entenda a fórmula cond(A) = ||A|| * ||A^{-1}|| para matrizes invertíveis.",
                                    "Aprenda que cond(A) ≥ 1, e valores altos indicam ill-condicionamento.",
                                    "Discuta como o condicionamento afeta a sensibilidade a perturbações numéricas.",
                                    "Relacione com estabilidade: erros são amplificados por cond(A)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o significado de cond(G) > 10^6 como mal-condicionado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas sobre normas de matrizes",
                                    "Calculadora científica",
                                    "Software NumPy ou MATLAB"
                                  ],
                                  "tips": "Use norma 2 para condicionamento espectral, comum em análise numérica.",
                                  "learningObjective": "Definir e interpretar o número de condicionamento como medida de estabilidade numérica.",
                                  "commonMistakes": [
                                    "Confundir cond(A) com |det(A)|",
                                    "Ignorar que cond(A) é adimensional e sempre ≥1",
                                    "Usar norma errada (ex: norma 1 em vez de 2)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Matriz de Gram G a Partir de uma Base Vetorial",
                                  "subSteps": [
                                    "Dada uma base {v1, v2, ..., vn} em R^m, compute G_{ij} = <vi, vj> (produto interno).",
                                    "Verifique simetria e positiva definitude de G (G = V^T V, onde V tem colunas vi).",
                                    "Escolha uma base de exemplo: v1 = [1, 0]^T, v2 = [1, ε]^T com ε pequeno para ill-condicionamento.",
                                    "Calcule G explicitamente para n=2.",
                                    "Confirme que G é invertível se a base é linearmente independente."
                                  ],
                                  "verification": "Construa G corretamente para uma base dada e verifique G v = ||v||^2 v para autovetores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para cálculos manuais",
                                    "Python com NumPy para verificação"
                                  ],
                                  "tips": "Normalize vetores se necessário, mas foque em produtos internos escalares.",
                                  "learningObjective": "Construir G como representação quadrática da base original.",
                                  "commonMistakes": [
                                    "Erro em produto interno (ex: esquecer transposição)",
                                    "Assumir base ortonormal prematuramente",
                                    "Não verificar simetria de G"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular ||G||, ||G^{-1}|| e cond(G)",
                                  "subSteps": [
                                    "Compute G^{-1} analiticamente ou numericamente (ex: para 2x2, fórmula explícita).",
                                    "Calcule ||G||_2 (maior autovalor de G^* G, mas para simétrica é sqrt(maior autovalor)).",
                                    "Calcule ||G^{-1}||_2 similarmente.",
                                    "Multiplique para obter cond(G) = ||G||_2 * ||G^{-1}||_2.",
                                    "Compare com cond da base original via relação cond(G) ≈ [cond(V)]^2."
                                  ],
                                  "verification": "Para exemplo dado, cond(G) deve coincidir com cálculo numérico preciso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software computacional (NumPy.linalg.norm, inv)",
                                    "Tabela de autovalores"
                                  ],
                                  "tips": "Para normas exatas em 2D, use autovalores; evite aproximações grosseiras.",
                                  "learningObjective": "Executar cálculos precisos de cond(G) usando normas adequadas.",
                                  "commonMistakes": [
                                    "Erro na inversa (divisão por det=0)",
                                    "Usar norma Frobenius em vez de 2 para condicionamento",
                                    "Arredondamento prematuro em ε pequeno"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar cond(G) e sua Relação com Estabilidade do Gram-Schmidt",
                                  "subSteps": [
                                    "Analise: se cond(G) alto, base original mal-condicionada (vetores quase colineares).",
                                    "Relacione com Gram-Schmidt: processo amplifica erros por fator ~cond(G).",
                                    "Simule numericamente: aplique Gram-Schmidt com/ sem ruído e observe perda de ortogonalidade.",
                                    "Conclua que bases mal-condicionadas levam a instabilidade numérica no processo.",
                                    "Discuta mitigação: use QR Householder em vez de Gram-Schmidt clássico."
                                  ],
                                  "verification": "Interprete um cond(G)=10^8 como crítica para aplicações de precisão dupla.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python para simulação Gram-Schmidt",
                                    "Gráficos de resíduos de ortogonalidade"
                                  ],
                                  "tips": "Teste com ε=1e-10 para ver explosão de erros.",
                                  "learningObjective": "Vincular cond(G) à estabilidade prática do algoritmo Gram-Schmidt.",
                                  "commonMistakes": [
                                    "Ignorar amplificação quadrática cond(V)^2 ≈ cond(G)",
                                    "Confundir ill-condicionamento com singularidade",
                                    "Não considerar precisão de máquina finita"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere base em R^2: v1 = [1, 0]^T, v2 = [1, 1e-6]^T. Compute G = [[1, 1], [1, 1 + 1e-12]]. Aprox. autovalores λ1≈2, λ2≈1e-12, cond(G)≈2e12. Inverso amplifica erros; Gram-Schmidt clássico perde ortogonalidade devido a cancelamento.",
                              "finalVerifications": [
                                "Calcula corretamente cond(G) para base 2D/3D dada.",
                                "Identifica bases mal-condicionadas via cond(G)>10^6.",
                                "Simula e demonstra perda de ortogonalidade em Gram-Schmidt.",
                                "Explica impacto na estabilidade numérica.",
                                "Propõe alternativas como decomposição QR."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de G, G^{-1} e normas (erro <1e-10).",
                                "Interpretação qualitativa correta de cond(G) (alto=mal-condicionado).",
                                "Uso apropriado de norma 2 espectral.",
                                "Demonstração numérica de instabilidade via simulação.",
                                "Clareza na relação com Gram-Schmidt.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Autovalores e normas de matrizes.",
                                "Análise Numérica: Estabilidade de algoritmos e análise de erros.",
                                "Programação: Implementação em Python/NumPy de Gram-Schmidt e condicionamento.",
                                "Engenharia Computacional: Simulações em elementos finitos."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao modelar estruturas via métodos de elementos finitos, bases vetoriais mal-condicionadas (ex: malhas distorcidas) levam a erros amplificados no Gram-Schmidt para extração de modos vibracionais, comprometendo previsões de estabilidade; cond(G) guia refatoração da malha."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Processo de Ortogonalização de Gram-Schmidt",
                        "description": "Algoritmo clássico para ortogonalizar uma base {v₁, v₂, ..., vₖ} gerando {u₁, u₂, ..., uₖ} onde u₁ = v₁ e uⱼ = vⱼ - ∑_{i=1}^{j-1} proj_{u_i}(vⱼ), produzindo uma base ortogonal estável para problemas de engenharia civil como análise estrutural.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Executar o processo Gram-Schmidt manualmente",
                            "description": "Aplicar os passos iterativos do algoritmo a vetores em ℝ² ou ℝ³, computando projeções sucessivas e verificando ortogonalidade via produtos internos nulos entre u_i e u_j (i ≠ j).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os vetores iniciais e inicializar u1",
                                  "subSteps": [
                                    "Selecione um conjunto de vetores linearmente independentes v1, v2, ..., vn em ℝ² ou ℝ³.",
                                    "Defina u1 = v1.",
                                    "Calcule a norma ao quadrado ||u1||² = u1 · u1 para uso futuro.",
                                    "Verifique que u1 ≠ 0.",
                                    "Registre u1 e ||u1||² em uma tabela organizada."
                                  ],
                                  "verification": "Confirme que u1 = v1 e ||u1||² > 0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta",
                                    "Calculadora para produtos internos"
                                  ],
                                  "tips": "Sempre verifique a independência linear inicial para evitar divisões por zero posteriores.",
                                  "learningObjective": "Compreender a inicialização da base ortogonal com o primeiro vetor.",
                                  "commonMistakes": [
                                    "Assumir normalização prematura de u1",
                                    "Esquecer de calcular ||u1||² antecipadamente",
                                    "Usar vetores colineares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ortogonalizar o segundo vetor v2",
                                  "subSteps": [
                                    "Calcule o produto interno <v2, u1> = v2 · u1.",
                                    "Compute o coeficiente de projeção c1 = <v2, u1> / ||u1||².",
                                    "Calcule a projeção proj_u1 v2 = c1 * u1.",
                                    "Defina u2 = v2 - proj_u1 v2.",
                                    "Verifique preliminarmente que <u2, u1> = 0."
                                  ],
                                  "verification": "Confirme que u2 · u1 = 0 (dentro de tolerância numérica pequena).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Mantenha todos os cálculos com frações exatas quando possível para evitar erros de arredondamento.",
                                  "learningObjective": "Aplicar a fórmula de projeção para o segundo vetor e garantir ortogonalidade bipartida.",
                                  "commonMistakes": [
                                    "Inverter a ordem de v2 · u1",
                                    "Esquecer de dividir por ||u1||²",
                                    "Erro de sinal na subtração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ortogonalizar vetores subsequentes (v3 em diante para ℝ³)",
                                  "subSteps": [
                                    "Para vk (k ≥ 3), calcule <vk, ui> para cada i = 1 a k-1.",
                                    "Compute ci = <vk, ui> / ||ui||² para cada i.",
                                    "Calcule a projeção total proj_vk = sum_{i=1}^{k-1} ci * ui.",
                                    "Defina uk = vk - proj_vk.",
                                    "Verifique que <uk, ui> = 0 para todos i < k."
                                  ],
                                  "verification": "Todos os produtos internos <uk, ui> = 0 para i = 1 a k-1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta",
                                    "Calculadora",
                                    "Tabela para rastrear coeficientes"
                                  ],
                                  "tips": "Use uma tabela para rastrear todos os <vk, ui> e ci, facilitando somas múltiplas.",
                                  "learningObjective": "Generalizar o processo iterativo para dimensões superiores como ℝ³.",
                                  "commonMistakes": [
                                    "Esquecer uma projeção em somas múltiplas",
                                    "Usar ||uk|| em vez de ||ui||",
                                    "Erros de acumulação em somas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar ortogonalidade completa da base",
                                  "subSteps": [
                                    "Compute <ui, uj> para todos os pares i < j.",
                                    "Confirme que todos os produtos internos são zero.",
                                    "Verifique que nenhum uk = 0.",
                                    "Opcionalmente, confirme que det([u1 ... un]) ≠ 0 ou span preservado.",
                                    "Registre a base ortogonal final {u1, u2, ..., un}."
                                  ],
                                  "verification": "Matriz de produtos internos é diagonal (zeros off-diagonal).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Automatize verificações parciais em cada step para detectar erros cedo.",
                                  "learningObjective": "Validar a propriedade fundamental de ortogonalidade via produtos internos.",
                                  "commonMistakes": [
                                    "Pular verificações cruzadas entre não-adjacentes",
                                    "Tolerar não-zeros pequenos sem investigar",
                                    "Confundir ortogonalidade com normalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo em ℝ²: v1 = (3, 1), v2 = (1, 2). u1 = (3, 1), ||u1||² = 9 + 1 = 10. <v2, u1> = 3 + 2 = 5, c1 = 5/10 = 0.5, proj = 0.5*(3,1) = (1.5, 0.5), u2 = (1,2) - (1.5,0.5) = (-0.5, 1.5). Verificação: u1·u2 = 3*(-0.5) + 1*1.5 = -1.5 + 1.5 = 0. Para ℝ³, estenda iterativamente com v3.",
                              "finalVerifications": [
                                "Todos <ui, uj> = 0 para i ≠ j.",
                                "Nenhum vetor uk é o zero vector.",
                                "Base {u1, ..., un} spans o mesmo espaço que {v1, ..., vn}.",
                                "Cálculos exatos ou com erro numérico mínimo (<10^-6).",
                                "Processo iterativo completo sem omissões.",
                                "Ortogonalidade preservada em todas as dimensões."
                              ],
                              "assessmentCriteria": [
                                "Precisão aritmética em produtos internos e normas.",
                                "Correta aplicação iterativa das fórmulas de projeção.",
                                "Verificações explícitas e sistemáticas de ortogonalidade.",
                                "Eficiência e organização nos cálculos manuais.",
                                "Capacidade de generalizar para ℝ² e ℝ³.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Espaços vetoriais e bases ortogonais.",
                                "Cálculo Vetorial: Produtos internos e projeções.",
                                "Programação Numérica: Implementação de algoritmos em Python/MATLAB.",
                                "Engenharia Civil: Análise modal e decomposição em elementos finitos.",
                                "Física: Representação de forças ortogonais em mecânica estrutural."
                              ],
                              "realWorldApplication": "Em engenharia civil, o processo Gram-Schmidt é aplicado em soluções computacionais para ortogonalizar modos de vibração em análise dinâmica de estruturas, melhorando o condicionamento de matrizes de rigidez e acelerando simulações de elementos finitos em softwares como ANSYS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Normalizar a base ortogonal obtida",
                            "description": "Após ortogonalização, dividir cada u_i por sua norma euclidiana para obter uma base ortonormal, útil em métodos de resíduos ponderados e otimização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e listar a base ortogonal obtida",
                                  "subSteps": [
                                    "Identifique todos os vetores u_i da base ortogonal após o processo de Gram-Schmidt.",
                                    "Confirme que os vetores são ortogonais calculando produtos internos u_i · u_j = 0 para i ≠ j.",
                                    "Anote as dimensões do espaço vetorial (ex: R^n).",
                                    "Prepare uma tabela ou matriz para registrar normas e vetores normalizados.",
                                    "Verifique se nenhum vetor é o vetor nulo."
                                  ],
                                  "verification": "Todos os produtos internos entre vetores distintos são zero.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou software (Python/MATLAB)",
                                    "Base ortogonal de exemplo"
                                  ],
                                  "tips": "Use uma representação matricial para facilitar cálculos futuros.",
                                  "learningObjective": "Compreender a base ortogonal como pré-requisito para normalização.",
                                  "commonMistakes": "Confundir ortogonalidade com ortonormalidade; ignorar vetores nulos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a norma euclidiana de cada vetor u_i",
                                  "subSteps": [
                                    "Para cada u_i, compute ||u_i|| = sqrt(∑ (u_i,k)^2) onde k=1 a n.",
                                    "Calcule o quadrado da norma primeiro para evitar raízes prematuras.",
                                    "Registre ||u_i|| para todos os vetores em uma lista ou tabela.",
                                    "Use fórmula vetorial em software: np.linalg.norm(u_i) no NumPy.",
                                    "Arredonde apenas no final para precisão."
                                  ],
                                  "verification": "Normas calculadas são positivas e não-zero para cada vetor.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software NumPy ou MATLAB",
                                    "Folha de cálculos"
                                  ],
                                  "tips": "Norma zero indica erro na ortogonalização anterior; reinicie se ocorrer.",
                                  "learningObjective": "Dominar o cálculo da norma euclidiana em contextos multivariados.",
                                  "commonMistakes": "Esquecer raiz quadrada; usar norma L1 ou L-infinito por engano."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Normalizar cada vetor dividindo pela sua norma",
                                  "subSteps": [
                                    "Para cada i, compute q_i = u_i / ||u_i|| componente a componente.",
                                    "Multiplique cada entrada de u_i pelo escalar 1/||u_i||.",
                                    "Implemente em código: q_i = u_i / np.linalg.norm(u_i).",
                                    "Armazene os q_i em uma nova matriz Q.",
                                    "Confirme numericamente que ||q_i|| ≈ 1 para cada i."
                                  ],
                                  "verification": "Cada ||q_i|| = 1 com tolerância numérica de 10^-10.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de programação (Python com NumPy)",
                                    "Matriz de vetores u_i"
                                  ],
                                  "tips": "Use divisão escalar-vetor para eficiência computacional.",
                                  "learningObjective": "Aplicar escalonamento para obter vetores unitários.",
                                  "commonMistakes": "Dividir pela norma errada; propagar erros de arredondamento cedo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a ortonormalidade da base {q_i}",
                                  "subSteps": [
                                    "Calcule produtos internos q_i · q_j para todos i,j.",
                                    "Confirme q_i · q_j = 0 se i ≠ j e =1 se i=j.",
                                    "Verifique linear independência somando combinações.",
                                    "Teste em software com np.dot(q_i, q_j).",
                                    "Documente resultados em relatório."
                                  ],
                                  "verification": "Matriz de Gram dos q_i é a identidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software NumPy/MATLAB",
                                    "Matriz Q normalizada"
                                  ],
                                  "tips": "Use tolerâncias numéricas (ex: 1e-12) devido a erros de ponto flutuante.",
                                  "learningObjective": "Validar propriedades de bases ortonormais.",
                                  "commonMistakes": "Ignorar erros numéricos; assumir verificação sem cálculo explícito."
                                }
                              ],
                              "practicalExample": "Dada base ortogonal em R^2: u1 = [3, 0], u2 = [1, 2]. Normas: ||u1||=3, ||u2||=sqrt(5). Então q1 = [1, 0], q2 = [1/sqrt(5), 2/sqrt(5)]. Verifique: q1·q2=0, ||q1||=1, ||q2||=1. Útil para decomposição QR em análise estrutural.",
                              "finalVerifications": [
                                "Todos os ||q_i|| = 1.",
                                "q_i · q_j = 0 para i ≠ j.",
                                "Base {q_i} span o mesmo espaço que a original.",
                                "Matriz Q tem colunas ortonormais.",
                                "Nenhuma norma original era zero.",
                                "Resultados consistentes em software e manual."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de normas (erro < 1e-10).",
                                "Correta normalização componente a componente.",
                                "Verificação completa de ortonormalidade.",
                                "Eficiência no uso de ferramentas computacionais.",
                                "Identificação e correção de erros comuns.",
                                "Clareza na documentação dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição QR para autovalores.",
                                "Computação: Implementação numérica estável de Gram-Schmidt modificado.",
                                "Física: Vetores unitários em mecânica de estruturas.",
                                "Otimização: Bases ortonormais em métodos de gradiente conjugado."
                              ],
                              "realWorldApplication": "Em engenharia civil, normalizar bases ortogonais é essencial na decomposição QR para resolver sistemas lineares mal-condicionados em análise de elementos finitos de estruturas, métodos de resíduos ponderados para otimização de vigas e otimização em projetos de fundações."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Implementar pseudocódigo do Gram-Schmidt",
                            "description": "Escrever pseudocódigo para o algoritmo, incluindo loops para projeções e atualizações, considerando entradas como matriz A com colunas v_i e saída Q com colunas u_i normalizadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Estrutura de Entrada e Saída",
                                  "subSteps": [
                                    "Identifique a matriz de entrada A com colunas v1, v2, ..., vn como vetores coluna.",
                                    "Defina a matriz de saída Q com colunas u1, u2, ..., un ortonormais.",
                                    "Inicialize Q como uma matriz vazia ou cópia de A para modificação.",
                                    "Especifique tipos de dados: vetores como arrays ou listas de números reais.",
                                    "Adicione comentários explicando n = número de colunas de A."
                                  ],
                                  "verification": "Verifique se o pseudocódigo declara corretamente A (m x n), Q (m x n) e n.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Documentação do algoritmo Gram-Schmidt",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Use notação clara como A[:, i] para coluna i.",
                                  "learningObjective": "Compreender as representações matriciais dos vetores no processo.",
                                  "commonMistakes": [
                                    "Confundir linhas com colunas",
                                    "Não definir dimensões m x n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Cálculo do Primeiro Vetor u1",
                                  "subSteps": [
                                    "Calcule a norma euclidiana de v1: norm_v1 = sqrt(sum(v1[i]^2 for i=1 to m)).",
                                    "Defina u1 = v1 / norm_v1.",
                                    "Atribua a primeira coluna de Q como u1.",
                                    "Adicione verificação se norm_v1 != 0 para evitar divisão por zero.",
                                    "Inclua comentários sobre normalização."
                                  ],
                                  "verification": "Teste com vetor simples [3,4]; u1 deve ser [0.6, 0.8].",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy",
                                    "Exemplos de normas vetoriais"
                                  ],
                                  "tips": "Use função auxiliar para norma para reutilização.",
                                  "learningObjective": "Dominar normalização do primeiro vetor base.",
                                  "commonMistakes": [
                                    "Esquecer raiz quadrada na norma",
                                    "Dividir pela norma ao invés de vetor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Loop Principal para Projeções e Subtrações",
                                  "subSteps": [
                                    "Inicie loop for k = 2 to n.",
                                    "Para cada k, inicialize temp = vk.",
                                    "Para cada j = 1 to k-1, calcule proj = (temp · uj) * uj e subtraia: temp = temp - proj.",
                                    "Após subloop, calcule norma de temp e normalize: uk = temp / ||temp||.",
                                    "Atribua uk à coluna k de Q; verifique ||temp|| != 0."
                                  ],
                                  "verification": "Execute pseudocódigo manualmente com 3 vetores; verifique ortogonalidade Q^T Q ≈ I.",
                                  "estimatedTime": "40 min",
                                  "materials": [
                                    "Papel e lápis para simulação",
                                    "Matrizes de teste 3x3"
                                  ],
                                  "tips": "Aninhe loops com cuidado: outer k, inner j.",
                                  "learningObjective": "Implementar iterações de ortogonalização via projeções.",
                                  "commonMistakes": [
                                    "Índices errados em loops (off-by-one)",
                                    "Usar u_k em vez de u_j anterior"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar Verificações e Retorno Final",
                                  "subSteps": [
                                    "Após loop, verifique ortonormalidade: para i≠j, Q[:,i] · Q[:,j] ≈ 0; ||Q[:,i]|| ≈ 1.",
                                    "Retorne matriz Q completa.",
                                    "Inclua tratamento de erros: se vetor linearmente dependente, flag ou pare.",
                                    "Adicione comentários sobre estabilidade numérica (não modificar aqui).",
                                    "Teste com matriz identidade para Q identidade."
                                  ],
                                  "verification": "Pseudocódigo roda sem erros e produz Q ortonormal para input válido.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Implementação em Python/MATLAB para validar pseudocódigo"
                                  ],
                                  "tips": "Use tolerância epsilon=1e-10 para verificações.",
                                  "learningObjective": "Garantir robustez e corretude do algoritmo.",
                                  "commonMistakes": [
                                    "Não tratar dependência linear",
                                    "Esquecer verificações finais"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada matriz A = [[1,1],[0,1],[0,0]] (colunas v1=[1,0,0], v2=[1,1,0]), o pseudocódigo produz Q ≈ [[1,0,0],[0,1,0],[0,0,1]] após ortogonalização e normalização, demonstrando remoção de componente de v2 em v1.",
                              "finalVerifications": [
                                "Pseudocódigo compila logicamente sem erros de sintaxe ou loops infinitos.",
                                "Para input 3x3, Q tem colunas com norma 1.",
                                "Colunas de Q são ortogonais: produto escalar zero.",
                                "Preserva span: A = Q R para alguma R superior triangular.",
                                "Manipula casos de dependência linear graciosamente.",
                                "Tempo de execução O(m n^2) implícito nos loops."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de loops aninhados (proj e sub).",
                                "Correta implementação de norma e normalização.",
                                "Tratamento de divisões por zero.",
                                "Clareza e comentários no pseudocódigo.",
                                "Verificações de ortonormalidade incluídas.",
                                "Eficiência: evita computações desnecessárias."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Fundamento para decomposição QR.",
                                "Programação Computacional: Estruturas de loop e vetores em Engenharia.",
                                "Física: Ortogonalidade em bases de funções de onda.",
                                "Estatística: Regressão least-squares via QR.",
                                "Engenharia Civil: Análise modal de estruturas vibrantes."
                              ],
                              "realWorldApplication": "Na engenharia civil, o Gram-Schmidt é usado em decomposição QR para resolver sistemas lineares grandes em análise estrutural, como simular deformações em pontes sob cargas, melhorando condicionamento numérico e precisão em softwares como ANSYS ou MATLAB."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Aplicação da Matriz de Gram no Algoritmo de Gram-Schmidt",
                        "description": "Integração da matriz de Gram no processo para decomposição QR via fatorização de Cholesky (G = RᵀR), melhorando estabilidade numérica em implementações computacionais para problemas de valor inicial e de contorno em engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Usar fatorização de Cholesky da matriz de Gram",
                            "description": "Computar R = chol(G), onde G = AᵀA, e obter Q = A R⁻¹ para decomposição QR estável, evitando perdas de ortogonalidade no Gram-Schmidt clássico devido a erros de arredondamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular a Matriz de Gram G = Aᵀ A",
                                  "subSteps": [
                                    "Selecionar uma matriz A de dimensões m x n (m ≥ n, posto completo)",
                                    "Computar a transposição Aᵀ",
                                    "Realizar a multiplicação matricial G = Aᵀ × A",
                                    "Verificar se G é simétrica (G = Gᵀ) e definida positiva",
                                    "Armazenar G para uso subsequente"
                                  ],
                                  "verification": "Conferir se G é simétrica e todos os autovalores são positivos",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A de exemplo (ex: 3x2)",
                                    "Software como MATLAB, Python (NumPy) ou calculadora matricial"
                                  ],
                                  "tips": "Para matrizes grandes, sempre use software para evitar erros de cálculo manual",
                                  "learningObjective": "Compreender a construção da matriz de Gram e suas propriedades",
                                  "commonMistakes": [
                                    "Esquecer a transposição de A",
                                    "Erros na multiplicação matricial",
                                    "Não verificar positividade definida"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar Fatoração de Cholesky em G para obter R",
                                  "subSteps": [
                                    "Confirmar que G é simétrica positiva definida",
                                    "Inicializar matriz R triangular superior vazia do mesmo tamanho de G",
                                    "Para cada elemento diagonal i: r_{ii} = sqrt(g_{ii} - sum_{k=1}^{i-1} r_{ik}^2)",
                                    "Para elementos off-diagonal j > i: r_{ij} = (g_{ij} - sum_{k=1}^{i-1} r_{ik} r_{kj}) / r_{ii}",
                                    "Verificar numericamente G ≈ Rᵀ R"
                                  ],
                                  "verification": "Multiplicar Rᵀ × R e comparar com G (erro < 1e-10)",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz G computada",
                                    "Implementação de Cholesky em Python/MATLAB ou algoritmo manual para 2x2"
                                  ],
                                  "tips": "Use pivoteamento se necessário para estabilidade, mas Cholesky assume ordem boa",
                                  "learningObjective": "Dominar o algoritmo de Cholesky para fatorar matrizes Gram",
                                  "commonMistakes": [
                                    "Divisão por zero em diagonal (G não positiva definida)",
                                    "Erros de sinal no off-diagonal",
                                    "Arredondamento levando a perda de simetria"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar Q = A × R⁻¹",
                                  "subSteps": [
                                    "Resolver os sistemas R × Q_k = A_{:k} para cada coluna k de A (back-substitution)",
                                    "Alternativamente, calcular inverso de R e multiplicar Q = A × inv(R)",
                                    "Armazenar as colunas de Q como vetores ortonormais",
                                    "Verificar dimensionalidade: Q deve ser m x n",
                                    "Normalizar colunas se necessário para precisão"
                                  ],
                                  "verification": "Verificar se as colunas de Q têm norma unitária e são aproximadamente ortogonais",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A e R",
                                    "Solver de sistemas triangulares em software numérico"
                                  ],
                                  "tips": "Prefira back-substitution a inv(R) para evitar amplificação de erros",
                                  "learningObjective": "Aplicar resolução de sistemas triangulares para obter Q ortogonal",
                                  "commonMistakes": [
                                    "Usar inv(R) direto em matrizes grandes (instável)",
                                    "Não tratar R como upper triangular",
                                    "Perda de ortogonalidade por arredondamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a Decomposição QR e Comparar com Gram-Schmidt",
                                  "subSteps": [
                                    "Computar R_check = Qᵀ × A e comparar com R",
                                    "Verificar A ≈ Q × R",
                                    "Calcular Qᵀ Q e confirmar identidade (ortogonalidade)",
                                    "Comparar com Gram-Schmidt clássico: executar GS e medir perda de ortogonalidade",
                                    "Documentar vantagens numéricas da abordagem Cholesky"
                                  ],
                                  "verification": "||Qᵀ Q - I|| < 1e-12 e ||A - Q R|| < 1e-10",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Q, R e A",
                                    "Funções de norma matricial em NumPy/MATLAB"
                                  ],
                                  "tips": "Use norma de Frobenius para verificações de matrizes",
                                  "learningObjective": "Avaliar estabilidade da QR via Cholesky vs. Gram-Schmidt",
                                  "commonMistakes": [
                                    "Ignorar tolerâncias de máquina",
                                    "Confundir R com Rᵀ",
                                    "Não comparar com método instável"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[1, 1], [0, 2], [1, 0]] (matriz de dados de tensões em uma viga de engenharia civil). Compute G = Aᵀ A = [[2, 1], [1, 5]]. Aplique Cholesky: R = [[√2, 1/√2], [0, √(9/2)]]. Então Q = A R⁻¹, resultando em Q ortogonal e A = Q R estável.",
                              "finalVerifications": [
                                "G = Aᵀ A é simétrica positiva definida",
                                "R da Cholesky satisfaz G = Rᵀ R com erro numérico mínimo",
                                "Qᵀ Q = I (ortogonalidade preservada)",
                                "A = Q R exatamente (dentro de precisão máquina)",
                                "Comparação: perda de ortogonalidade em Gram-Schmidt > Cholesky",
                                "R é triangular superior com diagonal positiva"
                              ],
                              "assessmentCriteria": [
                                "Precisão na computação de G e propriedades verificadas",
                                "Implementação correta do algoritmo Cholesky sem erros algébricos",
                                "Cálculo eficiente de Q via back-substitution",
                                "Verificações numéricas completas com tolerâncias adequadas",
                                "Explicação clara das vantagens de estabilidade numérica",
                                "Aplicação correta em exemplo de engenharia"
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar em Python (SciPy.linalg.cholesky)",
                                "Análise Numérica: Estudo de estabilidade e condicionamento",
                                "Estatística: Decomposição QR em regressão linear least-squares",
                                "Engenharia Mecânica: Análise de elementos finitos para estruturas",
                                "Física Computacional: Simulações de vetores em dinâmica"
                              ],
                              "realWorldApplication": "Em engenharia civil, a fatoração de Cholesky da matriz de Gram permite decomposições QR estáveis em métodos de elementos finitos para análise de estruturas, resolvendo sistemas Ax = b com mínima sensibilidade a erros de arredondamento, essencial em simulações de pontes e edifícios sob cargas dinâmicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.3",
                              "10.1.3.4.2.3"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Analisar estabilidade numérica com matriz de Gram",
                            "description": "Comparar o erro de ortogonalidade ||I - QᵀQ|| no Gram-Schmidt clássico versus modificado com Gram, quantificando impacto do condicionamento em aplicações como solução de equações não-lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Processos de Gram-Schmidt Clássico e Modificado",
                                  "subSteps": [
                                    "Estude a definição do processo Gram-Schmidt clássico: q_k = (a_k - sum_{j=1}^{k-1} (q_j^T a_k) q_j) / ||...||",
                                    "Analise limitações numéricas do clássico devido a cancelamentos subtractivos em matrizes mal condicionadas",
                                    "Introduza o Gram-Schmidt modificado usando matriz de Gram G_{jk} = q_j^T a_k para projeções",
                                    "Compare fórmulas: no modificado, r_{jk} = q_j^T a_k diretamente da Gram, evitando recomputações instáveis",
                                    "Implemente pseudocódigo para ambos em um ambiente numérico"
                                  ],
                                  "verification": "Escreva e execute pseudocódigo que gera Q ortogonal para uma matriz A pequena (3x3) e verifique ||Q^T Q - I|| < 1e-10",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de Álgebra Linear Numérica (Golub-Van Loan)",
                                    "MATLAB ou Python com NumPy/SciPy",
                                    "Matriz de teste A = [1 1 0; 1 1.0001 1; 0 1 1]"
                                  ],
                                  "tips": [
                                    "Use precisão dupla; visualize cancelamentos com 'format long' no MATLAB",
                                    "Desenhe fluxogramas para comparar fluxos dos algoritmos"
                                  ],
                                  "learningObjective": "Compreender diferenças teóricas e numéricas entre Gram-Schmidt clássico e modificado",
                                  "commonMistakes": [
                                    "Confundir projeções forward vs backward",
                                    "Ignorar normalização no final de cada vetor",
                                    "Usar A em vez de Q para Gram"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e Computar a Matriz de Gram",
                                  "subSteps": [
                                    "Defina G como matriz inferior triangular com G_{jk} = q_j^T a_k para j <= k",
                                    "Implemente computação incremental: para cada k, compute linha k de G usando Q atualizado",
                                    "Use G para modificar Gram-Schmidt: q_k = (a_k - sum_{j=1}^{k-1} G_{jk} q_j) / G_{kk}",
                                    "Teste com matriz mal condicionada: cond(A) > 1e6",
                                    "Verifique simetria e positividade de G"
                                  ],
                                  "verification": "Confirme que G é Cholesky-like (G^T G ≈ A^T A) com erro relativo < 1e-12",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python/MATLAB iniciado do Step 1",
                                    "Função cond() para condicionamento",
                                    "Matrizes de teste com cond crescente"
                                  ],
                                  "tips": [
                                    "Atualize Q e G simultaneamente em loop para evitar erros de acumulação",
                                    "Monitore normas ao longo das iterações"
                                  ],
                                  "learningObjective": "Dominar construção da matriz de Gram como estabilizador numérico",
                                  "commonMistakes": [
                                    "Recomputar toda G do zero a cada passo (ineficiente)",
                                    "Esquecer de normalizar G_{kk}",
                                    "Usar A diretamente sem Q"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Comparar Erro de Ortogonalidade",
                                  "subSteps": [
                                    "Codifique Gram-Schmidt clássico completo e compute Q_classic",
                                    "Codifique versão modificada com G e compute Q_mod",
                                    "Calcule erros: e_classic = norm(eye(n) - Q_classic' * Q_classic, 'fro')",
                                    "Repita para Q_mod: e_mod = norm(eye(n) - Q_mod' * Q_mod, 'fro')",
                                    "Gere gráfico de e vs cond(A) para várias A aleatórias"
                                  ],
                                  "verification": "Para A com cond=1e10, e_classic > 1e-5 enquanto e_mod < 1e-10",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Biblioteca NumPy/SciPy ou MATLAB",
                                    "Função norm() e eye()",
                                    "Gerador de matrizes hilbert() para mal condicionadas"
                                  ],
                                  "tips": [
                                    "Use Frobenius norm para erro de matriz",
                                    "Teste com n=10-50 para relevância prática",
                                    "Salve Q para reutilização"
                                  ],
                                  "learningObjective": "Quantificar superioridade numérica do modificado via métrica ||I - Q^T Q||",
                                  "commonMistakes": [
                                    "Norma errada (use 'fro' não 2)",
                                    "Não escalar erros por cond(A)",
                                    "Ignorar precisão de máquina"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto do Condicionamento em Aplicações Não-Lineares",
                                  "subSteps": [
                                    "Integre em solver não-linear: use QR de A(x) em Newton-Raphson para F(x)=0",
                                    "Simule iterações onde ortogonalidade afeta convergência",
                                    "Quantifique: compare número de iterações e resíduo final com clássico vs modificado",
                                    "Avalie sensibilidade: varie cond(A(x)) e meça perda de ortogonalidade",
                                    "Conclua thresholds: quando usar modificado (cond > 1e8)"
                                  ],
                                  "verification": "Em exemplo não-linear, método com Gram converge 2x mais rápido com erro < 1e-8",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código de Newton-Raphson",
                                    "Sistema não-linear exemplo: stiff ODE de viga",
                                    "Profiler para tempo/iterações"
                                  ],
                                  "tips": [
                                    "Linearize F'(x) via QR em cada passo",
                                    "Use condest() rápida para monitorar",
                                    "Documente trade-offs computacionais"
                                  ],
                                  "learningObjective": "Aplicar análise de estabilidade a contextos reais de engenharia",
                                  "commonMistakes": [
                                    "Não atualizar A em iterações não-lineares",
                                    "Sobrepor Q sem reortogonalizar",
                                    "Ignorar custo extra de G"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise estrutural de uma viga com malha finita (A 50x50, cond≈1e12 de hilbert-like), compute QR via clássico (erro orto=1e-3, falha convergência Newton) vs modificado (erro=1e-14, converge em 15 iterações).",
                              "finalVerifications": [
                                "Implementa corretamente ambos algoritmos sem bugs aritméticos",
                                "Calcula ||I - Q^T Q||_F com precisão máquina para n≤100",
                                "Gera gráfico log-log de erro vs cond(A) mostrando gap de 6 ordens",
                                "Aplica a solver não-linear com demonstração de melhoria quantitativa",
                                "Explica verbalmente impacto em estabilidade global",
                                "Identifica quando cond exige reortogonalização"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erros < 1e-12 em testes padrão (30%)",
                                "Eficiência código: tempo < 2x clássico para n=100 (20%)",
                                "Análise gráfica: plots claros com legendas/axes log (20%)",
                                "Interpretação: quantifica thresholds cond (20%)",
                                "Aplicação: sucesso em exemplo não-linear real (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear Numérica: fatoração QR e Cholesky",
                                "Programação Científica: implementação numéricamente estável em Python/MATLAB",
                                "Análise de Equações Diferenciais: estabilidade em métodos espectrais",
                                "Engenharia Computacional: pré-condicionadores em FEM para civis"
                              ],
                              "realWorldApplication": "Na simulação de elementos finitos para pontes (matrizes rigidez mal condicionadas), Gram-Schmidt modificado estabiliza eigen-solvers, reduzindo erros em modais de vibração de 10% para <0.1%, evitando redesigns custosos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Implementar algoritmo Gram-Schmidt modificado em MATLAB",
                            "description": "Codificar o processo usando gram(G) ou householder para QR, testando com matrizes mal-condicionadas de problemas de engenharia civil, conforme bibliografia de Chapra e Canale.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos Teóricos do Processo de Gram-Schmidt Modificado",
                                  "subSteps": [
                                    "Estude a definição matemática do processo Gram-Schmidt clássico e suas limitações numéricas devido a erros de arredondamento.",
                                    "Analise a versão modificada, focando na subtração ortogonal sequencial para maior estabilidade.",
                                    "Revise a relação com decomposição QR usando Gram-Schmidt ou Householder, conforme seções relevantes de Chapra e Canale.",
                                    "Entenda o papel de matrizes mal-condicionadas em problemas de engenharia civil, como matrizes de rigidez.",
                                    "Derive manualmente os passos para uma matriz 3x3 simples."
                                  ],
                                  "verification": "Resuma em um documento os passos matemáticos e identifique pelo menos 3 diferenças entre clássico e modificado.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Livro Chapra e Canale (capítulos sobre condicionamento e decomposição QR)",
                                    "Notas de aula sobre álgebra linear numérica",
                                    "Matriz de exemplo impressa ou digital"
                                  ],
                                  "tips": "Use diagramas vetoriais para visualizar a ortogonalização; foque em perdas de ortogonalidade.",
                                  "learningObjective": "Compreender a teoria por trás do Gram-Schmidt modificado e sua importância para estabilidade numérica.",
                                  "commonMistakes": [
                                    "Confundir Gram-Schmidt clássico com modificado",
                                    "Ignorar efeitos de condicionamento em matrizes reais",
                                    "Não derivar passos manualmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Ambiente MATLAB e Matrizes de Teste",
                                  "subSteps": [
                                    "Instale ou abra MATLAB e verifique funções built-in como qr() e cond().",
                                    "Gere matrizes de teste: uma bem-condicionada (ex: identidade) e mal-condicionadas (ex: matriz de Hilbert ou rigidez de treliça).",
                                    "Implemente função para calcular norma e produto interno usando dot() e norm().",
                                    "Crie script inicial para carregar e exibir propriedades (dimensões, cond(A)).",
                                    "Salve matrizes de engenharia civil de exemplos de Chapra (ex: problemas de estruturas)."
                                  ],
                                  "verification": "Execute script e confirme que cond(A) > 1e6 para matriz mal-condicionada via saída no console.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "MATLAB instalado",
                                    "Exemplos de matrizes de Chapra e Canale (digitalizados)",
                                    "Documentação MATLAB para qr e cond"
                                  ],
                                  "tips": "Use rand() para gerar matrizes aleatórias e ill-cond() se disponível; armazene em .mat.",
                                  "learningObjective": "Configurar ambiente de teste realista com matrizes relevantes à engenharia civil.",
                                  "commonMistakes": [
                                    "Usar matrizes quadradas perfeitas sem condicionamento ruim",
                                    "Esquecer de verificar versão MATLAB",
                                    "Não salvar workspace"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar o Algoritmo Gram-Schmidt Modificado em MATLAB",
                                  "subSteps": [
                                    "Escreva função principal [Q,R] = gramschmidt_mod(A) inicializando Q como cópia de A.",
                                    "Implemente loop principal: para cada coluna j, subtraia projeções de colunas anteriores usando (q_i' * a_j) * q_i.",
                                    "Normalize cada q_j com norm(q_j) para obter unidade.",
                                    "Calcule R como upper triangular com diagonais norm(q_j) e superdiag q_i' * a_j.",
                                    "Adicione opção para Householder se gram(G) falhar, usando house() built-in como fallback.",
                                    "Teste sintaxe com matriz pequena e debugue erros."
                                  ],
                                  "verification": "Chame função com matriz 3x3; verifique norm(Q'*Q - eye(size(Q))) < 1e-10.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Editor MATLAB (ou Live Script)",
                                    "Pseudo-código de Gram-Schmidt de notas",
                                    "Documentação MATLAB para funções vetoriais"
                                  ],
                                  "tips": "Vectorize operações com bsxfun ou repmat para eficiência; use fprintf para debug.",
                                  "learningObjective": "Implementar corretamente o algoritmo em código funcional e estável.",
                                  "commonMistakes": [
                                    "Não subtrair todas projeções anteriores",
                                    "Normalizar antes de subtrair",
                                    "Ignorar divisão por zero em normas zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Validar e Analisar Resultados com Matrizes Mal-Condicionadas",
                                  "subSteps": [
                                    "Execute algoritmo em matrizes bem e mal-condicionadas; compare Q*R com A original (norm(A - Q*R) < tol).",
                                    "Compare com qr(A) built-in: verifique ortogonalidade e resíduos.",
                                    "Analise perda de ortogonalidade: compute ||Q'Q - I|| e cond(R).",
                                    "Teste com matrizes de engenharia civil (ex: rigidez de viga); plote Q e R.",
                                    "Otimize para estabilidade adicionando reortogonalização se necessário.",
                                    "Gere relatório com tabelas de erros e plots."
                                  ],
                                  "verification": "Relatório mostra erro < 1e-8 para bem-condicionada e discute degradação em mal-condicionada.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Scripts dos steps anteriores",
                                    "MATLAB plotting functions (semilogy para cond)",
                                    "Exemplos Chapra de engenharia civil"
                                  ],
                                  "tips": "Use tol = 1e-12; plote norm(Q'*Q - I) vs tamanho matriz.",
                                  "learningObjective": "Avaliar performance numérica e validar contra benchmarks.",
                                  "commonMistakes": [
                                    "Não comparar com built-in",
                                    "Ignorar resíduos em mal-condicionadas",
                                    "Esquecer plots para visualização"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar, Refinar e Integrar em Workflow de Engenharia",
                                  "subSteps": [
                                    "Adicione comentários e help à função; crie GUI simples ou wrapper para inputs.",
                                    "Refatore código para modularidade (funções separadas para projeção e normalização).",
                                    "Integre em problema real: resolva Ax=b usando QR para sistemas mal-condicionados.",
                                    "Salve como toolbox pessoal ou GitHub repo.",
                                    "Escreva resumo de lições aprendidas e limitações."
                                  ],
                                  "verification": "Função documentada roda sem erros em novo dataset; resolva sistema com precisão melhorada.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "MATLAB publish ou Live Script para relatório",
                                    "Git para versionamento"
                                  ],
                                  "tips": "Use nargin para flexibilidade; teste edge cases como matrizes rank-deficient.",
                                  "learningObjective": "Produzir código production-ready aplicável a problemas reais.",
                                  "commonMistakes": [
                                    "Código sem comentários",
                                    "Não testar rank < n",
                                    "Ignorar integração com solve"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o algoritmo para decompor a matriz de rigidez de uma treliça 2D mal-condicionada (exemplo 11.4 de Chapra e Canale). Use para resolver deslocamentos sob carga, comparando tempo e precisão com qr() built-in, demonstrando estabilidade em cond(A) ≈ 1e10.",
                              "finalVerifications": [
                                "Norma do resíduo ||A - Q*R|| < 1e-10 para matrizes teste.",
                                "Ortogonalidade: ||Q'*Q - I|| < 1e-12.",
                                "Comparação com qr(A): fatores R idênticos até 1e-8.",
                                "Função roda em <1s para matriz 100x100 mal-condicionada.",
                                "Relatório discute impactos em engenharia civil.",
                                "Código modular com pelo menos 3 funções auxiliares."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: passos do algoritmo seguem Gram-Schmidt modificado exatamente (30%).",
                                "Estabilidade numérica: performance em mal-condicionadas vs clássico (25%).",
                                "Qualidade de código: comentários, eficiência, modularidade (20%).",
                                "Testes abrangentes: cobertura de casos, validações e plots (15%).",
                                "Aplicação contextual: ligação com problemas de engenharia civil (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Integra com métodos de álgebra linear em Python/NumPy.",
                                "Engenharia Computacional: Aplicações em FEA (Finite Element Analysis).",
                                "Análise de Dados: Pré-processamento para regressão em dados estruturais.",
                                "Matemática Aplicada: Estudo de autovalores em vibrações.",
                                "Otimização: Uso em solvers de minimos quadrados para design estrutural."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para decomposição QR estável de matrizes de rigidez em análises de estruturas grandes (pontes, edifícios), evitando erros numéricos em simulações FEM que levam a designs inseguros; otimiza solvers em software como ANSYS ou MATLAB PDE Toolbox."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.3",
                              "10.1.3.4.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Aplicações da Matriz de Gram em Processos Ortogonais",
                    "description": "Uso da matriz de Gram para verificar ortogonalidade e normalizar bases em contextos computacionais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Matriz de Gram e Verificação de Ortogonalidade",
                        "description": "Conceito fundamental sobre a construção da matriz de Gram a partir de um conjunto de vetores e sua utilização para verificar se um conjunto de vetores é ortogonal em contextos computacionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Construir a matriz de Gram",
                            "description": "Calcular a matriz de Gram G para um conjunto de vetores {v1, v2, ..., vn} definindo G_ij = <vi, vj>, onde < , > é o produto interno, implementando em software numérico como MATLAB ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e propriedades da Matriz de Gram",
                                  "subSteps": [
                                    "Leia a definição: G_ij = <vi, vj> para vetores vi, vj em um espaço vetorial com produto interno.",
                                    "Identifique propriedades chave: simétrica (G = G^T), semidefinida positiva, G_ii = ||vi||^2.",
                                    "Entenda aplicações: verificação de ortogonalidade (G diagonal se ortogonais), condicionamento.",
                                    "Anote fórmulas para produto interno em R^n: <u,v> = sum u_k * v_k.",
                                    "Desenhe um exemplo 2x2 para visualizar."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as 3 propriedades principais e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de álgebra linear ou notas de aula",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Use analogias como 'similaridade' entre vetores para fixar o conceito.",
                                  "learningObjective": "Compreender conceitualmente a matriz de Gram e suas propriedades fundamentais.",
                                  "commonMistakes": [
                                    "Confundir com matriz de covariância",
                                    "Esquecer que é simétrica",
                                    "Ignorar normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar o conjunto de vetores de entrada",
                                  "subSteps": [
                                    "Escolha um conjunto {v1, ..., vn} com n=3-5 vetores em R^2 ou R^3 para simplicidade inicial.",
                                    "Represente vetores como listas ou arrays: ex. v1 = [1,0], v2=[1,1].",
                                    "Verifique dimensionalidade: todos vetores devem ter o mesmo comprimento.",
                                    "Calcule normas individuais manualmente para prever diagonal de G.",
                                    "Salve em formato legível para código (lista de listas)."
                                  ],
                                  "verification": "Liste os vetores e calcule ||v1||^2 corretamente à mão.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Editor de texto"
                                  ],
                                  "tips": "Comece com vetores ortogonais conhecidos para testar intuição.",
                                  "learningObjective": "Selecionar e preparar dados vetoriais adequados para computação da matriz.",
                                  "commonMistakes": [
                                    "Vetores de dimensões diferentes",
                                    "Escala inconsistente",
                                    "Esquecer de transpor colunas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a matriz de Gram manualmente para validação",
                                  "subSteps": [
                                    "Para cada par (i,j), compute <vi, vj> = vi · vj = sum_{k=1}^m vi_k * vj_k.",
                                    "Preencha a matriz G linha por linha, garantindo simetria (G_ij = G_ji).",
                                    "Verifique diagonal: G_ii deve ser norma ao quadrado positiva.",
                                    "Calcule determinante ou traço para checagem rápida.",
                                    "Compare com expectativa: se ortogonais, off-diagonal deve ser zero."
                                  ],
                                  "verification": "Matriz resultante é simétrica e diagonal positiva; coincida com cálculo à mão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora"
                                  ],
                                  "tips": "Use tabela para organizar produtos internos e evitar recálculos.",
                                  "learningObjective": "Executar cálculo analítico preciso da matriz de Gram.",
                                  "commonMistakes": [
                                    "Erro aritmético em somas",
                                    "Não simetrizar manualmente",
                                    "Confundir produto escalar com subtração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o cálculo em Python com NumPy",
                                  "subSteps": [
                                    "Instale/importe NumPy: import numpy as np.",
                                    "Defina vetores como array: V = np.array([[1,0], [1,1], [0,1]]).",
                                    "Compute G = V @ V.T (para colunas como vetores).",
                                    "Imprima G e verifique simetria: np.allclose(G, G.T).",
                                    "Adicione função reutilizável: def gram_matrix(V): return V @ V.T."
                                  ],
                                  "verification": "Código roda sem erros e G coincide com cálculo manual (erro < 1e-10).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy (Jupyter ou VS Code)",
                                    "Documentação NumPy"
                                  ],
                                  "tips": "Use np.dot(V, V.T) se @ não funcionar em versão antiga.",
                                  "learningObjective": "Codificar eficientemente a construção da matriz de Gram usando álgebra linear computacional.",
                                  "commonMistakes": [
                                    "Transpor errado (V.T @ V em vez de V @ V.T)",
                                    "Vetores como linhas vs colunas",
                                    "Ignorar float precision"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e interpretar a matriz de Gram computada",
                                  "subSteps": [
                                    "Confirme simetria e positividade: eigenvalues = np.linalg.eigvals(G); all >=0.",
                                    "Verifique ortogonalidade: off-diagonais próximos de zero.",
                                    "Calcule condição: cond = np.linalg.cond(G).",
                                    "Compare tempos: manual vs computacional para conjuntos maiores.",
                                    "Documente insights: ex. vetores lineares dependentes → G singular."
                                  ],
                                  "verification": "Relatório curto com métricas (simetria, cond number) e interpretação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código Python do step 4",
                                    "NumPy docs para eigvals/cond"
                                  ],
                                  "tips": "Teste com n=10 vetores para ver escalabilidade.",
                                  "learningObjective": "Analisar propriedades numéricas e validar implementação.",
                                  "commonMistakes": [
                                    "Não checar precisão numérica",
                                    "Interpretar erroneamente singularidade",
                                    "Esquecer normalização"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado V = np.array([[1, 0], [1, 1], [0, 1]]), compute G: [[1,1,0], [1,2,1], [0,1,1]]. Verifique ortogonalidade parcial e use para preconditioning em simulações estruturais civis.",
                              "finalVerifications": [
                                "Construir G manualmente para 3 vetores coincide com código (erro absoluto <0.01).",
                                "Código Python funciona para n=5 vetores em <1s e G simétrica.",
                                "Identificar corretamente: vetores ortonormais → G = I.",
                                "Calcular e interpretar número de condição de G.",
                                "Explicar uso em verificação de base ortogonal.",
                                "Adaptar código para MATLAB equivalente."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Cálculos manuais e numéricos coincidem exatamente.",
                                "Eficiência: Código vetorizado, não loops ineficientes.",
                                "Validação: Todas verificações (simetria, PSD) implementadas.",
                                "Interpretação: Explicação clara de propriedades e aplicações.",
                                "Generalidade: Função funciona para qualquer dimensão/input válido.",
                                "Documentação: Código comentado e relatório conciso."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Extensão de produtos internos e autovalores.",
                                "Programação Computacional: Uso de bibliotecas NumPy/MATLAB para LA.",
                                "Estatística: Similar a matriz de covariância em PCA.",
                                "Engenharia Civil: Condicionamento em FEA (análise de elementos finitos).",
                                "Otimização: Preconditioning em métodos iterativos."
                              ],
                              "realWorldApplication": "Na engenharia civil, a matriz de Gram é usada em processos ortogonais para verificar bases de funções em métodos de elementos finitos (FEA), melhorar condicionamento de sistemas lineares em simulações de estruturas, e otimizar decomposições QR em análise modal de vibrações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Verificar ortogonalidade via matriz de Gram",
                            "description": "Analisar a matriz de Gram para determinar ortogonalidade: se G é diagonal com elementos não-nulos na diagonal, o conjunto é ortogonal; interpretar off-diagonais zero em implementações computacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Matriz de Gram e Ortogonalidade",
                                  "subSteps": [
                                    "Defina produto interno escalar para vetores reais.",
                                    "Explique o que é um conjunto ortogonal de vetores.",
                                    "Descreva a matriz de Gram G como G_{ij} = <v_i, v_j>.",
                                    "Identifique condições: G diagonal com elementos diagonais ≠ 0 implica ortogonalidade.",
                                    "Discuta tolerâncias numéricas para off-diagonais próximas de zero."
                                  ],
                                  "verification": "Resuma em um parágrafo as condições de ortogonalidade via G e forneça um contraexemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Calculadora básica",
                                    "Referência: notas de aula sobre produtos internos"
                                  ],
                                  "tips": "Lembre-se: ortogonalidade é <u,v>=0 para u≠v; normalize para ortonormal.",
                                  "learningObjective": "Compreender a relação teórica entre matriz de Gram e ortogonalidade.",
                                  "commonMistakes": [
                                    "Confundir diagonal não-nula com ortonormalidade",
                                    "Ignorar normalização dos vetores",
                                    "Esquecer que G é simétrica positiva semidefinida"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Matriz de Gram para um Conjunto de Vetores",
                                  "subSteps": [
                                    "Selecione um conjunto de 2-3 vetores em R^n.",
                                    "Calcule todos os produtos internos <v_i, v_j> manualmente.",
                                    "Monte a matriz G com elementos G_{ij}.",
                                    "Verifique se G é simétrica.",
                                    "Calcule os elementos diagonais ||v_i||^2."
                                  ],
                                  "verification": "Apresente a matriz G calculada e confirme simetria por transposição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou papel quadriculado",
                                    "Exemplo de vetores impresso"
                                  ],
                                  "tips": "Use expansão por coordenadas para produtos internos: soma x_i y_i.",
                                  "learningObjective": "Dominar o cálculo explícito da matriz de Gram.",
                                  "commonMistakes": [
                                    "Erro aritmético em somas de produtos",
                                    "Índices errados na matriz (linhas vs colunas)",
                                    "Confundir <u,v> com ||u|| ||v||"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Matriz de Gram para Verificar Ortogonalidade",
                                  "subSteps": [
                                    "Examine elementos off-diagonal: devem ser zero exatos ou próximos de zero.",
                                    "Verifique elementos diagonais: todos ≠ 0.",
                                    "Conclua: se diagonal dominante com off-diagonais ~0, conjunto é ortogonal.",
                                    "Compare com verificação direta de produtos internos.",
                                    "Documente conclusões em tabela: diagonal/off-diagonal."
                                  ],
                                  "verification": "Classifique o conjunto como ortogonal ou não, justificando com valores de G.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz G calculada do passo anterior",
                                    "Tabela de tolerâncias numéricas (ex: 1e-10)"
                                  ],
                                  "tips": "Use critério: |G_{ij}| < ε para i≠j, com ε=1e-12 em precisão dupla.",
                                  "learningObjective": "Aplicar critérios de análise para determinar ortogonalidade.",
                                  "commonMistakes": [
                                    "Aceitar off-diagonais pequenas sem tolerância",
                                    "Ignorar zeros exatos em cálculos simbólicos",
                                    "Confundir ortogonal com independente linear"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Interpretar Verificação Computacional",
                                  "subSteps": [
                                    "Implemente cálculo de G em Python/MATLAB com numpy.",
                                    "Use função dot() para produtos internos.",
                                    "Analise off-diagonais com np.abs(G - np.diag(np.diag(G))) < tol.",
                                    "Interprete resultados numéricos vs analíticos.",
                                    "Teste com vetores condicionados numericamente."
                                  ],
                                  "verification": "Execute código e gere output mostrando G e conclusão de ortogonalidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Jupyter Notebook",
                                    "Código template para Gram matrix"
                                  ],
                                  "tips": "Sempre plote G como heatmap para visualização intuitiva.",
                                  "learningObjective": "Integrar análise computacional à verificação teórica.",
                                  "commonMistakes": [
                                    "Erro de sintaxe em loops para G",
                                    "Tolerância inadequada levando a falsos positivos",
                                    "Não seedar random para reprodutibilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere vetores em R^3 para análise estrutural: v1=[1,0,0], v2=[0,1,0], v3=[0,0,1] (base canônica). Calcule G=[[1,0,0],[0,1,0],[0,0,1]] - diagonal com 1s ≠0, off-diagonais=0 → ortogonal. Agora, v1=[1,1,0], v2=[1,-1,0]: G=[[2,0],[0,2]] → ortogonal. Em código Python: import numpy as np; V=np.array([[1,1],[1,-1]]).T; G=V.T@V; print(np.allclose(G, np.diag(np.diag(G)), atol=1e-10)) → True.",
                              "finalVerifications": [
                                "Explique verbalmente por que off-diagonais zero implicam ortogonalidade.",
                                "Calcule G para novo conjunto e conclua corretamente.",
                                "Identifique erro em G com off-diagonal ≠0.",
                                "Implemente código que retorne 'Ortogonal' ou 'Não Ortogonal'.",
                                "Discuta impacto de ruído numérico em off-diagonais.",
                                "Compare tempo de verificação via G vs produtos internos diretos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de produtos internos (erro <1%).",
                                "Correta identificação de condições diagonal/off-diagonal.",
                                "Interpretação adequada de tolerâncias computacionais.",
                                "Código funcional e eficiente para verificação.",
                                "Justificativa clara e concisa das conclusões.",
                                "Uso correto de materiais e cumprimento de tempos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Extensão a autovalores de G para condicionamento.",
                                "Programação Numérica: Implementação em bibliotecas como SciPy para decomposições.",
                                "Física/Engenharia: Ortogonalidade em modos normais de vibração estrutural.",
                                "Análise Numérica: Estabilidade em processos de Gram-Schmidt.",
                                "Estatística: Covariância como Gram em dados centrados."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao modelar estruturas via elementos finitos (ex: SAP2000 ou ANSYS), verifica-se ortogonalidade de funções de forma ou modos para evitar ill-conditioning na matriz de rigidez, garantindo soluções numéricas estáveis em simulações de cargas sísmicas ou vento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Interpretar propriedades numéricas da matriz de Gram",
                            "description": "Avaliar o condicionamento da matriz de Gram (cond(G)) e sua relação com a estabilidade numérica na verificação de ortogonalidade em problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Matriz de Gram e suas Propriedades Básicas",
                                  "subSteps": [
                                    "Defina a matriz de Gram G = A^T A, onde A é uma matriz cujas colunas são vetores a serem analisados.",
                                    "Identifique propriedades chave: G é simétrica, positiva semidefinida e seus autovalores são quadrados das singular values de A.",
                                    "Relacione G com produtos internos: G_{ij} = <a_i, a_j>, onde ortogonalidade implica G diagonal.",
                                    "Discuta implicações numéricas iniciais, como trace(G) = soma das normas ao quadrado dos vetores.",
                                    "Exemplo simples: compute G para dois vetores ortogonais unitários."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando a matriz de Gram e liste três propriedades numéricas principais, verificando com um cálculo manual simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Calculadora ou Python/NumPy para exemplos iniciais"
                                  ],
                                  "tips": "Visualize G como uma representação do 'ângulo' entre vetores via produtos internos para intuição geométrica.",
                                  "learningObjective": "Dominar a definição e propriedades fundamentais da matriz de Gram para interpretação numérica.",
                                  "commonMistakes": [
                                    "Confundir G = A^T A com A A^T",
                                    "Ignorar que autovalores zero indicam dependência linear",
                                    "Esquecer simetria de G"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Propriedades Numéricas da Matriz de Gram",
                                  "subSteps": [
                                    "Construa a matriz A a partir de vetores relevantes em um contexto de engenharia civil (ex: vetores de deslocamento).",
                                    "Compute G = A^T A usando software numérico, verificando simetria numérica.",
                                    "Calcule autovalores e autovetores de G com funções como eig() no MATLAB ou numpy.linalg.eig().",
                                    "Analise o espectro: identifique lambda_max, lambda_min e verifique cond(G) preliminarmente como lambda_max / lambda_min.",
                                    "Valide com normas: ||G||_2 ≈ lambda_max e det(G) relacionado ao volume do paralelótopo."
                                  ],
                                  "verification": "Produza G, seus autovalores e confirme simetria com tolerância numérica 1e-10 para um conjunto de vetores dado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB, Python (NumPy/SciPy) ou Octave",
                                    "Dados de exemplo de vetores de estruturas civis"
                                  ],
                                  "tips": "Use precisão dupla e verifique resíduos para evitar erros de arredondamento em computações.",
                                  "learningObjective": "Habilitar o cálculo preciso de propriedades numéricas de G para análise subsequente.",
                                  "commonMistakes": [
                                    "Não escalonar vetores adequadamente antes do cálculo",
                                    "Ignorar tolerâncias numéricas em autovalores próximos de zero",
                                    "Usar normas erradas para cond(G)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar o Número de Condicionamento cond(G)",
                                  "subSteps": [
                                    "Defina cond_2(G) = λ_max / λ_min, onde λ são autovalores absolutos ordenados.",
                                    "Compute cond(G) numericamente e interprete escalas: cond < 10^3 bem condicionado, >10^6 mal condicionado.",
                                    "Relacione com normas de matriz: cond(G) = ||G||_2 * ||G^{-1}||_2, computando inversa se G não singular.",
                                    "Simule impacto: adicione ruído pequeno a A e observe variação em cond(G).",
                                    "Compare com cond(A), notando cond(G) = [cond(A)]^2."
                                  ],
                                  "verification": "Calcule cond(G) para dois exemplos: um bem condicionado (ortogonal) e um mal (quase colinear), explicando diferenças.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software numérico com funções cond() ou eig()",
                                    "Notebooks Jupyter para simulações"
                                  ],
                                  "tips": "Ordene autovalores corretamente e use log10(cond) para escalas intuitivas.",
                                  "learningObjective": "Avaliar quantitativamente o condicionamento de G e suas implicações iniciais.",
                                  "commonMistakes": [
                                    "Usar autovalores não ordenados",
                                    "Confundir cond(G) com cond(A)",
                                    "Ignorar singularidade quando λ_min ≈ 0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Relação de cond(G) com Estabilidade Numérica na Verificação de Ortogonalidade",
                                  "subSteps": [
                                    "Explique como cond(G) alto amplifica erros em verificação <v_i, v_j> ≈ 0 devido a perturbações numéricas.",
                                    "Analise estabilidade: erro relativo em G ~ cond(G) * máquina epsilon.",
                                    "Aplique em engenharia civil: verifique ortogonalidade de modos em análise dinâmica de estruturas.",
                                    "Decida thresholds: se cond(G) > 10^8, desconfie de ortogonalidade numérica e use métodos alternativos.",
                                    "Teste: perturbe vetores e re-verifique G para quantificar perda de ortogonalidade."
                                  ],
                                  "verification": "Em um caso de estudo, interprete se cond(G) permite confiar na ortogonalidade declarada, com justificativa quantitativa.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de dados FEM de vigas ou pórticos",
                                    "Software de análise estrutural como ANSYS ou código próprio"
                                  ],
                                  "tips": "Sempre relacione cond(G) com epsilon_máquina (~1e-16) para previsões realistas de estabilidade.",
                                  "learningObjective": "Conectar cond(G) à estabilidade prática em verificações de ortogonalidade em contextos reais.",
                                  "commonMistakes": [
                                    "Subestimar impacto de cond alto em off-diagonais de G",
                                    "Não considerar contexto específico da aplicação",
                                    "Confiar cegamente em cond baixo sem verificação de perturbações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma análise modal de uma viga contínua, os primeiros três modos de vibração devem ser ortogonais. Construa A com vetores de modo normalizados, compute G, encontre cond(G) = 1.2e5. Interprete: off-diagonais de G < 1e-8 sugerem ortogonalidade, mas cond alto indica sensibilidade a mesh refinamento em FEM; recomende verificação analítica.",
                              "finalVerifications": [
                                "Explique verbalmente a relação cond(G) = [cond(A)]^2.",
                                "Dado G 3x3, compute cond_2(G) e classifique como bem/mal condicionado.",
                                "Simule perturbação de 1e-10 em A e meça mudança relativa em off-diagonais de G.",
                                "Identifique quando cond(G) invalida verificação numérica de ortogonalidade.",
                                "Aplique a um exemplo civil: avalie G de vetores de deslocamento em pórtico.",
                                "Liste 3 consequências de cond(G) alto em simulações estruturais."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de autovalores e cond(G) (erro <1%)",
                                "Interpretação correta de cond(G) em termos de estabilidade numérica",
                                "Uso adequado de tolerâncias numéricas em verificações",
                                "Conexão explícita com aplicações em engenharia civil",
                                "Identificação de erros comuns e mitigação em simulações",
                                "Clareza na explicação de impactos em ortogonalidade"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores e normas de matrizes",
                                "Análise Numérica: condicionamento e estabilidade de algoritmos",
                                "Engenharia Estrutural: análise modal e FEM",
                                "Programação Computacional: implementação em Python/MATLAB",
                                "Física: ortogonalidade em funções de onda e vibrações"
                              ],
                              "realWorldApplication": "Na verificação de ortogonalidade de modos de vibração em projetos de pontes ou edifícios altos, um cond(G) elevado sinaliza risco de instabilidade numérica em simulações FEM, prevenindo erros em predições de fadiga ou resposta sísmica, garantindo segurança estrutural."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Normalização de Bases Usando Matriz de Gram",
                        "description": "Aplicação da matriz de Gram no processo de ortogonalização e normalização de bases, como no método de Gram-Schmidt modificado, para obter bases ortonormais em computação numérica.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Aplicar Gram-Schmidt com suporte da matriz de Gram",
                            "description": "Implementar o processo de Gram-Schmidt computacionalmente, utilizando a matriz de Gram para calcular coeficientes de projeção e gerar uma base ortogonal a partir de uma base linearmente independente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz A com a base linearmente independente",
                                  "subSteps": [
                                    "Selecione uma base linearmente independente {v1, v2, ..., vn} no espaço vetorial apropriado (ex: R^m com m >= n).",
                                    "Forme a matriz A de tamanho m x n cujas colunas são os vetores vi.",
                                    "Verifique a independência linear computando o rank de A ou det(A^T A) != 0.",
                                    "Defina o produto interno padrão (dot product).",
                                    "Documente as dimensões e contexto da aplicação."
                                  ],
                                  "verification": "Rank(A) == n e A tem colunas linearmente independentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "MATLAB",
                                    "Papel e calculadora para exemplos pequenos"
                                  ],
                                  "tips": "Escolha vetores representativos do problema real, como direções em estruturas civis.",
                                  "learningObjective": "Preparar dados de entrada corretos para o processo.",
                                  "commonMistakes": [
                                    "Selecionar vetores linearmente dependentes",
                                    "Erro na transposição de A",
                                    "Ignorar dimensões incompatíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a matriz de Gram G = A^T A",
                                  "subSteps": [
                                    "Compute A^T (transposta de A).",
                                    "Multiplique A^T por A para obter G (n x n simétrica positiva definida).",
                                    "Verifique que G é simétrica e todos autovalores positivos.",
                                    "Armazene G para uso posterior.",
                                    "Analise o condicionamento de G (cond(G) = ||G|| ||G^{-1}||)."
                                  ],
                                  "verification": "G_ij = <vi, vj> para todos i,j e G é positiva definida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "NumPy (np.dot(A.T, A))",
                                    "MATLAB (A'*A)",
                                    "Software de álgebra linear"
                                  ],
                                  "tips": "Use funções otimizadas para multiplicação de matrizes em software numérico.",
                                  "learningObjective": "Entender o papel da matriz de Gram nos produtos internos.",
                                  "commonMistakes": [
                                    "Confundir A A^T com A^T A",
                                    "Erro numérico em dimensões altas",
                                    "Não verificar definitude positiva"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar decomposição de Cholesky em G para obter R",
                                  "subSteps": [
                                    "Aplique Cholesky: G = R^T R, onde R é triangular superior.",
                                    "Implemente ou use função built-in para fatoração (ex: np.linalg.cholesky).",
                                    "Verifique G ≈ R^T R com tolerância numérica.",
                                    "Extraia os coeficientes de projeção da triangular R.",
                                    "Registre os valores diagonais de R (relacionados a normas)."
                                  ],
                                  "verification": "||G - R.T @ R|| < 1e-10 (norma Frobenius).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "SciPy (scipy.linalg.cholesky)",
                                    "MATLAB chol()",
                                    "Implementação manual para compreensão"
                                  ],
                                  "tips": "Cholesky é estável para G bem condicionada; use pivoting se necessário.",
                                  "learningObjective": "Usar Cholesky para extrair coeficientes de Gram-Schmidt de forma estável.",
                                  "commonMistakes": [
                                    "Confundir R superior com inferior",
                                    "Aplicar em G mal condicionada sem pré-condicionamento",
                                    "Erro na verificação de reconstrução"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a base ortogonal Q = A R^{-1}",
                                  "subSteps": [
                                    "Resolva os sistemas triangulares A = Q R usando substituição retroativa (back-substitution).",
                                    "Implemente ou use solver para múltiplas colunas (ex: np.linalg.solve(R.T, A.T).T).",
                                    "Normalize as colunas de Q se base orthonorm seja desejada (divida por normas).",
                                    "Verifique ortogonalidade: Q^T Q ≈ I.",
                                    "Confirme que span(Q) = span(A)."
                                  ],
                                  "verification": "Q.T @ Q ≈ eye(n) e norm(A - Q @ R) < 1e-10.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "NumPy/SciPy solve",
                                    "MATLAB rtsolve",
                                    "Código personalizado"
                                  ],
                                  "tips": "Evite inversão explícita de R; use solve para estabilidade.",
                                  "learningObjective": "Construir base ortogonal usando decomposição QR via Gram.",
                                  "commonMistakes": [
                                    "Inverter R diretamente (instável)",
                                    "Esquecer transposições em solve",
                                    "Não normalizar corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar a base ortogonal gerada",
                                  "subSteps": [
                                    "Compute ângulos entre colunas de Q (90 graus).",
                                    "Verifique preservação do espaço vetorial.",
                                    "Analise melhoria no condicionamento (cond(Q) ≈ 1).",
                                    "Aplique em contexto: ex. projeções em engenharia.",
                                    "Documente resultados e limitações numéricas."
                                  ],
                                  "verification": "Ortogonalidade, completude e estabilidade numérica confirmadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramentas de plotagem (Matplotlib)",
                                    "Calculadora de normas e cond"
                                  ],
                                  "tips": "Use tolerâncias relativas para verificações numéricas.",
                                  "learningObjective": "Avaliar qualidade da base ortogonal.",
                                  "commonMistakes": [
                                    "Ignorar erros de arredondamento",
                                    "Não comparar com GS clássico",
                                    "Sobrepor interpretação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de treliças civis, dados vetores de direções de barras v1=[1,0,0]^T, v2=[1,1,0]^T, v3=[1,1,1]^T em R^3. Compute G = [[1,1,1],[1,2,2],[1,2,3]], Cholesky R^T = [[1,1,1],[0,1,1],[0,0,1]], então Q = A R^{-1}, resultando em base ortogonal para decomposição modal eficiente.",
                              "finalVerifications": [
                                "Q^T Q é a identidade (ou diagonal com normas^2 para ortogonal não normalizada).",
                                "As colunas de Q geram o mesmo espaço que A.",
                                "Norma do resíduo ||A - Q R|| é inferior a 1e-10.",
                                "Condição de Q é próxima de 1.",
                                "Coeficientes em R correspondem a projeções corretas.",
                                "Sem perda de ortogonalidade devido a erros numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da ortogonalidade (erro < 1e-8).",
                                "Correção da decomposição (G ≈ R^T R).",
                                "Eficiência computacional vs. Gram-Schmidt clássico.",
                                "Tratamento de casos mal condicionados.",
                                "Clareza na implementação e documentação.",
                                "Aplicação correta ao contexto de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição QR e Cholesky.",
                                "Programação Numérica: Estabilidade e solvers lineares.",
                                "Engenharia Estrutural: Análise modal e elementos finitos.",
                                "Física: Vetores e bases ortogonais em mecânica.",
                                "Otimização: Redução dimensional em simulações."
                              ],
                              "realWorldApplication": "Na engenharia civil, usado em análise de elementos finitos para ortogonalizar modos de vibração em treliças e edifícios, melhorando condicionamento de matrizes de rigidez e acelerando simulações dinâmicas em software como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Normalizar vetores usando normas da matriz de Gram",
                            "description": "Calcular normas euclidianas via elementos diagonais da matriz de Gram (||vi||^2 = G_ii) e normalizar vetores para obter base orlonormal, com implementação em código para precisão numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular a Matriz de Gram para o Conjunto de Vetores",
                                  "subSteps": [
                                    "Selecione um conjunto de vetores linealmente independentes {v₁, v₂, ..., vₙ} em ℝᵐ.",
                                    "Calcule todos os produtos internos vᵢ · vⱼ para i, j = 1 até n, onde vᵢ · vⱼ = Σ vᵢₖ vⱼₖ.",
                                    "Construa a matriz G de ordem n×n, com G_{ij} = vᵢ · vⱼ.",
                                    "Verifique se G é simétrica positiva definida (diagonal dominante positiva).",
                                    "Armazene a matriz para uso posterior."
                                  ],
                                  "verification": "Confirme que G é simétrica (G = Gᵀ) e todos os elementos diagonais G_{ii} > 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de vetores exemplo",
                                    "Papel e lápis ou software como MATLAB/Octave",
                                    "Calculadora"
                                  ],
                                  "tips": "Aproveite a simetria de G para calcular apenas a triangular superior e transpor.",
                                  "learningObjective": "Dominar a construção da matriz de Gram a partir de produtos internos.",
                                  "commonMistakes": [
                                    "Erro no cálculo de produto interno (confundir com norma)",
                                    "Ignorar simetria levando a cálculos redundantes",
                                    "Usar vetores linearmente dependentes resultando em G singular"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair Normas Euclidianas dos Elementos Diagonais",
                                  "subSteps": [
                                    "Identifique os elementos da diagonal principal: G_{ii} para i=1 até n.",
                                    "Calcule o quadrado da norma euclidiana: ||vᵢ||² = G_{ii}.",
                                    "Obtenha a norma euclidiana: ||vᵢ|| = √G_{ii}.",
                                    "Liste todas as normas em um vetor de normas [||v₁||, ||v₂||, ..., ||vₙ||].",
                                    "Valide numericamente se ||vᵢ||² ≈ vᵢ · vᵢ para precisão."
                                  ],
                                  "verification": "Compare √G_{ii} com norma direta de vᵢ; diferença deve ser < 10^{-10}.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz de Gram do Step 1",
                                    "Função sqrt em calculadora ou código"
                                  ],
                                  "tips": "Use precisão de ponto flutuante dupla para evitar erros de arredondamento em raízes.",
                                  "learningObjective": "Entender que normas euclidianas são extraídas diretamente da diagonal da Gram.",
                                  "commonMistakes": [
                                    "Esquecer raiz quadrada (usar G_{ii} como norma)",
                                    "Erro de arredondamento em vetores com componentes grandes",
                                    "Confundir norma L2 com L1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Normalizar os Vetores para Obter Vetores Unitários",
                                  "subSteps": [
                                    "Para cada vetor vᵢ, compute uᵢ = vᵢ / ||vᵢ|| usando as normas do Step 2.",
                                    "Multiplique cada componente de vᵢ pelo escalar 1/||vᵢ||.",
                                    "Verifique manualmente ||uᵢ|| = 1 para cada i.",
                                    "Forme o conjunto {u₁, u₂, ..., uₙ} de vetores unitários.",
                                    "Armazene em formato matricial U com colunas uᵢ."
                                  ],
                                  "verification": "Calcule ||uᵢ|| para cada i; deve ser aproximadamente 1 (erro < 10^{-12}).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vetores originais e vetor de normas",
                                    "Planilha ou código para divisão escalar"
                                  ],
                                  "tips": "Normalizar em coordenadas normalizadas evita overflow em vetores longos.",
                                  "learningObjective": "Aplicar normalização escalar para obter vetores de norma unitária.",
                                  "commonMistakes": [
                                    "Dividir pela norma ao quadrado em vez da norma",
                                    "Erro de sinal na divisão",
                                    "Não atualizar todas as componentes uniformemente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar em Código e Verificar Ortonormalidade",
                                  "subSteps": [
                                    "Escreva código em Python com NumPy: def gram_normalization(vectors): ...",
                                    "Calcule G = V.T @ V onde V é matriz com colunas vi.",
                                    "Extraia normas = np.sqrt(np.diag(G)), normalize U = V / normas[None,:].",
                                    "Verifique ortonormalidade: np.allclose(U.T @ U, np.eye(n), atol=1e-10).",
                                    "Teste com dados de exemplo e compare com cálculo manual."
                                  ],
                                  "verification": "Código produz U tal que UᵀU = I (identidade) dentro de tolerância numérica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python + NumPy instalado",
                                    "Editor de código (Jupyter Notebook)",
                                    "Vetores de teste"
                                  ],
                                  "tips": "Use np.linalg.norm para validação cruzada; evite loops com broadcasting.",
                                  "learningObjective": "Implementar processo computacionalmente para precisão numérica em larga escala.",
                                  "commonMistakes": [
                                    "Erro de broadcasting em NumPy",
                                    "Tolerância numérica muito rígida falhando em floats",
                                    "Não importar np corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado {v₁ = [3, 4], v₂ = [1, 2]}: G = [[25, 11], [11, 5]], normas = [5, √5], u₁ = [0.6, 0.8], u₂ ≈ [0.447, 0.894]. Código: import numpy as np; V = np.array([[3,1],[4,2]]).T; G=V.T@V; norms=np.sqrt(np.diag(G)); U=V/norms[:,None]; print(np.allclose(U.T@U, np.eye(2))).",
                              "finalVerifications": [
                                "Matriz de Gram G calculada corretamente e simétrica.",
                                "Normas extraídas com √G_{ii} matching norma direta de vetores.",
                                "Vetores normalizados têm ||u_i|| = 1.",
                                "Conjunto {u_i} é ortogonal: u_i · u_j = 0 para i≠j.",
                                "Código Python executa sem erros e verifica ortonormalidade.",
                                "Precisão numérica mantida (erros < 1e-10)."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática em todos os cálculos manuais (100% precisão).",
                                "Eficiência no uso da diagonal da Gram vs. normas diretas.",
                                "Código limpo, comentado e reutilizável.",
                                "Validação numérica robusta com tolerâncias adequadas.",
                                "Compreensão demonstrada via verificações intermediárias.",
                                "Aplicação correta a exemplos de dimensão variável."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Processos de Gram-Schmidt e QR decomposition.",
                                "Programação Computacional: NumPy para álgebra linear numérica.",
                                "Engenharia Civil: Condicionamento em elementos finitos para análise estrutural.",
                                "Física: Ortonormalização de funções de onda em mecânica quântica.",
                                "Processamento de Sinais: Bases ortonormais em transformadas (ex: Fourier)."
                              ],
                              "realWorldApplication": "Em engenharia civil, normalizar bases via matriz de Gram melhora o condicionamento numérico em simulações de elementos finitos para análise de estruturas, reduzindo erros de propagação em solvers de sistemas lineares grandes, como em modelagem de vigas e placas sob cargas dinâmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Corrigir erros numéricos na normalização",
                            "description": "Identificar e mitigar perda de ortogonalidade devido a erros de arredondamento usando a matriz de Gram para re-ortogonalização em simulações computacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar perda de ortogonalidade devido a erros de arredondamento",
                                  "subSteps": [
                                    "Execute normalização sequencial de uma base vetorial usando Gram-Schmidt clássico em um ambiente computacional.",
                                    "Calcule os produtos internos <vi, vj> para i ≠ j após várias iterações ou em dimensões altas.",
                                    "Meça o desvio da ortogonalidade usando norma do off-diagonal da matriz de Gram esperada (identidade).",
                                    "Defina um limiar epsilon (ex: 1e-10) para detectar perda significativa.",
                                    "Registre os vetores afetados e o grau de contaminação numérica."
                                  ],
                                  "verification": "Confirme que max(|<vi,vj>| for i≠j) > epsilon em pelo menos um par de vetores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy, MATLAB ou Octave; conjunto de vetores de teste em alta dimensão.",
                                  "tips": "Use precisão dupla (float64) inicialmente para baseline.",
                                  "learningObjective": "Reconhecer sintomas numéricos de degradação de bases ortogonais.",
                                  "commonMistakes": "Ignorar erros em dimensões baixas onde rounding é menos pronunciado; confundir com não-normalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de Gram para os vetores degradados",
                                  "subSteps": [
                                    "Colete os vetores {v1, v2, ..., vk} em uma matriz V de dimensão n x k.",
                                    "Compute G = V^T * V, garantindo simetria e positivo-definida.",
                                    "Verifique cond(G) para asegurar estabilidade numérica (cond < 1e12).",
                                    "Armazene G como matriz densa ou esparsa se k grande.",
                                    "Compare G com identidade para quantificar perda."
                                  ],
                                  "verification": "G deve ser simétrica com diagonal próxima de 1 e off-diagonais pequenas mas não-zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Biblioteca NumPy/Scipy para dot products eficientes; vetor de teste com 10-20 vetores.",
                                  "tips": "Use função np.dot(V.T, V) para eficiência vetorial.",
                                  "learningObjective": "Dominar construção e interpretação da matriz de Gram em contexto numérico.",
                                  "commonMistakes": "Usar produtos internos não escalares; esquecer transposição em V^T V."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar re-ortogonalização via decomposição da Gram",
                                  "subSteps": [
                                    "Efetue decomposição Cholesky de G = L L^T (ou espectral para G^{-1/2}).",
                                    "Calcule a raiz quadrada inversa G^{-1/2} = (L^T)^{-1} L^{-1}.",
                                    "Prepare os coeficientes de projeção para re-ortogonalização.",
                                    "Teste estabilidade resolvendo sistemas lineares se necessário.",
                                    "Otimize para k pequeno usando fórmulas explícitas."
                                  ],
                                  "verification": "Verifique que G^{-1/2} * G * (G^{-1/2})^T ≈ I dentro de máquina epsilon.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Scipy.linalg.cholesky ou eig; código para decomposição.",
                                  "tips": "Prefira Cholesky para SPD; fallback para eig se il-condicionada.",
                                  "learningObjective": "Aplicar álgebra matricial para correção numérica de bases.",
                                  "commonMistakes": "Confundir G^{1/2} com G^{-1/2}; não verificar PD de G."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar re-ortogonalização e normalizar a nova base",
                                  "subSteps": [
                                    "Compute a base re-ortogonal Q = V * G^{-1/2}.",
                                    "Normalize colunas de Q para ||q_i|| = 1.",
                                    "Atualize a base em simulações (ex: substitua em métodos iterativos).",
                                    "Integre em loop de simulação para re-ortogonalização periódica.",
                                    "Monitore custo computacional (O(k^3) por re-ortogonalização)."
                                  ],
                                  "verification": "Após aplicação, max(|<qi,qj>| for i≠j) < 1e-12.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python/MATLAB com loops de simulação; profiler para timing.",
                                  "tips": "Re-ortogonalize a cada 10-20 passos para balancear precisão/custo.",
                                  "learningObjective": "Implementar correção prática em fluxos computacionais.",
                                  "commonMistakes": "Esquecer normalização final; aplicar em base já ortonormal."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar em simulação computacional",
                                  "subSteps": [
                                    "Execute simulação longa (ex: 1000 iterações) com e sem correção.",
                                    "Compare resíduos, convergência e precisão final.",
                                    "Ajuste frequência de re-ortogonalização baseada em monitoramento.",
                                    "Profile performance e reduza k se possível via seleção.",
                                    "Documente thresholds para produção."
                                  ],
                                  "verification": "Simulação com correção converge 2x mais rápido ou com erro 10x menor.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Simulador FEM simples ou solver iterativo; gráficos de erro.",
                                  "tips": "Use cond(G) > threshold para trigger automático.",
                                  "learningObjective": "Avaliar impacto real em aplicações de engenharia.",
                                  "commonMistakes": "Over-ortogonalizar (custo alto); ignorar overhead em k grande."
                                }
                              ],
                              "practicalExample": "Em análise modal de uma viga em Engenharia Civil, gere 5 modos de vibração via FEM. Após 50 iterações de refinamento, <v2,v3> = 1e-8 devido a rounding. Compute G (5x5), Cholesky, Q = V G^{-1/2}, resultando em ortogonalidade <1e-14, preservando precisão em frequências naturais.",
                              "finalVerifications": [
                                "Matriz de Gram pós-correção tem off-diagonais < 1e-12.",
                                "Condição numérica da base melhorou em pelo menos 1 ordem de magnitude.",
                                "Simulação converge sem divergência numérica.",
                                "Tempo total de computação aumentou <20%.",
                                "Normalização ||qi|| = 1 para todos i.",
                                "Nenhum artefato numérico em resíduos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da re-ortogonalização: erro ortogonalidade <1e-12.",
                                "Correção de implementação: G simétrica e PD validada.",
                                "Eficiência: custo O(k^3) corretamente gerenciado.",
                                "Detecção robusta: threshold adaptativo usado.",
                                "Aplicação contextual: integrado em simulação civil.",
                                "Documentação: erros comuns e tips incluídos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear numérica e estabilidade.",
                                "Computação: Programação científica com decomposições matriciais.",
                                "Física: Mecânica computacional em estruturas.",
                                "Estatística: Análise de erro e condicionamento."
                              ],
                              "realWorldApplication": "Em simulações FEM para análise sísmica de edifícios (Engenharia Civil), re-ortogonalização via Gram corrige modos de vibração degradados por rounding em malhas finas (>10^5 DOFs), evitando erros em fatores de amplificação dinâmica e garantindo conformidade com normas como ABNT NBR 15422."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Aplicações em Processos Computacionais de Engenharia Civil",
                        "description": "Integração da matriz de Gram em métodos numéricos como resíduos ponderados, problemas de valor inicial/contorno e otimização, com foco em condicionamento e estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Usar matriz de Gram no método dos resíduos ponderados",
                            "description": "Aplicar a matriz de Gram para ortogonalizar funções de peso em métodos de resíduos ponderados (ex: Galerkin), verificando ortogonalidade em soluções de EDP para engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Matriz de Gram e Resíduos Ponderados",
                                  "subSteps": [
                                    "Estude a definição de matriz de Gram para funções: G_{ij} = ∫ φ_i(x) φ_j(x) dx.",
                                    "Revise o método dos resíduos ponderados, focando em Galerkin onde pesos são funções base.",
                                    "Identifique a necessidade de ortogonalidade para melhorar condicionamento numérico.",
                                    "Analise um exemplo simples de EDP em engenharia civil, como equação de Laplace para tensões.",
                                    "Discuta como funções não ortogonais levam a il-condicionamento em soluções computacionais."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e explique por que ortogonalizar funções de peso.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de métodos numéricos (ex: Burden & Faires), notas de aula sobre Galerkin, software MATLAB ou Python (SymPy)"
                                  ],
                                  "tips": "Use diagramas para visualizar inner products em espaços de funções.",
                                  "learningObjective": "Compreender a base teórica da matriz de Gram e sua relevância em métodos de resíduos ponderados.",
                                  "commonMistakes": "Confundir inner product com produto escalar discreto; ignorar limites de integração no domínio físico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Matriz de Gram para Funções de Peso",
                                  "subSteps": [
                                    "Selecione funções de peso φ_i(x) relevantes para o problema (ex: polinômios de Legendre para viga cantilever).",
                                    "Calcule os elementos G_{ij} = ∫_Ω φ_i φ_j w(x) dx, onde w(x) é peso de integração.",
                                    "Implemente numericamente via quadratura Gauss para domínios 1D/2D em EDPs civis.",
                                    "Monte a matriz G completa para n funções (ex: 4x4 para aproximação quadrática).",
                                    "Verifique simetria e positividade definida da matriz."
                                  ],
                                  "verification": "Gere a matriz G e confirme simetria (G = G^T) e autovalores positivos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy para integração numérica, papel e lápis para cálculo analítico simples"
                                  ],
                                  "tips": "Comece com funções ortogonais conhecidas para validar implementação.",
                                  "learningObjective": "Construir corretamente a matriz de Gram para um conjunto dado de funções de peso.",
                                  "commonMistakes": "Erros em limites de integração; esquecer fator de peso w(x) no método ponderado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Ortogonalização via Decomposição da Matriz de Gram",
                                  "subSteps": [
                                    "Efetue decomposição Cholesky ou QR na matriz G para obter base ortogonal.",
                                    "Transforme coeficientes originais: u = G^{-1/2} c, onde c são coeficientes não ortogonais.",
                                    "Gere novas funções ψ_i = ∑ G^{-1/2}_{ij} φ_j ortogonais.",
                                    "Verifique ortogonalidade: ∫ ψ_i ψ_j dx = δ_{ij}.",
                                    "Ajuste para condições de contorno em problemas civis (ex: fixo-livre em vigas)."
                                  ],
                                  "verification": "Calcule inner products das novas funções e confirme identidade unitária.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "MATLAB ou Python (SciPy.linalg para Cholesky), exemplo de EDP de viga (equação de Euler-Bernoulli)"
                                  ],
                                  "tips": "Use decomposição espectral para insights em autovalores grandes (il-condicionamento).",
                                  "learningObjective": "Ortogonalizar funções de peso usando a matriz de Gram para melhorar estabilidade numérica.",
                                  "commonMistakes": "Inverter ordem na transformação; não normalizar adequadamente as funções resultantes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar no Método dos Resíduos Ponderados e Verificar Solução",
                                  "subSteps": [
                                    "Formule o sistema Ku = f com funções ortogonais no método Galerkin.",
                                    "Resolva o sistema linear e compare com versão não ortogonal.",
                                    "Avalie condicionamento: cond(K) = ||K|| ||K^{-1}|| antes/depois.",
                                    "Aplique a uma EDP civil: ex. deflexão de viga sob carga distribuída.",
                                    "Analise erro de resíduos: ||r|| = ||L u - f|| em norma ponderada."
                                  ],
                                  "verification": "Compare soluções e confirme redução no número de condição (>10x melhoria).",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "FEA software como ANSYS ou código Python customizado, dados de viga real (comprimento 5m, EI=1e6)"
                                  ],
                                  "tips": "Plot gráficos de deflexão para visualização intuitiva.",
                                  "learningObjective": "Integrar matriz de Gram em solução computacional de EDP e validar melhorias.",
                                  "commonMistakes": "Ignorar escalas físicas nas unidades; superestimar precisão sem checagem de mesh."
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever de 5m com carga uniforme q=10kN/m (EI=1e6 kNm²), use funções polinomiais φ_i(x)=x^i (i=0..3). Construa G, ortogonalize, aplique Galerkin: solução deflexão máx ~0.013m vs erro 15% sem ortogonalização.",
                              "finalVerifications": [
                                "Matriz G é simétrica positiva definida (autovalores >0).",
                                "Funções pós-ortogonalização satisfazem ∫ ψ_i ψ_j dx = δ_{ij}.",
                                "Número de condição do sistema K reduzido em pelo menos 50%.",
                                "Resíduos ponderados ||r|| < 1e-6 na solução final.",
                                "Solução atende condições de contorno exatas (ex: u(0)=0, u'(0)=0).",
                                "Comparação com solução analítica exata dentro de 1% erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da matriz de Gram (erro <1e-8).",
                                "Correta implementação de ortogonalização (verificação de identidade).",
                                "Melhoria mensurável no condicionamento numérico.",
                                "Explicação clara da relevância para EDPs em engenharia civil.",
                                "Código/execução reproduzível e comentado.",
                                "Análise de erros e limitações discutida."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Decomposições matriciais (Cholesky, QR).",
                                "Programação Computacional: Integração numérica e solvers lineares.",
                                "Física Estrutural: Teoria de vigas e placas em análise civil.",
                                "Estatística: Análise de erro e condicionamento em simulações."
                              ],
                              "realWorldApplication": "Em software de análise estrutural como SAP2000 ou FEA customizado, usa-se matriz de Gram para ortogonalizar modos em análise dinâmica de pontes, reduzindo tempo computacional e erros em projetos de edifícios altos sob vento/sísmica."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Analisar condicionamento em bases ortogonais",
                            "description": "Relacionar a matriz de Gram com o número de condicionamento de matrizes em problemas de valor inicial/contorno, implementando testes numéricos para estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de condicionamento numérico e matriz de Gram",
                                  "subSteps": [
                                    "Defina o número de condicionamento κ(A) = ||A|| * ||A^{-1}|| e sua interpretação em termos de sensibilidade a erros.",
                                    "Construa a matriz de Gram G = A^T A para uma matriz A com colunas linearmente independentes.",
                                    "Calcule autovalores de G e relacione com os quadrados das normas das colunas ortogonais.",
                                    "Implemente em Python/MATLAB a computação de κ(A) usando normas 2 e inversa.",
                                    "Teste com matrizes mal condicionados (ex: Hilbert) vs bem condicionados."
                                  ],
                                  "verification": "Verifique se κ(Q) ≈ 1 para matriz ortogonal Q gerada via QR.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com NumPy/SciPy, MATLAB, notas de álgebra linear numérica.",
                                  "tips": "Use svd() para computar cond number de forma estável, evite inversão direta.",
                                  "learningObjective": "Compreender como o condicionamento afeta estabilidade numérica e papel da matriz Gram.",
                                  "commonMistakes": "Confundir norma de Frobenius com norma 2; ignorar escala das matrizes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar condicionamento em bases ortogonais usando processo Gram-Schmidt",
                                  "subSteps": [
                                    "Aplique Gram-Schmidt para ortogonalizar colunas de A, obtendo Q ortonormal.",
                                    "Compute G = Q^T Q ≈ I (identidade) e verifique κ(Q) = 1.",
                                    "Compare κ(A) original com κ(Q) e R da decomposição QR = A.",
                                    "Implemente numericamente em código, medindo erros de arredondamento.",
                                    "Visualize espectro de autovalores de G antes/depois ortogonalização."
                                  ],
                                  "verification": "Confirme que ||Q^T Q - I|| < 1e-10 e κ(Q) < 1.01.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Código Python (numpy.linalg.qr), exemplos de matrizes 10x10.",
                                  "tips": "Modifique Gram-Schmidt clássico para versão modificada (estável).",
                                  "learningObjective": "Relacionar matriz Gram com condicionamento ideal em bases ortogonais.",
                                  "commonMistakes": "Perda de ortogonalidade por erros de ponto flutuante; não normalizar colunas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar conceitos em problemas de valor inicial/contorno (IVP/BVP)",
                                  "subSteps": [
                                    "Modele um BVP simples da engenharia civil, ex: equação de viga Euler-Bernoulli discretizada em matriz A.",
                                    "Gere matrizes de discretização (diferenças finitas) e compute sua Gram e κ(A).",
                                    "Ortogonalize basis via QR e resolva sistema Ax=b antes/depois.",
                                    "Analise impacto no erro de solução para perturbações em b ou A.",
                                    "Compare com métodos espectrais que usam bases ortogonais nativas."
                                  ],
                                  "verification": "Resolução de Ax=b com ||x - x_ort|| / ||x|| < 1e-6 após ortogonalização.",
                                  "estimatedTime": "4 horas",
                                  "materials": "SciPy para solve_ivp/ODE solvers, matrizes de rigidez de elementos finitos.",
                                  "tips": "Use malha uniforme para BVP; escale matrizes para cond ~1e6 inicialmente.",
                                  "learningObjective": "Conectar condicionamento ortogonal a estabilidade em problemas de engenharia.",
                                  "commonMistakes": "Não considerar boundary conditions no condicionamento; ignorar simetria."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e interpretar testes numéricos para estabilidade",
                                  "subSteps": [
                                    "Desenvolva script para testes: adicione ruído gaussiano a A/b, meça ||Δx||/||x|| vs κ(A).",
                                    "Execute Monte Carlo com 100 runs, plote erro relativo vs log(κ).",
                                    "Compare estabilidade em bases não-ortogonais vs ortogonais em IVP (ex: Runge-Kutta).",
                                    "Gere relatório com gráficos de cond number e erros de propagação.",
                                    "Otimize via preconditioning com QR para reduzir κ efetivo."
                                  ],
                                  "verification": "Testes mostram correlação linear log-erro vs log-κ, com melhora >90% pós-ortogonalização.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Matplotlib para plots, Jupyter Notebook para relatórios.",
                                  "tips": "Use cond=svdvals.max/svdvals.min para precisão.",
                                  "learningObjective": "Executar análises numéricas práticas para validar estabilidade.",
                                  "commonMistakes": "Ruído muito pequeno (use 1e-8 * ||A||); não normalizar erros."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar análise e propor melhorias em contextos computacionais",
                                  "subSteps": [
                                    "Resuma achados: como Gram indica bases ruins e QR melhora condicionamento.",
                                    "Proponha uso em FEM para engenharia civil (ex: evitar ill-conditioning em malhas).",
                                    "Teste em caso real: matriz de massa/rigidez de treliça.",
                                    "Discuta limitações (custo computacional de QR para n grande).",
                                    "Documente pipeline completo em repositório GitHub."
                                  ],
                                  "verification": "Relatório final com κ reduzido em > fator 10^3 e código reproduzível.",
                                  "estimatedTime": "2 horas",
                                  "materials": "GitHub, LaTeX/PDF para relatório.",
                                  "tips": "Automatize com funções modulares para reutilização.",
                                  "learningObjective": "Integrar conceitos em workflow de engenharia computacional.",
                                  "commonMistakes": "Generalizar demais sem dados numéricos; omitir trade-offs."
                                }
                              ],
                              "practicalExample": "Em análise de uma treliça 2D com 10 nós (matriz de rigidez 20x20 mal condicionado κ≈10^8 devido a elementos alongados), aplique QR: G original tem autovalores de 10^{-10} a 10^8; pós-QR, κ(Q)=1, reduzindo erro em deslocamentos de 15% para 0.1% sob ruído de sensores.",
                              "finalVerifications": [
                                "Computar corretamente κ(A) e G para matriz dada.",
                                "Gerar base ortogonal com QR e verificar Q^T Q = I.",
                                "Demonstrar redução de erro em solução de BVP com/ sem ortogonalização.",
                                "Interpretar plots de erro vs condicionamento.",
                                "Propor aplicação em problema de engenharia civil real.",
                                "Código executável sem erros numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erros <1e-8 em verificações ortogonalidade.",
                                "Compreensão conceitual: explicação clara de Gram-cond relation.",
                                "Implementação código: eficiente, comentado, reproduzível.",
                                "Análise testes: identificação de causas de ill-conditioning.",
                                "Criatividade aplicação: ligação relevante a civ engenharia.",
                                "Relatório qualidade: gráficos claros, conclusões fundamentadas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica (Python/SciPy para álgebra linear).",
                                "Análise Numérica (estabilidade métodos diferenciais).",
                                "Engenharia de Estruturas (FEM, matrizes rigidez).",
                                "Estatística (análise erro Monte Carlo).",
                                "Física Computacional (simulações dinâmicas IVP)."
                              ],
                              "realWorldApplication": "Em simulações FEM para projetos de pontes/predios, usar análise Gram/QR detecta e corrige ill-conditioning em malhas irregulares, evitando colapsos preditivos errôneos por instabilidade numérica, como visto em software ANSYS/ABAQUS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Autovalores e Autofunções",
                "description": "Métodos numéricos para cálculo de autovalores e autofunções de matrizes.",
                "totalSkills": 42,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Definição de Autovalores e Autofunções",
                    "description": "Conceitos fundamentais de autovalores e autofunções de matrizes, incluindo o problema de autovalores generalizado.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Definição de Autovalor e Autovetor",
                        "description": "Conceito fundamental de autovalor (λ) e autovetor (v) de uma matriz quadrada A, definido pela equação A v = λ v, onde v ≠ 0, representando direções invariantes sob transformação linear.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Reconhecer a definição formal",
                            "description": "Identificar e enunciar corretamente a definição matemática de autovalor e autovetor para uma matriz quadrada A ∈ ℝ^{n×n}, incluindo a condição de v não ser o vetor nulo e a interpretação geométrica como escalonamento em direção própria.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de álgebra linear",
                                  "subSteps": [
                                    "Lembre-se da definição de matriz quadrada A ∈ ℝ^{n×n}.",
                                    "Revise a multiplicação de matriz por vetor: Av.",
                                    "Identifique o que significa um vetor ser transformado por uma matriz.",
                                    "Diferencie vetores coluna e linha no contexto.",
                                    "Pratique com uma matriz 2x2 simples."
                                  ],
                                  "verification": "Resolva Av para uma matriz 2x2 e vetor simples; resultado deve coincidir com cálculo manual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Video introdutório de álgebra linear (Khan Academy)"
                                  ],
                                  "tips": "Use notação vetorial consistente (coluna).",
                                  "learningObjective": "Compreender pré-requisitos para definir autovalores.",
                                  "commonMistakes": "Confundir multiplicação escalar com matricial; esquecer transposição."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e enunciar a definição formal",
                                  "subSteps": [
                                    "Leia a definição: λ é autovalor se existe v ≠ 0 tal que Av = λv.",
                                    "Escreva a equação rearranjada: (A - λI)v = 0.",
                                    "Enuncie verbalmente: 'Autovetor é direção inalterada exceto por escala'.",
                                    "Copie a definição 3 vezes de memória.",
                                    "Explique para um parceiro ou grave áudio."
                                  ],
                                  "verification": "Escreva a definição exata sem olhar; compare com original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou papel",
                                    "Livro de álgebra linear (ex: Strang)",
                                    "Gravador de voz no celular"
                                  ],
                                  "tips": "Associe λ a 'fator de escala' e v a 'direção própria'.",
                                  "learningObjective": "Enunciar precisamente a definição matemática.",
                                  "commonMistakes": "Esquecer v ≠ 0; confundir com kernel de A."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a condição de v não nulo e exemplos iniciais",
                                  "subSteps": [
                                    "Entenda por que v=0 sempre satisfaz Av=λv, mas é trivial.",
                                    "Calcule para matriz identidade: todo vetor é autovetor com λ=1.",
                                    "Teste matriz diagonal: autovalores são diagonais, autovetores eixos padrão.",
                                    "Verifique falha: para v=0, Av=0=λ*0 para qualquer λ.",
                                    "Liste 3 exemplos onde v≠0 funciona."
                                  ],
                                  "verification": "Identifique corretamente autovetores não-nulos em matriz diagonal 2x2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software Python com NumPy ou MATLAB",
                                    "Matriz de exemplo impressa"
                                  ],
                                  "tips": "Sempre normalize v para |v|=1 em verificações.",
                                  "learningObjective": "Aplicar condição essencial de não-trivialidade.",
                                  "commonMistakes": "Aceitar v=0 como autovetor; ignorar singularidade de (A-λI)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender a interpretação geométrica",
                                  "subSteps": [
                                    "Visualize Av = λv como alongamento/escala na direção v.",
                                    "Desenhe para matriz escalonamento: elipse vira elipse alongada na direção própria.",
                                    "Compare com rotação: sem autovetores reais em ℝ².",
                                    "Simule em GeoGebra ou Desmos para n=2.",
                                    "Descreva: 'Direção própria permanece a mesma, só escala'."
                                  ],
                                  "verification": "Desenhe transformação geométrica correta para matriz [[2,0],[0,1]] e vetor [1,0].",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta GeoGebra ou Desmos",
                                    "Papel milimetrado",
                                    "Vídeo de visualização linear algebra (3Blue1Brown)"
                                  ],
                                  "tips": "Pense em 'setas que apontam na mesma direção após transformação'.",
                                  "learningObjective": "Interpretar geometricamente o conceito.",
                                  "commonMistakes": "Confundir com reflexão ou rotação pura."
                                }
                              ],
                              "practicalExample": "Para A = [[3,1],[1,3]] (matriz simétrica 2x2), autovalores λ=4 e 2 com autovetores [1,1] e [1,-1]. Verifique: A[1,1]^T = 4[1,1]^T (escala por 4 na diagonal), e geometricamente alonga a linha y=x por 4 e y=-x por 2.",
                              "finalVerifications": [
                                "Enuncie a definição completa sem erros.",
                                "Explique por que v≠0 é crucial.",
                                "Identifique autovalores/autovetores em matriz diagonal.",
                                "Descreva interpretação geométrica para escalonamento.",
                                "Resolva (A - λI)v=0 para exemplo dado.",
                                "Diferencie de transformação genérica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na enunciação da definição (incluindo notação).",
                                "Correta justificativa da condição v≠0.",
                                "Exemplos válidos com verificação numérica.",
                                "Descrição geométrica intuitiva e precisa.",
                                "Uso correto de terminologia (autovalor vs autovetor).",
                                "Ausência de confusões com conceitos relacionados (ex: traço, determinante)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração em estruturas (engenharia civil).",
                                "Computação: Análise de componentes principais (PCA) em dados.",
                                "Engenharia: Estabilidade de sistemas dinâmicos (vibrações de pontes).",
                                "Geometria: Transformações lineares e simetrias."
                              ],
                              "realWorldApplication": "Em engenharia civil, autovalores determinam frequências naturais de vibração de edifícios/pontes via análise modal, permitindo prever ressonâncias em terremotos e otimizar projetos estruturais com software como ANSYS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Calcular autovalores de matrizes 2x2",
                            "description": "Resolver o polinômio característico det(A - λI) = 0 para matrizes 2x2, encontrando as raízes λ e associando autovetores resolvendo (A - λI)v = 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir a matriz A - λI para uma matriz 2x2 dada",
                                  "subSteps": [
                                    "Escreva a matriz A = [[a, b], [c, d]]",
                                    "Forme a matriz identidade I = [[1, 0], [0, 1]]",
                                    "Multiplique I por λ: λI = [[λ, 0], [0, λ]]",
                                    "Subtraia λI de A: A - λI = [[a-λ, b], [c, d-λ]]",
                                    "Verifique a forma simbólica da matriz resultante"
                                  ],
                                  "verification": "Confirme que A - λI está corretamente formada comparando com a definição padrão",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para verificação numérica opcional"
                                  ],
                                  "tips": "Sempre use parênteses ou destaque λ para evitar confusão com subtração",
                                  "learningObjective": "Dominar a construção simbólica de A - λI para matrizes 2x2",
                                  "commonMistakes": [
                                    "Esquecer de subtrair λ da diagonal",
                                    "Confundir ordem de subtração (A - λI vs λI - A)",
                                    "Erros de sinal em off-diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o determinante det(A - λI) para obter o polinômio característico",
                                  "subSteps": [
                                    "Aplique a fórmula det([[p, q], [r, s]]) = ps - qr onde p=a-λ, q=b, r=c, s=d-λ",
                                    "Expanda: det = (a-λ)(d-λ) - bc",
                                    "Simplifique: ad - aλ - dλ + λ² - bc = λ² - (a+d)λ + (ad - bc)",
                                    "Identifique coeficientes: λ² - (tr(A))λ + det(A)",
                                    "Escreva o polinômio como det(A - λI) = 0"
                                  ],
                                  "verification": "O polinômio deve ser quadrático na forma λ² - (trace)λ + det(A) = 0",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de fórmulas de determinantes"
                                  ],
                                  "tips": "Lembre-se: det(A) = ad - bc é invariante",
                                  "learningObjective": "Calcular precisamente o polinômio característico de ordem 2",
                                  "commonMistakes": [
                                    "Erro no sinal do produto cruzado bc",
                                    "Esquecer o λ² positivo",
                                    "Confundir trace com det"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o polinômio característico para encontrar os autovalores λ",
                                  "subSteps": [
                                    "Use a fórmula quadrática λ = [trace ± sqrt(trace² - 4 det(A))] / 2",
                                    "Calcule o discriminante Δ = (a+d)² - 4(ad - bc)",
                                    "Se Δ > 0: dois autovalores reais distintos; Δ=0: autovalor repetido; Δ<0: complexos",
                                    "Calcule λ1 e λ2 numericamente para uma matriz exemplo",
                                    "Verifique somando λ1 + λ2 = trace(A) e multiplicando λ1*λ2 = det(A)"
                                  ],
                                  "verification": "Some e multiplique os λ encontrados e compare com trace e det de A",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para cálculos algébricos"
                                  ],
                                  "tips": "Sempre verifique a soma e produto como teste rápido",
                                  "learningObjective": "Resolver equações quadráticas aplicadas a autovalores",
                                  "commonMistakes": [
                                    "Erro na fórmula quadrática (esquecer /2)",
                                    "Sinal errado no discriminante",
                                    "Não verificar propriedades soma/produto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Encontrar autovetores associando a cada λ resolvendo (A - λI)v = 0",
                                  "subSteps": [
                                    "Para cada λi, forme Ai = A - λi I",
                                    "Resolva o sistema [[p, q], [r, s]] [x, y]^T = [0, 0]^T",
                                    "Como det(Ai)=0, as linhas são linearmente dependentes; use uma equação não-trivial",
                                    "Escolha x=1 (se possível) e resolva para y, ou vice-versa; normalize se desejar",
                                    "Verifique: A v = λ v multiplicando matriz-vetor"
                                  ],
                                  "verification": "Confirme A v = λ v para cada vetor encontrado",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Software como Python/NumPy opcional"
                                  ],
                                  "tips": "Para matrizes 2x2, sempre há uma equação livre; evite divisão por zero",
                                  "learningObjective": "Associar autovetores corretamente a autovalores",
                                  "commonMistakes": [
                                    "Usar λ errado na subtração",
                                    "Não verificar A v = λ v",
                                    "Vetores zero ou não normalizados"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[2, 1], [1, 2]]: trace=4, det=3. Polinômio: λ²-4λ+3=0 → λ=3,1. Para λ=3: [[-1,1],[1,-1]]v=0 → v1=[1,1]. Para λ=1: [[1,1],[1,1]]v=0 → v2=[1,-1]. Verifique: A[1,1]=[3,3]=3[1,1]; A[1,-1]=[1,1]=1[1,-1].",
                              "finalVerifications": [
                                "Forma corretamente A - λI para qualquer 2x2",
                                "Calcula polinômio característico sem erros algébricos",
                                "Resolve λ usando fórmula quadrática com verificação soma/produto",
                                "Encontra autovetores não-nulos e verifica A v = λ v",
                                "Aplica a um exemplo completo sem calculadora",
                                "Identifica casos especiais (Δ=0 ou complexo)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção simbólica de A - λI (100%)",
                                "Correção do polinômio característico e coeficientes",
                                "Exatidão na resolução quadrática e verificações",
                                "Validade dos autovetores (não-zero e satisfaz equação)",
                                "Eficiência nos cálculos e ausência de erros comuns",
                                "Capacidade de generalizar para matrizes arbitrárias"
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de modos normais em vibrações estruturais",
                                "Computação: Implementação em algoritmos como power method",
                                "Engenharia Mecânica: Estabilidade de sistemas dinâmicos",
                                "Matemática Aplicada: Diagonalização de matrizes",
                                "Estatística: Análise de componentes principais (PCA)"
                              ],
                              "realWorldApplication": "Em engenharia civil, calcular autovalores de matrizes de rigidez determina frequências naturais de edifícios e pontes, prevendo ressonâncias sísmicas e otimizando projetos contra colapsos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Interpretar geometricamente autovetores",
                            "description": "Explicar como autovetores representam direções inalteradas (apenas escaladas) pela multiplicação pela matriz, com exemplos em transformações lineares como rotações e alongamentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de vetores e transformações lineares",
                                  "subSteps": [
                                    "Represente vetores como setas no plano cartesiano 2D.",
                                    "Aplique uma matriz simples de rotação a um vetor e observe a mudança de direção.",
                                    "Aplique uma matriz de alongamento diagonal e note as direções afetadas diferentemente.",
                                    "Compare o vetor original com sua imagem após a transformação.",
                                    "Desenhe pelo menos três exemplos de transformações lineares."
                                  ],
                                  "verification": "Desenhar e rotular vetores antes e depois da transformação, confirmando visualmente as mudanças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e régua",
                                    "GeoGebra ou Desmos (opcional)"
                                  ],
                                  "tips": "Use cores diferentes para vetores originais e transformados para facilitar a visualização.",
                                  "learningObjective": "Compreender geometricamente como matrizes alteram direções e magnitudes de vetores.",
                                  "commonMistakes": [
                                    "Confundir rotação com reflexão",
                                    "Ignorar a origem na representação vetorial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a definição algébrica de autovetores",
                                  "subSteps": [
                                    "Lembre a equação Av = λv, onde A é a matriz, v o autovetor e λ o autovalor.",
                                    "Resolva para um autovetor simples: encontre v não nulo tal que A v = λ v.",
                                    "Verifique que v ≠ 0 e que a direção é preservada (só escala por λ).",
                                    "Calcule para uma matriz diagonal como [[2,0],[0,3]].",
                                    "Identifique autovetores como [1,0] e [0,1]."
                                  ],
                                  "verification": "Resolver manualmente para uma matriz 2x2 e confirmar que Av = λv.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de exercícios com matrizes",
                                    "Software MATLAB ou Python (NumPy)"
                                  ],
                                  "tips": "Sempre normalize o autovetor para facilitar comparações geométricas.",
                                  "learningObjective": "Dominar a definição algébrica e diferenciá-la de vetores comuns.",
                                  "commonMistakes": [
                                    "Aceitar v=0 como autovetor",
                                    "Confundir autovalor com determinante"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar geometricamente a ação da matriz sobre autovetores",
                                  "subSteps": [
                                    "Visualize que o autovetor aponta para uma direção inalterada pela matriz.",
                                    "Aplique a matriz ao autovetor e observe que ele 'estica' ou 'encolhe' apenas na mesma direção.",
                                    "Compare com vetores não-autovetores, que mudam de direção.",
                                    "Desenhe a transformação em um eixo alinhado com o autovetor.",
                                    "Explique verbalmente: 'A matriz preserva a direção, apenas escala por λ'."
                                  ],
                                  "verification": "Plotar gráfico mostrando autovetor inalterado em direção e vetor genérico desviado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "GeoGebra para plotar matrizes",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Pense em 'esteiras rolantes': autovetores são direções que só aceleram, sem desvio lateral.",
                                  "learningObjective": "Conectar algebraicamente a interpretação visual de direções invariantes.",
                                  "commonMistakes": [
                                    "Pensar que autovetor não muda de magnitude",
                                    "Ignorar autovalores negativos (inversão)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a interpretação em exemplos de transformações lineares",
                                  "subSteps": [
                                    "Exemplo de alongamento: matriz [[2,0],[0,1]] – autovetores eixos x e y.",
                                    "Exemplo de rotação: matriz de 90° tem autovetores complexos, mas discuta reais aproximados.",
                                    "Exemplo de cisalhamento: [[1,1],[0,1]] – encontre autovetor.",
                                    "Visualize e descreva cada caso geometricamente.",
                                    "Gere um relatório com desenhos e explicações."
                                  ],
                                  "verification": "Produzir três diagramas com autovetores destacados e descrições corretas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de graficação (GeoGebra/MATLAB)",
                                    "Modelos impressos de matrizes"
                                  ],
                                  "tips": "Comece com matrizes simétricas para autovetores ortogonais reais.",
                                  "learningObjective": "Aplicar o conceito a transformações comuns como rotações e alongamentos.",
                                  "commonMistakes": [
                                    "Assumir todos autovetores reais em rotações",
                                    "Não escalar corretamente por λ"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz de alongamento A = [[2, 0], [0, 0.5]]. O vetor v = [1, 0] é autovetor com λ=2, pois A v = [2, 0] = 2v – alonga na direção x sem desvio. Já w = [0,1] tem λ=0.5, encolhendo na y. Vetor genérico [1,1] vira [2, 0.5], mudando direção.",
                              "finalVerifications": [
                                "Explicar corretamente que autovetores definem direções invariantes escaladas.",
                                "Identificar autovetores em um gráfico de transformação linear.",
                                "Diferenciar autovetores de vetores que mudam direção.",
                                "Aplicar a matriz a um autovetor e verificar Av = λv visual e algebricamente.",
                                "Descrever exemplos de rotações e alongamentos.",
                                "Reconhecer impacto de autovalores negativos (inversão de direção)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição algébrica e geométrica (correta em 100%).",
                                "Clareza nos diagramas e visualizações (rótulos completos).",
                                "Profundidade nos exemplos (pelo menos 3 transformações).",
                                "Correção nos cálculos de Av = λv.",
                                "Capacidade de explicar verbalmente sem erros conceituais.",
                                "Integração de dicas para evitar erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração em estruturas (análise modal).",
                                "Engenharia Mecânica: Direções principais de tensão e deformação.",
                                "Computação: Algoritmos PCA para redução de dimensionalidade em dados.",
                                "Gráficos Computacionais: Transformações em renderização 3D."
                              ],
                              "realWorldApplication": "Na engenharia civil, autovetores identificam direções principais de deformação em vigas e lajes sob carga, permitindo análise de estabilidade e vibrações modais em pontes e edifícios via métodos numéricos como elementos finitos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Problema de Autovalores Generalizado",
                        "description": "Generalização do problema padrão para equações da forma A v = λ B v, onde A e B são matrizes quadradas, B simétrica definida positiva, comum em problemas de engenharia como análise modal em estruturas civis.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Enunciar a definição do problema generalizado",
                            "description": "Descrever o problema generalizado A v = λ B v, destacando diferenças em relação ao problema padrão (B = I), condições para existência de autovalores reais e o papel da matriz de Gram ou condicionamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar o problema de autovalores padrão",
                                  "subSteps": [
                                    "Defina o problema padrão como encontrar escalar λ (autovalor) e vetor v ≠ 0 (autovetor) tal que A v = λ v",
                                    "Reescreva a equação como A v = λ I v, onde I é a matriz identidade",
                                    "Explique que I é simétrica positiva definida, garantindo autovalores reais para A simétrica",
                                    "Dê um exemplo simples: para A 2x2 diagonal, autovalores são os elementos da diagonal",
                                    "Verifique matematicamente: (A - λ I) v = 0 com v ≠ 0"
                                  ],
                                  "verification": "Escrever corretamente a equação A v = λ I v e identificar I como identidade",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de álgebra linear (ex: Strang), calculadora ou software como MATLAB",
                                  "tips": "Sempre normalize v para |v| = 1 para facilitar comparações",
                                  "learningObjective": "Compreender a formulação base do problema padrão como pré-requisito",
                                  "commonMistakes": "Confundir autovalor com traço da matriz ou assumir v unitário sem especificar"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar a definição do problema de autovalores generalizado",
                                  "subSteps": [
                                    "Defina o problema generalizado: encontrar λ e v ≠ 0 tal que A v = λ B v",
                                    "Especifique que A e B são matrizes n x n, com B simétrica positiva definida",
                                    "Reescreva como (A - λ B) v = 0, análogo ao padrão mas com B no lugar de I",
                                    "Introduza notação: problema generalizado de autovalores (GEP)",
                                    "Destaque que v é autovetor generalizado"
                                  ],
                                  "verification": "Formular verbalmente e por escrito 'A v = λ B v' com condições em B",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Notas de aula sobre autovalores, quadro branco ou papel para equações",
                                  "tips": "Use negrito ou sublinhado para diferenciar A v = λ B v do padrão",
                                  "learningObjective": "Dominar a enunciação precisa da equação generalizada",
                                  "commonMistakes": "Esquecer de especificar v ≠ 0 ou assumir B = I implicitamente"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Destacar diferenças em relação ao problema padrão",
                                  "subSteps": [
                                    "Compare: no padrão, B = I (única e fixa); no generalizado, B varia e é parte do problema",
                                    "Note que o generalizado surge em aplicações físicas onde B representa massa/inércia",
                                    "Explique que soluções requerem B invertível para transformar em padrão (B^{-1} A v = λ v)",
                                    "Discuta singularidade: se B singular, problema mais complexo (deflacionado)",
                                    "Ilustre com dimensão: ambos n x n, mas autovalores dependem de ambos A e B"
                                  ],
                                  "verification": "Listar pelo menos 3 diferenças chave em uma tabela comparativa",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou software (Excel/MATLAB) para tabelas, exemplos matriciais",
                                  "tips": "Pense em B como 'peso' que modifica os autovalores de A",
                                  "learningObjective": "Identificar e articular distinções fundamentais entre os problemas",
                                  "commonMistakes": "Ignorar o papel de B como não-identidade ou confundir com autovalores de A sozinho"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar condições para autovalores reais e papel da matriz de Gram/condicionamento",
                                  "subSteps": [
                                    "Estabeleça condição: se A e B simétricas e B positiva definida, autovalores reais",
                                    "Defina matriz de Gram: G = V^T B V, onde V ortogonal em produto B-interno",
                                    "Explique condicionamento: cond(B) alto leva a instabilidade numérica em algoritmos",
                                    "Discuta teorema: autovalores reais e autovetores B-ortogonais se condições atendidas",
                                    "Aplique: em engenharia, B = massa garante positiva definida para estabilidade"
                                  ],
                                  "verification": "Enunciar teorema de existência e explicar impacto do condicionamento numérico",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software numérico (MATLAB eig(A,B)), referências teóricas (Golub-Van Loan)",
                                  "tips": "Verifique positiva definida com autovalores de B > 0",
                                  "learningObjective": "Compreender condições teóricas e implicações práticas",
                                  "commonMistakes": "Assumir autovalores reais sem B positiva definida ou ignorar efeitos numéricos"
                                }
                              ],
                              "practicalExample": "Em análise estrutural, considere A (matriz de rigidez 2x2: [[4, -2], [-2, 4]]) e B (matriz de massa: [[2, 0], [0, 1]]). Resolva A v = λ B v para frequências naturais: λ1 ≈ 1.17, v1 ≈ [0.85, 0.53]; λ2 ≈ 2.5, v2 ≈ [-0.53, 0.85]. Note como B modifica modos em relação a B=I.",
                              "finalVerifications": [
                                "Enunciar corretamente A v = λ B v com v ≠ 0",
                                "Listar 3 diferenças principais do problema padrão",
                                "Citar condições para autovalores reais (B positiva definida)",
                                "Explicar papel da matriz de Gram em ortogonalidade",
                                "Discutir impacto do condicionamento em soluções numéricas",
                                "Resolver um exemplo 2x2 simples manualmente"
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática (100% correto)",
                                "Completude das diferenças e condições (cobertura >90%)",
                                "Clareza na explicação verbal/escrita",
                                "Correta identificação de papéis teóricos (Gram/condicionamento)",
                                "Uso apropriado de exemplos e verificações",
                                "Profundidade conceitual sem erros comuns"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos de vibração em dinâmica estrutural (equações de movimento)",
                                "Computação: Algoritmos numéricos como QZ para GEP",
                                "Estatística: Análise de componentes principais generalizadas",
                                "Engenharia Mecânica: Análise modal de vibrações"
                              ],
                              "realWorldApplication": "Na engenharia civil, o problema generalizado modela frequências naturais de edifícios (A=rigidez, B=massa), essencial para design sísmico e evitar ressonâncias em pontes ou arranha-céus."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Transformar problema generalizado em padrão",
                            "description": "Aplicar decomposição espectral ou Cholesky em B para reduzir o problema generalizado a um problema padrão de autovalores, ilustrando com exemplo numérico simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema de Autovalores Generalizado",
                                  "subSteps": [
                                    "Defina o problema generalizado como Ax = λBx, onde A e B são matrizes simétricas n×n, B positiva definida.",
                                    "Explique a diferença entre problema padrão (Bx = λx) e generalizado.",
                                    "Verifique as propriedades necessárias: A simétrica, B simétrica positiva definida.",
                                    "Discuta quando usar decomposição espectral vs. Cholesky (Cholesky para B SPD).",
                                    "Esboce a transformação geral: reduzir a generalizado para padrão."
                                  ],
                                  "verification": "Escreva a definição e propriedades em um resumo de 1 parágrafo e confirme com fórmulas corretas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de álgebra linear ou notas de aula",
                                    "Calculadora para testes simples"
                                  ],
                                  "tips": "Sempre verifique se B é positiva definida computando autovalores ou teste de Cholesky.",
                                  "learningObjective": "Identificar e formular corretamente o problema de autovalores generalizado e suas premissas.",
                                  "commonMistakes": [
                                    "Confundir com problema padrão",
                                    "Ignorar que B deve ser positiva definida",
                                    "Esquecer simetria das matrizes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Decomposição Cholesky de B",
                                  "subSteps": [
                                    "Confirme que B é simétrica positiva definida (SPD).",
                                    "Aplique o algoritmo de Cholesky: encontre L triangular inferior tal que B = LL^T.",
                                    "Para matriz 2x2, calcule elementos de L manualmente: l11 = sqrt(b11), etc.",
                                    "Use software para matrizes maiores se necessário.",
                                    "Verifique a decomposição multiplicando LL^T e comparando com B."
                                  ],
                                  "verification": "Multiplique LL^T e confirme que resulta em B exata (erro < 10^-10).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software MATLAB/Python (numpy/scipy)",
                                    "Papel para cálculo manual",
                                    "Exemplo de matriz B 2x2"
                                  ],
                                  "tips": "Comece com matrizes pequenas para prática manual antes de software.",
                                  "learningObjective": "Executar e validar decomposição Cholesky para matriz SPD.",
                                  "commonMistakes": [
                                    "Cálculo errado de elementos de L",
                                    "Não verificar SPD antes",
                                    "Confundir L com L^T"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Transformar o Problema Generalizado em Padrão",
                                  "subSteps": [
                                    "Defina y = L^{-1}x, onde L é da decomposição Cholesky.",
                                    "Substitua na equação original: A(L y) = λ B (L y) → A L y = λ L L^T L y.",
                                    "Simplifique: L^{-T} A L y = λ y, definindo C = L^{-T} A L.",
                                    "Resulte no problema padrão C y = λ y.",
                                    "Note que autovetores originais x = L y."
                                  ],
                                  "verification": "Derive a matriz C explicitamente e confirme que Cy = λy para autovalores conhecidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software para inversas e multiplicações matriciais",
                                    "Papel para derivação algébrica"
                                  ],
                                  "tips": "Mantenha track das transformações y = L^{-1}x para não perder a relação.",
                                  "learningObjective": "Derivar a transformação algébrica de generalizado para padrão usando Cholesky.",
                                  "commonMistakes": [
                                    "Erro na substituição y",
                                    "Esquecer L^{-T} na esquerda",
                                    "Confundir autovalores (permanece λ)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com Exemplo Numérico Simples",
                                  "subSteps": [
                                    "Escolha A = [[2,1],[1,2]], B = [[2,0],[0,1]] (B SPD).",
                                    "Compute Cholesky de B: L = [[sqrt(2),0],[0,1]].",
                                    "Calcule C = L^{-T} A L.",
                                    "Resolva autovalores/padrão de C e transforme de volta para x.",
                                    "Compare com solução direta do generalizado."
                                  ],
                                  "verification": "Autovalores de C coincidem com generalizado original (erro < 0.01).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB/Python para eig",
                                    "Calculadora matricial online"
                                  ],
                                  "tips": "Use matrizes 2x2 para cálculo manual completo.",
                                  "learningObjective": "Aplicar a transformação em exemplo concreto e validar numericamente.",
                                  "commonMistakes": [
                                    "Erro numérico em inversas",
                                    "Não comparar soluções",
                                    "Matriz B não SPD"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Generalizar a Transformação",
                                  "subSteps": [
                                    "Discuta alternativa: decomposição espectral se B não SPD.",
                                    "Resolva o problema padrão Cy = λy usando métodos padrão (QR, etc.).",
                                    "Transforme autovetores de volta: x = L y.",
                                    "Analise estabilidade numérica da transformação.",
                                    "Documente o processo completo em um relatório curto."
                                  ],
                                  "verification": "Solução final satisfaz Ax = λBx original com erro residual < 10^-8.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software para verificação residual ||Ax - λBx||"
                                  ],
                                  "tips": "Sempre compute resíduo para validar.",
                                  "learningObjective": "Validar transformação e entender generalizações/alternativas.",
                                  "commonMistakes": [
                                    "Ignorar transformação de volta x = L y",
                                    "Não checar resíduo",
                                    "Assumir Cholesky sempre aplicável"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[5, 2], [2, 6]], B = [[4, 0], [0, 3]]. Cholesky: L = [[2, 0], [0, sqrt(3)]]. Então L^{-1} = [[0.5, 0], [0, 1/sqrt(3)]], L^{-T} similar. C = L^{-T} A L = [[1.5625, 1/sqrt(3)], [1/sqrt(3), 2]]. Autovalores de C: approx 0.5 e 3.5, que coincidem com generalizado.",
                              "finalVerifications": [
                                "Decomposição Cholesky B = LL^T exata.",
                                "Matriz C resulta em problema padrão Cy = λy.",
                                "Autovalores de C iguais aos do generalizado.",
                                "Autovetores transformados de volta satisfazem equação original.",
                                "Resíduo ||Ax - λBx|| < 10^-10.",
                                "Processo documentado com fórmulas e números."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação da transformação (100%).",
                                "Correção numérica da decomposição Cholesky (erro < 10^-12).",
                                "Validação completa com exemplo (autovalores coincidem).",
                                "Explicação clara de passos e verificações.",
                                "Uso correto de software e verificação de resíduos.",
                                "Generalização para casos alternativos mencionada."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos de vibração em estruturas (M ¨x + Kx = 0 → generalizado).",
                                "Programação: Implementar em Python/MATLAB para análise numérica.",
                                "Estatística: Análise de componentes principais (PCA) via generalizado.",
                                "Otimização: Problemas de autovalores em métodos iterativos."
                              ],
                              "realWorldApplication": "Em engenharia civil, transforma problemas de autovalores generalizados em vibrações de edifícios (Kx = λMx) para análise modal usando Cholesky, permitindo software como ANSYS ou SAP2000 simular frequências naturais e modos de falha estrutural."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Relacionar com problemas de engenharia civil",
                            "description": "Exemplificar aplicações em vibrações estruturais (problema de valor próprio generalizado em método dos resíduos ponderados ou problemas de contorno discretizados).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o problema de autovalores generalizado",
                                  "subSteps": [
                                    "Estudar a forma matricial do problema generalizado: (K - λM)u = 0, onde K é rigidez, M é massa e λ são autovalores.",
                                    "Explicar o significado físico: λ representa frequências quadradas em vibrações.",
                                    "Discutir linearização para solução numérica.",
                                    "Resolver um exemplo matricial simples 2x2 manualmente.",
                                    "Identificar condições de não-singularidade das matrizes."
                                  ],
                                  "verification": "Resolver corretamente um problema 2x2 e explicar o significado físico dos autovalores.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de Álgebra Linear (ex: Strang), MATLAB ou Python (NumPy/SciPy).",
                                  "tips": "Sempre verifique se as matrizes são simétricas positivas definidas para problemas reais.",
                                  "learningObjective": "Compreender a formulação matemática do problema de autovalores generalizado em contextos dinâmicos.",
                                  "commonMistakes": "Confundir autovalores com frequências angulares sem elevar à raiz quadrada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir vibrações estruturais em engenharia civil",
                                  "subSteps": [
                                    "Descrever equações de movimento: M ü + C ú + K u = F(t).",
                                    "Explicar análise modal: decomposição em modos naturais.",
                                    "Relacionar autovalores com frequências e autofunções com modos de vibração.",
                                    "Discutir importância em estruturas como pontes e edifícios.",
                                    "Analisar um caso simples de viga livre."
                                  ],
                                  "verification": "Esboçar diagrama de modos de vibração de uma viga e associar a autovalores.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software ANSYS ou MATLAB Vibration Toolbox, vídeos de vibrações estruturais (YouTube/Khan Academy).",
                                  "tips": "Visualize animações de modos para fixar conceitos.",
                                  "learningObjective": "Associar problemas dinâmicos de estruturas ao problema de autovalores.",
                                  "commonMistakes": "Ignorar amortecimento na análise inicial modal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar método dos resíduos ponderados para problemas de contorno discretizados",
                                  "subSteps": [
                                    "Explicar discretização por elementos finitos (EF) de problemas de contorno elásticos.",
                                    "Formular resíduos ponderados para equações diferenciais de vibração.",
                                    "Derivar matrizes K e M a partir de funções de forma.",
                                    "Implementar numéricamente em código para uma treliça simples.",
                                    "Comparar com soluções analíticas exatas."
                                  ],
                                  "verification": "Gerar matrizes K e M corretas para um elemento de viga e extrair autovalores.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Código MATLAB para EF (disponível online), livro 'Finite Element Procedures' de Bathe.",
                                  "tips": "Use integração numérica Gauss para eficiência em elementos maiores.",
                                  "learningObjective": "Construir problemas de autovalores generalizados via métodos numéricos em EF.",
                                  "commonMistakes": "Erros na montagem global das matrizes por falha em condições de contorno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar e analisar aplicações práticas",
                                  "subSteps": [
                                    "Modelar uma ponte pênsil simplificada com EF.",
                                    "Calcular frequências naturais e modos dominantes.",
                                    "Interpretar resultados: identificar modos críticos para vento/sísmos.",
                                    "Simular resposta dinâmica a excitação.",
                                    "Discutir otimizações baseadas em autovalores."
                                  ],
                                  "verification": "Produzir gráfico de modos de vibração e tabela de frequências com interpretação.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software gratuito FreeFEM ou MATLAB PDE Toolbox.",
                                  "tips": "Normalize autofunções para facilitar comparação.",
                                  "learningObjective": "Aplicar conceitos a cenários reais de engenharia civil.",
                                  "commonMistakes": "Superestimar rigidez sem validar malha EF."
                                }
                              ],
                              "practicalExample": "Em uma ponte estaiada, discretize a laje com elementos finitos, monte K e M usando resíduos ponderados, resolva o problema generalizado para obter frequências naturais (ex: 1.2 Hz para modo fundamental) e modos, verificando estabilidade aerodinâmica.",
                              "finalVerifications": [
                                "Explicar verbalmente a relação entre autovalores e frequências de vibração.",
                                "Montar matrizes K e M para um sistema 3 graus de liberdade.",
                                "Interpretar 3 primeiros modos de uma estrutura simples.",
                                "Comparar solução numérica com analítica em erro <5%.",
                                "Identificar 2 riscos sísmicos baseados nos autovalores.",
                                "Implementar código funcional para extração de autovalores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação do problema generalizado (80% correto).",
                                "Correção na implementação numérica (matrizes simétricas).",
                                "Profundidade na interpretação física dos resultados.",
                                "Criatividade em exemplos de engenharia civil reais.",
                                "Clareza em gráficos e relatórios de modos.",
                                "Integração de métodos como resíduos ponderados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e métodos numéricos (EF).",
                                "Física: Dinâmica e mecânica dos sólidos.",
                                "Engenharia Mecânica: Análise de vibrações em máquinas.",
                                "Computação: Programação científica (MATLAB/Python).",
                                "Gestão de Projetos: Avaliação de riscos estruturais."
                              ],
                              "realWorldApplication": "No projeto de edifícios altos em zonas sísmicas, como o Burj Khalifa, análise modal via autovalores generalizados identifica modos de torção e flexão, otimizando contraventamentos para evitar ressonância com ventos ou terremotos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.4",
                            "name": "Verificar ortogonalidade em problemas generalizados",
                            "description": "Demonstrar que autovetores são ortogonais em relação à matriz B (B-ortogonais) quando B é simétrica definida positiva, usando propriedades da matriz de Gram.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema de Autovalores Generalizado e Propriedades de B",
                                  "subSteps": [
                                    "Defina o problema generalizado: Encontrar autovalores λ e autovetores v ≠ 0 tais que A v = λ B v, onde A e B são matrizes simétricas n×n e B é definida positiva.",
                                    "Explique que B simétrica definida positiva implica autovalores positivos e inversível.",
                                    "Liste propriedades chave: O problema pode ser transformado em padrão via B^{-1/2}, preservando simetria.",
                                    "Verifique simetria: A^T = A, B^T = B.",
                                    "Confirme definidade positiva de B: x^T B x > 0 para x ≠ 0."
                                  ],
                                  "verification": "Escreva as definições e propriedades em um resumo de 1 página, incluindo um exemplo 2x2 simples.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Livro de álgebra linear (ex: Strang)",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Use o produto interno induzido por B: <x,y>_B = x^T B y.",
                                  "learningObjective": "Dominar a configuração matemática do problema e papel de B.",
                                  "commonMistakes": "Assumir B = I (problema padrão) sem generalizar; ignorar que B deve ser definida positiva para ortogonalidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir e Construir a Matriz de Gram",
                                  "subSteps": [
                                    "Defina a matriz de Gram G = V^T B V, onde V é a matriz cujas colunas são autovetores v1, ..., vn.",
                                    "Mostre que para autovalores distintos, A V = B V Λ (Λ diagonal com λ_i).",
                                    "Derive V^T A V = V^T B V Λ = G Λ.",
                                    "Como A simétrica, V^T A V é simétrica; assim G Λ é simétrica.",
                                    "Conclua que G é diagonal porque Λ tem entradas distintas e G Λ simétrica implica diagonalidade."
                                  ],
                                  "verification": "Construa G para um conjunto de autovetores conhecidos e verifique se é diagonal.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Software numérico (MATLAB/Python com NumPy)",
                                    "Exemplos de matrizes de aula"
                                  ],
                                  "tips": "Normalize os autovetores para que as diagonais de G sejam 1, facilitando cálculos.",
                                  "learningObjective": "Entender o papel central da matriz de Gram na ortogonalidade.",
                                  "commonMistakes": "Esquecer que λ_i distintos são cruciais para diagonalidade; confundir G = V^T V (caso B=I)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Ortogonalidade B-Ortogonal dos Autovetores",
                                  "subSteps": [
                                    "Da diagonalidade de G, off-diagonais G_{ij} = v_i^T B v_j = 0 para i ≠ j.",
                                    "Explique B-ortogonalidade: autovetores distintos satisfazem v_i^T B v_j = 0.",
                                    "Para autovalores múltiplos, ortogonalizar via Gram-Schmidt no espaço B-interno.",
                                    "Verifique normalização: v_i^T B v_i = 1 (escolhendo escala apropriada).",
                                    "Resuma teorema: Autovetores de problema generalizado com B SPD são B-ortogonais."
                                  ],
                                  "verification": "Prove formalmente v_i^T B v_j = 0 para i ≠ j usando equações matriciais.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Quadro branco ou papel para derivação",
                                    "Referências teóricas (ex: Golub-Van Loan)"
                                  ],
                                  "tips": "Multiplique a equação generalizada à esquerda por v_j^T: v_j^T A v_i = λ_i v_j^T B v_i.",
                                  "learningObjective": "Provar a ortogonalidade usando propriedades da Gram.",
                                  "commonMistakes": "Não distinguir ortogonalidade padrão (B=I) de B-ortogonal; pular passos na simetria de G Λ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar com Exemplo Numérico e Generalizações",
                                  "subSteps": [
                                    "Escolha matrizes exemplo: A = [[5,4],[4,5]], B = [[2,1],[1,2]] (B SPD).",
                                    "Compute autovalores/autovetores numericamente.",
                                    "Calcule v_i^T B v_j para i ≠ j e confirme ≈0.",
                                    "Teste sensibilidade numérica e discuta autovalores múltiplos.",
                                    "Generalize para aplicações: Expansão em autovetores B-ortogonais."
                                  ],
                                  "verification": "Implemente em código e produza output mostrando ortogonalidade (erro < 1e-10).",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use eig() para problema generalizado: [V,D] = eig(A,B).",
                                  "learningObjective": "Aplicar a teoria em prática computacional.",
                                  "commonMistakes": "Erros numéricos por não escalar vetores; escolher B não SPD."
                                }
                              ],
                              "practicalExample": "Considere A = [[2, 1], [1, 3]], B = [[1, 0], [0, 2]] (B SPD simétrica). Autovetores v1 ≈ [0.832, 0.555], v2 ≈ [-0.555, 0.832]. Compute v1^T B v2 ≈ 0, confirmando B-ortogonalidade. Use em código para visualizar.",
                              "finalVerifications": [
                                "Prove analiticamente v_i^T B v_j = 0 para i ≠ j.",
                                "Compute numericamente para matriz 3x3 e verifique |v_i^T B v_j| < 1e-12.",
                                "Explique impacto se B não SPD.",
                                "Construa base B-ortogonal e verifique completude.",
                                "Discuta redução modal: M = V^T B V diagonal.",
                                "Teste com autovalores múltiplos usando Gram-Schmidt B."
                              ],
                              "assessmentCriteria": [
                                "Precisão da prova da diagonalidade da matriz de Gram (100% correto).",
                                "Correção numérica no exemplo (erro < 1e-10).",
                                "Explicação clara de B-ortogonalidade vs ortogonalidade padrão.",
                                "Identificação correta de condições (B SPD simétrica).",
                                "Aplicação a exemplo real com interpretação.",
                                "Tratamento de autovalores múltiplos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração em dinâmica estrutural.",
                                "Engenharia Mecânica: Análise de elementos finitos para massas/damping.",
                                "Computação: Algoritmos QZ para autovalores generalizados.",
                                "Matemática Aplicada: Espaços com produtos internos indefinidos."
                              ],
                              "realWorldApplication": "Em engenharia civil, verifica ortogonalidade de modos de vibração em edifícios (matrizes de rigidez A e massa B), permitindo decomposição modal eficiente para análise sísmica e otimização estrutural."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Método da Potência",
                    "description": "Algoritmo iterativo para encontrar o autovalor dominante e sua autofunção associada.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Definição e Propósito do Método da Potência",
                        "description": "O Método da Potência é um algoritmo iterativo utilizado para aproximar o autovalor dominante (de maior módulo) de uma matriz e sua autofunção associada, partindo de um vetor inicial arbitrário e aplicando iterações de multiplicação matricial e normalização.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Explicar o conceito de autovalor dominante",
                            "description": "Diferenciar autovalor dominante como o autovalor com maior módulo absoluto em uma matriz diagonalizável, e justificar sua importância em problemas de engenharia civil como análise de estruturas e vibrações modais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Autovalores e Autofunções",
                                  "subSteps": [
                                    "Defina autovalor λ e autofunção v para uma matriz A, onde A v = λ v.",
                                    "Explique diagonalização: A = P D P⁻¹, com D diagonal contendo autovalores.",
                                    "Discuta o espectro de autovalores: conjunto de todos os autovalores de A.",
                                    "Identifique condições para matriz diagonalizável (autovalores distintos ou multiplicidade geométrica igual à algébrica).",
                                    "Calcule autovalores de uma matriz 2x2 simples usando equação característica."
                                  ],
                                  "verification": "Resolva corretamente a equação característica de uma matriz 2x2 e liste seus autovalores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora científica",
                                    "Software MATLAB ou Python (NumPy)"
                                  ],
                                  "tips": "Sempre verifique se a matriz é quadrada antes de prosseguir.",
                                  "learningObjective": "Compreender os pré-requisitos para identificar autovalores em matrizes.",
                                  "commonMistakes": "Confundir autovalor com autofunção; esquecer que autovalores vêm da equação det(A - λI) = 0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Identificar o Autovalor Dominante",
                                  "subSteps": [
                                    "Defina autovalor dominante como o autovalor λ_d com maior módulo |λ_d| > |λ_i| para todo i ≠ d.",
                                    "Explique que em matrizes diagonalizáveis, o dominante governa o comportamento assintótico de potências de A.",
                                    "Calcule módulos absolutos de autovalores de uma matriz exemplo.",
                                    "Compare módulos para destacar o maior.",
                                    "Discuta o caso de autovalores complexos: módulo é |λ| = √(Re² + Im²)."
                                  ],
                                  "verification": "Para uma matriz dada, liste autovalores, seus módulos e identifique o dominante corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Planilha Excel ou MATLAB para cálculos numéricos"
                                  ],
                                  "tips": "Ordene autovalores por módulo decrescente para visualização clara.",
                                  "learningObjective": "Definir precisamente e reconhecer o autovalor dominante em uma matriz.",
                                  "commonMistakes": "Ignorar autovalores complexos ou negativos; confundir módulo com valor absoluto simples."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Propriedades e Comportamento do Autovalor Dominante",
                                  "subSteps": [
                                    "Descreva como iterar A^k v converge para múltiplo da autofunção dominante quando k → ∞.",
                                    "Prove qualitativamente: contribuição do dominante cresce mais rápido que outros.",
                                    "Simule numericamente com método da potência em uma matriz 3x3.",
                                    "Discuta unicidade: geralmente único em módulo, mas pode haver múltiplos com mesmo módulo.",
                                    "Analise impacto em séries de potências ou sistemas dinâmicos."
                                  ],
                                  "verification": "Execute 10 iterações do método da potência e observe convergência para autofunção dominante.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB/Python com NumPy/SciPy",
                                    "Matriz de exemplo impressa"
                                  ],
                                  "tips": "Normalize o vetor em cada iteração para evitar overflow numérico.",
                                  "learningObjective": "Entender por que o dominante 'domina' o comportamento de longo prazo.",
                                  "commonMistakes": "Não normalizar vetores; assumir convergência sem verificar unicidade do módulo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Conceito em Engenharia Civil",
                                  "subSteps": [
                                    "Relacione a matriz de rigidez/massa em análise estrutural com autovalores (frequências modais).",
                                    "Explique que o autovalor dominante corresponde à menor frequência (modo fundamental de vibração).",
                                    "Discuta análise de estabilidade: dominante indica taxa de crescimento/decaimento em estruturas dinâmicas.",
                                    "Exemplo: Torre sob vento – dominante governa resposta em ressonância.",
                                    "Justifique uso do método da potência para estimar dominante sem calcular todos autovalores."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito como o dominante afeta vibrações em uma ponte.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo ou vídeo sobre análise modal",
                                    "Software ANSYS ou similar (opcional)",
                                    "Notas de aula"
                                  ],
                                  "tips": "Ligue à física: maior |λ| significa amplitude maior em vibrações livres.",
                                  "learningObjective": "Conectar teoria matemática a problemas reais de engenharia civil.",
                                  "commonMistakes": "Confundir autovalor dominante com maior frequência (em vibrações, menor ω é dominante em certos contextos)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Verificar Compreensão",
                                  "subSteps": [
                                    "Resuma diferenças entre autovalor dominante e outros em termos de módulo e impacto.",
                                    "Crie diagrama: espectro de autovalores com destaque ao dominante.",
                                    "Discuta limitações: matrizes não diagonalizáveis (ex: Jordan blocks).",
                                    "Relacione ao método da potência: converge para dominante.",
                                    "Planeje aplicação em projeto estrutural simples."
                                  ],
                                  "verification": "Explique o conceito em 2 minutos para um colega, respondendo perguntas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quadro branco ou ferramenta de desenho digital"
                                  ],
                                  "tips": "Use analogia: dominante como 'líder de matilha' que puxa o grupo.",
                                  "learningObjective": "Integrar conhecimento para explicação fluida e aplicação contextual.",
                                  "commonMistakes": "Generalizar para matrizes não diagonalizáveis sem ressalvas."
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez normalizada de uma viga simples: A = [[2, -1], [-1, 2]]. Autovalores: λ1=3, λ2=1. Dominante λ_d=3 (|3| > |1|). Aplicando método da potência em vetor inicial [1,0], iterações convergem para autofunção [1,1], representando modo de flexão dominante em análise vibracional da viga.",
                              "finalVerifications": [
                                "Identifica corretamente o autovalor dominante em matrizes 2x2 e 3x3.",
                                "Explica convergência do método da potência para o dominante.",
                                "Relaciona dominante a menor frequência modal em estruturas.",
                                "Distingue casos diagonalizáveis vs. não-diagonalizáveis.",
                                "Aplica conceito a exemplo de engenharia civil sem erros.",
                                "Resume importância em 1 parágrafo coerente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (módulo absoluto maior): 20%",
                                "Compreensão de propriedades dinâmicas (convergência): 25%",
                                "Aplicação contextual em engenharia civil: 25%",
                                "Uso correto de exemplos numéricos: 15%",
                                "Clareza na explicação verbal/escrita: 15%"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais de vibração em mecânica estrutural.",
                                "Computação: Algoritmos iterativos como método da potência em programação numérica.",
                                "Matemática Aplicada: Sistemas lineares e estabilidade em equações diferenciais.",
                                "Engenharia Mecânica: Análise de flutter em aerodinâmica."
                              ],
                              "realWorldApplication": "Em engenharia civil, o autovalor dominante da matriz massa-ritidez determina o modo fundamental de vibração de edifícios ou pontes, essencial para design sísmico: evita ressonância com terremotos, otimizando contraventores e amortecedores para suprimir o modo dominante e prevenir colapsos como no Tacoma Narrows Bridge."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Identificar condições iniciais para aplicação",
                            "description": "Verificar se a matriz é diagonalizável e possui um autovalor dominante simples, e escolher um vetor inicial não ortogonal à autofunção dominante para garantir convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Diagonalizabilidade e Autovalor Dominante",
                                  "subSteps": [
                                    "Defina uma matriz diagonalizável: possui base de autovetores linearmente independentes.",
                                    "Explique autovalor dominante: módulo maior que os demais autovalores.",
                                    "Descreva autovalor simples: multiplicidade algébrica igual a 1.",
                                    "Discuta por que essas condições são necessárias para o Método da Potência convergir.",
                                    "Revise o teorema de diagonalização para matrizes com autovalor dominante simples."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os conceitos e sua relação com convergência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de álgebra linear",
                                    "Notas de aula sobre autovalores"
                                  ],
                                  "tips": [
                                    "Use exemplos 2x2 para visualizar; foque na intuição geométrica dos autovetores."
                                  ],
                                  "learningObjective": "Dominar definições chave para aplicação do método.",
                                  "commonMistakes": [
                                    "Confundir multiplicidade algébrica com geométrica",
                                    "Ignorar que matrizes não simétricas podem não ser diagonalizáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Diagonalizabilidade da Matriz",
                                  "subSteps": [
                                    "Calcule o polinômio característico det(A - λI) = 0.",
                                    "Encontre todos os autovalores e suas multiplicidades algébricas.",
                                    "Para cada autovalor, resolva (A - λI)v = 0 e verifique dimensão do espaço nulo (multiplicidade geométrica).",
                                    "Confirme se a soma das multiplicidades geométricas é n (dimensão da matriz).",
                                    "Conclua se a matriz é diagonalizável."
                                  ],
                                  "verification": "Mostre cálculos e afirme se diagonalizável com justificativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou software como MATLAB/Python (NumPy)",
                                    "Papel e lápis para matrizes pequenas"
                                  ],
                                  "tips": [
                                    "Para matrizes simétricas reais, são sempre diagonalizáveis; use isso como atalho inicial."
                                  ],
                                  "learningObjective": "Aplicar cálculos para verificar diagonalizabilidade.",
                                  "commonMistakes": [
                                    "Erros em determinante",
                                    "Não calcular multiplicidade geométrica corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Autovalor Dominante Simples",
                                  "subSteps": [
                                    "Liste todos os autovalores do passo anterior.",
                                    "Compare módulos |λ_i| e identifique o maior (dominante).",
                                    "Verifique se sua multiplicidade algébrica é 1 (simples).",
                                    "Confirme que |λ_dominante| > |λ_outros| estritamente para convergência rápida.",
                                    "Se não simples ou não dominante único, note que o método pode falhar."
                                  ],
                                  "verification": "Apresente lista de autovalores ordenados por módulo e destaque o dominante simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Resultados do polinômio característico do passo 2"
                                  ],
                                  "tips": [
                                    "Use aproximação de Gershgorin para estimar autovalores rapidamente."
                                  ],
                                  "learningObjective": "Reconhecer condições de autovalor para sucesso do método.",
                                  "commonMistakes": [
                                    "Considerar valor real em vez de módulo para complexos",
                                    "Ignorar multiplicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escolher e Validar Vetor Inicial Adequado",
                                  "subSteps": [
                                    "Encontre aproximadamente o autovetor dominante resolvendo (A - λ_d I)v ≈ 0.",
                                    "Escolha vetor inicial x0 com componente não nula na direção do autovetor dominante (não ortogonal).",
                                    "Verifique ortogonalidade: produto escalar x0 · v_d ≠ 0.",
                                    "Evite vetores próprios de outros autovalores como inicial.",
                                    "Teste normalizando x0 para ||x0|| = 1."
                                  ],
                                  "verification": "Mostre x0 escolhido e justifique por que não é ortogonal ao autovetor dominante.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software para produto escalar",
                                    "Autovetor aproximado"
                                  ],
                                  "tips": [
                                    "Comece com x0 = [1,1,...,1]^T; raramente ortogonal ao dominante."
                                  ],
                                  "learningObjective": "Selecionar inicial que garanta convergência.",
                                  "commonMistakes": [
                                    "Escolher x0 ortogonal acidentalmente",
                                    "Não normalizar"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[4, 1], [1, 2]], polinômio λ² - 6λ + 7 = 0 → λ1=5 (simples, dominante), λ2=1. Autovetores: v1≈[1.6,1], v2≈[-1,1.6]. Diagonalizável (2 autovetores ind.). Escolha x0=[1,0] (produto escalar com v1 >0, não ortogonal). Iterações convergem para v1.",
                              "finalVerifications": [
                                "Explica diagonalizabilidade e calcula para matriz exemplo.",
                                "Identifica corretamente autovalor dominante simples.",
                                "Escolhe x0 não ortogonal e justifica.",
                                "Prevé se condições garantem convergência.",
                                "Aplica a uma matriz 3x3 simples.",
                                "Discute falhas se condições violadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de autovalores e multiplicidades (90% correto).",
                                "Correta identificação de diagonalizabilidade com verificação geométrica.",
                                "Escolha de x0 com validação de não-ortogonalidade.",
                                "Explicação clara da relação com convergência do método.",
                                "Uso eficiente de ferramentas computacionais.",
                                "Identificação de erros comuns em exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise modal de vibrações em estruturas (frequências naturais).",
                                "Computação: Implementação numérica em Python/MATLAB para engenharia.",
                                "Estatística: Análise de componentes principais (PCA) via autovalores.",
                                "Matemática Aplicada: Estabilidade em sistemas dinâmicos lineares."
                              ],
                              "realWorldApplication": "Em engenharia civil, identifica modo de vibração dominante em pontes ou edifícios para análise sísmica, prevendo frequências fundamentais e garantindo convergência rápida em simulações computacionais de estabilidade estrutural."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Relacionar com problemas de engenharia civil",
                            "description": "Aplicar o conceito em contextos como o cálculo de frequências fundamentais em estruturas civis, onde o autovalor dominante representa o modo de vibração principal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as vibrações naturais em estruturas civis",
                                  "subSteps": [
                                    "Estude os conceitos básicos de dinâmica estrutural, focando em modos de vibração e frequências naturais.",
                                    "Identifique exemplos reais como vigas, lajes e edifícios sujeitos a cargas dinâmicas (vento, terremotos).",
                                    "Revise a equação de movimento: M ü + C ú + K u = F, simplificando para o caso livre não amortecido.",
                                    "Discuta o papel da frequência fundamental como o modo dominante em análises sísmicas.",
                                    "Pesquise casos históricos de colapsos por ressonância (ex: Ponte Tacoma Narrows)."
                                  ],
                                  "verification": "Resuma em um parágrafo como as vibrações afetam estruturas civis e liste 3 exemplos reais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Dinâmica das Estruturas (Chopra), vídeos educativos no YouTube, papel e caneta.",
                                  "tips": "Comece com analogias simples como um pêndulo para visualizar modos de vibração.",
                                  "learningObjective": "Entender o contexto físico das vibrações em engenharia civil.",
                                  "commonMistakes": "Confundir frequência natural com forçada; ignorar múltiplos modos de vibração."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o problema de vibração como equação de autovalores",
                                  "subSteps": [
                                    "Derive a equação generalizada: K φ = ω² M φ, onde ω² é o autovalor e φ o autovetor (modo).",
                                    "Explique que o autovalor dominante (maior ω²) corresponde ao modo de menor frequência.",
                                    "Monte matrizes de massa (M) e rigidez (K) para um sistema simples, como uma viga com 2 graus de liberdade.",
                                    "Generalize para sistemas maiores em estruturas civis (ex: edifício de 10 andares).",
                                    "Verifique dimensionalidade: autovalores em rad²/s² representam frequências quadradas."
                                  ],
                                  "verification": "Escreva a equação de autovalores para um sistema 2x2 e identifique o autovalor dominante.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB ou Python (NumPy), calculadora simbólica (SymPy).",
                                  "tips": "Use premultiplicação por M⁻¹ para padronizar: A φ = λ φ, com λ = 1/ω² para iteração inversa.",
                                  "learningObjective": "Modelar problemas de engenharia civil como problemas de autovalores.",
                                  "commonMistakes": "Esquecer de normalizar modos ou confundir autovalor com frequência angular."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Método da Potência para encontrar o autovalor dominante",
                                  "subSteps": [
                                    "Implemente o algoritmo: inicialize vetor x₀ arbitrário, itere x_{k+1} = A x_k / ||A x_k|| até convergência.",
                                    "Aplique shifts se necessário para outros autovalores, mas foque no dominante (maior módulo).",
                                    "Teste em um modelo simples de estrutura civil (matrizes M e K de uma viga).",
                                    "Monitore convergência pelo Rayleigh quotient: λ ≈ (x^T A x) / (x^T x).",
                                    "Implemente em código com critério de parada (tolerância 1e-6)."
                                  ],
                                  "verification": "Execute o código e confirme que o autovalor converge para o valor exato conhecido.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com NumPy/SciPy, MATLAB, exemplo de matrizes de uma estrutura real.",
                                  "tips": "Escolha vetor inicial próximo ao modo esperado para aceleração; normalize a cada iteração.",
                                  "learningObjective": "Executar numericamente o Método da Potência em problemas estruturais.",
                                  "commonMistakes": "Não normalizar vetores, levando a overflow; ignorar defasagem em modos complexos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e validar no contexto da engenharia civil",
                                  "subSteps": [
                                    "Calcule frequência fundamental: f = √λ / (2π), onde λ é o autovalor dominante.",
                                    "Compare com normas técnicas (ex: NBR 15422 para análise modal).",
                                    "Avalie implicações: período T = 1/f para dimensionamento sísmico.",
                                    "Simule variação de parâmetros (massa, rigidez) e observe impacto no modo principal.",
                                    "Documente relatório com gráficos de modos e recomendações de projeto."
                                  ],
                                  "verification": "Gere gráfico do modo de vibração e explique sua relevância para segurança estrutural.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Matplotlib), normas ABNT online.",
                                  "tips": "Valide com solução exata para sistemas pequenos antes de escalar.",
                                  "learningObjective": "Relacionar autovalores computados a decisões de engenharia prática.",
                                  "commonMistakes": "Interpretar autovalor como frequência diretamente; negligenciar amortecimento real."
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever de 10m, comprimento L=10m, módulo E=30GPa, seção I=1e-4m⁴, ρ=2500kg/m³, A=0.1m². Monte M e K discretizados em 5 elementos finitos. Aplique Método da Potência para encontrar ω₁ ≈ 3.16 rad/s (f₁ ≈ 0.5 Hz), modo principal de flexão.",
                              "finalVerifications": [
                                "O aluno explica corretamente como o autovalor dominante representa a frequência fundamental.",
                                "Implementa código funcional que converge em <20 iterações para um sistema 5x5.",
                                "Identifica o modo de vibração em gráfico e relaciona a falhas reais (ex: ressonância sísmica).",
                                "Compara resultado numérico com analítico exato (erro <1%).",
                                "Discute limitações do método em estruturas com autovalores próximos.",
                                "Aplica variação paramétrica e prevê mudança na frequência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática do problema de vibração (20%).",
                                "Correta implementação e convergência do Método da Potência (30%).",
                                "Interpretação correta dos resultados em termos de engenharia civil (25%).",
                                "Uso de exemplos reais e validação (15%).",
                                "Clareza no relatório e gráficos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Linear e métodos iterativos.",
                                "Física: Dinâmica e vibrações harmônicas.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Engenharia Mecânica: Análise modal em máquinas rotativas.",
                                "Gestão de Projetos: Normas técnicas e segurança estrutural."
                              ],
                              "realWorldApplication": "Na análise sísmica de edifícios altos, o método identifica o período fundamental para dimensionar amortecedores e evitar ressonância com terremotos, conforme usado em projetos como o Burj Khalifa ou edifícios em zonas sísmicas no Brasil."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Algoritmo do Método da Potência",
                        "description": "Descrição passo a passo do algoritmo iterativo, incluindo inicialização, multiplicação por matriz, normalização e estimativa do autovalor.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Implementar inicialização do vetor",
                            "description": "Gerar um vetor inicial aleatório ou unitário e normalizá-lo para iniciar as iterações do método da potência em software como MATLAB ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de programação",
                                  "subSteps": [
                                    "Escolha Python com biblioteca NumPy para manipulação vetorial.",
                                    "Instale NumPy via pip se necessário: `pip install numpy`.",
                                    "Abra um ambiente interativo como Jupyter Notebook ou um editor como VS Code.",
                                    "Importe as bibliotecas: `import numpy as np`.",
                                    "Teste o import executando `np.__version__`."
                                  ],
                                  "verification": "As importações funcionam sem erros e a versão do NumPy é exibida.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python 3.x instalado, pip, Jupyter Notebook ou IDE (VS Code/PyCharm)",
                                  "tips": "Use Jupyter para testes interativos e visualização imediata dos vetores.",
                                  "learningObjective": "Preparar um ambiente funcional para implementação numérica eficiente.",
                                  "commonMistakes": "Esquecer de instalar NumPy ou usar `import numpy` sem alias `np`."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir parâmetros e gerar vetor inicial aleatório ou unitário",
                                  "subSteps": [
                                    "Defina a dimensão n do vetor (ex: n=5 para matriz 5x5).",
                                    "Gere vetor aleatório: `x0 = np.random.rand(n)`.",
                                    "Alternativa unitária: `x0 = np.ones(n) / np.sqrt(n)`.",
                                    "Armazene em variável `x0_initial`.",
                                    "Imprima o vetor para inspeção: `print('Vetor inicial:', x0_initial)`."
                                  ],
                                  "verification": "O vetor gerado tem tamanho n e valores não nulos (aleatórios entre 0-1 ou todos iguais em unitário).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código Python com NumPy importado",
                                  "tips": "Prefira aleatório para convergência geral; unitário para testes determinísticos.",
                                  "learningObjective": "Gerar um vetor inicial adequado que não seja o vetor nulo para evitar falhas no método.",
                                  "commonMistakes": "Gerar vetor de zeros (`np.zeros(n)`) ou dimensão incorreta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a normalização do vetor pela norma euclidiana",
                                  "subSteps": [
                                    "Calcule a norma euclidiana: `norma = np.linalg.norm(x0_initial)`.",
                                    "Normalizado: `x0_normalized = x0_initial / norma`.",
                                    "Imprima a norma original e o vetor normalizado.",
                                    "Confirme que a norma do normalizado é 1: `print(np.linalg.norm(x0_normalized))`.",
                                    "Salve como `x0` para uso nas iterações."
                                  ],
                                  "verification": "A norma do vetor normalizado é aproximadamente 1.0 (tolerância 1e-10).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código anterior com vetor inicial gerado",
                                  "tips": "Use `np.linalg.norm` para precisão numérica; evite loops manuais.",
                                  "learningObjective": "Aplicar normalização L2 para garantir que o vetor inicial tenha magnitude unitária.",
                                  "commonMistakes": "Dividir pela norma zero (evite vetor nulo) ou usar norma errada (ex: L1)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e testar a inicialização completa",
                                  "subSteps": [
                                    "Execute o código completo múltiplas vezes para variar aleatoriedade.",
                                    "Adicione asserções: `assert abs(np.linalg.norm(x0) - 1) < 1e-10`.",
                                    "Teste com n diferente (ex: n=10).",
                                    "Documente o código com comentários.",
                                    "Prepare função reutilizável: def initialize_power_vector(n): ..."
                                  ],
                                  "verification": "Asserções passam e vetor está pronto para multiplicação por matriz A.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Código completo dos steps anteriores",
                                  "tips": "Sempre teste com `np.random.seed(42)` para reprodutibilidade.",
                                  "learningObjective": "Validar a robustez da inicialização para iterações subsequentes do método da potência.",
                                  "commonMistakes": "Ignorar erros numéricos de precisão flutuante ou não testar variações."
                                }
                              ],
                              "practicalExample": "Em Python:\n```python\nimport numpy as np\nn = 5\nx0_initial = np.random.rand(n)\nnorma = np.linalg.norm(x0_initial)\nx0 = x0_initial / norma\nprint('Norma:', np.linalg.norm(x0))  # ~1.0\n```\nSaída: Vetor unitário pronto para A @ x0 no método da potência. Similar em MATLAB: `x0 = rand(n,1); x0 = x0 / norm(x0);`.",
                              "finalVerifications": [
                                "Norma euclidiana do vetor final é exatamente 1 (tolerância 1e-12).",
                                "Dimensão do vetor corresponde à da matriz A.",
                                "Vetor não contém apenas zeros.",
                                "Código executa sem erros em múltiplas rodadas.",
                                "Função inicializadora é reutilizável e testada.",
                                "Comentários explicam cada linha crítica."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: normalização L2 aplicada adequadamente.",
                                "Eficiência: uso de funções vetoriais NumPy sem loops.",
                                "Robustez: tratamento de casos edge (n=1, vetor quase nulo).",
                                "Clareza: código comentado e legível.",
                                "Testes: verificações automáticas incluídas.",
                                "Flexibilidade: suporta aleatório e unitário."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: compreensão de normas vetoriais e propriedades de autovetores.",
                                "Programação Computacional: manipulação eficiente de arrays com NumPy/MATLAB.",
                                "Estatística: geração de números pseudo-aleatórios e reprodutibilidade.",
                                "Engenharia de Software: criação de funções modulares e testes unitários."
                              ],
                              "realWorldApplication": "Na análise estrutural de edifícios (Engenharia Civil), inicializa vetores para o método da potência calcular autovalores dominantes, determinando frequências de vibração e modos de falha em pontes ou arranha-céus sob cargas dinâmicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Executar iteração de multiplicação e normalização",
                            "description": "Calcular o vetor atualizado como A * v_k, normalizá-lo para obter v_{k+1} e estimar o autovalor como o produto escalar ou norma do vetor resultante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar a multiplicação matricial A * v_k para obter w_k",
                                  "subSteps": [
                                    "Identifique a matriz A (n x n) e o vetor v_k (n x 1) da iteração anterior.",
                                    "Compute cada elemento de w_k usando w_i = soma_{j=1 to n} A_{i j} * (v_k)_j para i=1 to n.",
                                    "Verifique as dimensões: w_k deve ser n x 1.",
                                    "Registre os valores numéricos com precisão decimal adequada (ex: 4 casas).",
                                    "Confirme aritmeticamente com um elemento aleatório."
                                  ],
                                  "verification": "Compare w_k com cálculo manual ou software; dimensões corretas e valores exatos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz A",
                                    "Vetor v_k",
                                    "Calculadora científica ou Python com NumPy",
                                    "Papel e lápis para rascunho"
                                  ],
                                  "tips": "Multiplique linha por coluna sistematicamente; use funções prontas como np.dot(A, v_k) para validação.",
                                  "learningObjective": "Dominar o produto matricial-vetor como base para iterações iterativas.",
                                  "commonMistakes": [
                                    "Confundir multiplicação de linha-coluna",
                                    "Erros de sinal ou índice off-by-one",
                                    "Ignorar normalização prévia de v_k"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a norma euclidiana de w_k",
                                  "subSteps": [
                                    "Compute ||w_k|| = sqrt( soma_{i=1 to n} (w_k_i)^2 ).",
                                    "Eleve cada componente ao quadrado e some.",
                                    "Aplique a raiz quadrada no resultado.",
                                    "Use aproximação numérica se necessário (ex: sqrt(10) ≈ 3.162).",
                                    "Registre com precisão para evitar erros de propagação."
                                  ],
                                  "verification": "||w_k|| > 0 e coincide com cálculo em software (np.linalg.norm(w_k)).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Vetor w_k",
                                    "Calculadora com funções sqrt e ^2",
                                    "Python/MATLAB para verificação"
                                  ],
                                  "tips": "Para vetores pequenos, calcule manualmente; para grandes, use normas computacionais.",
                                  "learningObjective": "Aplicar norma L2 para escalonamento em métodos iterativos.",
                                  "commonMistakes": [
                                    "Usar norma L1 ou L-infinito por engano",
                                    "Esquecer raiz quadrada",
                                    "Arredondamento prematuro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Normalizar w_k para obter v_{k+1}",
                                  "subSteps": [
                                    "Divida cada componente: (v_{k+1})_i = (w_k)_i / ||w_k|| para i=1 to n.",
                                    "Aplique a divisão elemento-sabio.",
                                    "Verifique se ||v_{k+1}|| ≈ 1 (tolerância 1e-6).",
                                    "Arredonde para consistência numérica.",
                                    "Atualize v_k para próxima iteração."
                                  ],
                                  "verification": "Norma de v_{k+1} deve ser unitária; teste com np.linalg.norm(v_k1) == 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Vetor w_k",
                                    "Valor da norma ||w_k||",
                                    "Software para divisão vetorial"
                                  ],
                                  "tips": "Mantenha precisão alta para convergência; evite divisão por zero (verifique ||w_k|| != 0).",
                                  "learningObjective": "Garantir vetores unitários para estabilidade numérica no método da potência.",
                                  "commonMistakes": [
                                    "Dividir pela norma errada",
                                    "Inverter divisão",
                                    "Perder precisão em frações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estimar o autovalor λ_{k+1}",
                                  "subSteps": [
                                    "Calcule λ_{k+1} ≈ ||w_k|| (aproximação simples para autovetor dominante).",
                                    "Alternativamente, use produto escalar: λ = v_k^T * A * v_k / (v_k^T * v_k), mas priorize norma.",
                                    "Compare com λ_k anterior para monitorar convergência.",
                                    "Registre com precisão e note se está estabilizando.",
                                    "Documente para histórico de iterações."
                                  ],
                                  "verification": "λ_{k+1} próximo a λ_k (diferença < 1%); positivo para autovalor dominante.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "w_k",
                                    "||w_k||",
                                    "v_k anterior",
                                    "Calculadora para produto escalar"
                                  ],
                                  "tips": "Para matrizes simétricas, ||w_k|| é exato; monitore sequência de λ.",
                                  "learningObjective": "Extrair aproximação de autovalor da norma do resíduo iterativo.",
                                  "commonMistakes": [
                                    "Usar norma de v_k em vez de w_k",
                                    "Confundir com autovetor",
                                    "Ignorar sinal do autovalor"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[3, 1], [1, 3]], v_k = [0.8321, 0.5547]^T (iteração k). w_k = A v_k = [3.1103, 2.5547]^T, ||w_k|| ≈ 4.015, v_{k+1} = [0.7746, 0.6364]^T, λ_{k+1} ≈ 4.015. Verifique convergência para autovalor dominante ≈4.",
                              "finalVerifications": [
                                "||v_{k+1}|| = 1 (tolerância 1e-5)",
                                "w_k = A v_k exato em todos componentes",
                                "λ_{k+1} ≈ ||w_k|| com precisão relativa <1%",
                                "Sequência de λ estável ou convergindo",
                                "Sem erros de dimensão ou divisão por zero",
                                "Resultados reproduzíveis em software"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erro <1e-4)",
                                "Correta aplicação de multiplicação e normalização",
                                "Interpretação adequada da estimativa de autovalor",
                                "Verificação de normas e dimensões",
                                "Documentação clara de passos e valores",
                                "Eficiência no tempo estimado"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/NumPy para automação de iterações",
                                "Análise Numérica: Entender convergência e estabilidade",
                                "Física Estrutural: Modos de vibração em engenharia civil",
                                "Estatística: Análise de componentes principais (PCA)"
                              ],
                              "realWorldApplication": "Em análise de estruturas civis, o método da potência encontra frequências naturais (autovalores) de vibração em edifícios, essencial para design sísmico e estabilidade contra flambagem."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Codificar o loop iterativo completo",
                            "description": "Escrever um pseudocódigo ou código em linguagem de programação para repetir as iterações até atingir tolerância, incluindo atualização da autofunção aproximada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir parâmetros de controle do loop e inicializações",
                                  "subSteps": [
                                    "Declare variáveis: tolerância (tol, ex: 1e-6), contador de iterações (k = 0), iterações máximas (max_iter = 1000).",
                                    "Inicialize o vetor autofunção aproximado v_k com valores aleatórios ou unitários normalizados.",
                                    "Defina a matriz A (matriz de rigidez ou similar no contexto de engenharia).",
                                    "Prepare variáveis para armazenar autovalor aproximado lambda_k.",
                                    "Adicione comentários explicando o propósito de cada parâmetro."
                                  ],
                                  "verification": "Verifique se as variáveis estão declaradas corretamente e inicializadas antes do loop, sem erros de sintaxe.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de código (Python/Jupyter), documentação do Método da Potência.",
                                  "tips": "Use valores realistas para tol e max_iter para evitar loops infinitos em testes.",
                                  "learningObjective": "Entender e implementar controles de iteração para garantir convergência segura.",
                                  "commonMistakes": "Esquecer de inicializar k=0 ou definir tol muito pequeno, causando não convergência prática."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o cabeçalho do loop iterativo e atualização da autofunção",
                                  "subSteps": [
                                    "Escreva o loop while: while k < max_iter and norma_residuo > tol.",
                                    "Calcule o vetor temporário w = A * v_k (multiplicação matricial).",
                                    "Normalize w para obter v_{k+1} = w / ||w|| (norma euclidiana).",
                                    "Atualize o contador k = k + 1.",
                                    "Armazene v_{k+1} como nova autofunção aproximada."
                                  ],
                                  "verification": "Execute o loop com uma matriz teste simples; confira se v_k é atualizado e normalizado em cada iteração.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Biblioteca NumPy (Python) para operações matriciais, matriz de teste 3x3.",
                                  "tips": "Use funções vetorizadas como np.dot(A, v) e np.linalg.norm para eficiência.",
                                  "learningObjective": "Codificar a iteração principal do Método da Potência com normalização correta.",
                                  "commonMistakes": "Confundir ordem: normalizar antes da multiplicação ou usar norma errada (L1 em vez de L2)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular autovalor aproximado e critério de convergência",
                                  "subSteps": [
                                    "Calcule lambda_k = v_k^T * A * v_k / (v_k^T * v_k) (quociente de Rayleigh).",
                                    "Compute o resíduo: r_k = ||A * v_k - lambda_k * v_k||.",
                                    "Atualize condição de parada: if r_k < tol, break.",
                                    "Registre lambda_k e v_k em listas para histórico de convergência.",
                                    "Inclua print ou log para monitorar progresso."
                                  ],
                                  "verification": "Inspecione saídas: lambda_k deve estabilizar e resíduo diminuir progressivamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "NumPy para cálculos de norma e produto escalar, debugger do IDE.",
                                  "tips": "O quociente de Rayleigh aproxima o autovalor dominante; valide com autovalores conhecidos.",
                                  "learningObjective": "Integrar cálculo de autovalor e verificação de tolerância no loop.",
                                  "commonMistakes": "Calcular resíduo sem normalização ou usar v_{k-1} em vez de v_k."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar o loop e retornar resultados",
                                  "subSteps": [
                                    "Adicione cláusula else do loop para alertar sobre não convergência.",
                                    "Retorne lambda_k final, v_k final e número de iterações.",
                                    "Teste com matriz conhecida (ex: com autovalor dominante 4).",
                                    "Adicione docstring explicando inputs/outputs.",
                                    "Comente todo o código para clareza."
                                  ],
                                  "verification": "Rode o código completo; confira se retorna autovalor/autofunção corretos com tol atingida.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Matriz de teste com autovalores conhecidos, validador como np.linalg.eig.",
                                  "tips": "Sempre teste com max_iter baixo inicialmente para depuração rápida.",
                                  "learningObjective": "Completar implementação robusta com tratamento de erros e saída limpa.",
                                  "commonMistakes": "Loop infinito por tol não checado ou falta de break."
                                }
                              ],
                              "practicalExample": "Em Python com NumPy:\n\nimport numpy as np\ndef metodo_potencia(A, tol=1e-6, max_iter=1000):\n    n = A.shape[0]\n    v = np.random.rand(n)\n    v = v / np.linalg.norm(v)\n    k = 0\n    while k < max_iter:\n        w = A @ v\n        v_novo = w / np.linalg.norm(w)\n        lambda_k = v_novo.T @ A @ v_novo\n        residuo = np.linalg.norm(A @ v_novo - lambda_k * v_novo)\n        v = v_novo\n        k += 1\n        if residuo < tol:\n            break\n    return lambda_k, v, k\n\n# Teste: A = np.array([[4,1,0],[1,3,1],[0,1,2]])\n# lambda_dom ~4.0",
                              "finalVerifications": [
                                "O loop para quando resíduo < tol ou atinge max_iter.",
                                "Autofunção final tem norma unitária (||v|| ≈ 1).",
                                "Autovalor aproximado coincide com dominante conhecido (±tol).",
                                "Número de iterações é registrado e razoável (< max_iter).",
                                "Código executa sem erros para matrizes simétricas positivas.",
                                "Histórico mostra convergência monotônica."
                              ],
                              "assessmentCriteria": [
                                "Correção: autovalor/autofunção convergem corretamente.",
                                "Eficiência: uso de operações vetorizadas, sem loops desnecessários.",
                                "Robustez: tratamento de não convergência e normalização.",
                                "Clareza: comentários, nomes de variáveis descritivos, docstring.",
                                "Testabilidade: inclui exemplo de uso e validação.",
                                "Precisão numérica: resíduo calculado corretamente."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: compreensão de autovalores em decomposições matriciais.",
                                "Análise Numérica: métodos iterativos e critérios de convergência.",
                                "Programação Computacional: bibliotecas NumPy para engenharia.",
                                "Engenharia Estrutural: análise de modos de vibração.",
                                "Otimização: aproximações em problemas de autovalores."
                              ],
                              "realWorldApplication": "Na engenharia civil, o Método da Potência codificado é usado para encontrar o modo de vibração fundamental em análises modais de edifícios e pontes, permitindo avaliar frequências naturais e respostas sísmicas via multiplicação matricial de matrizes de massa/rigidez."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.1",
                              "10.1.4.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Convergência, Critérios de Parada e Limitações",
                        "description": "Análise da taxa de convergência linear dependente da razão |λ2/λ1|, critérios para parada das iterações e variantes para autovalores não dominantes.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Determinar critérios de convergência",
                            "description": "Definir tolerância baseada na diferença entre iterações sucessivas de vetores e autovalores, como ||v_{k+1} - v_k|| < ε ou |λ_{k+1} - λ_k| < ε.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Convergência no Método da Potência",
                                  "subSteps": [
                                    "Revise as iterações do método da potência: v_{k+1} = A v_k / ||A v_k|| e λ_{k+1} = v_{k+1}^T A v_{k+1}.",
                                    "Explique que convergência ocorre quando v_k e λ_k se estabilizam no autovetor e autovalor dominantes.",
                                    "Discuta a necessidade de critérios de parada para evitar iterações infinitas em implementações computacionais.",
                                    "Identifique fatores que afetam a taxa de convergência, como a razão |λ_2 / λ_1|."
                                  ],
                                  "verification": "Resuma em 3 frases o que significa convergência e por que critérios são necessários.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas do método da potência, calculadora.",
                                  "tips": "Visualize graficamente a sequência de vetores aproximando o autovetor verdadeiro.",
                                  "learningObjective": "Entender o significado matemático e prático de convergência iterativa.",
                                  "commonMistakes": "Confundir convergência com exatidão; lembre-se que é aproximada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Critério de Convergência Baseado em Vetores",
                                  "subSteps": [
                                    "Defina a norma da diferença: ||v_{k+1} - v_k||_2 < ε, onde ε é a tolerância.",
                                    "Normalize todos os vetores v_k para que ||v_k|| = 1 antes do cálculo.",
                                    "Escolha ε típico (ex: 10^{-6} para precisão moderada, 10^{-10} para alta precisão).",
                                    "Calcule manualmente para 2-3 iterações de uma matriz simples.",
                                    "Implemente em pseudocódigo: while ||v_new - v_old|| >= ε: iterate."
                                  ],
                                  "verification": "Calcule ||v_{k+1} - v_k|| para um exemplo e verifique se < ε.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, matriz de exemplo 2x2.",
                                  "tips": "Use norma euclidiana (L2) para vetores; evite normas não normalizadas.",
                                  "learningObjective": "Formular e aplicar critério vetorial para parada iterativa.",
                                  "commonMistakes": "Esquecer normalização, levando a normas crescentes; sempre normalize."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Critério de Convergência Baseado em Autovalores",
                                  "subSteps": [
                                    "Defina a diferença absoluta: |λ_{k+1} - λ_k| < ε.",
                                    "Calcule λ_k = v_{k}^T A v_k após cada normalização.",
                                    "Compare com o critério vetorial: autovalor converge mais rápido se dominante.",
                                    "Teste com exemplo: verifique estabilidade de λ_k em iterações sucessivas.",
                                    "Discuta hibridização: use ambos critérios para robustez."
                                  ],
                                  "verification": "Registre λ_k para 5 iterações e confirme estabilização abaixo de ε.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesma matriz de exemplo, software como Python/Octave opcional.",
                                  "tips": "Monitore |λ_{k+1} - λ_k| pois é computacionalmente mais barato que norma vetorial.",
                                  "learningObjective": "Formular critério escalar para autovalores e compará-lo ao vetorial.",
                                  "commonMistakes": "Usar λ_k sem normalização; sempre compute com v_k unitário."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar Tolerância ε e Aplicar Critérios em Prática",
                                  "subSteps": [
                                    "Escolha ε baseado no contexto: 10^{-8} para engenharia civil (precisão de máquina).",
                                    "Implemente loop com ambos critérios: pare se qualquer um for satisfeito.",
                                    "Teste sensibilidade: rode com ε = 10^{-4}, 10^{-8} e compare iterações.",
                                    "Registre número de iterações necessárias para convergência.",
                                    "Ajuste para limitações: detecte não-convergência se > max_iter (ex: 1000)."
                                  ],
                                  "verification": "Execute simulação completa e liste iterações até parada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Python/MATLAB com NumPy, ou planilha Excel para manual.",
                                  "tips": "Comece com ε maior para depuração rápida, refine depois.",
                                  "learningObjective": "Integrar critérios, escolher ε e validar em implementação.",
                                  "commonMistakes": "ε muito pequeno causa timeout; equilibre precisão e eficiência."
                                }
                              ],
                              "practicalExample": "Para A = [[4, 1], [1, 3]], autovalor dominante ≈4.3, vetor [0.82, 0.57]. Inicie v0=[1,1]/√2. Iteração 1: v1≈[0.85,0.53], ||v1-v0||≈0.12, λ1≈4.1. Iter2: v2≈[0.82,0.57], ||v2-v1||≈0.04, λ2≈4.25. Com ε=0.01, para na iter2 pois ||v2-v1||<0.01 e |λ2-λ1|<0.01.",
                              "finalVerifications": [
                                "Defina precisamente ||v_{k+1}-v_k|| < ε e justifique normalização.",
                                "Explique |λ_{k+1}-λ_k| < ε e quando usá-lo preferencialmente.",
                                "Calcule critérios para 3 iterações de uma matriz dada.",
                                "Escolha ε adequado para análise estrutural (ex: 10^{-8}).",
                                "Identifique 2 limitações dos critérios (ex: autovalor complexo).",
                                "Implemente pseudocódigo híbrido de parada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática dos critérios (100% fórmulas corretas).",
                                "Correta normalização e cálculo de normas/diferenças (erro <1%).",
                                "Escolha contextual de ε com justificativa (adequado ao problema).",
                                "Integração de ambos critérios em algoritmo coeso.",
                                "Análise de sensibilidade a ε (variação de iterações).",
                                "Identificação de erros comuns e soluções."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estudo de erros de arredondamento em iterações.",
                                "Programação Computacional: Implementação de loops while em Python/MATLAB.",
                                "Física/Engenharia Mecânica: Autovalores em vibrações modais de estruturas.",
                                "Estatística: Tolerâncias como intervalos de confiança em aproximações."
                              ],
                              "realWorldApplication": "Em engenharia civil, critérios de convergência são usados no método da potência para calcular frequências naturais e modos de vibração de edifícios e pontes via análise matricial de rigidez/massa, garantindo simulações precisas sem computação excessiva em softwares como SAP2000 ou ANSYS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Analisar taxa de convergência",
                            "description": "Calcular a razão espectral |λ2/λ1| para prever o número de iterações necessárias e discutir acelerações como deflação ou shifts para matrizes com autovalores próximos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Autovalores e Método da Potência",
                                  "subSteps": [
                                    "Relembrar a definição de autovalor dominante λ1 e autovetor associado no contexto do método da potência.",
                                    "Explicar como o método da potência itera um vetor inicial para convergir ao autovetor dominante.",
                                    "Identificar a importância da razão espectral ρ = |λ2/λ1|, onde λ2 é o segundo maior autovalor em módulo.",
                                    "Discutir o papel da taxa de convergência na previsão do comportamento iterativo.",
                                    "Resolver um exemplo simples manualmente para ilustrar a convergência lenta quando ρ está próximo de 1."
                                  ],
                                  "verification": "Resumir em um parágrafo os conceitos chave e calcular ρ para uma matriz 2x2 de exemplo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de álgebra linear (ex: Strang)",
                                    "Calculadora ou papel e lápis",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Visualize graficamente a convergência usando vetores iterados para intuitividade.",
                                  "learningObjective": "Compreender a base teórica da convergência no método da potência.",
                                  "commonMistakes": [
                                    "Confundir λ1 com o maior autovalor absoluto sem considerar módulo.",
                                    "Ignorar que ρ < 1 garante convergência, mas próximo de 1 torna lenta."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Razão Espectral |λ2/λ1|",
                                  "subSteps": [
                                    "Obter ou estimar os autovalores de uma matriz A usando decomposição ou software.",
                                    "Identificar λ1 (maior em módulo) e λ2 (segundo maior).",
                                    "Computar ρ = |λ2/λ1| para matrizes simétricas ou não-simétricas.",
                                    "Analisar o impacto de ρ no erro de convergência: erro ≈ ρ^k após k iterações.",
                                    "Praticar com matrizes de diferentes tamanhos, incluindo uma de engenharia civil (ex: matriz de rigidez)."
                                  ],
                                  "verification": "Calcular ρ corretamente para 2 matrizes fornecidas e plotar erro vs. iterações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software como MATLAB, Python (NumPy/SciPy) ou Octave",
                                    "Matrizes de exemplo em arquivo .csv"
                                  ],
                                  "tips": "Use funções prontas como eig() inicialmente, mas entenda o algoritmo por trás.",
                                  "learningObjective": "Dominar o cálculo preciso da taxa de convergência espectral.",
                                  "commonMistakes": [
                                    "Selecionar autovalores incorretos como λ2 (ex: considerar complexos sem módulo).",
                                    "Esquecer normalização do vetor de potência ao estimar."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Prever Número de Iterações Necessárias",
                                  "subSteps": [
                                    "Derivar a fórmula aproximada k ≈ log(ε / ||x0 - v1||) / log(1/ρ), onde ε é tolerância.",
                                    "Escolher tolerâncias típicas (ex: 10^-6) e calcular k para diferentes ρ.",
                                    "Simular o método da potência até convergência e comparar com previsão.",
                                    "Analisar sensibilidade: como pequenas mudanças em ρ afetam k.",
                                    "Documentar resultados em tabela: ρ, k_teórico, k_simulado."
                                  ],
                                  "verification": "Prever e validar k para uma matriz com ρ ≈ 0.9, erro < 1%.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python/MATLAB script para simulação",
                                    "Planilha Excel para tabelas"
                                  ],
                                  "tips": "Comece com ρ alto (próximo de 1) para ver convergência lenta na prática.",
                                  "learningObjective": "Aplicar ρ para estimar eficiência computacional.",
                                  "commonMistakes": [
                                    "Usar log(ρ) em vez de log(1/ρ).",
                                    "Ignorar dependência inicial do vetor x0."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Acelerações: Deflação e Shifts para Autovalores Próximos",
                                  "subSteps": [
                                    "Explicar deflação: remover componente de λ1 após encontrar para isolar λ2.",
                                    "Descrever shift-and-invert: transformar A - σI para alterar espectro.",
                                    "Aplicar deflação em exemplo com autovalores próximos.",
                                    "Implementar shift para acelerar quando |λ2| ≈ |λ1|.",
                                    "Comparar tempos de convergência original vs. acelerado em gráfico."
                                  ],
                                  "verification": "Implementar aceleração em código e demonstrar redução de iterações >50%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código fonte em Python/MATLAB",
                                    "Matriz com autovalores próximos (ex: vibrações estruturais)"
                                  ],
                                  "tips": "Teste shifts σ próximos a λ1 para maximizar separação espectral.",
                                  "learningObjective": "Identificar e aplicar técnicas para mitigar convergência lenta.",
                                  "commonMistakes": [
                                    "Deflação imprecisa levando a instabilidade numérica.",
                                    "Escolha errada de σ worsening a convergência."
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de uma estrutura de ponte com matriz de rigidez 5x5, autovalores λ1=10, λ2=9.5 (ρ=0.95). Calcule ρ, preveja k≈100 iterações para ε=10^-6. Aplique shift σ=9.7 para ρ_new≈0.8, reduzindo k para 30 iterações, simulando modos de vibração.",
                              "finalVerifications": [
                                "Calcular ρ corretamente para matriz não-diagonalizável.",
                                "Prever k com erro <10% vs. simulação.",
                                "Implementar deflação sem perda de precisão numérica.",
                                "Sugerir shift ótimo baseado em estimativa de autovalores.",
                                "Explicar limitações quando múltiplos autovalores dominantes.",
                                "Analisar convergência em critério de parada ||x_{k+1} - x_k|| < ε."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de ρ (erro <0.01).",
                                "Correção na previsão de iterações (desvio <20%).",
                                "Implementação funcional de acelerações.",
                                "Análise qualitativa de limitações profundas.",
                                "Clareza em relatórios com gráficos e tabelas.",
                                "Criatividade em exemplos de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear avançada e análise numérica.",
                                "Programação: Implementação de algoritmos iterativos em Python/MATLAB.",
                                "Física: Modos de vibração e estabilidade estrutural.",
                                "Engenharia de Computação: Otimização de algoritmos para grandes matrizes."
                              ],
                              "realWorldApplication": "Na análise modal de edifícios altos ou pontes, o método da potência com análise de convergência acelera a identificação de frequências naturais, essencial para design sísmico resistente, reduzindo tempo computacional de dias para horas em simulações FEM."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Aplicar em exemplo numérico",
                            "description": "Resolver um problema de matriz 3x3 ou maior, simulando iterações manualmente ou via código, e validar com autovalores exatos usando funções built-in.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz de exemplo e vetor inicial",
                                  "subSteps": [
                                    "Escolha uma matriz 3x3 não simétrica ou simétrica com autovalor dominante real e positivo, como A = [[3, 0.5, 0], [0.5, 2, 0.5], [0, 0.5, 1]].",
                                    "Verifique as propriedades da matriz (dominância, simetria) usando cálculo manual ou software.",
                                    "Selecione um vetor inicial x0 aleatório não nulo, como [1, 1, 1]^T, e normalize-o para ||x0|| = 1.",
                                    "Calcule o quociente de Rayleigh inicial λ0 = x0^T A x0 / x0^T x0.",
                                    "Documente os valores iniciais em uma tabela para rastreamento."
                                  ],
                                  "verification": "Confirme que a matriz está corretamente definida, vetor inicial normalizado (norma = 1) e quociente inicial calculado sem erros aritméticos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e calculadora; ou Python com NumPy para verificação rápida.",
                                  "tips": "Use matrizes com autovalor dominante conhecido para facilitar a validação posterior.",
                                  "learningObjective": "Entender a importância da escolha inicial para convergência rápida no método da potência.",
                                  "commonMistakes": "Escolher vetor inicial ortogonal ao autovetor dominante; esquecer de normalizar o vetor inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar iterações manuais ou via código do Método da Potência",
                                  "subSteps": [
                                    "Para cada iteração k: Compute y_k = A x_{k-1}.",
                                    "Normalize x_k = y_k / ||y_k|| (norma euclidiana).",
                                    "Atualize o autovalor aproximado λ_k = x_k^T A x_k (quociente de Rayleigh).",
                                    "Registre ||x_k - x_{k-1}|| e |λ_k - λ_{k-1}| para monitoramento.",
                                    "Realize pelo menos 10-20 iterações manualmente para matriz pequena ou codifique em loop Python."
                                  ],
                                  "verification": "Verifique que após 5 iterações, o quociente de Rayleigh estabiliza (variação < 1e-3) e vetor normalizado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha Excel ou papel para cálculos manuais; Python script com NumPy (np.dot, np.linalg.norm).",
                                  "tips": "Codifique em Python para automação: use loop while com print de iterações para visualização.",
                                  "learningObjective": "Dominar o ciclo iterativo do método da potência e seu papel na aproximação do autovetor dominante.",
                                  "commonMistakes": "Não normalizar corretamente, levando a overflow numérico; confundir autovalor com componente do vetor."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar critérios de convergência e parada",
                                  "subSteps": [
                                    "Defina tolerância ε = 1e-6 para ||x_k - x_{k-1}|| < ε e |λ_k - λ_{k-1}| < ε.",
                                    "Estabeleça máximo de iterações N_max = 100 para evitar loops infinitos.",
                                    "Monitore resíduos e pare quando critérios forem satisfeitos ou N_max atingido.",
                                    "Registre número de iterações necessárias e resíduo final.",
                                    "Analise se convergiu: compare com autovalor exato se conhecido."
                                  ],
                                  "verification": "O algoritmo para com critérios satisfeitos, registrando iterações < N_max e resíduo < ε.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código Python atualizado com condicionais if para parada; gráfico de convergência via Matplotlib.",
                                  "tips": "Plote λ_k vs k para visualizar taxa de convergência linear.",
                                  "learningObjective": "Implementar e entender critérios robustos para garantir convergência confiável.",
                                  "commonMistakes": "Tolerância muito frouxa levando a imprecisão; ignorar detecção de não-convergência (ex: autovalor complexo)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar resultados com funções built-in e analisar limitações",
                                  "subSteps": [
                                    "Use np.linalg.eig(A) para obter autovalores e autovetores exatos.",
                                    "Compare λ_aproximado com o maior autovalor real; compute erro relativo |λ_exato - λ_aprox| / |λ_exato|.",
                                    "Verifique ortogonalidade aproximada do autovetor com A x ≈ λ x.",
                                    "Discuta limitações: falha se autovalor dominante não único/real; sensibilidade a x0.",
                                    "Teste com matriz que não converge (ex: autovalores complexos) para demonstrar falhas."
                                  ],
                                  "verification": "Erro relativo < 1e-5; autovetor aproximado satisfaz equação residual < ε.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy e SciPy; matrizes de teste adicionais.",
                                  "tips": "Salve resultados em tabela comparativa para relatório claro.",
                                  "learningObjective": "Avaliar precisão do método e reconhecer cenários de aplicação limitada.",
                                  "commonMistakes": "Comparar com autovalor errado; ignorar normalização na validação final."
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez em análise estrutural: A = [[3, 0.5, 0], [0.5, 2, 0.5], [0, 0.5, 1]]. Vetor inicial x0 = [1,1,1]^T / sqrt(3). Após 12 iterações, converge para λ ≈ 3.302, autovetor ≈ [0.707, 0.707, 0]^T. Validação com eig: λ_exato = 3.3028, erro 0.02%.",
                              "finalVerifications": [
                                "Autovalor aproximado coincide com maior autovalor exato dentro de 1e-4 relativo.",
                                "Autovetor normalizado satisfaz ||A x - λ x|| < 1e-5.",
                                "Número de iterações registrado e < 50 para exemplo padrão.",
                                "Critérios de parada ativados corretamente sem exceder N_max.",
                                "Tabela de iterações mostra convergência monotônica.",
                                "Análise de limitações documentada para pelo menos 2 cenários falhos."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro relativo no autovalor < 1e-4.",
                                "Eficiência: convergência em < 20 iterações para matriz dominante.",
                                "Implementação: código ou cálculos manuais sem erros aritméticos.",
                                "Análise: identificação correta de critérios e limitações.",
                                "Documentação: tabelas, gráficos e comparações claras.",
                                "Robustez: teste com pelo menos uma matriz não convergente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Extensões a métodos como inverso da potência.",
                                "Programação: Uso de vetores/matrizes em Python/NumPy para computação científica.",
                                "Física/Engenharia Mecânica: Modos de vibração em estruturas civis.",
                                "Estatística: Análise de convergência e erros numéricos."
                              ],
                              "realWorldApplication": "Em engenharia civil, o método da potência é usado para encontrar frequências fundamentais de vibração em edifícios (matrizes de massa/rigidez), análise de estabilidade buckling em vigas/colunas, e otimização de estruturas modais em software como ANSYS ou SAP2000, acelerando simulações sem decomposição completa."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.4",
                            "name": "Identificar limitações e variantes",
                            "description": "Discutir falhas em matrizes com autovalores complexos ou múltiplos dominantes, e introduzir método da potência inversa para autovalor de menor módulo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar limitações do método da potência com autovalores complexos",
                                  "subSteps": [
                                    "Revise a definição de autovalores complexos em matrizes reais (pares conjugados).",
                                    "Analise por que o método da potência falha: vetores sucessivos oscilam sem convergir.",
                                    "Estude um exemplo simples de matriz de rotação, como A = [[0, -1], [1, 0]].",
                                    "Discuta o impacto na norma dos vetores iterados que não diminui monotonicamente.",
                                    "Registre as condições matemáticas para convergência (autovalor dominante real e positivo)."
                                  ],
                                  "verification": "Simule 5 iterações manualmente e observe a não-convergência; explique o padrão oscilatório.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para cálculos manuais",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Matriz exemplo impressa"
                                  ],
                                  "tips": "Visualize geometricamente: rotações preservam norma, impedindo dominância.",
                                  "learningObjective": "Explicar matematicamente por que autovalores complexos causam falha no método da potência.",
                                  "commonMistakes": [
                                    "Assumir que autovalores negativos reais causam o mesmo problema (eles convergem com sinal alternado, mas ajustável)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar problemas com autovalores múltiplos dominantes",
                                  "subSteps": [
                                    "Defina autovalores múltiplos dominantes: dois ou mais com o mesmo módulo máximo |λ|. ",
                                    "Examine como a convergência leva a uma combinação linear de autofunções associadas.",
                                    "Use exemplo: matriz A = [[2, 1], [0, 2]] com autovalor duplo λ=2.",
                                    "Calcule iterações e observe que o vetor não converge para uma única direção.",
                                    "Discuta acelerações como deflação ou shifts para mitigar."
                                  ],
                                  "verification": "Compute 10 iterações e demonstre que a direção final é uma combinação, não autofunção pura.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de álgebra linear (Python NumPy ou MATLAB)",
                                    "Folha de exercícios com matrizes Jordan"
                                  ],
                                  "tips": "Verifique multiplicidade algébrica vs geométrica para prever comportamento.",
                                  "learningObjective": "Identificar e quantificar o impacto de multiplicidade no método da potência.",
                                  "commonMistakes": [
                                    "Confundir com autovalores próximos, que convergem lentamente mas ainda convergem."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir o método da potência inversa para autovalor de menor módulo",
                                  "subSteps": [
                                    "Explique o princípio: resolve (A - σI)x = b para aproximar 1/(λ - σ), focando em menor |λ - σ|.",
                                    "Derive a relação: autovalor dominante de A⁻¹ corresponde a menor módulo de A.",
                                    "Escolha σ próximo ao autovalor alvo para acelerar convergência.",
                                    "Apresente algoritmo: iterar x_{k+1} = A⁻¹ x_k / ||A⁻¹ x_k||, usando solvers lineares.",
                                    "Compare com potência padrão: inverte o espectro de módulos."
                                  ],
                                  "verification": "Implemente pseudocódigo e teste com matriz diagonal simples.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Documentação de solvers lineares (LU, Gauss-Seidel)",
                                    "Exemplos de matrizes 3x3 invertíveis"
                                  ],
                                  "tips": "Para σ=0, potência inversa acha menor autovalor em módulo; evite singularidade.",
                                  "learningObjective": "Formular o método da potência inversa e suas vantagens para autovalores pequenos.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar ou lidar com inversa numérica instável."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir critérios de parada, variantes e aplicações práticas",
                                  "subSteps": [
                                    "Defina critérios: ||x_{k+1} - x_k|| < ε, Rayleigh quotient estabilizado.",
                                    "Adapte para potência inversa: monitore resíduo do sistema linear.",
                                    "Explore variantes: potência deslocada (shift-invertida) para autovalores específicos.",
                                    "Integre com engenharia civil: análise modal em vibrações estruturais.",
                                    "Avalie trade-offs: custo computacional vs precisão."
                                  ],
                                  "verification": "Proponha critérios para um exemplo dado e justifique tolerâncias.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigos ou slides sobre análise modal",
                                    "Código template em Python"
                                  ],
                                  "tips": "Use pré-condicionadores para sistemas lineares grandes em prática.",
                                  "learningObjective": "Selecionar método apropriado baseado em espectro da matriz.",
                                  "commonMistakes": [
                                    "Ignorar custo de inversão para matrizes esparsas grandes."
                                  ]
                                }
                              ],
                              "practicalExample": "Para matriz A = [[4, 1, 0], [1, 3, 1], [0, 1, 2]] (autovalores ≈4.37, 2.74, 1.89), potência padrão falha se complexo simulado; use potência inversa com σ=0 para menor autovalor ≈1.89, iterando solução de A x_{k+1} = x_k.",
                              "finalVerifications": [
                                "Liste e explique 3 limitações principais do método da potência.",
                                "Derive a convergência da potência inversa para autovalor mínimo.",
                                "Simule um caso de falha e corrija com variante.",
                                "Defina critérios de parada adaptados para inversa.",
                                "Compare precisão em exemplo numérico com autovalores conhecidos.",
                                "Identifique quando usar potência vs inversa em contexto estrutural."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de condições de falha (complexos/múltiplos).",
                                "Correção matemática na derivação da potência inversa.",
                                "Qualidade de exemplos e simulações numéricas.",
                                "Adequação de critérios de parada e verificações.",
                                "Profundidade em conexões práticas e trade-offs computacionais.",
                                "Clareza na explicação de variantes e acelerações."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/NumPy para solvers iterativos.",
                                "Física Estrutural: Análise de modos de vibração em vigas e edifícios.",
                                "Otimização: Seleção de shifts para autovalores alvo em problemas de engenharia.",
                                "Estatística: Análise de componentes principais (PCA) via autovalores.",
                                "Computação Científica: Uso de bibliotecas como SciPy para métodos de potência."
                              ],
                              "realWorldApplication": "Na engenharia civil, identifica modos de vibração de menor frequência em estruturas (ex.: pontes), usando potência inversa para autovalores pequenos, evitando falhas em métodos padrão e garantindo estabilidade sísmica precisa."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Método da Potência Inversa",
                    "description": "Variante do método da potência para calcular autovalores próximos a um valor especificado.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Definição e Motivação do Método da Potência Inversa",
                        "description": "O método da potência inversa é uma variante do método da potência que transforma o problema de autovalores para encontrar o autovalor de maior magnitude de uma matriz invertida (A - μI)^{-1}, permitindo calcular autovalores de A próximos a um valor especificado μ (shift).",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Entender a transformação do problema de autovalores",
                            "description": "Explicar como o autovalor λ de A próximo a μ corresponde ao autovalor dominante 1/|λ - μ| da matriz (A - μI)^{-1}, incluindo a relação entre autofunções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Autovalores e Autofunções",
                                  "subSteps": [
                                    "Defina formalmente autovalor λ e autofunção v para uma matriz A, tal que A v = λ v.",
                                    "Explique o conceito de autovalor dominante como aquele com maior módulo |λ|.",
                                    "Descreva o método da potência e por que ele converge para o autovalor dominante.",
                                    "Identifique limitações do método da potência para autovalores não dominantes.",
                                    "Introduza a motivação para shifts: encontrar autovalores próximos a um μ específico."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os conceitos e dê um exemplo 2x2 simples.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou Python/MATLAB para exemplo"
                                  ],
                                  "tips": "Sempre normalize os vetores nas iterações do método da potência para estabilidade numérica.",
                                  "learningObjective": "Dominar os pré-requisitos para entender a transformação do problema.",
                                  "commonMistakes": [
                                    "Confundir autovalor com traço da matriz.",
                                    "Ignorar a necessidade de normalização no método da potência.",
                                    "Esquecer que método da potência requer matriz diagonalizável."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e Analisar a Matriz Shifted A - μI",
                                  "subSteps": [
                                    "Selecione μ próximo ao autovalor λ desejado de A.",
                                    "Compute a matriz B = A - μ I explicitamente para uma matriz exemplo.",
                                    "Derive que os autovalores de B são σ_i = λ_i - μ, preservando autofunções.",
                                    "Identifique que o σ correspondente a λ mais próximo de μ tem o menor |σ|.",
                                    "Discuta implicações: menor |σ| significa maior potencial de dominância na inversa."
                                  ],
                                  "verification": "Calcule B para uma matriz 2x2 e liste corretamente os autovalores σ_i.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software numérico como NumPy ou MATLAB"
                                  ],
                                  "tips": "Escolha μ baseado em estimativas prévias, como traço/n para autovalor médio.",
                                  "learningObjective": "Compreender como o shift altera os autovalores relativos.",
                                  "commonMistakes": [
                                    "Esquecer de subtrair μ da diagonal (I é identidade).",
                                    "Alterar incorretamente as autofunções.",
                                    "Não reconhecer que |σ_min| determina dominância posterior."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Autovalores e Autofunções da Matriz Inversa B^{-1}",
                                  "subSteps": [
                                    "Prove que se B v = σ v, então B^{-1} v = (1/σ) v, preservando v.",
                                    "Mostre que o autovalor de B^{-1} com maior módulo é 1/σ_min, onde σ_min é o menor |σ|.",
                                    "Explique a correspondência: λ = μ + σ = μ + 1 / λ_{B^{-1}}.",
                                    "Verifique numericamente computando B^{-1} para um exemplo.",
                                    "Confirme que autofunções de B^{-1} são idênticas às de B e A."
                                  ],
                                  "verification": "Derive a fórmula λ = μ + 1/λ_inv e aplique a um exemplo numérico.",
                                  "estimatedTime": "30-35 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora matricial ou Python/MATLAB"
                                  ],
                                  "tips": "Use decomposição espectral para verificação teórica em exemplos pequenos.",
                                  "learningObjective": "Estabelecer a transformação matemática exata do problema.",
                                  "commonMistakes": [
                                    "Inverter incorretamente: confundir 1/σ com σ.",
                                    "Achar que autofunções mudam na inversa.",
                                    "Não considerar módulo para dominância (sinais podem variar)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender a Dominância e Integração com Método da Potência Inversa",
                                  "subSteps": [
                                    "Aplique método da potência em B^{-1}: iterações x_{k+1} = B^{-1} x_k / norma.",
                                    "Explique convergência para λ_dom = 1/σ_min devido a |λ_dom| > |outros|.",
                                    "Recupere λ original e v da iteração convergida.",
                                    "Simule 5-10 iterações em um exemplo para observar convergência.",
                                    "Discuta condições: B deve ser invertível (μ ≠ λ_i exatos)."
                                  ],
                                  "verification": "Execute iterações numéricas e confirme convergência ao valor esperado.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Python com NumPy ou MATLAB",
                                    "Papel para iterações manuais"
                                  ],
                                  "tips": "Resolva sistemas lineares em cada iteração em vez de inverter explicitamente para eficiência.",
                                  "learningObjective": "Conectar a teoria à prática computacional do método.",
                                  "commonMistakes": [
                                    "Aplicar potência diretamente em B em vez de B^{-1}.",
                                    "Não normalizar vetores, causando overflow.",
                                    "Ignorar singularidade se μ = λ exato."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[5, 1], [1, 2]] com autovalores ≈5.3 e 1.7. Escolha μ=5. Então B=A-5I=[[0,1],[1,-3]], autovalores σ≈0.3 e -4.3. Para B^{-1}, autovalores ≈3.3 e -0.23 (dominante 3.3). Recupere λ=5 + 1/3.3≈5.3. Autofunções preservadas. Simule potência inversa: inicie x0=[1,1], itere x1=B^{-1}x0/norma, converge a v dominante.",
                              "finalVerifications": [
                                "Deriva corretamente λ = μ + 1/λ_inv onde λ_inv dominante de (A-μI)^{-1}.",
                                "Explica por que o λ mais próximo de μ tem |σ| mínimo e |1/σ| máximo.",
                                "Confirma que autofunções de A, A-μI e (A-μI)^{-1} são as mesmas.",
                                "Aplica transformação em exemplo 2x2 com iterações numéricas precisas.",
                                "Identifica condições de invertibilidade e convergência.",
                                "Relaciona ao método da potência padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação das relações de autovalores.",
                                "Clareza na explicação conceitual da dominância via inversa.",
                                "Correta identificação e preservação de autofunções.",
                                "Proficiência em exemplos numéricos com convergência demonstrada.",
                                "Compreensão de limitações e pré-condições do método.",
                                "Capacidade de generalizar para matrizes maiores."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e análise numérica.",
                                "Computação: Implementação de algoritmos iterativos em Python/MATLAB.",
                                "Engenharia Civil: Análise modal para vibrações estruturais.",
                                "Física: Modos normais e frequências ressonantes em sistemas dinâmicos.",
                                "Estatística: Análise de componentes principais (PCA) via autovalores."
                              ],
                              "realWorldApplication": "Em engenharia civil, o método da potência inversa é crucial para análise computacional de estruturas, como encontrar modos de vibração próximos a frequências sísmicas específicas em pontes ou edifícios, permitindo simulações precisas de resposta dinâmica e dimensionamento seguro contra terremotos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Comparar com o método da potência padrão",
                            "description": "Identificar as diferenças principais: inversão em vez de multiplicação direta, foco em autovalores próximos a μ em vez do dominante, e necessidade de resolver sistemas lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método da Potência Padrão",
                                  "subSteps": [
                                    "Lembre-se que o método da potência padrão itera multiplicando um vetor inicial por A repetidamente para convergir para o autovetor dominante (autovalor de maior módulo).",
                                    "Escreva a fórmula iterativa: v_{k+1} = A v_k / ||A v_k||.",
                                    "Discuta a convergência: converge para λ_max se |λ1| > |λi| para i≠1.",
                                    "Anote condições de falha: autovalores próximos ou matriz não diagonalizável.",
                                    "Pratique com uma matriz 2x2 simples para visualizar."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases descrevendo o algoritmo e convergência; confira com referência padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora ou Python/MATLAB para matriz teste",
                                  "tips": "Sempre normalize o vetor para evitar overflow numérico.",
                                  "learningObjective": "Compreender precisamente o mecanismo e limitações do método da potência padrão.",
                                  "commonMistakes": "Confundir com decomposição espectral completa; ignorar normalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Método da Potência Inversa",
                                  "subSteps": [
                                    "Defina o método: resolve (A - μI) w = v_k para obter v_{k+1} = w / ||w||, convergindo para autovetor com autovalor mais próximo de μ.",
                                    "Explique a inversão: foca em 1/(λ - μ), maximizando para λ próximo a μ.",
                                    "Liste requisitos: resolver sistema linear em cada iteração (ex: Gauss-Seidel).",
                                    "Compare inversamente: potência padrão em A^{-1} encontra menor autovalor se μ=0.",
                                    "Teste conceitualmente com μ próximo a um autovalor não dominante."
                                  ],
                                  "verification": "Desenhe fluxograma do algoritmo e identifique onde ocorre a inversão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Referência teórica (livro de álgebra linear), software para resolver sistemas lineares",
                                  "tips": "Escolha μ inicial baseado em estimativa de Rayleigh para aceleração.",
                                  "learningObjective": "Dominar o papel da inversão e shift μ no método da potência inversa.",
                                  "commonMistakes": "Esquecer de resolver sistema linear; assumir multiplicação direta como no padrão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças Principais",
                                  "subSteps": [
                                    "Diferença 1: Multiplicação direta (padrão) vs. resolução de sistema linear (inversa).",
                                    "Diferença 2: Autovalor dominante (maior |λ|) vs. mais próximo de μ.",
                                    "Diferença 3: Convergência rápida para |λ_max| vs. lenta se μ longe, mas flexível para qualquer λ.",
                                    "Diferença 4: Não requer inversão explícita no padrão; sempre requer no inverso.",
                                    "Diferença 5: Aplicações: padrão para rigidez máxima; inverso para frequências específicas."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 4 colunas (aspecto, potência padrão, potência inversa, implicação).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou papel para tabela, exemplos matriciais impressos",
                                  "tips": "Use setas para mostrar 'inverso' como oposto conceitual ao 'direto'.",
                                  "learningObjective": "Listar e explicar as 3 diferenças principais com precisão.",
                                  "commonMistakes": "Ignorar custo computacional da resolução linear; superestimar velocidade do inverso."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Numericamente em Exemplo",
                                  "subSteps": [
                                    "Escolha matriz A = [[2,1],[1,2]], autovalores 3 e 1.",
                                    "Aplique potência padrão: converge para λ=3.",
                                    "Aplique potência inversa com μ=1.5: converge para λ=1.",
                                    "Meça iterações e erro para ambos.",
                                    "Analise: inverso acessa não dominante, mas mais caro por iteração."
                                  ],
                                  "verification": "Execute simulação e plote convergência; resultados batem com teoria?",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python (NumPy/SciPy) ou MATLAB, matriz exemplo",
                                  "tips": "Use qr_factorização para sistemas lineares eficientes.",
                                  "learningObjective": "Demonstrar diferenças em prática através de experimento controlado.",
                                  "commonMistakes": "Não normalizar vetores; μ mal escolhido atrasando convergência."
                                }
                              ],
                              "practicalExample": "Em uma matriz de rigidez de uma estrutura 3x3 com autovalores 10, 5, 1 (frequências modais), potência padrão acha modo dominante (10), mas inversa com μ=1.2 acha o modo flexível baixo (1), crucial para análise de vibrações em pontes civis.",
                              "finalVerifications": [
                                "Pode listar as 3 diferenças principais sem consultar notas?",
                                "Explica por que inversa resolve sistemas lineares?",
                                "Identifica quando usar cada método em engenharia?",
                                "Compara custo computacional corretamente?",
                                "Aplica shift μ em exemplo numérico?",
                                "Desenha tabela comparativa precisa?"
                              ],
                              "assessmentCriteria": [
                                "Exatidão na descrição da inversão vs. multiplicação (30%)",
                                "Correta identificação do foco em autovalores (25%)",
                                "Análise de convergência e limitações (20%)",
                                "Uso de exemplo numérico ilustrativo (15%)",
                                "Clareza na tabela ou resumo comparativo (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos de vibração em estruturas (equações diferenciais).",
                                "Estatística: Análise de componentes principais (PCA via autovalores).",
                                "Computação: Algoritmos iterativos e condicionamento numérico.",
                                "Matemática Aplicada: Teoria espectral em otimização."
                              ],
                              "realWorldApplication": "Na engenharia civil, comparar métodos para análise modal de edifícios: potência padrão para frequência fundamental (estabilidade sísmica), inversa para modos próximos a ressonância com vento, otimizando projetos em software como ANSYS."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Escolher o valor de shift μ adequadamente",
                            "description": "Determinar um μ inicial baseado em estimativas ou inspeção da matriz, considerando o espectro de autovalores para garantir convergência ao autovalor desejado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel do shift μ no Método da Potência Inversa",
                                  "subSteps": [
                                    "Estudar a fórmula do método: resolver (A - μI)^{-1} v para amplificar o autovalor 1/(λ - μ).",
                                    "Analisar como μ desloca o espectro de autovalores, tornando o desejado dominante.",
                                    "Revisar condições de convergência: μ deve ser próximo ao autovalor alvo para aceleração.",
                                    "Examinar exemplos teóricos onde μ inadequado causa divergência.",
                                    "Discutir o espectro de autovalores e sua relação com a escolha de μ."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito por que μ afeta a convergência, com equação correta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear Numérica",
                                    "Notas de aula sobre autovalores",
                                    "Calculadora ou software simbólico"
                                  ],
                                  "tips": "Visualize o espectro como pontos no plano complexo; μ 'puxa' o autovalor mais próximo.",
                                  "learningObjective": "Compreender teoricamente como o shift μ transforma o problema de autovalores.",
                                  "commonMistakes": [
                                    "Confundir μ com autovalor diretamente",
                                    "Ignorar o inverso na amplificação",
                                    "Não considerar autovalores complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o autovalor desejado no espectro da matriz",
                                  "subSteps": [
                                    "Inspecionar a matriz A: traço, determinantes de submatrizes para estimativas grosseiras.",
                                    "Calcular autovalores exatos se matriz pequena (método característico).",
                                    "Usar inspeção visual ou software para plotar espectro aproximado (ex: Gershgorin).",
                                    "Determinar qual autovalor é o alvo (ex: menor módulo para rigidez em estruturas).",
                                    "Documentar o espectro estimado em tabela ou gráfico."
                                  ],
                                  "verification": "Listar autovalores aproximados e destacar o desejado com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz A de exemplo",
                                    "Software MATLAB/Python (numpy.linalg.eig)",
                                    "Papel e lápis para círculos de Gershgorin"
                                  ],
                                  "tips": "Comece com autovalores extremos (máximo/mínimo) comuns em engenharia.",
                                  "learningObjective": "Identificar precisamente o autovalor de interesse no espectro.",
                                  "commonMistakes": [
                                    "Escolher autovalor errado sem contexto",
                                    "Não usar bounds como Gershgorin",
                                    "Ignorar multiplicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar e selecionar o valor inicial de μ",
                                  "subSteps": [
                                    "Escolher μ como média ponderada ou próximo ao autovalor alvo (ex: μ = λ_desejado ± 0.01).",
                                    "Usar estimativas prévias: traço/n para médio, ou de problemas similares.",
                                    "Ajustar μ para |λ_i - μ| mínimo para o alvo e maior para outros.",
                                    "Testar μ com norma da matriz deslocada para confirmar dominância.",
                                    "Registrar justificativa: 'μ escolhido para maximizar gap espectral'."
                                  ],
                                  "verification": "Calcular gap espectral |1/(λ1 - μ) - 1/(λ2 - μ)| > threshold.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz A",
                                    "Python/MATLAB para normas e autovalores",
                                    "Planilha para cálculos"
                                  ],
                                  "tips": "Para autovalor menor, μ ligeiramente menor que o estimado acelera convergência.",
                                  "learningObjective": "Selecionar μ otimizado baseado em análise espectral.",
                                  "commonMistakes": [
                                    "μ idêntico a autovalor (singularidade)",
                                    "μ muito distante (convergência lenta)",
                                    "Não quantificar proximidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a escolha de μ com iterações iniciais",
                                  "subSteps": [
                                    "Implementar 5-10 iterações do método com μ escolhido.",
                                    "Monitorar norma do vetor iterado e erro relativo ao autovalor.",
                                    "Comparar com outro μ para demonstrar melhoria na taxa de convergência.",
                                    "Ajustar μ se necessário (ex: shift-and-invert refinado).",
                                    "Documentar resultados em gráfico de convergência."
                                  ],
                                  "verification": "Gráfico mostra convergência em <20 iterações com erro <1e-6.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python/MATLAB pronto",
                                    "Matriz de teste",
                                    "Ferramenta de plotagem (matplotlib)"
                                  ],
                                  "tips": "Use vetor inicial aleatório; normalize a cada passo para estabilidade numérica.",
                                  "learningObjective": "Validar empiricamente a adequação de μ.",
                                  "commonMistakes": [
                                    "Poucas iterações para julgar",
                                    "Não normalizar vetores",
                                    "Ignorar erros de arredondamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez A = [[4, -1, 0], [-1, 4, -1], [0, -1, 4]] com autovalores ≈ [2.0, 3.0, 6.0]. Para o menor (≈2.0, modo fundamental), escolha μ=1.9. Após inversa (A-μI)^{-1}, iterações convergem rápido ao autovetor [1,2,1]/norma, simulando deslocamentos em viga.",
                              "finalVerifications": [
                                "μ está a <5% do autovalor alvo.",
                                "Gap espectral > fator 2 entre dominante e próximo.",
                                "Convergência em <15 iterações com tol=1e-6.",
                                "Justificativa teórica documentada.",
                                "Teste com matriz diferente confirma generalidade.",
                                "Gráfico de erro decrescente exponencial."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimativa de μ (nota 1-5).",
                                "Uso correto de ferramentas espectrais (Gershgorin, traço).",
                                "Análise de convergência quantitativa.",
                                "Justificativa clara e teórica.",
                                "Identificação de erros potenciais e correções.",
                                "Aplicação contextual em engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação em Python/NumPy.",
                                "Análise Numérica: Estabilidade e erros de arredondamento.",
                                "Física Estrutural: Modos de vibração em edifícios.",
                                "Estatística: Análise de espectros em dados experimentais.",
                                "Otimização: Escolha de parâmetros para minimizar iterações."
                              ],
                              "realWorldApplication": "Em análise modal de edifícios altos (Engenharia Civil), escolher μ próximo à menor frequência natural permite isolar o modo fundamental de vibração, essencial para dimensionamento sísmico e evitando ressonâncias em terremotos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Algoritmo Iterativo do Método",
                        "description": "Descrição dos passos iterativos: inicializar vetor v_0, normalizar, multiplicar por (A - μI)^{-1} resolvendo sistema linear, repetir até convergência, e recuperar o autovalor original.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Implementar a iteração básica",
                            "description": "Executar os passos: v_{k+1} = (A - μI)^{-1} v_k / ||v_{k+1}||, monitorando o autovalor aproximado como Rayleigh quotient.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar os componentes necessários",
                                  "subSteps": [
                                    "Definir a matriz A e o valor de shift μ aproximado do autovalor desejado.",
                                    "Escolher um vetor inicial v_0 não nulo e normalizá-lo (||v_0|| = 1).",
                                    "Definir critérios de parada, como tolerância ε (ex: 1e-6) e máximo de iterações K_max (ex: 100).",
                                    "Preparar estrutura para armazenar histórico de Rayleigh quotients.",
                                    "Configurar ambiente de programação (ex: Python com NumPy e SciPy)."
                                  ],
                                  "verification": "Verificar se A é quadrada, μ é escalar, v_0 tem norma 1 e critérios estão definidos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python com NumPy, SciPy; matriz A de teste pequena (ex: 3x3).",
                                  "tips": "Use vetores aleatórios para v_0 se não souber um bom chute inicial.",
                                  "learningObjective": "Entender a configuração inicial do algoritmo para garantir estabilidade numérica.",
                                  "commonMistakes": "Escolher v_0 paralelo ao autovetor indesejado; esquecer de normalizar v_0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz shifted e resolver o sistema linear",
                                  "subSteps": [
                                    "Calcular a matriz shifted B = A - μI.",
                                    "Resolver o sistema linear B w = v_k para obter w (use solver eficiente como scipy.linalg.solve).",
                                    "Verificar se B é invertível (condição numérica ou det(B) ≠ 0).",
                                    "Armazenar w como candidato para v_{k+1} não normalizado."
                                  ],
                                  "verification": "Conferir se ||B w - v_k|| < ε para validar a solução do sistema.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Funções de solver linear (NumPy.linalg.solve ou SciPy); matriz B.",
                                  "tips": "Para matrizes grandes/esparsas, prefira métodos iterativos como GMRES em vez de inversão direta.",
                                  "learningObjective": "Dominar a resolução eficiente de sistemas lineares no contexto do método inverso.",
                                  "commonMistakes": "Inverter B explicitamente (instável numericamente); ignorar singularidade perto de μ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Normalizar o novo vetor iterado",
                                  "subSteps": [
                                    "Calcular a norma euclidiana ||w|| de w.",
                                    "Definir v_{k+1} = w / ||w||.",
                                    "Verificar se ||v_{k+1}|| ≈ 1 (dentro de tolerância numérica)."
                                  ],
                                  "verification": "Computar np.linalg.norm(v_k1) e afirmar que está próximo de 1.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Função de norma (np.linalg.norm).",
                                  "tips": "Use norma 2 (euclidiana) para consistência com Rayleigh quotient.",
                                  "learningObjective": "Garantir que os vetores permaneçam na esfera unitária para monitoramento de convergência.",
                                  "commonMistakes": "Normalizar com norma errada (ex: norma 1 ou inf); dividir por zero."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Rayleigh quotient e verificar convergência",
                                  "subSteps": [
                                    "Computar o Rayleigh quotient ρ_{k+1} = v_{k+1}^T A v_{k+1}.",
                                    "Verificar convergência: |ρ_{k+1} - μ| < ε ou |ρ_{k+1} - ρ_k| < ε.",
                                    "Se não convergiu e k < K_max, atualizar v_k = v_{k+1}, incrementar k e repetir do step 2.",
                                    "Registrar histórico de ρ_k para análise.",
                                    "Parar e outputar autovetor aproximado v e autovalor ρ se convergido."
                                  ],
                                  "verification": "Plotar ou listar histórico de ρ_k mostrando estabilização.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Operações matriciais (np.dot); loop de iteração.",
                                  "tips": "Monitore resíduos ||A v - ρ v|| para confirmação adicional de convergência.",
                                  "learningObjective": "Implementar monitoramento preciso da aproximação do autovalor via Rayleigh quotient.",
                                  "commonMistakes": "Confundir ρ com μ (μ é chute inicial); loop infinito sem K_max."
                                }
                              ],
                              "practicalExample": "Para A = [[4, 1, 0], [1, 3, -1], [0, -1, 2]] (autovalores ~4.3, 2.3, 1.4), use μ=1.5, v0=[1,0,0]^T. Após 5 iterações: v ≈ [0.1, -0.7, 0.7]^T, ρ ≈1.414 (√2).",
                              "finalVerifications": [
                                "Rayleigh quotient estabilizado: |ρ_{k+1} - ρ_k| < 1e-8.",
                                "Resíduo pequeno: ||A v - ρ v|| / ||A|| < 1e-6.",
                                "Norma do vetor final é 1.",
                                "Histórico de ρ_k converge monotonicamente para o autovalor alvo.",
                                "Solução do sistema linear precisa em cada iteração.",
                                "Número de iterações ≤ K_max."
                              ],
                              "assessmentCriteria": [
                                "Correção na implementação do solver linear (erro <1e-10).",
                                "Normalização precisa mantendo ||v||=1.",
                                "Cálculo exato do Rayleigh quotient.",
                                "Loop de iteração com critérios de parada robustos.",
                                "Eficiência computacional (tempo <1s para n=100).",
                                "Tratamento de casos edge (B singular)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso de bibliotecas SciPy para álgebra linear.",
                                "Análise Numérica: Estabilidade e condicionamento de sistemas lineares.",
                                "Física/Engenharia: Aplicação em modos de vibração de estruturas.",
                                "Estatística: Análise de componentes principais (PCA) via autovalores."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para análise modal de estruturas (ex: pontes, edifícios), identificando frequências naturais de vibração para design contra terremotos ou vento, otimizando rigidez e evitando ressonâncias."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Resolver sistemas lineares eficientemente",
                            "description": "Usar decomposição LU ou métodos iterativos para resolver (A - μI) w = v_k em cada iteração, otimizando para matrizes esparsas comuns em engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar a matriz e escolher o método de resolução apropriado",
                                  "subSteps": [
                                    "Analise a estrutura da matriz (A - μI): verifique densidade/esparsidade usando funções como nnz() em MATLAB ou scipy.sparse em Python.",
                                    "Determine o condicionamento da matriz com cond() ou np.linalg.cond() para prever estabilidade numérica.",
                                    "Decida entre decomposição LU (para densas) ou métodos iterativos (para esparsas) baseado em tamanho e esparsidade (>50% zeros favorece iterativos).",
                                    "Calcule shift μ inicial se necessário para melhorar condicionamento.",
                                    "Documente a escolha com justificativa quantitativa (ex: % de zeros)."
                                  ],
                                  "verification": "Checklist completo: matriz analisada, método escolhido e justificado em relatório curto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software: MATLAB ou Python (NumPy, SciPy)",
                                    "Matriz de exemplo esparsa de engenharia civil (ex: rigidez de treliça)"
                                  ],
                                  "tips": "Sempre priorize esparsidade em problemas civis; teste com spy() para visualização.",
                                  "learningObjective": "Selecionar método ótimo baseado em propriedades da matriz para eficiência computacional.",
                                  "commonMistakes": [
                                    "Ignorar esparsidade levando a solvers densos lentos",
                                    "Não checar condicionamento causando instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar decomposição LU para matrizes densas",
                                  "subSteps": [
                                    "Forme a matriz aumentada [A - μI | v_k].",
                                    "Execute decomposição LU com pivoteamento parcial usando lu() em MATLAB ou scipy.linalg.lu_factor().",
                                    "Realize substituição forward para resolver Ly = v_k.",
                                    "Realize substituição backward para resolver Ux = y.",
                                    "Extraia w = x e verifique residual ||(A - μI)w - v_k|| < tol."
                                  ],
                                  "verification": "Sistema resolvido com residual < 1e-10; compare com solver direto como \\ em MATLAB.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código template em Python/MATLAB",
                                    "Matriz densa 100x100 gerada sinteticamente"
                                  ],
                                  "tips": "Use pivoteamento sempre para evitar singularidade; armazene L e U para reutilização em iterações.",
                                  "learningObjective": "Executar e validar decomposição LU manualmente para compreensão profunda.",
                                  "commonMistakes": [
                                    "Esquecer pivoteamento causando NaNs",
                                    "Confundir forward/backward substitution"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar métodos iterativos para matrizes esparsas",
                                  "subSteps": [
                                    "Converta matriz para formato esparso (sparse() em MATLAB ou csr_matrix em SciPy).",
                                    "Configure solver iterativo: GMRES ou BiCGSTAB com tolerância 1e-8 e maxiter=1000.",
                                    "Inclua preconditioner simples como ILU se condicionamento alto.",
                                    "Resolva (A - μI)w = v_k e monitore iterações/convergência.",
                                    "Compare tempo de CPU com LU para validar eficiência (>10x mais rápido para n>1000)."
                                  ],
                                  "verification": "Solução converge em <200 iterações com residual <1e-8; tempo medido e reportado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "SciPy.sparse.linalg",
                                    "Exemplo esparso real: matriz de elementos finitos de viga (n=5000)"
                                  ],
                                  "tips": "Ajuste tolerância por iteração da potência inversa; use restarts em GMRES para memória.",
                                  "learningObjective": "Otimizar resolução para esparsidade típica em análise estrutural civil.",
                                  "commonMistakes": [
                                    "Usar formato denso desperdiçando memória",
                                    "Sem preconditioner levando a não-convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar resolução no loop iterativo e otimizar performance",
                                  "subSteps": [
                                    "Incorpore solver escolhido no algoritmo da potência inversa: loop até convergência de autovetor.",
                                    "Profile código com tic/toc ou %timeit para identificar gargalos.",
                                    "Otimize: reutilize decomposição se μ fixo, ou atualize shift adaptativamente.",
                                    "Teste com problema civil real (ex: autovalor menor de estrutura modal).",
                                    "Gere relatório de eficiência: tempo total, precisão vs iterações."
                                  ],
                                  "verification": "Método converge ao autovetor com erro <1e-6 em <50 iterações; speedup quantificado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código completo do método da potência inversa",
                                    "Dataset: modelo FEM de ponte ou edifício"
                                  ],
                                  "tips": "Vectorize operações; use MEX/JIT para aceleração em loops quentes.",
                                  "learningObjective": "Alcançar resolução eficiente em contexto iterativo real de engenharia.",
                                  "commonMistakes": [
                                    "Recomputar decomposição toda iteração",
                                    "Shift μ pobre atrasando convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar para robustez",
                                  "subSteps": [
                                    "Teste sensibilidade a perturbações em A ou μ.",
                                    "Compare resultados com autovalores exatos (eig() para pequenas matrizes).",
                                    "Ajuste parâmetros (tol, maxiter) baseado em benchmarks.",
                                    "Documente pipeline completo em notebook Jupyter.",
                                    "Simule falhas (matriz singular) e implemente fallbacks."
                                  ],
                                  "verification": "Testes passam em 5 cenários variados; código robusto documentado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Suite de testes unitários (pytest)"
                                  ],
                                  "tips": "Sempre normalize w para evitar overflow em iterações.",
                                  "learningObjective": "Garantir solução robusta e confiável para aplicações críticas civis.",
                                  "commonMistakes": [
                                    "Não testar bordes como singularidade",
                                    "Ignorar normalização de vetores"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise modal de uma treliça de ponte (matriz rigidez 2000x2000 esparsa), resolva (K - μM)w = v_k por 20 iterações da potência inversa usando GMRES, alcançando autovalor menor em 15s vs 2min com LU densa.",
                              "finalVerifications": [
                                "Residual do sistema linear <1e-8 em todas iterações.",
                                "Convergência do método da potência inversa em <50 passos.",
                                "Tempo total <10% do solver denso para n>1000.",
                                "Autovetor normalizado com erro relativo <1e-6 vs referência.",
                                "Código roda sem erros em matrizes esparsas civis reais.",
                                "Relatório inclui profiling e speedup quantificado."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: residual e erro de autovetor abaixo de thresholds.",
                                "Eficiência: speedup >5x em esparsas vs denso, medido.",
                                "Robustez: funciona em 80% de casos testados incluindo il-condicionados.",
                                "Código limpo: comentado, modular, com verificações integradas.",
                                "Compreensão: explicação oral da escolha de método e trade-offs.",
                                "Otimização: uso de esparsidade e preconditioners demonstrado."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: fundamentos de autovalores e decomposições matriciais.",
                                "Programação Numérica: SciPy/NumPy para solvers avançados.",
                                "Otimização: escolha de algoritmos baseada em complexidade O(n).",
                                "Engenharia Computacional: modelagem FEM em estruturas civis.",
                                "Análise Numérica: estabilidade e condicionamento de métodos."
                              ],
                              "realWorldApplication": "Na análise dinâmica de edifícios altos ou pontes, resolve eficientemente autovalores para frequências modais, permitindo design sísmico seguro com simulações FEM em tempo real, reduzindo custos computacionais em 90% para malhas grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Aplicar critérios de parada",
                            "description": "Definir tolerâncias para norma do resíduo ||A v - λ v|| < ε ou mudança relativa no autovalor < δ, evitando iterações excessivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os critérios matemáticos de parada",
                                  "subSteps": [
                                    "Estude a definição da norma do resíduo: ||A v_k - λ_k v_k||, onde v_k é o vetor aproximado e λ_k o autovalor aproximado.",
                                    "Analise o critério de mudança relativa no autovalor: |λ_k - λ_{k-1}| / |λ_{k-1}| < δ.",
                                    "Compare os dois critérios: norma do resíduo mede precisão Rayleigh, mudança relativa detecta convergência estabilizada.",
                                    "Revise propriedades do Método da Potência Inversa: convergência quadrática perto do autovalor.",
                                    "Calcule manualmente o resíduo para uma iteração exemplo com matriz pequena."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os dois critérios e forneça um cálculo manual correto de resíduo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, calculadora científica, notas do algoritmo do Método da Potência Inversa.",
                                  "tips": "Visualize graficamente a redução do resíduo ao longo das iterações para intuição.",
                                  "learningObjective": "Dominar as fórmulas matemáticas e interpretações dos critérios de parada.",
                                  "commonMistakes": "Confundir norma do resíduo com erro absoluto no autovalor; ignorar normalização do vetor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir parâmetros de tolerância apropriados",
                                  "subSteps": [
                                    "Avalie o problema: para engenharia civil, ε ~ 10^{-6} para precisão numérica, δ ~ 10^{-8} para estabilidade.",
                                    "Considere o condicionamento da matriz A: tolerâncias menores para matrizes bem condicionadas.",
                                    "Teste sensibilidade: execute iterações preliminares com diferentes ε e observe número de iterações.",
                                    "Defina limites máximos de iterações (ex: 1000) para evitar loops infinitos.",
                                    "Documente escolhas: justifique valores baseados em precisão desejada e recursos computacionais."
                                  ],
                                  "verification": "Crie uma tabela com 3 conjuntos de (ε, δ) e justifique cada um para um problema específico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou software como Excel/Python para testes rápidos, documentação de precisão numérica.",
                                  "tips": "Comece com valores conservadores (maiores) e refine iterativamente para equilibrar precisão e tempo.",
                                  "learningObjective": "Selecionar tolerâncias otimizadas para contexto de engenharia civil.",
                                  "commonMistakes": "Escolher ε muito pequeno levando a iterações excessivas; ignorar erros de arredondamento em floating-point."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar verificações no algoritmo iterativo",
                                  "subSteps": [
                                    "Modifique o loop while: adicione cálculo de resíduo após cada iteração.",
                                    "Implemente normalização: ||v_k|| = 1 antes de calcular resíduo.",
                                    "Inclua verificação dupla: pare se resíduo < ε OU mudança relativa < δ.",
                                    "Adicione logging: registre resíduo e λ a cada 10 iterações para depuração.",
                                    "Teste código com matriz conhecida: verifique parada correta."
                                  ],
                                  "verification": "Execute código com input padrão e confirme parada com mensagens de log corretas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de programação (Python com NumPy ou MATLAB), matriz de teste 3x3.",
                                  "tips": "Use funções vetoriais para eficiência; evite recomputar normas desnecessariamente.",
                                  "learningObjective": "Integrar critérios de parada de forma robusta no código iterativo.",
                                  "commonMistakes": "Esquecer normalização levando a resíduos crescentes; divisão por zero em mudança relativa se λ_{k-1}=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e ajustar critérios em cenários reais",
                                  "subSteps": [
                                    "Aplique a matriz de rigidez de uma estrutura simples (ex: viga com 3 graus de liberdade).",
                                    "Compare resultados com autovalores exatos (via decomposição eig).",
                                    "Analise convergência: plote resíduo vs. iterações e ajuste ε/δ se necessário.",
                                    "Teste robustez: varie vetor inicial e verifique consistência da parada.",
                                    "Relate métricas: número de iterações, tempo CPU, erro final."
                                  ],
                                  "verification": "Gere relatório com gráficos e tabelas mostrando convergência dentro de tolerâncias.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código do passo 3, matrizes de exemplo de engenharia civil, software de plotagem (Matplotlib).",
                                  "tips": "Salve checkpoints de vetores para reinício se não convergir.",
                                  "learningObjective": "Avaliar e refinar critérios para aplicações práticas em análise estrutural.",
                                  "commonMistakes": "Não testar múltiplos iniciais levando a falsos positivos de convergência."
                                }
                              ],
                              "practicalExample": "Para matriz A = [[5, 1, 0], [1, 5, 1], [0, 1, 5]] (rigidez aproximada de treliça), vetor inicial v0 = [1,0,0]^T normalizado. Após iterações da Potência Inversa (shift para menor autovalor ~4), defina ε=1e-6, δ=1e-8. Na iteração 15: resíduo=2.3e-7 < ε, pare e reporte λ≈3.79, v≈[0.41, 0.82, 0.41].",
                              "finalVerifications": [
                                "O algoritmo para automaticamente quando ambos critérios são satisfeitos.",
                                "Número de iterações < 500 para matrizes de tamanho médio.",
                                "Erro no autovalor final < 1% comparado a solução exata.",
                                "Resíduo final plotado mostra platô abaixo de ε.",
                                "Código lida com casos de não-convergência emitindo alerta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática dos critérios (100% correto).",
                                "Escolha justificada de ε/δ com testes de sensibilidade.",
                                "Implementação bug-free com logging e normalização.",
                                "Relatório com validação em pelo menos 2 matrizes diferentes.",
                                "Tempo de execução otimizado (<5s para n=50).",
                                "Explicação clara de ajustes baseados em contexto civil."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação eficiente de loops e normas vetoriais.",
                                "Análise Numérica: Estudo de convergência e estabilidade de algoritmos iterativos.",
                                "Física Aplicada: Modos de vibração em estruturas civis.",
                                "Estatística: Definição de tolerâncias baseada em intervalos de confiança."
                              ],
                              "realWorldApplication": "Em análise modal de edifícios altos, aplica critérios para estimar frequências naturais de vibração, evitando simulações excessivamente longas em softwares como ANSYS, garantindo segurança sísmica com precisão de engenharia."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Análise de Convergência e Aplicações",
                        "description": "Estudo da taxa de convergência linear dependente da razão |λ_2 - μ| / |λ_1 - μ|, acelerações como deflação, e uso em problemas de engenharia civil como análise modal de estruturas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Analisar condições de convergência",
                            "description": "Calcular a taxa de convergência ρ = |λ^{(2)} - μ| / |λ^{(1)} - μ|, onde λ^{(1)} é o autovalor mais próximo de μ, e identificar casos de falha como autovalores múltiplos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz e definir o parâmetro de deslocamento μ",
                                  "subSteps": [
                                    "Identifique a matriz A simétrica positiva definida do problema de autovalores.",
                                    "Escolha μ como uma aproximação inicial próxima ao autovalor de interesse (ex: baseado em estimativa de Rayleigh).",
                                    "Construa a matriz deslocada B = (A - μI)^{-1}, verificando invertibilidade.",
                                    "Implemente ou configure software para computar autovalores de B.",
                                    "Documente a escolha de μ e justifique sua proximidade ao autovalor alvo."
                                  ],
                                  "verification": "Confirme que B está corretamente formada e invertível, testando com um vetor teste.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Matriz A de exemplo, calculadora científica ou MATLAB/Python (NumPy/SciPy), papel para anotações.",
                                  "tips": "Escolha μ dentro do intervalo espectral de A para garantir convergência rápida.",
                                  "learningObjective": "Compreender o papel de μ no método da potência inversa e preparar a matriz deslocada.",
                                  "commonMistakes": "Escolher μ fora do espectro levando a singularidade; não verificar simetria de A."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e ordenar os autovalores de B pela proximidade a 1",
                                  "subSteps": [
                                    "Compute todos os autovalores λ^{(k)} da matriz B usando decomposição ou bibliotecas numéricas.",
                                    "Ordene os autovalores em ordem decrescente de magnitude: |λ^{(1)}| ≥ |λ^{(2)}| ≥ ...",
                                    "Identifique λ^{(1)} como o de maior magnitude (mais próximo de 1 em módulo para convergência).",
                                    "Mapeie de volta para autovalores de A: λ_A^{(k)} = μ + 1/λ^{(k)}.",
                                    "Liste os três primeiros autovalores ordenados por proximidade ao autovalor alvo de A."
                                  ],
                                  "verification": "Verifique se a soma dos autovalores coincide com o traço de B (propriedade espectral).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software numérico (MATLAB eig(), Python scipy.linalg.eig()), matriz B preparada.",
                                  "tips": "Use precisão numérica alta para evitar erros de arredondamento em autovalores próximos.",
                                  "learningObjective": "Dominar o cálculo e ordenação de autovalores no contexto deslocado.",
                                  "commonMistakes": "Confundir ordenação por magnitude com proximidade a μ; ignorar mapeamento inverso."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a taxa de convergência ρ",
                                  "subSteps": [
                                    "Selecione λ^{(1)} como autovalor de B mais próximo de 1 (maior módulo).",
                                    "Identifique λ^{(2)} como o segundo mais próximo.",
                                    "Calcule ρ = |λ^{(2)}| / |λ^{(1)}| (taxa assintótica de convergência).",
                                    "Mapeie para termos de A: ρ = |λ_A^{(2)} - μ| / |λ_A^{(1)} - μ|.",
                                    "Registre ρ com precisão decimal e interprete: ρ < 1 indica convergência."
                                  ],
                                  "verification": "ρ deve satisfazer 0 < ρ < 1 para convergência; teste com ρ=1 sinalizando problema.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Lista de autovalores ordenados, calculadora.",
                                  "tips": "Use fórmula exata para pequenos problemas para validar computação numérica.",
                                  "learningObjective": "Aplicar a fórmula de ρ corretamente e relacioná-la à velocidade de convergência.",
                                  "commonMistakes": "Usar λ^{(1)} errado ou esquecer o módulo absoluto; calcular para A diretamente sem deslocamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar casos de falha e interpretar resultados",
                                  "subSteps": [
                                    "Verifique se |λ^{(1)}| ≈ 1 e ρ próximo de 0 (boa convergência).",
                                    "Detecte autovalores múltiplos: se |λ^{(1)}| = |λ^{(2)}|, ρ=1, método falha.",
                                    "Identifique outros casos: autovalores complexos ou μ mal escolhido.",
                                    "Recomende ajustes: novo μ ou métodos alternativos (ex: deflação).",
                                    "Resuma análise em relatório: ρ calculado, condições de convergência atendidas."
                                  ],
                                  "verification": "Simule iterações iniciais do método para confirmar taxa observada ≈ ρ.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código para iterações do método da potência inversa, relatório template.",
                                  "tips": "Sempre teste com matrizes pequenas conhecidas para validar detecção de falhas.",
                                  "learningObjective": "Diagnosticar falhas de convergência e propor soluções práticas.",
                                  "commonMistakes": "Ignorar multiplicidade algébrica vs geométrica; não simular para confirmação."
                                }
                              ],
                              "practicalExample": "Para matriz A = [[2,1],[1,2]] (autovalores 3 e 1), escolha μ=2.5. B = (A - 2.5I)^{-1} tem λ_B ≈ 2 e 0.5. Então ρ = |0.5|/|2| = 0.25, indicando convergência rápida; simule 5 iterações para eigenvector próximo de [1,1].",
                              "finalVerifications": [
                                "ρ calculado corretamente com ρ < 1.",
                                "Autovalores ordenados e mapeados de volta para A.",
                                "Casos de falha (ex: ρ=1) identificados e explicados.",
                                "Simulação numérica confirma taxa de convergência.",
                                "Relatório resume análise com justificativas.",
                                "Fórmula aplicada sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de ρ (erro < 1e-6).",
                                "Correta identificação de λ^{(1)} e λ^{(2)} pela proximidade a μ.",
                                "Detecção precisa de falhas como autovalores múltiplos.",
                                "Interpretação qualitativa de ρ (rápida/lenta/falha).",
                                "Uso adequado de ferramentas numéricas sem erros de implementação.",
                                "Relatório claro com fórmulas e resultados numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Linear (decomposição espectral).",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física: Análise de vibrações em estruturas civis.",
                                "Estatística: Análise de erro e convergência assintótica."
                              ],
                              "realWorldApplication": "Em engenharia civil, analisar convergência no método da potência inversa para encontrar frequências naturais de vigas ou edifícios, otimizando simulações em software como ANSYS para projetos sísmicos seguros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Resolver exemplo numérico manualmente",
                            "description": "Aplicar o método a uma matriz 3x3 simples, computando 5 iterações à mão para ilustrar convergência ao autovalor próximo a μ = 2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração Inicial do Problema",
                                  "subSteps": [
                                    "Defina a matriz A 3x3 exemplo: A = [[2, 1, 0], [1, 2, 1], [0, 1, 2]].",
                                    "Estabeleça μ = 2 como o valor de deslocamento para o autovalor alvo.",
                                    "Calcule a matriz B = A - μI = [[0, 1, 0], [1, 0, 1], [0, 1, 0]].",
                                    "Escolha um vetor inicial x₀ = [1, 0, 0]ᵀ (não normalizado).",
                                    "Prepare uma tabela para registrar x_k, y_k, norma e λ_k estimado em cada iteração."
                                  ],
                                  "verification": "Verifique se B está corretamente calculada multiplicando B por um vetor teste simples e confirmando igual a (A - 2I)v.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora científica.",
                                  "tips": "Use frações exatas inicialmente para evitar erros de arredondamento precoce.",
                                  "learningObjective": "Compreender a preparação do problema e o papel do deslocamento μ na Potência Inversa.",
                                  "commonMistakes": "Esquecer de subtrair μ da diagonal principal; escolher x₀ nulo ou dependente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver Método de Resolução do Sistema Linear By = x",
                                  "subSteps": [
                                    "Aplique eliminação gaussiana na matriz aumentada [B | x] para resolver By = x.",
                                    "Para B tridiagonal, use forward elimination: pivô na posição (1,2), elimine abaixo.",
                                    "Realize back-substitution para obter y.",
                                    "Teste o método com x₀ para obter y₁.",
                                    "Defina procedimento padronizado para reutilizar nas iterações subsequentes."
                                  ],
                                  "verification": "Confirme que By ≈ x com erro < 10^{-3} usando multiplicação matricial manual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, régua para alinhar equações, calculadora.",
                                  "tips": "Pivoteie se necessário, mas para esta B simétrica, eliminação direta funciona bem.",
                                  "learningObjective": "Dominar resolução manual de sistemas lineares 3x3 para iterações.",
                                  "commonMistakes": "Dividir pelo pivô zero (não ocorre aqui); erros de sinal na eliminação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Iterações 1 a 3 do Método",
                                  "subSteps": [
                                    "Para k=0: Resolva By₁ = x₀, compute ||y₁||₂, x₁ = y₁ / ||y₁||₂.",
                                    "Estime λ₁ = x₁ᵀ A x₁ (calcule manualmente A x₁ primeiro).",
                                    "Repita para k=1: By₂ = x₁, normalize para x₂, λ₂ = x₂ᵀ A x₂.",
                                    "Continue para k=2: By₃ = x₂, x₃, λ₃.",
                                    "Registre todos os valores em tabela, notando mudanças nos componentes de x_k."
                                  ],
                                  "verification": "Verifique se ||B x_k|| ≈ ||x_{k-1}|| e λ_k próximo de 2 (ex: λ₁≈2.5, λ₂≈2.2).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, calculadora para normas euclidianas (√(a²+b²+c²)).",
                                  "tips": "Mantenha 4 casas decimais; normalize usando norma L2 para consistência.",
                                  "learningObjective": "Aplicar iterações manuais e observar convergência inicial.",
                                  "commonMistakes": "Não normalizar y_k; erro em Rayleigh quotient (xᵀAx ao invés de xᵀx=1)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Completar Iterações 4-5 e Analisar Convergência",
                                  "subSteps": [
                                    "Para k=3: By₄ = x₃, x₄ = y₄ / ||y₄||, λ₄.",
                                    "Para k=4: By₅ = x₄, x₅, λ₅.",
                                    "Compare x₄ e x₅ (diferença <0.01 em componentes).",
                                    "Plote ou tabule λ_k vs k, confirmando |λ_k - 2| diminuindo.",
                                    "Identifique autovetor final ≈ [0.408, 0.816, 0.408]ᵀ e λ≈2."
                                  ],
                                  "verification": "x₅ ≈ x₄ e λ₅ ≈ 2 com erro <0.01; A x₅ ≈ 2 x₅.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para gráfico simples de convergência, calculadora.",
                                  "tips": "Use resíduos r_k = ||A x_k - λ_k x_k|| para quantificar precisão.",
                                  "learningObjective": "Avaliar taxa de convergência e validar resultados finais.",
                                  "commonMistakes": "Arredondamento acumulado; ignorar normalização inconsistente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificação Final e Interpretação",
                                  "subSteps": [
                                    "Calcule autovalores exatos de A (característica: det(A-λI)=0) para comparar.",
                                    "Confirme convergência ao autovalor 2 (mais próximo de μ).",
                                    "Discuta por que convergiu para λ=2 e não 1 ou 3.",
                                    "Documente lições: passos exatos, erros observados.",
                                    "Sugira melhorias como μ mais próximo ou pré-condicionamento."
                                  ],
                                  "verification": "Erro final |λ₅ - 2| < 0.001 e ||A x₅ - 2 x₅|| < 0.01.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora para polinômio característico.",
                                  "tips": "Autovalores exatos: raízes de (λ-1)(λ-2)^2=0.",
                                  "learningObjective": "Interpretar resultados e conectar teoria à prática numérica.",
                                  "commonMistakes": "Confundir autovalor dominante com deslocado; não validar com multiplicação."
                                }
                              ],
                              "practicalExample": "Para A = [[2,1,0],[1,2,1],[0,1,2]], μ=2, x₀=[1,0,0]ᵀ. Após iteração 1: y₁≈[0,1,0]ᵀ, x₁=[0,1,0]ᵀ, λ₁=2. Após 5 iterações: x₅≈[0.408,0.816,0.408]ᵀ, λ₅=2.000 (convergência ilustrada pela estabilização de x_k e λ_k→2).",
                              "finalVerifications": [
                                "λ_k converge para 2 com |λ₅ - 2| < 0.01.",
                                "Componentes de x_k estabilizam (ex: x_{k+1} - x_k < 0.01 em norma).",
                                "A x₅ ≈ 2 x₅ verificado por multiplicação matricial.",
                                "Tabela de iterações completa sem erros aritméticos evidentes.",
                                "Resíduo r₅ = ||A x₅ - λ₅ x₅|| < 0.05.",
                                "Explicação coerente da convergência ao autovalor mais próximo de μ."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos manuais (erros <0.001 por iteração).",
                                "Correta normalização e Rayleigh quotient em todas as iterações.",
                                "Evidência de compreensão da eliminação gaussiana (passos mostrados).",
                                "Análise qualitativa/quantitativa de convergência (gráfico ou tabela).",
                                "Validação final com multiplicação A x ≈ λ x.",
                                "Clareza na documentação e identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Integra com métodos iterativos como Gauss-Seidel.",
                                "Programação: Implementação em Python com NumPy para automação.",
                                "Física Estrutural: Autovalores em análise modal de vibrações.",
                                "Estatística: Análise de componentes principais (PCA) via decomposição.",
                                "Engenharia de Software: Verificação numérica e estabilidade de algoritmos."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, o Método da Potência Inversa é usado para extrair frequências naturais (autovalores) de matrizes de rigidez/massa em análise dinâmica de edifícios, permitindo prever modos de vibração e projetar contra ressonância em terremotos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Implementar em software numérico",
                            "description": "Codificar o método em MATLAB ou Python usando bibliotecas como numpy/scipy para matrizes de rigidez em problemas de engenharia civil, validando com autovalores exatos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e preparar matriz de rigidez",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias: numpy e scipy via pip.",
                                    "Definir uma matriz de rigidez simétrica positiva definida exemplo para uma estrutura simples (ex: treliça 2D com 3 nós).",
                                    "Calcular autovalores exatos usando scipy.linalg.eigvals para referência.",
                                    "Definir tolerância de convergência (ex: 1e-6) e número máximo de iterações (ex: 1000)."
                                  ],
                                  "verification": "Matriz criada corretamente e autovalores exatos computados sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python 3.x, bibliotecas numpy, scipy; editor como Jupyter Notebook ou VS Code.",
                                  "tips": "Use matrizes pequenas inicialmente (3x3 ou 4x4) para depuração rápida.",
                                  "learningObjective": "Preparar dados de entrada representativos de problemas reais em engenharia civil.",
                                  "commonMistakes": "Esquecer de garantir simetria da matriz ou usar matriz não positiva definida."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o algoritmo do Método da Potência Inversa",
                                  "subSteps": [
                                    "Inicializar vetor próprio aleatório normalizado.",
                                    "Em loop: resolver sistema linear K * v = b onde b é vetor anterior (usar scipy.linalg.solve).",
                                    "Normalizar novo vetor e estimar autovalor como Rayleigh quotient (v^T K v / v^T v).",
                                    "Verificar critério de parada: mudança no autovalor < tolerância."
                                  ],
                                  "verification": "Código executa iterações sem singularidade e converge em <1000 passos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código Python com numpy para operações vetoriais e scipy para solve.",
                                  "tips": "Use shift=0 para menor autovalor em matrizes de rigidez.",
                                  "learningObjective": "Codificar iterativamente o método para extrair autovalor dominante invertido.",
                                  "commonMistakes": "Não normalizar vetor a cada iteração, levando a overflow numérico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar resultados com autovalores exatos",
                                  "subSteps": [
                                    "Comparar autovalor aproximado com o menor autovalor exato (de eigvals).",
                                    "Calcular erro relativo: |λ_aprox - λ_exato| / |λ_exato|.",
                                    "Verificar ortogonalidade do vetor próprio com outros autovetores.",
                                    "Plotar histórico de convergência (autovalor vs iteração) usando matplotlib."
                                  ],
                                  "verification": "Erro relativo < 1e-6 e gráfico mostra convergência suave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Biblioteca matplotlib para visualização.",
                                  "tips": "Salve histórico em listas para plotting eficiente.",
                                  "learningObjective": "Garantir precisão numérica da implementação.",
                                  "commonMistakes": "Comparar com autovalor errado (não o menor)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar convergência e testar em problema maior",
                                  "subSteps": [
                                    "Testar com matriz maior (ex: 10x10 de uma viga ou frame simples).",
                                    "Medir número de iterações e tempo de CPU para convergência.",
                                    "Experimentar acelerações como deflação para múltiplos autovalores.",
                                    "Documentar achados em relatório curto com código comentado."
                                  ],
                                  "verification": "Convergência confirmada em problemas realistas com relatório gerado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matrizes de rigidez geradas via código ou arquivos .csv.",
                                  "tips": "Use %timeit no Jupyter para benchmark.",
                                  "learningObjective": "Avaliar robustez e escalabilidade do método.",
                                  "commonMistakes": "Ignorar conditioning da matriz, causando lentidão."
                                }
                              ],
                              "practicalExample": "Para uma treliça 2D com 3 nós e matriz de rigidez 4x4: [[2,-1,0,-1],[-1,2,-1,0],[0,-1,2,-1],[-1,0,-1,2]] * 1e6 N/m. O menor autovalor exato é ~0.5858e6. Implemente para convergir a λ≈0.5858e6 e vetor [0.5,0.5,0.5,0.5]/norm.",
                              "finalVerifications": [
                                "Código roda sem erros numéricos em matrizes até 20x20.",
                                "Erro relativo do autovalor < 1e-8 após convergência.",
                                "Gráfico de convergência mostra platô em <200 iterações.",
                                "Vetor próprio normalizado com norma euclidiana ≈1.",
                                "Tempo total de execução <5s para matriz 10x10.",
                                "Comentários no código explicam cada seção."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro relativo <1e-6.",
                                "Eficiência: convergência em <500 iterações.",
                                "Robustez: funciona com matrizes mal-condicionadas.",
                                "Clareza: código legível com comentários e funções modulares.",
                                "Validação: comparação quantitativa com eigvals.",
                                "Visualização: plots de convergência incluídos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: compreensão de autovalores em sistemas lineares.",
                                "Programação Computacional: uso de solvers numéricos em Python/MATLAB.",
                                "Engenharia Mecânica: análise modal de vibrações estruturais.",
                                "Matemática Numérica: métodos iterativos e análise de erro."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para análise de estabilidade de edifícios e pontes: o menor autovalor da matriz de rigidez indica frequência fundamental de vibração, crítico para design sísmico e otimização de estruturas contra colapso."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Algoritmo QR",
                    "description": "Método de decomposição QR para cálculo de todos os autovalores e autofunções de forma eficiente.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Decomposição QR",
                        "description": "Processo de fatoração de uma matriz A em um produto de uma matriz ortogonal Q e uma matriz triangular superior R, fundamental para o algoritmo QR.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Entender a definição de decomposição QR",
                            "description": "Compreender que qualquer matriz quadrada real A pode ser decomposta como A = QR, onde Q é ortogonal (Q^T Q = I) e R é triangular superior, e sua importância na estabilização numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Matrizes Quadradas Reais",
                                  "subSteps": [
                                    "Defina uma matriz quadrada como uma matriz n x n com entradas reais.",
                                    "Liste propriedades fundamentais: soma, produto, inversa (se existir).",
                                    "Identifique exemplos de matrizes quadradas reais de ordem 2 e 3.",
                                    "Diferencie de matrizes retangulares.",
                                    "Verifique se uma dada matriz A satisfaz ser quadrada e real."
                                  ],
                                  "verification": "Construa e valide duas matrizes quadradas reais de 2x2, confirmando dimensões e entradas reais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, caneta, software como MATLAB ou Python (NumPy) para verificação opcional.",
                                  "tips": "Sempre confira dimensões: linhas = colunas para quadrada.",
                                  "learningObjective": "Estabelecer a base conceitual para matrizes aplicáveis à decomposição QR.",
                                  "commonMistakes": "Confundir matrizes quadradas com simétricas ou ignorar que entradas devem ser reais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Matrizes Ortogonais",
                                  "subSteps": [
                                    "Defina matriz ortogonal Q: Q^T Q = I, onde I é a identidade.",
                                    "Explique que colunas (e linhas) de Q formam base ortonormal.",
                                    "Calcule Q^T Q para uma matriz 2x2 simples e verifique igualdade a I.",
                                    "Discuta propriedades: preserva normas e ângulos (isometria).",
                                    "Construa uma matriz ortogonal rotacionando vetores unitários."
                                  ],
                                  "verification": "Para uma Q 2x2, compute Q^T Q e confirme que resulta na matriz identidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora matricial, Python/NumPy ou MATLAB para multiplicação.",
                                  "tips": "Lembre-se: ortogonalidade é simétrica, Q^{-1} = Q^T.",
                                  "learningObjective": "Dominar a propriedade chave de Q na decomposição QR.",
                                  "commonMistakes": "Esquecer transposição ou confundir com unitária (apenas para complexas)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender Matrizes Triangulares Superiores e Decomposição QR",
                                  "subSteps": [
                                    "Defina matriz triangular superior R: entradas abaixo da diagonal principal são zero.",
                                    "Explique decomposição QR: A = Q R para qualquer A quadrada real.",
                                    "Verifique unicidade sob condições (diagonal de R positiva).",
                                    "Dê um exemplo simples: encontre Q e R para A = [[3, 1], [1, 3]].",
                                    "Descreva processo conceitual via Gram-Schmidt."
                                  ],
                                  "verification": "Decomponha uma matriz 2x2 dada em QR e confirme A = Q R.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel para cálculos manuais, software numérico para validação.",
                                  "tips": "Use Gram-Schmidt para ortogonalizar colunas de A.",
                                  "learningObjective": "Internalizar a definição exata de A = QR.",
                                  "commonMistakes": "Confundir R com triangular inferior ou ignorar ortogonalidade de Q."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Importância da Decomposição QR na Estabilização Numérica",
                                  "subSteps": [
                                    "Discuta instabilidades em métodos diretos para autovalores (ex: power method).",
                                    "Explique como QR itera para autovalores: A_k = Q_k R_k, A_{k+1} = R_k Q_k.",
                                    "Compare com decomposições LU: QR é mais estável numericamente.",
                                    "Analise erro de arredondamento em implementações.",
                                    "Relacione a análise estrutural em engenharia civil."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito por que QR estabiliza o algoritmo de autovalores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Artigos ou vídeos sobre algoritmo QR, exemplos numéricos em software.",
                                  "tips": "Foco em convergência: diagonais de R aproximam autovalores.",
                                  "learningObjective": "Compreender aplicação prática e superioridade numérica de QR.",
                                  "commonMistakes": "Subestimar erros de floating-point em outras decomposições."
                                }
                              ],
                              "practicalExample": "Considere a matriz A = [[12, -51], [6, 166]]. Aplicando Gram-Schmidt: colunas normalizadas formam Q = [[0.8575, 0.5145], [0.4287, 0.8575]], e R = [[14, -56], [0, 167.77]]. Verifique A ≈ Q R, ilustrando decomposição exata com Q ortogonal e R triangular superior.",
                              "finalVerifications": [
                                "Defina precisamente decomposição QR com propriedades de Q e R.",
                                "Forneça exemplo 2x2 com Q^T Q = I e A = Q R.",
                                "Explique unicidade da decomposição.",
                                "Descreva papel na estabilização do algoritmo QR para autovalores.",
                                "Identifique quando QR é preferível a LU.",
                                "Relacione a contexto de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de Q ortogonal (Q^T Q = I).",
                                "Correção na identificação de R como triangular superior.",
                                "Compreensão da aplicabilidade universal a matrizes quadradas reais.",
                                "Explicação clara da estabilização numérica vs. outros métodos.",
                                "Uso correto de terminologia e exemplos válidos.",
                                "Conexão lógica com algoritmo QR para autovalores."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: bases ortonormais e Gram-Schmidt.",
                                "Cálculo Numérico: análise de erros e estabilidade.",
                                "Engenharia Computacional: solvers para sistemas lineares.",
                                "Física: transformações ortogonais em mecânica.",
                                "Programação: implementação em Python/MATLAB para simulações."
                              ],
                              "realWorldApplication": "Na engenharia civil, a decomposição QR é essencial no algoritmo QR para calcular autovalores e autofunções em análises modais de estruturas como pontes e edifícios, garantindo estabilidade numérica em simulações de vibrações e respostas sísmicas, evitando erros de propagação em grandes matrizes de rigidez."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Aplicar o processo Gram-Schmidt para obter Q",
                            "description": "Implementar o processo de Gram-Schmidt modificado para ortogonalizar as colunas de A e obter Q, garantindo estabilidade numérica contra perdas de ortogonalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz de entrada e inicializar estruturas de dados",
                                  "subSteps": [
                                    "Receba a matriz A de dimensões m x n (m >= n) com colunas linearmente independentes.",
                                    "Crie a matriz Q de tamanho m x n inicializada com zeros.",
                                    "Crie a matriz R de tamanho n x n inicializada com zeros.",
                                    "Verifique se a norma da primeira coluna a1 não é zero (threshold 1e-12)."
                                  ],
                                  "verification": "Dimensões de A, Q e R confirmadas; norma de a1 > 0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Matriz A de exemplo",
                                    "Ambiente de programação (Python com NumPy ou MATLAB)"
                                  ],
                                  "tips": "Trabalhe sempre com precisão de ponto flutuante dupla (float64).",
                                  "learningObjective": "Configurar corretamente as estruturas para o algoritmo Gram-Schmidt modificado.",
                                  "commonMistakes": [
                                    "Índices incorretos para m e n",
                                    "Inicializar Q como identidade em vez de zeros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Processar a primeira coluna: normalização inicial",
                                  "subSteps": [
                                    "Defina v1 como a primeira coluna de A (a1).",
                                    "Calcule r11 = norma euclidiana de v1 (sqrt(v1^T v1)).",
                                    "Se r11 < 1e-12, reporte dependência linear.",
                                    "Defina q1 = v1 / r11.",
                                    "Armazene q1 na primeira coluna de Q e r11 em R[1,1]."
                                  ],
                                  "verification": "||q1|| = 1 (verificar norma euclidiana).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Funções de norma (np.linalg.norm) e divisão vetorial"
                                  ],
                                  "tips": "Use norma L2 (euclidiana) explicitamente.",
                                  "learningObjective": "Implementar a base ortonormal inicial.",
                                  "commonMistakes": [
                                    "Dividir por norma zero sem checagem",
                                    "Confundir norma L1 ou L-infinito com L2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar projeções ortogonais para colunas subsequentes",
                                  "subSteps": [
                                    "Para j = 2 até n:",
                                    "  Defina vj = coluna j de A (aj).",
                                    "  Para i = 1 até j-1:",
                                    "    Calcule rij = transposta(qi) * vj (produto escalar).",
                                    "    Atualize vj = vj - rij * qi imediatamente.",
                                    "  Armazene cada rij em R[i,j]."
                                  ],
                                  "verification": "Após cada i, qi^T * vj ≈ 0 (erro < 1e-12).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Loops aninhados",
                                    "Função de produto escalar (np.dot)"
                                  ],
                                  "tips": "Atualize vj após cada projeção individual para garantir estabilidade numérica (característica do MGS).",
                                  "learningObjective": "Executar projeções sequenciais no Gram-Schmidt modificado.",
                                  "commonMistakes": [
                                    "Calcular todas rij antes de subtrair (isso é Classical GS, instável)",
                                    "Erros de indexação em loops duplos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Normalizar colunas restantes e completar Q e R",
                                  "subSteps": [
                                    "Continuando para cada j = 2 até n:",
                                    "  Calcule rjj = norma euclidiana de vj atualizado.",
                                    "  Se rjj < 1e-12, reporte dependência linear.",
                                    "  Defina qj = vj / rjj.",
                                    "  Armazene qj na coluna j de Q e rjj em R[j,j]."
                                  ],
                                  "verification": "||qj|| = 1 para todas as colunas de Q.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Função de norma euclidiana"
                                  ],
                                  "tips": "Defina uma tolerância numérica fixa (ex: 1e-12) para zeros.",
                                  "learningObjective": "Finalizar a ortonormalização e preencher R.",
                                  "commonMistakes": [
                                    "Normalizar vj antes de todas as projeções",
                                    "Esquecer de armazenar elementos diagonais de R"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar ortogonalidade, decomposição e estabilidade",
                                  "subSteps": [
                                    "Compute QtQ = transposta(Q) * Q e verifique se diagonal ≈ 1 e off-diagonal ≈ 0.",
                                    "Compute QR = Q * R e verifique ||A - QR||_F < 1e-10 (norma Frobenius).",
                                    "Compare com decomposição QR built-in (np.linalg.qr(A)).",
                                    "Meça perda de ortogonalidade: ||I - QtQ||_F < 1e-12.",
                                    "Teste com matriz ill-conditioned para demonstrar estabilidade."
                                  ],
                                  "verification": "Todos os testes passam com erros abaixo dos thresholds.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Multiplicação de matrizes",
                                    "Função QR built-in",
                                    "Norma Frobenius"
                                  ],
                                  "tips": "Para matrizes grandes, use vetores esparsos se aplicável.",
                                  "learningObjective": "Validar correção e superioridade numérica do MGS.",
                                  "commonMistakes": [
                                    "Ignorar erros de arredondamento em verificações",
                                    "Não testar com built-in para benchmark"
                                  ]
                                },
                                {
                                  "practicalExample": "Considere A = [[1, 1], [1, 0], [0, 1]] (3x2).\n- v1 = [1,1,0]^T, r11 = sqrt(2), q1 = [1/sqrt(2), 1/sqrt(2), 0]^T.\n- j=2, v2 = [1,0,1]^T, r12 = q1^T v2 = 1/sqrt(2), v2 -= r12 q1 → [0.5, -0.5, 1]^T.\n- r22 = sqrt(1.5), q2 = v2 / r22.\nResultado: Q com colunas unitárias e ortogonais, R = [[sqrt(2), 1/sqrt(2)], [0, sqrt(1.5)]], A ≈ Q R.",
                                  "finalVerifications": [
                                    "Q^T Q ≈ I (identidade dentro de 1e-12)",
                                    "||A - Q R||_F < 1e-10",
                                    "Elementos diagonais de R positivos",
                                    "Colunas de Q têm norma unitária",
                                    "Perda de ortogonalidade ||I - Q^T Q||_F < 1e-12"
                                  ],
                                  "assessmentCriteria": [
                                    "Implementação usa Modified GS (atualização imediata de vj)",
                                    "Tratamento correto de singularidade (thresholds)",
                                    "Verificação numérica completa incluída",
                                    "Código eficiente O(m n^2) com loops otimizados",
                                    "Demonstração de estabilidade vs. Classical GS em exemplo"
                                  ],
                                  "crossCurricularConnections": [
                                    "Álgebra Linear: bases ortonormais e produto interno",
                                    "Análise Numérica: erros de arredondamento e estabilidade",
                                    "Programação Computacional: vetores e loops em NumPy/MATLAB",
                                    "Engenharia Civil: solvers para matrizes de rigidez em elementos finitos"
                                  ],
                                  "realWorldApplication": "Na engenharia civil, o algoritmo QR via Gram-Schmidt modificado é usado para decompor matrizes de rigidez em análises modais de estruturas (ex: vibrações de pontes e edifícios), garantindo precisão numérica em problemas de autovalores para prever estabilidade e modos de falha."
                                }
                              ]
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Calcular a matriz R a partir de Q e A",
                            "description": "Derivar R = Q^T A após a obtenção de Q, verificando propriedades como diagonalidade positiva para matrizes simétricas positivas definidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as matrizes Q e A para o cálculo",
                                  "subSteps": [
                                    "Confirme que Q é uma matriz ortogonal (Q^T Q = I) do passo anterior do algoritmo QR.",
                                    "Verifique que A é simétrica positiva definida (SPD), com todos autovalores positivos.",
                                    "Anote as dimensões de Q (n x n) e A (n x n) para garantir compatibilidade.",
                                    "Copie Q e A em um ambiente de cálculo matricial.",
                                    "Calcule det(Q) para confirmar ortogonalidade aproximada (deve ser ±1)."
                                  ],
                                  "verification": "Q^T Q resulta em matriz identidade dentro de tolerância numérica (ex: 10^-10).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Software como MATLAB, Python (NumPy), ou papel e lápis para matrizes pequenas.",
                                  "tips": "Use funções prontas como qr() em MATLAB para validar Q prévio.",
                                  "learningObjective": "Entender pré-condições para validade da decomposição QR.",
                                  "commonMistakes": "Ignorar erros numéricos em Q, levando a R inválido; assumir A não SPD."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a transposta de Q (Q^T)",
                                  "subSteps": [
                                    "Identifique Q como matriz n x n.",
                                    "Aplique transposição: elemento (i,j) de Q^T é Q(j,i).",
                                    "Para implementação numérica, use transpose() ou .T em NumPy.",
                                    "Verifique manualmente para matrizes 2x2: linhas viram colunas.",
                                    "Armazene Q^T separadamente para multiplicação."
                                  ],
                                  "verification": "Multiplique Q * Q^T e confirme identidade (off-diagonais ~0, diagonal ~1).",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Calculadora matricial ou software (MATLAB: Q', NumPy: Q.T).",
                                  "tips": "Em código, evite loops manuais; use operações vetoriais para eficiência.",
                                  "learningObjective": "Dominar transposição matricial e sua propriedade em bases ortogonais.",
                                  "commonMistakes": "Confundir Q^T com inversa (para ortogonal, coincidem, mas verifique numericamente)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar a multiplicação Q^T * A para obter R",
                                  "subSteps": [
                                    "Confirme dimensões: Q^T (n x n) * A (n x n) → R (n x n).",
                                    "Calcule cada elemento R_ij = soma_k Q^T_ik * A_kj.",
                                    "Implemente em software: R = Q' * A (MATLAB) ou np.dot(Q.T, A) (NumPy).",
                                    "Para mão: compute linha por linha de Q^T vezes colunas de A.",
                                    "Arredonde resultados considerando precisão flutuante."
                                  ],
                                  "verification": "R deve ser aproximadamente upper triangular (elementos abaixo diagonal ~0).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software numérico ou planilha para multiplicação manual.",
                                  "tips": "Use tolerância 10^-12 para zeros numéricos em verificações.",
                                  "learningObjective": "Executar multiplicação matricial eficiente e entender R como resíduo triangular.",
                                  "commonMistakes": "Erro de índice em loops manuais; esquecer ordem (Q^T A, não A Q^T)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar propriedades de R para matrizes SPD",
                                  "subSteps": [
                                    "Confirme upper triangular: R_ij = 0 para i > j (dentro de tolerância).",
                                    "Verifique diagonal positiva: todos R_ii > 0.",
                                    "Calcule normas off-diagonal abaixo da diagonal (< 10^-10).",
                                    "Para SPD, confirme que autovalores de R são positivos (opcional via eig).",
                                    "Registre discrepâncias e itere se necessário."
                                  ],
                                  "verification": "Diagonal de R positiva e estrutura triangular confirmada numericamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Funções eig() ou trace() em software.",
                                  "tips": "Plote heatmaps de R para visualização intuitiva de triangularidade.",
                                  "learningObjective": "Validar saída do algoritmo QR e convergência para autovalores.",
                                  "commonMistakes": "Aceitar diagonal não positiva como válida; ignorar acumulação de erros numéricos."
                                }
                              ],
                              "practicalExample": "Dada A = [[4, 1], [1, 3]] (SPD) e Q = [[0.8, 0.6], [-0.6, 0.8]] (ortogonal), compute Q^T = [[0.8, -0.6], [0.6, 0.8]]. Então R = Q^T * A = [[3.8, 2.8], [0, 2.2]] (aprox. upper triangular, diag positiva: 3.8>0, 2.2>0).",
                              "finalVerifications": [
                                "R é upper triangular (subdiagonal zero dentro de 10^-10).",
                                "Elementos da diagonal de R são todos positivos.",
                                "Q^T * Q = I (ortogonalidade preservada).",
                                "A = Q * R (reconstrução exata dentro de tolerância).",
                                "Norma de Frobenius de subdiagonal de R é mínima.",
                                "Autovalores de R positivos para A SPD."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica na multiplicação (erro < 10^-8).",
                                "Correta identificação de Q^T.",
                                "Validação completa de propriedades triangulares e positivas.",
                                "Eficiência computacional (uso de funções vetoriais).",
                                "Interpretação correta de resultados no contexto QR.",
                                "Documentação clara de passos e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/MATLAB para autovalores.",
                                "Análise Numérica: Estabilidade do algoritmo QR iterativo.",
                                "Física/Engenharia: Modos de vibração em estruturas civis.",
                                "Álgebra Linear: Propriedades de matrizes ortogonais e triangulares."
                              ],
                              "realWorldApplication": "Em engenharia civil, calcular autovalores via iterações QR para determinar frequências naturais e modos de vibração de edifícios e pontes, essencial para análise sísmica e design estrutural seguro."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Algoritmo QR Iterativo",
                        "description": "Aplicação iterativa da decomposição QR para convergir a uma forma diagonal ou quase-diagonal, aproximando os autovalores na diagonal.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Descrever os passos do algoritmo QR básico",
                            "description": "Executar A_{k+1} = R_k Q_k a partir de A_k = Q_k R_k, repetindo até convergência, onde os autovalores reais e positivos aparecem na diagonal de forma crescente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos da Decomposição QR",
                                  "subSteps": [
                                    "Revise a decomposição QR: Toda matriz A_k invertível pode ser fatorada como A_k = Q_k R_k, onde Q_k é ortogonal (Q_k^T Q_k = I) e R_k é triangular superior.",
                                    "Estude propriedades: Q_k preserva normas, R_k captura a estrutura triangular.",
                                    "Identifique o contexto do algoritmo QR iterativo para autovalores de matrizes simétricas com autovalores reais positivos.",
                                    "Pratique decomposição QR manual para matriz 2x2 simples.",
                                    "Confirme que a iteração preserva autovalores: det(A_{k+1}) = det(A_k)."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito as propriedades de Q e R, e demonstre com uma matriz 2x2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, calculadora científica ou software como MATLAB/Octave.",
                                  "tips": "Comece com matrizes pequenas para visualizar a ortogonalidade multiplicando Q^T Q.",
                                  "learningObjective": "Compreender a base matemática da decomposição QR e sua relevância para iterações em autovalores.",
                                  "commonMistakes": "Confundir QR com decomposição LU; esquecer que Q é ortogonal, não unitária."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a Matriz e Configurar Parâmetros",
                                  "subSteps": [
                                    "Escolha A_0 como matriz simétrica positiva definida (ex: matriz de rigidez em estruturas).",
                                    "Defina tolerância de convergência (ex: 10^{-6}) e número máximo de iterações (ex: 100).",
                                    "Inicialize contadores: k = 0.",
                                    "Verifique se A_0 tem autovalores reais positivos (opcional via traço e determinante).",
                                    "Prepare estrutura para armazenar iterações (vetor de resíduos ou matrizes históricas)."
                                  ],
                                  "verification": "Mostre A_0 inicial e parâmetros configurados em um documento ou código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software numérico (Python com NumPy, MATLAB) ou planilha para matrizes pequenas.",
                                  "tips": "Use matrizes simétricas para garantir convergência; normalize se necessário.",
                                  "learningObjective": "Configurar corretamente o problema inicial para iteração estável.",
                                  "commonMistakes": "Escolher matriz não simétrica ou com autovalores negativos, causando não-convergência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Decomposição QR e Atualizar Matriz",
                                  "subSteps": [
                                    "Compute Q_k e R_k tal que A_k = Q_k R_k usando Gram-Schmidt ou Householder.",
                                    "Calcule A_{k+1} = R_k Q_k.",
                                    "Incrementar k = k + 1.",
                                    "Armazene A_{k+1} para próxima iteração.",
                                    "Monitore off-diagonal elements para sinal de convergência."
                                  ],
                                  "verification": "Execute uma iteração manual ou computacional e confirme A_{k+1} ≈ A_k Q_k R_k^{-1}, mas use a fórmula direta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Biblioteca QR (scipy.linalg.qr em Python, qr() em MATLAB), papel para 2x2.",
                                  "tips": "Implemente em loop para automação; verifique ortogonalidade com norm(Q^T Q - I) < epsilon.",
                                  "learningObjective": "Dominar o núcleo iterativo: QR → RQ, preservando espectro.",
                                  "commonMistakes": "Inverter a ordem (QR em vez de RQ); acumular erros numéricos sem reortogonalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Convergência e Extrair Autovalores",
                                  "subSteps": [
                                    "Calcule norma dos subdiagonais: ||A_k - diag(A_k)|| < tolerância.",
                                    "Ou verifique ||A_{k+1} - A_k|| < epsilon.",
                                    "Se não convergiu e k < max_iter, volte ao passo 3.",
                                    "Ao convergir, extraia diagonal de A_final como autovalores ordenados crescentemente.",
                                    "Opcional: Compute autovetores das colunas de Q acumulado."
                                  ],
                                  "verification": "Apresente A_final diagonal e compare com autovalores exatos (via charpoly).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código iterativo completo, ferramenta para autovalores exatos (eig()).",
                                  "tips": "Ajuste tolerância para precisão; plote resíduos vs. iterações para visualização.",
                                  "learningObjective": "Implementar critério de parada e interpretar resultados como autovalores.",
                                  "commonMistakes": "Parar cedo (subdiagonais não zero); ignorar ordenação crescente na diagonal."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Descrever os Passos Completos",
                                  "subSteps": [
                                    "Escreva pseudocódigo ou fluxograma do algoritmo inteiro.",
                                    "Descreva sequência: Inicializar → Enquanto não convergir: QR → RQ → k++ → Fim.",
                                    "Explique convergência teórica para matrizes simétricas.",
                                    "Teste com exemplo e discuta limitações (ex: autovalores próximos).",
                                    "Registre tempo de convergência e precisão alcançada."
                                  ],
                                  "verification": "Produza relatório descrevendo todos os passos com exemplo numérico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto, LaTeX ou Markdown para fluxograma.",
                                  "tips": "Use setas em fluxograma para loop while; inclua condições de saída.",
                                  "learningObjective": "Sintetizar o algoritmo em descrição clara e acionável.",
                                  "commonMistakes": "Omitir critério de convergência; descrever sem menção à ordenação diagonal."
                                }
                              ],
                              "practicalExample": "Para A_0 = [[4, 1], [1, 2]] (matriz de rigidez simples), itere QR: Primeira iteração dá A1 ≈ [[4.3, 0.7], [0.7, 1.7]]; após 5 iterações, converge para diag([4.372, 1.628]), autovalores exatos.",
                              "finalVerifications": [
                                "Descreva corretamente os 4 passos principais: inicializar, QR, RQ, convergência.",
                                "Implemente e execute em software para matriz 3x3, mostrando convergência em <20 iterações.",
                                "Explique por que autovalores aparecem ordenados na diagonal.",
                                "Compare diagonal final com eig() exato, erro <10^{-5}.",
                                "Crie fluxograma preciso do loop iterativo.",
                                "Identifique limitação: má convergência para autovalores múltiplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da iteração A_{k+1} = R_k Q_k (100% correto).",
                                "Número e detalhe de substeps em cada passo (mínimo 4 por step).",
                                "Correta implementação de critério de convergência com tolerância.",
                                "Exemplo prático executado com resultados numéricos validados.",
                                "Explicação teórica de preservação de autovalores e ordenação.",
                                "Ausência de erros comuns como inversão QR/RQ."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Decomposição QR via Gram-Schmidt/Householder.",
                                "Programação Numérica: Implementação em Python/MATLAB para métodos iterativos.",
                                "Física/Engenharia: Análise modal de vibrações em estruturas civis.",
                                "Otimização: Similar a métodos de deflação para autovalores múltiplos."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, o algoritmo QR resolve problemas de análise modal em edifícios, computando frequências naturais (autovalores) de matrizes de massa/rigidez para prever modos de vibração e evitar ressonância em terremotos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Implementar critério de parada por convergência",
                            "description": "Definir tolerâncias para norm da diferença entre iterações sucessivas ou subdiagonal pequena, monitorando a convergência para todos os autovalores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir critérios de convergência para o algoritmo QR iterativo",
                                  "subSteps": [
                                    "Estude a definição de convergência no algoritmo QR: a matriz converge para triangular superior quando autovalores estão na diagonal.",
                                    "Identifique dois critérios principais: (1) norma da diferença entre matrizes de iterações sucessivas ||A_{k+1} - A_k|| < ε, (2) elementos da subdiagonal |A_{k+1}[i+1,i]| < δ para todos i.",
                                    "Escolha normas apropriadas (ex: norma 2 ou infinito) e defina tolerâncias iniciais (ε = 1e-10, δ = 1e-12).",
                                    "Documente os critérios em pseudocódigo, incluindo condições para todos os autovalores.",
                                    "Valide conceitualmente com uma matriz de exemplo 2x2."
                                  ],
                                  "verification": "Pseudocódigo escrito e validado manualmente com matriz de teste converge em poucas iterações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação do algoritmo QR, papel e caneta ou editor de texto, matrizes de teste em NumPy.",
                                  "tips": "Comece com matrizes simétricas para simplificar, pois autovalores reais são esperados em engenharia civil.",
                                  "learningObjective": "Compreender e formalizar condições matemáticas de convergência para monitoramento numérico.",
                                  "commonMistakes": "Confundir norma da diferença de matrizes com diferença de autovalores; ignorar verificação para todos os elementos da subdiagonal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar cálculo da norma da diferença entre iterações sucessivas",
                                  "subSteps": [
                                    "No código do QR iterativo, armazene a matriz A_k da iteração anterior.",
                                    "Após cada iteração QR (A_{k+1} = R_k Q_k), compute diff = np.linalg.norm(A_new - A_old).",
                                    "Use np.linalg.norm com ord=2 para norma euclidiana ou ord=np.inf para norma máxima.",
                                    "Atualize A_old = A_new.copy() para próxima iteração.",
                                    "Adicione logging ou print para monitorar a norma em cada passo."
                                  ],
                                  "verification": "Execute 5 iterações manuais e confirme que a norma diminui progressivamente via logs.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy, código base do algoritmo QR iterativo.",
                                  "tips": "Use cópias profundas (copy()) para evitar aliasing de arrays NumPy.",
                                  "learningObjective": "Implementar eficientemente métricas de erro numérico em loops iterativos.",
                                  "commonMistakes": "Não usar cópia de array, levando a diff=0 sempre; escolher norma inadequada que não captura convergência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar verificação da subdiagonal e integração do critério de parada",
                                  "subSteps": [
                                    "Defina tolerância δ e extraia subdiagonal: subdiag = np.abs(np.diag(A_new, -1)) < δ.",
                                    "Crie condição composta: converged = (norm_diff < ε) and np.all(subdiag).",
                                    "Integre no loop while: while not converged and k < max_iter: ...",
                                    "Adicione contador de iterações e mensagem de saída (convergido ou max_iter atingido).",
                                    "Teste com matriz que converge rapidamente e uma que requer mais iterações."
                                  ],
                                  "verification": "O loop para corretamente quando critérios são satisfeitos, sem exceder max_iter desnecessariamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python/NumPy do passo anterior, matrizes de teste variadas (2x2 e 3x3).",
                                  "tips": "Use np.all() para verificar todos elementos da subdiagonal de uma vez; defina max_iter=1000 para segurança.",
                                  "learningObjective": "Combinar múltiplos critérios em uma condição de parada robusta para algoritmos numéricos.",
                                  "commonMistakes": "Verificar apenas norma sem subdiagonal, parando prematuramente; esquecer np.all() e checar apenas primeiro elemento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e ajustar tolerâncias para convergência em autovalores",
                                  "subSteps": [
                                    "Compare autovalores extraídos da diagonal com np.linalg.eigvals(A_original) para precisão.",
                                    "Varie ε e δ (1e-8 a 1e-12) e meça iterações necessárias e erro relativo.",
                                    "Implemente função de teste automatizada com assert para |λ_computado - λ_exato| < 1e-8.",
                                    "Analise logs para identificar iterações onde convergência estabiliza.",
                                    "Otimize tolerâncias para equilíbrio entre precisão e eficiência computacional."
                                  ],
                                  "verification": "Testes passam com erro < 1e-8 e número de iterações razoável (<200 para matriz 10x10).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código completo, NumPy/SciPy para eigvals de referência, Jupyter Notebook para visualização.",
                                  "tips": "Plote norma vs iteração com matplotlib para insight visual na convergência.",
                                  "learningObjective": "Avaliar e refinar critérios de parada empiricamente para aplicações reais.",
                                  "commonMistakes": "Tolerâncias muito frouxas levando a autovalores imprecisos; rigidez excessiva causando loops infinitos."
                                }
                              ],
                              "practicalExample": "Para matriz A = [[4, 1], [1, 3]], itere QR: iteração 1: norma_diff=0.5; it2: 0.1; it3: 1e-5 < 1e-6 → para. Autovalores diagonal [4.3, 2.7] aproximam exatos [4.618, 2.382]. Em engenharia civil, use para matriz de rigidez 3x3 de viga.",
                              "finalVerifications": [
                                "Norma da diferença entre iterações sucessivas < ε (ex: 1e-10).",
                                "Todos elementos da subdiagonal < δ (ex: 1e-12).",
                                "Autovalores da diagonal coincidem com np.linalg.eigvals dentro de 1e-8 relativo.",
                                "Número de iterações < max_iter (ex: 1000).",
                                "Sem warnings de overflow/underflow em logs.",
                                "Código executa em <5s para matriz 10x10."
                              ],
                              "assessmentCriteria": [
                                "Critérios de convergência corretamente implementados e documentados (20%).",
                                "Cálculo preciso de norma e subdiagonal sem erros numéricos (25%).",
                                "Integração robusta no loop com handling de max_iter (20%).",
                                "Testes automatizados com matrizes variadas e análise de precisão (20%).",
                                "Eficiência: convergência em <200 iterações para n=10 (10%).",
                                "Código limpo, comentado e com visualizações de convergência (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estabilidade e condicionamento de algoritmos iterativos.",
                                "Otimização: Critérios de parada em gradiente descendente ou métodos de Newton.",
                                "Engenharia Estrutural: Cálculo de modos de vibração via autovalores de rigidez/massa.",
                                "Programação Científica: Boas práticas em NumPy para computação de alta precisão.",
                                "Estatística: Monitoramento de convergência em MCMC ou EM algorithms."
                              ],
                              "realWorldApplication": "Em engenharia civil, implemente em análise modal de estruturas (pontes, edifícios) para determinar frequências naturais de vibração, prevendo ressonâncias sísmicas; tolerâncias ajustadas garantem precisão em simulações FEM sem desperdício computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Analisar a convergência do algoritmo QR",
                            "description": "Explicar que para matrizes simétricas, o algoritmo converge quadraticamente aos autovalores, com os maiores em magnitude convergindo primeiro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar propriedades de matrizes simétricas e algoritmo QR básico",
                                  "subSteps": [
                                    "Defina matriz simétrica e liste suas propriedades chave (autovalores reais, autovetores ortogonais).",
                                    "Recapitule o algoritmo QR: decomposição QR e multiplicação A_{k+1} = R_k Q_k.",
                                    "Explique o conceito de deflação para autovalores convergidos.",
                                    "Discuta por que matrizes simétricas são ideais para QR iterativo.",
                                    "Identifique pré-condições para convergência (sem autovalores múltiplos)."
                                  ],
                                  "verification": "Resuma em um parágrafo as propriedades e o fluxo do QR para simétricas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas de aula sobre autovalores, software Python/MATLAB para QR.",
                                  "tips": "Use diagramas para visualizar iterações QR.",
                                  "learningObjective": "Compreender base teórica para convergência em simétricas.",
                                  "commonMistakes": "Confundir simétricas com hermitianas; ignorar ortogonalidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar taxa de convergência quadrática",
                                  "subSteps": [
                                    "Estude o teorema de convergência QR para simétricas: ||sin θ_{k+1}|| ≤ C ||sin θ_k||².",
                                    "Derive qualitativamente por que a convergência é quadrática usando ângulos entre subespaços.",
                                    "Compare com métodos lineares (ex: power iteration).",
                                    "Calcule numericamente o erro em iterações sucessivas para observar quadraticidade.",
                                    "Explique papel da ortogonalidade das Q_k na aceleração."
                                  ],
                                  "verification": "Plote log-log de erro vs iteração mostrando slope 2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigo sobre QR convergence, Jupyter notebook com NumPy/SciPy.",
                                  "tips": "Monitore resíduos ||A_k v_k - λ_k v_k||.",
                                  "learningObjective": "Explicar e demonstrar convergência quadrática.",
                                  "commonMistakes": "Confundir quadrática com cúbica; não normalizar resíduos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar ordem de convergência dos autovalores",
                                  "subSteps": [
                                    "Analise que autovalores extremos (maiores/menores em magnitude) convergem primeiro.",
                                    "Explique mecanismo: subdiagonal tende a zero começando pelos extremos.",
                                    "Use exemplo 3x3 para rastrear elementos subdiagonais ao longo das iterações.",
                                    "Discuta shifts (Wilkinson) para acelerar convergência interna.",
                                    "Verifique deflação sequencial dos autovalores maiores."
                                  ],
                                  "verification": "Mostre trace de matriz convergindo para soma de autovalores conhecidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matriz de exemplo simétrica, calculadora simbólica como SymPy.",
                                  "tips": "Comece com matriz diagonal dominante para intuição.",
                                  "learningObjective": "Identificar sequência de convergência por magnitude.",
                                  "commonMistakes": "Assumir convergência simultânea; ignorar autovalores próximos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e validar convergência numericamente",
                                  "subSteps": [
                                    "Implemente QR iterativo em código para matriz simétrica 4x4.",
                                    "Execute 20 iterações e monitore autovalores aproximados vs exatos.",
                                    "Meça tempo de convergência e compare quadraticidade.",
                                    "Teste sensibilidade a perturbações numéricas.",
                                    "Conclua relatório com gráficos de convergência."
                                  ],
                                  "verification": "Código roda com erro < 1e-10 em <15 iterações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com NumPy/LAPACK, MATLAB.",
                                  "tips": "Use qr() built-in e loop até tolerância.",
                                  "learningObjective": "Aplicar análise em simulação prática.",
                                  "commonMistakes": "Não re-ortogonalizar Q; overflow numérico."
                                }
                              ],
                              "practicalExample": "Considere A = [[4, 1, 0], [1, 3, 1], [0, 1, 2]] (simétrica). Autovalores exatos: ~5.36, 2, 0.64. Após 5 iterações QR: diagonal ~[5.3, 2.1, 0.7], subdiagonais <1e-3, convergindo quadraticamente do maior primeiro.",
                              "finalVerifications": [
                                "Explique quadraticidade com fórmula de erro.",
                                "Identifique ordem: maiores magnitude primeiro.",
                                "Simule exemplo 3x3 com código e gráficos.",
                                "Discuta limitações (autovalores múltiplos).",
                                "Compare tempo com power method.",
                                "Defina deflação corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de convergência quadrática (80%).",
                                "Correta identificação de ordem por magnitude (90%).",
                                "Qualidade da simulação numérica e gráficos (85%).",
                                "Análise de erros comuns e limitações (75%).",
                                "Clareza na derivação qualitativa (80%).",
                                "Aplicação de conceitos em exemplo prático (90%)."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia Civil: Análise modal de estruturas (vibrações).",
                                "Física: Modos normais em sistemas mecânicos.",
                                "Computação: Otimização numérica e estabilidade.",
                                "Matemática: Teoria espectral e álgebra linear avançada."
                              ],
                              "realWorldApplication": "Em engenharia civil, analisa frequências de vibração de pontes/ edifícios via autovalores de matrizes de rigidez/massa simétricas; QR garante convergência rápida para design sísmico seguro."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Cálculo de Autovalores e Autofunções",
                        "description": "Extração final dos autovalores da diagonal da matriz convergida e recuperação das autofunções via produto de Q's.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Extrair autovalores da matriz final",
                            "description": "Identificar os autovalores como os elementos da diagonal principal da matriz A final após convergência do algoritmo QR.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a convergência do algoritmo QR para autovalores",
                                  "subSteps": [
                                    "Revise o processo iterativo do QR: decomposição QR e multiplicação Rk * Qk",
                                    "Identifique o critério de convergência: quando elementos subdiagonais são próximos de zero",
                                    "Explique por que a matriz final Ak converge para uma forma triangular superior com autovalores na diagonal",
                                    "Discuta a preservação espectral: autovalores de A são os mesmos de Ak",
                                    "Pratique com uma matriz 2x2 para observar iterações manuais"
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o motivo pelo qual a diagonal de Ak contém os autovalores",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre algoritmo QR",
                                    "Exemplo de matriz 2x2 ou 3x3",
                                    "Calculadora ou papel para iterações manuais"
                                  ],
                                  "tips": "Monitore o off-diagonal elements; convergência é rápida para matrizes simétricas",
                                  "learningObjective": "Entender o mecanismo teórico que posiciona autovalores na diagonal principal após convergência",
                                  "commonMistakes": "Confundir convergência com diagonalização completa; ignorar que QR produz triangular superior, não necessariamente diagonal"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter e confirmar a matriz final Ak após convergência",
                                  "subSteps": [
                                    "Execute as iterações QR até o critério de parada (ex: |A(k+1)_{i+1,i}| < 10^-6)",
                                    "Registre a última iteração como Ak final",
                                    "Verifique se Ak é aproximadamente triangular superior (elementos abaixo da diagonal ~0)",
                                    "Confirme simetria se A original era simétrica (Ak deve ser diagonal)",
                                    "Salve Ak em formato matricial claro"
                                  ],
                                  "verification": "Apresente Ak e mostre que subdiagonais são menores que tolerância epsilon",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software como MATLAB/Python (numpy/scipy)",
                                    "Matriz de teste inicial",
                                    "Tolerância numérica definida (ex: 1e-10)"
                                  ],
                                  "tips": "Use laços em Python para automatizar iterações e plotar convergência",
                                  "learningObjective": "Selecionar corretamente a matriz convergida como base para extração de autovalores",
                                  "commonMistakes": "Parar iterações prematuramente, resultando em Ak imprecisa; não verificar triangularidade"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair elementos da diagonal principal de Ak",
                                  "subSteps": [
                                    "Identifique a diagonal principal: elementos A_{ii} para i=1 a n",
                                    "Liste os valores: λ1 = A_{11}, λ2 = A_{22}, ..., λn = A_{nn}",
                                    "Ordene os autovalores em ordem decrescente ou crescente se necessário",
                                    "Registre com precisão numérica adequada (ex: 4 casas decimais)",
                                    "Compare com autovalores conhecidos para matrizes teste"
                                  ],
                                  "verification": "Extraia e liste os n autovalores da diagonal, confirmando contagem e valores",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz Ak final",
                                    "Planilha ou código para extração (ex: np.diag(Ak))"
                                  ],
                                  "tips": "Em código, use funções prontas como np.diag para simplicidade, mas entenda o processo manual",
                                  "learningObjective": "Extrair precisamente os autovalores da diagonal principal de forma sistemática",
                                  "commonMistakes": "Incluir elementos off-diagonal por engano; esquecer de ordenar ou arredondar adequadamente"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar os autovalores extraídos",
                                  "subSteps": [
                                    "Verifique se produto dos autovalores equals det(A) e traço equals soma",
                                    "Teste com autovetores aproximados: Ak * v ≈ λ v para cada λ",
                                    "Discuta precisão numérica e sensibilidade a erros de arredondamento",
                                    "Documente os autovalores em relatório com contexto do problema",
                                    "Compare com métodos alternativos como potenciação para validação"
                                  ],
                                  "verification": "Demonstre que os autovalores satisfazem propriedades espectrais de A original",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código para verificação espectral",
                                    "Matriz A original",
                                    "Biblioteca eig para comparação"
                                  ],
                                  "tips": "Sempre valide com propriedades conhecidas como traço e determinante",
                                  "learningObjective": "Confirmar validade dos autovalores extraídos e interpretá-los no contexto",
                                  "commonMistakes": "Ignorar validação, aceitando valores sem checagem; confundir autovalores com autofunções"
                                }
                              ],
                              "practicalExample": "Para A = [[4, 1], [1, 3]], após 5 iterações QR: Ak ≈ [[5.000, 0.447], [0.000, 2.000]]. Autovalores: λ1=5.000 (A11), λ2=2.000 (A22). Verificação: traço(A)=7=5+2, det(A)=11=5*2.",
                              "finalVerifications": [
                                "Diagonal principal de Ak contém exatamente n autovalores",
                                "Subdiagonais de Ak são numericamente zero (<1e-10)",
                                "Autovalores preservam traço e determinante de A original",
                                "Valores extraídos coincidem com output de np.linalg.eigvals(A)",
                                "Autovalores ordenados corretamente (decrescente)",
                                "Nenhuma perda de precisão por iterações insuficientes"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da matriz final convergida (90%+ convergência)",
                                "Extração correta e completa da diagonal principal",
                                "Validação espectral com traço/determinante (erro <1%)",
                                "Interpretação clara do processo QR e extração",
                                "Uso adequado de ferramentas numéricas sem erros de implementação",
                                "Documentação de passos e resultados"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Definição e propriedades de autovalores",
                                "Programação Numérica: Implementação de algoritmos iterativos em Python/MATLAB",
                                "Análise Numérica: Erros de arredondamento e convergência",
                                "Engenharia de Estruturas: Modos de vibração e estabilidade"
                              ],
                              "realWorldApplication": "Em engenharia civil, extrair autovalores via QR determina frequências naturais de vibração em edifícios ou pontes, essencial para análise modal e design sísmico resistente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Recuperar autofunções via produto acumulado de Q",
                            "description": "Calcular as autofunções como as colunas da matriz Z = Q_1 Q_2 ... Q_n, normalizando-as adequadamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar e calcular o produto acumulado Z = Q₁ Q₂ ... Qₙ",
                                  "subSteps": [
                                    "Inicialize a matriz Z como a matriz identidade I do mesmo tamanho da matriz original A (ex: Z = eye(n) no MATLAB ou np.eye(n) no Python).",
                                    "Obtenha a sequência de matrizes ortogonais Q₁, Q₂, ..., Qₙ geradas nas iterações do algoritmo QR.",
                                    "Iterativamente multiplique Z ← Z × Qᵢ para i = 1 até n, preservando a ordem das multiplicações à direita.",
                                    "Verifique dimensionalmente que Z mantém o tamanho n×n após cada multiplicação.",
                                    "Confirme numericamente que Z permanece aproximadamente ortogonal (Zᵀ Z ≈ I)."
                                  ],
                                  "verification": "Execute Z.T @ Z e verifique se todos os elementos off-diagonal são próximos de 0 e diagonal próxima de 1 (tolerância 1e-10).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Sequência de matrizes Qᵢ das iterações QR",
                                    "Software de álgebra linear (NumPy/Python, MATLAB ou Octave)",
                                    "Matriz A original para referência"
                                  ],
                                  "tips": [
                                    "Use funções otimizadas de multiplicação matricial (np.dot ou @ em Python) para eficiência numérica.",
                                    "Monitore condicionamento numérico em iterações longas para evitar acúmulo de erros de arredondamento."
                                  ],
                                  "learningObjective": "Compreender como o produto acumulado dos rotacionadores QR converge para as autofunções normalizadas da matriz A.",
                                  "commonMistakes": [
                                    "Inicializar Z incorretamente (ex: zeros em vez de identidade)",
                                    "Inverter a ordem de multiplicação (Qᵢ × Z em vez de Z × Qᵢ)",
                                    "Ignorar perda de ortogonalidade devido a erros numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair as autofunções candidatas das colunas de Z",
                                  "subSteps": [
                                    "Identifique a j-ésima coluna de Z, denotada zⱼ, como a autofunção aproximada correspondente ao autovalor λⱼ (ordenados pela convergência QR).",
                                    "Extraia todas as colunas z₁, z₂, ..., zₙ em vetores coluna separados.",
                                    "Armazene as autofunções em uma matriz V cujas colunas são as zⱼ.",
                                    "Verifique preliminarmente a linear independência das colunas (rank(Z) = n).",
                                    "Compute resíduos iniciais rⱼ = A zⱼ - λⱼ zⱼ para inspeção qualitativa."
                                  ],
                                  "verification": "Confirme que as colunas de Z satisfazem aproximadamente A Z ≈ Z Λ, onde Λ é a diagonal dos autovalores (erro norma < 1e-8).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz Z computada",
                                    "Autovalores λⱼ convergidos",
                                    "Matriz A original",
                                    "Software para extração de colunas (Z[:, j])"
                                  ],
                                  "tips": [
                                    "Ordene colunas de Z conforme a ordem de convergência dos autovalores para correspondência correta.",
                                    "Use slicing eficiente em arrays (ex: V = Z em Python, já que colunas são diretas)."
                                  ],
                                  "learningObjective": "Reconhecer que as colunas do produto acumulado Q convergem para a base de autofunções da matriz.",
                                  "commonMistakes": [
                                    "Extrair linhas em vez de colunas",
                                    "Desordenar colunas sem alinhar com autovalores",
                                    "Não verificar resíduos antes da normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Normalizar as autofunções extraídas",
                                  "subSteps": [
                                    "Para cada autofunção zⱼ, calcule a norma euclidiana ||zⱼ||₂ = √(zⱼᵀ zⱼ).",
                                    "Normalize dividindo: vⱼ = zⱼ / ||zⱼ||₂.",
                                    "Atualize a matriz V com colunas vⱼ normalizadas.",
                                    "Reverifique resíduos normalizados: rⱼ = A vⱼ - λⱼ vⱼ.",
                                    "Confirme que todas as normas ||vⱼ||₂ = 1."
                                  ],
                                  "verification": "Para cada vⱼ, compute np.linalg.norm(v_j) e verifique igualdade a 1 (tolerância 1e-12).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz V com colunas zⱼ",
                                    "Funções de norma (np.linalg.norm)",
                                    "Autovalores λⱼ"
                                  ],
                                  "tips": [
                                    "Escolha norma L2 (euclidiana) padrão para autofunções em aplicações de engenharia.",
                                    "Normalização em fase final minimiza erros propagados das iterações QR."
                                  ],
                                  "learningObjective": "Aplicar normalização para obter autofunções unitárias, essenciais para ortonormalidade.",
                                  "commonMistakes": [
                                    "Usar norma L1 ou L∞ incorretamente",
                                    "Normalizar antes da extração, perdendo precisão",
                                    "Esquecer sinal da normalização (escolha consistente, ex: primeiro elemento positivo)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar propriedades finais das autofunções normalizadas",
                                  "subSteps": [
                                    "Teste ortogonalidade: vᵢᵀ vⱼ ≈ 0 para i ≠ j e vᵢᵀ vᵢ = 1.",
                                    "Valide equação espectral: ||A vⱼ - λⱼ vⱼ||₂ < ε (ex: ε=1e-10).",
                                    "Confirme decomposição espectral: A ≈ V Λ Vᵀ.",
                                    "Analise sensibilidade numérica dos autovalores próximos.",
                                    "Documente métricas de erro para relatório."
                                  ],
                                  "verification": "Compute matriz de Gram Vᵀ V e verifique identidade; resíduos médios < 1e-9.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz V normalizada",
                                    "Autovalores Λ",
                                    "Matriz A",
                                    "Ferramentas de diagnóstico numérico"
                                  ],
                                  "tips": [
                                    "Use tolerâncias adaptativas baseadas em máquina epsilon para robustez.",
                                    "Para matrizes reais simétricas, espere ortonormalidade exata (dentro de precisão)."
                                  ],
                                  "learningObjective": "Validar que as autofunções recuperadas são precisas e utilizáveis em simulações.",
                                  "commonMistakes": [
                                    "Ignorar autovalores múltiplos (requer deflactionamento)",
                                    "Não testar ortogonalidade pós-normalização",
                                    "Aceitar resíduos altos sem investigação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[4, 1], [1, 3]] (simétrica). Após 10 iterações QR, suponha Q1 Q2 ... Q10 = Z ≈ [[0.851, -0.526], [0.526, 0.851]] (autovalores ≈4.618, 2.382). Colunas z1=[0.851,0.526], z2=[-0.526,0.851]. Normalize: v1=[0.901,0.434], v2=[-0.623,0.782]. Verifique A v1 ≈ 4.618 v1.",
                              "finalVerifications": [
                                "Todas as autofunções vⱼ têm norma euclidiana exatamente 1.",
                                "As autofunções são mutuamente ortogonais: vᵢᵀ vⱼ = 0 para i ≠ j.",
                                "Resíduos da equação espectral ||A vⱼ - λⱼ vⱼ||₂ < 1e-10.",
                                "Decomposição A ≈ V Λ Vᵀ reconstrói A com erro norma < 1e-9.",
                                "Z permanece aproximadamente unitária: ||Zᵀ Z - I||₂ < 1e-8.",
                                "Correspondência correta entre colunas de Z e autovalores ordenados."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: resíduos < 1e-10 e normas =1.",
                                "Correção conceitual: justificativa da ordem Z × Qᵢ e normalização.",
                                "Eficiência computacional: código vetorizado sem loops desnecessários.",
                                "Validação completa: testes de ortogonalidade e decomposição espectral.",
                                "Documentação: explicação clara de passos e métricas de erro.",
                                "Robustez: tratamento de casos com autovalores próximos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica: Implementação em Python (NumPy/SciPy) ou MATLAB para automação QR.",
                                "Análise Estrutural (Engenharia Civil): Modos de vibração em vigas/pontes via autovalores de rigidez-massa.",
                                "Física Computacional: Simulação de osciladores acoplados em dinâmica estrutural.",
                                "Processamento de Sinais: Análise de componentes principais (PCA) para dados de sensores em estruturas.",
                                "Otimização Numérica: Condicionamento e estabilidade em métodos iterativos."
                              ],
                              "realWorldApplication": "Em engenharia civil, recupera autofunções para análise modal de edifícios e pontes, identificando modos de vibração dominantes para design resistente a terremotos, otimização de amortecedores e previsão de colapso dinâmico em simulações FEM."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Aplicar deflação para eficiência computacional",
                            "description": "Implementar deflação shift para acelerar convergência em matrizes não simétricas ou para isolar autovalores específicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Deflação e Deflação Shift no Algoritmo QR",
                                  "subSteps": [
                                    "Revise o algoritmo QR básico para cálculo de autovalores em matrizes não simétricas.",
                                    "Estude deflação: remoção do autovetor dominante da matriz para reduzir dimensionalidade.",
                                    "Aprenda deflação shift: aplicar shift (deslocamento espectral) para isolar autovalores específicos antes da deflação.",
                                    "Analise como isso acelera convergência em problemas com autovalores bem separados.",
                                    "Compare com iterações sem deflação usando exemplos teóricos simples."
                                  ],
                                  "verification": "Explique em suas palavras como deflação shift melhora a convergência e esboce um fluxograma do processo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação NumPy ou MATLAB",
                                    "Artigo sobre Algoritmo QR",
                                    "Papel e lápis para diagramas"
                                  ],
                                  "tips": "Use visualizações de espectro de autovalores para intuitivamente entender shifts.",
                                  "learningObjective": "Dominar os princípios teóricos da deflação shift para justificar sua aplicação.",
                                  "commonMistakes": [
                                    "Confundir deflação com deflacionamento econômico; ignorar normalização de autovetores."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Deflação Simples em uma Matriz Não Simétrica",
                                  "subSteps": [
                                    "Gere uma matriz não simétrica de 4x4 representando um problema de engenharia civil (ex: rigidez com amortecimento).",
                                    "Execute iterações QR para encontrar o autovalor dominante e seu autovetor.",
                                    "Defla a matriz: substitua A por (I - u u^T) A, onde u é o autovetor normalizado.",
                                    "Repita QR na matriz deflada para o próximo autovalor.",
                                    "Meça o número de iterações com e sem deflação."
                                  ],
                                  "verification": "O código converge em menos iterações após deflação; compare logs de iterações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Jupyter Notebook",
                                    "Matriz de exemplo de análise estrutural"
                                  ],
                                  "tips": "Sempre normalize o autovetor para evitar instabilidade numérica.",
                                  "learningObjective": "Implementar deflação básica para reduzir o espaço de busca de autovalores.",
                                  "commonMistakes": [
                                    "Não normalizar autovetor levando a overflow; usar produto escalar incorreto."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Deflação Shift para Isolamento de Autovalores Específicos",
                                  "subSteps": [
                                    "Escolha um shift μ próximo ao autovalor alvo baseado em estimativas iniciais.",
                                    "Aplique QR no shift: resolva autovalores de (A - μ I).",
                                    "Defla após encontrar o autovalor shiftado: ajuste para o autovalor original λ = μ + 1/θ.",
                                    "Itere com shifts adaptativos para múltiplos autovalores.",
                                    "Valide ortogonalidade dos autovetores obtidos."
                                  ],
                                  "verification": "Autovalores isolados convergem rapidamente; residual ||A v - λ v|| < 1e-10.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código Python/MATLAB estendido",
                                    "Função de residual de autovalor",
                                    "Gráficos de convergência"
                                  ],
                                  "tips": "Use Rayleigh quotient para estimar shifts iniciais e acelere.",
                                  "learningObjective": "Aplicar shifts para targeting eficiente em matrizes não simétricas.",
                                  "commonMistakes": [
                                    "Shift muito distante causando divergência; esquecer de desfazer o shift nos autovalores."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Otimizar a Implementação Completa",
                                  "subSteps": [
                                    "Aplique o algoritmo completo a uma matriz real de engenharia civil (ex: vibrações de ponte).",
                                    "Compare tempo de CPU e precisão com bibliotecas como SciPy.eigs.",
                                    "Otimize: vetorize operações e use QR Householder para estabilidade.",
                                    "Analise sensibilidade a ruído numérico.",
                                    "Documente o código com comentários e gere relatório de performance."
                                  ],
                                  "verification": "Eficiência demonstrada: redução >30% em iterações; autovalores precisos validados.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Dados reais de estruturas civis",
                                    "Profiler de código (timeit)",
                                    "Biblioteca de referência SciPy"
                                  ],
                                  "tips": "Teste com matrizes tridiagonais Hessenberg para eficiência.",
                                  "learningObjective": "Avaliar e refinar a implementação para aplicações práticas.",
                                  "commonMistakes": [
                                    "Ignorar acumulação de erros de arredondamento; não validar contra autovalores conhecidos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de vibrações de uma ponte suspensa, use deflação shift no algoritmo QR para isolar as frequências modais mais baixas (críticas para ressonância) de uma matriz de massa-amortecimento não simétrica 50x50, reduzindo iterações de 500 para 120.",
                              "finalVerifications": [
                                "Convergência acelerada confirmada por logs de iterações.",
                                "Autovetores ortogonais: V^T V ≈ I.",
                                "Residual de autovalores < 1e-12.",
                                "Eficiência computacional: tempo reduzido em pelo menos 25%.",
                                "Validação contra eigendecomposição exata para matrizes pequenas.",
                                "Aplicação bem-sucedida em matriz de engenharia real."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos autovalores e autovetores obtidos.",
                                "Redução mensurável no número de iterações QR.",
                                "Estabilidade numérica da implementação.",
                                "Correção na aplicação de shifts e deflação.",
                                "Eficiência computacional comparada a métodos padrão.",
                                "Clareza e modularidade do código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Álgebra linear avançada e estabilidade de algoritmos.",
                                "Programação Computacional: Otimização de código em Python/MATLAB.",
                                "Engenharia Estrutural: Análise modal de vibrações em civil.",
                                "Física: Dinâmica de sistemas com autovalores complexos."
                              ],
                              "realWorldApplication": "Na engenharia civil, otimiza simulações de estabilidade de edifícios altos ou pontes contra terremotos, isolando modos de falha críticos em matrizes grandes de elementos finitos, economizando horas de computação em análises de projetos reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Deflação e aceleração",
                    "description": "Técnicas para encontrar múltiplos autovalores, incluindo deflação e métodos de aceleração como shifts.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Deflação",
                        "description": "Técnica para eliminar o efeito de autovalores e autofunções já computados em métodos iterativos, permitindo a extração de múltiplos autovalores de uma matriz sem recalcular os anteriores.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Definir deflação e sua aplicação em métodos de autovalores",
                            "description": "Explicar o conceito de deflação, incluindo os tipos principais (deflação por subtração e por inversão), e sua importância na resolução de problemas de engenharia civil que envolvem análise modal de estruturas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Fundamental de Deflação em Autovalores",
                                  "subSteps": [
                                    "Revise a definição de autovalores e autofunções em problemas de valores próprios Ax = λx.",
                                    "Identifique a necessidade de deflação: após encontrar um autovalor λ1 e autofunção x1, remover sua influência para encontrar os subsequentes.",
                                    "Estude o princípio geral da deflação como técnica iterativa para isolar autovalores restantes.",
                                    "Compare deflação com métodos de aceleração como o de Wilkinson.",
                                    "Discuta limitações iniciais, como sensibilidade numérica."
                                  ],
                                  "verification": "Explique em suas palavras o propósito da deflação e dê um exemplo simples de matriz 2x2.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de álgebra linear (ex: Strang, Introduction to Linear Algebra)",
                                    "Notebook Jupyter com NumPy"
                                  ],
                                  "tips": "Comece com matrizes pequenas para visualizar o processo manualmente.",
                                  "learningObjective": "Definir deflação e justificar sua utilidade em computação de múltiplos autovalores.",
                                  "commonMistakes": [
                                    "Confundir deflação com deflacionamento econômico; ignorar normalização das autofunções."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Deflação por Subtração",
                                  "subSteps": [
                                    "Aprenda a fórmula: A' = A - λ1 (x1 x1^T) / (x1^T x1) para matrizes simétricas.",
                                    "Implemente o processo: encontre λ1 e x1, compute a projeção e subtraia.",
                                    "Teste com uma matriz diagonalizável simétrica 3x3.",
                                    "Analise estabilidade numérica e perda de precisão em iterações múltiplas.",
                                    "Compare resultados com eigenvalores completos via biblioteca."
                                  ],
                                  "verification": "Aplique deflação por subtração em uma matriz 3x3 e verifique se o autovalor restante é correto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy e SciPy",
                                    "Matriz de exemplo impressa ou em papel"
                                  ],
                                  "tips": "Sempre normalize x1 para evitar amplificação de erros.",
                                  "learningObjective": "Implementar e validar deflação por subtração em problemas lineares.",
                                  "commonMistakes": [
                                    "Não normalizar o vetor autofunção; usar produto escalar incorreto para não-simétricas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar Deflação por Inversão",
                                  "subSteps": [
                                    "Entenda o método: resolva (A - σI)u = x1 para shift σ próximo a λ1, depois deflate.",
                                    "Estude a fórmula iterativa: usar inversão para defletir shifts.",
                                    "Implemente em código: combine com método da potência deslocado.",
                                    "Teste em matriz não-simétrica e compare com subtração.",
                                    "Avalie convergência e casos onde inversão é superior."
                                  ],
                                  "verification": "Execute deflação por inversão em uma matriz e confirme recuperação de autovalores subsequentes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Python SciPy.linalg",
                                    "Documentação de solvers lineares"
                                  ],
                                  "tips": "Escolha σ próximo mas não igual a λ1 para estabilidade.",
                                  "learningObjective": "Aplicar deflação por inversão e diferenciar de subtração.",
                                  "commonMistakes": [
                                    "Escolha inadequada de shift σ levando a singularidade; ignorar multiplicidade de autovalores."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Deflação em Análise Modal de Estruturas",
                                  "subSteps": [
                                    "Conecte a problemas de engenharia civil: equação [K - ω²M]φ = 0 para modos de vibração.",
                                    "Modele uma estrutura simples (viga ou treliça) com matrizes de rigidez K e massa M.",
                                    "Use deflação para extrair modos dominantes sequencialmente.",
                                    "Simule em software: implemente ou use toolbox para análise modal.",
                                    "Interprete resultados: frequências e modos em contextos reais como terremotos."
                                  ],
                                  "verification": "Gere espectro modal de uma estrutura 3DOF usando deflação e valide com solver full.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software FEA como ANSYS Student ou Python FEniCS/NumPy",
                                    "Exemplo de matrizes K e M de viga"
                                  ],
                                  "tips": "Comece com estruturas pequenas (2-5 DOF) para depuração manual.",
                                  "learningObjective": "Integrar deflação em análise modal prática de engenharia civil.",
                                  "commonMistakes": [
                                    "Confundir autovalores de generalizado com padrão; não verificar ortogonalidade de modos."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e Otimizar Uso de Deflação",
                                  "subSteps": [
                                    "Compare deflação com métodos QR ou subspace iteration.",
                                    "Analise erros numéricos em grandes matrizes esparsas.",
                                    "Otimize código para eficiência em problemas estruturais.",
                                    "Discuta acelerações híbridas (deflação + shifts).",
                                    "Resolva um case study de ponte ou edifício."
                                  ],
                                  "verification": "Relatório comparativo de tempo/convergência entre deflação e método full para matriz 10x10.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Benchmark scripts em Python",
                                    "Artigos sobre análise modal (ex: Bathe)"
                                  ],
                                  "tips": "Use profiling para medir performance.",
                                  "learningObjective": "Criticar e otimizar deflação em contextos reais.",
                                  "commonMistakes": [
                                    "Sobreestimar precisão sem verificação; ignorar esparsidade em FEA."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a matriz de rigidez-massa generalizada de uma viga 2DOF: encontre o primeiro modo (ω1 ≈ 1.732 rad/s), aplique deflação por subtração para obter o segundo modo (ω2 ≈ 5.196 rad/s), validando com eig() no MATLAB/Python.",
                              "finalVerifications": [
                                "Defina deflação e seus dois tipos principais com fórmulas.",
                                "Implemente deflação por subtração em código para matriz 4x4.",
                                "Explique por que inversão é útil para autovalores extremos.",
                                "Aplique em análise modal de estrutura simples e interprete modos.",
                                "Compare precisão e tempo com métodos não-deflacionados.",
                                "Identifique cenários onde deflação falha (ex: autovalores próximos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e fórmulas (30%)",
                                "Correta implementação e código funcional (25%)",
                                "Análise de erros e limitações (20%)",
                                "Aplicação contextual em engenharia civil (15%)",
                                "Clareza na explicação e exemplos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear avançada e métodos numéricos.",
                                "Física: Dinâmica das estruturas e vibrações.",
                                "Computação: Programação científica e otimização numérica.",
                                "Engenharia Mecânica: Análise de vibrações em máquinas."
                              ],
                              "realWorldApplication": "Na análise modal de pontes e edifícios, deflação permite extrair modos críticos de vibração (ex: torção em pontes pênseis) de forma eficiente em matrizes grandes de FEA, otimizando design sísmico e reduzindo tempo computacional em simulações de engenharia civil."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Implementar deflação por subtração",
                            "description": "Desenvolver o algoritmo de deflação por subtração de rank-one, modificando a matriz original A para A - λ v v^T / (v^T v), onde λ é o autovalor e v a autofunção normalizada, com exemplo em MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a teoria da deflação por subtração rank-one",
                                  "subSteps": [
                                    "Estude a fórmula de deflação: A_new = A - λ * (v * v^T) / (v^T * v), onde v é normalizado.",
                                    "Entenda por que isso remove o autovalor λ da matriz A.",
                                    "Revise propriedades de autovalores e autovetores simétricos.",
                                    "Analise um exemplo teórico com matriz 2x2 para validar o conceito.",
                                    "Anote as condições necessárias: v deve ser normalizado (||v||=1)."
                                  ],
                                  "verification": "Explique em suas palavras como a deflação remove o autovalor e forneça um exemplo manual 2x2.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Documentação MATLAB eig()",
                                    "Livro de álgebra linear (ex: Strang)",
                                    "Papel e caneta para cálculos manuais"
                                  ],
                                  "tips": "Comece com matrizes simétricas para garantir autovalores reais.",
                                  "learningObjective": "Compreender matematicamente o processo de deflação por subtração.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar v",
                                    "Confundir v v^T com v^T v",
                                    "Não considerar matrizes não-simétricas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar a matriz e computar o primeiro par autovalor-autovetor",
                                  "subSteps": [
                                    "Defina uma matriz A simétrica de teste (ex: 3x3 ou 4x4).",
                                    "Use a função eig(A) no MATLAB para obter autovalores e autovetores.",
                                    "Identifique o autovalor dominante (maior módulo) e seu autovetor correspondente.",
                                    "Extraia λ e v do output de eig.",
                                    "Verifique se v está normalizado com norm(v) == 1; normalize se necessário."
                                  ],
                                  "verification": "Execute eig(A) e confirme que λ e v satisfazem A*v ≈ λ*v com erro < 1e-10.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "MATLAB instalado",
                                    "Script MATLAB básico",
                                    "Matriz de exemplo conhecida"
                                  ],
                                  "tips": "Use [V, D] = eig(A) para obter ambos; V(:,1) é o primeiro autovetor.",
                                  "learningObjective": "Computar corretamente o par dominante usando funções built-in do MATLAB.",
                                  "commonMistakes": [
                                    "Selecionar autovetor errado",
                                    "Não verificar normalização",
                                    "Usar autovalores complexos sem cuidado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o cálculo da matriz de rank-one e a deflação",
                                  "subSteps": [
                                    "Calcule v v^T usando v * v' (transposta conjugada no MATLAB).",
                                    "Compute o escalar denom = v' * v (deve ser ~1 se normalizado).",
                                    "Calcule a matriz rank_one = λ * (v * v') / denom.",
                                    "Atualize A_new = A - rank_one.",
                                    "Armazene A_new em uma variável e exiba para inspeção."
                                  ],
                                  "verification": "Confirme que trace(A_new) ≈ trace(A) - λ e det(A_new) muda adequadamente.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "MATLAB Editor",
                                    "Exemplo de matriz A hardcoded no script"
                                  ],
                                  "tips": "Use v * v' para outer product; evite loops para eficiência.",
                                  "learningObjective": "Codificar precisamente a fórmula de deflação em MATLAB.",
                                  "commonMistakes": [
                                    "Usar v' * v ao invés de v * v'",
                                    "Dividir incorretamente pelo denominador",
                                    "Erro de sinal na subtração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a deflação e iterar para múltiplos autovalores",
                                  "subSteps": [
                                    "Compute eig(A_new) e verifique que λ original não é mais autovalor (erro > 1e-6).",
                                    "Repita o processo para o próximo autovalor dominante em A_new.",
                                    "Implemente um loop para deflação múltipla até k autovalores.",
                                    "Compare autovalores originais com os deflacionados.",
                                    "Teste estabilidade numérica com matriz maior (ex: 10x10)."
                                  ],
                                  "verification": "Os k primeiros autovalores de A coincidem com os dominantes sequenciais das deflações.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "MATLAB com script expandido",
                                    "Matrizes de teste aleatórias (randn)"
                                  ],
                                  "tips": "Monitore resíduos ||A_new * v - λ * v|| para validação.",
                                  "learningObjective": "Validar numericamente a deflação e estendê-la iterativamente.",
                                  "commonMistakes": [
                                    "Acúmulo de erros numéricos em loops",
                                    "Não recomeçar eig do zero cada vez",
                                    "Ignorar conditioning da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e documentar o algoritmo completo",
                                  "subSteps": [
                                    "Escreva uma função MATLAB deflacao_subtracao(A, k) que retorna autovalores e vetores deflacionados.",
                                    "Adicione comentários e help na função.",
                                    "Teste com matrizes de engenharia civil (ex: rigidez de treliça).",
                                    "Meça tempo de execução vs power method puro.",
                                    "Compare precisão com eig full."
                                  ],
                                  "verification": "Função retorna autovalores corretos para k=1 a n-1 sem crashes.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "MATLAB Function file",
                                    "Exemplos de matrizes estruturais"
                                  ],
                                  "tips": "Use sparse se A for esparsa em aplicações civis.",
                                  "learningObjective": "Criar um algoritmo reutilizável e bem documentado.",
                                  "commonMistakes": [
                                    "Função não vectorizada",
                                    "Falta de input validation",
                                    "Documentação incompleta"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [4 1 0; 1 3 1; 0 1 2]. eig(A) dá λ1≈5.37, v1≈[0.62; 0.78; 0.12]. Após deflação: A_new ≈ [3.35 0.24 -0.07; 0.24 2.76 0.76; -0.07 0.76 1.89]. eig(A_new) confirma λ1 removido, próximos ≈3.17 e 0.83.",
                              "finalVerifications": [
                                "Autovalor original λ não satisfaz mais A_new * v ≈ λ * v (resíduo > 1e-8).",
                                "Traço de A_new = traço(A) - λ.",
                                "Autovalores restantes coincidem com os de A exceto λ.",
                                "Código executa em <1s para matriz 50x50.",
                                "Função lida com múltiplas deflações sem perda de precisão.",
                                "Normalização preservada em todos autovetores."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: fórmula implementada exatamente.",
                                "Eficiência numérica: resíduos < 1e-10.",
                                "Robustez: funciona para matrizes simétricas até 100x100.",
                                "Clareza do código: comentado e modular.",
                                "Validação: testes unitários incluídos.",
                                "Documentação: help e exemplos na função."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso avançado de MATLAB para álgebra linear.",
                                "Engenharia Estrutural: Cálculo de modos de vibração em edifícios.",
                                "Física Computacional: Simulação de sistemas dinâmicos lineares.",
                                "Otimização: Aceleração de métodos iterativos como power method."
                              ],
                              "realWorldApplication": "Na análise modal de estruturas civis (ex: pontes, edifícios), deflação permite extrair modos de vibração sucessivos eficientemente sem computar todos os autovalores, otimizando simulações sísmicas em MATLAB para projetos de engenharia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Aplicar deflação por orthogonalização",
                            "description": "Utilizar processo de Gram-Schmidt para orthogonalizar novas autofunções em relação às anteriores, garantindo independência linear em problemas de vibrações estruturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de autovalores, autofunções e orthogonalidade",
                                  "subSteps": [
                                    "Defina autovalores e autofunções de uma matriz de rigidez/massa em problemas de vibrações.",
                                    "Explique a importância da orthogonalidade das autofunções para independência linear dos modos de vibração.",
                                    "Revise o produto escalar e a norma euclidiana para vetores.",
                                    "Discuta o papel da deflação em métodos iterativos para encontrar múltiplos autovalores.",
                                    "Identifique quando a orthogonalização é necessária em problemas estruturais."
                                  ],
                                  "verification": "Resuma os conceitos em um diagrama ou tabela e explique verbalmente para um colega.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de álgebra linear, notas de aula, calculadora.",
                                  "tips": "Use exemplos simples de matrizes 2x2 para ilustrar autovalores antes de avançar.",
                                  "learningObjective": "Compreender os fundamentos teóricos que justificam a deflação por orthogonalização.",
                                  "commonMistakes": "Confundir orthogonalidade com normalização; lembre-se que orthogonalidade é produto escalar zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter autofunções iniciais e aproximada nova",
                                  "subSteps": [
                                    "Calcule as primeiras autofunções φ1 e φ2 usando método da potência ou similar para a matriz do problema.",
                                    "Gere uma autofunção aproximada φ_new via iteração inicial (ex: método de Rayleigh-Ritz).",
                                    "Verifique se φ1 e φ2 já estão normalizadas (||φ_i|| = 1).",
                                    "Armazene as autofunções em um conjunto ortonormal inicial.",
                                    "Defina a matriz de massas/rigidez do problema estrutural simples (ex: viga com 3 graus de liberdade)."
                                  ],
                                  "verification": "Confirme que as autofunções iniciais satisfazem A φ_i = λ_i φ_i com tolerância < 1e-6.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python (NumPy/SciPy), papel quadriculado.",
                                  "tips": "Comece com problemas pequenos (n=3) para depuração rápida.",
                                  "learningObjective": "Preparar o conjunto de dados necessário para o processo de orthogonalização.",
                                  "commonMistakes": "Não normalizar as iniciais; sempre normalize antes de orthogonalizar novas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o processo de Gram-Schmidt para orthogonalização",
                                  "subSteps": [
                                    "Calcule as projeções proj_φi = (φ_new · φ_i) φ_i para cada φ_i anterior.",
                                    "Subtraia as projeções: φ_new_ort = φ_new - sum(proj_φi).",
                                    "Normalize a nova autofunção: φ_new = φ_new_ort / ||φ_new_ort||.",
                                    "Repita o processo iterativamente se necessário para convergência.",
                                    "Implemente em código ou manualmente para verificação."
                                  ],
                                  "verification": "Verifique que φ_new · φ_i = 0 para todos i anteriores com precisão numérica.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python/MATLAB com funções dot() e norm(), planilha Excel para testes manuais.",
                                  "tips": "Use tolerância 1e-10 para produtos escalares em computação numérica.",
                                  "learningObjective": "Executar o algoritmo Gram-Schmidt passo a passo em vetores de autofunções.",
                                  "commonMistakes": "Esquecer de subtrair todas as projeções ou inverter a ordem de subtração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar independência linear e integrar na deflação",
                                  "subSteps": [
                                    "Teste independência linear computando o determinante da matriz formada pelas autofunções.",
                                    "Atualize o espaço deflacionado: deflação efetiva removendo componentes nas direções anteriores.",
                                    "Aplique em iteração subsequente para próxima autofunção.",
                                    "Analise estabilidade numérica (condicionamento da base).",
                                    "Documente o processo em um relatório com vetores finais."
                                  ],
                                  "verification": "Confirme det([φ1, φ2, φ_new]) ≠ 0 e normas unitárias.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de álgebra linear (SymPy para simbólico), relatório template.",
                                  "tips": "Monitore o condicionamento da matriz para evitar ill-conditioning.",
                                  "learningObjective": "Garantir que o conjunto final seja ortonormal e independente.",
                                  "commonMistakes": "Ignorar erros de arredondamento; use precisão dupla."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em problema real de vibrações estruturais",
                                  "subSteps": [
                                    "Monte matrizes de massa M e rigidez K para uma treliça ou viga simples.",
                                    "Encontre múltiplos modos usando deflação ortogonalizada.",
                                    "Compare frequências naturais com solução exata.",
                                    "Visualize modos de vibração (plot de deslocamentos).",
                                    "Discuta aceleração do método vs. sem deflação."
                                  ],
                                  "verification": "Frequências convergem com erro < 1% após poucas iterações.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB Structural Toolbox ou FEniCS/Python, dados de estrutura exemplo.",
                                  "tips": "Escolha estruturas simétricas para orthogonalidade natural.",
                                  "learningObjective": "Aplicar deflação por orthogonalização em contexto engenheiro-civil real.",
                                  "commonMistakes": "Não considerar simetria das matrizes; assuma M e K simétricas positivas definidas."
                                }
                              ],
                              "practicalExample": "Considere uma viga com 3 DOFs: M = diag(1,1,1), K = [[2,-1,0],[-1,2,-1],[0,-1,1]]. Autofunções iniciais φ1=[1,1,1]/sqrt(3), φ2=[1,0,-1]/sqrt(2). Nova approx φ_new=[1,2,1]. Aplique Gram-Schmidt: proj1=(φ_new·φ1)φ1 ≈ [4/3,4/3,4/3]/sqrt(3), proj2=(φ_new·φ2)φ2 ≈ 0, φ_new_ort=[1-4/3,2-4/3,1-4/3], normalize para obter φ3 ortogonal.",
                              "finalVerifications": [
                                "Todos produtos escalares φ_new · φ_i = 0 (tol 1e-10).",
                                "Norma euclidiana ||φ_new|| = 1.",
                                "Autovalor associado satisfaz K φ_new = λ M φ_new.",
                                "Conjunto {φ1,φ2,φ3} linearmente independente (rank=3).",
                                "Convergência acelerada em iterações subsequentes.",
                                "Visualização dos modos mostra deformações independentes."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática no cálculo de projeções (100% precisão).",
                                "Eficiência computacional (tempo de execução < esperado).",
                                "Tratamento de erros numéricos (uso de tolerâncias adequadas).",
                                "Explicação clara do processo em relatório.",
                                "Aplicação correta em contexto estrutural.",
                                "Identificação de melhorias ou limitações do método."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Linear e métodos numéricos iterativos.",
                                "Física: Mecânica das Vibrações e dinâmica estrutural.",
                                "Computação: Programação científica (NumPy, SciPy, MATLAB).",
                                "Engenharia Mecânica: Análise modal de sistemas multi-graus de liberdade.",
                                "Estatística: Análise de erros e condicionamento matricial."
                              ],
                              "realWorldApplication": "Na análise modal de pontes e edifícios altos, a deflação por orthogonalização permite calcular modos de vibração independentes rapidamente, essencial para prever ressonâncias em terremotos ou ventos fortes, otimizando o projeto contra falhas catastróficas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.4",
                            "name": "Analisar estabilidade numérica da deflação",
                            "description": "Discutir questões de condicionamento e perda de precisão na deflação, com estratégias de mitigação usando matrizes de Gram e exemplos numéricos de instabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de deflação e condicionamento numérico",
                                  "subSteps": [
                                    "Defina deflação como o processo de remover autovalores conhecidos para isolar os restantes em uma matriz.",
                                    "Explique condicionamento numérico usando o número de condição de uma matriz (cond(A) = ||A|| * ||A^{-1}||).",
                                    "Discuta como erros de arredondamento se amplificam em iterações de deflação.",
                                    "Identifique fontes de perda de precisão: subtração de autovetores e multiplicações sucessivas.",
                                    "Calcule cond(A) para uma matriz de exemplo 2x2."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e calcule cond(A) corretamente para a matriz exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, calculadora científica, software MATLAB ou Python (NumPy).",
                                  "tips": "Use normas 2 para condicionamento, pois é comum em autovalores.",
                                  "learningObjective": "Compreender como o condicionamento afeta a estabilidade da deflação.",
                                  "commonMistakes": "Confundir condicionamento com rank da matriz; ignorar impacto de autovalores próximos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar instabilidade numérica com exemplos concretos",
                                  "subSteps": [
                                    "Construa uma matriz simétrica 3x3 com autovalores λ1=1, λ2=1.001, λ3=2 (próximos para simular instabilidade).",
                                    "Aplique deflação padrão: defla = A - λ1 * (u1 * u1^T), onde u1 é autovetor normalizado.",
                                    "Compute autovalores da matriz deflacionada em precisão finita (use float64).",
                                    "Compare com valores exatos e meça erro relativo: |λ_approx - λ_exact| / |λ_exact|.",
                                    "Repita com perturbação de 1e-10 em u1 para simular erro de arredondamento."
                                  ],
                                  "verification": "Gere tabela de erros relativos mostrando amplificação >10x em λ2.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, Jupyter Notebook para visualização.",
                                  "tips": "Normalizar autovetores com norma euclidiana para consistência.",
                                  "learningObjective": "Identificar e quantificar perda de precisão na deflação padrão.",
                                  "commonMistakes": "Usar precisão infinita (simbólica) em vez de finita; não perturbar intencionalmente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar estratégias de mitigação com matrizes de Gram",
                                  "subSteps": [
                                    "Defina matriz de Gram G = U^T U, onde U contém autovetores deflacionados ortonormalizados.",
                                    "Explique deflação via Gram: nova matriz B = U^T A U, que preserva simetria e ortogonalidade.",
                                    "Implemente deflação de Gram: atualize U removendo coluna e reortogonalizando com QR.",
                                    "Compare cond(B) vs. cond(defla padrão) no exemplo do Step 2.",
                                    "Discuta deflação implícita vs. explícita para evitar formação explícita de subtrações."
                                  ],
                                  "verification": "Mostre que cond(B) < cond(defla) e erros reduzidos em 50% ou mais.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python (NumPy, SciPy.linalg.qr), documentação de funções qr e eig.",
                                  "tips": "Use qr para reortogonalização eficiente em dimensões maiores.",
                                  "learningObjective": "Dominar mitigação de instabilidade usando propriedades de Gram.",
                                  "commonMistakes": "Esquecer reortogonalização após remoção; usar Gram não simétrica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, comparar e validar em contexto aplicado",
                                  "subSteps": [
                                    "Aplique deflação padrão e Gram a uma matriz 4x4 de rigidez estrutural (ex: viga com modos vibracionais).",
                                    "Meça tempos de computação e precisão para n=10 iterações.",
                                    "Gere gráfico de erros vs. número de deflações deflacionadas.",
                                    "Proponha critérios para escolher método: se cond > 1e6, use Gram.",
                                    "Teste sensibilidade a ruído gaussiano em A."
                                  ],
                                  "verification": "Relatório com gráficos e conclusão sobre superioridade da mitigação.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/Python, Matplotlib/Plots para gráficos, matriz exemplo de engenharia.",
                                  "tips": "Escalone para matrizes maiores usando sparse se disponível.",
                                  "learningObjective": "Aplicar análise de estabilidade em cenários reais de engenharia.",
                                  "commonMistakes": "Ignorar simetria da matriz original; não validar ortogonalidade final."
                                }
                              ],
                              "practicalExample": "Considere a matriz de massa M = [[2, 0.1, 0], [0.1, 2, 0.1], [0, 0.1, 2]] com autovalores próximos ~2. Usando deflação padrão após remover λ1=1.9, erro em λ2 cresce para 1e-8; com Gram, reduz para 1e-12. Implemente em Python: eigvals_padrão vs. eigvals_gram.",
                              "finalVerifications": [
                                "Explicar verbalmente como condicionamento amplifica erros na deflação.",
                                "Computar manualmente deflação para 2x2 e identificar perda de precisão.",
                                "Implementar código Python/MATLAB para exemplo 3x3 mostrando instabilidade.",
                                "Comparar erros em deflação padrão vs. Gram em matriz 4x4.",
                                "Propor mitigação para autovalores múltiplos.",
                                "Analisar impacto em análise modal de uma estrutura simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de condicionamento e seu papel (20%)",
                                "Correção nos cálculos numéricos e detecção de instabilidade (25%)",
                                "Implementação válida de deflação com Gram e comparação (25%)",
                                "Análise qualitativa/quantitativa de erros e mitigações (15%)",
                                "Clareza em exemplos e gráficos (10%)",
                                "Conexão com aplicações em engenharia civil (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Propriedades de autovalores e ortogonalidade.",
                                "Análise Numérica: Erros de arredondamento e estabilidade de algoritmos.",
                                "Programação Computacional: Implementação em Python/MATLAB para eigenproblems.",
                                "Engenharia Estrutural: Análise modal e frequências naturais em vibrações."
                              ],
                              "realWorldApplication": "Na análise dinâmica de edifícios altos, deflação de autovalores da matriz de rigidez/massa identifica modos vibracionais subsequentes. Instabilidade numérica pode levar a frequências erradas, causando superestimação de ressonância em terremotos; mitigação com Gram garante precisão em simulações FEM para projetos seguros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Métodos de Aceleração",
                        "description": "Técnicas para melhorar a taxa de convergência dos métodos iterativos de autovalores, como shifts, focando em aceleração para autovalores dominantes ou específicos em simulações de engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Explicar o conceito de shift em métodos iterativos",
                            "description": "Descrever como o shift σ transforma o problema em (A - σI) para isolar autovalores próximos a σ, acelerando métodos como o power method em análises de estabilidade estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os métodos iterativos básicos e suas limitações",
                                  "subSteps": [
                                    "Revise o power method: iterar v_{k+1} = A v_k / ||A v_k|| para encontrar autovetor dominante.",
                                    "Identifique que o método converge lentamente se o autovalor de interesse não for o dominante (maior módulo).",
                                    "Discuta aplicações em engenharia civil, como análise de estabilidade onde autovalores indicam frequências de vibração.",
                                    "Calcule manualmente 3 iterações de power method em uma matriz simples para observar lentidão.",
                                    "Anote razões para aceleração em problemas reais com espectro de autovalores espalhado."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que o power method falha em isolar autovalores não dominantes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, lápis, calculadora científica, matriz de exemplo 2x2 (ex: A = [[3,1],[1,2]])",
                                  "tips": "Comece com matrizes pequenas para visualizar convergência antes de escalar.",
                                  "learningObjective": "Identificar limitações do power method em contextos de engenharia estrutural.",
                                  "commonMistakes": "Confundir autovalor dominante com o de maior interesse; ignorar normalização no método."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito matemático do shift",
                                  "subSteps": [
                                    "Defina shift σ como um número escalar escolhido próximo ao autovalor desejado λ.",
                                    "Mostre a transformação: resolva (A - σI) x = b em vez de A x = λ x, isolando autovalores de A - σI próximos a zero.",
                                    "Derive que autovalores de A - σI são λ_i - σ, então λ = μ + σ onde μ é autovalor de A - σI.",
                                    "Explique geometricamente: shift desloca o espectro para tornar λ - σ dominante.",
                                    "Discuta escolha de σ: use Rayleigh quotient ou estimativas iniciais."
                                  ],
                                  "verification": "Escreva a equação (A - σI) v = μ v e relacione μ com λ original.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de derivadas matriciais, software como MATLAB ou Python (NumPy) para testar shifts",
                                  "tips": "Visualize o espectro em gráfico de autovalores reais para escolher σ intuitivamente.",
                                  "learningObjective": "Dominar a formulação algébrica do shift e sua justificativa espectral.",
                                  "commonMistakes": "Esquecer de adicionar σ de volta ao recuperar λ; escolher σ longe do alvo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar shift no power method (shifted power method)",
                                  "subSteps": [
                                    "Modifique power method: aplique a B = A - σI em vez de A.",
                                    "Execute iterações: w_{k+1} = B w_k / ||B w_k||, estime μ ≈ Rayleigh quotient.",
                                    "Recupere λ = μ + σ e autovetor v = w.",
                                    "Compare convergência com e sem shift em uma matriz de exemplo.",
                                    "Teste numericamente com ruído para simular dados reais de estruturas."
                                  ],
                                  "verification": "Implemente e rode 5 iterações, mostrando aceleração (ex: erro reduzido em 50%).",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, matriz de teste 3x3 (ex: A com autovalores 10, 2, 1; σ=1.5)",
                                  "tips": "Use laços em código para automatizar iterações e plotar erro vs. iterações.",
                                  "learningObjective": "Implementar e validar o shifted power method computacionalmente.",
                                  "commonMistakes": "Não normalizar vetores; confundir autovetor de B com o de A."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar aplicações e sensibilidade em estabilidade estrutural",
                                  "subSteps": [
                                    "Relacione a análise modal: autovalores como frequências naturais de vigas/estruturas.",
                                    "Discuta aceleração em matrizes grandes de elementos finitos (KEF).",
                                    "Teste sensibilidade: varie σ e meça iterações para convergência.",
                                    "Explore deflação combinada: use shift após encontrar um autovalor.",
                                    "Resuma vantagens: redução de custo computacional em simulações civis."
                                  ],
                                  "verification": "Descreva um cenário de ponte onde shift acelera análise de flutter.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Artigo ou vídeo sobre análise modal em engenharia civil, planilha para sensibilidade",
                                  "tips": "Priorize σ via inspeção de diagonal da matriz para aproximações rápidas.",
                                  "learningObjective": "Conectar shift a problemas reais de engenharia civil.",
                                  "commonMistakes": "Subestimar il-condicionamento se σ muito próximo a múltiplos λ; ignorar simetria de A."
                                }
                              ],
                              "practicalExample": "Considere matriz de rigidez de uma treliça simples A = [[5, -2], [-2, 5]] com autovalores 3 e 7. Sem shift, power method converge devagar para λ=3. Escolha σ=3, B=A-3I=[[2,-2],[-2,2]], autovalores de B: 0 e 4. Aplique power method em B: converge rápido a autovetor [1,1], λ=3+0=3 em 3 iterações vs. 10 sem shift.",
                              "finalVerifications": [
                                "Explica corretamente a transformação A → A - σI e recuperação de λ.",
                                "Implementa shifted power method em código e demonstra aceleração numérica.",
                                "Identifica σ ótimo para um espectro dado.",
                                "Relaciona conceito a análise de estabilidade em engenharia civil.",
                                "Discute limitações como sensibilidade numérica.",
                                "Compara convergência com/sem shift em gráfico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (80% correto).",
                                "Correção na implementação computacional (convergência verificada).",
                                "Profundidade na escolha e justificativa de σ.",
                                "Relevância de exemplos à engenharia civil.",
                                "Clareza na explicação oral/escrita de aceleração.",
                                "Identificação de pelo menos 2 erros comuns e prevenções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear avançada e análise numérica.",
                                "Programação: Implementação em Python/MATLAB para métodos iterativos.",
                                "Física: Dinâmica de estruturas e modos de vibração.",
                                "Engenharia Mecânica: Análise modal compartilhada com civil."
                              ],
                              "realWorldApplication": "Em análises de estabilidade de pontes ou edifícios via elementos finitos, shifts aceleram extração de frequências baixas críticas para evitar ressonância, reduzindo tempo de simulação de horas para minutos em matrizes de milhares de graus de liberdade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Implementar shift de Rayleigh",
                            "description": "Calcular o quociente de Rayleigh ρ = v^T A v / v^T v como shift adaptativo, aplicando no método da potência invertida para convergência rápida ao autovalor mais próximo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Quociente de Rayleigh e sua Interpretação",
                                  "subSteps": [
                                    "Estude a definição do quociente de Rayleigh: ρ = (v^T A v) / (v^T v), onde A é simétrica e v é um vetor não nulo.",
                                    "Derive intuitivamente por que ρ aproxima um autovalor quando v é próximo de um autovetor.",
                                    "Calcule manualmente ρ para uma matriz 2x2 simples, como A = [[4,1],[1,3]], com v = [1,1].",
                                    "Analise como ρ varia com a direção de v, plotando em papel ou software simples.",
                                    "Leia sobre propriedades: ρ está entre λ_min e λ_max para A simétrica definida positiva."
                                  ],
                                  "verification": "Calcule corretamente ρ para pelo menos 3 vetores de teste e explique sua relação com autovalores.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Calculadora ou papel para cálculos manuais",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Pense em ρ como uma média ponderada dos autovalores; visualize v como combinação de autovetores.",
                                  "learningObjective": "Entender matematicamente o quociente de Rayleigh como estimativa de autovalor.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar o denominador v^T v",
                                    "Usar produto escalar incorreto (v A v em vez de v^T A v)",
                                    "Ignorar simetria de A"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Cálculo Numérico do Quociente de Rayleigh",
                                  "subSteps": [
                                    "Instale e importe bibliotecas: NumPy para operações matriciais.",
                                    "Escreva função rayleigh_quotient(A, v) que compute ρ usando np.dot(v.T, np.dot(A, v)) / np.dot(v.T, v).",
                                    "Teste com matrizes de exemplo 2x2 e 3x3, variando v inicial.",
                                    "Adicione normalização de v para evitar overflow: v = v / np.linalg.norm(v).",
                                    "Crie script para plotar ρ vs iterações iniciais no método da potência básica."
                                  ],
                                  "verification": "Função retorna ρ exato (até 1e-10) para autovetor exato fornecido.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy",
                                    "Jupyter Notebook",
                                    "Matriz de teste A = np.array([[4,1],[1,3]])"
                                  ],
                                  "tips": "Use np.linalg.norm(v) para normalizar; evite loops desnecessários com operações vetoriais.",
                                  "learningObjective": "Codificar eficientemente o quociente de Rayleigh para matrizes reais.",
                                  "commonMistakes": [
                                    "Não transpor v corretamente",
                                    "Dividir por zero se v=0 (sempre normalizar)",
                                    "Usar loops em vez de operações matriciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Revisar e Implementar Método da Potência Invertida Básico",
                                  "subSteps": [
                                    "Revise power iteration invertida: resolve (A - σI) w = v_k para aproximar autovalor próximo a σ.",
                                    "Implemente função power_inverse(A, sigma, v0, tol=1e-8, max_iter=100).",
                                    "No loop: resolva sistema linear com np.linalg.solve, normalize w, atualize v.",
                                    "Monitore ||v_{k+1} - v_k|| para convergência.",
                                    "Teste com σ inicial arbitrário e verifique convergência lenta."
                                  ],
                                  "verification": "Método converge ao autovalor mais próximo de σ em <50 iterações para matriz 5x5.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "NumPy/SciPy para solve",
                                    "Jupyter Notebook",
                                    "Matrizes de teste assimétricas opcionais"
                                  ],
                                  "tips": "Escolha σ inicial como traço(A)/n; use solve para eficiência em matrizes densas.",
                                  "learningObjective": "Implementar power iteration invertida para targeting autovalores específicos.",
                                  "commonMistakes": [
                                    "Escolha ruim de σ levando a não-convergência",
                                    "Não normalizar após solve",
                                    "Tolerância muito frouxa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Shift de Rayleigh Adaptativo no Algoritmo",
                                  "subSteps": [
                                    "Modifique o loop: após cada iteração, compute ρ = rayleigh_quotient(A, v), use como novo σ.",
                                    "Atualize σ ← ρ a cada passo para aceleração adaptativa.",
                                    "Implemente parada dupla: tol em ||v_new - v|| e mudança em ρ < tol.",
                                    "Compare iterações com e sem shift em log de saída.",
                                    "Adicione logging: imprima ρ_k, iteração, norma residual."
                                  ],
                                  "verification": "Com shift, converge 2-5x mais rápido que sem shift no mesmo exemplo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código dos passos anteriores",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Atualize σ só após 2-3 iterações iniciais para estabilidade; plote convergência.",
                                  "learningObjective": "Combinar Rayleigh shift com power invertida para convergência rápida.",
                                  "commonMistakes": [
                                    "Atualizar σ muito cedo causando oscilação",
                                    "Não reiniciar v após shift",
                                    "Ignorar normalização pós-shift"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Validar e Analisar Convergência",
                                  "subSteps": [
                                    "Aplique a matriz exemplo de vibração: A 4x4 de estrutura treliça (fornecida ou gere).",
                                    "Compare autovalor com np.linalg.eigvals(A) como ground truth.",
                                    "Meça speedup: iterações com/sem shift, tempo CPU.",
                                    "Teste sensibilidade: varie v0 randômico 10x, compute média de iterações.",
                                    "Documente relatório: código, plots de ρ vs iter, conclusões."
                                  ],
                                  "verification": "Erro em autovalor final <1e-6 e speedup observável.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "NumPy completo",
                                    "Matplotlib para plots",
                                    "Matriz exemplo de engenharia"
                                  ],
                                  "tips": "Use seed para reprodutibilidade em rand; benchmark com %timeit.",
                                  "learningObjective": "Validar implementação empiricamente e quantificar aceleração.",
                                  "commonMistakes": [
                                    "Comparar com eigvals sem checar simetria",
                                    "v0 muito próximo de singular",
                                    "Plots sem legendas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para matriz de massas/rigidez em viga Euler-Bernoulli 3 graus de liberdade: A = [[10, -5, 0], [-5, 12, -5], [0, -5, 8]]. Inicie com v0 = [1,0,0], σ=0. Aplique power invertida sem shift (30+ iters), depois com Rayleigh shift (converge em 8 iters ao λ≈0.5, freq natural de vibração).",
                              "finalVerifications": [
                                "Código completo roda sem erros para matrizes até 10x10.",
                                "Rayleigh shift acelera convergência em pelo menos 2x vs básico.",
                                "Autovalor estimado bate com eigvals dentro de 1e-8.",
                                "Relatório inclui plots de convergência e análise de speedup.",
                                "Função generaliza para múltiplos shifts (cluster de autovalores).",
                                "Testes unitários passam para casos edge (v0 singular)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro <1e-10 em ρ para autovetor exato (30%).",
                                "Eficiência: speedup quantificado e plots claros (25%).",
                                "Código limpo: funções modulares, comentários, PEP8 (20%).",
                                "Análise: explicação de porquê shift funciona, erros comuns evitados (15%).",
                                "Aplicação: adaptação a exemplo de engenharia civil real (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Quocientes de Rayleigh e métodos iterativos.",
                                "Programação Computacional: NumPy/SciPy para álgebra linear numérica.",
                                "Engenharia Civil: Análise modal de estruturas dinâmicas.",
                                "Física: Modos normais de vibração em sistemas discretos.",
                                "Otimização: Aceleração de algoritmos iterativos."
                              ],
                              "realWorldApplication": "Em análise dinâmica de edifícios e pontes, acelera cálculo de frequências naturais (autovalores) para design sísmico, reduzindo tempo de simulação de horas para minutos em modelos FEM grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Aplicar shift de Wilkinson",
                            "description": "Utilizar shift ótimo aproximado σ = a_{n,n} para matrizes tridiagonais na QR algorithm, demonstrando aceleração em problemas de valores próprios de grandes matrizes de rigidez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Algoritmo QR Básico para Matrizes Tridiagonais Simétricas",
                                  "subSteps": [
                                    "Estudar a decomposição QR usando reflexões de Householder para manter a tridiagonalidade.",
                                    "Implementar uma iteração QR simples sem shift em uma matriz tridiagonal pequena.",
                                    "Executar múltiplas iterações e observar a convergência lenta para autovalores.",
                                    "Analisar como a tridiagonalidade é preservada após cada iteração QR.",
                                    "Verificar a ordenação descendente dos autovalores na diagonal."
                                  ],
                                  "verification": "Código roda sem erros e produz autovalores aproximados corretos após 50+ iterações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Documentação de análise numérica (ex: Golub & Van Loan)"
                                  ],
                                  "tips": "Use loops while para iterações até convergência de 1e-10.",
                                  "learningObjective": "Compreender o mecanismo de convergência da QR para matrizes tridiagonais.",
                                  "commonMistakes": [
                                    "Perder a estrutura tridiagonal por arredondamento",
                                    "Não normalizar corretamente os refletors de Householder"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Necessidade de Shifts e Deflação na QR",
                                  "subSteps": [
                                    "Explicar por que shifts aceleram a convergência deflacionária.",
                                    "Estudar deflação: identificar autovalores convergidos quando |a_{k,k} - a_{k+1,k+1}| < epsilon.",
                                    "Implementar QR com shift genérico σ = a_{k,k} e comparar iterações.",
                                    "Analisar o papel do shift em aproximar o autovalor dominante.",
                                    "Testar em matriz de exemplo para observar redução de iterações."
                                  ],
                                  "verification": "Comparar número de iterações: sem shift >20, com shift <10 para matriz 10x10.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Jupyter Notebook",
                                    "Exemplos de matrizes tridiagonais rígidas"
                                  ],
                                  "tips": "Escolha epsilon = 1e-12 para tolerância de deflação.",
                                  "learningObjective": "Dominar como shifts genéricos melhoram a velocidade da QR.",
                                  "commonMistakes": [
                                    "Escolher shift incorreto levando a divergência",
                                    "Ignorar deflação causando recomputação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender o Shift de Wilkinson e sua Justificativa Teórica",
                                  "subSteps": [
                                    "Derivar o shift ótimo aproximado σ = a_{n,n} para o bloco 2x2 inferior.",
                                    "Estudar por que Wilkinson escolhe o autovalor menor do bloco 2x2 para aceleração.",
                                    "Implementar cálculo de σ resolvendo equação quadrática do bloco [a_{n-1,n-1}, a_{n-1,n}; a_{n,n-1}, a_{n,n}].",
                                    "Analisar estabilidade numérica e robustez para matrizes rígidas.",
                                    "Comparar com shift = Rayleigh (a_{n,n})."
                                  ],
                                  "verification": "σ calculado coincide com autovalor exato do bloco 2x2 dentro de 1e-10.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis para derivação",
                                    "Código Python para bloco 2x2"
                                  ],
                                  "tips": "Use fórmula analítica para raízes quadráticas evitando overflow.",
                                  "learningObjective": "Justificar matematicamente a escolha de σ = Wilkinson shift.",
                                  "commonMistakes": [
                                    "Confundir com shift de Rayleigh simples",
                                    "Erro na fórmula do discriminante quadrático"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar QR com Shift de Wilkinson e Demonstrar Aceleração",
                                  "subSteps": [
                                    "Codificar algoritmo completo: QR com Wilkinson shift e deflação iterativa.",
                                    "Testar em matriz tridiagonal grande (n=100) de rigidez estrutural.",
                                    "Medir tempo e iterações vs. QR sem shift.",
                                    "Verificar precisão dos autovalores contra método exato (ex: eig).",
                                    "Otimizar código para grandes matrizes (vetorização)."
                                  ],
                                  "verification": "Aceleração >5x em iterações para matriz 100x100 rígida.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "NumPy/SciPy para benchmarks",
                                    "Matrizes de exemplo de engenharia civil"
                                  ],
                                  "tips": "Profile o código com %timeit para medir aceleração real.",
                                  "learningObjective": "Aplicar shift de Wilkinson para resolver problemas de autovalores eficientemente.",
                                  "commonMistakes": [
                                    "Não deflar corretamente múltiplos autovalores",
                                    "Arredondamento em matrizes grandes"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a matriz tridiagonal simétrica 4x4 de rigidez: A = [[4, -1, 0, 0], [-1, 4, -1, 0], [0, -1, 4, -1], [0, 0, -1, 4]], aplique QR sem shift (converge em ~25 iterações) vs. com Wilkinson shift (converge em ~8 iterações), obtendo autovalores ≈ [1.0, 2.0, 3.0, 6.0] com precisão 1e-12.",
                              "finalVerifications": [
                                "Implementa QR com Wilkinson shift convergindo 5x mais rápido que sem shift.",
                                "Calcula corretamente σ do bloco 2x2 inferior.",
                                "Preserva tridiagonalidade e deflação em matrizes n>50.",
                                "Autovalores coincidem com numpy.linalg.eig dentro de 1e-10.",
                                "Demonstra aceleração em matriz rígida de engenharia civil.",
                                "Explica verbalmente a teoria do shift ótimo aproximado."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica dos autovalores (erro <1e-10).",
                                "Eficiência: redução comprovada de iterações/tempo (>4x).",
                                "Corretude da implementação (testes unitários passam).",
                                "Manuseio de casos edge (matriz quase singular).",
                                "Documentação clara do código com comentários.",
                                "Análise comparativa em relatório curto."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação eficiente em Python/MATLAB.",
                                "Análise Estrutural (Engenharia Civil): Cálculo de modos de vibração.",
                                "Física Computacional: Simulação de sistemas dinâmicos rígidos.",
                                "Otimização Numérica: Técnicas de aceleração iterativa.",
                                "Matemática Aplicada: Álgebra linear avançada."
                              ],
                              "realWorldApplication": "Na engenharia civil, acelera o cálculo de frequências naturais e modos de vibração em grandes matrizes de rigidez de edifícios altos ou pontes, permitindo simulações em tempo real para análise sísmica e otimização estrutural em softwares como SAP2000 ou ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Otimização e Programação Matemática",
                "description": "Técnicas de otimização e programação linear ou não-linear para problemas de engenharia.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Programação Linear",
                    "description": "Formulação de problemas de otimização com função objetivo e restrições lineares, resolvidos pelo método simplex.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Formulação de Problemas de Programação Linear",
                        "description": "Processo de modelagem matemática de problemas de otimização em Engenharia Civil, definindo variáveis de decisão, função objetivo linear e restrições lineares, incluindo conversão para forma padrão com variáveis de folga.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Identificar variáveis de decisão e parâmetros",
                            "description": "Reconhecer e definir as variáveis contínuas não-negativas que representam as decisões em problemas reais de Engenharia Civil, como alocação de recursos em obras ou dimensionamento de estruturas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Variáveis de Decisão e Parâmetros",
                                  "subSteps": [
                                    "Defina variáveis de decisão como as quantidades desconhecidas que representam escolhas em um problema de otimização.",
                                    "Defina parâmetros como valores fixos e conhecidos que descrevem o ambiente do problema.",
                                    "Explique por que as variáveis devem ser contínuas (podem assumir qualquer valor real) e não-negativas (≥0) em contextos de Engenharia Civil.",
                                    "Diferencie variáveis de decisão de parâmetros com exemplos simples, como tempo vs. quantidade de material."
                                  ],
                                  "verification": "Escreva definições claras e exemplos corretos em um resumo de 1 página.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Material didático sobre Programação Linear (PDF ou slides)"
                                  ],
                                  "tips": "Use analogias do dia a dia, como 'decidir quantos quilos de arroz comprar' para variáveis.",
                                  "learningObjective": "Dominar as definições e características essenciais de variáveis e parâmetros.",
                                  "commonMistakes": "Confundir parâmetros com variáveis ou ignorar a não-negatividade em problemas físicos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar um Problema Real de Engenharia Civil",
                                  "subSteps": [
                                    "Escolha um problema concreto, como alocação de recursos em uma obra de ponte.",
                                    "Identifique o objetivo principal (ex: minimizar custo ou tempo).",
                                    "Liste as restrições naturais do problema (ex: capacidade de carga, orçamento disponível).",
                                    "Descreva as decisões que o engenheiro deve tomar no contexto real."
                                  ],
                                  "verification": "Crie um diagrama ou fluxograma do problema destacando objetivos e restrições.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplo de problema impresso ou digital",
                                    "Software de diagramação como Draw.io (opcional)"
                                  ],
                                  "tips": "Comece pelo 'o quê' (decisões) antes do 'como' (modelagem).",
                                  "learningObjective": "Desenvolver habilidade de decompor problemas reais em componentes acionáveis.",
                                  "commonMistakes": "Focar apenas em objetivos sem considerar restrições reais do mundo físico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Definir Variáveis de Decisão",
                                  "subSteps": [
                                    "Para cada decisão identificada, atribua uma variável (ex: x1 = toneladas de concreto).",
                                    "Garanta que as variáveis sejam contínuas (ex: não inteiras se fracionário for possível).",
                                    "Especifique o domínio não-negativo (x ≥ 0).",
                                    "Nomeie as variáveis de forma descritiva e liste-as com unidades."
                                  ],
                                  "verification": "Liste 3-5 variáveis com notação matemática e justificativa de por que são decisões.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel quadriculado para equações",
                                    "Calculadora para estimativas iniciais"
                                  ],
                                  "tips": "Pergunte: 'Isso é algo que eu controlo e pode variar?' para confirmar variáveis.",
                                  "learningObjective": "Mapear decisões reais para símbolos matemáticos precisos.",
                                  "commonMistakes": "Incluir dados fixos como variáveis ou usar variáveis discretas em problemas contínuos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Listar Parâmetros do Problema",
                                  "subSteps": [
                                    "Extraia valores fixos das restrições (ex: custo por tonelada = 1000 R$).",
                                    "Classifique parâmetros por tipo (custos, capacidades, demandas).",
                                    "Verifique consistência de unidades em todos os parâmetros.",
                                    "Documente fontes ou suposições para cada parâmetro."
                                  ],
                                  "verification": "Crie uma tabela com parâmetros, valores, unidades e justificativas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Dados de referência de Engenharia Civil"
                                  ],
                                  "tips": "Parâmetros são 'dados de entrada'; não mudam com as decisões.",
                                  "learningObjective": "Distinguir e catalogar dados fixos para formulação precisa.",
                                  "commonMistakes": "Tratar variáveis como parâmetros ou usar valores irreais sem justificativa."
                                }
                              ],
                              "practicalExample": "Em uma obra de fundação, defina x1 = volume de concreto (m³, ≥0), x2 = quantidade de aço (kg, ≥0) como variáveis de decisão para minimizar custo total, com parâmetros como custo_concreto=500 R$/m³, resistência_mínima=20 MPa.",
                              "finalVerifications": [
                                "Todas as variáveis são contínuas e não-negativas.",
                                "Variáveis representam diretamente decisões do engenheiro.",
                                "Parâmetros são valores fixos com unidades consistentes.",
                                "Lista de variáveis cobre todas as decisões essenciais do problema.",
                                "Não há sobreposição entre variáveis e parâmetros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 100% das decisões mapeadas corretamente.",
                                "Clareza na notação: símbolos descritivos e domínios explícitos.",
                                "Justificativa robusta: cada item suportado por raciocínio lógico.",
                                "Consistência de unidades: todas compatíveis com contexto civil.",
                                "Completude: sem omissões de restrições chave."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e modelagem matemática.",
                                "Economia: Otimização de custos e alocação de recursos escassos.",
                                "Informática: Preparação para implementação em solvers como Excel Solver ou Python (PuLP).",
                                "Gestão de Projetos: Planejamento de recursos em obras civis.",
                                "Física: Restrições baseadas em propriedades materiais e cargas."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, isso permite otimizar alocação de materiais em pontes ou edifícios, reduzindo custos em até 20% e evitando desperdícios, como no dimensionamento de vigas onde variáveis definem seções e parâmetros incluem normas ABNT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Formular a função objetivo linear",
                            "description": "Escrever a função objetivo linear de maximização ou minimização, expressando custos, lucros ou eficiência em termos das variáveis de decisão, com coeficientes derivados de dados do problema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o enunciado do problema e identificar o objetivo principal",
                                  "subSteps": [
                                    "Ler o enunciado completo do problema com atenção, destacando palavras-chave como 'maximizar', 'minimizar', 'lucro', 'custo' ou 'eficiência'.",
                                    "Determinar se o objetivo é de maximização (ex: lucro, produção) ou minimização (ex: custo, tempo).",
                                    "Identificar o que exatamente está sendo otimizado, como 'lucro total' ou 'custo total de materiais'.",
                                    "Reformular o objetivo em uma frase simples, como 'Maximizar o lucro total da produção'.",
                                    "Anotar todos os dados numéricos relevantes associados ao objetivo, ignorando restrições por enquanto."
                                  ],
                                  "verification": "Escrever uma frase clara resumindo o objetivo (max/min) e o que será otimizado, confirmando com o enunciado original.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Enunciado do problema",
                                    "Papel e caneta ou editor de texto",
                                    "Calculadora básica"
                                  ],
                                  "tips": [
                                    "Sempre priorize o que o problema pede explicitamente otimizar; evite presumir objetivos implícitos.",
                                    "Destaque termos em negrito ou sublinhe para facilitar revisão."
                                  ],
                                  "learningObjective": "Compreender e isolar o objetivo principal de otimização em problemas de programação linear.",
                                  "commonMistakes": [
                                    "Confundir o objetivo com as restrições do problema.",
                                    "Ignorar se é maximização ou minimização.",
                                    "Misturar dados de restrições com o objetivo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir as variáveis de decisão",
                                  "subSteps": [
                                    "Listar todos os elementos quantitativos que o tomador de decisão pode controlar, como quantidades de produtos ou recursos alocados.",
                                    "Atribuir símbolos matemáticos às variáveis, como x₁ para quantidade do produto A e x₂ para produto B.",
                                    "Escrever definições claras para cada variável, incluindo unidades (ex: x₁ = metros cúbicos de concreto tipo 1).",
                                    "Verificar se as variáveis são não-negativas (xᵢ ≥ 0) conforme o contexto do problema.",
                                    "Confirmar que as variáveis cobrem todas as decisões necessárias para alcançar o objetivo."
                                  ],
                                  "verification": "Criar uma lista numerada de variáveis com suas definições e unidades, revisando se atendem ao objetivo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado ou planilha",
                                    "Enunciado do problema"
                                  ],
                                  "tips": [
                                    "Use subscritos para clareza (x₁, x₂); evite nomes longos.",
                                    "Pergunte: 'O que eu controlo?' para identificar variáveis."
                                  ],
                                  "learningObjective": "Selecionar e notate corretamente as variáveis de decisão relevantes para o problema.",
                                  "commonMistakes": [
                                    "Definir variáveis redundantes ou insuficientes.",
                                    "Esquecer unidades ou não-negatividade.",
                                    "Confundir variáveis com constantes do problema."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar os coeficientes da função objetivo",
                                  "subSteps": [
                                    "Para cada variável de decisão, localizar ou calcular o coeficiente no contexto do objetivo (ex: lucro por unidade de x₁).",
                                    "Extrair valores numéricos diretamente do enunciado ou computar combinações simples (ex: preço venda - custo).",
                                    "Verificar consistência de unidades entre coeficientes e variáveis (ex: todos em R$/m³).",
                                    "Criar uma tabela com colunas: Variável | Coeficiente | Descrição (ex: x₁ | 10 | Lucro por m³).",
                                    "Somar mentalmente ou anotar a contribuição esperada de cada termo para validar."
                                  ],
                                  "verification": "Tabela completa de coeficientes com cálculos mostrados e unidades consistentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel para tabela",
                                    "Calculadora",
                                    "Enunciado"
                                  ],
                                  "tips": [
                                    "Coeficientes são sempre lineares; procure 'por unidade' no texto.",
                                    "Use cores para diferenciar max (+) de min (-)."
                                  ],
                                  "learningObjective": "Extrair e validar coeficientes precisos derivados dos dados do problema.",
                                  "commonMistakes": [
                                    "Usar coeficientes de restrições no objetivo.",
                                    "Erros de sinal (positivo para lucro, negativo para custo em min).",
                                    "Inconsistência de unidades."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever a função objetivo linear formal",
                                  "subSteps": [
                                    "Montar a expressão: Z = c₁x₁ + c₂x₂ + ... + cₙxₙ, substituindo os coeficientes reais.",
                                    "Especificar claramente se é 'Maximizar Z' ou 'Minimizar Z'.",
                                    "Verificar a sintaxe matemática: somatórios corretos, sem expoentes ou produtos entre variáveis.",
                                    "Substituir valores numéricos nos coeficientes conforme o problema.",
                                    "Ler em voz alta e comparar com o objetivo original para confirmação final."
                                  ],
                                  "verification": "Função objetivo escrita em formato matemático padrão, testada com valores hipotéticos simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor LaTeX ou papel para equação",
                                    "Exemplo resolvido de referência"
                                  ],
                                  "tips": [
                                    "Use Σ se múltiplas variáveis; prefira expansão explícita para clareza inicial.",
                                    "Sempre inclua 'Max Z =' ou 'Min Z ='."
                                  ],
                                  "learningObjective": "Construir a expressão linear precisa da função objetivo pronta para o modelo de PL.",
                                  "commonMistakes": [
                                    "Escrever termos quadráticos ou não-lineares acidentalmente.",
                                    "Esquecer o sinal max/min.",
                                    "Omitir variáveis definidas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma obra de engenharia civil, maximizar o lucro de produção de concreto: x₁ (m³ de concreto comum, lucro R$10/m³) + x₂ (m³ de concreto reforçado, lucro R$15/m³). Função: Maximizar Z = 10x₁ + 15x₂.",
                              "finalVerifications": [
                                "Identificar corretamente se é maximização ou minimização com base no enunciado.",
                                "Definir todas as variáveis de decisão com definições claras e unidades.",
                                "Coeficientes extraídos ou calculados precisamente dos dados fornecidos.",
                                "Expressão matemática linear sem erros de sintaxe ou sinal.",
                                "Função alinhada perfeitamente com o objetivo descrito no problema.",
                                "Teste com valores numéricos simples produz resultados lógicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do objetivo (max/min) e variáveis (100% corretas).",
                                "Clareza e consistência na notação matemática e unidades.",
                                "Correção dos coeficientes com cálculos mostrados quando necessário.",
                                "Completude: todos elementos do problema incorporados na função.",
                                "Capacidade de validar a função com exemplos numéricos simples.",
                                "Eficiência no processo: tempo dentro do estimado e sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e funções lineares.",
                                "Economia: Análise de custo-benefício e otimização de recursos.",
                                "Engenharia de Produção: Planejamento de mix de produtos.",
                                "Gestão de Projetos: Alocação eficiente de recursos em obras civis.",
                                "Estatística: Modelagem preditiva básica para coeficientes."
                              ],
                              "realWorldApplication": "Na engenharia civil, formular a função objetivo para minimizar o custo total de materiais em uma ponte, como Z = 50x₁ + 80x₂ (x₁=toneladas de aço, x₂=toneladas de concreto), permitindo otimizar orçamentos e prazos de obras reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Definir restrições lineares",
                            "description": "Estabelecer restrições de desigualdade ou igualdade lineares representando limitações físicas, como disponibilidade de materiais, mão de obra ou normas técnicas em projetos civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de restrições lineares em programação linear",
                                  "subSteps": [
                                    "Estude a definição de restrições lineares como desigualdades ou igualdades do tipo ax + by ≤ c, onde a, b, c são constantes e x, y variáveis de decisão.",
                                    "Revise exemplos básicos de restrições em contextos civis, como limite de cimento disponível: 2x + y ≤ 1000 kg.",
                                    "Diferencie restrições de igualdade (ex: proporção exata de mistura) de desigualdade (ex: máximo de mão de obra).",
                                    "Analise como restrições definem o espaço viável no plano cartesiano.",
                                    "Pratique plotando uma restrição simples em um gráfico."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é uma restrição linear e dê um exemplo correto de um contexto civil.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de otimização, papel quadriculado, calculadora, vídeo tutorial sobre programação linear.",
                                  "tips": "Use analogias cotidianas, como orçamento familiar, para fixar o conceito.",
                                  "learningObjective": "Identificar e classificar restrições lineares como fundamentais para delimitar soluções factíveis em problemas de otimização.",
                                  "commonMistakes": "Confundir variáveis de decisão com constantes; ignorar o sinal de desigualdade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar limitações físicas em um problema de engenharia civil",
                                  "subSteps": [
                                    "Leia o enunciado do problema e liste recursos limitados: materiais (cimento, aço), mão de obra (horas-homem), normas técnicas (resistência mínima).",
                                    "Classifique limitações em tipos: disponibilidade (≤), exigências mínimas (≥), exatas (=).",
                                    "Quantifique cada limitação com dados numéricos do problema.",
                                    "Mapeie variáveis de decisão relevantes (ex: x = metros de concreto, y = toneladas de aço).",
                                    "Crie uma tabela relacionando limitações a variáveis."
                                  ],
                                  "verification": "Produza uma tabela completa com pelo menos 4 limitações identificadas e classificadas corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Enunciado de problema exemplo, planilha Excel para tabela, normas técnicas ABNT (ex: NBR 6118).",
                                  "tips": "Sempre pergunte: 'O que impede soluções ilimitadas?' para encontrar restrições.",
                                  "learningObjective": "Extrair e categorizar restrições reais de cenários de engenharia civil.",
                                  "commonMistakes": "Omitir restrições implícitas como normas de segurança; superestimar recursos disponíveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular restrições matemáticas lineares",
                                  "subSteps": [
                                    "Para cada limitação, escreva a expressão linear: coeficientes × variáveis ± constante ≤/≥/= valor limite.",
                                    "Verifique linearidade: apenas somas, produtos constantes×variáveis, sem potências ou produtos variáveis×variáveis.",
                                    "Inclua sinal do lado direito (normalmente ≥0 para não-negatividade).",
                                    "Escreva todas as restrições em um conjunto coeso.",
                                    "Teste com valores de exemplo para validar sentido da desigualdade."
                                  ],
                                  "verification": "Escreva 4-6 restrições lineares corretas para o problema analisado, sem erros de sinal ou coeficientes.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Papel para rascunhos, software como GeoGebra ou MATLAB para plotar, exemplos resolvidos.",
                                  "tips": "Comece com unidades: garanta que lados da desigualdade tenham mesmas unidades (ex: kg, horas).",
                                  "learningObjective": "Traduzir limitações qualitativas em equações lineares precisas e viáveis.",
                                  "commonMistakes": "Esquecer não-negatividade (x ≥ 0, y ≥ 0); inverter sinais de desigualdade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar as restrições formuladas",
                                  "subSteps": [
                                    "Substitua valores extremos nas restrições para checar se definem espaço viável não-vazio.",
                                    "Compare com o problema original: todas limitações cobertas? Nenhuma redundante?",
                                    "Ajuste se necessário (ex: adicionar folga para desigualdades não-vinculantes).",
                                    "Plote o sistema de restrições para visualizar a região factível.",
                                    "Discuta com pares ou tutor para feedback."
                                  ],
                                  "verification": "Gere um gráfico da região viável e confirme que atende todas limitações do problema.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de graficação (Desmos, Excel), impressora para gráficos.",
                                  "tips": "Se região viável vazia, relaxe restrições ou revise coeficientes.",
                                  "learningObjective": "Garantir que restrições sejam consistentes, completas e representem fielmente o problema real.",
                                  "commonMistakes": "Ignorar interseções que violam outras restrições; criar restrições redundantes."
                                }
                              ],
                              "practicalExample": "Em um projeto de fundação: x = m³ de concreto tipo A (custa 200 kg cimento/m³), y = m³ tipo B (150 kg/m³). Limitações: 5000 kg cimento disponível (200x + 150y ≤ 5000), 100 horas mão de obra (10x + 8y ≤ 100), mínimo 20 m³ concreto (x + y ≥ 20), x ≥ 0, y ≥ 0.",
                              "finalVerifications": [
                                "Todas limitações do problema estão representadas por restrições lineares?",
                                "Região viável é não-vazia e limitada?",
                                "Sinais de desigualdades estão corretos (testados com pontos extremos)?",
                                "Unidades e coeficientes batem com dados reais?",
                                "Restrições de não-negatividade incluídas?",
                                "Nenhuma restrição não-linear introduzida?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pelo menos 80% das limitações relevantes (nota 0-20).",
                                "Correção matemática em todas restrições lineares (nota 0-30).",
                                "Linearidade e ausência de erros comuns (nota 0-20).",
                                "Validação via gráfico ou testes numéricos (nota 0-15).",
                                "Completude: cobre normas técnicas e recursos (nota 0-15)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e geometria analítica para plotar restrições.",
                                "Economia: Alocação eficiente de recursos escassos em projetos.",
                                "Gestão de Projetos: Planejamento de recursos em cronogramas civis.",
                                "Física: Limitações materiais baseadas em propriedades mecânicas."
                              ],
                              "realWorldApplication": "Na construção de uma ponte, definir restrições como 'aço disponível ≤ 50 toneladas' (5x + 3y ≤ 50, x=metros vigas, y=metros cabos) e 'resistência mínima ≥ 100 MPa' garante otimização de custos sem comprometer segurança, usado em softwares como LINGO ou CPLEX."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.1.4",
                            "name": "Converter para forma padrão",
                            "description": "Transformar o problema em forma padrão introduzindo variáveis de folga, excedente e artificiais, preparando-o para o método simplex, incluindo verificação de viabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o problema original de programação linear",
                                  "subSteps": [
                                    "Identifique o objetivo (maximização ou minimização) e as variáveis de decisão.",
                                    "Liste todas as restrições funcionais, classificando-as como ≤, ≥ ou =.",
                                    "Anote as restrições de não-negatividade (x ≥ 0).",
                                    "Verifique se o vetor b (lado direito das restrições) contém apenas valores não-negativos.",
                                    "Registre o problema em sua forma original para referência."
                                  ],
                                  "verification": "Crie um resumo escrito do problema com objetivo, variáveis, restrições e sinalizações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplo de problema de PL"
                                  ],
                                  "tips": [
                                    "Comece pelo objetivo para contextualizar.",
                                    "Classifique restrições por tipo para facilitar a conversão.",
                                    "Desenhe um fluxograma simples do problema."
                                  ],
                                  "learningObjective": "Compreender a estrutura completa do problema antes da padronização.",
                                  "commonMistakes": [
                                    "Ignorar restrições de não-negatividade.",
                                    "Confundir maximização com minimização sem converter.",
                                    "Não verificar se b ≥ 0."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Padronizar o objetivo e converter para maximização",
                                  "subSteps": [
                                    "Se o objetivo for minimização, multiplique por -1 para transformá-lo em maximização (z' = -z).",
                                    "Escreva o objetivo na forma padrão: max c^T x, onde x inclui apenas variáveis de decisão originais.",
                                    "Confirme que todas as variáveis estão com coeficientes corretos.",
                                    "Atualize o problema com o novo objetivo.",
                                    "Verifique algebraicamente se a transformação preserva a solução ótima."
                                  ],
                                  "verification": "O objetivo está escrito como 'max c x' com todos x ≥ 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy",
                                    "Folha de exercícios"
                                  ],
                                  "tips": [
                                    "Lembre-se: min z = max -z.",
                                    "Teste com valores simples para validar.",
                                    "Mantenha traço da transformação original."
                                  ],
                                  "learningObjective": "Dominar a conversão de objetivos para forma padrão simplex.",
                                  "commonMistakes": [
                                    "Esquecer de inverter o sinal ao converter minimização.",
                                    "Incluir variáveis auxiliares prematuramente no objetivo.",
                                    "Erros aritméticos nos coeficientes."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir variáveis de folga, excedente e artificiais nas restrições",
                                  "subSteps": [
                                    "Para restrições ≤: adicione variável de folga s ≥ 0 (ex: ax ≤ b → ax + s = b).",
                                    "Para restrições ≥: adicione variável excedente s ≥ 0 e artificial a ≥ 0 (ex: ax ≥ b → ax - s + a = b).",
                                    "Para restrições =: adicione apenas artificial a ≥ 0 (ex: ax = b → ax + a = b).",
                                    "Garanta que o vetor b seja ≥ 0; se não, multiplique a restrição por -1 e ajuste variáveis.",
                                    "Escreva o sistema completo de igualdades: A x = b, com todas variáveis ≥ 0."
                                  ],
                                  "verification": "Todas restrições são igualdades com variáveis auxiliares corretas e b ≥ 0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou software como MATLAB/Python (SciPy)",
                                    "Tabela de conversão de restrições"
                                  ],
                                  "tips": [
                                    "Use convenções: s para folga, e para excedente, a para artificial.",
                                    "Artificiais só para ≥ ou = na fase 1.",
                                    "Verifique balanceamento: esquerda = direita."
                                  ],
                                  "learningObjective": "Aplicar corretamente variáveis auxiliares para igualar restrições.",
                                  "commonMistakes": [
                                    "Usar folga em ≥ (deve ser excedente).",
                                    "Esquecer artificial em =.",
                                    "Não ajustar b negativo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar viabilidade e preparar para o método simplex",
                                  "subSteps": [
                                    "Confirme que o problema está em forma padrão: max c x, Ax = b, x ≥ 0, b ≥ 0.",
                                    "Para problemas com artificiais, prepare a função objetivo da Fase 1: min w = soma de artificiais.",
                                    "Selecione variáveis básicas iniciais (folgas/excedentes como identidade).",
                                    "Teste viabilidade básica: verifique se existe base viável inicial.",
                                    "Documente o tableau inicial pronto para simplex."
                                  ],
                                  "verification": "Gere o tableau simplex inicial e confirme ausência de artificiais na solução básica ótima da Fase 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de PL como GLPK ou Python PuLP",
                                    "Modelo de tableau simplex"
                                  ],
                                  "tips": [
                                    "Se w* > 0 na Fase 1, problema infactível.",
                                    "Use pivotagem manual para teste rápido.",
                                    "Salve versões intermediárias."
                                  ],
                                  "learningObjective": "Validar a forma padrão e detectar inviabilidade precoce.",
                                  "commonMistakes": [
                                    "Assumir viabilidade sem Fase 1.",
                                    "Erro no tableau inicial.",
                                    "Ignorar b < 0 após ajustes."
                                  ]
                                }
                              ],
                              "practicalExample": "Problema: Max z = 3x + 4y s.t. x + y ≤ 5, 2x + y ≥ 6, x,y ≥ 0. Conversão: Max z = 3x + 4y; x + y + s1 = 5; 2x + y - s2 + a = 6 (s1,s2,a ≥ 0). Fase 1: Min w = a, com tableau inicial verificando viabilidade (infactível pois Fase 1 w*>0).",
                              "finalVerifications": [
                                "Todas restrições convertidas para Ax = b com x ≥ 0, b ≥ 0.",
                                "Variáveis de folga/excedente/artificiais introduzidas corretamente por tipo.",
                                "Objetivo padronizado para maximização.",
                                "Viabilidade básica confirmada ou Fase 1 preparada.",
                                "Tableau inicial gerado sem erros aritméticos.",
                                "Traçado completo da transformação documentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação e conversão de restrições (30%).",
                                "Correta introdução e sinalização de variáveis auxiliares (25%).",
                                "Validação de forma padrão e viabilidade (20%).",
                                "Clareza na documentação e tableau final (15%).",
                                "Eficiência no tempo e ausência de erros comuns (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Manipulação de matrizes A e vetores b.",
                                "Programação Computacional: Implementação em Python (SciPy.optimize.linprog).",
                                "Gestão de Projetos: Otimização de recursos em engenharia.",
                                "Economia: Modelagem de custos e restrições orçamentárias."
                              ],
                              "realWorldApplication": "Em engenharia civil, otimizar alocação de materiais em obras (ex: minimizar custo de concreto e aço sujeito a restrições de carga e volume), convertendo para simplex em softwares como LINGO para soluções eficientes em projetos de pontes ou edifícios."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.2",
                              "10.1.5.1.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Método Simplex",
                        "description": "Algoritmo iterativo para resolução de problemas de programação linear na forma padrão, envolvendo tabela simplex, seleção de pivô e atualizações até atingir a solução ótima.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Construir a tabela simplex inicial",
                            "description": "Montar a tabela inicial do método simplex a partir do problema em forma padrão, identificando a base inicial factível e os coeficientes da função objetivo e restrições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Converter o problema para forma padrão",
                                  "subSteps": [
                                    "Identifique a função objetivo e confirme se é de maximização (se minimização, multiplique por -1)",
                                    "Escreva todas as restrições na forma padrão (≤, = ou ≥ convertidas adequadamente)",
                                    "Adicione variáveis não-negativas (x_i ≥ 0) se não especificadas",
                                    "Verifique se o problema está em forma padrão: max Z, restrições ≤ com b ≥ 0",
                                    "Anote os coeficientes de cada variável na função objetivo e restrições"
                                  ],
                                  "verification": "Confirme que todas restrições são ≤ com lado direito não-negativo e função é maximização",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Problema de programação linear escrito",
                                    "Papel e caneta ou planilha Excel"
                                  ],
                                  "tips": "Sempre priorize maximização; para minimização, transforme em max -Z",
                                  "learningObjective": "Entender e aplicar a padronização necessária para o simplex",
                                  "commonMistakes": [
                                    "Esquecer de inverter o sinal em minimização",
                                    "Deixar restrições ≥ sem conversão",
                                    "Ignorar variáveis não-negativas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir variáveis de folga e artificiais",
                                  "subSteps": [
                                    "Para cada restrição ≤, adicione uma variável de folga s_i ≥ 0 para torná-la =",
                                    "Para restrições =, não adicione folga; para ≥, adicione variável artificial a_i ≥ 0 e folga -s_i",
                                    "Ajuste a função objetivo: para folgas, coeficiente 0; para artificiais, use método Big-M ou duas fases",
                                    "Liste todas as variáveis básicas iniciais (folgas para ≤ básicas em 1)",
                                    "Escreva o sistema completo em forma matricial"
                                  ],
                                  "verification": "O sistema agora tem m equações = com m variáveis básicas factíveis (folgas = b_i)",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de cálculo com coeficientes originais",
                                    "Calculadora para somas iniciais"
                                  ],
                                  "tips": "Variáveis de folga nunca entram na função objetivo; artificiais penalizam a base inicial",
                                  "learningObjective": "Dominar a introdução de variáveis auxiliares para base factível inicial",
                                  "commonMistakes": [
                                    "Adicionar folga em restrição = ou ≥ incorretamente",
                                    "Esquecer sinal negativo em folga para ≥",
                                    "Não penalizar artificiais na Z"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a base inicial e coeficientes da tabela",
                                  "subSteps": [
                                    "Identifique a base B: colunas das variáveis básicas (identidade para folgas)",
                                    "Calcule CB (vetor de custos básicos: coeficientes Z das básicas, geralmente 0 para folgas)",
                                    "Preencha ZB = CB * b (inicialmente 0 para folgas)",
                                    "Para cada coluna j não-básica: cj - Zj, onde Zj = CB * A_j (A_j coluna de restrições)",
                                    "Calcule o vetor custo-reduzido para função objetivo"
                                  ],
                                  "verification": "Verifique se ZB inicial = 0 e base é identidade unitária",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz de coeficientes anotada",
                                    "Software como MATLAB ou Python (opcional para verificação)"
                                  ],
                                  "tips": "Use propriedades da matriz identidade para simplificar cálculos iniciais",
                                  "learningObjective": "Calcular corretamente os custos reduzidos e identificar base factível",
                                  "commonMistakes": [
                                    "Erro em multiplicação CB * A_j",
                                    "Confundir CB com cj",
                                    "Não zerar ZB para folgas puras"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e formatar a tabela simplex inicial",
                                  "subSteps": [
                                    "Desenhe a tabela: linhas para Z e restrições; colunas para básicas, variáveis, RHS",
                                    "Preencha coeficientes: função Z na primeira linha, restrições abaixo",
                                    "Insira valores básicos na coluna básica, b no RHS, custos reduzidos na linha Z",
                                    "Destaque a base inicial factível (valores b ≥ 0)",
                                    "Revise a tabela para consistência (soma ponderada das restrições dá Z)"
                                  ],
                                  "verification": "Simule uma iteração: coluna pivot com custo reduzido negativo existe se não ótimo",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou papel quadriculado",
                                    "Exemplo resolvido de referência"
                                  ],
                                  "tips": "Formate com linhas grossas para separar Z das restrições",
                                  "learningObjective": "Construir visualmente a tabela pronta para iterações simplex",
                                  "commonMistakes": [
                                    "Posição errada de RHS ou básicos",
                                    "Sinais invertidos em custos reduzidos",
                                    "Esquecer linha de ZB"
                                  ]
                                }
                              ],
                              "practicalExample": "Problema: Max Z = 3x1 + 5x2 s.a. 1x1 + 2x2 ≤ 4, 2x1 + 1x2 ≤ 5, x1,x2 ≥ 0. Introduza s1,s2: equações = com b=[4,5]. Base: s1=4, s2=5. Tabela inicial: Linha Z: básicos [0,0], x1[-3,-2], x2[-5,-1], RHS[0]. Restrições: [1,0,1,0,4]; [0,2,0,1,5].",
                              "finalVerifications": [
                                "Base inicial é factível (todos b ≥ 0)",
                                "Matriz básica é identidade unitária",
                                "Custos reduzidos calculados corretamente (cj - Zj)",
                                "Função objetivo ZB = 0 para folgas puras",
                                "Todas colunas não-básicas têm coeficientes corretos das restrições",
                                "Tabela balanceada: soma CB * restrições = linha Z"
                              ],
                              "assessmentCriteria": [
                                "Precisão na padronização do problema (100%)",
                                "Correta introdução e identificação de variáveis auxiliares",
                                "Cálculos exatos de Zj e custos reduzidos sem erros aritméticos",
                                "Formatação clara e completa da tabela",
                                "Explicação coerente da base inicial factível",
                                "Detecção de inconsistências na verificação final"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Manipulação de matrizes e vetores (B^-1, multiplicações)",
                                "Programação Computacional: Implementação em Python (SciPy.linprog) ou Excel Solver",
                                "Engenharia Civil: Otimização de mix de concreto ou alocação de mão-de-obra",
                                "Estatística: Sensibilidade e análise de dual",
                                "Economia: Modelagem de recursos limitados em projetos"
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usado para otimizar alocação de recursos em obras, como minimizar custos de mistura de concreto sob restrições de resistência e disponibilidade de materiais, gerando a tabela inicial para software de otimização como LINGO ou CPLEX."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.4"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Executar iterações de pivotagem",
                            "description": "Aplicar as regras de seleção de coluna de entrada (critério de redução) e linha de saída (mínimo positivo), realizando operações gaussianas para pivotar e atualizar a tabela simplex.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar Critério de Redução para Selecionar Coluna de Entrada",
                                  "subSteps": [
                                    "Examine a linha da função objetivo (linha Z) na tabela simplex.",
                                    "Identifique todos os coeficientes cj - zj que são negativos.",
                                    "Selecione a coluna de entrada correspondente ao coeficiente mais negativo (critério de Bland se empate).",
                                    "Marque a coluna selecionada como 'entrante'.",
                                    "Registre o nome da variável básica que entrará na base."
                                  ],
                                  "verification": "Confirme que o coeficiente selecionado é o mais negativo na linha Z e que a coluna está marcada corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela simplex impressa ou digital, lápis e papel para anotações, calculadora.",
                                  "tips": "Sempre comece pela linha Z; ignore colunas com coeficientes zero ou positivos.",
                                  "learningObjective": "Dominar a identificação precisa da variável entrante para maximizar a melhoria na função objetivo.",
                                  "commonMistakes": "Escolher coeficiente negativo menos negativo; esquecer de verificar empates."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Teste de Mínimo Positivo para Selecionar Linha de Saída",
                                  "subSteps": [
                                    "Na coluna de entrada selecionada, identifique elementos a_ij > 0 nas linhas de restrições.",
                                    "Para cada a_ij > 0, calcule a razão b_i / a_ij, onde b_i é o termo independente.",
                                    "Selecione a linha com a menor razão positiva (mínimo positivo; use Bland se empate).",
                                    "Marque essa linha como 'saínte' e identifique o elemento pivô (interseção).",
                                    "Verifique se há razões zero ou indefinidas e ignore-as."
                                  ],
                                  "verification": "Liste todas as razões calculadas e confirme que a menor positiva foi escolhida corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela simplex, calculadora para divisões precisas, régua para alinhar colunas.",
                                  "tips": "Só considere a_ij > 0; divida com precisão para evitar erros de arredondamento.",
                                  "learningObjective": "Aprender a determinar a variável saínte para evitar soluções inviáveis.",
                                  "commonMistakes": "Incluir a_ij ≤ 0 nas razões; escolher razão negativa ou zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Normalizar a Linha Pivô para Tornar o Elemento Pivô Igual a 1",
                                  "subSteps": [
                                    "Identifique o elemento pivô na interseção da coluna e linha selecionadas.",
                                    "Divida todos os elementos da linha pivô pelo valor do pivô.",
                                    "Confirme que o pivô agora é 1.000.",
                                    "Atualize o termo b_i da linha pivô com o novo valor.",
                                    "Rotule a nova variável básica na linha pivô."
                                  ],
                                  "verification": "Verifique se todos os elementos da linha pivô foram divididos corretamente e o pivô é 1.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Tabela simplex, calculadora para divisões exatas.",
                                  "tips": "Trabalhe com frações exatas se possível para precisão.",
                                  "learningObjective": "Executar a primeira operação gaussiana para padronizar a base.",
                                  "commonMistakes": "Dividir apenas o pivô, esquecendo o resto da linha; erros aritméticos em divisões."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Eliminar o Pivô nas Outras Linhas e Atualizar a Tabela",
                                  "subSteps": [
                                    "Para cada linha não-pivô (incluindo Z), use eliminação gaussiana: nova_linha = linha - (coef * linha_pivô).",
                                    "Calcule o multiplicador como o elemento na coluna pivô daquela linha.",
                                    "Subtraia para zerar todos os elementos na coluna pivô, exceto o pivô.",
                                    "Atualize a linha Z subtraindo (cj-zj_pivô * linha_pivô).",
                                    "Verifique que a nova tabela tem zeros na coluna entrante, exceto 1 no pivô."
                                  ],
                                  "verification": "Confirme zeros em toda a coluna pivô (exceto 1) e valores atualizados corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela simplex em planilha ou papel quadriculado, calculadora científica.",
                                  "tips": "Faça uma cópia da tabela original antes de alterar para comparar.",
                                  "learningObjective": "Realizar operações elementares para transformar a base simplex.",
                                  "commonMistakes": "Esquecer de atualizar a linha Z; multiplicadores errados levando a não-zeros."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar Otimalidade e Preparar Próxima Iteração",
                                  "subSteps": [
                                    "Examine a nova linha Z: se todos cj - zj ≥ 0, solução ótima alcançada.",
                                    "Se houver negativos, prepare para nova iteração marcando a tabela atual.",
                                    "Calcule valores básicos atuais (coluna b).",
                                    "Registre iterações realizadas e solução corrente.",
                                    "Salve a tabela para análise posterior."
                                  ],
                                  "verification": "Lista de cj - zj na Z todos não-negativos OU nova coluna entrante identificada corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Tabela atualizada, software de otimização para validação opcional.",
                                  "tips": "Conte iterações para evitar loops infinitos em problemas degenerados.",
                                  "learningObjective": "Avaliar convergência do algoritmo simplex.",
                                  "commonMistakes": "Parar prematuramente com negativos na Z; ignorar degenerescência."
                                }
                              ],
                              "practicalExample": "Considere o problema: Max Z = 3x1 + 5x2, s.a. 1x1 + 2x2 ≤ 6, 2x1 + 1x2 ≤ 8, x≥0. Tableau inicial: coluna entrante x1 (c-z=-3), linha saínte 1 (razão 6/1=6 vs 8/2=4, min=4). Pivô=2. Após pivotagem: nova Z com c-z x2=-1.5 (não ótima), solução básica x2=2, x1=2, Z=16. Repita para otimalidade.",
                              "finalVerifications": [
                                "Todos os coeficientes na linha Z são não-negativos.",
                                "Coluna de variáveis básicas tem identidades unitárias.",
                                "Valores em b são não-negativos (solução factível).",
                                "Cálculos de pivotagem sem erros aritméticos (verificados manualmente).",
                                "Solução básica atual corresponde aos valores em b.",
                                "Iteração melhora Z (verificar incremento)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção de coluna/linha pivô (100% correto).",
                                "Cálculos gaussianos exatos sem erros de sinal ou arredondamento.",
                                "Tabela final válida e factível.",
                                "Explicação clara do processo em 1-2 parágrafos.",
                                "Tempo de execução eficiente (dentro do estimado).",
                                "Identificação correta de otimalidade."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Operações gaussianas e eliminação.",
                                "Programação Computacional: Implementação em Python (SciPy.linprog) ou Excel Solver.",
                                "Engenharia Civil: Otimização de custos em estruturas e recursos hídricos.",
                                "Estatística: Sensibilidade e análise pós-otimalidade."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usado para otimizar alocação de materiais em projetos de construção, como minimizar custos de concreto e aço sob restrições de resistência e orçamento, garantindo eficiência em canteiros de obra."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Identificar condições de optimalidade",
                            "description": "Verificar critérios de parada: todos os coeficientes da função objetivo não-negativos para maximização, detectar soluções ilimitadas, inviáveis ou degenerescência na tabela simplex.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e compreender a estrutura da tabela simplex atual",
                                  "subSteps": [
                                    "Localize a linha da função objetivo (Z-row) na tabela simplex.",
                                    "Identifique as colunas das variáveis não básicas e suas respectivas coeficientes reduzidos (c_j - z_j).",
                                    "Confirme as variáveis básicas e seu status (básicas ou não básicas).",
                                    "Verifique se a tabela está na forma padrão do método simplex tabular.",
                                    "Anote o valor atual da função objetivo Z."
                                  ],
                                  "verification": "A tabela é corretamente identificada com todas as linhas e colunas rotuladas, e o valor Z está calculado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela simplex impressa ou em software como Excel/LINGO, calculadora.",
                                  "tips": "Sempre comece pela linha Z; ela é o coração da análise de optimalidade.",
                                  "learningObjective": "Compreender a estrutura da tabela para análise posterior.",
                                  "commonMistakes": "Confundir linha Z com restrições ou ignorar variáveis de folga."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar critérios de optimalidade para maximização",
                                  "subSteps": [
                                    "Examine todos os coeficientes na linha Z para variáveis não básicas.",
                                    "Confirme se todos os coeficientes (c_j - z_j) são não-negativos (≥ 0).",
                                    "Se todos forem ≥ 0, declare a solução ótima.",
                                    "Registre o valor ótimo de Z e as variáveis básicas.",
                                    "Teste sensibilidade alterando ligeiramente um coeficiente para validar."
                                  ],
                                  "verification": "Lista de coeficientes Z extraída e todos confirmados ≥ 0, com declaração explícita de optimalidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela simplex, lápis e papel para anotações.",
                                  "tips": "Para minimização, inverta o sinal: verifique coeficientes não-positivos.",
                                  "learningObjective": "Aplicar o critério principal de parada para problemas de maximização.",
                                  "commonMistakes": "Esquecer variáveis artificiais ou confundir maximização com minimização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar soluções ilimitadas (unbounded)",
                                  "subSteps": [
                                    "Identifique colunas com coeficiente Z negativo (para maximização) e sem restrição limitante.",
                                    "Verifique se na coluna há apenas entradas ≥ 0 nas restrições (sem linha de pivô possível).",
                                    "Confirme ausência de coeficientes negativos nas restrições dessa coluna.",
                                    "Declare solução ilimitada se Z negativo e coluna 'ilimitada'.",
                                    "Explique implicações: Z → ∞."
                                  ],
                                  "verification": "Coluna específica identificada com Z < 0 e todas entradas restrições ≥ 0, declaração de unboundedness.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela simplex destacando a coluna suspeita.",
                                  "tips": "Procure por 'colunas de escape' sem barreiras inferiores.",
                                  "learningObjective": "Reconhecer padrões de soluções não finitas.",
                                  "commonMistakes": "Ignorar colunas com Z positivo ou confundir com inviabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar inviabilidade e degenerescência",
                                  "subSteps": [
                                    "Cheque a coluna da variável artificial: se coeficiente Z > 0 após fase II, solução inviável.",
                                    "Verifique valores básicos: se algum b_i < 0, potencial inviabilidade.",
                                    "Para degenerescência: múltiplas variáveis básicas zero na mesma iteração ou ciclo sem progresso.",
                                    "Confirme ciclos: iterações repetidas sem mudança em Z.",
                                    "Declare status: inviável, degenerado ou ótimo."
                                  ],
                                  "verification": "Relatório final com status (ótimo/inviável/degenerado/ilimitado) e evidências da tabela.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela simplex com histórico de iterações.",
                                  "tips": "Use fase I para eliminar artificiais antes da fase II.",
                                  "learningObjective": "Diferenciar condições patológicas da optimalidade.",
                                  "commonMistakes": "Confundir degenerescência com optimalidade ou ignorar artificiais."
                                }
                              ],
                              "practicalExample": "Considere o problema: Max Z = 3x1 + 5x2, s.a. x1 + x2 ≤ 4, 2x1 + x2 ≤ 5, x1,x2 ≥ 0. Na tabela final: linha Z com coeficientes [0, 0, 2, 1] para não básicas. Todos ≥0 → ótima. Se coluna x3 (não básica) tivesse Z=-1 e restrições [1,2] (todas >0) → ilimitada.",
                              "finalVerifications": [
                                "Todos coeficientes Z ≥ 0 para maximização.",
                                "Nenhuma coluna com Z < 0 e restrições todas ≥ 0.",
                                "Variáveis artificiais eliminadas (Z_art = 0).",
                                "Nenhum valor básico negativo persistente.",
                                "Ausência de ciclos ou degenerescência (Z não oscila).",
                                "Valor Z final consistente com solução básica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos coeficientes Z.",
                                "Correta detecção de padrões ilimitados/inviáveis.",
                                "Explicação clara de degenerescência com exemplos.",
                                "Uso correto de terminologia simplex.",
                                "Análise completa sem omissões em tabela fornecida.",
                                "Tempo de resolução eficiente e lógica passo a passo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes e sistemas lineares).",
                                "Programação: Implementação em Python (biblioteca PuLP ou SciPy.optimize).",
                                "Estatística: Otimização em regressão e análise de dados.",
                                "Engenharia Civil: Alocação de recursos em projetos de construção."
                              ],
                              "realWorldApplication": "Na engenharia civil, otimizar mistura de concreto (maximizar resistência com custos mínimos) usando simplex; detectar ilimitadas evita superestimar recursos, inviáveis sinaliza restrições impossíveis como prazos irreais em obras."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.4",
                            "name": "Interpretar a solução ótima",
                            "description": "Extrair valores das variáveis básicas e não-básicas da tabela final, calcular o valor ótimo da função objetivo e analisar sensibilidade básica em contextos de Engenharia Civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar variáveis básicas e não básicas na tabela final do Simplex",
                                  "subSteps": [
                                    "Localize a tabela final do método Simplex após as iterações.",
                                    "Identifique a coluna 'Base' ou as linhas que indicam as variáveis básicas (aquelas com coeficiente 1 na coluna da identidade).",
                                    "Liste as variáveis não básicas (aquelas com coeficiente 0 na base final).",
                                    "Registre os valores das variáveis básicas na coluna de solução básica (b).",
                                    "Confirme que o vetor solução é factível (todos valores não negativos)."
                                  ],
                                  "verification": "Verifique se a lista de básicas e não básicas corresponde à identidade unitária nas colunas respectivas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela Simplex final impressa ou digital",
                                    "Folha de papel ou Excel",
                                    "Caneta e lápis"
                                  ],
                                  "tips": "Sempre comece pela coluna 'Solução Básica' para evitar confusões com outras colunas.",
                                  "learningObjective": "Compreender a estrutura da base ótima no método Simplex.",
                                  "commonMistakes": [
                                    "Confundir variáveis de folga com variáveis de decisão",
                                    "Ignorar variáveis não básicas como zero"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair valores das variáveis da solução ótima",
                                  "subSteps": [
                                    "Para cada variável básica, leia o valor diretamente da coluna 'b' (solução básica).",
                                    "Atribua valor zero a todas as variáveis não básicas.",
                                    "Escreva o vetor solução completo: x = [x1, x2, ..., xn].",
                                    "Verifique se todos os valores são não negativos (condição de optimalidade primal).",
                                    "Anote as unidades das variáveis no contexto de Engenharia Civil (ex: m³ de concreto)."
                                  ],
                                  "verification": "Compare o vetor solução com a combinação linear das colunas básicas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela Simplex",
                                    "Calculadora",
                                    "Planilha para anotar valores"
                                  ],
                                  "tips": "Use cores diferentes para destacar básicas (verde) e não básicas (vermelho).",
                                  "learningObjective": "Extrair com precisão os valores numéricos da solução ótima.",
                                  "commonMistakes": [
                                    "Ler valores errados da coluna errada",
                                    "Esquecer de zerar não básicas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o valor ótimo da função objetivo",
                                  "subSteps": [
                                    "Identifique os coeficientes da função objetivo Z = c1*x1 + c2*x2 + ... + cn*xn.",
                                    "Substitua os valores do vetor solução nos coeficientes.",
                                    "Realize o cálculo multiplicação e soma.",
                                    "Compare com o valor na linha Z da tabela final para validação.",
                                    "Interprete o valor no contexto: ex: custo mínimo em R$/m³."
                                  ],
                                  "verification": "O valor calculado deve igualar o da linha Z na tabela (test de dualidade).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Coeficientes originais do problema",
                                    "Calculadora",
                                    "Tabela Simplex"
                                  ],
                                  "tips": "Use a fórmula Z = soma (cj * xj) apenas para variáveis básicas.",
                                  "learningObjective": "Calcular e validar o valor ótimo da função objetivo.",
                                  "commonMistakes": [
                                    "Usar coeficientes reduzidos em vez dos originais",
                                    "Erro aritmético em somas grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar sensibilidade básica",
                                  "subSteps": [
                                    "Examine a linha Z reduzida: verifique se todos zj - cj <= 0 (otimalidade).",
                                    "Identifique os ranges de otimalidade para coeficientes básicos (variação permitida).",
                                    "Analise a coluna b para shadow prices (preços sombra das restrições).",
                                    "Discuta impactos: ex: quanto o Z muda se um recurso aumentar em 1 unidade.",
                                    "Relacione com Engenharia Civil: sensibilidade a variações de custo de materiais."
                                  ],
                                  "verification": "Confirme que pequenas variações nos parâmetros mantêm a base ótima.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela Simplex completa",
                                    "Software como Excel Solver ou Lingo",
                                    "Documentação do problema"
                                  ],
                                  "tips": "Use fórmulas de sensibilidade: range = min/max das razões dos elementos da tableau.",
                                  "learningObjective": "Interpretar análises de sensibilidade para robustez da solução.",
                                  "commonMistakes": [
                                    "Confundir preços sombra com custos reduzidos",
                                    "Ignorar limites de range"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de pavimentação rodoviária, otimizar a mistura de asfalto (x1 m³) e brita (x2 m³) para minimizar custo Z = 50x1 + 40x2, s.a. restrições de resistência. Tabela final: básicas x1=10, x2=5 (folga=0); Z=750. Sensibilidade: custo asfalto pode variar ±5 sem mudar base.",
                              "finalVerifications": [
                                "Lista correta de variáveis básicas e valores extraídos.",
                                "Cálculo exato do Z ótimo com validação na tableau.",
                                "Identificação precisa de ranges de sensibilidade.",
                                "Interpretação contextual em Engenharia Civil.",
                                "Verificação de factibilidade e optimalidade.",
                                "Discussão de pelo menos um shadow price relevante."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de valores (100% correto).",
                                "Correção no cálculo de Z (erro <1%).",
                                "Análise de sensibilidade com ranges corretos.",
                                "Clareza na interpretação aplicada ao contexto.",
                                "Completude de todos os elementos (sem omissões).",
                                "Uso adequado de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: análise de riscos em orçamentos.",
                                "Economia de Engenharia: otimização de custos.",
                                "Programação Computacional: uso de solvers como Excel ou Python (PuLP).",
                                "Estatística: análise de sensibilidade e Monte Carlo.",
                                "Matemática Discreta: grafos e fluxos em redes."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, interpretar soluções ótimas do Simplex permite otimizar alocação de recursos em obras como pontes ou barragens, minimizando custos de materiais (cimento, aço) enquanto atende restrições de resistência e prazos, com análise de sensibilidade para variações de mercado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Programação Não-Linear",
                    "description": "Técnicas numéricas para otimizar funções não-lineares, incluindo métodos baseados em gradientes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Fundamentos de Programação Não-Linear",
                        "description": "Conceitos básicos de otimização de funções não-lineares, incluindo problemas não-constritos e constritos, condições de otimalidade e convergência de algoritmos numéricos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Identificar problemas de otimização não-linear",
                            "description": "Reconhecer e formular problemas de otimização onde a função objetivo ou restrições são não-lineares, diferenciando de problemas lineares em contextos de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de otimização linear",
                                  "subSteps": [
                                    "Defina otimização linear (PL): função objetivo e restrições lineares.",
                                    "Liste características principais: soluções em vértices, simplex method.",
                                    "Identifique exemplos em engenharia civil: alocação linear de recursos em obras.",
                                    "Compare com problemas reais que parecem lineares mas não são.",
                                    "Resuma diferenças iniciais em uma tabela."
                                  ],
                                  "verification": "Criar uma tabela comparativa com pelo menos 3 exemplos lineares corretos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Programação Linear (ex: Hillier), planilha Excel"
                                  ],
                                  "tips": "Use gráficos para visualizar regiões factíveis lineares.",
                                  "learningObjective": "Compreender as bases da PL para contrastar com não-linear.",
                                  "commonMistakes": [
                                    "Confundir restrições lineares com funções convexas",
                                    "Ignorar a piecewise linearidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender características da otimização não-linear",
                                  "subSteps": [
                                    "Defina programação não-linear (PNL): função objetivo ou restrições não-lineares.",
                                    "Estude tipos: unimodal, multimodal, convexa vs não-convexa.",
                                    "Aprenda métodos de solução: gradiente, Newton, penalidade.",
                                    "Analise impactos: múltiplos ótimos locais, não-guarante de global.",
                                    "Examine equações não-lineares comuns: quadráticas, exponenciais."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito 3 diferenças chave entre PL e PNL.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB ou Python (SciPy), vídeo-aula sobre PNL"
                                  ],
                                  "tips": "Desenhe curvas de nível para visualizar não-linearidades.",
                                  "learningObjective": "Reconhecer elementos matemáticos que tornam um problema não-linear.",
                                  "commonMistakes": [
                                    "Assumir convexidade sem verificar",
                                    "Confundir não-linearidade com não-convexidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar PNL em contextos de engenharia civil",
                                  "subSteps": [
                                    "Analise problemas civis: dimensionamento de vigas com tensão não-linear.",
                                    "Examine restrições: capacidade de solos com curvas de falha não-lineares.",
                                    "Classifique cenários: otimização de reservatórios com evaporação exponencial.",
                                    "Diferencie de PL: custo de concreto vs volume linear.",
                                    "Crie fluxograma para diagnóstico: linear? → não-linear?"
                                  ],
                                  "verification": "Classificar 5 problemas civis como PL ou PNL com justificativa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigos sobre otimização em estruturas civis, casos de estudo PDF"
                                  ],
                                  "tips": "Procure termos como 'quadrático', 'exponencial' nas formulações.",
                                  "learningObjective": "Aplicar conceitos para detectar PNL em aplicações reais de engenharia civil.",
                                  "commonMistakes": [
                                    "Subestimar não-linearidades em restrições de segurança",
                                    "Classificar erroneamente problemas quadráticos como lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e validar problemas de otimização não-linear",
                                  "subSteps": [
                                    "Escolha um problema civil real e formule: objetivo e restrições.",
                                    "Verifique não-linearidade: derive ou plote funções.",
                                    "Teste sensibilidade: altere parâmetros e observe mudanças não-lineares.",
                                    "Compare com versão linearizada e discuta limitações.",
                                    "Documente em relatório curto com gráficos."
                                  ],
                                  "verification": "Apresentar formulação completa de 1 problema PNL com plot de viabilidade.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python/Jupyter Notebook, bibliotecas NumPy/Matplotlib"
                                  ],
                                  "tips": "Use sympy para verificar derivadas e confirmar não-linearidade.",
                                  "learningObjective": "Formular autonomamente problemas PNL e diferenciá-los.",
                                  "commonMistakes": [
                                    "Linearizar prematuramente sem justificativa",
                                    "Omitir verificação de multimodalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de barragem, otimizar o volume de concreto minimizando custo (função quadrática no raio) sujeito a restrições de estabilidade hidrostática (pressão não-linear com altura^2). Diferente de alocação linear de mão-de-obra.",
                              "finalVerifications": [
                                "Definir corretamente PNL e listar 3 características.",
                                "Diferenciar PL de PNL em 4 exemplos civis.",
                                "Formular um problema PNL completo com justificativa.",
                                "Identificar não-linearidades em funções e restrições dadas.",
                                "Explicar por que um método PL falha em PNL.",
                                "Plotar e interpretar região factível não-linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de não-linearidades (90% acerto).",
                                "Clareza na formulação matemática de problemas.",
                                "Uso correto de terminologia técnica.",
                                "Profundidade na diferenciação PL vs PNL.",
                                "Qualidade de exemplos e visualizações.",
                                "Capacidade de justificar escolhas em contextos civis."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: gradientes e Hessian para análise.",
                                "Programação Computacional: implementação em Python/MATLAB.",
                                "Mecânica dos Solos: modelos constitutivos não-lineares.",
                                "Economia de Engenharia: custos não-lineares em projetos.",
                                "Estatística: otimização estocástica não-linear."
                              ],
                              "realWorldApplication": "No design de fundações de edifícios altos, onde a otimização do diâmetro de estacas considera capacidade portante não-linear do solo, evitando colapsos e otimizando custos em projetos como viadutos urbanos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Entender condições de otimalidade",
                            "description": "Explicar as condições necessárias e suficientes para um ponto ser ótimo em funções não-lineares, utilizando derivadas de primeira e segunda ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar derivadas de primeira e segunda ordem em funções não-lineares",
                                  "subSteps": [
                                    "Estudar a definição de gradiente (derivada de primeira ordem) para funções multivariáveis.",
                                    "Compreender a matriz Hessiana como derivada de segunda ordem.",
                                    "Calcular manualmente o gradiente e a Hessiana para funções simples como f(x) = x² + sin(x).",
                                    "Explorar propriedades da Hessiana: positiva definida, negativa definida e indefinida.",
                                    "Praticar com funções de duas variáveis, como f(x,y) = x² + y²."
                                  ],
                                  "verification": "Calcular corretamente o gradiente e a Hessiana de pelo menos duas funções exemplo e identificar sua definitude.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Caderno e lápis",
                                    "Calculadora científica",
                                    "Software como MATLAB ou Python (NumPy/SciPy)"
                                  ],
                                  "tips": "Use simetria nas funções para simplificar cálculos da Hessiana.",
                                  "learningObjective": "Compreender o papel das derivadas de primeira e segunda ordem na análise de otimalidade.",
                                  "commonMistakes": "Confundir gradiente (vetor) com derivada escalar univariada; ignorar a simetria da Hessiana."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender condições de primeira ordem (FOC) para otimalidade",
                                  "subSteps": [
                                    "Definir condições necessárias de primeira ordem: gradiente igual a zero no ponto candidato.",
                                    "Explicar por que ∇f(x*) = 0 é necessário para mínimo/máximo local.",
                                    "Resolver ∇f(x) = 0 para funções não-lineares univariadas e multivariáveis.",
                                    "Identificar pontos estacionários em exemplos como f(x,y) = x² + 2xy + y².",
                                    "Discutir limitações: pontos de sela ou máximos locais também satisfazem FOC."
                                  ],
                                  "verification": "Encontrar todos os pontos onde ∇f = 0 em uma função dada e classificá-los preliminarmente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Folha de exercícios impressa",
                                    "Software de simbólico como SymPy (Python)",
                                    "Livro de cálculo vetorial"
                                  ],
                                  "tips": "Comece com funções separáveis para praticar resolução de sistemas.",
                                  "learningObjective": "Aplicar FOC para identificar candidatos a pontos ótimos.",
                                  "commonMistakes": "Assumir que ∇f=0 garante mínimo; esquecer de verificar restrições em problemas com constraints."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar condições de segunda ordem (SOC) para confirmar otimalidade",
                                  "subSteps": [
                                    "Definir SOC para mínimo local: Hessiana positiva definida em x* (autovalores >0).",
                                    "Para máximo local: Hessiana negativa definida (autovalores <0).",
                                    "Calcular autovalores da Hessiana ou usar teste de Sylvester para 2x2.",
                                    "Aplicar SOC a exemplos: verificar mínimo em f(x,y)=x²+y².",
                                    "Diferenciar casos: Hessiana indefinida indica ponto de sela."
                                  ],
                                  "verification": "Classificar um ponto estacionário como mínimo, máximo ou sela usando autovalores da Hessiana.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora matricial ou MATLAB para autovalores",
                                    "Tabela de critérios de definitude"
                                  ],
                                  "tips": "Para matrizes 2x2, verifique traço >0 e determinante >0 para positiva definida.",
                                  "learningObjective": "Usar SOC para distinguir tipos de pontos ótimos.",
                                  "commonMistakes": "Confundir Hessiana singular (autovalor=0) com definida; calcular derivadas parciais erradas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar condições necessárias e suficientes para otimalidade",
                                  "subSteps": [
                                    "Resumir: FOC necessárias; FOC + SOC suficiente para mínimo/máximo local.",
                                    "Discutir condições em problemas com restrições (KKT, mas foco em irrestritos).",
                                    "Verificar completa em exemplo numérico: resolver e classificar ponto ótimo.",
                                    "Explorar numericamente com software para funções complexas.",
                                    "Comparar com métodos globais (ex: convexidade)."
                                  ],
                                  "verification": "Explicar e aplicar todas as condições a uma função não-linear completa.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplos resolvidos em PDF",
                                    "Python/MATLAB para simulação"
                                  ],
                                  "tips": "Sempre combine FOC e SOC; teste convexidade para otimalidade global.",
                                  "learningObjective": "Explicar condições completas para pontos ótimos em não-lineares.",
                                  "commonMistakes": "Ignorar que SOC é local; aplicar sem FOC prévia."
                                }
                              ],
                              "practicalExample": "Para otimizar o custo de uma viga em engenharia civil, minimize f(x,y) = 2x² + 3y² - xy sujeito a materiais limitados. Verifique x*=0, y*=0: ∇f=(4x- y, 6y -x)=0 satisfaz FOC; Hessiana [[4,-1],[-1,6]] tem autovalores positivos (mínimo local).",
                              "finalVerifications": [
                                "Explicar verbalmente FOC e SOC com precisão.",
                                "Calcular gradiente e Hessiana corretamente em função dada.",
                                "Classificar ponto como mínimo/máximo/sela usando autovalores.",
                                "Identificar condições necessárias vs suficientes.",
                                "Aplicar a exemplo prático sem erros.",
                                "Discutir limitações em funções não-convexas."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (FOC/SOC corretas): 30%",
                                "Habilidade de cálculo (derivadas/autovalores): 25%",
                                "Aplicação em exemplos: 20%",
                                "Compreensão de necessário/suficiente: 15%",
                                "Clareza na explicação escrita/oral: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial e Integral (derivadas parciais)",
                                "Álgebra Linear (matrizes Hessiana e autovalores)",
                                "Engenharia Estrutural (otimização de projetos)",
                                "Programação Computacional (solvers numéricos como SciPy.optimize)"
                              ],
                              "realWorldApplication": "Em engenharia civil, otimizar o dimensionamento de estruturas como pontes ou edifícios, minimizando custos/materiais sujeitos a restrições de segurança, usando condições de otimalidade para validar soluções computacionais em software como ANSYS ou MATLAB."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Analisar convergência de métodos numéricos",
                            "description": "Avaliar critérios de convergência e taxas de convergência para algoritmos de otimização não-linear, considerando tolerâncias e iterações máximas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de convergência em métodos numéricos",
                                  "subSteps": [
                                    "Definir convergência como o processo pelo qual a sequência de aproximações se aproxima do valor exato.",
                                    "Explicar tipos de convergência: linear, superlinear, quadrática e cúbica.",
                                    "Diferenciar convergência local de global.",
                                    "Estudar condições necessárias para convergência, como continuidade e diferenciabilidade da função objetivo.",
                                    "Revisar notação assintótica de ordem de convergência (ex: ||e_{k+1}|| ≤ C ||e_k||^p)."
                                  ],
                                  "verification": "Resumir em um parágrafo os tipos de convergência e fornecer um exemplo simples para cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de otimização não-linear (ex: Nocedal & Wright), notebook para anotações, vídeo introdutório sobre análise numérica.",
                                  "tips": "Use analogias como 'acelerar um carro para uma parada exata' para visualizar taxas de convergência.",
                                  "learningObjective": "Identificar e explicar os conceitos básicos de convergência aplicados a otimização.",
                                  "commonMistakes": "Confundir taxa de convergência com velocidade de iteração; ignorar dependência em condições iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar critérios de convergência para algoritmos específicos",
                                  "subSteps": [
                                    "Listar critérios comuns: norma do gradiente ||∇f(x_k)|| < ε, norma do passo ||x_{k+1} - x_k|| < ε.",
                                    "Analisar critérios para métodos como Gradiente Descendente, Newton e Quasi-Newton.",
                                    "Discutir critérios de falha: gradiente estagnado ou passos muito pequenos.",
                                    "Implementar uma função simples em Python para checar ||∇f(x)||.",
                                    "Comparar critérios em tabelas para diferentes métodos."
                                  ],
                                  "verification": "Criar uma tabela comparativa de critérios para 3 métodos e testá-la em uma função quadrática.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy e SciPy, Jupyter Notebook, exemplos de funções de benchmark (Rosenbrock).",
                                  "tips": "Sempre normalize os critérios para dimensões diferentes usando normas adequadas.",
                                  "learningObjective": "Selecionar e justificar critérios de convergência apropriados para um dado algoritmo.",
                                  "commonMistakes": "Usar tolerâncias absolutas em problemas mal-condicionados; ignorar escala da função."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar taxas de convergência numericamente",
                                  "subSteps": [
                                    "Coletar dados de iterações: erros residuais e passos ao longo das iterações.",
                                    "Calcular taxas empíricas: log(||e_{k+1}|| / ||e_k||) para taxa linear.",
                                    "Plotar gráficos log-log de erro vs. iteração para visualizar ordem p.",
                                    "Comparar taxas teóricas vs. observadas em simulações.",
                                    "Ajustar hiperparâmetros para melhorar a taxa observada."
                                  ],
                                  "verification": "Gerar um gráfico de convergência para um método e estimar a taxa com coeficiente de determinação R² > 0.95.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python/MATLAB com Matplotlib, funções de otimização prontas (scipy.optimize).",
                                  "tips": "Use pontos iniciais próximos do ótimo para capturar comportamento assintótico.",
                                  "learningObjective": "Quantificar a taxa de convergência de um algoritmo em prática.",
                                  "commonMistakes": "Usar poucos pontos de dados para estimativa; confundir ruído numérico com taxa lenta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impacto de tolerâncias e iterações máximas",
                                  "subSteps": [
                                    "Definir tolerâncias: ε_grad, ε_step, ε_f para função, gradiente e passo.",
                                    "Estudar trade-offs: tolerância pequena aumenta precisão mas risco de não convergência.",
                                    "Implementar loop de parada: while ||∇f|| > ε and k < max_iter.",
                                    "Simular cenários: varrer valores de ε e max_iter, medir tempo e precisão.",
                                    "Recomendar valores baseados em contexto de engenharia (ex: ε=1e-6 para estruturas)."
                                  ],
                                  "verification": "Executar simulações variando parâmetros e relatar quando convergência falha.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python customizado, timer para medir iterações e tempo CPU.",
                                  "tips": "Comece com max_iter=1000 e reduza iterativamente baseado em testes.",
                                  "learningObjective": "Configurar parâmetros de parada robustos para aplicações reais.",
                                  "commonMistakes": "Tolerâncias fixas sem considerar escala do problema; max_iter muito baixo causando falsos não-convergentes."
                                }
                              ],
                              "practicalExample": "Em um problema de otimização de uma viga cantilever na engenharia civil, minimize o peso sujeito a restrições de deflexão usando o método de Newton. Analise o log de iterações: com ε=1e-6 e max_iter=200, verifique se ||∇f|| cai abaixo de ε em 15 iterações, calcule taxa quadrática (p≈2) via gráfico log-log e ajuste ε para 1e-8 se necessário para precisão estrutural.",
                              "finalVerifications": [
                                "Explicar corretamente 3 critérios de convergência para métodos não-lineares.",
                                "Calcular taxa de convergência empírica de um log de iterações com erro <10%.",
                                "Identificar falha de convergência em um exemplo com gradiente estagnado.",
                                "Configurar tolerâncias e max_iter para convergir em <50 iterações.",
                                "Plotar e interpretar gráfico de erro vs. iteração.",
                                "Justificar escolha de parâmetros para um problema de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e aplicação de conceitos de convergência (30%).",
                                "Correção nos cálculos de taxas e critérios (25%).",
                                "Qualidade de análises numéricas e gráficos (20%).",
                                "Robustez na configuração de parâmetros de parada (15%).",
                                "Clareza na justificativa e conexão com aplicações reais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Estudo de erros e estabilidade numérica.",
                                "Programação Computacional: Implementação em Python/SciPy para simulações.",
                                "Engenharia Estrutural: Otimização de elementos finitos em projetos civis.",
                                "Estatística: Análise de regressão para taxas empíricas de convergência."
                              ],
                              "realWorldApplication": "Na otimização de projetos de pontes ou edifícios em engenharia civil, analisar convergência garante que algoritmos como SQP ou Interior Point atinjam soluções confiáveis para dimensionamento ótimo de estruturas, evitando colapsos por aproximações imprecisas e otimizando custos com controle de tempo computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Métodos Baseados em Gradientes",
                        "description": "Técnicas de otimização que utilizam o gradiente da função objetivo para buscar mínimos locais, incluindo gradiente descendente e suas variantes.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Implementar método do gradiente descendente",
                            "description": "Desenvolver algoritmos para o método de gradiente descendente em funções não-lineares univariadas e multivariadas, ajustando passos de aprendizado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos matemáticos do gradiente descendente",
                                  "subSteps": [
                                    "Estudar a definição de gradiente para funções univariadas e multivariadas.",
                                    "Calcular derivadas parciais manualmente para funções não-lineares simples.",
                                    "Entender a iteração: θ_{k+1} = θ_k - α * ∇f(θ_k), onde α é o learning rate.",
                                    "Analisar condições de convergência e o papel do tamanho do passo.",
                                    "Resolver exercícios analíticos de minimização univariada."
                                  ],
                                  "verification": "Capacidade de derivar o gradiente de uma função dada e explicar a atualização iterativa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Cálculo Vetorial",
                                    "Notebook para cálculos manuais",
                                    "Vídeos tutoriais sobre gradientes (Khan Academy)"
                                  ],
                                  "tips": "Visualize o gradiente como uma seta apontando para o aumento mais íngreme da função.",
                                  "learningObjective": "Dominar a teoria matemática por trás do método de gradiente descendente.",
                                  "commonMistakes": "Confundir gradiente com derivada simples; ignorar normalização de variáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar gradiente descendente para funções univariadas",
                                  "subSteps": [
                                    "Definir a função objetivo f(x) não-linear, ex: f(x) = x² + sin(x).",
                                    "Implementar função para calcular a derivada numérica ou analítica em Python/NumPy.",
                                    "Escrever o loop principal: inicializar x0, escolher α, iterar até convergência.",
                                    "Adicionar critério de parada: |f(x_{k+1}) - f(x_k)| < ε.",
                                    "Plotar a convergência com Matplotlib."
                                  ],
                                  "verification": "O código converge para o mínimo conhecido da função teste.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Jupyter Notebook",
                                    "Exemplos de código base de GD univariado"
                                  ],
                                  "tips": "Comece com α pequeno (0.01) para evitar overshooting.",
                                  "learningObjective": "Desenvolver código funcional para otimização univariada.",
                                  "commonMistakes": "Escolha inadequada de α levando a divergência; falta de critério de parada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender para funções multivariadas",
                                  "subSteps": [
                                    "Definir função multivariada, ex: f(x,y) = x² + y² + xy.",
                                    "Implementar cálculo de gradiente vetorial usando NumPy arrays.",
                                    "Adaptar o loop: usar vetores para θ e ∇f(θ).",
                                    "Testar com diferentes inicializações e observar basins de atração.",
                                    "Implementar normalização de features para melhorar convergência."
                                  ],
                                  "verification": "Convergência para o mínimo global em funções quadráticas multivariadas.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "NumPy avançado",
                                    "SciPy para validação",
                                    "Documentação NumPy vectorization"
                                  ],
                                  "tips": "Vectorize todas as operações para eficiência computacional.",
                                  "learningObjective": "Adaptar o algoritmo para espaços de alta dimensão.",
                                  "commonMistakes": "Não vectorizar operações, levando a código lento; ignorar escala das variáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar e validar o algoritmo",
                                  "subSteps": [
                                    "Implementar adaptação de learning rate (ex: decay ou line search).",
                                    "Adicionar momentum para aceleração.",
                                    "Validar contra otimizadores built-in como SciPy minimize.",
                                    "Analisar taxa de convergência e custo computacional.",
                                    "Documentar o código com comentários e testes unitários."
                                  ],
                                  "verification": "Desempenho comparável ou superior a métodos padrão em benchmarks.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "SciPy.optimize",
                                    "Pytest para testes",
                                    "Gráficos de perda vs iterações"
                                  ],
                                  "tips": "Use line search simples como backtracking para α adaptativo.",
                                  "learningObjective": "Melhorar robustez e eficiência do implementado.",
                                  "commonMistakes": "Overfitting do learning rate; não testar múltiplas inicializações."
                                }
                              ],
                              "practicalExample": "Implemente o GD para minimizar a função de energia potencial em uma treliça simples: f(θ) = soma de deformações quadráticas, onde θ são os deslocamentos nodais, otimizando para equilíbrio estrutural sob carga.",
                              "finalVerifications": [
                                "O algoritmo converge para o mínimo com erro < 1e-6 em < 1000 iterações.",
                                "Gradientes calculados coincidem com analíticos em testes unitários.",
                                "Código roda eficientemente para dimensões até 50 variáveis.",
                                "Visualizações mostram trajetórias de convergência corretas.",
                                "Resultados batem com solvers comerciais como ANSYS para caso teste.",
                                "Adaptação de α previne divergência em 95% dos casos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da convergência (erro final < 1e-5).",
                                "Eficiência computacional (tempo < 1s para 1000 iterações em dim=10).",
                                "Robustez a diferentes inicializações e funções.",
                                "Qualidade do código (legibilidade, modularidade, testes).",
                                "Correta implementação de gradientes e atualizações.",
                                "Capacidade de extensão para problemas reais de engenharia."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial e Integral: Derivadas parciais e gradientes.",
                                "Programação Computacional: NumPy, vectorização e otimização.",
                                "Machine Learning: Base para otimizadores em redes neurais.",
                                "Mecânica dos Sólidos: Otimização em análise estrutural.",
                                "Estatística: Análise de convergência e sensibilidade."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para otimizar projetos de estruturas, minimizando peso sob restrições de resistência, como no dimensionamento automático de vigas em pontes ou edifícios altos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Aplicar gradiente conjugado",
                            "description": "Utilizar o método de gradiente conjugado para otimização não-linear, resolvendo sistemas lineares aproximados em problemas de grande dimensão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Otimização e Pré-requisitos",
                                  "subSteps": [
                                    "Estude o problema de otimização não-linear: minimizar f(x) sujeito a restrições.",
                                    "Revise cálculo de gradientes e Hessianas para funções multivariáveis.",
                                    "Entenda limitações do gradiente descendente simples (zigzagging em ravinas).",
                                    "Aprenda conceitos de direções conjugadas e conjugação A-ortogonal.",
                                    "Resolva exercícios manuais de gradiente descendente em 2D."
                                  ],
                                  "verification": "Responda corretamente a um quiz com 5 perguntas sobre gradientes e direções conjugadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Numerical Optimization' de Nocedal e Wright (cap. 2)",
                                    "Notebook Jupyter",
                                    "Vídeo Khan Academy sobre gradientes"
                                  ],
                                  "tips": "Visualize gradientes com plots 3D para entender o zigzagging.",
                                  "learningObjective": "Compreender por que o gradiente conjugado supera o gradiente descendente em eficiência.",
                                  "commonMistakes": [
                                    "Confundir gradiente com Hessiana",
                                    "Ignorar normalização de direções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Algoritmo do Gradiente Conjugado",
                                  "subSteps": [
                                    "Estude as fórmulas: p_k = -g_k + β_k p_{k-1}, onde β_k = (g_k^T g_k)/(g_{k-1}^T g_{k-1}).",
                                    "Aprenda condições de parada: ||g_k|| < ε ou k > max_iter.",
                                    "Analise propriedades: conjugação em até n passos para quadráticas.",
                                    "Derive manualmente para função quadrática f(x) = (1/2)x^T A x - b^T x.",
                                    "Compare com Fletcher-Reeves e Polak-Ribiere."
                                  ],
                                  "verification": "Derive β_k em papel e verifique com exemplo numérico de 2 variáveis.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Slides de curso de otimização",
                                    "Python com NumPy para cálculos manuais",
                                    "Artigo original de Hestenes e Stiefel"
                                  ],
                                  "tips": "Use β Polak-Ribiere para não-convexas: β = max(0, (g_k^T (g_k - g_{k-1})) / (g_{k-1}^T g_{k-1})).",
                                  "learningObjective": "Dominar as atualizações de direção e parâmetro β no algoritmo.",
                                  "commonMistakes": [
                                    "Usar β incorreto para reinicialização",
                                    "Esquecer reset a cada n iterações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Algoritmo em Código",
                                  "subSteps": [
                                    "Escreva função em Python: def conjugate_gradient(f, grad_f, x0, tol=1e-6, max_iter=1000).",
                                    "Implemente loop: compute g_k, p_k, α_k = argmin f(x_k + α p_k), x_{k+1} = x_k + α p_k.",
                                    "Adicione line search inexato (Armijo) para α_k.",
                                    "Teste com Rosenbrock: f(x,y) = 100(y-x^2)^2 + (1-x)^2.",
                                    "Plote convergência: erro vs iterações."
                                  ],
                                  "verification": "Código converge para mínimo conhecido da Rosenbrock em <100 iterações.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python 3, NumPy, SciPy.optimize para validação",
                                    "GitHub repo de exemplos de otimização"
                                  ],
                                  "tips": "Use finite differences para gradiente se analítico indisponível.",
                                  "learningObjective": "Implementar funcionalmente o algoritmo com line search.",
                                  "commonMistakes": [
                                    "Line search falha levando a divergência",
                                    "Não vetorizar para alta dimensão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Problema de Engenharia Civil",
                                  "subSteps": [
                                    "Modele otimização: minimize peso de truss sujeito a restrições de tensão.",
                                    "Defina f(x) = soma(A_i * L_i * ρ), g(x) = σ_max - σ_i <=0.",
                                    "Use gradiente conjugado para resolver sistema aproximado K u = f em iterações.",
                                    "Execute simulação com 1000 variáveis (grande dimensão).",
                                    "Compare tempo/convergência com gradiente descendente."
                                  ],
                                  "verification": "Solução satisfaz restrições com redução >20% no peso objetivo.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Biblioteca FEniCS ou custom FEM code",
                                    "Dados de truss benchmark (ex: 10-bar truss)"
                                  ],
                                  "tips": "Pré-condicione com diagonal de K para aceleração.",
                                  "learningObjective": "Aplicar em contexto real de otimização estrutural.",
                                  "commonMistakes": [
                                    "Violar restrições por line search inadequado",
                                    "Ignorar escala de variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Validar Resultados",
                                  "subSteps": [
                                    "Calcule métricas: iterações, tempo CPU, norma residual final.",
                                    "Teste sensibilidade a tol e initial guess.",
                                    "Valide contra solver exato (ex: IPOPT).",
                                    "Documente relatório com plots de convergência e solução.",
                                    "Discuta escalabilidade para problemas >10^4 dims."
                                  ],
                                  "verification": "Relatório mostra convergência 10x mais rápida que GD simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "Jupyter para relatório interativo"
                                  ],
                                  "tips": "Monitore cond number de Hessiana aproximada.",
                                  "learningObjective": "Avaliar performance e limitações do método.",
                                  "commonMistakes": [
                                    "Sobreestimar convergência sem checar gradiente zero",
                                    "Não resetar conjugação periodicamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimizar seções transversais de uma truss de 25 barras para minimizar peso total, sujeito a deslocamentos < 0.35 polegadas e tensões < 25 ksi, usando gradiente conjugado para resolver iterações de análise estática em alta dimensão.",
                              "finalVerifications": [
                                "Algoritmo implementado converge em <200 iterações para problema de 50 vars.",
                                "Gradiente final ||g|| < 1e-8.",
                                "Solução respeita todas restrições com folga >5%.",
                                "Tempo de execução <10s para 1000 dims.",
                                "Comparação com SciPy CG mostra match >99.9%.",
                                "Relatório documenta código e resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro relativo <1e-6 no mínimo.",
                                "Eficiência: < n iterações para quadráticas.",
                                "Robustez: converge para 5 funções teste diferentes.",
                                "Código limpo: modular, comentado, com testes unitários.",
                                "Análise: identifica bottlenecks e melhorias.",
                                "Aplicação contextual: resolve problema civil realista."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: resolução de sistemas lineares grandes.",
                                "Programação Computacional: implementação eficiente em Python/NumPy.",
                                "Engenharia Estrutural: otimização de designs sob restrições.",
                                "Matemática Aplicada: álgebra linear e cálculo variacional.",
                                "Machine Learning: base para SGD e otimizadores avançados."
                              ],
                              "realWorldApplication": "Em engenharia civil, o gradiente conjugado é usado em software como ANSYS ou COMSOL para otimização topológica de estruturas, reduzindo material em pontes e edifícios enquanto mantém segurança, economizando milhões em projetos de grande escala."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Escolher passos de busca em gradientes",
                            "description": "Implementar buscas lineares (ex: backtracking, Wolfe) para determinar o tamanho ótimo do passo em métodos baseados em gradientes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Line Search em Métodos de Gradiente",
                                  "subSteps": [
                                    "Revise o conceito de métodos baseados em gradientes e o papel do tamanho do passo (α).",
                                    "Estude as condições de Armijo para backtracking e condições de Wolfe para busca inexata.",
                                    "Analise funções objetivo unimodais e o problema de maximizar f(α) = φ(αp) onde p é a direção de descida.",
                                    "Derive matematicamente por que line search é necessário para convergência eficiente.",
                                    "Implemente uma função simples para plotar φ(α) em uma função quadrática teste."
                                  ],
                                  "verification": "Crie um gráfico de φ(α) mostrando o máximo e confirme que α ótimo reduz a função objetivo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy, Matplotlib; notas de otimização não-linear.",
                                  "tips": "Comece com funções quadráticas simples para visualizar o comportamento unimodal.",
                                  "learningObjective": "Compreender o problema teórico do line search e suas condições de parada.",
                                  "commonMistakes": "Confundir direção de descida com tamanho do passo; ignorar unimodalidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Backtracking Line Search",
                                  "subSteps": [
                                    "Defina parâmetros iniciais: α_init = 1.0, ρ = 0.5 (redução), c = 1e-4 (Armijo).",
                                    "Escreva função para computar φ(α) = f(x + α p) onde f é a função objetivo.",
                                    "Implemente loop while: enquanto φ(α) > φ(0) + c α ∇f·p, α ← ρ α.",
                                    "Teste em função Rosenbrock com gradiente descendente.",
                                    "Meça número de iterações e compare com α fixo."
                                  ],
                                  "verification": "Execute 10 iterações e verifique redução consistente da função objetivo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python, NumPy, SciPy (para Rosenbrock); Jupyter Notebook.",
                                  "tips": "Use ρ entre 0.1-0.8 e c pequeno para evitar passos muito curtos.",
                                  "learningObjective": "Codificar backtracking funcional e entender seu comportamento conservador.",
                                  "commonMistakes": "Erro numérico em gradientes; α_init muito grande causando overflow."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Line Search com Condições de Wolfe",
                                  "subSteps": [
                                    "Defina condições Wolfe: Armijo (c1=1e-4) e curvatura (c2=0.9, ∇φ(α) ≥ c2 ∇φ(0)).",
                                    "Implemente busca com zoom: inicie com α_lo, α_hi; refine intervalo satisfazendo Wolfe.",
                                    "Use derivação numérica finita para ∇φ(α) se derivada analítica indisponível.",
                                    "Teste em função não-quadrática como Himmelblau.",
                                    "Compare eficiência (iterações de line search) com backtracking."
                                  ],
                                  "verification": "Confirme que α aceito satisfaz ambas condições Wolfe em logs.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python, NumPy; funções teste de otimização padrão.",
                                  "tips": "Implemente zoom para eficiência; c2 próximo de 1 para passos maiores.",
                                  "learningObjective": "Dominar condições Wolfe para buscas mais agressivas e precisas.",
                                  "commonMistakes": "Falha no zoom levando a loops infinitos; precisão em derivadas numéricas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Comparar em Método de Gradiente Completo",
                                  "subSteps": [
                                    "Combine line search (backtracking e Wolfe) em um loop de gradiente descendente.",
                                    "Execute em problema de engenharia: minimizar peso de treliça sujeito a restrições.",
                                    "Registre histórico: α escolhido, redução f, número de avaliações de f por iteração.",
                                    "Analise convergência: plote f vs iterações para ambos métodos.",
                                    "Escolha α ótimo baseado em trade-off eficiência/convergência."
                                  ],
                                  "verification": "Alcance redução de f em pelo menos 50% em <50 iterações totais.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código anterior; modelo de treliça simples em NumPy.",
                                  "tips": "Use gradiente projetado para restrições; normalize direção.",
                                  "learningObjective": "Aplicar line search em otimização real e selecionar método apropriado.",
                                  "commonMistakes": "Ignorar restrições lineares; não logar métricas para comparação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Otimizar Implementações",
                                  "subSteps": [
                                    "Profile código para identificar gargalos (ex: muitas avaliações de f).",
                                    "Tune hiperparâmetros: teste grids para ρ, c1, c2.",
                                    "Implemente Strong Wolfe para maior robustez.",
                                    "Valide contra solvers como SciPy.minimize com method='L-BFGS-B'.",
                                    "Documente melhores práticas para cenários convexos vs não-convexos."
                                  ],
                                  "verification": "Melhore tempo de convergência em 20% vs implementação inicial.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "SciPy, timeit para profiling; dados de benchmark.",
                                  "tips": "Use vetores NumPy para velocidade; evite loops Python puros.",
                                  "learningObjective": "Refinar algoritmos para performance em aplicações reais.",
                                  "commonMistakes": "Overfitting hiperparâmetros a uma função; ignorar estabilidade numérica."
                                }
                              ],
                              "practicalExample": "Em um projeto de engenharia civil, otimize o dimensionamento de uma treliça para minimizar peso sujeito a limites de tensão. Use gradiente descendente com backtracking para encontrar α que reduza o peso de 150kg para 120kg em 30 iterações, verificando condições Armijo em cada passo.",
                              "finalVerifications": [
                                "Código roda sem erros em funções teste padrão (Rosenbrock, Himmelblau).",
                                "α aceito satisfaz condições de line search (Armijo/Wolfe) em >95% das iterações.",
                                "Convergência demonstrada: ||∇f|| < 1e-6 ou redução f >90%.",
                                "Número de avaliações de f por iteração <10 para backtracking, <20 para Wolfe.",
                                "Resultados coincidem com SciPy.optimize em erro relativo <1%.",
                                "Análise de sensibilidade mostra robustez a hiperparâmetros."
                              ],
                              "assessmentCriteria": [
                                "Correção teórica: derivações e condições implementadas precisamente.",
                                "Eficiência computacional: minimiza avaliações de função objetivo.",
                                "Robustez: funciona em convexo e não-convexo sem falhas.",
                                "Documentação: código comentado com explicações matemáticas.",
                                "Análise comparativa: gráficos e métricas para backtracking vs Wolfe.",
                                "Aplicação contextual: adaptação a problema de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: gradientes e derivadas direcionais.",
                                "Programação Numérica: implementação eficiente em Python/NumPy.",
                                "Estatística: análise de convergência e variância em tuning.",
                                "Engenharia Estrutural: otimização de treliças e design ótimo.",
                                "Física: minimização de energia potencial em sistemas."
                              ],
                              "realWorldApplication": "Na análise estrutural de pontes ou edifícios, line search em gradientes otimiza seções de vigas para mínimo custo/material, reduzindo peso em 15-30% enquanto atende normas de segurança (ex: ABNT NBR), acelerando iterações em software como ANSYS ou códigos customizados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Métodos de Segunda Ordem e Aplicações",
                        "description": "Algoritmos que incorporam informações da Hessiana, como método de Newton, e aplicações práticas em problemas de engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Implementar método de Newton",
                            "description": "Codificar o método de Newton para otimização não-linear, calculando inversas de Hessiana e lidando com singularidades.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos Teóricos do Método de Newton",
                                  "subSteps": [
                                    "Estude a formulação matemática do método de Newton para otimização não-linear: x_{k+1} = x_k - H^{-1} ∇f(x_k), onde H é a Hessiana.",
                                    "Revise conceitos de gradiente (∇f) e Hessiana (H) para funções escalares multivariáveis.",
                                    "Analise condições de convergência quadrática e requisitos para Hessiana positiva definida.",
                                    "Identifique cenários comuns de falha, como singularidades na Hessiana.",
                                    "Resuma em um diagrama de fluxo as iterações do algoritmo."
                                  ],
                                  "verification": "Crie um resumo escrito ou diagrama confirmando compreensão dos componentes matemáticos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de otimização (ex: Nocedal & Wright), notas de aula, papel e caneta ou ferramenta de diagramação como Draw.io.",
                                  "tips": "Use exemplos unidimensionais simples para visualizar a convergência antes de multivariáveis.",
                                  "learningObjective": "Compreender a base matemática e condições de uso do método de Newton.",
                                  "commonMistakes": "Confundir gradiente com Hessiana ou ignorar a necessidade de segunda derivada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Função Objetivo e Computar Derivadas",
                                  "subSteps": [
                                    "Escolha uma função objetivo f(x) não-linear relevante para engenharia civil, como minimizar peso de estrutura sob restrições.",
                                    "Implemente analiticamente ou numéricamente o gradiente ∇f(x) usando autograd ou diferenças finitas.",
                                    "Calcule a Hessiana H(x) analiticamente ou via hessian de bibliotecas como SymPy.",
                                    "Teste as derivadas em pontos conhecidos para validar precisão.",
                                    "Armazene funções em módulos Python para reutilização."
                                  ],
                                  "verification": "Execute testes unitários comparando derivadas numéricas e analíticas com erro < 1e-6.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python 3, NumPy, SciPy, SymPy, Jupyter Notebook.",
                                  "tips": "Prefira derivadas analíticas para precisão; use SymPy para simbolismo inicial.",
                                  "learningObjective": "Implementar corretamente gradiente e Hessiana para uma função dada.",
                                  "commonMistakes": "Erros de sinal no gradiente ou transposição incorreta na Hessiana."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Iteração Principal do Algoritmo",
                                  "subSteps": [
                                    "Inicialize x0, tolerância (ex: 1e-8), máximo de iterações (ex: 100).",
                                    "Em loop: compute ∇f e H em x_k; resolva H d = -∇f para direção d.",
                                    "Atualize x_{k+1} = x_k + d; cheque normas de ∇f e passo para convergência.",
                                    "Registre histórico de iterações (f(x), ||∇f||) para monitoramento.",
                                    "Implemente parada por gradiente pequeno ou mudança insignificante em x."
                                  ],
                                  "verification": "Rode em função quadrática conhecida (ex: Rosenbrock) e confirme convergência em <10 iterações.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com NumPy, SciPy.linalg.solve para inversa, Matplotlib para plots.",
                                  "tips": "Use solve em vez de inv(H) para estabilidade numérica.",
                                  "learningObjective": "Codificar o núcleo iterativo do método de Newton com controles de convergência.",
                                  "commonMistakes": "Usar np.linalg.inv em vez de solve, levando a instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Lidar com Singularidades e Modificações",
                                  "subSteps": [
                                    "Implemente detecção de singularidade via cond(H) > 1e12 ou falha em solve.",
                                    "Adicione regularização: H_mod = H + λI, com λ inicial 1e-6, ajustado dinamicamente.",
                                    "Inclua backtracking line search para α em x + α d, reduzindo α por 0.5 até Armijo condition.",
                                    "Teste em funções com Hessiana indefinida ou singular.",
                                    "Documente thresholds e lógica de fallback para gradiente descendente."
                                  ],
                                  "verification": "Simule singularidade artificial e confirme que algoritmo continua convergindo.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Código anterior, funções teste como Himmelblau com perturbações.",
                                  "tips": "Comece com λ fixo simples antes de adaptativo para depuração.",
                                  "learningObjective": "Tornar o método robusto a problemas numéricos reais.",
                                  "commonMistakes": "λ muito grande, causando convergência lenta como gradiente descendente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Validar e Otimizar Implementação",
                                  "subSteps": [
                                    "Teste em benchmarks: Rosenbrock, Powell, função civil customizada.",
                                    "Compare com otimizadores built-in (SciPy minimize(method='Newton-CG')).",
                                    "Profile código para gargalos (ex: solve Hessiana) e otimize com cache.",
                                    "Adicione logging e visualizações de trajetórias de convergência.",
                                    "Escreva testes unitários para todo o pipeline."
                                  ],
                                  "verification": "Código passa todos testes com precisão relativa <1e-8 e tempo razoável.",
                                  "estimatedTime": "2 horas",
                                  "materials": "pytest para testes, cProfile para profiling, SciPy.optimize para baseline.",
                                  "tips": "Use vectorização NumPy para eficiência em dimensões médias.",
                                  "learningObjective": "Garantir robustez, precisão e eficiência da implementação completa.",
                                  "commonMistakes": "Ignorar underflow/overflow em funções exponenciais."
                                }
                              ],
                              "practicalExample": "Implemente o método para otimizar o perfil de uma viga cantilever minimizando volume sujeito a limite de deflexão máxima, definindo f(x) = volume(x), com ∇f e H derivadas analíticas das equações de Euler-Bernoulli.",
                              "finalVerifications": [
                                "O algoritmo converge para o mínimo conhecido em funções benchmark com ||∇f|| < 1e-10.",
                                "Tratamento de singularidade ativa sem crash, com fallback funcional.",
                                "Line search aceita passos com redução suficiente em f(x).",
                                "Tempo de execução é competitivo com otimizadores padrão para dim <= 50.",
                                "Código é modular, testado e documentado com docstrings.",
                                "Visualizações mostram trajetórias suaves de convergência."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: derivadas e atualizações implementadas precisamente.",
                                "Robustez: lida com singularidades e não-convergências sem erros.",
                                "Eficiência: convergência quadrática observada em casos ideais.",
                                "Clareza do código: estrutura modular, comentários e testes unitários.",
                                "Validação: comparação quantitativa com solvers estabelecidos.",
                                "Aplicabilidade: funciona em problemas de engenharia civil realistas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e álgebra linear numérica.",
                                "Programação: Desenvolvimento de algoritmos numéricos em Python.",
                                "Engenharia Civil: Otimização estrutural e análise de elementos finitos.",
                                "Estatística: Análise de sensibilidade e incertezas em otimizações."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para otimizar designs de estruturas como pontes ou edifícios, minimizando custos/materiais enquanto satisfaz restrições de segurança e normas (ex: ASCE 7), integrando com FEM software como ANSYS."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Usar métodos quasi-Newton (BFGS)",
                            "description": "Aplicar atualizações quasi-Newton como BFGS para aproximar a Hessiana sem computar segundas derivadas explicitamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos dos Métodos Quasi-Newton e BFGS",
                                  "subSteps": [
                                    "Estude a motivação dos métodos de segunda ordem e limitações da Hessiana explícita.",
                                    "Revise a fórmula da direção de busca em métodos Newton: p_k = -H_k^{-1} ∇f(x_k).",
                                    "Aprenda o princípio de atualização quasi-Newton: aproximar H_{k+1} ≈ H_k + correção baseada em s_k e y_k.",
                                    "Foquem na atualização BFGS específica: H_{k+1} = (I - ρ_k s_k y_k^T) H_k (I - ρ_k y_k s_k^T) + ρ_k s_k s_k^T, onde ρ_k = 1 / y_k^T s_k.",
                                    "Compare BFGS com DFP e entenda por que BFGS satisfaz a propriedade de curvatura."
                                  ],
                                  "verification": "Resuma em um diagrama as diferenças entre Newton, quasi-Newton e BFGS, incluindo fórmulas chave.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Numerical Optimization' de Nocedal & Wright (cap. 6); vídeo Khan Academy sobre Hessiana; notebook Jupyter para anotações.",
                                  "tips": "Desenhe fluxogramas para visualizar atualizações; memorize ρ_k como chave para estabilidade.",
                                  "learningObjective": "Explicar como BFGS aproxima a Hessiana usando gradientes sucessivos sem derivadas segundas.",
                                  "commonMistakes": "Confundir s_k (deslocamento) com y_k (mudança no gradiente); ignorar inicialização de H_0 como I."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Implementar a Atualização BFGS",
                                  "subSteps": [
                                    "Implemente a função de atualização BFGS em Python usando NumPy para matrizes.",
                                    "Calcule s_k = x_{k+1} - x_k e y_k = ∇f(x_{k+1}) - ∇f(x_k) em um loop.",
                                    "Codifique a fórmula completa de H_{k+1}, garantindo simetria positiva definida.",
                                    "Teste com função quadrática simples onde Hessiana é conhecida para validar.",
                                    "Adicione line search (ex: Armijo) para garantir redução de f."
                                  ],
                                  "verification": "Execute código em função teste e verifique se ||y_k - H_k s_k|| diminui (propriedade de curvatura).",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com NumPy/SciPy; código template de otimização disponível em GitHub (bfgs-template.py); documentação SciPy.optimize.",
                                  "tips": "Use np.outer para produtos externos eficientes; inicie H_0 = eye(n) para escalabilidade.",
                                  "learningObjective": "Implementar corretamente a atualização BFGS garantindo propriedades matemáticas.",
                                  "commonMistakes": "Erro numérico em ρ_k quando y_k^T s_k ≈ 0 (adicione safeguard > 1e-10); não checar simetria pós-atualização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar BFGS em Problemas Não-Lineares",
                                  "subSteps": [
                                    "Escolha função não-linear convexa (ex: Rosenbrock) e defina ∇f analiticamente.",
                                    "Estruture o algoritmo: inicialize x_0, H_0; loop até ||∇f|| < tol.",
                                    "Integre busca linear para passo α_k.",
                                    "Registre histórico de f(x_k), ||∇f|| e tempo de computação.",
                                    "Compare convergência com gradiente descendente simples."
                                  ],
                                  "verification": "Plote curvas de convergência mostrando BFGS superquadrático vs. linear.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Jupyter Notebook; Matplotlib para plots; funções teste de SciPy (rosen).",
                                  "tips": "Use tol=1e-6 para gradiente; monitore cond(H_k) para ill-conditioning.",
                                  "learningObjective": "Executar BFGS completo em problema não-linear e analisar convergência.",
                                  "commonMistakes": "Passo α_k fixo causando overshoot; não normalizar direção p_k."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Otimizar Implementação para Engenharia Civil",
                                  "subSteps": [
                                    "Aplique BFGS a problema estrutural: minimizar peso de treliça sujeito a restrições de tensão.",
                                    "Defina ∇f via autograd ou finita diferenças.",
                                    "Otimize hiperparâmetros: tol, max_iter, H_0 limitada.",
                                    "Avalie sensibilidade a ruído em gradientes reais.",
                                    "Documente speedup vs. métodos first-order."
                                  ],
                                  "verification": "Obtenha solução factível com redução >90% em f vs. inicial.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Biblioteca PyTorch para autograd; modelo treliça simples (ex: 10 barras).",
                                  "tips": "Para grandes n, use L-BFGS (versão limitada); vetorize computações.",
                                  "learningObjective": "Adaptar BFGS a aplicações de otimização estrutural em Engenharia Civil.",
                                  "commonMistakes": "Ignorar restrições (use projected BFGS); gradientes imprecisos de diferenças finitas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Comparar com Ferramentas Padrão",
                                  "subSteps": [
                                    "Compare sua implementação com SciPy.optimize.minimize(method='BFGS').",
                                    "Teste em benchmark não-convexo com múltiplos mínimos.",
                                    "Meça eficiência: iterações, tempo CPU, precisão.",
                                    "Analise falhas: saddle points, não-convexidade.",
                                    "Escreva relatório com plots e métricas."
                                  ],
                                  "verification": "Sua impl. converge em <5% diferença de SciPy em 3 problemas teste.",
                                  "estimatedTime": "2 horas",
                                  "materials": "SciPy; benchmarks CUTEst ou problemas civis custom.",
                                  "tips": "Use profiling (timeit) para bottlenecks; log det(H_k) para monitorar.",
                                  "learningObjective": "Validar robustez de BFGS custom vs. bibliotecas profissionais.",
                                  "commonMistakes": "Comparar apples-to-oranges (diferentes tol); ignorar restarts para basins."
                                }
                              ],
                              "practicalExample": "Otimizar o dimensionamento de uma treliça de ponte suspensa minimizando peso total sujeito a limites de tensão e deslocamento, usando BFGS para atualizar aproximações da Hessiana baseada em simulações finitas de elementos.",
                              "finalVerifications": [
                                "Implementação converge em <50 iterações para Rosenbrock com tol=1e-6.",
                                "Atualização BFGS mantém H_k SPD (autovalores >0).",
                                "Propriedade de curvatura satisfeita: média ||y - H s|| / ||y|| < 0.1.",
                                "Aplicação em treliça reduz massa em >20% vs. inicial factível.",
                                "Código roda <1s para n=50 variáveis.",
                                "Relatório compara com SciPy: erro relativo <1e-4."
                              ],
                              "assessmentCriteria": [
                                "Precisão: solução final ||∇f|| <1e-6 e f reduzida adequadamente.",
                                "Eficiência: <100 iterações e tempo <5s para problemas médios.",
                                "Robustez: lida com H_0 mal-condicionada e y^T s pequeno.",
                                "Correção matemática: fórmulas BFGS implementadas sem erros.",
                                "Documentação: código comentado, plots de convergência claros.",
                                "Aplicação contextual: adaptação bem-sucedida a problema civil.",
                                "Análise: identificação de speedup vs. GD (fator >5x)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso de NumPy/SciPy para álgebra linear eficiente.",
                                "Cálculo Numérico: Aproximações de gradientes e buscas lineares.",
                                "Engenharia Estrutural: Otimização de treliças e elementos finitos.",
                                "Estatística: Análise de sensibilidade e confiança em aproximações Hessiana.",
                                "Machine Learning: Paralelos com SGD momentum e second-order optimizers como K-FAC."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, BFGS otimiza designs de estruturas como edifícios altos ou pontes, minimizando material (custo/CO2) enquanto satisfaz normas de segurança (ex: AASHTO), reduzindo iterações em software como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Resolver problemas com restrições não-lineares",
                            "description": "Formular e resolver programação não-linear com restrições usando métodos de penalidade ou multiplicadores de Lagrange em softwares como MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão Teórica de Programação Não-Linear com Restrições",
                                  "subSteps": [
                                    "Estude a definição de programação não-linear (PNL) e tipos de restrições (igualdades e desigualdades).",
                                    "Aprenda o método de penalidade: como incorporar restrições no objetivo via funções de penalidade quadráticas.",
                                    "Entenda os multiplicadores de Lagrange: formulação do lagrangiano e condições de otimalidade de Karush-Kuhn-Tucker (KKT).",
                                    "Compare vantagens e desvantagens de cada método em contextos com restrições não-lineares.",
                                    "Resolva manualmente um problema simples de 1 variável para fixar conceitos."
                                  ],
                                  "verification": "Resuma em um parágrafo os princípios de cada método e resolva um exemplo analítico simples com cálculos mostrados.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de Otimização Não-Linear (ex: Nocedal & Wright), notas de aula, calculadora.",
                                  "tips": "Use diagramas para visualizar o espaço de viabilidade e pontos de penalidade.",
                                  "learningObjective": "Compreender os fundamentos teóricos para formular corretamente problemas de PNL com restrições.",
                                  "commonMistakes": "Confundir penalidades exatas com inexatas; ignorar convexidade das restrições."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formulação de um Problema de Otimização Não-Linear",
                                  "subSteps": [
                                    "Defina a função objetivo não-linear (ex: minimizar custo de material em uma viga).",
                                    "Identifique e escreva restrições não-lineares (ex: resistência estrutural ≥ limite, volume ≤ restrição).",
                                    "Verifique se o problema é factível e converte restrições em forma padrão.",
                                    "Escolha variáveis de decisão e parâmetros iniciais.",
                                    "Documente a formulação matemática completa em LaTeX ou texto."
                                  ],
                                  "verification": "Apresente a formulação escrita com objetivo, restrições e domínio das variáveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel e caneta ou editor LaTeX, exemplos de problemas de engenharia civil.",
                                  "tips": "Comece com poucas variáveis (2-3) para simplicidade inicial.",
                                  "learningObjective": "Capacitar a modelagem precisa de problemas reais como PNL com restrições.",
                                  "commonMistakes": "Esquecer normalizar restrições ou definir mal o domínio das variáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementação do Método de Penalidade em MATLAB",
                                  "subSteps": [
                                    "Crie a função objetivo penalizada combinando f(x) + penalidade * violação.",
                                    "Implemente um algoritmo de otimização (ex: fmincon ou gradiente descendente customizado).",
                                    "Defina parâmetros: fator de penalidade inicial e esquema de atualização.",
                                    "Execute iterações e plote convergência (objetivo vs iterações).",
                                    "Ajuste hiperparâmetros para convergência estável."
                                  ],
                                  "verification": "Código MATLAB roda e produz solução com violações de restrições < 1e-6.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB com Optimization Toolbox, script de exemplo.",
                                  "tips": "Use 'fsolve' para raízes não-lineares dentro do loop; monitore overflow numérico.",
                                  "learningObjective": "Desenvolver habilidade em codificar métodos de penalidade para PNL restrita.",
                                  "commonMistakes": "Penalidade fixa muito baixa/alta; não atualizar fator de penalidade adequadamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementação dos Multiplicadores de Lagrange em MATLAB",
                                  "subSteps": [
                                    "Formule o lagrangiano: L(x, λ, μ) = f(x) + λ*g(x) + μ*h(x).",
                                    "Implemente condições KKT usando 'fmincon' com multiplicadores ou solver customizado.",
                                    "Inicialize multiplicadores e resolva sistema não-linear iterativamente.",
                                    "Verifique dual feasibility e complementaridade slackness.",
                                    "Compare resultados com método de penalidade."
                                  ],
                                  "verification": "Solução satisfaz KKT com tolerância < 1e-4; plote multiplicadores vs iterações.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB Optimization Toolbox, documentação fmincon.",
                                  "tips": "Use opção 'Algorithm: interior-point' no fmincon para multiplicadores automáticos.",
                                  "learningObjective": "Aplicar método de Lagrange para soluções exatas em PNL com restrições.",
                                  "commonMistakes": "Inicialização ruim de λ/μ levando a não-convergência; ignorar desigualdades."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Análise, Validação e Aplicação Prática",
                                  "subSteps": [
                                    "Compare soluções dos dois métodos (valor objetivo, viabilidade).",
                                    "Analise sensibilidade variando restrições ou parâmetros.",
                                    "Valide com problema real de engenharia civil (ex: otimização de seção transversal).",
                                    "Documente relatório com código, gráficos e conclusões.",
                                    "Teste em cenários com ruído ou múltiplos mínimos locais."
                                  ],
                                  "verification": "Relatório completo com comparações quantitativas e gráficos de convergência.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB, Excel para análise sensibilidade.",
                                  "tips": "Salve sessões MATLAB para reprodutibilidade; use legendas claras em plots.",
                                  "learningObjective": "Integrar métodos para análise crítica e aplicação em contextos reais.",
                                  "commonMistakes": "Não verificar viabilidade final; superestimar precisão numérica."
                                }
                              ],
                              "practicalExample": "Otimize a seção transversal de uma viga de concreto (área A e inércia I) para minimizar custo C = 100*A + 50*sqrt(I), sujeito a restrições não-lineares: resistência flexural σ = M*(h/2)/I ≤ 30 MPa e volume V = A*h ≤ 0.5 m³, onde h = sqrt(12*I/A). Implemente em MATLAB usando penalidade e Lagrange, comparando soluções.",
                              "finalVerifications": [
                                "Solução converge para ambos métodos com erro < 1e-6.",
                                "Restrições satisfeitas com viabilidade absoluta < 1e-4.",
                                "Código MATLAB é modular e comentado.",
                                "Gráficos mostram convergência e trajetórias de variáveis.",
                                "Comparação quantitativa: diferença em objetivo < 1%.",
                                "Teste com variação de parâmetros confirma robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação matemática (100% correta).",
                                "Eficiência numérica: convergência em < 100 iterações.",
                                "Qualidade do código: legível, sem warnings/erros.",
                                "Análise crítica: identificação de prós/contras dos métodos.",
                                "Validação: correspondência com solução analítica conhecida.",
                                "Relatório: clareza e profundidade de insights.",
                                "Aplicação contextual: relevância para engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Avançada: Cálculo Variacional e Equações Diferenciais.",
                                "Programação Computacional: Algoritmos Numéricos em MATLAB/Python.",
                                "Engenharia Estrutural: Análise de Otimização em Projetos Civis.",
                                "Estatística: Análise de Sensibilidade e Monte Carlo.",
                                "Gestão de Projetos: Otimização de Custos e Recursos."
                              ],
                              "realWorldApplication": "Em engenharia civil, otimizar designs de pontes ou edifícios minimizando custos de material sob restrições não-lineares de resistência sísmica e vento, usando MATLAB para iterar soluções rápidas em projetos reais como o viaduto de um metrô."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.4",
                            "name": "Aplicar em engenharia civil",
                            "description": "Otimizar estruturas ou projetos civis, como ajuste de parâmetros em modelos de materiais não-lineares ou dimensionamento ótimo de vigas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o Problema de Otimização Não-Linear",
                                  "subSteps": [
                                    "Identificar variáveis de decisão, como seção transversal de vigas ou parâmetros de materiais não-lineares.",
                                    "Definir a função objetivo, ex: minimizar volume ou peso da estrutura.",
                                    "Estabelecer restrições de desigualdade e igualdade baseadas em normas civis (tensões, deformações).",
                                    "Modelar comportamentos não-lineares, como plasticidade em materiais.",
                                    "Escrever a formulação matemática completa em notação padrão."
                                  ],
                                  "verification": "Verificar se o modelo matemático está corretamente documentado e balanceado (objetivo + restrições).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de modelagem (Python com NumPy/SciPy, MATLAB)",
                                    "Normas ABNT NBR para estruturas",
                                    "Livro de otimização não-linear (Nocedal & Wright)"
                                  ],
                                  "tips": "Comece com um problema simples para validar a formulação antes de complexificar.",
                                  "learningObjective": "Capacitar o aluno a traduzir problemas de engenharia civil em modelos matemáticos de otimização não-linear.",
                                  "commonMistakes": [
                                    "Ignorar não-linearidades reais dos materiais",
                                    "Definir restrições irrealistas",
                                    "Esquecer variáveis de folga"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Configurar Método de Segunda Ordem",
                                  "subSteps": [
                                    "Revisar métodos como Newton, Quasi-Newton (BFGS) ou SQP para problemas com Hessiana.",
                                    "Implementar cálculo de gradientes e Hessiana analítica ou aproximada.",
                                    "Configurar tolerâncias de convergência e inicializar pontos de partida.",
                                    "Testar em problema toy para validar implementação.",
                                    "Ajustar parâmetros para estabilidade em problemas civis (ex: grandes escalas)."
                                  ],
                                  "verification": "Executar iterações iniciais e confirmar que gradientes e Hessiana são computados corretamente.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Bibliotecas Python (SciPy.optimize, CVXPY)",
                                    "Documentação de solvers não-lineares",
                                    "Computador com Python instalado"
                                  ],
                                  "tips": "Use Hessiana aproximada (BFGS) se analítica for complexa para economizar tempo.",
                                  "learningObjective": "Entender e aplicar métodos de segunda ordem para aceleração de convergência em otimização não-linear.",
                                  "commonMistakes": [
                                    "Pontos iniciais ruins levando a divergência",
                                    "Não verificar simetria positiva da Hessiana",
                                    "Tolerâncias muito frouxas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Resolver o Modelo de Otimização",
                                  "subSteps": [
                                    "Codificar o modelo completo no software escolhido.",
                                    "Executar o solver e monitorar iterações (gradientes, passos de linha).",
                                    "Ajustar parâmetros de materiais não-lineares durante otimização.",
                                    "Analisar histórico de convergência e custo computacional.",
                                    "Realizar múltiplas execuções com sementes diferentes para robustez."
                                  ],
                                  "verification": "Confirmar convergência dentro de tolerância e satisfação de restrições (KKT conditions).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Ambiente de programação (Jupyter Notebook)",
                                    "Exemplos de código de otimização estrutural",
                                    "Dados de propriedades de materiais (aço, concreto)"
                                  ],
                                  "tips": "Use plotagens para visualizar convergência e evitar 'caixas pretas'.",
                                  "learningObjective": "Desenvolver habilidades práticas em resolução numérica de problemas civis não-lineares.",
                                  "commonMistakes": [
                                    "Sobrecarga numérica em Hessianas mal-condicionadas",
                                    "Violação de restrições por precisão numérica",
                                    "Ignorar tempo de CPU em problemas grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Resultados e Analisar Sensibilidade",
                                  "subSteps": [
                                    "Comparar solução ótima com métodos analíticos ou FEM tradicional.",
                                    "Realizar análise de sensibilidade variando parâmetros civis (cargas, solos).",
                                    "Verificar viabilidade estrutural com simulações adicionais.",
                                    "Documentar economia de material ou custo alcançada.",
                                    "Preparar relatório com gráficos e métricas de performance."
                                  ],
                                  "verification": "Solução atende todas restrições e melhora objetivo em pelo menos 10% vs. design inicial.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software FEM (ex: Abaqus trial, Ftool)",
                                    "Templates de relatório em LaTeX ou Word"
                                  ],
                                  "tips": "Sempre valide com engenharia de senso comum: a viga otimizada faz sentido fisicamente?",
                                  "learningObjective": "Avaliar criticamente soluções otimizadas no contexto real de engenharia civil.",
                                  "commonMistakes": [
                                    "Aceitar soluções localmente ótimas sem global",
                                    "Não testar variações de cargas reais",
                                    "Relatórios sem quantificação de ganhos"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimizar o dimensionamento de uma viga de aço em ponte: minimizar peso sujeito a restrições de flexão máxima (σ ≤ 250 MPa) e flambagem, usando modelo não-linear para interação material-geometry, resultando em redução de 15% no peso.",
                              "finalVerifications": [
                                "Função objetivo minimizada corretamente com convergência confirmada.",
                                "Todas restrições civis satisfeitas (tensões, deflexões).",
                                "Solução robusta a perturbações de parâmetros (±10%).",
                                "Tempo computacional razoável (<1 hora para modelo médio).",
                                "Validação cruzada com software comercial FEM.",
                                "Documentação completa com código reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução ótima (erro <1% vs. benchmark).",
                                "Eficiência iterativa do método de segunda ordem (menos de 50 iterações).",
                                "Adequação ao contexto civil (normas ABNT/Eurocode).",
                                "Qualidade da implementação (código limpo, comentado).",
                                "Análise de sensibilidade abrangente.",
                                "Relatório claro com visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e álgebra linear para Hessianas.",
                                "Física/Mecânica dos Materiais: Modelos constitutivos não-lineares.",
                                "Computação: Programação numérica e visualização de dados.",
                                "Gestão de Projetos: Otimização custo-benefício em construções."
                              ],
                              "realWorldApplication": "Em projetos de edifícios altos ou pontes, otimizar vigas e lajes reduz custos de material em 10-20%, acelera construção e melhora sustentabilidade, como no caso da Ponte Rio-Niterói com ajustes não-lineares em cabos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Otimização sem Restrições",
                    "description": "Algoritmos como gradiente descendente, busca linear e método de Newton para minimização irrestrita.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Gradiente Descendente",
                        "description": "Algoritmo iterativo para minimização de funções diferenciáveis sem restrições, baseado na direção oposta ao gradiente da função objetivo para encontrar mínimos locais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Compreender o princípio do gradiente descendente",
                            "description": "Explicar o conceito de direção de descida utilizando o gradiente negativo, passos de iteração e critérios de parada como tolerância no gradiente ou no incremento de parâmetros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos fundamentais de otimização e gradiente",
                                  "subSteps": [
                                    "Definir função objetivo f(x) em otimização sem restrições.",
                                    "Explicar o gradiente ∇f(x) como vetor de derivadas parciais.",
                                    "Visualizar geometricamente o gradiente como direção de maior aumento da função.",
                                    "Interpretar o sinal negativo do gradiente como direção de descida mais íngreme."
                                  ],
                                  "verification": "Desenhe o gráfico de f(x) = x² e indique o gradiente em um ponto x=2, explicando a direção de descida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráficos impressos de funções quadráticas"
                                  ],
                                  "tips": "Use analogia com uma montanha: gradiente aponta para o topo mais próximo.",
                                  "learningObjective": "Compreender o gradiente como indicador direcional para minimização.",
                                  "commonMistakes": [
                                    "Confundir gradiente com a derivada simples em 1D",
                                    "Ignorar a magnitude do gradiente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a direção de descida utilizando o gradiente negativo",
                                  "subSteps": [
                                    "Calcular explicitamente -∇f(x) para uma função dada.",
                                    "Comparar direções: gradiente vs. gradiente negativo em exemplos 1D e 2D.",
                                    "Escolher taxa de aprendizado inicial (α) heurística.",
                                    "Atualizar parâmetros: x_{k+1} = x_k - α ∇f(x_k)."
                                  ],
                                  "verification": "Para f(x,y)=x²+y² em (1,1), compute -∇f e novo ponto com α=0.1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python/Jupyter simples",
                                    "Folha de exercícios com funções"
                                  ],
                                  "tips": "Comece com α pequeno para evitar overshooting.",
                                  "learningObjective": "Dominar a fórmula da direção de descida e atualização.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo",
                                    "Escolher α muito grande causando divergência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar os passos de iteração do algoritmo",
                                  "subSteps": [
                                    "Estruturar o loop iterativo: inicializar x0, compute ∇f, update x, repetir.",
                                    "Executar 3-5 iterações manualmente para função simples.",
                                    "Analisar como a função diminui a cada passo.",
                                    "Ajustar α manualmente se necessário."
                                  ],
                                  "verification": "Realize 5 iterações para f(x)=x² a partir de x0=3 e tabule valores de f(x_k).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel quadriculado",
                                    "Código Python básico para verificação"
                                  ],
                                  "tips": "Registre ||∇f|| para monitorar convergência.",
                                  "learningObjective": "Executar o ciclo completo de iterações do gradiente descendente.",
                                  "commonMistakes": [
                                    "Não normalizar passos",
                                    "Parar prematuramente sem critério"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender critérios de parada e convergência",
                                  "subSteps": [
                                    "Definir tolerância no gradiente: pare se ||∇f(x)|| < ε.",
                                    "Definir tolerância no incremento: pare se ||x_{k+1} - x_k|| < δ.",
                                    "Discutir condições para convergência (f convexa, α adequada).",
                                    "Escolher valores típicos para ε e δ (ex: 1e-6)."
                                  ],
                                  "verification": "Aplique critérios em exemplo anterior e justifique parada na iteração final.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos numéricos resolvidos",
                                    "Gráfico de convergência"
                                  ],
                                  "tips": "Use ambos critérios para robustez.",
                                  "learningObjective": "Aplicar e justificar condições de parada no algoritmo.",
                                  "commonMistakes": [
                                    "Usar ε muito pequeno causando loops infinitos",
                                    "Ignorar não-convergência em funções não-convexas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar o princípio completo do gradiente descendente",
                                  "subSteps": [
                                    "Resumir algoritmo em pseudocódigo.",
                                    "Discutir limitações (taxa de aprendizado fixa).",
                                    "Comparar com métodos exatos como Newton.",
                                    "Planejar implementação computacional simples."
                                  ],
                                  "verification": "Escreva pseudocódigo completo e teste com função conhecida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Referência de pseudocódigo"
                                  ],
                                  "tips": "Pseudocódigo ajuda na programação futura.",
                                  "learningObjective": "Integrar todos elementos em visão unificada.",
                                  "commonMistakes": [
                                    "Omitir inicialização ou critérios",
                                    "Confundir com gradiente conjugado"
                                  ]
                                }
                              ],
                              "practicalExample": "Em engenharia civil, minimize f(θ) = custo de material + penalidade por deformação em uma viga, onde θ são espessuras. Inicie θ0=[5cm,3cm], ∇f(θ0)=[2,-1], α=0.05 → θ1=[4.9,3.05]. Itere até ||∇f||<0.01, convergindo para design ótimo com custo mínimo.",
                              "finalVerifications": [
                                "Explicar verbalmente direção de descida com gradiente negativo.",
                                "Calcular corretamente 3 iterações manuais de exemplo 2D.",
                                "Identificar e aplicar dois critérios de parada.",
                                "Desenhar gráfico ilustrando trajetória de convergência.",
                                "Discutir impacto de α inadequado."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual do gradiente e sua negação (80%).",
                                "Correção matemática em cálculos iterativos (90%).",
                                "Justificativa clara de critérios de parada (85%).",
                                "Uso apropriado de analogias e visualizações (75%).",
                                "Integração de limitações reais do método (80%)."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Vetorial: computação de gradientes multivariados.",
                                "Programação Computacional: implementação em loops numéricos.",
                                "Álgebra Linear: vetores e normas.",
                                "Física: analogia com forças descendentes em potencial.",
                                "Machine Learning: base para treinamento de redes neurais."
                              ],
                              "realWorldApplication": "Na engenharia civil, otimizar projetos de estruturas minimizando custos e maximizando resistência, ajustando parâmetros como dimensões de vigas via gradiente descendente em solvers como MATLAB ou Python, acelerando iterações em problemas de dimensionamento ótimo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Implementar gradiente descendente em código",
                            "description": "Desenvolver um programa em MATLAB ou Python para minimizar uma função univariada ou multivariada, incluindo cálculo numérico de gradientes e atualização de parâmetros com taxa de aprendizado fixa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função objetivo e preparar o ambiente de programação",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: NumPy para cálculos numéricos e Matplotlib para visualização.",
                                    "Defina a função objetivo univariada ou multivariada, por exemplo, f(x) = x² + 10*sin(x) para univariada ou f(x,y) = x² + y² + 10*sin(x)*cos(y) para bivariada.",
                                    "Escreva uma função Python que compute f(theta) onde theta é um vetor NumPy.",
                                    "Inicialize parâmetros: ponto inicial theta0, taxa de aprendizado alpha (ex: 0.01), número máximo de iterações (ex: 1000), tolerância para convergência (ex: 1e-6).",
                                    "Crie uma lista ou array para armazenar histórico de theta e valores de f ao longo das iterações."
                                  ],
                                  "verification": "Execute a função f em pontos de teste e confirme que retorna valores corretos comparando com cálculos manuais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "Matplotlib",
                                    "Editor de código (VS Code ou Jupyter Notebook)"
                                  ],
                                  "tips": "Use funções vetorizadas do NumPy para eficiência; teste com funções simples como f(x)=x² primeiro.",
                                  "learningObjective": "Compreender e codificar a função objetivo de forma reutilizável para otimização.",
                                  "commonMistakes": [
                                    "Esquecer de importar bibliotecas",
                                    "Usar loops Python em vez de operações vetorizadas",
                                    "Definir função sem suporte a vetores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o cálculo numérico do gradiente",
                                  "subSteps": [
                                    "Defina uma função gradiente_numérico(f, theta, h=1e-5) que compute o gradiente usando diferenças finitas centrais: grad[i] = (f(theta + h*e_i) - f(theta - h*e_i)) / (2*h).",
                                    "Crie uma matriz identidade para gerar vetores unitários e_i.",
                                    "Teste a função em um ponto conhecido, como gradiente de f(x)=x² em x=2 deve ser ~4.",
                                    "Meça o tempo de execução para funções multivariadas e ajuste h se necessário para precisão.",
                                    "Adicione tratamento de erros para dimensões incompatíveis."
                                  ],
                                  "verification": "Compare gradiente numérico com gradiente analítico conhecido para uma função simples e verifique erro < 1e-4.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "NumPy para identidade e operações matriciais"
                                  ],
                                  "tips": "Escolha h pequeno mas não muito (1e-5 a 1e-8) para evitar erros numéricos; vetorize o loop sobre dimensões.",
                                  "learningObjective": "Dominar aproximação numérica de gradientes para funções não analíticas.",
                                  "commonMistakes": [
                                    "Usar diferença forward em vez de central (menos precisa)",
                                    "Loop lento sobre dimensões sem vetorização",
                                    "h muito pequeno causando NaN"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop principal do gradiente descendente",
                                  "subSteps": [
                                    "Escreva a função gradient_descent(f, theta0, alpha, max_iter, tol) que inicializa histórico.",
                                    "Em um loop while (iter < max_iter and norma_grad > tol): compute grad = gradiente_numérico(f, theta), atualize theta = theta - alpha * grad, armazene histórico.",
                                    "Compute norma do gradiente com np.linalg.norm(grad).",
                                    "Implemente critério de parada: norma_grad < tol ou mudança em f pequena.",
                                    "Retorne theta_final, histórico de theta e f_values."
                                  ],
                                  "verification": "Execute com função conhecida (f(x)=x², theta0=10, alpha=0.1) e confirme convergência para ~0.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código dos Steps 1-2"
                                  ],
                                  "tips": "Monitore f_values para detectar divergência (alpha muito grande); use print ou logging para debug.",
                                  "learningObjective": "Codificar o algoritmo core de GD com atualizações iterativas e critérios de convergência.",
                                  "commonMistakes": [
                                    "Atualização errada: theta += alpha*grad em vez de subtrair",
                                    "Esquecer critério de parada levando a loop infinito",
                                    "Alpha fixo muito alto causando oscilação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, visualizar e validar a implementação",
                                  "subSteps": [
                                    "Execute GD em exemplo univariado e bivariado, plotando histórico de f_values e trajetórias de theta.",
                                    "Use Matplotlib para plotar superfície/contorno da função e caminho de convergência.",
                                    "Teste sensibilidade: varie alpha (0.001 a 0.1), theta0 e observe convergência.",
                                    "Compare com otimizadores built-in como scipy.optimize.minimize(method='BFGS') para validação.",
                                    "Documente o código com comentários e crie um relatório de resultados."
                                  ],
                                  "verification": "Código converge para mínimo conhecido (erro < 1e-3), plots mostram trajetória suave sem divergência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código completo",
                                    "Matplotlib",
                                    "SciPy (opcional para comparação)"
                                  ],
                                  "tips": "Salve plots como PNG; use subplots para múltiplas visualizações.",
                                  "learningObjective": "Validar implementação através de testes empíricos e visualização.",
                                  "commonMistakes": [
                                    "Plots incorretos (eixos errados)",
                                    "Ignorar divergência em testes",
                                    "Não comparar com soluções conhecidas"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente GD para minimizar f(x,y) = x² + y² + 10*sin(x) em Python, iniciando em theta0 = [2, 2], alpha=0.01. O código deve convergir para próximo de [0,0] em <500 iterações, com plot da trajetória no plano xy e evolução de f.",
                              "finalVerifications": [
                                "Código executa sem erros para funções uni e multivariadas.",
                                "Converge para mínimo com norma_grad < 1e-6 em tempo razoável (<1s para dim<=5).",
                                "Histórico de f_values é decrescente e estabiliza.",
                                "Gradiente numérico coincide com analítico em funções teste (erro<1e-4).",
                                "Visualizações mostram convergência suave sem oscilações excessivas.",
                                "Função é reutilizável para novas funções objetivo."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro no mínimo final <1e-3 vs. valor ótimo conhecido.",
                                "Eficiência: <1000 iterações para convergência em problemas simples.",
                                "Robustez: lida com dimensões variáveis e detecta não-convergência.",
                                "Clareza: código comentado, funções modulares e legíveis.",
                                "Validação: inclui testes unitários e plots de convergência.",
                                "Flexibilidade: permite ajuste de alpha, tol e max_iter."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial (gradientes), análise numérica (diferenças finitas).",
                                "Programação: Vetorização NumPy, debugging iterativo, visualização de dados.",
                                "Engenharia Civil: Otimização de parâmetros em modelos estruturais (ex: minimizar energia em vigas).",
                                "Física: Dinâmica de gradiente como analogia a forças descendentes.",
                                "Estatística: Base para gradiente descendente estocástico em ML."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, GD é usado para otimizar designs de estruturas, como minimizar peso de treliças sob restrições de tensão ou calibrar parâmetros de modelos finitos para simulações de terremotos, reduzindo custos e melhorando segurança."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Analisar convergência e sensibilidade",
                            "description": "Avaliar o impacto da taxa de aprendizado na convergência, identificar condições para convergência linear e aplicar em problemas de engenharia civil como otimização de estruturas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Convergência no Gradiente Descendente",
                                  "subSteps": [
                                    "Revise a fórmula do Gradiente Descendente: θ_{k+1} = θ_k - α ∇f(θ_k), onde α é a taxa de aprendizado.",
                                    "Estude as condições gerais de convergência para funções convexas e diferenciáveis.",
                                    "Analise o papel do gradiente zero como ponto de convergência.",
                                    "Explore exemplos matemáticos simples, como minimização de f(x) = x².",
                                    "Discuta convergência global vs. local em contextos não-convexos."
                                  ],
                                  "verification": "Resuma em um diagrama as condições de convergência e teste com um exemplo numérico simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Otimização Numérica (Nocedal & Wright)",
                                    "Notebook Jupyter com Python/NumPy",
                                    "Slides sobre GD"
                                  ],
                                  "tips": "Comece com funções quadráticas para visualizar convergência intuitivamente.",
                                  "learningObjective": "Entender as bases teóricas de convergência no GD.",
                                  "commonMistakes": [
                                    "Confundir convergência com estagnação",
                                    "Ignorar Lipschitz continuity da gradiente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Impacto da Taxa de Aprendizado na Convergência",
                                  "subSteps": [
                                    "Implemente simulações numéricas variando α de 0.001 a 1.0 em uma função teste.",
                                    "Plote curvas de perda vs. iterações para diferentes α.",
                                    "Identifique α ótimo via linha de busca ou backtracking.",
                                    "Meça taxa de convergência (ex.: número de iterações para erro < 10^{-4}).",
                                    "Compare estabilidade: divergência para α grande, lentidão para α pequeno."
                                  ],
                                  "verification": "Gere gráficos comparativos e explique picos de divergência.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com Matplotlib/Seaborn",
                                    "Função teste: Rosenbrock ou Himmelblau",
                                    "Código base de GD"
                                  ],
                                  "tips": "Use escalas logarítmicas nos eixos para melhor visualização de convergência.",
                                  "learningObjective": "Quantificar como α afeta velocidade e estabilidade da convergência.",
                                  "commonMistakes": [
                                    "Escolher α fixo sem teste",
                                    "Não normalizar features antes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Condições para Convergência Linear",
                                  "subSteps": [
                                    "Estude o teorema: para f convexa, ∇f Lipschitz com constante L, e α ≤ 1/L, converge linearmente.",
                                    "Derive a taxa de convergência: ||θ_{k+1} - θ*|| ≤ (1 - μ/L) ||θ_k - θ*|| para μ-condicionada.",
                                    "Aplique em funções quadráticas: análise de autovalores da Hessiana.",
                                    "Simule cenários com diferentes condnumbers (condicionamento).",
                                    "Discuta acelerações como Momentum para melhorar convergência linear."
                                  ],
                                  "verification": "Prove ou simule o teorema para f(x,y) = (x-1)² + 100(y-1)².",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Notas de Análise Numérica",
                                    "SymPy para derivações simbólicas",
                                    "MATLAB ou Python para autovalores"
                                  ],
                                  "tips": "Foco em condicionamento da Hessiana: cond < 10 para boa convergência.",
                                  "learningObjective": "Reconhecer e verificar condições matemáticas para convergência linear.",
                                  "commonMistakes": [
                                    "Confundir convergência linear com quadrática",
                                    "Ignorar não-convexidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Análise em Problemas de Otimização de Estruturas Civis",
                                  "subSteps": [
                                    "Modele um problema: minimizar peso de treliça sujeita a restrições de tensão.",
                                    "Implemente GD com análise de α e convergência em simulação finita de elementos.",
                                    "Avalie sensibilidade: varie α e meça impacto em design final.",
                                    "Compare com soluções analíticas ou outros otimizadores.",
                                    "Gere relatório com gráficos de convergência e design otimizado."
                                  ],
                                  "verification": "Otimize uma treliça simples e verifique tensão máxima < limite.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software FEA como ANSYS ou código Python com SciPy",
                                    "Dados de treliça 2D/3D",
                                    "Biblioteca PyTorch para GD"
                                  ],
                                  "tips": "Comece com problema 2D para depuração rápida.",
                                  "learningObjective": "Aplicar conceitos em engenharia civil prática.",
                                  "commonMistakes": [
                                    "Não linearizar restrições adequadamente",
                                    "Escala numérica inconsistente"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimizar o design de uma treliça para uma ponte pedonal: minimizar volume de material sujeito a cargas vivas/mortas, usando GD para ajustar seções transversais. Varie α de 0.01 a 0.1, plote convergência e selecione α que converge em <100 iterações com volume reduzido em 15%.",
                              "finalVerifications": [
                                "Pode derivar condições de convergência linear para funções quadráticas.",
                                "Simula e plota curvas de perda para 5 valores de α em problema teste.",
                                "Identifica α causing divergência em simulação.",
                                "Aplica GD em otimização de treliça com convergência verificada.",
                                "Explica impacto de condicionamento na velocidade de convergência.",
                                "Gera relatório com verificações numéricas (erro < 10^{-6})."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de condições de convergência (teorema correto).",
                                "Qualidade dos gráficos de sensibilidade à α (clareza e insights).",
                                "Correção da implementação em problema civil (resultados físicos válidos).",
                                "Análise quantitativa: taxas de convergência calculadas.",
                                "Criatividade em conexões com aplicações reais.",
                                "Ausência de erros comuns como overflow numérico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Álgebra Linear (autovalores, condicionamento).",
                                "Computação: Programação Numérica e Machine Learning (otimizadores).",
                                "Física: Mecânica das Estruturas (modelagem de treliças).",
                                "Estatística: Análise de Sensibilidade e Monte Carlo para robustez."
                              ],
                              "realWorldApplication": "Em projetos de edifícios altos ou pontes, otimizar estruturas para minimizar custos de material e tempo de construção, garantindo convergência rápida do GD para iterações em tempo real durante simulações FEA, evitando designs subótimos ou inseguros."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Busca Linear",
                        "description": "Método unidimensional para determinar o tamanho ótimo do passo em algoritmos de otimização, garantindo redução suficiente na função objetivo ao longo de uma direção de busca.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Entender métodos de busca linear exatos e inexatos",
                            "description": "Descrever buscas exatas (minimização exata da função ao longo da linha) e inexatos como backtracking ou Wolfe, incluindo condições de aceitação como Armijo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Busca Linear",
                                  "subSteps": [
                                    "Defina busca linear como a minimização de uma função univariada φ(α) = f(x + αd) ao longo da direção d.",
                                    "Explique o papel da busca linear em algoritmos de otimização sem restrições, como gradiente descendente.",
                                    "Identifique quando a busca linear é necessária: para determinar o tamanho do passo ótimo.",
                                    "Diferencie busca linear de outras técnicas de otimização.",
                                    "Revise derivadas e condições de otimalidade para funções univariadas."
                                  ],
                                  "verification": "Resuma em um parágrafo os fundamentos e desenhe um gráfico simples de φ(α).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Otimização Não Linear (ex: Nocedal & Wright)",
                                    "Papel e lápis para gráficos",
                                    "Software como MATLAB ou Python (NumPy)"
                                  ],
                                  "tips": "Comece com exemplos visuais de funções unimodais para intuitivamente entender o problema.",
                                  "learningObjective": "Entender o conceito e o propósito da busca linear em otimização.",
                                  "commonMistakes": [
                                    "Confundir busca linear com otimização global.",
                                    "Ignorar a unimodalidade da função φ(α)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Métodos de Busca Linear Exatos",
                                  "subSteps": [
                                    "Descreva a busca exata: encontrar α* tal que φ'(α*) = 0 exatamente.",
                                    "Analise métodos como dicotomia, seção áurea e interpolação cúbica para minimização exata.",
                                    "Implemente um exemplo simples de busca por interpolação cúbica em código.",
                                    "Discuta convergência e custo computacional dos métodos exatos.",
                                    "Resolva um problema numérico manualmente para uma função quadrática."
                                  ],
                                  "verification": "Implemente e execute código para minimizar φ(α) = (α-2)^2 + sin(α), confirmando α* ≈ 2.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com SciPy.optimize",
                                    "Exemplos numéricos de livros de otimização",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use funções conhecidas como mínimo para validar implementações.",
                                  "learningObjective": "Dominar técnicas para minimização exata univariada.",
                                  "commonMistakes": [
                                    "Assumir que métodos exatos são sempre eficientes.",
                                    "Erros em derivação da interpolação cúbica."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Métodos de Busca Linear Inexatos",
                                  "subSteps": [
                                    "Explique backtracking: inicia com α=1 e reduz por fator β até satisfazer Armijo.",
                                    "Detalhe condição de Armijo: φ(α) ≤ φ(0) + c α φ'(0), com 0<c<1.",
                                    "Estude condições de Wolfe: Armijo + φ'(α) ≥ σ φ'(0), com 0<σ<c.",
                                    "Compare backtracking e Wolfe em termos de robustez e eficiência.",
                                    "Implemente backtracking para uma função não quadrática."
                                  ],
                                  "verification": "Aplique backtracking a φ(α) = α^4 - 2α^2 + α e verifique satisfação de Armijo.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python/Jupyter Notebook",
                                    "Artigos sobre condições de Wolfe",
                                    "Gráficos de φ(α) via Matplotlib"
                                  ],
                                  "tips": "Teste com c=10^-4 e β=0.5 para valores padrão realistas.",
                                  "learningObjective": "Compreender e aplicar critérios de aceitação inexatos.",
                                  "commonMistakes": [
                                    "Escolher parâmetros c e σ inadequados.",
                                    "Confundir Armijo (decréscimo) com Wolfe (curvatura)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Métodos e Aplicar em Contexto",
                                  "subSteps": [
                                    "Compare exatos vs. inexatos: precisão vs. velocidade e robustez.",
                                    "Discuta trade-offs em problemas de engenharia civil (ex: otimização estrutural).",
                                    "Integre busca linear em um algoritmo de gradiente descendente simples.",
                                    "Avalie numericamente: execute testes com diferentes funções e meça iterações/tempo.",
                                    "Registre lições aprendidas sobre escolha de método."
                                  ],
                                  "verification": "Gere tabela comparativa de desempenho para 3 funções teste.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Jupyter Notebook para benchmarks",
                                    "Funções teste: Rosenbrock, Himmelblau"
                                  ],
                                  "tips": "Use timers em código para medir eficiência real.",
                                  "learningObjective": "Selecionar e justificar métodos de busca linear apropriados.",
                                  "commonMistakes": [
                                    "Ignorar sensibilidade a ruído numérico em exatos.",
                                    "Subestimar custo de derivadas em inexatos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em otimização de uma treliça civil, minimize f(x) = peso + penalidade por deslocamento usando gradiente descendente com busca linear inexata (Wolfe) para determinar α em cada iteração, garantindo convergência rápida mesmo com funções não suaves.",
                              "finalVerifications": [
                                "Descreva verbalmente diferenças entre buscas exatas e inexatas.",
                                "Implemente backtracking e verifique Armijo em um exemplo dado.",
                                "Explique condições Wolfe e por que elas melhoram backtracking.",
                                "Compare número de avaliações de função em exato vs. inexato para φ(α) não quadrática.",
                                "Aplique em mini-problema de gradiente descendente e confirme redução de f.",
                                "Liste prós/contras de cada método em tabela."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de conceitos fundamentais (exato vs. inexato).",
                                "Correta derivação e implementação de condições Armijo/Wolfe.",
                                "Qualidade dos códigos e resultados numéricos (convergência verificada).",
                                "Análise comparativa profunda com evidências empíricas.",
                                "Aplicação contextual a problemas de engenharia.",
                                "Clareza em verificações e exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo univariado e análise numérica.",
                                "Programação: Implementação de algoritmos em Python/MATLAB.",
                                "Engenharia Civil: Otimização de estruturas e análise finita.",
                                "Física: Modelagem de energia potencial em sistemas estruturais."
                              ],
                              "realWorldApplication": "Na análise e projeto de pontes ou edifícios, usa-se busca linear inexata em solvers de otimização para minimizar custos sob cargas variáveis, acelerando iterações em software como ANSYS ou códigos personalizados, garantindo designs eficientes e seguros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Implementar busca linear com backtracking",
                            "description": "Codificar um algoritmo de backtracking em conjunto com gradiente descendente, testando em funções quadráticas e não-lineares para otimização irrestrita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Gradiente Descendente e Busca Linear",
                                  "subSteps": [
                                    "Estude a fórmula do gradiente descendente: x_{k+1} = x_k - α ∇f(x_k), onde α é o tamanho do passo.",
                                    "Entenda a busca linear: encontrar α que minimize f(x_k - α ∇f(x_k)) ao longo da direção de descida.",
                                    "Revise condições de Wolfe para backtracking: Armijo e curvatura.",
                                    "Implemente uma função para calcular gradiente numérico ou analítico.",
                                    "Teste com uma função simples como f(x) = x²."
                                  ],
                                  "verification": "Execute testes unitários que confirmem o cálculo correto do gradiente em funções conhecidas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Otimização Numérica (Nocedal & Wright)",
                                    "Python/Jupyter Notebook",
                                    "Biblioteca NumPy"
                                  ],
                                  "tips": "Use gradiente analítico quando possível para precisão; numérico para prototipagem rápida.",
                                  "learningObjective": "Compreender os componentes matemáticos e o papel da busca linear no gradiente descendente.",
                                  "commonMistakes": [
                                    "Confundir direção de descida com gradiente (lembre: -∇f)",
                                    "Ignorar normalização da direção",
                                    "Não verificar Lipschitz para condições de Wolfe"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Gradiente Descendente com Tamanho de Passo Fixo",
                                  "subSteps": [
                                    "Defina uma classe ou função para o otimizador GD com α fixo (ex: 0.01).",
                                    "Crie um loop de iterações com critério de parada (tolerância em norma do gradiente ou max_iter).",
                                    "Registre histórico de função, gradiente e iterações.",
                                    "Teste em função quadrática f(x,y) = (x-1)² + (y-2)².",
                                    "Plote convergência para visualizar."
                                  ],
                                  "verification": "O algoritmo converge para o mínimo conhecido (ex: [1,2]) com erro < 1e-6 em < 100 iterações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "NumPy",
                                    "Matplotlib para plots",
                                    "Exemplos de código de GD online"
                                  ],
                                  "tips": "Sempre normalize o gradiente se a função for mal-condicionada.",
                                  "learningObjective": "Codificar um GD funcional com passo fixo para baseline.",
                                  "commonMistakes": [
                                    "Passo fixo muito grande causando divergência",
                                    "Critério de parada muito frouxo",
                                    "Não logar histórico para debug"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Algoritmo de Backtracking para Busca Linear",
                                  "subSteps": [
                                    "Defina parâmetros iniciais: α0 = 1, ρ = 0.5 (backtrack factor), c = 1e-4 (Armijo).",
                                    "Em uma iteração: comece com α = α0; enquanto f(x - α d) > f(x) - c α ||d||², α *= ρ.",
                                    "Implemente verificação de condição de Armijo (suficiente decrease).",
                                    "Opcional: adicione condição de curvatura Wolfe.",
                                    "Teste isoladamente com direção d fixa."
                                  ],
                                  "verification": "Backtracking reduz α até satisfazer Armijo em 80% das tentativas simuladas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Pseudocódigo de Nocedal",
                                    "NumPy para vetores"
                                  ],
                                  "tips": "Escolha ρ entre 0.1-0.5; α0 grande acelera mas pode backtrack mais.",
                                  "learningObjective": "Dominar o backtracking para tamanhos de passo adaptativos.",
                                  "commonMistakes": [
                                    "Erro na norma: use ||∇f|| ou ||d||?",
                                    "c muito pequeno causando backtracks infinitos",
                                    "Não testar com α0 superestimado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Backtracking no Gradiente Descendente",
                                  "subSteps": [
                                    "Modifique o GD para chamar backtracking em cada iteração: d = -∇f(x), α via backtrack.",
                                    "Atualize x += α * d.",
                                    "Adicione logs para α aceito por iteração.",
                                    "Teste em função quadrática e compare com passo fixo.",
                                    "Ajuste hiperparâmetros para convergência ótima."
                                  ],
                                  "verification": "Código converge mais rápido que GD fixo em pelo menos 20% das iterações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Matplotlib"
                                  ],
                                  "tips": "Monitore α médio; se muito pequeno, ajuste α0 ou c.",
                                  "learningObjective": "Criar um otimizador completo GD + backtracking.",
                                  "commonMistakes": [
                                    "Esquecer de atualizar f e ∇f após linha de busca",
                                    "d = ∇f ao invés de -∇f",
                                    "Loop infinito sem max_backtracks"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar em Funções Quadráticas e Não-Lineares",
                                  "subSteps": [
                                    "Defina f1 quadrática: Rosenbrock f(x,y) = 100(y-x²)² + (1-x)² (quase quadrática).",
                                    "Defina f2 não-linear: Himmelblau f(x,y) = (x² + y - 11)² + (x + y² - 7)².",
                                    "Execute GD-backtrack de múltiplos pontos iniciais.",
                                    "Compare métricas: iterações, α final, tempo CPU.",
                                    "Plote trajetórias e superfícies de contorno."
                                  ],
                                  "verification": "Convergência confirmada para mínimos conhecidos em ambas funções de x0 aleatórios.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "NumPy, Matplotlib, SciPy para mínimos conhecidos"
                                  ],
                                  "tips": "Use seed para reprodutibilidade; teste 10 runs por função.",
                                  "learningObjective": "Validar robustez em problemas variados.",
                                  "commonMistakes": [
                                    "Pontos iniciais ruins causando armadilhas locais",
                                    "Não plotar para inspecionar trajetórias",
                                    "Ignorar escala das funções"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimizar dimensões de uma viga em concreto armado: minimize custo f(largura, altura) = c1*largura*altura + c2*(altura)^2 sujeito a gradientes de tensão, usando GD-backtrack para encontrar seção ótima a partir de estimativa inicial.",
                              "finalVerifications": [
                                "Código roda sem erros em funções quadráticas e não-lineares.",
                                "Converge para mínimos conhecidos com tol < 1e-6.",
                                "Backtracking ativa em >50% das iterações com redução média de α >0.1.",
                                "Histórico de plots mostra trajetórias suaves.",
                                "Tempo de execução <5s para 1000 iterações.",
                                "Testes unitários passam para gradiente e backtrack isolados."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: condições de Armijo implementadas precisamente.",
                                "Eficiência: <20% mais iterações que métodos benchmark.",
                                "Robustez: converge de 90% dos x0 aleatórios.",
                                "Código limpo: modular, comentado, com funções reutilizáveis.",
                                "Análise: relatório com plots e métricas comparativas.",
                                "Inovação: extensão opcional como momentum."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e análise numérica.",
                                "Programação: OOP em Python, testes unitários com pytest.",
                                "Engenharia Civil: Otimização de estruturas e custos.",
                                "Estatística: Análise de convergência e sensibilidade.",
                                "Física: Modelagem de gradientes em campos de potencial."
                              ],
                              "realWorldApplication": "Em engenharia civil, otimizar projetos de pontes ou edifícios minimizando material/custo enquanto satisfaz tensões, usando GD-backtrack para ajustes iterativos em parâmetros geométricos durante simulações FEM."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Aplicar em combinação com métodos multidimensionais",
                            "description": "Integrar busca linear em gradiente descendente para problemas multivariados, analisando eficiência computacional em contextos de engenharia como ajuste de curvas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Gradiente Descendente e Busca Linear",
                                  "subSteps": [
                                    "Estude a fórmula do gradiente descendente: x_{k+1} = x_k - α ∇f(x_k), onde α é o step size.",
                                    "Analise métodos de busca linear: busca exata (minimizar f(x_k + α d_k)) vs. inexata (Armijo, Wolfe).",
                                    "Compare GD com step size fixo vs. adaptativo via busca linear em termos de convergência.",
                                    "Implemente um exemplo unidimensional simples em Python para visualizar iterações.",
                                    "Discuta limitações em problemas multivariados, como escolha inadequada de α."
                                  ],
                                  "verification": "Implemente e plote 10 iterações de GD com e sem busca linear em uma função quadrática; verifique redução no valor da função.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Notebook Jupyter",
                                    "Referência: Nocedal & Wright 'Numerical Optimization' capítulo 3"
                                  ],
                                  "tips": "Use funções built-in como scipy.optimize.line_search para prototipagem rápida.",
                                  "learningObjective": "Compreender como a busca linear melhora a escolha do step size no GD.",
                                  "commonMistakes": "Confundir direção de descida (gradiente negativo) com busca linear; ignorar condições de Wolfe."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Integrar Busca Linear no Algoritmo de Gradiente Descendente",
                                  "subSteps": [
                                    "Defina o algoritmo híbrido: compute ∇f(x_k), direção d_k = -∇f(x_k), então α_k via busca linear.",
                                    "Implemente busca linear inexata com regra de Armijo: f(x_k + α d_k) ≤ f(x_k) + c1 α ∇f(x_k)^T d_k.",
                                    "Teste em função bivariada como Rosenbrock: f(x,y) = (1-x)^2 + 100(y-x^2)^2.",
                                    "Ajuste parâmetros: c1=0.0001, β=0.5 para backtracking.",
                                    "Registre histórico de α_k e ||∇f|| para análise de convergência."
                                  ],
                                  "verification": "Código roda sem erros e converge em <50 iterações para Rosenbrock com tolerância 1e-6.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python/NumPy/SciPy",
                                    "Função Rosenbrock implementada",
                                    "Gráficos de convergência"
                                  ],
                                  "tips": "Comece com α inicial=1; backtrack até satisfazer Armijo para estabilidade.",
                                  "learningObjective": "Desenvolver algoritmo GD com line search para otimização multivariada.",
                                  "commonMistakes": "Escolha de c1 muito pequeno (backtracking excessivo) ou grande (passos instáveis)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar para Problemas Multivariados e Testar Eficiência",
                                  "subSteps": [
                                    "Gere problema sintético multivariado (d=10 vars) com f(x) = ||Ax - b||^2 + ruído.",
                                    "Compare tempo de CPU e iterações: GD fixo α vs. GD + line search.",
                                    "Meça flops por iteração: gradiente O(nd^2), line search O(n iterações * nd).",
                                    "Plote curvas de convergência: f(k) vs. k e tempo cumulativo.",
                                    "Analise trade-offs: line search aumenta custo por iteração mas acelera convergência global."
                                  ],
                                  "verification": "Relatório com tabelas: GD fixo demora 2x mais iterações; line search reduz f em 90% mais rápido.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com timeit/NumPy",
                                    "Matrizes A (10x10), b aleatórias",
                                    "Profiler como %timeit"
                                  ],
                                  "tips": "Use vetoresização NumPy para eficiência; limite max iterações line search=20.",
                                  "learningObjective": "Quantificar ganhos computacionais da integração em alta dimensionalidade.",
                                  "commonMistakes": "Não normalizar dados (gradientes explodem); ignorar custo de line search em d grande."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Contexto de Engenharia Civil: Ajuste de Curvas",
                                  "subSteps": [
                                    "Colete dados reais/simulados: tensão vs. deformação em viga (multivariado: parâmetros elásticos).",
                                    "Formule minimização: min θ ||dados - modelo(θ)||^2, onde modelo é polinomial/multivariado.",
                                    "Aplique GD + line search para estimar θ (ex: módulos Young, Poisson em 3D).",
                                    "Valide ajuste: R^2 >0.95, resíduos aleatórios.",
                                    "Analise eficiência: tempo para convergência vs. métodos alternativos como Levenberg-Marquardt."
                                  ],
                                  "verification": "Modelo ajustado reproduz dados com erro <5%; código convergente em <100 iterações.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Dados CSV de testes estruturais",
                                    "Python/Pandas/Matplotlib",
                                    "Modelo físico: σ=ε E(θ)"
                                  ],
                                  "tips": "Pré-condicione gradiente com Hessiana diagonal para aceleração.",
                                  "learningObjective": "Aplicar técnica em problema real de engenharia civil.",
                                  "commonMistakes": "Sobreajuste (poucos dados); não penalizar θ grandes (adicionar regularização L2)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Eficiência Computacional e Otimizar",
                                  "subSteps": [
                                    "Calcule complexidade: O(n d^2) por gradiente + O(max_iter_ls * n d) por line search.",
                                    "Teste escalabilidade: d=5,50,100; meça tempo wall-clock.",
                                    "Otimize: use CG aproximado para line search ou L-BFGS para quasi-Newton.",
                                    "Compare com bibliotecas: scipy.optimize.minimize(method='BFGS') vs. custom.",
                                    "Documente recomendações: use line search quando d<50 e f não-quádruple."
                                  ],
                                  "verification": "Gráfico de tempo vs. d mostra line search eficiente até d=50; relatório escrito.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Benchmark scripts",
                                    "Relatório LaTeX/Markdown"
                                  ],
                                  "tips": "Profile com cProfile para bottlenecks reais.",
                                  "learningObjective": "Avaliar e otimizar eficiência em contextos de engenharia.",
                                  "commonMistakes": "Medir apenas iterações, ignorar flops/tempo real; testes em funções fáceis."
                                }
                              ],
                              "practicalExample": "Em projeto de ponte, ajuste parâmetros de modelo constitutivo (E, ν) minimizando erro entre dados experimentais de deformação e simulação via GD + busca linear Armijo, convergindo em 40 iterações vs. 150 com α fixo.",
                              "finalVerifications": [
                                "Algoritmo implementado converge para Rosenbrock e problema multivariado em <100 iterações.",
                                "Análise computacional mostra redução de 50% no tempo total para d=10.",
                                "Aplicação em ajuste de curvas atinge R^2 >0.95 com resíduos <5%.",
                                "Código modular e comentado, roda em <10s por execução.",
                                "Relatório compara eficiência com benchmarks padrão.",
                                "Testes de sensibilidade a parâmetros line search confirmam robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão: norma gradiente final <1e-6.",
                                "Eficiência: tempo total < GD fixo em 70% dos casos.",
                                "Implementação: código limpo, vetorizado, com funções reutilizáveis.",
                                "Análise: gráficos e métricas quantitativas claras.",
                                "Aplicação: modelo ajustado fisicamente plausível (ex: E~200GPa aço).",
                                "Robustez: funciona com ruído ±10% nos dados."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Uso de NumPy/SciPy para otimização.",
                                "Estatística: Análise de resíduos e validação de ajuste (R^2, AIC).",
                                "Física/Mecânica: Modelos constitutivos em engenharia de materiais.",
                                "Ciência de Dados: Regressão não-linear e machine learning básico.",
                                "Gestão de Projetos: Avaliação custo-benefício computacional."
                              ],
                              "realWorldApplication": "Otimização de parâmetros em simulações FEM para estruturas civis, reduzindo tempo de calibração de semanas para horas, permitindo iterações rápidas em design de pontes e edifícios resistentes a sismos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Método de Newton",
                        "description": "Algoritmo de segunda ordem para otimização sem restrições, utilizando a Hessiana da função para aproximação quadrática e aceleração da convergência quadrática perto do mínimo.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Compreender a base quadrática do método de Newton",
                            "description": "Explicar a expansão de Taylor de segunda ordem, direção de busca dada pela solução do sistema linear com a matriz Hessiana e condições para mínimo local (Hessiana positiva definida).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Expansão de Taylor de Segunda Ordem",
                                  "subSteps": [
                                    "Revise o teorema da expansão de Taylor para funções de variável real multivariável até segunda ordem.",
                                    "Identifique os termos: função no ponto atual, gradiente (primeira derivada) e Hessiana (segunda derivada).",
                                    "Escreva a fórmula matemática: f(x + d) ≈ f(x) + ∇f(x)^T d + (1/2) d^T H(x) d.",
                                    "Discuta a aproximação quadrática como modelo local da função objetivo.",
                                    "Pratique com uma função unidimensional simples para visualizar a parábola tangente."
                                  ],
                                  "verification": "Derive corretamente a expansão para uma função dada, como f(x,y) = x² + y², e explique cada termo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Cálculo Multivariável (ex: Apostol), papel e caneta, calculadora simbólica (Wolfram Alpha).",
                                  "tips": "Visualize graficamente a função e sua aproximação para melhor intuição.",
                                  "learningObjective": "Compreender como a expansão de Taylor modela localmente a função como uma parábola.",
                                  "commonMistakes": "Confundir gradiente com Hessiana ou ignorar o fator 1/2 no termo quadrático."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Aproximação Quadrática no Método de Newton",
                                  "subSteps": [
                                    "Partindo da expansão de Taylor, defina o modelo quadrático m(d) = f(x) + ∇f(x)^T d + (1/2) d^T H(x) d.",
                                    "Explique que o objetivo é minimizar m(d) para encontrar a direção de busca d.",
                                    "Mostre que o mínimo de m(d) ocorre quando ∇m(d) = 0, levando a H(x) d = -∇f(x).",
                                    "Discuta o sistema linear resultante e sua solução.",
                                    "Implemente numericamente para uma função teste em software."
                                  ],
                                  "verification": "Resolva o sistema H d = -∇f para uma Hessiana 2x2 simples e verifique se minimiza o modelo quadrático.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python (NumPy/SciPy), exemplos de funções quadráticas.",
                                  "tips": "Use funções com Hessiana conhecida (ex: f(x) = (1/2)x^T A x) para validação.",
                                  "learningObjective": "Derivar a direção de busca d como solução do sistema linear envolvendo a Hessiana.",
                                  "commonMistakes": "Esquecer o sinal negativo em H d = -∇f ou assumir Hessiana identidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Condições para Mínimo Local",
                                  "subSteps": [
                                    "Defina matriz positiva definida: todos autovalores positivos ou x^T H x > 0 para x ≠ 0.",
                                    "Explique que se H(x) é positiva definida, m(d) tem mínimo único em d*.",
                                    "Discuta condições de segunda ordem para mínimo local da função original.",
                                    "Teste positividade com autovalores ou forma quadrática.",
                                    "Explore casos onde Hessiana não é PD (sela ou máximo)."
                                  ],
                                  "verification": "Para uma Hessiana dada, compute autovalores e conclua se garante mínimo local.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matriz de Hessiana exemplos, software para autovalores (MATLAB eig ou Python linalg.eig).",
                                  "tips": "Lembre: Hessiana PD implica convexidade local, essencial para convergência quadrática.",
                                  "learningObjective": "Identificar quando a aproximação quadrática garante um mínimo local válido.",
                                  "commonMistakes": "Confundir positiva definida com semi-definida ou ignorar autovalores negativos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Conceitos no Contexto do Método de Newton",
                                  "subSteps": [
                                    "Resuma o algoritmo: compute ∇f e H, resolva H d = -∇f, atualize x ← x + α d.",
                                    "Discuta line search para α quando Hessiana não PD.",
                                    "Compare com gradiente descendente (H = I).",
                                    "Simule iterações em uma função não linear.",
                                    "Avalie convergência quadrática sob condições ideais."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o fluxo completo e condições de parada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código pronto de Método de Newton em Python, gráficos de convergência.",
                                  "tips": "Sempre verifique Hessiana PD antes de confiar na direção.",
                                  "learningObjective": "Conectar expansão quadrática, direção e condições em uma visão unificada do método.",
                                  "commonMistakes": "Subestimar necessidade de line search em problemas reais."
                                }
                              ],
                              "practicalExample": "Considere minimizar f(x,y) = x² + 10 sin(y) em x0=(1,0). Compute ∇f=(2x, 10 cos(y)), H=diag(2, -10 sin(y)). No ponto inicial, H não PD (autovalor negativo), ilustração de falha; ajuste para ponto onde PD.",
                              "finalVerifications": [
                                "Deriva corretamente a expansão de Taylor de 2ª ordem para função multivariável.",
                                "Resolve H d = -∇f e interpreta d como direção de descida.",
                                "Verifica positividade definida da Hessiana via autovalores.",
                                "Explica condições para mínimo local e convergência quadrática.",
                                "Simula uma iteração completa do método.",
                                "Discute limitações quando Hessiana não PD."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação da expansão e sistema linear (30%).",
                                "Clareza na explicação de conceitos como Hessiana PD (25%).",
                                "Capacidade de aplicar em exemplo numérico (20%).",
                                "Identificação correta de condições e erros comuns (15%).",
                                "Integração conceitual no método de Newton (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Multivariável: Expansões de Taylor e derivadas parciais.",
                                "Álgebra Linear: Autovalores, definitude de matrizes e sistemas lineares.",
                                "Programação Numérica: Implementação em Python/MATLAB para otimização.",
                                "Engenharia Civil: Otimização de estruturas (ex: minimizar peso sob restrições)."
                              ],
                              "realWorldApplication": "No design de vigas e lajes em Engenharia Civil, o método de Newton otimiza formas para mínimo peso/material sob cargas, usando aproximações quadráticas para eficiência computacional em softwares como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Implementar método de Newton para funções escalares e vetoriais",
                            "description": "Programar o cálculo numérico de derivadas de segunda ordem e resolução de sistemas lineares via decomposição LU ou Cholesky em MATLAB, aplicando a equações não-lineares da engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar teoria do método de Newton para funções escalares e vetoriais",
                                  "subSteps": [
                                    "Estude a formulação do método de Newton para funções escalares: x_{k+1} = x_k - f(x_k)/f'(x_k).",
                                    "Analise a extensão para funções vetoriais: x_{k+1} = x_k - H^{-1} ∇f(x_k), onde H é a Hessiana.",
                                    "Identifique a necessidade de derivadas numéricas quando analíticas não estão disponíveis.",
                                    "Revise condições de convergência quadrática e critérios de parada (ex: ||∇f|| < ε).",
                                    "Anote exemplos de equações não-lineares da engenharia civil, como equilíbrio de forças em estruturas."
                                  ],
                                  "verification": "Resuma em um documento as equações chave e condições de convergência, com pelo menos 3 exemplos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação MATLAB",
                                    "Livro de Otimização Numérica (ex: Nocedal & Wright)",
                                    "Notas de aula sobre Método de Newton"
                                  ],
                                  "tips": "Use diagramas para visualizar iterações escalar vs. vetorial.",
                                  "learningObjective": "Compreender os fundamentos teóricos para implementação precisa.",
                                  "commonMistakes": [
                                    "Confundir gradiente com Hessiana",
                                    "Ignorar não-convergência em pontos singulares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar cálculo numérico de derivadas de primeira e segunda ordem em MATLAB",
                                  "subSteps": [
                                    "Defina função para gradiente numérico forward-difference: ∇f ≈ (f(x+h e_i) - f(x))/h.",
                                    "Implemente Hessiana numérica via diferenças finitas centrais para precisão O(h^2).",
                                    "Escreva função genérica approxGradient(f, x, h) e approxHessian(f, x, h).",
                                    "Teste com função simples f(x) = x^2 em 1D e 2D para validar resultados.",
                                    "Ajuste h dinamicamente (ex: h = sqrt(eps) * max(1, ||x||)) para estabilidade numérica."
                                  ],
                                  "verification": "Execute testes unitários; compare com derivadas analíticas (erro < 1e-6).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Editor",
                                    "Funções de teste pré-definidas (ex: rosenbrock.m)"
                                  ],
                                  "tips": "Vectorize computações com meshgrid para eficiência em múltiplas dimensões.",
                                  "learningObjective": "Dominar aproximações numéricas robustas para gradiente e Hessiana.",
                                  "commonMistakes": [
                                    "Escolha inadequada de h levando a erros de arredondamento",
                                    "Não normalizar direção em testes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar resolução de sistemas lineares via decomposição LU ou Cholesky",
                                  "subSteps": [
                                    "Implemente decomposição LU com pivotamento parcial usando eliminação gaussiana.",
                                    "Adapte para Cholesky quando Hessiana é simétrica definida positiva: A = L L^T.",
                                    "Escreva função luSolve(A, b) e choleskySolve(A, b) com verificação de simetria.",
                                    "Integre detecção automática: use Cholesky se spd, senão LU.",
                                    "Teste com matrizes de Hessiana de exemplos quadráticos, verificando ||A x - b|| < 1e-10."
                                  ],
                                  "verification": "Resolva Ax = b para A conhecida; valide solução exata.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB com funções lu() e chol() para referência",
                                    "Exemplos de matrizes de teste"
                                  ],
                                  "tips": "Monitore cond(A) para singularidades; adicione regularização se necessário.",
                                  "learningObjective": "Capacitar resolução eficiente de sistemas lineares em otimizações.",
                                  "commonMistakes": [
                                    "Pivotamento esquecido causando instabilidade",
                                    "Assumir sempre simetria positiva"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e implementar o algoritmo completo do método de Newton em MATLAB",
                                  "subSteps": [
                                    "Defina função newtonMethod(f, x0, tol, maxIter, h) integrando gradiente, Hessiana e solver.",
                                    "Implemente loop: compute ∇f e H, resolva H d = -∇f, atualize x += d, cheque critério de parada.",
                                    "Adicione logging de iterações (k, ||∇f||, ||d||) e plot de convergência.",
                                    "Inclua tratamento de falhas: backtracking line search se ||∇f|| não diminui.",
                                    "Teste com função escalar (ex: f(x)=x^4 - 2x^2 + x) e vetorial (Rosenbrock)."
                                  ],
                                  "verification": "Execute 5 iterações; confirme convergência para mínimo conhecido.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Funções dos steps anteriores",
                                    "Funções benchmark como rosenbrock.m"
                                  ],
                                  "tips": "Use global tol=1e-8; maxIter=100 para segurança.",
                                  "learningObjective": "Integrar componentes em algoritmo funcional e robusto.",
                                  "commonMistakes": [
                                    "Loop infinito sem maxIter",
                                    "Não logar para debug"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e validar em equações não-lineares da engenharia civil",
                                  "subSteps": [
                                    "Defina problema: minimize energia potencial em viga sob carga (f(x) com não-linearidades geométricas).",
                                    "Implemente f_obj como função vetorial representando equilíbrio não-linear.",
                                    "Execute newtonMethod em x0 inicial (ex: configuração reta da viga).",
                                    "Compare solução com método analítico ou FEM simples; plote deformação.",
                                    "Analise sensibilidade a h e tol; documente número de iterações."
                                  ],
                                  "verification": "Solução converge em <20 iterações; residual <1e-6; plots mostram mínimo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Modelo de viga não-linear em MATLAB",
                                    "Software FEM para validação (opcional)"
                                  ],
                                  "tips": "Escolha x0 fisicamente realista para aceleração de convergência.",
                                  "learningObjective": "Aplicar método a contextos reais de engenharia civil.",
                                  "commonMistakes": [
                                    "x0 inviável causando Hessiana indefinida",
                                    "Ignorar unidades no problema físico"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimizar o perfil de uma viga cantilever sob carga distribuída não-linear, minimizando energia total f(x) = ∫ (deformação)^2 dx + penalidade geométrica, onde x são coeficientes de spline para a forma da viga. Implemente em MATLAB para encontrar configuração ótima com tensão máxima < limite de material.",
                              "finalVerifications": [
                                "Algoritmo converge em <30 iterações para testes padrão.",
                                "Erro em gradiente/Hessiana numérica <1e-8 vs. analítica.",
                                "Sistemas lineares resolvidos com residual ||H d + ∇f|| <1e-12.",
                                "Aplicação em viga: deformação final plausível e plots de convergência suaves.",
                                "Código roda sem erros em MATLAB R2020+; tempo total <10s por run.",
                                "Logs mostram redução quadrática em ||∇f||."
                              ],
                              "assessmentCriteria": [
                                "Precisão: convergência ao mínimo com tol=1e-10.",
                                "Eficiência: <20 iterações para dim<=10.",
                                "Robustez: lida com Hessiana mal-condicionada via backtracking.",
                                "Modularidade: funções separadas e reutilizáveis.",
                                "Documentação: comentários inline e exemplo de uso.",
                                "Validação: testes unitários passam 100%.",
                                "Aplicação contextual: solução engenharia civil coerente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e álgebra linear numérica.",
                                "Programação: Desenvolvimento de software científico em MATLAB.",
                                "Engenharia Mecânica: Análise estrutural não-linear.",
                                "Física: Princípios de equilíbrio e energia potencial.",
                                "Estatística: Análise de sensibilidade e Monte Carlo para robustez."
                              ],
                              "realWorldApplication": "Na engenharia civil, o método de Newton é usado em software como ANSYS ou SAP2000 para otimizar designs de pontes e edifícios, resolvendo equilíbrios não-lineares em grandes deformações ou materiais com histerese, reduzindo custos e melhorando segurança estrutural."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Avaliar limitações e modificações",
                            "description": "Identificar problemas como Hessiana indefinida, implementar modificações como quasi-Newton (BFGS) e comparar com gradiente descendente em termos de iterações e precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar limitações do Método de Newton",
                                  "subSteps": [
                                    "Revisar a fórmula do Método de Newton e o papel da Hessiana na direção de busca.",
                                    "Analisar casos em que a Hessiana é indefinida ou semi-definida, levando a direções não descendentes.",
                                    "Estudar o alto custo computacional de calcular e inverter a Hessiana em dimensões elevadas.",
                                    "Exemplificar com funções não convexas, como a função Rosenbrock, onde o método diverge.",
                                    "Discutir necessidade de line search ou trust region para mitigar falhas."
                                  ],
                                  "verification": "Listar e explicar pelo menos 3 limitações com exemplos matemáticos ou numéricos simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Notas de aula sobre otimização, livro 'Numerical Optimization' de Nocedal & Wright (cap. 3), papel e caneta para derivações.",
                                  "tips": "Use gráficos de contorno para visualizar falhas da Hessiana indefinida.",
                                  "learningObjective": "Compreender as condições de falha do Método de Newton e suas implicações práticas.",
                                  "commonMistakes": "Confundir indefinição da Hessiana com erro numérico; ignorar impacto em problemas de grande escala."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar modificações quasi-Newton com foco em BFGS",
                                  "subSteps": [
                                    "Explicar métodos quasi-Newton como aproximação de segunda ordem sem Hessiana explícita.",
                                    "Derivar a atualização BFGS de rank-2, enfatizando preservação de curvatura positiva.",
                                    "Comparar BFGS com DFP e SR1 em termos de estabilidade e convergência superlinear.",
                                    "Implementar pseudocódigo para inicialização (B0 = I) e atualizações sucessivas.",
                                    "Analisar garantias teóricas de convergência global com line search."
                                  ],
                                  "verification": "Escrever pseudocódigo completo do BFGS e explicar uma atualização passo a passo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Referências teóricas (Nocedal & Wright, cap. 6), software como MATLAB ou Python para simulações iniciais.",
                                  "tips": "Comece com funções 1D para validar a atualização manualmente.",
                                  "learningObjective": "Dominar o algoritmo BFGS e suas vantagens sobre Newton puro.",
                                  "commonMistakes": "Esquecer normalização nos vetores de diferença; usar atualizações sem line search."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Método de Newton modificado e BFGS em código",
                                  "subSteps": [
                                    "Codificar Método de Newton com modificação (ex: modificar Hessiana para definida positiva via eigenvalues).",
                                    "Implementar BFGS completo com line search (Armijo) em Python/NumPy.",
                                    "Testar em função quadrática simples para validar contra solução analítica.",
                                    "Adicionar logging de Hessiana aproximada e passos em cada iteração.",
                                    "Debugar casos de indefinição usando decomposição espectral."
                                  ],
                                  "verification": "Executar código em uma função teste e confirmar convergência com erro < 1e-6.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python 3+, bibliotecas NumPy e SciPy, Jupyter Notebook, função teste (ex: Rosenbrock).",
                                  "tips": "Use print statements para inspecionar matrizes Bk em iterações iniciais.",
                                  "learningObjective": "Desenvolver implementação funcional e robusta de modificações quasi-Newton.",
                                  "commonMistakes": "Divisão por zero em atualizações; não clamp eigenvalues negativos na modificação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar BFGS/Newton modificado com Gradiente Descendente",
                                  "subSteps": [
                                    "Implementar Gradiente Descente com line search para baseline.",
                                    "Executar experimentos em múltiplas funções (quadráticas, Rosenbrock, Himmelblau).",
                                    "Medir métricas: número de iterações, precisão final, tempo de CPU.",
                                    "Gerar tabelas e gráficos de convergência (erro vs iteração).",
                                    "Analisar trade-offs: precisão vs custo computacional."
                                  ],
                                  "verification": "Produzir relatório com tabela comparativa mostrando superioridade do BFGS em iterações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Código dos passos anteriores, Matplotlib para plots, planilha para métricas.",
                                  "tips": "Fixe tolerância de convergência (1e-8) e máximo de iterações (1000) para fair comparison.",
                                  "learningObjective": "Avaliar quantitativamente vantagens das modificações em cenários reais.",
                                  "commonMistakes": "Comparar sem line search equivalente; ignorar dimensionalidade nas funções teste."
                                }
                              ],
                              "practicalExample": "Otimize a função Rosenbrock f(x,y) = 100(y - x²)² + (1 - x)², comum em modelagem de deformações em estruturas civis. Implemente Newton (com modificação para Hessiana), BFGS e GD; compare iterações até ||grad|| < 1e-6, mostrando BFGS convergindo em ~20 iterações vs 100+ do GD.",
                              "finalVerifications": [
                                "Identificar indefinição da Hessiana em uma função dada.",
                                "Implementar e executar BFGS corretamente em código.",
                                "Gerar tabela comparativa com GD mostrando menos iterações e maior precisão para BFGS.",
                                "Explicar verbalmente preservação de curvatura no BFGS.",
                                "Modificar Hessiana indefinida via eigenvalues e validar convergência.",
                                "Plotar curvas de convergência para 3 funções teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de limitações (80% cobertura dos principais problemas).",
                                "Corretude da implementação BFGS (convergência superlinear confirmada).",
                                "Qualidade da comparação quantitativa (métricas claras, gráficos legíveis).",
                                "Profundidade teórica (derivações e propriedades explicadas).",
                                "Robustez do código (trata indefinições, logging incluso).",
                                "Análise crítica de trade-offs (iterações vs custo computacional)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/NumPy.",
                                "Análise Numérica: Aproximações matriciais e decomposições.",
                                "Engenharia Computacional: Otimização em simulações FEM.",
                                "Estatística: Análise de convergência e variância em experimentos.",
                                "Matemática Aplicada: Álgebra linear para Hessianas."
                              ],
                              "realWorldApplication": "Na engenharia civil, otimizar dimensões de vigas ou treliças para minimizar peso/custo sob cargas dinâmicas, onde superfícies de energia são não convexas (Hessiana indefinida); BFGS acelera convergência em solvers de elementos finitos, reduzindo tempo de projeto de horas para minutos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.4",
                            "name": "Aplicar em problemas reais de otimização",
                            "description": "Resolver problemas de minimização irrestrita em engenharia civil, como otimização de parâmetros em modelos de estruturas, utilizando software numérico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema de otimização irrestrita",
                                  "subSteps": [
                                    "Identifique o problema real em engenharia civil, como minimizar o peso de uma treliça ajustando parâmetros geométricos.",
                                    "Defina a função objetivo f(x), derivada analítica ∇f(x) e Hessiana H(x).",
                                    "Colete dados iniciais e defina vetor inicial x0.",
                                    "Verifique se o problema é unimodal e suave para adequação ao Método de Newton.",
                                    "Documente suposições e unidades de medida."
                                  ],
                                  "verification": "Função objetivo, gradiente e Hessiana implementados e testados com valores conhecidos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Papel e lápis para esboços; software como MATLAB ou Python (NumPy) para prototipagem inicial.",
                                  "tips": "Comece com problemas de baixa dimensão (2-3 variáveis) para validação rápida.",
                                  "learningObjective": "Capacidade de traduzir problemas de engenharia em formulações matemáticas precisas de otimização.",
                                  "commonMistakes": "Ignorar não-diferenciabilidade da função ou escolher x0 longe do ótimo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o algoritmo do Método de Newton em software numérico",
                                  "subSteps": [
                                    "Escreva código para calcular ∇f(x) e H(x) numericamente ou analiticamente.",
                                    "Implemente a iteração: d_k = -H(x_k)^{-1} ∇f(x_k), x_{k+1} = x_k + d_k.",
                                    "Adicione critério de parada: ||∇f(x_k)|| < ε ou k > max_iter.",
                                    "Inclua tratamento de Hessiana não positiva definida (modificação de Levenberg-Marquardt se necessário).",
                                    "Teste com função quadrática simples para validar."
                                  ],
                                  "verification": "Código converge corretamente para função teste conhecida, como f(x) = x^2.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com NumPy, SciPy (para inversão de matrizes); ou MATLAB.",
                                  "tips": "Use solvers built-in como scipy.optimize.minimize(method='Newton-CG') para benchmark.",
                                  "learningObjective": "Desenvolver proficiência em codificação de algoritmos de otimização numérica.",
                                  "commonMistakes": "Não inverter corretamente a Hessiana ou ignorar singularidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o método ao problema de engenharia civil",
                                  "subSteps": [
                                    "Integre o modelo estrutural (ex: equações de equilíbrio de treliça) na função objetivo.",
                                    "Execute o algoritmo com x0 realista baseado em projeto preliminar.",
                                    "Monitore iterações: plote ∇f(x_k) e x_k vs. k.",
                                    "Registre histórico de convergência e valores de f(x_k).",
                                    "Ajuste parâmetros como ε ou step size se oscilações ocorrerem."
                                  ],
                                  "verification": "Otimização converge em <20 iterações com redução significativa em f(x).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Software FEM básico como FEniCS ou código customizado para modelo simples; Jupyter Notebook.",
                                  "tips": "Use visualizações (Matplotlib) para inspecionar trajetórias de otimização.",
                                  "learningObjective": "Aplicar Método de Newton em contextos reais de estruturas civis.",
                                  "commonMistakes": "x0 impraticável levando a não-convergência; negligenciar custos computacionais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e validar a solução",
                                  "subSteps": [
                                    "Compare solução ótima com análises manuais ou software comercial (ex: ANSYS).",
                                    "Calcule sensibilidade: impacto de pequenas variações em parâmetros.",
                                    "Avalie viabilidade prática: verifique se solução respeita limites físicos implícitos.",
                                    "Gere relatório com gráficos de convergência e métricas de performance.",
                                    "Teste robustez com ruído nos dados iniciais."
                                  ],
                                  "verification": "Solução reduz f(x) em >20% vs. x0 e atende critérios de engenharia.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software de plotagem (Matplotlib/Excel); normas ABNT para relatório.",
                                  "tips": "Documente tempo de CPU por iteração para escalabilidade futura.",
                                  "learningObjective": "Interpretar e validar resultados de otimização em cenários reais.",
                                  "commonMistakes": "Aceitar soluções sem verificação de gradiente zero ou mínimos locais."
                                }
                              ],
                              "practicalExample": "Otimizar dimensões (área de barras) de uma treliça plana de 10 nós para minimizar peso total, sujeito a minimização irrestrita da função energia potencial, usando Python/SciPy. Inicial x0 de seção uniforme 10 cm² converge para áreas otimizadas reduzindo peso em 15%.",
                              "finalVerifications": [
                                "Gradiente na solução final ||∇f(x*)|| < 10^{-6}.",
                                "Hessiana em x* positiva definida (autovalores >0).",
                                "Convergência em ≤15 iterações.",
                                "Solução física viável (áreas > área mínima de fabricação).",
                                "Comparação com método de gradiente descendente mostra superioridade de Newton.",
                                "Tempo total de execução <5 minutos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução (erro relativo <1%).",
                                "Eficiência computacional (iterações e tempo).",
                                "Qualidade do código (modular, comentado, reutilizável).",
                                "Análise de convergência documentada com plots.",
                                "Validação cruzada com benchmarks analíticos.",
                                "Relatório claro com interpretações de engenharia."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e álgebra linear (inversão de matrizes).",
                                "Programação: Desenvolvimento numérico em Python/MATLAB.",
                                "Mecânica das Estruturas: Modelagem de treliças e análise estática.",
                                "Gestão de Projetos: Avaliação de trade-offs custo vs. performance.",
                                "Estatística: Análise de sensibilidade e incertezas."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios, otimizar parâmetros de estruturas para minimizar material usado (reduzindo custos e impacto ambiental), como no design de treliças em viadutos onde o Método de Newton acelera iterações em software de engenharia, economizando semanas de projeto manual."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Otimização com Restrições",
                    "description": "Métodos de multiplicadores de Lagrange e penalização para problemas com restrições de igualdade e desigualdade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Método dos Multiplicadores de Lagrange para Restrições de Igualdade",
                        "description": "Formulação do problema de otimização com restrições de igualdade usando o Lagrangiano e condições de otimalidade de primeira ordem.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Formular o Lagrangiano",
                            "description": "Construir a função Lagrangiana a partir de uma função objetivo e restrições de igualdade, introduzindo multiplicadores de Lagrange associados a cada restrição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a Função Objetivo e as Restrições de Igualdade",
                                  "subSteps": [
                                    "Leia o problema de otimização e destaque a função objetivo f(x), que deve ser minimizada ou maximizada.",
                                    "Liste todas as restrições de igualdade g_i(x) = 0, onde i = 1 a m.",
                                    "Confirme que não há restrições de desigualdade; foque apenas em igualdades.",
                                    "Anote os multiplicadores λ_i associados a cada g_i(x).",
                                    "Esboce a forma geral: min/max f(x) s.a. g_i(x) = 0."
                                  ],
                                  "verification": "Verifique se você pode escrever claramente f(x) e todas as g_i(x) = 0 em um papel ou editor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Enunciado do problema de otimização"
                                  ],
                                  "tips": "Sempre use notação consistente: x como vetor de variáveis, g_i como funções escalares.",
                                  "learningObjective": "Compreender e extrair os componentes fundamentais do problema de otimização com restrições de igualdade.",
                                  "commonMistakes": [
                                    "Confundir função objetivo com restrições",
                                    "Esquecer de listar todos os multiplicadores λ_i antecipadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir os Multiplicadores de Lagrange",
                                  "subSteps": [
                                    "Para cada restrição g_i(x) = 0, associe um multiplicador λ_i (i = 1 a m).",
                                    "Entenda que λ_i penaliza violações da restrição i.",
                                    "Escreva os termos de penalidade: λ_i * g_i(x) para cada i.",
                                    "Confirme que há exatamente m multiplicadores para m restrições.",
                                    "Pense no Lagrangiano como L(x, λ) = f(x) + soma(λ_i g_i(x))."
                                  ],
                                  "verification": "Liste os pares (g_i, λ_i) e explique o papel de cada λ_i em uma frase.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de rascunho",
                                    "Tabela para mapear restrições e multiplicadores"
                                  ],
                                  "tips": "Comece com problemas simples com 1 restrição para praticar a associação.",
                                  "learningObjective": "Dominar a introdução conceitual e notacional dos multiplicadores de Lagrange.",
                                  "commonMistakes": [
                                    "Usar sinal errado no termo λ_i g_i (deve ser + para igualdades)",
                                    "Confundir número de λ_i com número de variáveis x"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Expressão Completa do Lagrangiano",
                                  "subSteps": [
                                    "Escreva L(x, λ) = f(x) + ∑_{i=1}^m λ_i g_i(x).",
                                    "Substitua as expressões explícitas de f(x) e g_i(x) na fórmula.",
                                    "Expanda todos os termos algébricos para forma explícita.",
                                    "Verifique dimensionalidade: L deve ser escalar em termos de x e λ.",
                                    "Simplifique expressões idênticas ou colete termos semelhantes."
                                  ],
                                  "verification": "Compare sua expressão de L com a fórmula padrão; ela deve coincidir simbolicamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como SymPy/MATLAB",
                                    "Exemplo de problema resolvido"
                                  ],
                                  "tips": "Use parênteses para agrupar termos e evite ambiguidades na soma.",
                                  "learningObjective": "Formular matematicamente o Lagrangiano de forma precisa e explícita.",
                                  "commonMistakes": [
                                    "Esquecer o sinal + antes da soma",
                                    "Não expandir funções compostas em f ou g_i"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Verificar a Formulação do Lagrangiano",
                                  "subSteps": [
                                    "Calcule o gradiente ∇L e confirme que inclui ∂f/∂x_j + ∑ λ_i ∂g_i/∂x_j.",
                                    "Substitua um ponto x factível (g_i(x)=0) e verifique se L(x,λ) = f(x).",
                                    "Teste com λ_i=0: L deve reduzir a f(x) sem restrições.",
                                    "Identifique se o problema é convexo (opcional para validação).",
                                    "Documente a formulação final em LaTeX ou texto formatado."
                                  ],
                                  "verification": "Resolva as condições de otimalidade ∂L/∂x_j = 0 e g_i=0 para um caso simples e confira.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de álgebra computacional",
                                    "Exemplos numéricos de otimização"
                                  ],
                                  "tips": "Sempre valide com um exemplo numérico pequeno para ganhar confiança.",
                                  "learningObjective": "Garantir que a formulação do Lagrangiano esteja correta e pronta para resolução.",
                                  "commonMistakes": [
                                    "Ignorar verificação de factibilidade",
                                    "Erros de derivação no gradiente"
                                  ]
                                }
                              ],
                              "practicalExample": "Problema: Minimize f(x,y) = x² + y² sujeito a g(x,y) = x + y - 1 = 0. Lagrangiano: L(x,y,λ) = x² + y² + λ(x + y - 1). Verificação: Em (0.5,0.5), g=0 e L=f=0.5.",
                              "finalVerifications": [
                                "Pode formular L corretamente para um problema com 2 restrições?",
                                "Identifica corretamente todos os λ_i e seus termos?",
                                "L reduz a f quando restrições são satisfeitas?",
                                "Consegue derivar ∇L sem erros?",
                                "Aplica a formulação em um exemplo de engenharia civil?",
                                "Explica o papel físico dos multiplicadores?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de f e g_i (100% corretos).",
                                "Correta introdução e notação de todos os λ_i.",
                                "Expressão de L expandida e simplificada sem erros algébricos.",
                                "Validação via gradiente e factibilidade demonstrada.",
                                "Clareza na documentação e explicação conceitual.",
                                "Tempo de formulação eficiente (<1h para problemas médios)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Analogia com princípio variacional de Hamilton.",
                                "Economia: Otimização de utilidade com restrições orçamentárias.",
                                "Programação: Implementação em Python (SciPy.optimize).",
                                "Estatística: Máxima verossimilhança com restrições.",
                                "Engenharia de Software: Modelagem de dependências em otimização."
                              ],
                              "realWorldApplication": "Em engenharia civil, formular o Lagrangiano para otimizar o custo de uma viga (f= custo de material) com restrições de igualdade no volume e equilíbrio de forças, permitindo soluções computacionais eficientes em softwares como ANSYS ou MATLAB para projetos estruturais sustentáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Derivar condições de otimalidade",
                            "description": "Estabelecer as equações de gradiente nulo do Lagrangiano e resolver o sistema resultante para encontrar pontos estacionários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o Problema de Otimização com Restrições de Igualdade",
                                  "subSteps": [
                                    "Identifique a função objetivo f(x) a ser otimizada (minimizada ou maximizada).",
                                    "Liste todas as restrições de igualdade g_i(x) = 0, onde i = 1 a m.",
                                    "Defina o vetor de variáveis x = (x1, x2, ..., xn) e verifique se o número de restrições m ≤ n.",
                                    "Escreva o problema explicitamente: min/max f(x) s.a. g_i(x) = 0.",
                                    "Verifique se as funções são diferenciáveis (gradientes existam)."
                                  ],
                                  "verification": "Confirme que o problema está escrito corretamente e todas as restrições estão em forma de igualdade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, software de álgebra simbólica como SymPy ou Mathematica.",
                                  "tips": "Sempre normalize as restrições para g(x) = 0 em vez de g(x) = c.",
                                  "learningObjective": "Compreender a estrutura padrão de um problema de otimização com restrições de igualdade.",
                                  "commonMistakes": "Confundir restrições de igualdade com desigualdades ou esquecer de verificar diferenciabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Função Lagrangiana",
                                  "subSteps": [
                                    "Defina os multiplicadores de Lagrange λ1, λ2, ..., λm.",
                                    "Escreva o Lagrangiano L(x, λ) = f(x) - Σ λ_i * g_i(x).",
                                    "Expanda explicitamente L em termos das variáveis x e λ.",
                                    "Confirme o sinal do termo de restrição (use -λg para minimização padrão).",
                                    "Anote as dimensões: ∇L tem n + m componentes."
                                  ],
                                  "verification": "Verifique se L está corretamente formada comparando com a definição teórica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta, calculadora para funções multivariáveis.",
                                  "tips": "Lembre-se: para maximização, pode inverter o sinal, mas padronize para minimização.",
                                  "learningObjective": "Dominar a construção do Lagrangiano como combinação linear da objetivo e restrições.",
                                  "commonMistakes": "Usar +λg em vez de -λg ou inverter o sinal incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer as Condições de Gradiente Nulo",
                                  "subSteps": [
                                    "Compute o gradiente ∇L com respeito a x: ∂L/∂x_j = ∂f/∂x_j - Σ λ_i * ∂g_i/∂x_j = 0 para j=1 a n.",
                                    "Inclua as restrições: ∂L/∂λ_i = -g_i(x) = 0 para i=1 a m.",
                                    "Escreva o sistema completo: ∇_x L = 0 e g(x) = 0.",
                                    "Simplifique as equações parciais se possível.",
                                    "Identifique o sistema não-linear resultante com n + m equações e variáveis."
                                  ],
                                  "verification": "Resolva simbolicamente uma equação simples para confirmar ∇L = 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software como MATLAB ou Python (SymPy) para derivadas simbólicas.",
                                  "tips": "Use notação vetorial: ∇f = λ ∇g para restrição única.",
                                  "learningObjective": "Derivar as condições de otimalidade de primeira ordem usando gradientes.",
                                  "commonMistakes": "Esquecer o sinal negativo nas derivadas das restrições ou confundir ∇_x L com ∇_λ L."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o Sistema para Pontos Estacionários",
                                  "subSteps": [
                                    "Substitua as equações ∇_x L = 0 nas restrições g(x) = 0.",
                                    "Resolva analiticamente para problemas de baixa dimensão (n≤3).",
                                    "Use métodos numéricos (Newton-Raphson) para sistemas maiores.",
                                    "Encontre todos os pontos candidatos (x*, λ*).",
                                    "Verifique se satisfazem todas as equações simultaneamente."
                                  ],
                                  "verification": "Plugue os pontos encontrados de volta nas equações originais para validar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora gráfica, MATLAB ou Python (fsolve).",
                                  "tips": "Para restrições lineares, resolva λ explicitamente de ∇f = λ ∇g.",
                                  "learningObjective": "Resolver sistemas não-lineares oriundos das condições de Lagrange.",
                                  "commonMistakes": "Ignorar soluções múltiplas ou soluções espúrias que não satisfazem restrições."
                                }
                              ],
                              "practicalExample": "Minimize f(x,y) = x² + y² sujeito a x + y = 1. Lagrangiano: L = x² + y² - λ(x + y - 1). Condições: 2x - λ = 0, 2y - λ = 0, x + y = 1. Solução: x=0.5, y=0.5, λ=1 (ponto estacionário mínimo).",
                              "finalVerifications": [
                                "Todas as equações ∂L/∂x_j = 0 e g_i(x) = 0 estão satisfeitas.",
                                "Os multiplicadores λ foram corretamente calculados.",
                                "Pontos múltiplos foram identificados e verificados.",
                                "Gradientes das restrições não são linearmente dependentes no ponto.",
                                "Sinal dos λ indica viabilidade (se aplicável).",
                                "Comparação com valor da função objetivo em pontos conhecidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação do Lagrangiano (100% correto).",
                                "Correção das derivadas parciais e condições de gradiente nulo.",
                                "Solução completa e verificada do sistema.",
                                "Interpretação correta dos pontos estacionários.",
                                "Eficiência no uso de ferramentas computacionais.",
                                "Identificação de erros potenciais no processo."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Vetorial: Gradientes e derivadas parciais.",
                                "Álgebra Linear: Sistemas não-lineares e autovalores para segunda ordem.",
                                "Física: Princípios variacionais em mecânica clássica.",
                                "Economia: Otimização de utilidade com restrições orçamentárias."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, otimizar o dimensionamento de vigas em estruturas sujeitas a restrições de equilíbrio de forças, minimizando peso/custo enquanto satisfaz normas de segurança (ex: tração zero em certos pontos)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Resolver numericamente problemas com Lagrange",
                            "description": "Aplicar métodos numéricos como Newton-Raphson para solucionar o sistema não-linear gerado pelas condições de Lagrange em problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema de otimização e construir o Lagrangiano",
                                  "subSteps": [
                                    "Identificar a função objetivo f(x) a ser minimizada ou maximizada.",
                                    "Definir as restrições de igualdade g_i(x) = 0 para i=1 a m.",
                                    "Construir o Lagrangiano L(x, λ) = f(x) + Σ λ_i g_i(x).",
                                    "Verificar dimensões: x em R^n, λ em R^m.",
                                    "Documentar o problema em um contexto de engenharia civil."
                                  ],
                                  "verification": "Lagrangiano escrito corretamente e restrições listadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou editor de texto; software como MATLAB ou Python.",
                                  "tips": "Sempre normalize as variáveis para facilitar a convergência numérica.",
                                  "learningObjective": "Compreender a formulação teórica do método de Lagrange para restrições de igualdade.",
                                  "commonMistakes": "Esquecer o sinal dos multiplicadores λ ou inverter f e g."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as condições de otimalidade e formar o sistema não-linear",
                                  "subSteps": [
                                    "Calcular os gradientes: ∇L = ∇f + Σ λ_i ∇g_i = 0.",
                                    "Incluir as restrições g_i(x) = 0 no sistema F(X) = 0, onde X = [x; λ].",
                                    "Verificar se o Jacobiano J = ∂F/∂X é quadrado (n+m x n+m).",
                                    "Escolher uma aproximação inicial X_0 razoável.",
                                    "Testar dimensionalidade do sistema."
                                  ],
                                  "verification": "Sistema F(X) = 0 com n+m equações escrito explicitamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (SymPy ou MATLAB Symbolic); caderno de anotações.",
                                  "tips": "Use aproximações iniciais próximas ao ótimo esperado para acelerar convergência.",
                                  "learningObjective": "Dominar a derivação das equações de Lagrange e formação do sistema não-linear.",
                                  "commonMistakes": "Erro no cálculo de gradientes parciais ou omissão de equações de restrição."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método numérico Newton-Raphson",
                                  "subSteps": [
                                    "Computar o Jacobiano J_k em cada iteração k.",
                                    "Resolver o sistema linear J_k ΔX_k = -F(X_k) para ΔX_k.",
                                    "Atualizar X_{k+1} = X_k + ΔX_k.",
                                    "Definir critérios de parada: ||F(X)|| < tol ou max iterações.",
                                    "Implementar em código com controle de erros."
                                  ],
                                  "verification": "Código executável que gera iterações iniciais corretas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB; ambiente Jupyter.",
                                  "tips": "Use decomposição LU ou QR para resolver J ΔX = b de forma estável.",
                                  "learningObjective": "Aplicar Newton-Raphson a sistemas não-lineares multidimensionais.",
                                  "commonMistakes": "Jacobiano singular devido a passo inicial ruim; não checar convergência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar iterações e monitorar convergência",
                                  "subSteps": [
                                    "Executar o algoritmo até convergência ou falha.",
                                    "Registrar histórico de ||F||, ||ΔX|| e número de iterações.",
                                    "Analisar resíduos das restrições g_i(X*).",
                                    "Testar sensibilidade a X_0 diferente.",
                                    "Plotar convergência para visualização."
                                  ],
                                  "verification": "Solução X* com ||F(X*)|| < 1e-6 e restrições satisfeitas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software numérico; gráficos (Matplotlib ou MATLAB plot).",
                                  "tips": "Monitore o condicionamento de J; se >1e10, reinicie com passo menor.",
                                  "learningObjective": "Executar e diagnosticar soluções numéricas em problemas reais.",
                                  "commonMistakes": "Ignorar divergência ou aceitar soluções com resíduos altos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar a solução no contexto de engenharia",
                                  "subSteps": [
                                    "Verificar se X* é mínimo (Hessiano positivo definido).",
                                    "Calcular valor da função objetivo f(X*).",
                                    "Interpretar multiplicadores λ como sensibilidades.",
                                    "Comparar com solução analítica se possível.",
                                    "Documentar relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Relatório com validação e interpretação física.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software para Hessiano; documento Word/LaTeX.",
                                  "tips": "λ_i indica custo marginal da restrição i; use para design.",
                                  "learningObjective": "Interpretar resultados numéricos em aplicações de engenharia civil.",
                                  "commonMistakes": "Confundir máximo com mínimo ou ignorar multiplicadores."
                                }
                              ],
                              "practicalExample": "Otimizar o custo de uma viga retangular sujeita a restrição de resistência ao momento fletor: minimizar C = 100*(w*h) sujeito a (w*h^3)/12 = I_min, onde w= largura, h=altura. Resolver numericamente o sistema de Lagrange usando Newton-Raphson em Python.",
                              "finalVerifications": [
                                "Sistema não-linear resolvido com precisão ||F|| < 1e-8.",
                                "Restrições g_i(X*) satisfeitas dentro de tolerância 1e-6.",
                                "Convergência em menos de 20 iterações.",
                                "Multiplicadores λ interpretados corretamente.",
                                "Solução física viável (variáveis positivas).",
                                "Hessiano confirma mínimo local."
                              ],
                              "assessmentCriteria": [
                                "Correção na formulação do Lagrangiano (100%).",
                                "Implementação precisa do Newton-Raphson (90% de acurácia).",
                                "Diagnóstico de convergência e resíduos (80%).",
                                "Interpretação engenheirística dos resultados (70%).",
                                "Eficiência computacional (menos de 15 iterações).",
                                "Relatório claro e completo."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Vetorial: Gradientes e Jacobianos.",
                                "Álgebra Linear: Resolução de sistemas lineares e decomposições.",
                                "Programação Numérica: Implementação em Python/MATLAB.",
                                "Análise Estrutural: Aplicações em dimensionamento de elementos civis.",
                                "Otimização: Extensão a restrições de desigualdade (KKT)."
                              ],
                              "realWorldApplication": "No projeto de estruturas civis, como otimizar seções transversais de vigas ou pilares para minimizar custo de material sob restrições de rigidez e resistência, usado em softwares como SAP2000 ou ANSYS para automação de design otimizado."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Método dos Multiplicadores de Lagrange para Restrições de Desigualdade",
                        "description": "Extensão do método de Lagrange para restrições de desigualdade utilizando condições de Karush-Kuhn-Tucker (KKT).",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Definir condições KKT",
                            "description": "Formular as condições de complementaridade, viabilidade e estacionariedade para problemas com restrições de desigualdade ≤ e ≥.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema padrão de otimização com restrições de desigualdade",
                                  "subSteps": [
                                    "Defina o problema de minimização: min f(x) sujeito a g_i(x) ≤ 0 para i=1..m e h_j(x) = 0 para j=1..p.",
                                    "Identifique restrições de desigualdade ≤ e ≥ (converta ≥ em ≤ multiplicando por -1).",
                                    "Revise o papel dos multiplicadores de Lagrange para restrições de igualdade.",
                                    "Discuta a necessidade de condições de otimalidade para problemas convexos.",
                                    "Estude o teorema de Lagrange para desigualdades sob qualificações de restrição."
                                  ],
                                  "verification": "Escreva a formulação padrão de um problema de otimização com pelo menos duas restrições de desigualdade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Otimização Não-Linear (ex: Nocedal & Wright), notas de aula, calculadora simbólica como SymPy.",
                                  "tips": "Sempre normalize restrições ≥ para ≤ para padronização.",
                                  "learningObjective": "Reconhecer e formular o problema padrão com restrições mistas.",
                                  "commonMistakes": "Confundir restrições ≤ com ≥ sem conversão; ignorar restrições de não-negatividade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a condição de estacionariedade usando multiplicadores de Lagrange",
                                  "subSteps": [
                                    "Introduza os multiplicadores λ_i ≥ 0 para g_i(x) ≤ 0 e μ_j para h_j(x) = 0.",
                                    "Escreva o Lagrangiano: L(x, λ, μ) = f(x) + Σ λ_i g_i(x) + Σ μ_j h_j(x).",
                                    "Estabeleça ∇L(x*, λ*, μ*) = 0 como condição de estacionariedade.",
                                    "Explique que λ_i representam 'preços sombra' para violações de restrições.",
                                    "Verifique linear independência dos gradientes ativos nas qualificações CQ."
                                  ],
                                  "verification": "Compute o gradiente do Lagrangiano para um problema simples e defina =0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB ou Python (NumPy/SciPy), exemplos resolvidos de KKT.",
                                  "tips": "Use notação vetorial para múltiplas restrições: ∇f + λ^T ∇g + μ^T ∇h = 0.",
                                  "learningObjective": "Formular a condição de gradiente zero no Lagrangiano estendido.",
                                  "commonMistakes": "Esquecer o sinal positivo nos multiplicadores para desigualdades ≤ 0; não considerar restrições de igualdade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer condições de viabilidade primal e dual",
                                  "subSteps": [
                                    "Viabilidade primal: g_i(x*) ≤ 0 e h_j(x*) = 0 para todos i,j.",
                                    "Viabilidade dual: λ_i* ≥ 0 para todos i (multiplicadores não-negativos).",
                                    "Discuta o conjunto de restrições ativas: I_A = {i | g_i(x*) = 0}.",
                                    "Explique que para restrições inativas, λ_i* = 0 implicitamente.",
                                    "Verifique exemplos onde viabilidade falha leva a soluções inválidas."
                                  ],
                                  "verification": "Para um ponto candidato, cheque se todas primal e dual viabilidades são satisfeitas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folhas de exercícios, solver online como Wolfram Alpha para verificação.",
                                  "tips": "Liste explicitamente o conjunto ativo para reduzir o problema.",
                                  "learningObjective": "Aplicar e verificar primal e dual feasibilities em candidatos a ótimos.",
                                  "commonMistakes": "Permitir λ_i < 0 para desigualdades ≤; confundir viabilidade primal com dual."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular a condição de complementaridade slackness",
                                  "subSteps": [
                                    "Defina complementaridade: λ_i* * g_i(x*) = 0 para cada i.",
                                    "Explique: ou restrição ativa (g_i=0, λ_i livre ≥0) ou inativa (g_i<0, λ_i=0).",
                                    "Integre todas: estacionariedade + primal feas + dual feas + complementaridade = KKT.",
                                    "Resolva um sistema KKT simples manualmente.",
                                    "Discuta condições suficientes para convexidade (f convexa, g côncavas)."
                                  ],
                                  "verification": "Escreva as 4 condições KKT completas para um problema dado e resolva para variáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exercícios de KKT, Python com cvxpy para validação numérica.",
                                  "tips": "Comece com problemas com poucas variáveis (2-3) para prática manual.",
                                  "learningObjective": "Completar a formulação KKT unificando todas as condições.",
                                  "commonMistakes": "Escrever λ_i g_i ≤ 0 em vez de =0; ignorar igualdades na complementaridade."
                                }
                              ],
                              "practicalExample": "Minimize f(x,y) = x² + y² sujeito a g1(x,y) = x + y - 1 ≤ 0, g2 = -x ≤ 0, g3 = -y ≤ 0. As condições KKT em (0.5,0.5): ∇f = (1,1), λ1=2, λ2=λ3=0; verifica estacionariedade (1+λ1 -λ2, 1+λ1 -λ3)=(0,0); primal feas; dual feas; comp. slack: λ1*(x+y-1)=0, λ2*x=0 (inativo), λ3*y=0.",
                              "finalVerifications": [
                                "Pode formular corretamente as 4 condições KKT para um problema com 2 desigualdades ≤ e 1 igualdade?",
                                "Identifica o conjunto de restrições ativas em um ponto candidato?",
                                "Verifica primal e dual viabilidades sem erros?",
                                "Aplica complementaridade slackness para eliminar variáveis?",
                                "Resolve um sistema KKT de 4-6 equações manualmente?",
                                "Reconhece quando CQ (qualificação de restrição) é necessária?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação do Lagrangiano e gradiente zero.",
                                "Correta identificação de viabilidades primal e dual.",
                                "Aplicação exata da complementaridade slackness.",
                                "Tratamento adequado de restrições ≥ convertidas.",
                                "Capacidade de integrar todas condições em um sistema coeso.",
                                "Explicação clara do significado físico dos multiplicadores."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Vetorial: Gradientes e multiplicadores.",
                                "Programação Numérica: Implementação em solvers como IPOPT.",
                                "Engenharia Estrutural: Otimização de seções transversais com restrições de tensão.",
                                "Economia: Dualidade em programação linear/não-linear."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, define condições para otimizar o design de uma viga sob cargas, minimizando peso (f(x)=volume) sujeito a restrições de tensão ≤ σ_max e deformação ≥ δ_min, usando KKT em solvers para encontrar configurações ótimas economicamente viáveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Classificar pontos ativos e inativos",
                            "description": "Identificar restrições ativas e inativas em um ponto candidato e ajustar o Lagrangiano conforme as condições KKT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o problema de otimização e condições KKT",
                                  "subSteps": [
                                    "Leia o problema de minimização com restrições de desigualdade: min f(x) s.a. g_i(x) ≤ 0 para i=1,...,m.",
                                    "Lembre-se das condições KKT: ∇L(x*,λ)=0, λ_i ≥ 0, g_i(x*) ≤ 0, λ_i g_i(x*)=0 para cada i.",
                                    "Identifique as restrições de desigualdade g_i(x).",
                                    "Defina o Lagrangiano L(x,λ) = f(x) + ∑ λ_i g_i(x).",
                                    "Anote o ponto candidato x* fornecido."
                                  ],
                                  "verification": "Confirme que todas as restrições g_i estão listadas e o Lagrangiano está corretamente definido em um rascunho.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta, formulário do problema de otimização.",
                                  "tips": "Sempre escreva as condições KKT explicitamente para referência rápida.",
                                  "learningObjective": "Compreender o contexto teórico das condições KKT e o papel das restrições de desigualdade.",
                                  "commonMistakes": "Confundir restrições de igualdade com desigualdade ou esquecer a condição de complementaridade slackness."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar o valor das restrições no ponto candidato",
                                  "subSteps": [
                                    "Calcule g_i(x*) para cada restrição i=1,...,m.",
                                    "Use uma calculadora ou software para precisão numérica.",
                                    "Registre cada g_i(x*) com tolerância numérica (ex: 10^-6 para zero).",
                                    "Classifique preliminarmente: g_i(x*) = 0 (potencialmente ativa), g_i(x*) < 0 (inativa), g_i(x*) > 0 (inviável).",
                                    "Descarte o ponto se qualquer g_i(x*) > 0."
                                  ],
                                  "verification": "Lista completa de valores g_i(x*) calculados e registrados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora científica ou software como MATLAB/Python (SymPy ou NumPy).",
                                  "tips": "Use tolerância para flutuações numéricas; considere g_i(x*) ≈ 0 como ativo.",
                                  "learningObjective": "Avaliar numericamente as restrições em um ponto candidato.",
                                  "commonMistakes": "Ignorar tolerâncias numéricas levando a classificações erradas ou calcular errado os valores g_i."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar restrições como ativas ou inativas",
                                  "subSteps": [
                                    "Defina ativas: conjunto A = {i | g_i(x*) = 0}.",
                                    "Defina inativas: conjunto I = {i | g_i(x*) < 0}.",
                                    "Liste explicitamente os índices em A e I.",
                                    "Verifique viabilidade: todos g_i(x*) ≤ 0.",
                                    "Prepare para complementaridade: para i em I, λ_i deve ser 0."
                                  ],
                                  "verification": "Conjuntos A e I listados corretamente sem sobreposições ou omissões.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Tabela ou lista no papel para conjuntos A e I.",
                                  "tips": "Marque visualmente com cores: verde para ativas, vermelho para inativas.",
                                  "learningObjective": "Distinguir precisamente restrições ativas de inativas baseadas em g_i(x*).",
                                  "commonMistakes": "Incluir restrições estritamente <0 como ativas ou vice-versa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar o Lagrangiano e verificar condições KKT",
                                  "subSteps": [
                                    "Formule o Lagrangiano reduzido: L_red(x,λ_A) = f(x) + ∑_{i∈A} λ_i g_i(x), com λ_i=0 para i∈I.",
                                    "Resolva ∇L_red(x*,λ_A) = 0 para λ_A ≥ 0.",
                                    "Verifique primal feasibility: g_i(x*) ≤ 0 ∀i.",
                                    "Verifique dual feasibility: λ_i ≥ 0 ∀i.",
                                    "Verifique complementaridade: λ_i g_i(x*)=0 ∀i."
                                  ],
                                  "verification": "Sistema ∇L_red resolvido e todas KKT satisfeitas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de álgebra simbólica (MATLAB, Python) para gradientes.",
                                  "tips": "Comece com λ_i=0 para inativas para simplificar o sistema.",
                                  "learningObjective": "Ajustar o Lagrangiano considerando apenas restrições ativas e validar KKT.",
                                  "commonMistakes": "Incluir termos de restrições inativas no Lagrangiano reduzido."
                                }
                              ],
                              "practicalExample": "Considere min f(x,y) = (x-1)^2 + (y-1)^2 s.a. g1(x,y)=x+y-2 ≤0, g2(x,y)= -x ≤0, g3(x,y)= -y ≤0. Ponto candidato x*=(1,1). Calcule: g1=0 (ativa), g2=-1<0 (inativa), g3=-1<0 (inativa). Lagrangiano reduzido: L_red = f + λ1 g1. Resolva ∇L_red=0 para confirmar.",
                              "finalVerifications": [
                                "Conjuntos A e I corretamente identificados sem erros.",
                                "Todos g_i(x*) ≤ 0 (viabilidade primal).",
                                "Lagrangiano reduzido inclui apenas termos para i∈A.",
                                "Condições KKT primal, dual e complementaridade satisfeitas.",
                                "Cálculos numéricos precisos com tolerância aplicada.",
                                "Documentação completa com listas e equações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na avaliação de g_i(x*) (100% correto).",
                                "Classificação correta de pelo menos 90% das restrições.",
                                "Formulação correta do Lagrangiano reduzido.",
                                "Resolução válida do sistema ∇L_red=0.",
                                "Verificação completa das condições KKT.",
                                "Explicação clara de raciocínio em subpassos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar em Python (SciPy.optimize) para solvers KKT.",
                                "Engenharia Estrutural: Otimizar projetos civis sob restrições de tensão/deformação.",
                                "Estatística: Identificar constraints ativas em regressão com restrições.",
                                "Física: Aplicar em mecânica com restrições de equilíbrio."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao otimizar o dimensionamento de vigas em estruturas sob restrições de resistência e deslocamento (ex: g_i modelando tensões ≤ limite), classificar restrições ativas permite refinar soluções computacionais em softwares como ANSYS ou SAP2000, garantindo designs eficientes e seguros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Aplicar em problemas de engenharia",
                            "description": "Resolver um problema de otimização estrutural com restrições de desigualdade, como limites de tensão, usando condições KKT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema de otimização estrutural",
                                  "subSteps": [
                                    "Defina a função objetivo, como minimizar o volume ou peso da estrutura.",
                                    "Identifique as variáveis de decisão, como dimensões de seções transversais.",
                                    "Especifique as cargas atuantes e condições de contorno da estrutura.",
                                    "Liste restrições iniciais de igualdade, como equilíbrio de forças.",
                                    "Documente todas as premissas do modelo físico."
                                  ],
                                  "verification": "Verifique se a formulação está matematicamente correta e fisicamente coerente com o problema real.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel e caneta, software de modelagem como MATLAB ou Python (SymPy/Numpy)",
                                  "tips": "Comece com um problema simples, como uma viga ou treliça, para facilitar a compreensão.",
                                  "learningObjective": "Entender como traduzir um problema de engenharia em um modelo matemático de otimização.",
                                  "commonMistakes": "Esquecer unidades consistentes ou ignorar simetrias na estrutura."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expressar restrições de desigualdade e preparar para KKT",
                                  "subSteps": [
                                    "Defina restrições de desigualdade, como σ ≤ σ_max para tensões.",
                                    "Escreva as restrições em forma padrão: g(x) ≤ 0.",
                                    "Verifique a convexidade da função objetivo e restrições para garantir aplicabilidade de KKT.",
                                    "Introduza multiplicadores de Lagrange para restrições de igualdade existentes.",
                                    "Padronize o problema para minimização com restrições g_i(x) ≤ 0 e h_j(x) = 0."
                                  ],
                                  "verification": "Confirme que todas as restrições são expressas corretamente e o problema está no formato padrão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Folha de cálculo ou editor de equações (LaTeX), calculadora simbólica",
                                  "tips": "Use diagramas esquemáticos da estrutura para visualizar as restrições.",
                                  "learningObjective": "Dominar a representação de limites físicos como restrições matemáticas.",
                                  "commonMistakes": "Confundir restrições de desigualdade com igualdade ou inverter o sinal das desigualdades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e configurar as condições KKT",
                                  "subSteps": [
                                    "Escreva o Lagrangiano: L = f + ∑ λ g + ∑ μ h.",
                                    "Estabeleça as condições de primal feasibility: g(x*) ≤ 0, h(x*) = 0.",
                                    "Defina dual feasibility: λ ≥ 0.",
                                    "Aplique complementaridade: λ g(x*) = 0.",
                                    "Escreva as condições de estacionariedade: ∇L = 0."
                                  ],
                                  "verification": "Resolva simbolicamente um caso toy para checar se as condições KKT são satisfeitas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software de álgebra simbólica (MATLAB Symbolic, Python SymPy), quadro branco",
                                  "tips": "Classifique restrições ativas/inativas para simplificar o sistema.",
                                  "learningObjective": "Compreender as condições de otimalidade para problemas com desigualdades.",
                                  "commonMistakes": "Esquecer a condição de complementaridade ou assumir todas restrições ativas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o sistema KKT e validar a solução",
                                  "subSteps": [
                                    "Monte o sistema não-linear de equações KKT.",
                                    "Use métodos numéricos (ex: fsolve no MATLAB) para encontrar x*, λ*, μ*.",
                                    "Verifique todas as condições KKT na solução candidata.",
                                    "Compare com soluções analíticas ou simulações FEM para validação.",
                                    "Interprete os multiplicadores como sensibilidades às restrições."
                                  ],
                                  "verification": "A solução deve satisfazer todas as KKT e produzir uma estrutura viável.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Software numérico (MATLAB, Python SciPy), simulador estrutural (ex: ANSYS ou SAP2000)",
                                  "tips": "Forneça boas estimativas iniciais baseadas em soluções sem restrições.",
                                  "learningObjective": "Aplicar ferramentas computacionais para resolver problemas reais de otimização.",
                                  "commonMistakes": "Não convergência devido a má escalabilidade; normalize variáveis."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e realizar análise de sensibilidade",
                                  "subSteps": [
                                    "Calcule o valor ótimo da função objetivo e compare com baseline.",
                                    "Analise quais restrições estão ativas e seu impacto.",
                                    "Varie parâmetros (ex: σ_max) e observe mudanças via multiplicadores.",
                                    "Gere relatórios com gráficos de tensão e deformação.",
                                    "Proponha melhorias ou extensões do modelo."
                                  ],
                                  "verification": "Solução deve ser robusta a pequenas perturbações e economicamente sensata.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Gráficos em Python (Matplotlib) ou Excel",
                                  "tips": "Documente tudo em um relatório estruturado para revisão.",
                                  "learningObjective": "Extrair insights práticos de soluções otimizadas.",
                                  "commonMistakes": "Ignorar viabilidade física pós-otimização ou superestimar precisão numérica."
                                }
                              ],
                              "practicalExample": "Otimize o dimensionamento de uma treliça plana com 3 barras sob carga vertical de 10 kN, minimizando o volume total (função objetivo) sujeito a tensões ≤ 150 MPa em tração/compressão e área mínima de 1 cm² por barra. Use KKT para encontrar áreas ótimas.",
                              "finalVerifications": [
                                "Solução primal viável: todas g(x*) ≤ 0 e h(x*) = 0.",
                                "Dual feasibility: todos λ* ≥ 0.",
                                "Complementaridade: λ_i* * g_i(x*) = 0 para todo i.",
                                "Estacionariedade: ∇f(x*) + ∑ λ* ∇g + ∑ μ* ∇h = 0.",
                                "Restrições LICQ (Linear Independence Constraint Qualification) satisfeitas.",
                                "Comparação com simulação FEM confirma tensões dentro dos limites."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação do problema e restrições.",
                                "Correta aplicação e resolução das condições KKT.",
                                "Validação numérica e interpretação física da solução.",
                                "Análise de sensibilidade e robustez da solução ótima.",
                                "Clareza na documentação e visualizações.",
                                "Eficiência computacional e convergência do solver."
                              ],
                              "crossCurricularConnections": [
                                "Mecânica dos Materiais: cálculo de tensões e deformações.",
                                "Análise Numérica: solvers não-lineares e otimização.",
                                "Programação Computacional: implementação em Python/MATLAB.",
                                "Engenharia de Projetos: otimização econômica de estruturas."
                              ],
                              "realWorldApplication": "No projeto de pontes, edifícios e torres, onde se minimiza o consumo de aço ou concreto sujeito a normas de segurança (ex: NBR 8800), reduzindo custos em até 20% sem comprometer a integridade estrutural."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Métodos de Penalização para Restrições",
                        "description": "Técnicas de transformação de problemas com restrições em problemas não-restritos via funções de penalidade para igualdades e desigualdades.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Construir função de penalidade quadrática",
                            "description": "Definir funções de penalidade para restrições de igualdade (ex: (g(x))^2) e desigualdade (ex: max(0, h(x))^2), com parâmetro de penalidade crescente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender restrições em problemas de otimização",
                                  "subSteps": [
                                    "Identifique restrições de igualdade g(x) = 0 e desigualdade h(x) ≤ 0 no problema.",
                                    "Revise o problema padrão: min f(x) s.a. g(x)=0, h(x)≤0.",
                                    "Explique o papel das restrições na engenharia civil, como equilíbrio de forças.",
                                    "Esboce um problema exemplo com 1 igualdade e 1 desigualdade.",
                                    "Discuta por que métodos de penalidade convertem restrições em termos não restritos."
                                  ],
                                  "verification": "Liste corretamente as restrições e seu impacto no problema.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Exemplo de problema de otimização em engenharia civil"
                                  ],
                                  "tips": [
                                    "Use notação padrão: g para igualdade, h para desigualdade.",
                                    "Comece com problemas simples de 2 variáveis."
                                  ],
                                  "learningObjective": "Identificar e classificar restrições de igualdade e desigualdade em problemas de otimização.",
                                  "commonMistakes": [
                                    "Confundir igualdade com desigualdade.",
                                    "Ignorar sinal das desigualdades (sempre ≤0)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir penalidade quadrática para restrições de igualdade",
                                  "subSteps": [
                                    "Defina P_g(x) = [g(x)]^2 para restrições g(x)=0.",
                                    "Justifique a escolha quadrática: suave, diferenciável e penaliza quadraticamente desvios.",
                                    "Derive o gradiente: ∇P_g = 2 g(x) ∇g(x).",
                                    "Teste com g(x) = x1 + x2 - 1 = 0 em 2D.",
                                    "Verifique que P_g=0 iff g(x)=0."
                                  ],
                                  "verification": "Escreva a fórmula correta e compute P_g para um ponto violador.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy",
                                    "Papel para derivações"
                                  ],
                                  "tips": [
                                    "Quadrático garante convexidade local perto da restrição.",
                                    "Sempre normalize g se necessário."
                                  ],
                                  "learningObjective": "Formular a penalidade quadrática suave para restrições de igualdade.",
                                  "commonMistakes": [
                                    "Usar |g(x)| em vez de [g(x)]^2 (não diferenciável).",
                                    "Esquecer o fator 2 no gradiente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir penalidade quadrática para restrições de desigualdade",
                                  "subSteps": [
                                    "Defina P_h(x) = [max(0, h(x))]^2 para h(x)≤0.",
                                    "Explique max(0,h): zero se factível, penaliza só violações.",
                                    "Compute gradiente: 2 max(0,h(x)) ∇h(x) se h>0, senão 0.",
                                    "Teste com h(x) = x1^2 + x2^2 - 1 ≤0 (disco unitário).",
                                    "Confirme P_h=0 na região factível."
                                  ],
                                  "verification": "Aplique a uma desigualdade e mostre P_h=0 em ponto factível e >0 fora.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "SymPy ou MATLAB para gradientes",
                                    "Gráfico de exemplo"
                                  ],
                                  "tips": [
                                    "max(0,h) é a violação ativa.",
                                    "Use funções suaves como softplus para aproximações numéricas."
                                  ],
                                  "learningObjective": "Formular penalidade quadrática que ignora violações inativas em desigualdades.",
                                  "commonMistakes": [
                                    "Penalizar h(x) diretamente sem max.",
                                    "Confundir com penalidade linear."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar função de penalidade total com parâmetro crescente",
                                  "subSteps": [
                                    "Combine: P(x,μ) = f(x) + μ ∑ [g_i(x)]^2 + μ ∑ [max(0,h_j(x))]^2.",
                                    "Explique μ_k → ∞ para convergência ao ótimo restrito.",
                                    "Escolha sequência μ_k = 10^k ou adaptativa.",
                                    "Implemente em pseudocódigo ou Python para um problema teste.",
                                    "Avalie minimizador não restrito para μ grande."
                                  ],
                                  "verification": "Escreva P(x,μ) completa e minimize numericamente para μ=100.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Otimizador como minimize()"
                                  ],
                                  "tips": [
                                    "Aumente μ gradualmente para evitar il-condicionamento.",
                                    "Monitore ||g|| e max(h)."
                                  ],
                                  "learningObjective": "Construir e parametrizar a função de penalidade quadrática completa.",
                                  "commonMistakes": [
                                    "Usar μ fixo (não converge).",
                                    "Esquecer somar sobre todas restrições."
                                  ]
                                }
                              ],
                              "practicalExample": "Em projeto de viga cantilever: min custo = c1 L + c2 A, s.a. g(x)= momento equilíbrio=0, h(x)= tensão máxima ≤ σ_allow. Construa P(x,μ) = custo + μ [g]^2 + μ [max(0, tensão-σ)]^2 e minimize para μ=10,100.",
                              "finalVerifications": [
                                "P(x,μ) é zero nas restrições quando factível.",
                                "Gradiente de P é correto e suave.",
                                "Minimizador de P_μ aproxima solução restrita para μ grande.",
                                "Código numérico converge sem erros.",
                                "Violação de restrições <1e-4 para μ=1000.",
                                "Função é não-negativa nas penalidades."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática das fórmulas de penalidade.",
                                "Uso apropriado de max(0,·) para desigualdades.",
                                "Compreensão do papel e crescimento de μ.",
                                "Capacidade de derivar gradientes.",
                                "Implementação prática funcional.",
                                "Análise de convergência qualitativa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e otimização.",
                                "Programação: Implementação numérica com SciPy/NumPy.",
                                "Engenharia Mecânica: Análise estrutural com restrições.",
                                "Estatística: Penalidades em regressão regularizada (L2).",
                                "Física: Princípios de equilíbrio e limites materiais."
                              ],
                              "realWorldApplication": "Otimização de estruturas civis como vigas e lajes, minimizando custo/massa sujeita a restrições de equilíbrio (igualdades) e segurança (desigualdades de tensão/deflexão), usado em softwares como ANSYS ou SAP2000 para design eficiente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Implementar método de penalização exata",
                            "description": "Aplicar sequência de minimizações não-restritas com penalidades crescentes até convergência para a solução ótima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema de otimização com restrições",
                                  "subSteps": [
                                    "Identifique a função objetivo f(x) a ser minimizada.",
                                    "Liste todas as restrições de igualdade h_i(x) = 0 e desigualdade g_j(x) ≤ 0.",
                                    "Defina o domínio das variáveis x e condições de viabilidade.",
                                    "Escreva o problema matemático completo em forma padrão.",
                                    "Verifique se o problema é convexo ou não para escolher solver apropriado."
                                  ],
                                  "verification": "Problema escrito em LaTeX ou pseudocódigo e revisado por pares.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel e caneta ou editor de texto (Jupyter Notebook), documentação de otimização.",
                                  "tips": "Comece com problemas pequenos para testar formulação.",
                                  "learningObjective": "Compreender e representar problemas de otimização restrita.",
                                  "commonMistakes": "Esquecer restrições de desigualdade ou não-normalizar variáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a função penalizada e parâmetros iniciais",
                                  "subSteps": [
                                    "Construa a função penalizada P(x, r) = f(x) + r * Σ[φ(h_i(x)) + φ(g_j(x))], onde φ é função penalidade quadrática.",
                                    "Escolha r_0 inicial pequeno (ex: 1.0) e fator de multiplicação μ > 1 (ex: 10).",
                                    "Defina tolerância de convergência ε (ex: 1e-6) para ||∇P|| e violações.",
                                    "Implemente φ(t) = t² para penalização exata quadrática.",
                                    "Teste a função penalizada com x inicial arbitrário."
                                  ],
                                  "verification": "Função P(x, r) computada corretamente para valores teste.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python com NumPy e SciPy, Jupyter Notebook.",
                                  "tips": "Use penalidade quadrática para suavidade e convergência rápida.",
                                  "learningObjective": "Construir transformações não-restritas do problema.",
                                  "commonMistakes": "Escolher r_0 muito grande, causando il-condicionamento inicial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar minimização não-restrita para penalidade fixa",
                                  "subSteps": [
                                    "Escolha um método de minimização (ex: BFGS ou gradiente conjugado do SciPy).",
                                    "Implemente função que computa ∇P e Hessian aproximado se necessário.",
                                    "Execute minimização a partir de x_k inicial até ||∇P|| < ε.",
                                    "Registre x_k*, f(x_k*), violações e r atual.",
                                    "Valide se minimizador é aproximado local."
                                  ],
                                  "verification": "Convergência confirmada pelo solver e resíduos baixos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "SciPy.optimize (minimize), código fonte em Python.",
                                  "tips": "Forneça gradiente analítico para aceleração.",
                                  "learningObjective": "Aplicar solvers não-restritos em funções penalizadas.",
                                  "commonMistakes": "Não fornecer gradiente, levando a lentidão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Iterar com penalidades crescentes até convergência",
                                  "subSteps": [
                                    "Inicie loop com k=0, x_0 aleatório ou heurístico.",
                                    "Em cada iteração: minimize P(x, r_k), atualize r_{k+1} = μ * r_k.",
                                    "Verifique critérios: violações < ε e mudança em x < δ.",
                                    "Pare se convergido ou max_iter atingido.",
                                    "Monitore histórico de r_k, violações e f(x)."
                                  ],
                                  "verification": "Loop para com critérios satisfeitos e histórico plotado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Matplotlib para plots, código Python completo.",
                                  "tips": "Aumente μ se violações persistirem.",
                                  "learningObjective": "Gerenciar sequência de penalidades para exatidão.",
                                  "commonMistakes": "Parar cedo sem violações zero."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e analisar a solução ótima",
                                  "subSteps": [
                                    "Verifique se x* satisfaz todas restrições dentro de tolerância.",
                                    "Compare f(x*) com benchmarks ou soluções exatas.",
                                    "Analise sensibilidade a parâmetros iniciais.",
                                    "Calcule duals aproximados via Lagrange multipliers.",
                                    "Documente código e resultados em relatório."
                                  ],
                                  "verification": "Restrições violadas < 1e-8 e f(x*) coerente.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Código fonte, solver de referência (ex: CVXPY).",
                                  "tips": "Use múltiplos x_0 para robustez.",
                                  "learningObjective": "Garantir qualidade da solução exata.",
                                  "commonMistakes": "Ignorar verificação de viabilidade final."
                                }
                              ],
                              "practicalExample": "Otimizar dimensões de uma viga simplesmente apoiada (largura b, altura h) minimizando volume sujeito a restrições de tensão máxima σ ≤ 200 MPa e deflexão δ ≤ L/360, sob carga distribuída q=10 kN/m e L=5m. Use r_0=1, μ=10, ε=1e-6. Solução converge para b=0.2m, h=0.4m.",
                              "finalVerifications": [
                                "Função objetivo e restrições satisfeitas dentro de ε=1e-6.",
                                "Histórico de penalidades mostra r_k → ∞.",
                                "Solução invariante a perturbações iniciais.",
                                "Gradiente da lagrangiana aproximadamente zero.",
                                "Tempo de computação < 1 minuto para problema médio.",
                                "Código roda sem erros em diferentes seeds."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da função penalizada (20%).",
                                "Implementação eficiente do loop iterativo (25%).",
                                "Convergência comprovada com plots (20%).",
                                "Validação rigorosa da solução (20%).",
                                "Código limpo e documentado (10%).",
                                "Análise de sensibilidade (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e análise numérica.",
                                "Programação: Otimização em Python/SciPy.",
                                "Engenharia de Software: Testes unitários para funções.",
                                "Estatística: Análise de sensibilidade e Monte Carlo."
                              ],
                              "realWorldApplication": "Projeto otimizado de estruturas civis como pontes e edifícios, minimizando custo de material sob normas de segurança (ex: ABNT NBR), reduzindo desperdício em até 15% em projetos reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Comparar com multiplicadores de Lagrange",
                            "description": "Analisar vantagens, desvantagens e convergência de métodos de penalização versus Lagrange em problemas computacionais de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos dos Métodos de Penalização e Multiplicadores de Lagrange",
                                  "subSteps": [
                                    "Estude a formulação padrão de problemas de otimização com restrições de igualdade: min f(x) s.a. g(x)=0.",
                                    "Revise o método de Lagrange: L(x,λ) = f(x) + λ^T g(x), condições KKT.",
                                    "Entenda métodos de penalização quadrática: P(x,ρ) = f(x) + (ρ/2) ||g(x)||^2, onde ρ → ∞.",
                                    "Compare formulações matemáticas lado a lado em um quadro.",
                                    "Identifique diferenças chave: Lagrange é exato; penalização é aproximado."
                                  ],
                                  "verification": "Crie um resumo escrito comparando as funções objetivo de ambos métodos para um problema toy.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de Otimização Não Linear (Nocedal & Wright), slides de aula sobre otimização com restrições, papel e caneta para anotações.",
                                  "tips": "Use diagramas de fluxo para visualizar como cada método incorpora restrições.",
                                  "learningObjective": "Compreender as bases matemáticas e diferenças fundamentais entre os métodos.",
                                  "commonMistakes": "Confundir penalização exata com quadrática; ignorar que Lagrange requer condições de qualificação de restrições."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Vantagens e Desvantagens de Cada Método",
                                  "subSteps": [
                                    "Liste vantagens da penalização: simplicidade (problema irrestrito), sem necessidade de multiplicadores iniciais.",
                                    "Liste desvantagens da penalização: ill-conditioning para ρ grande, sensibilidade a escolha de ρ.",
                                    "Liste vantagens de Lagrange: solução exata, multiplicadores interpretáveis como sensibilidades.",
                                    "Liste desvantagens de Lagrange: mais iterativo, requer solver para sistemas KKT.",
                                    "Crie uma tabela comparativa com 4-5 critérios (ex.: robustez, custo computacional)."
                                  ],
                                  "verification": "Preencha e discuta uma tabela de prós/contras com um colega ou em autoavaliação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Planilha Excel ou Google Sheets para tabela, artigos acadêmicos sobre comparação de métodos.",
                                  "tips": "Classifique cada item como 'alta/média/baixa' impacto para priorizar.",
                                  "learningObjective": "Identificar trade-offs práticos de cada método em contextos computacionais.",
                                  "commonMistakes": "Superestimar simplicidade da penalização ignorando tuning de parâmetros; subestimar utilidade de λ em Lagrange."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Aspectos de Convergência e Implementação Computacional",
                                  "subSteps": [
                                    "Estude taxas de convergência: penalização é O(1/√ρ), Lagrange via SQP é superlinear.",
                                    "Simule numericamente em Python/MATLAB: resolva um problema pequeno variando ρ vs. iterações Lagrange.",
                                    "Analise estabilidade: observe Hessiana mal-condicionada em penalização.",
                                    "Discuta cenários onde um converge melhor (ex.: restrições lineares favorecem Lagrange).",
                                    "Registre métricas: número de iterações, tempo CPU, precisão final."
                                  ],
                                  "verification": "Gere gráficos de convergência para ambos métodos em um problema teste.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com SciPy/NumPy, MATLAB (opcional), exemplo de código de otimização disponível online.",
                                  "tips": "Comece com ρ baixo e aumente gradualmente para observar ill-conditioning.",
                                  "learningObjective": "Avaliar desempenho numérico e convergência em problemas reais de engenharia.",
                                  "commonMistakes": "Usar ρ fixo sem sequência; ignorar normalização de restrições em penalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Comparação a um Problema de Engenharia Civil",
                                  "subSteps": [
                                    "Selecione um problema: otimização de seção transversal de viga com restrições de tensão e deslocamento.",
                                    "Implemente ambos métodos: código para penalização e Lagrange (usando solver como IPOPT).",
                                    "Compare resultados: soluções finais, λ vs. penalidades, tempo de execução.",
                                    "Analise implicações: como λ informa design vs. aproximações de penalização.",
                                    "Documente conclusões em relatório curto."
                                  ],
                                  "verification": "Execute simulações e compare outputs em relatório com gráficos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Software de otimização (Python SciPy, CVXPY), modelo finito de viga simples.",
                                  "tips": "Use problemas com 2-5 variáveis para depuração rápida.",
                                  "learningObjective": "Integrar comparação teórica com aplicação prática em engenharia civil.",
                                  "commonMistakes": "Escolher problema muito complexo inicialmente; não validar soluções com software comercial."
                                }
                              ],
                              "practicalExample": "Em um projeto de otimização de treliça para uma ponte, use penalização para prototipagem rápida (ρ inicial baixo), mas Lagrange para design final, onde multiplicadores λ revelam sensibilidades a cargas de vento, guiando reforços estruturais.",
                              "finalVerifications": [
                                "Capacidade de listar 3 vantagens/desvantagens precisas de cada método.",
                                "Gráficos de convergência mostram diferença clara em iterações/tempo.",
                                "Interpretação correta de λ como forças de Lagrange em contexto estrutural.",
                                "Tabela comparativa completa com critérios quantitativos.",
                                "Relatório de aplicação em engenharia civil sem erros conceituais.",
                                "Simulação numérica reproduz resultados teóricos esperados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição matemática de ambos métodos (20%)",
                                "Profundidade na análise de prós/contras e convergência (25%)",
                                "Qualidade da implementação numérica e gráficos (25%)",
                                "Relevância à engenharia civil com exemplo prático (15%)",
                                "Clareza e organização do relatório comparativo (10%)",
                                "Identificação de cenários ideais para cada método (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Álgebra Linear (Hessianas, autovalores).",
                                "Programação: Implementação de solvers em Python/MATLAB.",
                                "Física: Mecânica Estrutural em otimização de vigas/treliças.",
                                "Estatística: Análise de sensibilidade via multiplicadores."
                              ],
                              "realWorldApplication": "Na engenharia civil, ao otimizar projetos de edifícios altos contra terremotos, Lagrange fornece insights sobre restrições críticas de rigidez, enquanto penalização acelera iterações iniciais em software como ANSYS ou SAP2000, economizando tempo em licitações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.2",
                              "10.1.5.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.4",
                            "name": "Programar em MATLAB ou software similar",
                            "description": "Implementar um algoritmo de penalização para otimizar um problema com restrições, usando referências como Chapra e Canale.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente MATLAB e definir o problema de otimização",
                                  "subSteps": [
                                    "Instale e abra o MATLAB ou software similar (ex: Octave).",
                                    "Defina a função objetivo f(x) para o problema de otimização, usando sintaxe MATLAB (ex: function f = obj_func(x)).",
                                    "Especifique as restrições de desigualdade g(x) <= 0 e igualdade h(x) = 0.",
                                    "Inicialize variáveis: ponto inicial x0, tolerância epsilon, parâmetro de penalização inicial mu.",
                                    "Consulte Chapra e Canale (Capítulo sobre otimização) para exemplos de problemas com restrições."
                                  ],
                                  "verification": "Execute o script inicial e confirme que funções são definidas sem erros usando 'whos' para listar variáveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB/Octave instalado, livro Chapra e Canale (PDF ou físico), editor de script MATLAB.",
                                  "tips": "Use funções anônimas (@) para funções simples para agilizar o código.",
                                  "learningObjective": "Entender e codificar a formulação matemática de um problema de otimização com restrições em MATLAB.",
                                  "commonMistakes": "Esquecer de definir funções como vetores/colunas consistentes; usar variáveis globais sem escopo claro."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função de penalização",
                                  "subSteps": [
                                    "Crie a função penalizada P(x, mu) = f(x) + mu * sum(max(0, g(x)))^2 + mu * sum(h(x)^2).",
                                    "Codifique as restrições g(x) e h(x) dentro da função penalizada.",
                                    "Teste a função com x0 e mu inicial, plotando P(x) vs x para visualização.",
                                    "Ajuste mu inicial baseado em magnitudes de f e restrições (tipicamente 1 a 10).",
                                    "Salve como função separada: function P = penalty_func(x, mu)."
                                  ],
                                  "verification": "Chame penalty_func(x0, mu) e verifique se retorna valor finito e restrições violadas aumentam P.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB com funções plot() e fplot(), exemplos do Chapra e Canale.",
                                  "tips": "Normalize restrições dividindo por sua magnitude esperada para estabilidade numérica.",
                                  "learningObjective": "Construir a função de penalização que transforma restrições em penalidades quadráticas.",
                                  "commonMistakes": "Usar abs() em vez de max(0,g) para desigualdades; mu muito pequeno causando não convergência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar o algoritmo de minimização da função penalizada",
                                  "subSteps": [
                                    "Implemente um método de busca simples como gradiente descendente: x = x - alpha * grad_P.",
                                    "Calcule gradiente analítico ou numérico de P(x, mu) usando gradient() ou finite differences.",
                                    "Configure loop: while norma(grad) > epsilon, atualize x, monitore iterações (max 1000).",
                                    "Aumente mu progressivamente (mu = mu * 10) se violações > tol.",
                                    "Adicione logs: vetor de histórico de x, f(x), violações."
                                  ],
                                  "verification": "Execute o loop e plote histórico de f(x) e violações; deve convergir.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Funções MATLAB: norm(), linspace() para plots, debugger.",
                                  "tips": "Use alpha adaptativo (ex: backtracking line search) para passos estáveis.",
                                  "learningObjective": "Aplicar método numérico iterativo para minimizar a função penalizada.",
                                  "commonMistakes": "Passo alpha fixo muito grande causando oscilação; não aumentar mu adequadamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, validar e refinar o algoritmo",
                                  "subSteps": [
                                    "Use exemplo do Chapra e Canale (ex: otimização de reservatório com restrições).",
                                    "Compare solução com método exato (ex: fmincon() do MATLAB Optimization Toolbox).",
                                    "Analise sensibilidade: varie mu inicial e epsilon.",
                                    "Plote contornos de f(x) e P(x) com contourf() mostrando convergência.",
                                    "Documente código com comentários e salve como .m funcional."
                                  ],
                                  "verification": "Solução final satisfaz restrições (g<=0, h~0) e f(x) próximo de ótimo conhecido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Optimization Toolbox (opcional), exemplos Chapra e Canale.",
                                  "tips": "Vectorize computações para eficiência em múltiplas variáveis.",
                                  "learningObjective": "Validar implementação contra benchmarks e refinar para precisão.",
                                  "commonMistakes": "Ignorar violações residuais; não testar com problemas multi-variáveis."
                                }
                              ],
                              "practicalExample": "Otimizar o custo de uma viga de concreto (f(x1,x2)=c1*x1 + c2*x2) sujeito a restrições de tensão (g1: sigma_max <= allow) e volume mínimo, implementando penalização em MATLAB para encontrar dimensões ótimas x1 (altura), x2 (largura).",
                              "finalVerifications": [
                                "Código executa sem erros e converge em <1000 iterações.",
                                "Restrições finais: todas g(x) <= 1e-4 e h(x) <= 1e-4.",
                                "Valor objetivo f(x*) dentro de 5% do ótimo conhecido.",
                                "Plots mostram convergência suave de P(x) e violações -> 0.",
                                "Código comentado e reproduzível com seed rand.",
                                "Testado com pelo menos dois problemas diferentes."
                              ],
                              "assessmentCriteria": [
                                "Correta formulação da função penalizada (quadrática, mu progressivo).",
                                "Implementação numérica estável do minimizador (gradiente ou similar).",
                                "Validação quantitativa com métricas de erro e plots.",
                                "Eficiência: tempo de execução < 5s para problema 2D.",
                                "Clareza do código: funções modulares, comentários explicativos.",
                                "Tratamento de casos edge (ex: restrições ativas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e métodos numéricos (gradientes).",
                                "Programação: Estruturas de loop, funções e vetores em MATLAB/Python.",
                                "Engenharia Civil: Otimização estrutural e dimensionamento.",
                                "Estatística: Análise de sensibilidade e Monte Carlo para robustez."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, como otimizar seções transversais de pontes ou edifícios para minimizar custo sob restrições de segurança (tensão, deflexão), reduzindo material em 10-20% enquanto atende normas ABNT NBR."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Aplicações em Engenharia Civil",
                    "description": "Uso de otimização em projetos estruturais, alocação de recursos e planejamento de obras civis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Otimização em Projetos Estruturais",
                        "description": "Aplicação de técnicas de otimização para minimizar custos, peso ou material em estruturas civis, sujeitas a restrições de resistência, estabilidade e normas técnicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Formular problema de otimização para dimensionamento de vigas",
                            "description": "Definir função objetivo (ex.: minimizar volume de concreto) e restrições (ex.: momentos fletores máximos, deflexões permitidas) para otimização de seções transversais de vigas usando programação linear ou não-linear.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar variáveis de decisão e função objetivo",
                                  "subSteps": [
                                    "Analise o problema de dimensionamento da viga: identifique cargas, comprimento e apoios.",
                                    "Defina variáveis: largura (b), altura (h), possivelmente espessura de armadura.",
                                    "Escolha função objetivo: minimizar volume (V = b * h * L), custo ou peso.",
                                    "Expresse matematicamente: min f(x) onde x = [b, h].",
                                    "Verifique unidades consistentes (ex: metros, m³)."
                                  ],
                                  "verification": "Lista de variáveis e função objetivo escrita corretamente, com unidades.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de cálculo ou software como Excel/MATLAB",
                                    "Normas ABNT NBR 6118",
                                    "Diagrama da viga"
                                  ],
                                  "tips": "Comece com o mais simples: volume como proxy para custo.",
                                  "learningObjective": "Compreender como traduzir objetivos de engenharia em funções matemáticas.",
                                  "commonMistakes": [
                                    "Esquecer comprimento L na função de volume",
                                    "Usar variáveis irrelevantes",
                                    "Ignorar sinal da minimização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar restrições de resistência (ULS)",
                                  "subSteps": [
                                    "Calcule momentos fletores máximos (Mf) e forças cisalhantes (V) via integração ou software.",
                                    "Aplique fórmulas de dimensionamento: Mf ≤ MRd (resistência momento), VRd ≥ V.",
                                    "Expresse em termos de b, h: ex: σ * b * h²/6 ≥ Mf / γ.",
                                    "Inclua coeficientes de segurança e fatores de majoração.",
                                    "Liste como desigualdades: g_i(x) ≤ 0."
                                  ],
                                  "verification": "Restrições ULS formuladas e verificadas com valores numéricos exemplo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabelas de momentos para vigas",
                                    "Calculadora ou Python/SciPy",
                                    "Normas de concreto armado"
                                  ],
                                  "tips": "Use diagramas de momento para Mf max.",
                                  "learningObjective": "Mapear critérios de segurança estrutural para restrições otimizadas.",
                                  "commonMistakes": [
                                    "Confundir ULS com SLS",
                                    "Esquecer fatores parciais γ",
                                    "Usar igualdades em vez de desigualdades"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar restrições de serviço (SLS) e geométricas",
                                  "subSteps": [
                                    "Calcule deflexões: δ = (5 q L⁴)/(384 E I) ≤ δ_adm.",
                                    "Expresse I = b h³/12 em termos de variáveis.",
                                    "Adicione limites mínimos/máximos: h ≥ L/15, b ≥ h/2.",
                                    "Inclua vibrações ou outras se aplicável.",
                                    "Compile todas restrições em lista padronizada."
                                  ],
                                  "verification": "Todas restrições testadas com valores plausíveis sem violação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Fórmulas de deflexão ACI/ABNT",
                                    "Planilha Excel para cálculos",
                                    "Referências de ratios span/depth"
                                  ],
                                  "tips": "Priorize deflexão como restrição crítica em vigas longas.",
                                  "learningObjective": "Integrar múltiplos critérios de desempenho em um modelo de otimização.",
                                  "commonMistakes": [
                                    "Ignorar deflexão em vigas esbeltas",
                                    "Restrições muito frouxas levando a soluções irrealistas",
                                    "Unidades inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e justificar tipo de programação matemática",
                                  "subSteps": [
                                    "Verifique linearidade: se objetivo e restrições lineares em b,h → programação linear.",
                                    "Caso não-linear (ex: I ~ h³) → programação não-linear.",
                                    "Escolha solver: linprog para LP, fmincon para NLP.",
                                    "Defina bounds iniciais e feasibility.",
                                    "Documente suposições (ex: seção retangular constante)."
                                  ],
                                  "verification": "Modelo classificado corretamente com justificativa e pseudocódigo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação MATLAB/SciPy optimize",
                                    "Exemplos de LP vs NLP"
                                  ],
                                  "tips": "Linearize quando possível para simplicidade computacional.",
                                  "learningObjective": "Discernir entre métodos de otimização baseados na estrutura do problema.",
                                  "commonMistakes": [
                                    "Forçar LP em problema não-linear",
                                    "Não considerar convexidade",
                                    "Esquecer bounds"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Formular problema completo e validar",
                                  "subSteps": [
                                    "Escreva formulação padrão: min f(x) s.a. g(x)≤0, h(x)=0, x∈X.",
                                    "Insira dados numéricos exemplo e resolva preliminarmente.",
                                    "Verifique sensibilidade: altere cargas e veja impacto.",
                                    "Documente em LaTeX ou relatório.",
                                    "Identifique possíveis extensões (multiobjetivo)."
                                  ],
                                  "verification": "Problema resolvido com solução factível e ótima plausível.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de otimização (MATLAB, Python)",
                                    "Editor LaTeX",
                                    "Dados de exemplo real"
                                  ],
                                  "tips": "Sempre rode um solver para validar formulação.",
                                  "learningObjective": "Consolidar formulação em um problema pronto para implementação.",
                                  "commonMistakes": [
                                    "Erros de transcrição",
                                    "Solução infactível por restrições conflitantes",
                                    "Não validar numericamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga simplesmente apoiada de L=5m com q=20kN/m: min V=b*h*5, s.a. M_max= (20*25)/8 =31.25kNm ≤ 0.8*fcd*b*h²/6; δ≤L/250 com I=b h³/12; 0.2≤b≤0.5m, 0.3≤h≤1m. Resolver com fmincon em MATLAB dá b≈0.25m, h≈0.45m.",
                              "finalVerifications": [
                                "Função objetivo minimiza recurso chave (volume/custo).",
                                "Todas restrições ULS/SLS cobrem falhas críticas.",
                                "Variáveis dentro de bounds realistas.",
                                "Solução numérica factível e convergida.",
                                "Documentação clara com unidades.",
                                "Sensibilidade testada para variações de carga."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das expressões (sem erros algébricos).",
                                "Completude: todas restrições relevantes incluídas.",
                                "Realismo: solução alinhada com normas e prática.",
                                "Clareza e organização da formulação.",
                                "Justificativa do método de otimização.",
                                "Validação numérica com exemplo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Programação linear/não-linear e análise de sensibilidade.",
                                "Física/Mecânica: Cálculo de esforços internos e deflexões.",
                                "Computação: Implementação em solvers como SciPy ou MATLAB.",
                                "Economia: Minimização de custos em projetos sustentáveis.",
                                "Gestão de Projetos: Otimização em planejamento estrutural."
                              ],
                              "realWorldApplication": "Em projetos de edifícios e pontes, formulações como essa permitem dimensionar vigas com mínimo concreto, reduzindo custos em 10-20%, emissões de CO2 e tempo de obra, usado em softwares como SAP2000 ou otimização custom em firmas como T&B Engenharia."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Resolver otimização de treliças com métodos numéricos",
                            "description": "Implementar algoritmo de otimização (ex.: gradiente descendente ou programação quadrática) para minimizar peso de treliças, considerando autovalores para análise de estabilidade e método dos resíduos ponderados para verificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar a treliça e formular o problema de otimização",
                                  "subSteps": [
                                    "Definir geometria da treliça: nós, barras e condições de contorno.",
                                    "Calcular matriz de rigidez global [K] usando elementos de treliça.",
                                    "Estabelecer função objetivo: minimizar peso total (soma de áreas * densidade * comprimento).",
                                    "Definir restrições: tensões limites, deslocamentos admissíveis e equilíbrio.",
                                    "Formular como problema de otimização: min f(x) s.a. g(x) <= 0, onde x são áreas das barras."
                                  ],
                                  "verification": "Verificar se a matriz [K] é simétrica e positiva definida; função objetivo e restrições codificadas corretamente.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software MATLAB/Python (NumPy/SciPy)",
                                    "Documentação de elementos finitos para treliças",
                                    "Exemplo de treliça 2D simples (10 nós)"
                                  ],
                                  "tips": "Comece com uma treliça pequena (6-10 barras) para depuração rápida; use unidades consistentes (kN, m).",
                                  "learningObjective": "Compreender e implementar a formulação matemática de otimização em estruturas de treliça.",
                                  "commonMistakes": [
                                    "Ignorar simetria na montagem de [K]",
                                    "Esquecer restrições de não-negatividade nas áreas",
                                    "Unidades inconsistentes levando a resultados absurdos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar algoritmo de otimização numérica",
                                  "subSteps": [
                                    "Escolher método: gradiente descendente com projeção ou programação quadrática (QP).",
                                    "Implementar gradiente da função objetivo (derivadas analíticas ou numéricas).",
                                    "Codificar solver iterativo: atualizar x_{k+1} = proj(x_k - α ∇f(x_k)).",
                                    "Incorporar restrições via penalidades ou multiplicadores de Lagrange.",
                                    "Definir critérios de parada: tolerância em ∇f ou número máximo de iterações."
                                  ],
                                  "verification": "Testar em problema não restrito simples; convergência para mínimo conhecido.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Bibliotecas SciPy.optimize ou cvxpy para QP",
                                    "Notebook Jupyter para prototipagem",
                                    "Função teste: Rosenbrock para validar gradiente"
                                  ],
                                  "tips": "Use α adaptativo (backtracking line search) para aceleração; monitore norma do gradiente.",
                                  "learningObjective": "Desenvolver habilidade em codificar e depurar algoritmos de otimização não linear.",
                                  "commonMistakes": [
                                    "Passo α muito grande causando divergência",
                                    "Gradientes numéricos imprecisos por h inadequado",
                                    "Não tratar restrições de desigualdade corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar análise de estabilidade via autovalores",
                                  "subSteps": [
                                    "Resolver [K]u = F para deslocamentos sob cargas.",
                                    "Extrair autovalores menores de [K] para verificar estabilidade (λ_min > threshold).",
                                    "Adicionar restrição: λ_min(x) >= λ_crit no problema de otimização.",
                                    "Implementar solver de autovalores (eigsh para esparsos).",
                                    "Atualizar análise em cada iteração da otimização."
                                  ],
                                  "verification": "λ_min > 0 para configurações factíveis; plotar modos de flambagem.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "SciPy.linalg.eigh ou ARPACK",
                                    "Exemplos de análise modal em treliças",
                                    "Gráficos de modos via Matplotlib"
                                  ],
                                  "tips": "Use decomposição para matrizes esparsas; threshold = 1e-6 * trace([K]).",
                                  "learningObjective": "Aplicar análise espectral para garantir estabilidade em otimização estrutural.",
                                  "commonMistakes": [
                                    "Usar todos autovalores em vez de menores",
                                    "Não normalizar modos",
                                    "Ignorar flambagem local em barras"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar solução com método dos resíduos ponderados e finalizar otimização",
                                  "subSteps": [
                                    "Calcular resíduos r = F - [K]u para cada nó.",
                                    "Aplicar método dos resíduos ponderados: minimizar ||W^{1/2} r||_2 onde W é diagonal de pesos.",
                                    "Comparar solução otimizada com verificação: ||r|| < tol.",
                                    "Avaliar redução de peso: comparar com design inicial.",
                                    "Iterar otimização se verificação falhar."
                                  ],
                                  "verification": "Resíduos ponderados < 1e-6; peso reduzido > 20% sem violar restrições.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código de resíduos de MEF",
                                    "Ferramentas de plotagem de deformadas",
                                    "Relatório template para resultados"
                                  ],
                                  "tips": "Pese mais resíduos em nós críticos (suportes/carregados); visualize malha deformada.",
                                  "learningObjective": "Validar precisão numérica em problemas de MEF otimizados.",
                                  "commonMistakes": [
                                    "Pesos uniformes ignorando importância",
                                    "Tolerância frouxa mascarando erros",
                                    "Não plotar para inspeção visual"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e documentar a solução otimizada",
                                  "subSteps": [
                                    "Compilar métricas: peso final, λ_min, max tensão, tempo de CPU.",
                                    "Sensibilidade: variar cargas e observar robustez.",
                                    "Documentar código com comentários e README.",
                                    "Gerar relatório com gráficos (peso vs iterações, malha otimizada).",
                                    "Testar em treliça maior para generalização."
                                  ],
                                  "verification": "Relatório completo com todas métricas passando critérios; código roda sem erros.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "LaTeX ou Markdown para relatório",
                                    "Git para versionamento",
                                    "Treliça benchmark (25 nós)"
                                  ],
                                  "tips": "Use funções modulares para reutilização; inclua seed para reprodutibilidade.",
                                  "learningObjective": "Sintetizar resultados de otimização em formato profissional.",
                                  "commonMistakes": [
                                    "Falta de reprodutibilidade",
                                    "Gráficos sem legendas/escalas",
                                    "Ignorar trade-offs peso/estabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Otimizar uma treliça 2D de 10 barras suportando carga vertical de 100 kN no centro, minimizando peso de 500 kg inicial para <350 kg, com tensões <= 200 MPa e λ_min > 1e5 N/m, usando gradiente descendente em Python.",
                              "finalVerifications": [
                                "Peso otimizado reduzido em pelo menos 20% do inicial.",
                                "Autovalor mínimo λ_min >= threshold definido.",
                                "Resíduos ponderados < 1e-6 em todos os graus de liberdade.",
                                "Todas restrições de tensão e deslocamento satisfeitas.",
                                "Código converge em <100 iterações para treliça benchmark.",
                                "Visualização da malha otimizada sem instabilidades aparentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação matemática (30%)",
                                "Correção e eficiência do algoritmo de otimização (25%)",
                                "Integração correta de análise de autovalores (20%)",
                                "Validação via resíduos ponderados (15%)",
                                "Qualidade da documentação e visualizações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores), Cálculo (gradientes)",
                                "Programação: NumPy/SciPy para computação científica",
                                "Física: Mecânica dos sólidos, equilíbrio estático",
                                "Engenharia de Software: Modularidade e testes unitários",
                                "Estatística: Análise de sensibilidade e incertezas"
                              ],
                              "realWorldApplication": "Design otimizado de pontes treliçadas, torres de transmissão ou coberturas de estádios, reduzindo material em 15-30% e custos, como na otimização da Ponte Golden Gate ou estruturas sísmicas modernas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Avaliar condicionamento em problemas de otimização estrutural",
                            "description": "Analisar matriz de Gram e condicionamento numérico em modelos de otimização para projetos de lajes ou pilares, ajustando curvas de resposta para melhorar convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Matriz de Gram e Condicionamento Numérico",
                                  "subSteps": [
                                    "Estude a definição de matriz de Gram como produto G = A^T A para uma matriz de restrições A.",
                                    "Aprenda o número de condicionamento κ = σ_max / σ_min, onde σ são valores singulares.",
                                    "Revise impactos de alto condicionamento em otimização: lentidão de convergência e instabilidade numérica.",
                                    "Explore exemplos simples em 2D para visualizar il-condicionamento.",
                                    "Pratique cálculo manual de Gram e condicionamento para matrizes pequenas."
                                  ],
                                  "verification": "Resolva 3 exercícios manuais e confirme κ calculado com fórmula analítica.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de otimização numérica (Nocedal & Wright), Python com NumPy/SciPy, caderno para cálculos manuais.",
                                  "tips": "Use decomposição SVD para valores singulares em vez de autovalores para precisão.",
                                  "learningObjective": "Compreender matematicamente matriz de Gram e métricas de condicionamento em contextos de otimização.",
                                  "commonMistakes": "Confundir autovalores da Gram com singulares da original; ignorar normalização de variáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Modelo de Otimização para Projeto Estrutural",
                                  "subSteps": [
                                    "Defina o problema: minimize peso/custo de laje ou pilar sujeito a restrições de resistência e deformação.",
                                    "Formule variáveis de decisão (ex.: espessuras, armaduras) e restrições lineares/não-lineares.",
                                    "Construa matriz de Jacobiana A das restrições para Gram.",
                                    "Implemente o modelo em software como Python (SciPy.optimize) ou MATLAB.",
                                    "Teste viabilidade inicial rodando otimização sem análise de condicionamento."
                                  ],
                                  "verification": "Modelo roda com solução factível; exporte matriz A para próximo passo.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python/Jupyter com SciPy, exemplos de lajes/pilares em normas ABNT NBR 6118.",
                                  "tips": "Escalone variáveis para unidades semelhantes antes de montar A.",
                                  "learningObjective": "Modelar realisticamente problemas de otimização estrutural com restrições relevantes.",
                                  "commonMistakes": "Restrições mal escalonadas levando a A com escalas díspares; omitir não-linearidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Analisar Matriz de Gram e Condicionamento",
                                  "subSteps": [
                                    "Extraia/compute G = A^T A ou use SVD diretamente em A.",
                                    "Calcule κ(G) via autovalores ou σ_max/σ_min.",
                                    "Identifique autovalores pequenos (direções il-condicionadas).",
                                    "Plote espectro de autovalores e curvas de resposta do solver.",
                                    "Compare κ com thresholds (ex.: <10^6 para boa convergência)."
                                  ],
                                  "verification": "Gere relatório com κ, plot de espectro e tempo de convergência medido.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "NumPy/SciPy para SVD/eigen, Matplotlib para plots, solver de otimização.",
                                  "tips": "Use np.linalg.cond() para verificação rápida; monitore iterações do solver.",
                                  "learningObjective": "Aplicar computacionalmente análise de condicionamento em matrizes reais de otimização.",
                                  "commonMistakes": "Usar norma errada (L2 vs. inf); não considerar efeitos de não-linearidade em A."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diagnosticar Problemas e Ajustar Curvas de Resposta",
                                  "subSteps": [
                                    "Analise curvas de convergência: detecte platôs ou oscilações por il-condicionamento.",
                                    "Aplique regularização: adicione Tikhonov ou reescale restrições.",
                                    "Ajuste parâmetros do solver (tolerâncias, stepsizes) baseado em κ.",
                                    "Re-otimize e compare métricas pré/pós-ajuste.",
                                    "Documente melhorias em tempo/convergência."
                                  ],
                                  "verification": "κ reduzido >50% e convergência 2x mais rápida em re-otimização.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Mesmo ambiente Python; documentação IPOPT ou SLSQP solvers.",
                                  "tips": "Priorize reescalonamento sobre regularização para preservar exatidão.",
                                  "learningObjective": "Diagnosticar e mitigar il-condicionamento via ajustes práticos em solvers.",
                                  "commonMistakes": "Ajustes excessivos distorcendo solução física; ignorar validação estrutural."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Iterar Solução Otimizada",
                                  "subSteps": [
                                    "Verifique solução contra normas (ex.: tensões < limites).",
                                    "Siga sensibilidade: perturbe variáveis e reavalie κ.",
                                    "Gere relatório final com métricas, plots e recomendações.",
                                    "Teste em variação do problema (ex.: pilar em vez de laje).",
                                    "Discuta limitações e extensões (ex.: multi-objetivo)."
                                  ],
                                  "verification": "Relatório completo com solução validada e κ estável em testes de sensibilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software FEA como ANSYS para validação física opcional.",
                                  "tips": "Automatize script para reavaliação rápida de κ.",
                                  "learningObjective": "Integrar análise de condicionamento em workflow completo de otimização estrutural.",
                                  "commonMistakes": "Aceitar solução sem verificação física; subestimar sensibilidade a parâmetros."
                                }
                              ],
                              "practicalExample": "Em um projeto de laje plana de concreto armado (10x10m, cargas vivas 5kN/m²), otimize espessura e armadura minimizando volume sujeito a restrições de flecha (L/250) e punção. Compute G da Jacobiana das 20 restrições, encontre κ=10^8 devido a escalas díspares, reescale e reduza para 10^4, acelerando convergência de 500 para 50 iterações.",
                              "finalVerifications": [
                                "Número de condicionamento κ < 10^6 no modelo final.",
                                "Convergência em <100 iterações com solver padrão.",
                                "Solução satisfaz todas restrições com margens >5%.",
                                "Espectro de autovalores sem gaps >3 ordens de magnitude.",
                                "Teste de sensibilidade: κ varia <20% com ±10% nos inputs.",
                                "Validação física: tensões/deformações dentro de normas ABNT."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de κ e análise de G (90% match com referência).",
                                "Eficácia dos ajustes: redução mensurável em tempo/convergência.",
                                "Qualidade do modelo estrutural: realismo e completude das restrições.",
                                "Clareza de relatórios/plots explicando diagnósticos.",
                                "Criatividade em mitigações além de reescalonamento básico.",
                                "Generalização: sucesso em pelo menos 2 variantes do problema."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Decomposição SVD e análise espectral.",
                                "Programação Computacional: Implementação em Python/SciPy para otimização.",
                                "Engenharia de Software: Automatização de workflows de análise.",
                                "Estatística: Análise de sensibilidade e Monte Carlo para robustez."
                              ],
                              "realWorldApplication": "Em projetos de edifícios altos ou pontes, avaliar condicionamento garante otimização eficiente de elementos como lajes e pilares, reduzindo custos de material em 10-20% e evitando falhas numéricas em softwares comerciais como SAP2000 ou ETABS durante iterações de design."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Otimização na Alocação de Recursos",
                        "description": "Uso de programação matemática para alocar eficientemente mão de obra, equipamentos e materiais em canteiros de obras, minimizando custos e atrasos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Modelar alocação de recursos com programação linear",
                            "description": "Formular modelo PL para alocação ótima de trabalhadores e máquinas em atividades de construção, resolvendo com simplex ou interior-point, considerando restrições de disponibilidade e demandas diárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e identificar variáveis de decisão",
                                  "subSteps": [
                                    "Analise o cenário de construção: identifique atividades (ex: fundação, estrutura, acabamento), recursos disponíveis (trabalhadores e máquinas) e restrições (horas disponíveis por dia, demandas mínimas por atividade).",
                                    "Defina variáveis de decisão: x_ij como número de unidades do recurso i alocadas à atividade j (não-negativas).",
                                    "Estime coeficientes: produtividade por unidade de recurso por atividade (para função objetivo).",
                                    "Liste restrições: soma de alocações por recurso ≤ disponibilidade; soma por atividade ≥ demanda diária.",
                                    "Documente suposições: linearidade, divisibilidade de recursos."
                                  ],
                                  "verification": "Crie um diagrama ou tabela resumindo variáveis, recursos e restrições; verifique se cobre todos os elementos do problema.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta ou planilha Excel para tabelas",
                                    "Descrição do problema de exemplo"
                                  ],
                                  "tips": "Comece com um problema pequeno (2 recursos, 3 atividades) para praticar.",
                                  "learningObjective": "Identificar corretamente todas as componentes de um problema de alocação de recursos.",
                                  "commonMistakes": [
                                    "Esquecer restrições de demanda mínima",
                                    "Definir variáveis não-lineares acidentalmente",
                                    "Ignorar não-negatividade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a função objetivo e as restrições matemáticas",
                                  "subSteps": [
                                    "Escreva a função objetivo: maximizar Z = soma (produtividade_ij * x_ij) para todas i,j.",
                                    "Formule restrições de disponibilidade: para cada recurso i, soma_j (tempo_ij * x_ij) ≤ disponibilidade_i.",
                                    "Adicione restrições de demanda: para cada atividade j, soma_i (produtividade_ij * x_ij) ≥ demanda_j.",
                                    "Inclua restrições de não-negatividade: x_ij ≥ 0 para todos i,j.",
                                    "Verbalize o modelo completo em notação padrão de PL."
                                  ],
                                  "verification": "Escreva o modelo em formato padrão (max Z = ... s.a. ...); confira balanceamento de unidades (ex: horas vs. output).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de edição de texto ou LaTeX para equações",
                                    "Calculadora para estimativas"
                                  ],
                                  "tips": "Use índices duplos claros (i para recursos, j para atividades) para evitar confusão.",
                                  "learningObjective": "Construir um modelo PL matematicamente correto e completo.",
                                  "commonMistakes": [
                                    "Confundir maximização com minimização",
                                    "Esquecer multiplicadores de tempo nas restrições",
                                    "Não balancear lados das inequações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o modelo em software de otimização",
                                  "subSteps": [
                                    "Escolha ferramenta: Python com PuLP ou SciPy.linprog, ou MATLAB.",
                                    "Instale bibliotecas necessárias e importe.",
                                    "Codifique variáveis, objetivo e restrições usando loops para generalidade.",
                                    "Defina solver: método simplex ou interior-point.",
                                    "Teste com dados de exemplo para depuração."
                                  ],
                                  "verification": "Execute o código e verifique se roda sem erros; confira se as restrições são respeitadas na solução inicial.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python instalado com PuLP/SciPy",
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Documentação PuLP"
                                  ],
                                  "tips": "Use variáveis LpVariable.dict para facilitar loops em múltiplas dimensões.",
                                  "learningObjective": "Traduzir modelo matemático para código executável.",
                                  "commonMistakes": [
                                    "Índices errados no código",
                                    "Sentido errado das restrições (≥ vs ≤)",
                                    "Não definir bounds não-negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o modelo, interpretar resultados e análise de sensibilidade",
                                  "subSteps": [
                                    "Execute o solver e obtenha solução ótima (valores x_ij, Z ótimo).",
                                    "Interprete: alocações recomendadas, folgas nas restrições.",
                                    "Realize análise de sensibilidade: variações em coeficientes ou recursos.",
                                    "Valide: verifique se atende demandas e não excede disponibilidades.",
                                    "Gere relatório com gráficos (ex: pizza de alocações)."
                                  ],
                                  "verification": "Compare solução com cálculo manual para problema pequeno; verifique duals/sensibilidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Mesmo software do step 3",
                                    "Bibliotecas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Salve seeds para reprodutibilidade em solvers estocásticos.",
                                  "learningObjective": "Extrair insights acionáveis da solução ótima.",
                                  "commonMistakes": [
                                    "Ignorar soluções inviáveis",
                                    "Interpretar folgas incorretamente",
                                    "Não testar variações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um canteiro de obras: 100 h/dia de trabalhadores, 40 h/dia de escavadeiras para 3 atividades (fundação: demanda 20m³/d, estrutura: 30m²/d, acabamento: 50m²/d). Produtividades: trabalhadores-fundação 0.5m³/h, escavadeiras-estrutura 2m²/h, etc. Modele para maximizar produção total atendendo demandas mínimas.",
                              "finalVerifications": [
                                "Modelo formulado corretamente identifica todas variáveis e restrições.",
                                "Código executa e produz solução factível e ótima.",
                                "Interpretação inclui alocações específicas e valor objetivo.",
                                "Análise de sensibilidade explica impactos de ±10% em um recurso.",
                                "Relatório resume aplicação prática no exemplo.",
                                "Solução manual para caso reduzido coincide com computacional."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática do modelo (100% das restrições corretas).",
                                "Funcionalidade e eficiência do código (roda em <1min, sem erros).",
                                "Profundidade da interpretação e sensibilidade (≥3 insights).",
                                "Clareza da documentação e gráficos.",
                                "Criatividade em extensões (ex: adicionar custos).",
                                "Alinhamento com contexto de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Integra com CPM/PERT para scheduling.",
                                "Economia: Análise custo-benefício em alocações.",
                                "Estatística: Sensibilidade como análise de risco.",
                                "Programação: Algoritmos numéricos em solvers.",
                                "Sustentabilidade: Otimizar para minimizar desperdício de recursos."
                              ],
                              "realWorldApplication": "Em obras civis como construção de pontes ou edifícios, otimiza alocação diária de equipes e equipamentos para cumprir prazos e orçamentos, reduzindo ociosidade em até 20% e evitando atrasos por falta de recursos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Aplicar método de Monte Carlo em cenários de alocação incerta",
                            "description": "Gerar números aleatórios para simular variações em suprimentos e demandas, otimizando alocação de recursos com integração de Monte Carlo e solução de equações não-lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema de alocação e identificar variáveis incertas",
                                  "subSteps": [
                                    "Analise o cenário de alocação de recursos em engenharia civil, como suprimentos de materiais e demandas de obra.",
                                    "Identifique variáveis incertas: suprimentos (ex: volume de concreto), demandas (ex: consumo por seção da obra).",
                                    "Defina restrições: orçamento total, prazos, capacidades de armazenamento.",
                                    "Estabeleça o objetivo: minimizar custos ou desperdícios sob incerteza.",
                                    "Documente o modelo matemático inicial com equações não-lineares para alocação ótima."
                                  ],
                                  "verification": "Modelo do problema documentado com variáveis, restrições e objetivo claramente definidos em um diagrama ou relatório.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Papel e caneta ou software de diagramação (Draw.io)",
                                    "Planilha Excel para prototipagem inicial"
                                  ],
                                  "tips": "Comece com um exemplo simples de uma obra pequena para validar o entendimento antes de complexificar.",
                                  "learningObjective": "Compreender e modelar problemas de alocação de recursos com incertezas em contextos de engenharia civil.",
                                  "commonMistakes": [
                                    "Ignorar correlações entre variáveis incertas",
                                    "Definir distribuições inadequadas sem base em dados históricos",
                                    "Esquecer restrições não-lineares como capacidades limitadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer distribuições probabilísticas para variáveis incertas",
                                  "subSteps": [
                                    "Colete dados históricos ou estime parâmetros para distribuições (ex: normal para suprimentos, log-normal para demandas).",
                                    "Escolha distribuições apropriadas: uniforme para variações uniformes, triangular para expert opinions.",
                                    "Defina parâmetros: média, desvio padrão, limites mínimo/máximo para cada variável.",
                                    "Valide distribuições com testes estatísticos simples ou gráficos (histograma, Q-Q plot).",
                                    "Integre ao modelo: represente variáveis como funções aleatórias."
                                  ],
                                  "verification": "Distribuições parametrizadas e validadas, com gráficos gerados mostrando realismo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com bibliotecas NumPy, SciPy e Matplotlib",
                                    "Dados históricos de projetos civis (fontes públicas ou simulados)"
                                  ],
                                  "tips": "Use distribuições conservadoras (caudas pesadas) para cenários de risco alto em engenharia.",
                                  "learningObjective": "Selecionar e parametrizar distribuições probabilísticas adequadas para modelagem de incertezas.",
                                  "commonMistakes": [
                                    "Assumir normalidade sem justificativa",
                                    "Usar médias pontuais em vez de distribuições",
                                    "Ignorar dependências entre suprimentos e demandas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a simulação Monte Carlo",
                                  "subSteps": [
                                    "Gere N amostras (ex: 10.000) de números aleatórios para cada variável incerta usando funções de amostragem.",
                                    "Para cada iteração, calcule alocação via solução de equações não-lineares (ex: usando fsolve do SciPy).",
                                    "Registre métricas: custo total, desperdício, violações de restrições por iteração.",
                                    "Execute a simulação em loop e armazene resultados em arrays.",
                                    "Visualize distribuições de saída com histogramas e estatísticas descritivas (média, percentis)."
                                  ],
                                  "verification": "Simulação executada com pelo menos 5.000 iterações, produzindo histogramas e estatísticas sem erros.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "Bibliotecas: NumPy, SciPy (optimize.fsolve), Pandas, Matplotlib"
                                  ],
                                  "tips": "Teste com poucas iterações primeiro para depurar código antes de escalar para N grande.",
                                  "learningObjective": "Implementar simulações Monte Carlo para propagar incertezas em modelos de otimização.",
                                  "commonMistakes": [
                                    "Poucas iterações levando a variância alta",
                                    "Não tratar falhas na solução não-linear",
                                    "Vazamento de aleatoriedade entre iterações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar alocação e analisar resultados da simulação",
                                  "subSteps": [
                                    "Use percentis da simulação (ex: 95%) para definir alocações robustas ou cenários de risco.",
                                    "Integre Monte Carlo em otimização estocástica: minimize custo esperado sujeito a restrições probabilísticas.",
                                    "Resolva o problema otimizado com solvers não-lineares, usando médias ou cenários da simulação.",
                                    "Gere relatório: alocação ótima, intervalos de confiança, sensibilidade a parâmetros.",
                                    "Valide com cenários determinísticos para comparação."
                                  ],
                                  "verification": "Alocação ótima computada com métricas de risco, relatório gerado com visualizações.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python com SciPy.optimize",
                                    "Jupyter Notebook para relatórios interativos"
                                  ],
                                  "tips": "Foque em otimização robusta (worst-case) para aplicações civis críticas.",
                                  "learningObjective": "Integrar resultados Monte Carlo em decisões de otimização para alocações incertas.",
                                  "commonMistakes": [
                                    "Interpretar apenas a média ignorando risco",
                                    "Não calibrar com dados reais",
                                    "Sobrecarregar o modelo com muitas variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar o modelo",
                                  "subSteps": [
                                    "Compare resultados com dados reais ou benchmarks de projetos semelhantes.",
                                    "Realize análise de sensibilidade: varie parâmetros de distribuição e observe impactos.",
                                    "Ajuste modelo baseado em feedback: refine distribuições ou adicione variáveis.",
                                    "Documente limitações e recomendações para uso prático.",
                                    "Prepare apresentação ou dashboard para stakeholders."
                                  ],
                                  "verification": "Modelo validado com análise de sensibilidade e relatório final completo.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Python com Seaborn para visualizações avançadas",
                                    "Ferramentas de dashboard como Plotly Dash (opcional)"
                                  ],
                                  "tips": "Sempre inclua um 'sanity check' comparando com solução determinística.",
                                  "learningObjective": "Validar e iterar modelos Monte Carlo para robustez em aplicações reais.",
                                  "commonMistakes": [
                                    "Não testar sensibilidade",
                                    "Aceitar resultados sem validação externa",
                                    "Ignorar computacional custo em refinamentos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma obra de ponte, suprimentos de aço chegam com variação normal (média 100t, dp 10t) e demanda por seção varia log-normalmente. Simule 10k cenários Monte Carlo para otimizar alocação entre seções, resolvendo não-lineares para minimizar desperdício >5% com 95% confiança, resultando em alocação ajustada de 105t para seção crítica.",
                              "finalVerifications": [
                                "Simulação converge com <1% variância em estatísticas chave após 10k iterações.",
                                "Alocação ótima respeita todas restrições probabilísticas (ex: P(violações)<5%).",
                                "Histogramas de saídas mostram distribuições realistas sem anomalias.",
                                "Análise de sensibilidade identifica variáveis críticas.",
                                "Comparação com determinístico mostra ganho de robustez.",
                                "Código roda em <5min e é reproduzível com seed fixa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de incertezas (distribuições justificadas: 20%)",
                                "Correta implementação Monte Carlo e integração não-linear (30%)",
                                "Qualidade da análise e interpretação de resultados (25%)",
                                "Robustez e validação do modelo (15%)",
                                "Clareza de documentação e visualizações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: Distribuições e amostragem aleatória.",
                                "Programação Computacional: Python/NumPy para simulações numéricas.",
                                "Otimização Matemática: Solvers não-lineares e estocástica.",
                                "Gestão de Projetos: Análise de risco em engenharia.",
                                "Engenharia de Dados: Sensibilidade e validação de modelos."
                              ],
                              "realWorldApplication": "Otimização de alocação de recursos em construções civis sob incertezas climáticas ou logísticas, como em projetos de infraestrutura onde suprimentos de cimento variam por chuvas, reduzindo custos em 10-20% e evitando atrasos em obras como barragens ou rodovias."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Otimizar estoques de materiais com redes neurais",
                            "description": "Treinar rede neural artificial para prever demandas e otimizar níveis de estoque, integrando ajuste de curvas e programação matemática para minimizar custos de armazenamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e Preparação de Dados Históricos de Demanda",
                                  "subSteps": [
                                    "Identificar fontes de dados: registros de compras, uso diário de materiais e fatores externos como clima ou atrasos em obras.",
                                    "Coletar dados de pelo menos 12-24 meses de demanda de materiais como cimento, aço ou areia.",
                                    "Limpar dados: remover outliers, tratar valores ausentes e normalizar séries temporais.",
                                    "Realizar feature engineering: aplicar ajuste de curvas (ex: regressão polinomial ou exponencial) para suavizar tendências sazonais.",
                                    "Dividir dados em treino (70%), validação (15%) e teste (15%)."
                                  ],
                                  "verification": "Dataset preparado exportado em CSV com pelo menos 80% de completude e features validadas via gráficos de correlação.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Planilhas Excel ou Google Sheets",
                                    "Python com pandas, numpy e matplotlib",
                                    "Dados históricos simulados ou reais de estoque"
                                  ],
                                  "tips": [
                                    "Use rolling averages para suavizar ruído; visualize dados com plots de séries temporais antes de prosseguir."
                                  ],
                                  "learningObjective": "Preparar dados de alta qualidade para treinamento de redes neurais em previsão de demanda.",
                                  "commonMistakes": [
                                    "Ignorar sazonalidade na construção civil",
                                    "Não tratar outliers de picos de obra",
                                    "Sobrecarregar features irrelevantes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construção e Treinamento da Rede Neural para Previsão de Demanda",
                                  "subSteps": [
                                    "Definir arquitetura da NN: camadas densas com 2-3 hidden layers, ativação ReLU e saída linear para regressão.",
                                    "Implementar em Python com Keras/TensorFlow: compilar com otimizador Adam e loss MSE.",
                                    "Treinar o modelo com dados preparados, usando early stopping e validação cruzada temporal.",
                                    "Ajustar hiperparâmetros: grid search para learning rate, batch size e neurônios por camada.",
                                    "Avaliar no conjunto de teste: calcular métricas como MAE, RMSE e MAPE."
                                  ],
                                  "verification": "Modelo treinado salva em .h5 com RMSE < 10% no teste e gráficos de previsão vs real.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Python com TensorFlow/Keras",
                                    "Jupyter Notebook",
                                    "GPU opcional para aceleração"
                                  ],
                                  "tips": [
                                    "Normalize inputs entre 0-1; use dropout (0.2) para evitar overfitting em datasets pequenos."
                                  ],
                                  "learningObjective": "Treinar uma rede neural eficaz para prever demandas variáveis em contextos de engenharia civil.",
                                  "commonMistakes": [
                                    "Overfitting por falta de regularização",
                                    "Não usar divisão temporal nos dados",
                                    "Ignorar escalabilidade para grandes obras"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formulação do Modelo de Otimização Matemática de Estoques",
                                  "subSteps": [
                                    "Definir variáveis: níveis de estoque ótimo S(t), custos de holding h, custos de pedido c, demanda prevista D(t) da NN.",
                                    "Formular problema: minimizar custo total C = soma(h*S(t) + c*pedidos) sujeito a S(t) >= D(t) e capacidades.",
                                    "Implementar em programação linear/inteira mista (MILP) usando PuLP ou Gurobi.",
                                    "Incorporar previsões da NN como constraints estocásticos com cenários (otimista/pessimista).",
                                    "Resolver o modelo para horizonte de 6-12 meses."
                                  ],
                                  "verification": "Modelo de otimização resolvido com relatório de custos e níveis de estoque gerados em tabela.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Python com PuLP ou SciPy.optimize",
                                    "Previsões da NN do step anterior"
                                  ],
                                  "tips": [
                                    "Comece com EOQ clássico e evolua para dinâmico; teste sensibilidade a variações na previsão."
                                  ],
                                  "learningObjective": "Integrar previsões de IA com programação matemática para otimização de recursos.",
                                  "commonMistakes": [
                                    "Não considerar lead times de fornecedores",
                                    "Restrições irrealistas de capacidade",
                                    "Ignorar custos ocultos como depreciação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração, Simulação e Refinamento do Sistema Completo",
                                  "subSteps": [
                                    "Integrar NN e otimizador em pipeline único: prever demanda e otimizar estoques iterativamente.",
                                    "Simular cenários: baseline (sem NN), com NN e com erros intencionais na previsão.",
                                    "Avaliar redução de custos e service level (taxa de atendimento de demanda).",
                                    "Refinar: re-treinar NN com feedback de simulação e ajustar modelo de otimização.",
                                    "Documentar sistema com dashboard interativo (ex: Streamlit)."
                                  ],
                                  "verification": "Dashboard rodando com simulações mostrando redução de custos >15% vs baseline.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com Streamlit ou Dash",
                                    "Modelos dos steps anteriores"
                                  ],
                                  "tips": [
                                    "Automatize pipeline com funções modulares; valide com dados reais de obra pequena."
                                  ],
                                  "learningObjective": "Desenvolver e validar um sistema end-to-end para otimização de estoques em engenharia civil.",
                                  "commonMistakes": [
                                    "Falta de integração robusta entre módulos",
                                    "Simulações sem variabilidade real",
                                    "Não documentar para reutilização"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma obra de construção de ponte, use dados históricos de uso de aço para treinar uma NN que prevê demanda semanal baseada em progresso e clima. Integre com MILP para otimizar pedidos semanais, reduzindo estoque de 20% e custos de armazenamento em 18%.",
                              "finalVerifications": [
                                "Previsão da NN atinge MAPE < 8% em dados de teste out-of-sample.",
                                "Modelo de otimização reduz custos totais em pelo menos 12% vs heurística tradicional.",
                                "Service level > 95% em simulações com variabilidade de demanda.",
                                "Pipeline integrado executa em < 5 minutos para horizonte de 1 ano.",
                                "Dashboard permite ajustes interativos e exporta relatórios.",
                                "Sensibilidade testada: sistema robusto a ±20% erro na previsão."
                              ],
                              "assessmentCriteria": [
                                "Precisão da previsão (40%): métricas de erro baixas e gráficos convincentes.",
                                "Eficácia da otimização (30%): redução quantificável de custos e estoques.",
                                "Qualidade da integração (15%): pipeline sem erros e modular.",
                                "Documentação e usabilidade (10%): código comentado e dashboard intuitivo.",
                                "Análise de robustez (5%): testes de cenários extremos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Séries Temporais: para feature engineering e validação.",
                                "Inteligência Artificial: fundamentos de redes neurais e deep learning.",
                                "Gestão de Operações: conceitos de inventory management e supply chain.",
                                "Programação Avançada: Python para ML e otimização.",
                                "Engenharia de Produção: aplicações em planejamento de recursos finitos."
                              ],
                              "realWorldApplication": "Em canteiros de obra civis, como barragens ou rodovias, onde flutuações de demanda por materiais (cimento, agregados) causam excessos caros ou faltas críticas; sistemas assim reduzem desperdícios em até 25%, integrando-se a ERPs como SAP para automação contínua."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Otimização no Planejamento de Obras Civis",
                        "description": "Técnicas de otimização para sequenciamento de tarefas, controle de prazos e gerenciamento de riscos em cronogramas de obras civis.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Otimizar cronogramas com programação inteira",
                            "description": "Formular problema de programação inteira mista para minimizar duração total da obra (makespan), integrando problemas de valor inicial para modelagem dinâmica de tarefas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Programação Inteira e Scheduling de Projetos",
                                  "subSteps": [
                                    "Estude conceitos básicos de Programação Linear Inteira (PLI) e Mista (PLIM).",
                                    "Revise o problema RCPSP (Resource-Constrained Project Scheduling Problem).",
                                    "Analise o objetivo de minimizar makespan (duração total da obra).",
                                    "Identifique precedências entre tarefas e restrições de recursos."
                                  ],
                                  "verification": "Explique em suas palavras o que é makespan e liste 3 restrições típicas de RCPSP.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Project Scheduling' de Brucker",
                                    "Documentação PuLP ou Gurobi",
                                    "Artigos sobre RCPSP"
                                  ],
                                  "tips": "Use diagramas de Gantt para visualizar precedências.",
                                  "learningObjective": "Dominar terminologia e estrutura básica de problemas de agendamento.",
                                  "commonMistakes": [
                                    "Confundir PLI com PLP contínua.",
                                    "Ignorar restrições de recursos renováveis vs. não-renováveis."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Variáveis e Função Objetivo do Modelo MIP",
                                  "subSteps": [
                                    "Defina variáveis de decisão: tempo de início (S_i), alocação de recursos (X_{i,r}).",
                                    "Estabeleça função objetivo: minimizar max(S_i + D_i).",
                                    "Introduza variáveis binárias para precedências (Y_{ij}).",
                                    "Inclua variáveis auxiliares para linearizar o makespan (M)."
                                  ],
                                  "verification": "Escreva a função objetivo e liste todas variáveis com seus domínios.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Solver gratuito como CBC via PuLP (Python)",
                                    "Planilhas Excel para prototipagem"
                                  ],
                                  "tips": "Sempre linearize max() usando big-M formulation.",
                                  "learningObjective": "Formular corretamente a estrutura matemática inicial do problema.",
                                  "commonMistakes": [
                                    "Esquecer domínios inteiros/binários.",
                                    "Usar variáveis contínuas onde discretas são necessárias."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Restrições de Precedência, Recursos e Capacidade",
                                  "subSteps": [
                                    "Adicione restrições de precedência: S_j >= S_i + D_i + M*(1 - Y_{ij}).",
                                    "Implemente limites de recursos: sum(X_{i,r} for i in ativos) <= Capacidade_r.",
                                    "Inclua não-negatividade e limites de tempo de tarefas.",
                                    "Teste consistência com um exemplo pequeno (3 tarefas)."
                                  ],
                                  "verification": "Valide o modelo com um grafo de precedências simples sem violações.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com PuLP instalado",
                                    "Exemplos de instâncias RCPSP (PSPLIB dataset)"
                                  ],
                                  "tips": "Comece com instâncias pequenas para depuração.",
                                  "learningObjective": "Construir um modelo MIP completo e factível.",
                                  "commonMistakes": [
                                    "Restrições de precedência fracas levando a ciclos.",
                                    "Sobrestimar capacidades de recursos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Problemas de Valor Inicial para Modelagem Dinâmica",
                                  "subSteps": [
                                    "Modele durações dinâmicas D_i(t) baseadas em condições iniciais (ex: progresso inicial).",
                                    "Incorpore equações de valor inicial: D_i = f(estado_inicial, recursos).",
                                    "Adicione variáveis para estados dinâmicos (ex: integrando IVPs simplificadas).",
                                    "Ajuste o modelo para tarefas com dependências evolutivas (ex: cura de concreto)."
                                  ],
                                  "verification": "Modifique o modelo para uma tarefa com D_i dependente de tempo inicial e resolva.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Documentação de solvers para não-lineares (se approx)",
                                    "Tutoriais Pyomo para dinâmica"
                                  ],
                                  "tips": "Aproxime dinâmicas com discretização temporal.",
                                  "learningObjective": "Incorporar aspectos dinâmicos em otimização estática.",
                                  "commonMistakes": [
                                    "Ignorar não-convexidade introduzida por dinâmicas.",
                                    "Não inicializar solvers adequadamente."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar, Resolver e Analisar o Modelo Otimizado",
                                  "subSteps": [
                                    "Codifique o modelo completo em Python/PuLP ou Gurobi.",
                                    "Execute o solver e analise solução ótima (tempos, alocações).",
                                    "Sensitividade: varie condições iniciais e observe makespan.",
                                    "Gere relatório com Gantt chart da solução."
                                  ],
                                  "verification": "Obtenha makespan ótimo para exemplo padrão e compare com heurística.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Ambiente Python (Jupyter Notebook)",
                                    "Biblioteca matplotlib para Gantt"
                                  ],
                                  "tips": "Use callbacks para limites de tempo em problemas grandes.",
                                  "learningObjective": "Aplicar solver MIP para otimizar cronogramas reais.",
                                  "commonMistakes": [
                                    "Não escalar problemas grandes (use relaxações).",
                                    "Interpretar erroneamente status do solver."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de construção de ponte com 8 tarefas (fundação, pilares, vigas, etc.), precedências lógicas, 2 guindastes limitados e condição inicial de 20% progresso na fundação afetando durações dinâmicas de cura; formule MIP para minimizar makespan de 45 para 32 dias.",
                              "finalVerifications": [
                                "Modelo MIP resolve com status ótimo.",
                                "Makespan minimizado respeita todas precedências e recursos.",
                                "Variação de condições iniciais altera solução corretamente.",
                                "Gantt chart visual sem sobreposições inválidas.",
                                "Solução factível para instância PSPLIB.",
                                "Análise de sensibilidade identifica gargalos.",
                                "Código roda em <5min para n=20 tarefas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação matemática (100% restrições corretas).",
                                "Eficiência computacional (tempo solver <10% makespan).",
                                "Validação com exemplos reais (erro <5%).",
                                "Integração dinâmica funcional (variação D_i coerente).",
                                "Relatório claro com insights acionáveis.",
                                "Criatividade em extensões (multi-modo).",
                                "Reprodutibilidade do código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização Não-Linear e DEs.",
                                "Informática: Programação em Python e Solvers MIP.",
                                "Gestão de Projetos: CPM/PERT e MS Project.",
                                "Estatística: Análise de Sensibilidade e Monte Carlo.",
                                "Engenharia de Software: Modelagem e Validação."
                              ],
                              "realWorldApplication": "Em canteiros de obras civis, como barragens ou rodovias, para reduzir atrasos e custos, integrando dados reais de sensores IoT para condições iniciais dinâmicas, economizando até 20% no tempo total de execução."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Usar autofunções em análise de riscos de planejamento",
                            "description": "Aplicar autovalores e autofunções para decompor variâncias em cronogramas PERT/CPM, otimizando alocação de folgas com métodos numéricos de Chapra e Canale.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Cronogramas PERT/CPM e Análise de Variância",
                                  "subSteps": [
                                    "Estude os conceitos básicos de redes PERT/CPM, incluindo caminhos críticos e cálculo de folgas totais/livres.",
                                    "Revise estatística descritiva: variância, desvio padrão e matriz de covariância para atividades interdependentes.",
                                    "Identifique fontes de variância em projetos civis, como atrasos em suprimentos ou condições climáticas.",
                                    "Construa um exemplo simples de cronograma PERT com 5-7 atividades e calcule variâncias manualmente.",
                                    "Explore o livro de Chapra e Canale (Capítulo 11) sobre métodos numéricos para análise de incertezas."
                                  ],
                                  "verification": "Crie um diagrama PERT/CPM com variâncias calculadas e folgas identificadas corretamente.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Livro 'Métodos Numéricos' de Chapra e Canale (edição recente), software MS Project ou Primavera, planilha Excel.",
                                  "tips": "Use diagramas de rede para visualizar dependências antes de calcular variâncias.",
                                  "learningObjective": "Compreender como variâncias em atividades afetam o risco total do cronograma.",
                                  "commonMistakes": "Ignorar dependências entre atividades ao calcular variâncias agregadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Autovalores e Autofunções para Decomposição de Variância",
                                  "subSteps": [
                                    "Aprenda a definição matemática de autovalores (λ) e autofunções (v) de uma matriz simétrica (A v = λ v).",
                                    "Estude decomposição em autovalores para matrizes de covariância em análise de componentes principais (PCA).",
                                    "Implemente em Python/MATLAB o cálculo de autovalores e autofunções usando bibliotecas como NumPy ou eig().",
                                    "Aplique a uma matriz de covariância 3x3 fictícia para decompor variância em componentes principais.",
                                    "Interprete os autovalores como proporções de variância explicada por cada autofunção."
                                  ],
                                  "verification": "Execute um script que diagonaliza uma matriz de covariância e lista autovalores ordenados.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Python com NumPy/SciPy, MATLAB (se disponível), tutoriais online sobre eigendecomposição.",
                                  "tips": "Sempre normalize as autofunções para interpretação como direções de máxima variância.",
                                  "learningObjective": "Dominar o uso de eigendecomposição para identificar direções principais de variância.",
                                  "commonMistakes": "Confundir autovalores com variâncias absolutas sem normalizar a matriz."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar Matriz de Covariância em Cronogramas PERT/CPM",
                                  "subSteps": [
                                    "Construa a matriz de covariância Σ para variâncias de durações de atividades em um cronograma PERT.",
                                    "Mapeie atividades como vetores e dependências como off-diagonais na matriz Σ.",
                                    "Calcule autovalores/autofunções de Σ para decompor variâncias totais do caminho crítico.",
                                    "Projeite variâncias de folgas totais usando autofunções dominantes (maiores autovalores).",
                                    "Valide com simulação Monte Carlo de 1000 iterações para comparar decomposição analítica."
                                  ],
                                  "verification": "Gere relatório com matriz Σ decomposada e % de variância explicada pelo primeiro autovalor.",
                                  "estimatedTime": "6 horas",
                                  "materials": "Software Python (Pandas, NumPy), planilha com dados de cronograma exemplo.",
                                  "tips": "Use dados reais de projetos civis para matriz Σ realista, assumindo correlações de 0.2-0.5.",
                                  "learningObjective": "Aplicar eigendecomposição diretamente à matriz de covariância de um cronograma.",
                                  "commonMistakes": "Não considerar correlações zero entre atividades independentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar Alocação de Folgas Usando Métodos Numéricos de Chapra e Canale",
                                  "subSteps": [
                                    "Implemente método de Newton-Raphson (Chapra Cap. 6) para otimizar alocação de folgas sob restrições de variância.",
                                    "Defina função objetivo: minimizar variância total ponderada pelas autofunções principais.",
                                    "Incorpore autovalores para priorizar redução de risco em direções de alta variância.",
                                    "Resolva numericamente com gradiente descendente ou otimizadores SciPy para alocação ótima.",
                                    "Avalie sensibilidade alterando autovalores e recalculando folgas otimizadas."
                                  ],
                                  "verification": "Otimize um cronograma exemplo reduzindo variância total em pelo menos 20%.",
                                  "estimatedTime": "7 horas",
                                  "materials": "Código Python com SciPy.optimize, exemplos do livro Chapra e Canale (Cap. 20 sobre otimização).",
                                  "tips": "Inicialize com folgas uniformes e use autovalores como pesos no objetivo.",
                                  "learningObjective": "Integrar eigendecomposição com otimização numérica para gerenciamento de riscos.",
                                  "commonMistakes": "Violar restrições de folga total ao otimizar apenas variância local."
                                }
                              ],
                              "practicalExample": "Em um projeto de construção de uma ponte com 10 atividades (fundação, vigas, pavimentação), construa matriz Σ de covariâncias devido a clima/suprimentos. Decomponha com autofunções para identificar que 70% da variância vem de atrasos em fundação. Otimize alocação de 15 dias de folga total, reduzindo risco de atraso em 25%.",
                              "finalVerifications": [
                                "Cronograma PERT/CPM com matriz Σ corretamente construída e eigendecomposta.",
                                "Script Python/MATLAB executável que calcula e interpreta autovalores/autofunções.",
                                "Otimização numérica converge para alocação de folgas com redução mensurável de variância.",
                                "Relatório compara resultados analíticos vs. simulação Monte Carlo (erro <5%).",
                                "Identificação precisa das 2-3 principais autofunções responsáveis por risco.",
                                "Aplicação sensível a mudanças em correlações de entrada."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na decomposição (autovalores somam traço de Σ).",
                                "Correta interpretação de autofunções como direções de risco principal.",
                                "Eficiência da otimização (convergência em <50 iterações).",
                                "Validação cruzada com métodos alternativos (ex: Monte Carlo).",
                                "Clareza no relatório com visualizações (gráficos de variância explicada).",
                                "Aplicação contextualizada a engenharia civil real."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de Componentes Principais (PCA) e multivariada.",
                                "Programação: Implementação numérica em Python/MATLAB (SciPy/NumPy).",
                                "Gerenciamento de Projetos: Integração com PMBOK para análise de riscos.",
                                "Matemática Aplicada: Álgebra Linear e Métodos Numéricos (Chapra).",
                                "Engenharia de Software: Desenvolvimento de ferramentas de otimização customizadas."
                              ],
                              "realWorldApplication": "Em obras civis como construção de rodovias ou barragens, usa-se para priorizar buffers de tempo em atividades de alto risco (ex: escavação em solos variáveis), reduzindo atrasos em 15-30% e custos overrun, conforme casos da Odebrecht ou construtoras europeias com PERT avançado."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Simular planejamento com problemas de valor de contorno",
                            "description": "Resolver problemas de valor de contorno para modelar fluxos de trabalho contínuos, otimizando planejamento de obras com resíduos ponderados e validação via MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o Problema de Valor de Contorno (BVP) para Fluxos Contínuos em Planejamento de Obras",
                                  "subSteps": [
                                    "Identifique o processo contínuo a modelar, como fluxo de materiais ou mão de obra ao longo do tempo ou espaço da obra (ex.: construção linear de uma ponte).",
                                    "Defina a equação diferencial ordinária (EDO) que representa o fluxo, como d²u/dx² + f(x) = 0 para equilíbrio de cargas.",
                                    "Especifique condições de contorno: valores fixos nas extremidades (ex.: u(0) = inicial, u(L) = final).",
                                    "Incorpore resíduos ponderados definindo pesos para minimizar erros em pontos críticos da obra.",
                                    "Documente a formulação matemática em notação clara."
                                  ],
                                  "verification": "Verifique se a EDO e condições de contorno correspondem ao problema real da obra e se os resíduos ponderados estão definidos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Papel e caneta ou software como LaTeX/Overleaf; documentação de problemas de engenharia civil.",
                                  "tips": "Comece com um problema simples unidimensional para validar a intuição antes de complexidades.",
                                  "learningObjective": "Compreender como traduzir fluxos reais de obras em BVPs matemáticos com otimização de resíduos.",
                                  "commonMistakes": "Ignorar unidades inconsistentes nas condições de contorno ou pesos inadequados para resíduos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Discretizar o BVP Usando Método de Diferenças Finitas",
                                  "subSteps": [
                                    "Divida o domínio [0, L] em N pontos equidistantes com passo h = L/(N-1).",
                                    "Aproxime derivadas: du/dx ≈ (u_{i+1} - u_{i-1})/(2h), d²u/dx² ≈ (u_{i+1} - 2u_i + u_{i-1})/h².",
                                    "Monte o sistema linear Au = b, onde A é a matriz tridiagonal esparsa derivada da discretização.",
                                    "Inclua condições de contorno ajustando linhas de A e b para u(1) e u(N).",
                                    "Teste a matriz A para simetria e positiva definitividade."
                                  ],
                                  "verification": "Resolva o sistema analiticamente para N pequeno e compare com solução exata conhecida.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB ou Python (NumPy/SciPy); calculadora matricial.",
                                  "tips": "Use malha fina (N>100) só após validar com malha grosseira para economizar tempo.",
                                  "learningObjective": "Dominar a discretização numérica de BVPs para gerar sistemas lineares solucionáveis.",
                                  "commonMistakes": "Erro na indexação de fronteiras (i=1 e i=N) ou aproximação errada de derivadas de segunda ordem."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Otimização com Resíduos Ponderados em MATLAB",
                                  "subSteps": [
                                    "Escreva script MATLAB para gerar A, b e vetor de pesos W baseado em importância de pontos (ex.: regiões críticas da obra).",
                                    "Defina função de resíduo: r = W*(Au - b), minimize ||r||² usando lsqminnorm ou fmincon.",
                                    "Incorpore solução inicial u0 e configure tolerâncias (ex.: 1e-8).",
                                    "Execute simulação iterativa e plote u(x) vs. x.",
                                    "Salve resultados em arquivo .mat para análise posterior."
                                  ],
                                  "verification": "Confira se ||Au - b|| < 1e-6 e resíduos ponderados são uniformemente pequenos.",
                                  "estimatedTime": "4 horas",
                                  "materials": "MATLAB com Optimization Toolbox; exemplos de código de diferenças finitas.",
                                  "tips": "Vetorize operações em MATLAB para velocidade; use sparse() para matrizes grandes.",
                                  "learningObjective": "Aplicar otimização numérica para soluções robustas de BVPs com pesos em contextos de engenharia.",
                                  "commonMistakes": "Pesos W mal normalizados levando a viés em resíduos ou não usar sparse para N grande."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Simulação e Otimizar Planejamento de Obras",
                                  "subSteps": [
                                    "Compare solução numérica com solução analítica ou dados reais de obra simulada.",
                                    "Analise convergência variando N e h; plote erro vs. h em log-log.",
                                    "Otimize parâmetros da obra (ex.: alocação de recursos) minimizando tempo total ou custo via sensibilidade.",
                                    "Gere relatório com gráficos de fluxo otimizado e cronograma.",
                                    "Teste cenários sensíveis (ex.: atrasos em contorno inicial)."
                                  ],
                                  "verification": "Ordem de convergência deve ser O(h²); erro < 1% para dados reais.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB plotting tools; dados de caso real de obra civil.",
                                  "tips": "Use hold on para múltiplas curvas em um plot; exporte para PDF.",
                                  "learningObjective": "Validar precisão numérica e aplicar resultados para otimização prática de planejamento.",
                                  "commonMistakes": "Não testar convergência ou ignorar efeitos de fronteira em malhas irregulares."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados e Iterar para Melhoria",
                                  "subSteps": [
                                    "Interprete gráficos: identifique gargalos no fluxo (picos em u(x)).",
                                    "Calcule métricas: tempo total da obra, custo ponderado, eficiência.",
                                    "Itere ajustando pesos ou modelo (ex.: adicionar não-linearidades).",
                                    "Documente lições aprendidas e proponha melhorias para obras reais.",
                                    "Compartilhe código em repositório Git para versionamento."
                                  ],
                                  "verification": "Métricas otimizadas melhoram >10% vs. baseline não-otimizado.",
                                  "estimatedTime": "2 horas",
                                  "materials": "GitHub; planilhas Excel para métricas.",
                                  "tips": "Foque em 2-3 insights acionáveis por análise para evitar sobrecarga.",
                                  "learningObjective": "Extrair valor prático de simulações para decisões de engenharia civil.",
                                  "commonMistakes": "Sobreajuste do modelo a ruído em vez de tendências reais."
                                }
                              ],
                              "practicalExample": "Simule o fluxo contínuo de concreto em uma obra de pavimentação de 1km de estrada. Condições: fluxo inicial 100m³/h em x=0, final 0 em x=1km. Otimize alocação de bombas minimizando resíduos ponderados em zonas de alta demanda (meio da obra), validando em MATLAB para reduzir tempo total de 10 para 8 horas.",
                              "finalVerifications": [
                                "Solução satisfaz condições de contorno com erro <1e-6.",
                                "Resíduos ponderados ||W*(Au-b)|| < 1e-8.",
                                "Convergência demonstrada com ordem O(h²) em plots log-log.",
                                "Gráficos de u(x) mostram fluxo realista sem oscilações.",
                                "Métricas de planejamento (tempo/custo) melhoradas vs. baseline.",
                                "Código MATLAB executável e comentado roda sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro de discretização <1%.",
                                "Eficiência computacional: tempo de execução <5min para N=1000.",
                                "Relevância ao contexto: modelo captura fluxos reais de obras.",
                                "Qualidade da otimização: redução >15% em objetivo ponderado.",
                                "Documentação: relatório claro com equações, código e interpretações.",
                                "Robustez: solução estável a variações em condições de contorno."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Métodos de diferenças finitas e análise de erros.",
                                "Programação: Implementação eficiente em MATLAB com toolboxes.",
                                "Gestão de Projetos: Otimização de cronogramas e recursos em engenharia.",
                                "Estatística: Análise de resíduos e testes de convergência."
                              ],
                              "realWorldApplication": "Em obras civis como construção de barragens ou rodovias, simulações de BVPs otimizam alocação contínua de recursos (cimento, mão de obra), reduzindo atrasos e custos em até 20% via validação MATLAB em projetos da Petrobras ou DNIT."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Solução de Equações Não-Lineares",
                "description": "Algoritmos iterativos para encontrar raízes de equações não-lineares.",
                "totalSkills": 45,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Método da Bisseção",
                    "description": "Algoritmo iterativo que divide intervalos sucessivamente para localizar raízes de funções contínuas em intervalos fechados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1.1",
                        "name": "Fundamentos Teóricos do Método da Bisseção",
                        "description": "Princípios matemáticos fundamentais que garantem a existência de uma raiz em um intervalo fechado, baseados na continuidade da função e no Teorema do Valor Intermediário.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1.1",
                            "name": "Verificar pré-condições de aplicação",
                            "description": "Avaliar se a função é contínua em [a, b] e se existe mudança de sinal, ou seja, f(a) * f(b) < 0, para garantir pelo menos uma raiz no intervalo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e validar o intervalo inicial [a, b]",
                                  "subSteps": [
                                    "Identificar a equação não-linear f(x) = 0 a ser resolvida.",
                                    "Propor ou receber valores iniciais para a e b, garantindo a < b.",
                                    "Visualizar graficamente a função no intervalo para estimar possível raiz (usando software ou esboço manual).",
                                    "Confirmar que o intervalo é finito e fechado.",
                                    "Documentar a escolha do intervalo com justificativa inicial."
                                  ],
                                  "verification": "Intervalo [a, b] definido com a < b e justificado por estimativa de raiz.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Equação f(x)",
                                    "Calculadora ou software de plotagem (ex: Desmos, MATLAB)",
                                    "Papel e lápis para esboço"
                                  ],
                                  "tips": [
                                    "Escolha a e b próximos da raiz suspeita para convergência rápida.",
                                    "Use conhecimento prévio ou análise assintótica para guiar a seleção."
                                  ],
                                  "learningObjective": "Selecionar um intervalo inicial adequado que potencialmente contenha uma raiz.",
                                  "commonMistakes": [
                                    "Escolher intervalo muito amplo, dificultando visualização.",
                                    "Ignorar se a >= b.",
                                    "Não justificar a escolha do intervalo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a continuidade da função f em [a, b]",
                                  "subSteps": [
                                    "Classificar o tipo de função (polinomial, racional, trigonométrica, etc.).",
                                    "Analisar o domínio de f e pontos de descontinuidade potenciais.",
                                    "Confirmar que não há descontinuidades (assíntotas, saltos) no intervalo fechado [a, b].",
                                    "Para funções definidas por partes, verificar continuidade em cada ponto interno.",
                                    "Citar o Teorema do Valor Intermediário como base teórica."
                                  ],
                                  "verification": "Declaração explícita e justificada de que f é contínua em [a, b].",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Definição da função f(x)",
                                    "Tabelas de continuidade de funções comuns",
                                    "Software de plotagem para visual inspeção"
                                  ],
                                  "tips": [
                                    "Funções polinomiais, exponenciais e trigonométricas são contínuas em R.",
                                    "Verifique limites laterais em pontos críticos."
                                  ],
                                  "learningObjective": "Aplicar conhecimentos de análise para confirmar continuidade no intervalo.",
                                  "commonMistakes": [
                                    "Assumir continuidade sem análise.",
                                    "Confundir domínio com continuidade em subintervalos.",
                                    "Ignorar descontinuidades removíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os valores de f(a) e f(b)",
                                  "subSteps": [
                                    "Substituir x = a na função f e calcular f(a) com precisão numérica.",
                                    "Substituir x = b na função f e calcular f(b) com precisão numérica.",
                                    "Verificar cálculos manualmente ou com calculadora para evitar erros aritméticos.",
                                    "Registrar os valores com sinal explícito (positivo, negativo ou zero).",
                                    "Plotar ou tabular os pontos (a, f(a)) e (b, f(b)) para visualização."
                                  ],
                                  "verification": "Valores de f(a) e f(b) calculados corretamente com sinais indicados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software computacional (ex: Python, MATLAB)",
                                    "Folha de cálculo"
                                  ],
                                  "tips": [
                                    "Use aproximações decimais consistentes (ex: 4 casas).",
                                    "Confira sinal antes de prosseguir."
                                  ],
                                  "learningObjective": "Executar avaliações numéricas precisas nos extremos do intervalo.",
                                  "commonMistakes": [
                                    "Erros de cálculo aritmético simples.",
                                    "Esquecer parênteses em expressões compostas.",
                                    "Não notar se f(a) ou f(b) = 0 (raiz já encontrada)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a mudança de sinal e concluir as pré-condições",
                                  "subSteps": [
                                    "Calcular o produto f(a) * f(b).",
                                    "Verificar se f(a) * f(b) < 0, indicando sinais opostos.",
                                    "Se produto = 0, identificar raiz exata em a ou b e encerrar.",
                                    "Se condições atendidas, afirmar existência de pelo menos uma raiz por Teorema do Valor Intermediário.",
                                    "Documentar conclusão completa das pré-condições."
                                  ],
                                  "verification": "Conclusão correta sobre mudança de sinal e garantia de raiz.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Resultados de f(a) e f(b)",
                                    "Teorema do Valor Intermediário referenciado"
                                  ],
                                  "tips": [
                                    "Sinais opostos: um positivo, outro negativo.",
                                    "Se mesmo sinal, ajuste intervalo e recomece."
                                  ],
                                  "learningObjective": "Aplicar critério de mudança de sinal para validar aplicação do método da bisseção.",
                                  "commonMistakes": [
                                    "Confundir produto negativo com sinais iguais.",
                                    "Ignorar caso f(a)*f(b)=0.",
                                    "Não citar teorema justificador."
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x³ - x - 2 em [1, 2]: f é polinomial (contínua em R). f(1) = 1 - 1 - 2 = -2 < 0. f(2) = 8 - 2 - 2 = 4 > 0. Produto = (-2)*4 = -8 < 0. Pré-condições atendidas: existe pelo menos uma raiz em [1, 2].",
                              "finalVerifications": [
                                "Intervalo [a, b] selecionado corretamente com a < b.",
                                "Continuidade de f em [a, b] justificada adequadamente.",
                                "Cálculos de f(a) e f(b) precisos com sinais corretos.",
                                "Verificação correta de f(a)*f(b) < 0.",
                                "Conclusão explícita sobre existência de raiz pelo Teorema do Valor Intermediário.",
                                "Documentação completa sem omissões."
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção nos cálculos numéricos (100% exato).",
                                "Justificativa teórica sólida para continuidade.",
                                "Interpretação correta da condição de mudança de sinal.",
                                "Uso apropriado de visualizações ou ferramentas auxiliares.",
                                "Clareza e completude na documentação.",
                                "Identificação e correção de potenciais erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Pura: Teorema do Valor Intermediário e análise de funções.",
                                "Programação: Implementação de funções de verificação em Python ou MATLAB.",
                                "Engenharia Civil: Modelagem de equações não-lineares em estruturas (ex: buckling).",
                                "Física: Análise de equilíbrio em sistemas com mudança de sinal (ex: forças).",
                                "Estatística: Confiança em intervalos para predição de raízes."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao modelar o colapso de uma viga sob carga não-linear f(P) = 0 (onde P é carga crítica), verifica-se pré-condições para encontrar P em [P_min, P_max], garantindo segurança estrutural antes de simulações computacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.1.2",
                            "name": "Aplicar o Teorema do Valor Intermediário",
                            "description": "Explicar e demonstrar como o teorema assegura a existência de pelo menos um ponto c em (a, b) onde f(c) = 0, justificando a viabilidade do método.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Enunciado e Condições do Teorema do Valor Intermediário",
                                  "subSteps": [
                                    "Leia o enunciado formal: Se f é contínua em [a, b] e f(a) * f(b) < 0, então existe c ∈ (a, b) tal que f(c) = 0.",
                                    "Identifique as hipóteses principais: continuidade de f em [a, b] e mudança de sinal em f(a) e f(b).",
                                    "Explique intuitivamente: a função deve 'cruzar' o eixo x entre a e b devido à continuidade.",
                                    "Diferencie de outros teoremas como o de Rolle ou Valor Médio.",
                                    "Escreva o teorema em suas próprias palavras."
                                  ],
                                  "verification": "Resuma o teorema corretamente em um parágrafo sem consultar fontes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Cálculo I (ex: Stewart ou Apostila de Análise Numérica)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Visualize graficamente: desenhe uma curva contínua mudando de sinal para fixar a ideia.",
                                  "learningObjective": "Dominar o enunciado exato e as condições necessárias do IVT.",
                                  "commonMistakes": [
                                    "Confundir com teorema do valor médio (que envolve derivada)",
                                    "Ignorar a continuidade como hipótese essencial",
                                    "Achar que vale para qualquer mudança de sinal sem continuidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar as Hipóteses do Teorema para uma Função Dada",
                                  "subSteps": [
                                    "Escolha um intervalo [a, b] e uma função f contínua (ex: polinômios, exponenciais).",
                                    "Calcule f(a) e f(b); verifique se f(a) * f(b) < 0.",
                                    "Confirme continuidade: liste pontos de possível descontinuidade e prove ausência em [a, b].",
                                    "Se hipóteses falharem, ajuste o intervalo ou explique por quê.",
                                    "Documente os cálculos em uma tabela: Intervalo | f(a) | f(b) | Produto | Contínua?"
                                  ],
                                  "verification": "Para uma função dada, produza uma tabela confirmando todas as hipóteses.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como GeoGebra/Mathematica",
                                    "Folha de exercícios com funções exemplo"
                                  ],
                                  "tips": "Sempre calcule numericamente primeiro, depois prove continuidade analiticamente.",
                                  "learningObjective": "Aplicar rigorosamente as condições do IVT a exemplos concretos.",
                                  "commonMistakes": [
                                    "Assumir continuidade sem prova",
                                    "Usar intervalos abertos em vez de fechados",
                                    "Ignorar produto negativo estrito (f(a)*f(b)<0)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar a Existência de Raiz Usando o IVT",
                                  "subSteps": [
                                    "Com hipóteses satisfeitas, afirme: 'Pelo IVT, ∃ c ∈ (a, b) tal que f(c)=0'.",
                                    "Estime bounds para c: use sinal para localizar subintervalos.",
                                    "Aplique iterativamente: bisseque [a,b] e verifique IVT em subintervalos.",
                                    "Compare com gráfico: plote f para visualizar o c.",
                                    "Escreva uma prova curta usando contradição (suponha sem raiz e derive absurdos)."
                                  ],
                                  "verification": "Escreva uma demonstração completa para um exemplo, citando IVT explicitamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (Desmos ou Python/Matplotlib)",
                                    "Exemplos de funções não-lineares da engenharia"
                                  ],
                                  "tips": "Pense em termos de 'garantia de existência' sem encontrar c explicitamente.",
                                  "learningObjective": "Usar IVT para provar existência de soluções sem resolvê-las.",
                                  "commonMistakes": [
                                    "Tentar encontrar c exato (IVT só garante existência)",
                                    "Aplicar em funções não contínuas como step",
                                    "Confundir com método numérico que aproxima c"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar a Viabilidade do Método da Bisseção via IVT",
                                  "subSteps": [
                                    "Explique: Bisseção inicia com [a,b] onde IVT aplica; itera garantindo IVT em subintervalos.",
                                    "Simule 2-3 iterações: calcule midpoint m, avalie f(m), selecione subintervalo.",
                                    "Discuta convergência: erro halved a cada passo, garantido por IVT.",
                                    "Relacione a engenharia civil: ex, encontrar x onde carga =0 em viga.",
                                    "Compare com outros métodos (ex: Newton, que não precisa IVT)."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito como IVT sustenta a bisseção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para simular bisseção",
                                    "Casos reais de equações em estruturas civis"
                                  ],
                                  "tips": "Lembre: IVT é a 'base teórica' que prova que bisseção sempre converge para raiz.",
                                  "learningObjective": "Conectar IVT diretamente à robustez do método da bisseção.",
                                  "commonMistakes": [
                                    "Achar bisseção 'encontra' raiz exata (só aproxima)",
                                    "Ignorar que bisseção requer IVT inicial",
                                    "Confundir com secante (que usa derivadas)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x^3 - x - 2 em [1, 2]: f(1) = -2 <0, f(2)=4>0, produto <0, f contínua (polinômio). Pelo IVT, ∃ c ∈ (1,2) com f(c)=0. Bisseção: m=1.5, f(1.5)≈-0.875<0 → novo [1.5,2]; continua garantido por IVT.",
                              "finalVerifications": [
                                "Explicar IVT sem erros em 1 minuto.",
                                "Verificar hipóteses corretamente para 3 funções novas.",
                                "Provar existência de raiz em exemplo não trivial.",
                                "Simular 3 iterações de bisseção justificando IVT cada vez.",
                                "Identificar falhas em aplicações incorretas de IVT.",
                                "Relacionar a um problema de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado e hipóteses do IVT (20%)",
                                "Correta verificação de condições em exemplos (25%)",
                                "Demonstração lógica de existência de raiz (20%)",
                                "Conexão clara com método da bisseção (20%)",
                                "Uso de exemplos práticos e verificações (10%)",
                                "Clareza na escrita e raciocínio (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Base para métodos iterativos como bisseção e falsi posição.",
                                "Programação: Implementar IVT checks em código Python/MATLAB para solvers automáticos.",
                                "Física/Engenharia: Modelar equilíbrio em estruturas (ex: f(x)=0 para deflexão zero).",
                                "Estatística: Intervalos de confiança análogos à garantia de existência.",
                                "Geometria: Visualização gráfica de continuidade e cruzamento."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, aplicar IVT no método da bisseção para resolver equações não-lineares como encontrar o ponto de colapso de uma viga (onde momento f(x)=0), ou cargas críticas em fundações, garantindo convergência numérica em softwares como ANSYS sem suposições de derivabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.1.1.3",
                            "name": "Estimar o número de iterações necessárias",
                            "description": "Calcular o número mínimo de bissecções n tal que (b - a)/2^n < ε, onde ε é a tolerância desejada, para prever a precisão alcançada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a fórmula de precisão do método da bissecção",
                                  "subSteps": [
                                    "Identifique os componentes: intervalo inicial [a, b], tolerância ε e erro máximo E_n = (b - a)/2^n.",
                                    "Explique o significado: após n iterações, o comprimento do intervalo é reduzido pela metade a cada passo.",
                                    "Derive intuitivamente: cada bissecção divide o intervalo por 2, então geometricamente 1/2^n.",
                                    "Discuta limites: ε representa a precisão desejada para a raiz aproximada.",
                                    "Anote a desigualdade: E_n < ε para garantir convergência."
                                  ],
                                  "verification": "Escreva a fórmula E_n = (b - a)/2^n e explique verbalmente seu significado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Visualize o processo como cortar um bolo ao meio repetidamente para encontrar um ponto específico.",
                                  "learningObjective": "Entender a origem geométrica e teórica da fórmula de erro no método da bissecção.",
                                  "commonMistakes": [
                                    "Confundir E_n com o erro absoluto da raiz f(x)",
                                    "Ignorar que é o comprimento do intervalo final, não o erro em f(x)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a desigualdade para o número de iterações",
                                  "subSteps": [
                                    "Escreva a condição: (b - a)/2^n < ε.",
                                    "Multiplique ambos os lados por 2^n: b - a < ε * 2^n.",
                                    "Divida por ε: (b - a)/ε < 2^n.",
                                    "Aplique logaritmo base 2: log2((b - a)/ε) < n.",
                                    "Conclua: n > log2((b - a)/ε), e n mínimo é o teto dessa valor."
                                  ],
                                  "verification": "Transforme a desigualdade em n > log2((b - a)/ε) para valores dados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de logaritmos ou calculadora"
                                  ],
                                  "tips": "Use log2(x) = ln(x)/ln(2) se não tiver log base 2 direta na calculadora.",
                                  "learningObjective": "Dominar a manipulação algébrica para isolar n na desigualdade de precisão.",
                                  "commonMistakes": [
                                    "Esquecer de inverter a desigualdade ao isolar n",
                                    "Usar log10 em vez de log2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular numericamente o número mínimo de iterações",
                                  "subSteps": [
                                    "Colete valores: meça ou defina a, b e ε para o problema específico.",
                                    "Calcule Δ = b - a.",
                                    "Compute r = Δ / ε.",
                                    "Calcule n = ceil(log2(r)), onde ceil arredonda para cima.",
                                    "Verifique manualmente: compute (b - a)/2^n e confirme se < ε."
                                  ],
                                  "verification": "Para Δ=1, ε=0.01, calcule n=7 e verifique (1)/128 ≈0.0078 <0.01.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora com funções log e ceil",
                                    "Planilha Excel ou Python para verificação opcional"
                                  ],
                                  "tips": "Sempre use a função teto (ceil) pois n deve ser inteiro e suficiente.",
                                  "learningObjective": "Aplicar a fórmula computacionalmente com precisão numérica.",
                                  "commonMistakes": [
                                    "Arredondar para baixo em vez de teto",
                                    "Erro de cálculo em log2 devido a aproximações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar a estimativa de iterações",
                                  "subSteps": [
                                    "Compare n estimado com iterações reais em uma implementação do método.",
                                    "Analise sensibilidade: como n muda se ε diminui ou Δ aumenta.",
                                    "Discuta trade-offs: mais iterações = mais precisão, mas mais tempo computacional.",
                                    "Aplique em contexto: relacione com problemas de engenharia civil não-lineares.",
                                    "Documente: crie uma tabela de n vs. ε para diferentes cenários."
                                  ],
                                  "verification": "Gere uma tabela mostrando n para ε=10^-3, 10^-4, 10^-5 e interprete tendências.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para tabela",
                                    "Implementação simples do método da bissecção em Python ou MATLAB (opcional)"
                                  ],
                                  "tips": "Teste com implementações reais para validar que n estimado é conservador.",
                                  "learningObjective": "Interpretar resultados no contexto prático e avaliar robustez da estimativa.",
                                  "commonMistakes": [
                                    "Ignorar que a estimativa é um limite superior, não exato",
                                    "Não considerar condições de parada reais como f(c)≈0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para encontrar a raiz de f(x) = x^3 - x - 2 = 0 em [1, 2] com ε = 0.001: Δ = 1, r = 1/0.001 = 1000, log2(1000) ≈ 9.96, n = 10. Verificação: 1/2^10 = 1/1024 ≈ 0.000976 < 0.001.",
                              "finalVerifications": [
                                "Calcule n corretamente para [0, π], ε=10^-6 (esperado n=22).",
                                "Explique por que n deve ser inteiro e usar teto.",
                                "Verifique manualmente que após n iterações, E_n < ε.",
                                "Compare estimativa com número real de iterações em código.",
                                "Identifique impacto de dobrar Δ ou dividir ε por 10."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação da fórmula n > log2((b-a)/ε).",
                                "Precisão no cálculo numérico incluindo uso de teto.",
                                "Validação adequada com verificação de E_n < ε.",
                                "Interpretação contextualizada para aplicações reais.",
                                "Identificação de erros comuns e sensibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos e funções exponenciais.",
                                "Programação: Implementação de loops e controle de precisão numérica.",
                                "Física: Análise de erros em simulações numéricas.",
                                "Estatística: Estimativa de convergência e intervalos de confiança."
                              ],
                              "realWorldApplication": "Em engenharia civil, para solver equações não-lineares de equilíbrio estrutural (ex: deformações em vigas sob carga variável), estimar n evita execuções desnecessárias de código, otimizando tempo de simulação em softwares como ANSYS ou MATLAB para projetos de pontes e edifícios."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.1.2",
                        "name": "Algoritmo Iterativo do Método da Bisseção",
                        "description": "Descrição passo a passo do procedimento iterativo que divide sucessivamente o intervalo contendo a raiz.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.2.1",
                            "name": "Calcular o ponto médio do intervalo",
                            "description": "Determinar c = (a + b)/2 e avaliar f(c) para decidir qual subintervalo contém a raiz.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os limites atuais do intervalo [a, b]",
                                  "subSteps": [
                                    "Revise o intervalo atual [a, b] da iteração anterior ou inicial.",
                                    "Confirme que f(a) e f(b) têm sinais opostos (f(a) * f(b) < 0).",
                                    "Registre os valores exatos de a e b para evitar erros de transcrição.",
                                    "Verifique se o intervalo satisfaz as condições iniciais do método da bisseção.",
                                    "Anote o número da iteração atual para rastreamento."
                                  ],
                                  "verification": "Confirme que f(a) * f(b) < 0 e que a < b.",
                                  "estimatedTime": "3 minutos",
                                  "materials": "Papel e caneta, calculadora ou software de cálculo (ex: Python ou Excel).",
                                  "tips": "Sempre anote os valores com precisão decimal para evitar arredondamentos prematuros.",
                                  "learningObjective": "Entender a importância dos limites do intervalo para garantir convergência.",
                                  "commonMistakes": "Esquecer de verificar o sinal oposto de f(a) e f(b); inverter a e b."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o ponto médio c = (a + b) / 2",
                                  "subSteps": [
                                    "Some os valores de a e b.",
                                    "Divida o resultado por 2 para obter c.",
                                    "Registre c com pelo menos 4 casas decimais para precisão.",
                                    "Verifique o cálculo manualmente ou com calculadora.",
                                    "Compare c com a e b para confirmar que está no meio do intervalo."
                                  ],
                                  "verification": "Verifique se a < c < b e recalcule para confirmação.",
                                  "estimatedTime": "2 minutos",
                                  "materials": "Calculadora científica ou planilha eletrônica.",
                                  "tips": "Use frações exatas se possível antes de decimalizar para maior precisão.",
                                  "learningObjective": "Dominar o cálculo aritmético simples aplicado ao método numérico.",
                                  "commonMistakes": "Arredondar cedo demais; erro de soma ou divisão por 2."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar a função f(c) no ponto médio",
                                  "subSteps": [
                                    "Substitua c na função f(x).",
                                    "Calcule f(c) passo a passo, respeitando a ordem de operações.",
                                    "Registre o valor exato de f(c).",
                                    "Verifique o sinal de f(c) (positivo, negativo ou zero).",
                                    "Se f(c) = 0, identifique c como a raiz exata."
                                  ],
                                  "verification": "Confirme que f(c) foi calculado corretamente comparando com um segundo método.",
                                  "estimatedTime": "4 minutos",
                                  "materials": "Função f(x) definida, calculadora ou interpretador de código.",
                                  "tips": "Teste f(c) em uma calculadora gráfica para validação visual.",
                                  "learningObjective": "Aplicar avaliação funcional com precisão numérica.",
                                  "commonMistakes": "Erro na substituição de c; esquecer parênteses na função."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Decidir o novo subintervalo baseado em f(c)",
                                  "subSteps": [
                                    "Compare os sinais: se f(a) * f(c) < 0, novo intervalo é [a, c].",
                                    "Senão, se f(c) * f(b) < 0, novo intervalo é [c, b].",
                                    "Atualize a e b com os novos valores.",
                                    "Registre o novo intervalo e o comprimento reduzido.",
                                    "Verifique se o novo intervalo ainda contém a raiz."
                                  ],
                                  "verification": "Confirme que o novo [a, b] satisfaz f(a) * f(b) < 0 e é menor que o anterior.",
                                  "estimatedTime": "3 minutos",
                                  "materials": "Tabela de iterações em papel ou planilha.",
                                  "tips": "Crie uma tabela com colunas para iteração, a, b, c, f(c), novo intervalo.",
                                  "learningObjective": "Entender a lógica de bisseção para redução do erro.",
                                  "commonMistakes": "Escolher subintervalo errado baseado em sinais; não atualizar corretamente."
                                }
                              ],
                              "practicalExample": "Para f(x) = x³ - x - 2 com intervalo inicial [1, 2]: a=1 (f(1)=-1), b=2 (f(2)=4). Calcule c=(1+2)/2=1.5, f(1.5)= -0.875. Como f(1)*f(1.5)<0, novo intervalo [1, 1.5].",
                              "finalVerifications": [
                                "c está exatamente no meio de [a, b]?",
                                "f(c) calculado corretamente e sinal identificado?",
                                "Novo subintervalo escolhido baseado na regra de sinais?",
                                "Comprimento do novo intervalo é metade do anterior?",
                                "Condições de continuidade e sinal oposto preservadas?",
                                "Raiz ainda contida no novo intervalo?"
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de c (erro < 0.001).",
                                "Avaliação correta de f(c) sem erros aritméticos.",
                                "Seleção lógica do subintervalo com justificativa de sinais.",
                                "Registro completo da iteração em tabela.",
                                "Explicação verbal da decisão de bisseção.",
                                "Aplicação em pelo menos 3 iterações consecutivas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em loop while em Python ou MATLAB.",
                                "Álgebra: Reforço de avaliação polinomial e propriedades de funções contínuas.",
                                "Estatística: Conceito de média aritmética e redução de incerteza.",
                                "Física: Aplicação em equações de equilíbrio estático."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado no método da bisseção para resolver equações não-lineares como as de deformação em vigas ou equilíbrio hidráulico em canais, onde se encontra o ponto de zero força ou fluxo crítico iterativamente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1.3"
                            ]
                          },
                          {
                            "id": "10.1.6.1.1.2.2",
                            "name": "Atualizar o intervalo com base no sinal",
                            "description": "Se f(a) * f(c) < 0, definir novo intervalo [a, c]; caso contrário, [c, b], preservando a mudança de sinal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar os valores da função nos pontos a e c",
                                  "subSteps": [
                                    "Calcule f(a) usando a função definida e o valor atual de a.",
                                    "Calcule f(c), onde c é o ponto médio do intervalo atual (c = (a + b)/2).",
                                    "Registre os sinais de f(a) e f(c) (positivo, negativo ou zero).",
                                    "Anote os valores exatos para referência futura.",
                                    "Confirme que f(a) e f(b) ainda mantêm mudança de sinal do intervalo inicial."
                                  ],
                                  "verification": "Verifique se f(a) e f(c) foram calculados corretamente comparando com uma calculadora ou software.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função f(x) definida",
                                    "Calculadora ou software como Python/MATLAB",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Sempre use precisão suficiente (pelo menos 4 casas decimais) para evitar erros de arredondamento.",
                                  "learningObjective": "Compreender como avaliar a função nos extremos e no ponto médio para identificar sinais.",
                                  "commonMistakes": [
                                    "Esquecer de calcular f(c) com o ponto médio exato",
                                    "Confundir f(a) com f(b)",
                                    "Ignorar zeros na função"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a condição de mudança de sinal entre a e c",
                                  "subSteps": [
                                    "Multiplique os valores: produto = f(a) * f(c).",
                                    "Analise o sinal do produto: se < 0, há mudança de sinal em [a, c].",
                                    "Se produto >= 0, confirme que há mudança em [c, b] (pois f(a)*f(b) < 0 originalmente).",
                                    "Registre o resultado da condição booleanamente (verdadeiro/falso).",
                                    "Explique verbalmente por que a raiz está no subintervalo escolhido."
                                  ],
                                  "verification": "Confirme o produto e seu sinal; teste com valores conhecidos onde a raiz é conhecida.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Valores de f(a) e f(c) do passo anterior",
                                    "Calculadora"
                                  ],
                                  "tips": "Lembre-se: mudança de sinal ocorre quando o produto é negativo, indicando raiz pelo teorema do valor intermediário.",
                                  "learningObjective": "Dominar a detecção de mudança de sinal via produto para localizar a raiz.",
                                  "commonMistakes": [
                                    "Invertar o sinal do produto",
                                    "Confundir produto < 0 com >= 0",
                                    "Não considerar zero como sem mudança"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e definir o novo intervalo",
                                  "subSteps": [
                                    "Se f(a) * f(c) < 0, defina novo_a = a e novo_b = c.",
                                    "Caso contrário (f(a) * f(c) >= 0), defina novo_a = c e novo_b = b.",
                                    "Calcule o comprimento do novo intervalo para observar a redução pela metade.",
                                    "Anote o novo intervalo [novo_a, novo_b].",
                                    "Visualize graficamente o novo intervalo se possível."
                                  ],
                                  "verification": "O novo intervalo deve ter mudança de sinal confirmada: f(novo_a) * f(novo_b) < 0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resultados dos passos 1 e 2",
                                    "Gráfico da função (opcional, via Desmos ou Python)"
                                  ],
                                  "tips": "Sempre priorize o subintervalo menor que preserva a mudança de sinal para convergência rápida.",
                                  "learningObjective": "Aplicar logicamente a condição para atualizar o intervalo corretamente.",
                                  "commonMistakes": [
                                    "Escolher o intervalo errado baseado na condição",
                                    "Não atualizar ambos a e b",
                                    "Manter intervalo antigo por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Atualizar variáveis e validar a preservação",
                                  "subSteps": [
                                    "Atribua a = novo_a e b = novo_b nas variáveis do algoritmo.",
                                    "Reavalie f(a) e f(b) no novo intervalo para confirmação.",
                                    "Verifique se f(a) * f(b) < 0 ainda vale.",
                                    "Registre o número de iterações e o novo comprimento do intervalo.",
                                    "Prepare para a próxima iteração calculando novo c."
                                  ],
                                  "verification": "Execute uma iteração manual completa e confirme convergência (intervalo reduzido pela metade).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código ou planilha para simulação iterativa",
                                    "Histórico de intervalos"
                                  ],
                                  "tips": "Mantenha um log de intervalos para rastrear convergência visualmente.",
                                  "learningObjective": "Garantir que a atualização preserve as propriedades do método da bisseção.",
                                  "commonMistakes": [
                                    "Não validar o novo produto de sinais",
                                    "Perder precisão em atualizações repetidas",
                                    "Parar prematuramente sem verificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x^3 - x - 2 com intervalo inicial [1, 2]: c = 1.5, f(1) ≈ -2.0 (neg), f(1.5) ≈ -0.875 (neg), produto > 0 → novo intervalo [1.5, 2]. Confirmação: f(1.5) neg, f(2) ≈ 2 pos, mudança preservada.",
                              "finalVerifications": [
                                "O novo intervalo [a', b'] satisfaz f(a') * f(b') < 0.",
                                "O comprimento do novo intervalo é aproximadamente metade do anterior.",
                                "A raiz da função permanece no novo intervalo.",
                                "Nenhum erro de cálculo em f(a) ou f(c).",
                                "A lógica condicional foi aplicada corretamente (if f(a)*f(c) < 0).",
                                "Preparado para próxima iteração sem perda de precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na avaliação de sinais e produto (100% correto).",
                                "Seleção correta do subintervalo baseado na condição.",
                                "Redução consistente do tamanho do intervalo.",
                                "Validação explícita da preservação de mudança de sinal.",
                                "Explicação clara da lógica em termos do teorema do valor intermediário.",
                                "Ausência de erros comuns como inversão de intervalos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em loop while em Python ou MATLAB.",
                                "Análise Numérica: Entender garantias de convergência do método da bisseção.",
                                "Engenharia Civil: Aplicar em equações de equilíbrio estrutural não-lineares.",
                                "Matemática: Teorema do Valor Intermediário e continuidade de funções."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para resolver equações não-lineares em análise de estruturas, como determinar cargas críticas em vigas onde deformação segue f(x) = 0, garantindo precisão em projetos de pontes ou edifícios sem dependência de derivadas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.1.2.3",
                            "name": "Executar iterações manuais",
                            "description": "Realizar 4-5 iterações manualmente em um exemplo numérico, registrando os intervalos e aproximações sucessivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o problema e verificar o intervalo inicial",
                                  "subSteps": [
                                    "Escolha uma equação não-linear f(x) = 0 com uma raiz real conhecida ou estimada.",
                                    "Selecione valores iniciais a e b tal que f(a) e f(b) tenham sinais opostos (f(a) * f(b) < 0).",
                                    "Calcule f(a) e f(b) para confirmar o teorema do valor intermediário.",
                                    "Registre os valores iniciais em uma tabela: iteração 0, a0, b0, f(a0), f(b0), intervalo [a0, b0].",
                                    "Defina a tolerância de parada (ex: |b - a| < 0.01) e número máximo de iterações (5)."
                                  ],
                                  "verification": "Confirme que f(a) * f(b) < 0 e registre a tabela inicial corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica",
                                    "Folha de cálculo ou tabela impressa"
                                  ],
                                  "tips": [
                                    "Use equações simples como f(x) = x³ - x - 2 para prática inicial.",
                                    "Arredonde valores intermediários para 4 casas decimais para consistência."
                                  ],
                                  "learningObjective": "Entender e validar as condições iniciais para garantir convergência do método.",
                                  "commonMistakes": [
                                    "Escolher a e b com mesmo sinal em f(a) e f(b).",
                                    "Não calcular f(a) e f(b) com precisão.",
                                    "Ignorar múltiplas raízes no intervalo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a primeira iteração da bisseção",
                                  "subSteps": [
                                    "Calcule o ponto médio c1 = (a0 + b0) / 2.",
                                    "Avalie f(c1).",
                                    "Verifique os sinais: se f(a0) * f(c1) < 0, defina novo intervalo [a1 = a0, b1 = c1]; senão [a1 = c1, b1 = b0].",
                                    "Registre na tabela: iteração 1, a1, b1, c1, f(c1), f(a1), f(b1), comprimento do intervalo.",
                                    "Verifique se |b1 - a1| < tolerância; se sim, pare."
                                  ],
                                  "verification": "Tabela da iteração 1 completa com cálculos corretos e intervalo reduzido pela metade.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de registro"
                                  ],
                                  "tips": [
                                    "Sempre use a fórmula exata c = (a + b)/2 para evitar erros de arredondamento precoce.",
                                    "Anote f(c) com sinal explícito (+ ou -)."
                                  ],
                                  "learningObjective": "Aplicar o princípio de bisseção para reduzir o intervalo na primeira iteração.",
                                  "commonMistakes": [
                                    "Erro no cálculo de c (ex: soma errada).",
                                    "Decisão incorreta do novo intervalo baseada em sinais.",
                                    "Arredondamento excessivo em c."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações subsequentes (2 a 4)",
                                  "subSteps": [
                                    "Repita o processo da iteração 1 para c2 = (a1 + b1)/2, avaliando f(c2) e atualizando [a2, b2].",
                                    "Continue para iteração 3: c3 = (a2 + b2)/2, f(c3), novo intervalo [a3, b3].",
                                    "Execute iteração 4: c4 = (a3 + b3)/2, f(c4), [a4, b4].",
                                    "Registre cada linha na tabela com todos os valores: ai, bi, ci, f(ai), f(bi), f(ci), |bi - ai|.",
                                    "Monitore a redução do intervalo a cada passo (deve ser aproximadamente halved)."
                                  ],
                                  "verification": "Tabela com iterações 2-4 completas, intervalos decrescentes e decisões corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela atualizada"
                                  ],
                                  "tips": [
                                    "Mantenha consistência no número de casas decimais (ex: 4).",
                                    "Use c_n como aproximação sucessiva da raiz."
                                  ],
                                  "learningObjective": "Dominar o loop iterativo, observando a convergência quadrática do método.",
                                  "commonMistakes": [
                                    "Perder o rastreamento de índices (confundir a_i com a_{i+1}).",
                                    "Cálculos propagados errados de f(c).",
                                    "Parar prematuramente sem atingir 4 iterações."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar a quinta iteração, registrar resultados finais e analisar",
                                  "subSteps": [
                                    "Calcule c5 = (a4 + b4)/2, f(c5), e atualize [a5, b5].",
                                    "Complete a tabela com iteração 5, incluindo aproximação final (ex: média de a5 e b5 ou c5).",
                                    "Calcule o erro estimado: |b5 - a5| e compare com tolerância.",
                                    "Plote graficamente os intervalos ou aproxime a raiz final.",
                                    "Verifique se a sequência de c_n converge para a raiz real."
                                  ],
                                  "verification": "Tabela final com 5 iterações, erro < tolerância e análise de convergência.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para gráfico opcional",
                                    "Tabela final"
                                  ],
                                  "tips": [
                                    "A aproximação final é geralmente c_n ou (a_n + b_n)/2.",
                                    "Confira somando colunas para detecção de erros."
                                  ],
                                  "learningObjective": "Finalizar iterações, registrar dados e avaliar a precisão do método.",
                                  "commonMistakes": [
                                    "Erro de cálculo acumulado nas iterações finais.",
                                    "Não registrar comprimentos de intervalo.",
                                    "Ignorar verificação de tolerância."
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x³ - x - 2 = 0, intervalo inicial [1, 2] (f(1) = -2 < 0, f(2) = 4 > 0). Iteração 1: c1=1.5, f(1.5)≈-0.125<0 → [1.5,2]. Iteração 2: c2=1.75, f(1.75)≈1.609>0 → [1.5,1.75]. Continue até 5 iterações, aproximando x≈1.521.",
                              "finalVerifications": [
                                "Tabela completa com 5 iterações, incluindo a_i, b_i, c_i, f valores e intervalos.",
                                "Todos cálculos numéricos corretos até 4 casas decimais.",
                                "Sinais de f corretamente usados para atualizar intervalos.",
                                "Comprimento final do intervalo reduzido por fator ≈1/32 (2^5).",
                                "Aproximação final consistente com raiz conhecida (≈1.521).",
                                "Nenhum erro de propagação em iterações sucessivas."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos em cada iteração (erro < 0.001).",
                                "Correta aplicação da regra de sinais para bisseção.",
                                "Registro completo e organizado em tabela.",
                                "Análise de convergência e erro estimado.",
                                "Tempo de execução dentro do estimado total (60 min).",
                                "Identificação de potenciais erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teorema do Valor Intermediário e análise numérica.",
                                "Programação: Implementação do algoritmo em Python ou MATLAB para automação.",
                                "Física: Solução de equações em mecânica de estruturas (ex: equilíbrio não-linear).",
                                "Estatística: Avaliação de precisão e tolerâncias em aproximações.",
                                "Engenharia de Software: Boas práticas de iteração e laços em códigos."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, o método da bisseção resolve equações não-lineares para calcular cargas críticas em vigas (ex: f(L) = momento fletor - limite = 0), vazão em redes hidráulicas ou deformações em solos, onde soluções analíticas são impossíveis, garantindo precisão em projetos seguros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.1.3",
                        "name": "Critérios de Convergência, Parada e Implementação",
                        "description": "Definição de condições para encerrar o algoritmo e análise de convergência linear, incluindo implementação computacional básica.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.3.1",
                            "name": "Definir critérios de parada",
                            "description": "Implementar parada quando |b - a| < ε, |f(c)| < ε ou após N iterações máximas, evitando loops infinitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Principais Critérios de Parada",
                                  "subSteps": [
                                    "Estude o critério de comprimento do intervalo: verificar se |b - a| < ε, onde ε é a tolerância de precisão.",
                                    "Analise o critério de valor absoluto da função: verificar se |f(c)| < ε, indicando que c é próximo da raiz.",
                                    "Revise o critério de iterações máximas: parar após N iterações para evitar loops infinitos.",
                                    "Explique como cada critério garante convergência e previne execução indefinida.",
                                    "Compare os critérios em termos de precisão e robustez para problemas reais."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando os três critérios e suas finalidades, incluindo um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação do Método da Bisseção",
                                    "Vídeo tutorial sobre convergência numérica",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Comece com exemplos gráficos para visualizar |b - a| e |f(c)|.",
                                    "Lembre-se: ε típico é 10^-6 para aplicações de engenharia."
                                  ],
                                  "learningObjective": "Identificar e diferenciar os três critérios de parada, entendendo seu papel na prevenção de loops infinitos.",
                                  "commonMistakes": [
                                    "Confundir |b - a| < ε com |f(c)| < ε.",
                                    "Subestimar a necessidade de N máximo em casos de convergência lenta.",
                                    "Ignorar que |f(c)| pode ser pequeno sem c ser a raiz exata."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Parâmetros de Parada Apropriados",
                                  "subSteps": [
                                    "Determine ε baseado na precisão requerida (ex: 1e-6 para cálculos de engenharia civil).",
                                    "Estime N máximo usando a fórmula aproximada: N ≈ log((b-a)/ε) / log(2) + margem de segurança.",
                                    "Considere o contexto do problema, como tolerância em deformações estruturais.",
                                    "Documente justificativas para ε e N, incluindo unidades e impacto na precisão.",
                                    "Teste valores iniciais com um intervalo [a, b] simples para validar escolhas."
                                  ],
                                  "verification": "Crie uma tabela com 3 cenários diferentes de ε e N, justificando cada um para um problema de engenharia.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou Python para estimar log",
                                    "Exemplos de problemas de equações não-lineares em engenharia civil"
                                  ],
                                  "tips": [
                                    "Use ε conservador para evitar falsos positivos; N deve ser pelo menos 50 para intervalos típicos."
                                  ],
                                  "learningObjective": "Selecionar e justificar valores de ε e N adequados ao contexto de engenharia.",
                                  "commonMistakes": [
                                    "Escolher ε muito pequeno, levando a muitas iterações.",
                                    "Definir N fixo sem estimativa, causando timeouts ou imprecisão.",
                                    "Não considerar o tamanho inicial de [a, b]."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Lógica de Parada no Algoritmo",
                                  "subSteps": [
                                    "Estruture o loop principal do método da bisseção com contador k inicializado em 0.",
                                    "Adicione verificações sequenciais: if |b - a| < ε, break e retorne 'Parada por intervalo'.",
                                    "Inclua if |f(c)| < ε, break e retorne 'Parada por função próxima de zero'.",
                                    "Adicione if k >= N, break e retorne 'Parada por iterações máximas - possível não convergência'.",
                                    "Integre ao código existente e teste sintaxe com um exemplo básico."
                                  ],
                                  "verification": "Execute o código com um debugger ou prints para confirmar que as condições triggeram corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (Python/MATLAB)",
                                    "Pseudocódigo do método da bisseção",
                                    "Intervalo de teste [1, 2] para f(x) = x^3 - 2x + 1"
                                  ],
                                  "tips": [
                                    "Coloque verificações no início do loop para eficiência.",
                                    "Use mensagens de log para identificar qual critério ativou."
                                  ],
                                  "learningObjective": "Codificar condicionais de parada de forma robusta e legível no algoritmo da bisseção.",
                                  "commonMistakes": [
                                    "Colocar break fora do loop.",
                                    "Usar == em vez de < para floats (use abs(dif) < ε).",
                                    "Incrementar k após as verificações, causando overflow."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar a Implementação dos Critérios",
                                  "subSteps": [
                                    "Execute com ε pequeno (1e-8) e verifique parada por iterações ou precisão.",
                                    "Teste com ε grande (1e-2) para parada rápida por intervalo ou função.",
                                    "Simule não convergência forçando N baixo e valide alerta.",
                                    "Compare resultado com raiz conhecida e analise número de iterações.",
                                    "Ajuste parâmetros e reteste para otimização."
                                  ],
                                  "verification": "Gere um relatório com saídas de 3 testes, mostrando critério de parada, iterações e erro relativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código implementado",
                                    "Ferramentas de plotagem (Matplotlib) para visualizar convergência"
                                  ],
                                  "tips": [
                                    "Registre sempre o critério usado para depuração futura."
                                  ],
                                  "learningObjective": "Validar empiricamente que os critérios funcionam e detectam falhas.",
                                  "commonMistakes": [
                                    "Não testar casos extremos como ε=0.",
                                    "Ignorar erros de precisão em floats.",
                                    "Confundir parada prematura com convergência real."
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver f(x) = x^3 - x - 2 = 0 em [1, 2], implemente bisseção com ε=1e-5 e N=50. O algoritmo itera até |b-a| < 1e-5 após 20 iterações, retornando c ≈ 1.5214 (raiz real ≈1.5213797), com log indicando 'Parada por intervalo'. Teste alterando ε para 1e-3 (para em 10 iterações) e N=5 (para por iterações máximas com alerta).",
                              "finalVerifications": [
                                "Liste e explique os três critérios de parada com fórmulas.",
                                "Implemente pseudocódigo completo com lógica de parada.",
                                "Justifique ε=1e-6 e N=100 para um problema de engenharia civil.",
                                "Identifique qual critério ativou em um teste com saída de código.",
                                "Descreva como os critérios previnem loops infinitos.",
                                "Calcule iterações estimadas para [a,b]=[0,10], ε=1e-6."
                              ],
                              "assessmentCriteria": [
                                "Exatidão na definição dos critérios (|b-a|<ε, |f(c)|<ε, k>=N).",
                                "Justificativa contextual de parâmetros ε e N.",
                                "Implementação correta e testada da lógica condicional.",
                                "Relatório de testes abrangendo casos normais e extremos.",
                                "Análise de convergência e prevenção de loops infinitos.",
                                "Clareza na documentação e exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Teoria de convergência e análise de erro.",
                                "Programação: Estruturas de controle (loops, condicionais) e depuração.",
                                "Engenharia Computacional: Simulações robustas em software de análise estrutural.",
                                "Estatística: Tolerâncias e confiança em aproximações numéricas."
                              ],
                              "realWorldApplication": "Em engenharia civil, critérios de parada são essenciais em solvers de equações não-lineares para análise de estruturas (ex: equilíbrio de vigas com grandes deformações ou solos não-lineares), garantindo que simulações terminem rapidamente sem loops infinitos, permitindo iterações em projetos reais como pontes ou edifícios."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.2.3"
                            ]
                          },
                          {
                            "id": "10.1.6.1.1.3.2",
                            "name": "Analisar taxa de convergência",
                            "description": "Compreender que o erro é reduzido pela metade a cada iteração, com erro máximo E_n = (b - a)/2^n, e calcular para exemplos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Convergência e Erro no Método da Bisseção",
                                  "subSteps": [
                                    "Revise o método da bisseção: seleção de intervalo inicial [a, b] onde f(a) e f(b) têm sinais opostos.",
                                    "Defina convergência: o processo aproxima a raiz verdadeira à medida que o intervalo é reduzido.",
                                    "Explique erro de aproximação: diferença máxima entre a aproximação atual e a raiz (|x_n - r| ≤ (b - a)/2^n).",
                                    "Identifique a taxa de redução: o erro é halved (dividido por 2) a cada iteração.",
                                    "Discuta por que isso é convergência linear com constante 1/2."
                                  ],
                                  "verification": "Explique em suas palavras a relação entre iterações, intervalo e erro máximo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas sobre método da bisseção",
                                    "Gráfico ilustrando halving do intervalo"
                                  ],
                                  "tips": "Desenhe o intervalo [a,b] e marque como ele é dividido repetidamente para visualizar o halving.",
                                  "learningObjective": "Compreender os fundamentos teóricos de erro e taxa de convergência no método da bisseção.",
                                  "commonMistakes": [
                                    "Confundir erro absoluto com erro relativo",
                                    "Achar que o método converge mais rápido que linearmente",
                                    "Ignorar que o bound é conservador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Fórmula do Erro Máximo E_n",
                                  "subSteps": [
                                    "Estabeleça o comprimento inicial do intervalo: I_0 = b - a.",
                                    "Mostre que após uma iteração: I_1 = I_0 / 2.",
                                    "Generalize por recursão: I_n = I_{n-1} / 2 = (b - a) / 2^n.",
                                    "Conclua que o erro máximo E_n = (b - a) / 2^n, pois a raiz está no intervalo.",
                                    "Prove por indução: base n=0 verdadeira, assume para n=k, mostra para n=k+1."
                                  ],
                                  "verification": "Escreva a derivação completa da fórmula E_n em um papel ou documento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para derivação",
                                    "Calculadora para verificação numérica"
                                  ],
                                  "tips": "Use indução matemática para solidificar a prova; comece com casos pequenos (n=1,2).",
                                  "learningObjective": "Derivar matematicamente a fórmula do erro máximo e entender sua origem geométrica.",
                                  "commonMistakes": [
                                    "Esquecer o expoente n na fórmula",
                                    "Confundir E_n com o erro real exato",
                                    "Não considerar que é um bound superior"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Tabular Erro para Iterações Específicas",
                                  "subSteps": [
                                    "Selecione um exemplo: f(x) = x^3 - 2x - 5 = 0 no intervalo [2, 3] (b-a=1).",
                                    "Calcule E_n para n=0 a 5: E_0=1, E_1=0.5, E_2=0.25, etc.",
                                    "Crie uma tabela: colunas para n, I_n, E_n e aproximação x_n (opcional).",
                                    "Compare E_n com erro real se a raiz for conhecida (aprox. 2.094).",
                                    "Observe o padrão: cada E_n = E_{n-1} / 2."
                                  ],
                                  "verification": "Produza uma tabela completa com cálculos corretos para pelo menos 6 iterações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use uma planilha para automatizar 2^n e visualizar o decaimento exponencial.",
                                  "learningObjective": "Aplicar a fórmula para quantificar o erro em cenários numéricos concretos.",
                                  "commonMistakes": [
                                    "Erro no cálculo de potências de 2",
                                    "Arredondar prematuramente",
                                    "Não tabular para visualização clara"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Taxa de Convergência e Aplicar Critérios Práticos",
                                  "subSteps": [
                                    "Calcule iterações necessárias para E_n < ε: n > log2((b-a)/ε).",
                                    "Exemplo: para ε=10^{-6}, b-a=1, n > log2(10^6) ≈ 20 iterações.",
                                    "Compare taxa com outros métodos (bisseção: lenta, mas robusta).",
                                    "Integre em critério de parada: pare quando (b-a)/2^n < ε.",
                                    "Discuta limitações: convergência garantida mas lenta para alta precisão."
                                  ],
                                  "verification": "Resolva para n mínimo dado ε e justifique em um parágrafo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora com log2 ou software como Python/MATLAB",
                                    "Exemplos de problemas de engenharia"
                                  ],
                                  "tips": "Use log2(x) = ln(x)/ln(2) se não disponível; teste com ε variados.",
                                  "learningObjective": "Interpretar a taxa para decisões práticas em implementações computacionais.",
                                  "commonMistakes": [
                                    "Usar log10 em vez de log2",
                                    "Subestimar n para intervalos largos",
                                    "Ignorar overhead computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Para encontrar a raiz de f(x) = x^2 - 4 = 0 em [1, 3] (raiz ≈2, b-a=2). E_0=2, E_1=1, E_5=2/32=0.0625, E_10=2/1024≈0.00195. Após 10 iterações, erro <0.002, ideal para problemas de engenharia onde precisão moderada basta.",
                              "finalVerifications": [
                                "Deriva corretamente E_n = (b - a)/2^n?",
                                "Calcula E_n e n para ε dado com precisão?",
                                "Explica o halving do erro em termos simples?",
                                "Identifica quando bisseção é apropriada vs. métodos mais rápidos?",
                                "Aplica fórmula em um exemplo novo sem erros?",
                                "Discute bound vs. erro real?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula (30%)",
                                "Correção nos cálculos numéricos e tabulações (25%)",
                                "Profundidade na análise de taxa e critérios de parada (20%)",
                                "Clareza na explicação conceitual (15%)",
                                "Aplicação prática em exemplos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Logaritmos",
                                "Programação: Implementação de loops iterativos com critérios de erro",
                                "Estatística: Análise de bounds de erro e confiabilidade numérica",
                                "Física/Engenharia: Solução de equações não-lineares em modelos dinâmicos"
                              ],
                              "realWorldApplication": "Em engenharia civil, analisar taxa de convergência em solvers iterativos para equações não-lineares de equilíbrio estrutural ou fluxo em redes hidráulicas, otimizando tempo de computação em softwares como ANSYS ou MATLAB para evitar iterações excessivas em projetos reais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.1.3.3",
                            "name": "Implementar em pseudocódigo ou MATLAB",
                            "description": "Escrever pseudocódigo completo do método e adaptá-lo para MATLAB ou similar, testando em função não-linear de engenharia civil como equilíbrio de vigas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Desenvolver pseudocódigo completo do Método da Bisseção com critérios de convergência",
                                  "subSteps": [
                                    "Revise os critérios de parada: tolerância absoluta (ε_a), tolerância relativa (ε_r), número máximo de iterações (N_max)",
                                    "Defina entradas: função f(x), intervalo inicial [a, b] onde f(a)*f(b) < 0, parâmetros de tolerância e N_max",
                                    "Escreva o loop principal: calcule ponto médio c = (a + b)/2, verifique f(c) == 0 ou critérios de convergência",
                                    "Atualize intervalo: se f(a)*f(c) < 0 então b = c, senão a = c; incremente iterações",
                                    "Saída: raiz aproximada, número de iterações, histórico de erros",
                                    "Inclua tratamento de erros como intervalo inválido ou não convergência"
                                  ],
                                  "verification": "Pseudocódigo roda manualmente em papel para um exemplo simples e converge corretamente",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, caneta, referência ao algoritmo da bisseção",
                                  "tips": "Use indentação clara para representar loops e condicionais; anote comentários para cada linha chave",
                                  "learningObjective": "Dominar a lógica algorítmica do método da bisseção incluindo todos os critérios de parada",
                                  "commonMistakes": "Esquecer verificação de f(a)*f(b) < 0; não incluir parada por iterações máximas; confundir tolerâncias absoluta e relativa"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir função não-linear de equilíbrio de vigas para teste",
                                  "subSteps": [
                                    "Modele uma viga simply supported com carga não-linear: f(x) = EI * x'''(L-x) - P * (x/L)^n = 0, onde x é deslocamento máximo",
                                    "Simplifique para equação não-linear: f(x) = x^3 - 2*x^2 + 1.5*x - 0.5 = 0 (representando equilíbrio deformado)",
                                    "Escolha intervalo inicial [a, b] = [0, 2] verificando mudança de sinal: f(0) > 0, f(2) < 0",
                                    "Calcule valores analíticos aproximados ou gráficos para validar raiz esperada ~0.5",
                                    "Documente parâmetros físicos: E=modulo elasticidade, I=inércia, L=comprimento, P=carga, n=expoente não-linear"
                                  ],
                                  "verification": "Plote f(x) manualmente ou em ferramenta simples e confirme pelo menos uma raiz no intervalo",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora, software de plotagem como Desmos ou papel milimetrado",
                                  "tips": "Escolha função com raiz conhecida para validação inicial; garanta monotonicidade parcial no intervalo",
                                  "learningObjective": "Aplicar método a problema real de engenharia civil, modelando equações de equilíbrio estrutural",
                                  "commonMistakes": "Intervalo sem mudança de sinal; função sem raiz real; ignorar contexto físico da viga"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar pseudocódigo em MATLAB com função de viga",
                                  "subSteps": [
                                    "Abra MATLAB e defina função anônima: f = @(x) x.^3 - 2*x.^2 + 1.5*x - 0.5;",
                                    "Escreva script principal: defina a, b, tol_a=1e-6, tol_r=1e-6, N_max=100",
                                    "Implemente loop while: c=(a+b)/2; verifique abs(f(c))<tol_a ou abs((b-a)/a)<tol_r ou it> N_max",
                                    "Atualize a ou b baseado em sinal de f(c); armazene histórico de c e erros",
                                    "Adicione plot: plotar f(x), intervalo inicial/final e raízes"
                                  ],
                                  "verification": "Execute script e confirme convergência para raiz ~0.532 com <20 iterações e erro <1e-6",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB instalado, editor de script",
                                  "tips": "Use fprintf para output tabular de iterações; vetorize funções para eficiência",
                                  "learningObjective": "Traduzir pseudocódigo para código MATLAB funcional e visual",
                                  "commonMistakes": "Loop infinito por tolerâncias inadequadas; erro de sintaxe em funções anônimas; plot sem legendas"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, analisar convergência e documentar resultados",
                                  "subSteps": [
                                    "Execute com diferentes tolerâncias e N_max, registre iterações e erro final",
                                    "Compare com solução analítica ou outro método (ex: Newton-Raphson)",
                                    "Analise taxa de convergência: plote erro vs iteração (deve ser linear)",
                                    "Teste casos edge: sem convergência, f(c)=0 imediato",
                                    "Gere relatório: código comentado, plots, tabela de resultados e interpretação para viga"
                                  ],
                                  "verification": "Relatório mostra convergência consistente, plots claros e comparação com valor esperado",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB, documento Word/PDF para relatório",
                                  "tips": "Salve múltiplas versões do script; use semilogy para erro logarítmico",
                                  "learningObjective": "Avaliar robustez do método e interpretar resultados no contexto de engenharia",
                                  "commonMistakes": "Ignorar não-convergência; plots ilegíveis; sem comparação com referências"
                                }
                              ],
                              "practicalExample": "Implemente o método para resolver f(x) = x^3 - 2x^2 + 1.5x - 0.5 = 0, representando o deslocamento máximo em uma viga de 5m com carga distribuída não-linear P(x)=P0*(x/L)^2. Inicial [0,2], converge para x≈0.532m em 12 iterações com tol=1e-6.",
                              "finalVerifications": [
                                "Pseudocódigo inclui todos critérios de parada e tratamento de erros",
                                "Função de viga tem mudança de sinal no intervalo e raiz física válida",
                                "Código MATLAB executa sem erros e converge em <50 iterações",
                                "Plots mostram evolução do intervalo e convergência linear",
                                "Relatório documenta parâmetros, resultados e análise de erro",
                                "Testes edge (ex: N_max baixo) são tratados corretamente"
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro final <1e-6 e raiz dentro de 1% do valor esperado",
                                "Completude: todos elementos do pseudocódigo implementados no MATLAB",
                                "Eficiência: convergência em <30 iterações para exemplo padrão",
                                "Visualização: plots claros com legendas, eixos rotulados e histórico",
                                "Documentação: comentários no código e relatório explicando aplicação em vigas",
                                "Robustez: lida com casos inválidos sem crash"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Comparação com outros métodos iterativos",
                                "Programação: Boas práticas de scripting em MATLAB/Python",
                                "Engenharia Estrutural: Modelagem de deformações não-lineares em vigas",
                                "Física: Equilíbrio estático e leis de Hooke generalizadas",
                                "Análise de Dados: Plots de convergência e regressão de erros"
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios, o método da bisseção resolve equações não-lineares para prever deslocamentos em vigas sob cargas sísmicas ou ventos, otimizando design e evitando colapsos estruturais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Método da Posição Falsa",
                    "description": "Método iterativo que usa interpolação linear entre dois pontos para aproximar a raiz, melhorando a eficiência da bisseção.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Definição e Princípio do Método da Posição Falsa",
                        "description": "Compreensão dos fundamentos do método da posição falsa (Regula Falsi), que combina a confiabilidade do método da bisseção com interpolação linear para aproximar raízes de equações não-lineares f(x) = 0 em um intervalo [a, b] onde f(a) e f(b) têm sinais opostos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Identificar condições iniciais para aplicação",
                            "description": "Determinar um intervalo inicial [a, b] contínuo onde f(a) * f(b) < 0, garantindo a existência de pelo menos uma raiz pelo teorema do valor intermediário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Teorema do Valor Intermediário (TVI)",
                                  "subSteps": [
                                    "Lembre-se da declaração do TVI: Se f é contínua em [a, b] e f(a) e f(b) têm sinais opostos, então existe c em (a, b) tal que f(c) = 0.",
                                    "Confirme que a função deve ser contínua no intervalo fechado [a, b].",
                                    "Entenda que o TVI garante pelo menos uma raiz, mas não sua localização exata.",
                                    "Discuta limitações: não funciona se f(a) e f(b) tiverem o mesmo sinal ou se houver discontinuidades.",
                                    "Esboce um gráfico simples de uma função cruzando o eixo x para visualizar."
                                  ],
                                  "verification": "Explique o TVI em suas próprias palavras e identifique se ele se aplica a uma função dada com sinais opostos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora gráfica ou software como GeoGebra/Desmos.",
                                  "tips": "Sempre verifique continuidade primeiro; funções polinomiais são contínuas em todo R.",
                                  "learningObjective": "Compreender os fundamentos teóricos que justificam a escolha do intervalo inicial.",
                                  "commonMistakes": "Assumir que o TVI encontra a raiz exata (ele só garante existência); ignorar a exigência de continuidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Condição f(a) * f(b) < 0",
                                  "subSteps": [
                                    "Calcule f(a) e f(b) para valores iniciais propostos.",
                                    "Verifique se o produto f(a) * f(b) é negativo, indicando sinais opostos (um positivo, outro negativo).",
                                    "Se o produto for positivo, ajuste a ou b expandindo o intervalo.",
                                    "Teste múltiplos pontos próximos para localizar mudança de sinal.",
                                    "Registre os valores de f(a) e f(b) em uma tabela para clareza."
                                  ],
                                  "verification": "Para uma função dada, compute f(a) e f(b) e confirme se o produto é negativo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora científica, planilha Excel ou Python para avaliação rápida de funções.",
                                  "tips": "Use intervalos pequenos inicialmente para precisão, mas garanta que capturem a raiz.",
                                  "learningObjective": "Dominar a interpretação algébrica da mudança de sinal como garantia de raiz.",
                                  "commonMistakes": "Confundir f(a) * f(b) < 0 com |f(a)| * |f(b)| < 0; não considerar zeros exatos (f(a)=0 já é raiz)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estratégias para Selecionar o Intervalo Inicial [a, b]",
                                  "subSteps": [
                                    "Plote ou esboce o gráfico da função para visualizar cruzamentos com o eixo x.",
                                    "Avalie a função em pontos equidistantes (ex: a=0, b=1, 2, etc.) até encontrar mudança de sinal.",
                                    "Use conhecimento do domínio físico (ex: em engenharia, x ≥ 0 para comprimentos).",
                                    "Aplique bissecção manual inicial para refinar.",
                                    "Priorize intervalos pequenos para convergência rápida no método da posição falsa."
                                  ],
                                  "verification": "Selecione [a, b] para uma função desconhecida e justifique com cálculos de sinal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráfica online (Desmos), papel quadriculado, software MATLAB/Python para plotagem.",
                                  "tips": "Comece com domínio amplo e afine; evite intervalos muito grandes para métodos numéricos.",
                                  "learningObjective": "Aprender técnicas práticas para isolar raízes em equações não-lineares.",
                                  "commonMistakes": "Escolher [a,b] onde f é não-contínua (ex: divisões por zero); ignorar múltiplas raízes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Documentar a Escolha do Intervalo",
                                  "subSteps": [
                                    "Reconfirme f(a) * f(b) < 0 e continuidade em [a, b].",
                                    "Calcule o comprimento do intervalo (b - a) para avaliar eficiência.",
                                    "Teste um ponto intermediário para confirmar apenas uma raiz (opcional).",
                                    "Documente em formato: 'Intervalo [a,b]: f(a)=X, f(b)=Y, produto=Z < 0'.",
                                    "Prepare para iteração no método da posição falsa."
                                  ],
                                  "verification": "Apresente um relatório curto validando [a,b] com evidências numéricas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de relatório, calculadora.",
                                  "tips": "Sempre salve plots e tabelas para auditoria em projetos de engenharia.",
                                  "learningObjective": "Garantir robustez na seleção inicial para métodos numéricos confiáveis.",
                                  "commonMistakes": "Não documentar valores exatos; prosseguir com intervalos inválidos."
                                }
                              ],
                              "practicalExample": "Para f(x) = x^3 - 2x^2 - 5x + 6 (equação modelando deformação em uma viga sob carga distribuída em engenharia civil), teste x= -1: f(-1)=10 >0; x=0: f(0)=6>0; x=1: f(1)=0 (raiz exata, mas simule); x=2: f(2)=-4<0. Escolha [-1,2]? Não, mesmo sinal inicial; refine para [1,2] mas f(1)=0; exemplo melhor: [2,3] f(2)=-4<0, f(3)=6>0, produto <0. Intervalo válido [2,3].",
                              "finalVerifications": [
                                "Selecione corretamente [a,b] para 3 funções diferentes com mudança de sinal.",
                                "Explique por que f(a)*f(b)<0 garante raiz pelo TVI.",
                                "Identifique e corrija um intervalo inválido proposto.",
                                "Documente um intervalo com valores numéricos precisos.",
                                "Aplique a uma equação de engenharia civil real.",
                                "Confirme continuidade no intervalo escolhido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de f(a)*f(b)<0 (100% correto).",
                                "Justificativa teórica clara referenciando TVI.",
                                "Eficiência do intervalo (b-a mínimo possível).",
                                "Ausência de erros comuns como ignorar continuidade.",
                                "Documentação completa e organizada.",
                                "Aplicação contextual a problemas de engenharia."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar script em Python para automação da busca de sinal oposto.",
                                "Física: Raízes em equações de equilíbrio estático (força net=0).",
                                "Estatística: Intervalos de confiança em modelagem preditiva.",
                                "Geometria Computacional: Visualização de raízes via gráficos 2D."
                              ],
                              "realWorldApplication": "Em engenharia civil, identificar condições iniciais para o método da posição falsa resolve equações não-lineares como as de fluxo em tubulações (equação de Hazen-Williams) ou pontos de flambagem em colunas (Euler buckling modificado), garantindo convergência numérica rápida para dimensionamento seguro de estruturas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Explicar a interpolação linear no método",
                            "description": "Descrever como o método usa a reta secante entre (a, f(a)) e (b, f(b)) para encontrar o ponto de interseção com o eixo x, dado por x = (a*f(b) - b*f(a)) / (f(b) - f(a)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os Pontos Iniciais de Bracketing",
                                  "subSteps": [
                                    "Selecionar um intervalo [a, b] onde f(a) e f(b) têm sinais opostos (f(a) * f(b) < 0)",
                                    "Calcular os valores f(a) e f(b) usando a função dada",
                                    "Visualizar graficamente os pontos (a, f(a)) e (b, f(b)) no plano cartesiano",
                                    "Confirmar que existe pelo menos uma raiz no intervalo pelo Teorema do Valor Intermediário",
                                    "Anotar os pontos como base para a reta secante"
                                  ],
                                  "verification": "Os pontos (a, f(a)) e (b, f(b)) estão corretamente calculados e plotados, com sinais opostos confirmados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função f(x) de exemplo",
                                    "Papel quadriculado ou software de graficação como Desmos/GeoGebra",
                                    "Calculadora"
                                  ],
                                  "tips": [
                                    "Sempre verifique os sinais de f(a) e f(b) antes de prosseguir.",
                                    "Use um gráfico para intuitivamente ver a raiz entre os pontos."
                                  ],
                                  "learningObjective": "Compreender a importância do bracketing inicial para garantir convergência.",
                                  "commonMistakes": [
                                    "Escolher intervalo sem mudança de sinal.",
                                    "Erros de cálculo em f(a) ou f(b)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Equação da Reta Secante",
                                  "subSteps": [
                                    "Recordar a equação da reta que passa por dois pontos: y - y1 = m (x - x1), onde m é a inclinação",
                                    "Calcular a inclinação m = (f(b) - f(a)) / (b - a)",
                                    "Substituir os pontos (a, f(a)) e (b, f(b)) na equação da reta",
                                    "Simplificar a equação para y = m(x - a) + f(a)",
                                    "Verificar que a reta conecta exatamente os dois pontos"
                                  ],
                                  "verification": "A equação da reta é derivada corretamente e satisfaz ambos os pontos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para derivação",
                                    "Calculadora para inclinação",
                                    "Gráfico dos pontos"
                                  ],
                                  "tips": [
                                    "Use a fórmula de inclinação diretamente para evitar erros aritméticos.",
                                    "Desenhe a reta no gráfico para validação visual."
                                  ],
                                  "learningObjective": "Dominar a construção geométrica e algébrica da reta secante.",
                                  "commonMistakes": [
                                    "Confundir inclinação com diferença de y/x invertida.",
                                    "Não simplificar a equação adequadamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Interseção com o Eixo X",
                                  "subSteps": [
                                    "Definir a interseção com o eixo x como o ponto onde y = 0",
                                    "Substituir y = 0 na equação da reta: 0 = m(x - a) + f(a)",
                                    "Isolar x: x = a - f(a)/m",
                                    "Substituir m pela expressão (f(b) - f(a))/(b - a), resultando em x = (a f(b) - b f(a)) / (f(b) - f(a))",
                                    "Interpretar x como aproximação linear da raiz"
                                  ],
                                  "verification": "A fórmula final x = (a f(b) - b f(a)) / (f(b) - f(a)) é derivada corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de derivação algébrica",
                                    "Calculadora simbólica ou app como Wolfram Alpha para verificação"
                                  ],
                                  "tips": [
                                    "Faça a derivação passo a passo para evitar saltos lógicos.",
                                    "Teste a fórmula nos pontos originais para consistência."
                                  ],
                                  "learningObjective": "Derivar e compreender a fórmula explícita da interpolação linear.",
                                  "commonMistakes": [
                                    "Erro de sinal ao isolar x.",
                                    "Inverter numerador ou denominador na fórmula final."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar no Contexto do Método da Posição Falsa",
                                  "subSteps": [
                                    "Explicar que este x substitui o ponto com sinal igual ao de f(x) no próximo intervalo",
                                    "Comparar com o método da bisseção (que usa o meio aritmético)",
                                    "Discutir vantagens: convergência mais rápida por usar inclinação",
                                    "Simular uma iteração completa com o novo [a, x] ou [x, b]",
                                    "Resumir o princípio geométrico: reta secante sempre 'corta' o eixo próximo à raiz"
                                  ],
                                  "verification": "Pode explicar verbalmente ou por escrito como a interpolação impulsiona o método.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplo numérico resolvido",
                                    "Tabela de iterações",
                                    "Software como Python/MATLAB para simulação"
                                  ],
                                  "tips": [
                                    "Use animações online do Regula Falsi para visualização dinâmica.",
                                    "Enfatize a preservação do bracketing."
                                  ],
                                  "learningObjective": "Integrar a interpolação linear ao fluxo iterativo do método.",
                                  "commonMistakes": [
                                    "Confundir com secante puro (sem bracketing).",
                                    "Ignorar a atualização do intervalo."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere f(x) = x² - 2 = 0 no intervalo [1, 2]. Aqui, a=1, f(a)=-1; b=2, f(b)=2. A interpolação linear dá x = (1*2 - 2*(-1)) / (2 - (-1)) = (2 + 2)/3 = 4/3 ≈ 1.333. Verifique f(1.333) ≈ -0.222, que mantém o bracketing com [1.333, 2].",
                              "finalVerifications": [
                                "Deriva corretamente a fórmula x = (a f(b) - b f(a)) / (f(b) - f(a)) a partir da reta secante.",
                                "Aplica a fórmula em um exemplo numérico e calcula f(x) no novo ponto.",
                                "Explica geometricamente por que a interseção aproxima a raiz.",
                                "Compara com bisseção, destacando convergência superlinear.",
                                "Simula uma iteração completa do método da posição falsa.",
                                "Identifica quando o método pode falhar (ex: funções convexas)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica (sem erros aritméticos).",
                                "Compreensão geométrica demonstrada via esboço ou descrição.",
                                "Aplicação correta em exemplos, com verificação de bracketing.",
                                "Explicação clara das vantagens sobre métodos lineares simples.",
                                "Uso apropriado de terminologia (reta secante, interpolação linear).",
                                "Capacidade de generalizar para implementações computacionais"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações lineares e Teorema do Valor Intermediário.",
                                "Programação: Implementação de loops iterativos em Python/MATLAB.",
                                "Física: Modelagem de equações não-lineares em dinâmica de estruturas.",
                                "Estatística: Aproximações numéricas em regressão linear.",
                                "Engenharia de Software: Algoritmos numéricos em bibliotecas como SciPy."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para resolver equações não-lineares em análise de estruturas, como encontrar deformações em vigas com materiais não-lineares (ex: concreto armado sob grandes cargas), onde f(x) representa desequilíbrio de forças e x a deformação crítica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Comparar com o método da bisseção",
                            "description": "Analisar as vantagens da posição falsa sobre a bisseção, como convergência mais rápida (ordem ≈1.618), mantendo a garantia de convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Princípios Fundamentais do Método da Bisseção",
                                  "subSteps": [
                                    "Relembre a definição: método que divide o intervalo [a, b] ao meio repetidamente, garantindo convergência linear.",
                                    "Descreva o critério de parada: |b - a| < tolerância ou número máximo de iterações.",
                                    "Implemente manualmente 3-5 iterações em uma equação simples como f(x) = x^2 - 2.",
                                    "Registre o erro relativo em cada iteração para análise posterior.",
                                    "Anote a ordem de convergência aproximada (1, linear)."
                                  ],
                                  "verification": "Lista de iterações completas com erros calculados e gráfico de convergência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, calculadora, software como Python ou Excel para plotar erros.",
                                  "tips": "Sempre verifique f(a) * f(b) < 0 para garantir raiz no intervalo.",
                                  "learningObjective": "Compreender a convergência garantida mas lenta da bisseção.",
                                  "commonMistakes": "Esquecer de verificar o sinal oposto das funções nos extremos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Método da Posição Falsa e sua Formulação",
                                  "subSteps": [
                                    "Defina o método: aproxima a raiz usando a secante entre f(a) e f(b), atualizando o extremo com sinal oposto.",
                                    "Escreva a fórmula: c = b - f(b) * (b - a) / (f(b) - f(a)).",
                                    "Implemente 3-5 iterações na mesma equação f(x) = x^2 - 2.",
                                    "Compare visualmente o novo intervalo com o da bisseção.",
                                    "Calcule a redução percentual do intervalo em cada passo."
                                  ],
                                  "verification": "Tabela comparativa de iterações da posição falsa vs. bisseção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora científica, planilha Excel ou script Python simples.",
                                  "tips": "A posição falsa pode ser mais lenta se f for muito assimétrica; teste variações.",
                                  "learningObjective": "Dominar a mecânica da posição falsa e sua semelhança com secante.",
                                  "commonMistakes": "Confundir com método da secante (que não garante convergência bracketed)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Taxas de Convergência Teórica e Numérica",
                                  "subSteps": [
                                    "Explique a ordem de convergência: bisseção ≈1 (linear), posição falsa ≈1.618 (número de ouro).",
                                    "Derive ou recite a prova qualitativa da superlinearidade da posição falsa.",
                                    "Plote log(erros) vs. iterações para ambos métodos na equação teste.",
                                    "Calcule numericamente a ordem usando E_{n+1} ≈ C * E_n^p para p≈1.618 na posição falsa.",
                                    "Quantifique: número de iterações para precisão 10^-6."
                                  ],
                                  "verification": "Gráfico de erros e tabela com ordens calculadas (p >1 para posição falsa).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de plotagem (Python/MATLAB/Excel), equação não-linear com raiz conhecida.",
                                  "tips": "Use funções convexas para demonstrar convergência mais rápida da posição falsa.",
                                  "learningObjective": "Analisar matematicamente por que a posição falsa converge mais rápido.",
                                  "commonMistakes": "Ignorar que a constante C na posição falsa pode ser maior em casos ruins."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Vantagens Gerais e Garantias de Convergência",
                                  "subSteps": [
                                    "Liste vantagens: convergência mais rápida, mesma garantia bracketed (f(a)*f(b)<0).",
                                    "Discuta desvantagens: pode estagnar se função plana em um lado.",
                                    "Compare estabilidade numérica e sensibilidade a erros de arredondamento.",
                                    "Resuma em tabela: velocidade, garantia, casos ideais vs. ruins.",
                                    "Conclua quando usar cada um em problemas de engenharia."
                                  ],
                                  "verification": "Tabela de prós/contras e recomendação contextualizada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para tabela, referências teóricas (livro de análise numérica).",
                                  "tips": "Enfatize que posição falsa é 'bisseção turbinada' para a maioria dos casos.",
                                  "learningObjective": "Avaliar trade-offs para seleção de método em cenários reais.",
                                  "commonMistakes": "Afirmar que posição falsa sempre converge mais rápido sem testes."
                                }
                              ],
                              "practicalExample": "Resolva f(x) = e^x - 3x^2 (equação de equilíbrio em vigas) no intervalo [0,1]. Aplique bisseção (≈25 iterações para 10^-10) vs. posição falsa (≈17 iterações), plotando redução de intervalo.",
                              "finalVerifications": [
                                "Explicar verbalmente a ordem 1.618 e derivá-la qualitativamente.",
                                "Apresentar tabela numérica mostrando <20% mais iterações na bisseção.",
                                "Identificar caso onde posição falsa falha (f plana) e propor solução.",
                                "Recomendar posição falsa para problemas de engenharia civil rotineiros.",
                                "Gráfico de convergência confirmando superioridade.",
                                "Resumir garantias: ambos convergem monotonicamente no bracket."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da ordem de convergência (erro <10%).",
                                "Tabela comparativa completa com pelo menos 10 iterações cada.",
                                "Análise equilibrada de vantagens/desvantagens com exemplos.",
                                "Uso correto de gráficos para visualização de erros.",
                                "Conexão explícita com aplicações em equações não-lineares civis.",
                                "Ausência de erros conceituais sobre garantias bracketed."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar ambos em Python para automação.",
                                "Cálculo Numérico: Ligação com métodos de secante e regula falsi.",
                                "Engenharia Computacional: Otimização em solvers de FEM (elementos finitos).",
                                "Estatística: Análise de erros e confiabilidade numérica."
                              ],
                              "realWorldApplication": "Em engenharia civil, usar posição falsa para raízes em equações de flambagem de colunas ou equilíbrio hidráulico, reduzindo tempo computacional em softwares como ANSYS, mantendo robustez da bisseção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Algoritmo Iterativo do Método",
                        "description": "Implementação passo a passo do algoritmo iterativo, incluindo cálculo do novo ponto de aproximação e atualização do intervalo.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Desenvolver pseudocódigo do algoritmo",
                            "description": "Escrever o pseudocódigo completo: inicializar a e b, calcular x, atualizar o intervalo baseado no sinal de f(x), repetir até critério de parada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a inicialização dos parâmetros",
                                  "subSteps": [
                                    "Escolher valores iniciais a e b tais que f(a) * f(b) < 0 para garantir que há uma raiz no intervalo.",
                                    "Definir a tolerância (tol) para o critério de parada, como 0.001.",
                                    "Estabelecer o número máximo de iterações (max_iter), como 100.",
                                    "Definir a função f(x) explicitamente no pseudocódigo.",
                                    "Verificar manualmente os sinais de f(a) e f(b)."
                                  ],
                                  "verification": "Confirme que f(a) e f(b) têm sinais opostos calculando-os manualmente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Exemplo de função não-linear como f(x) = x^3 - x - 2"
                                  ],
                                  "tips": [
                                    "Sempre priorize intervalos pequenos para convergência rápida.",
                                    "Teste múltiplos intervalos se necessário."
                                  ],
                                  "learningObjective": "Compreender a importância da bracket inicial para o sucesso do método.",
                                  "commonMistakes": [
                                    "Escolher a e b com o mesmo sinal de f.",
                                    "Não definir tol ou max_iter, causando loops infinitos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever a fórmula para cálculo do ponto x",
                                  "subSteps": [
                                    "Recordar e anotar a fórmula do método: x = (a * f(b) - b * f(a)) / (f(b) - f(a)).",
                                    "Implementar o cálculo de f(x) logo após x.",
                                    "Incluir chamadas à função f(x) de forma clara.",
                                    "Simular o cálculo com valores iniciais para validar.",
                                    "Adicionar comentário explicando a origem geométrica (linha secante)."
                                  ],
                                  "verification": "Calcule x manualmente com a e b iniciais e compare com fórmula conhecida.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência da fórmula do método da posição falsa"
                                  ],
                                  "tips": [
                                    "Lembre-se: é a interseção da secante com o eixo x.",
                                    "Evite divisão por zero checando f(b) != f(a)."
                                  ],
                                  "learningObjective": "Dominar a expressão matemática central do algoritmo.",
                                  "commonMistakes": [
                                    "Confundir com fórmula da bisseção (média simples).",
                                    "Esquecer de calcular f(x)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a lógica de atualização do intervalo",
                                  "subSteps": [
                                    "Verificar se f(x) * f(a) < 0: se sim, atualizar b = x (raiz em [a, x]).",
                                    "Caso contrário, atualizar a = x (raiz em [x, b]).",
                                    "Incrementar o contador de iterações.",
                                    "Opcionalmente, calcular a largura do intervalo |b - a| para monitoramento.",
                                    "Adicionar comentários para cada caso condicional."
                                  ],
                                  "verification": "Simule duas iterações com exemplo e confirme que o intervalo encolhe corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo numérico simples"
                                  ],
                                  "tips": [
                                    "Mantenha o bracket sempre válido após atualização.",
                                    "Use estruturas IF-ELSE claras."
                                  ],
                                  "learningObjective": "Aprender a decisão baseada em sinais para preservar o bracket.",
                                  "commonMistakes": [
                                    "Atualizar errado o lado do sinal.",
                                    "Não incrementar iterações."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estruturar o loop, critérios de parada e finalizar o pseudocódigo",
                                  "subSteps": [
                                    "Criar loop WHILE: enquanto |b - a| > tol E iter < max_iter.",
                                    "Colocar cálculos de x, f(x), atualização e incremento dentro do loop.",
                                    "Após o loop, retornar a aproximação da raiz (ex: x ou (a+b)/2).",
                                    "Adicionar comentários em todo o pseudocódigo.",
                                    "Testar logicamente o fluxo completo."
                                  ],
                                  "verification": "Trace o pseudocódigo com exemplo até parada e verifique convergência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo completo de iterações"
                                  ],
                                  "tips": [
                                    "Use pseudocódigo indentado para clareza.",
                                    "Considere saída de erro se não convergir."
                                  ],
                                  "learningObjective": "Construir a estrutura iterativa completa e robusta.",
                                  "commonMistakes": [
                                    "Loop infinito sem critérios.",
                                    "Retornar valor errado ao final."
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x^3 - x - 2 (raiz ≈1.52):\nINÍCIO\n  a ← 1\n  b ← 2  // f(1)<0, f(2)>0\n  tol ← 0.001\n  max_iter ← 100\n  iter ← 0\nENQUANTO |b - a| > tol E iter < max_iter FAÇA\n  x ← (a*f(b) - b*f(a)) / (f(b) - f(a))\n  fx ← f(x)\n  SE fx * f(a) < 0 ENTAO\n    b ← x\n  SENÃO\n    a ← x\n  FIMSE\n  iter ← iter + 1\nFIMENQUANTO\nRETORNE x\nFIM\nPrimeira iteração: x≈1.618, fx>0 → a=1.618.",
                              "finalVerifications": [
                                "Inicialização inclui a, b com sinais opostos, tol e max_iter?",
                                "Fórmula de x está correta e f(x) calculada?",
                                "Atualização do intervalo baseada corretamente em f(x)*f(a)?",
                                "Loop WHILE com critérios duplos (|b-a|>tol E iter<max_iter)?",
                                "Incremento de iter e retorno da raiz ao final?",
                                "Pseudocódigo indentado e comentado?"
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: algoritmo converge corretamente.",
                                "Clareza e legibilidade: sintaxe pseudocódigo padrão.",
                                "Completude: todos elementos do método presentes.",
                                "Robustez: tratamento implícito de casos limites.",
                                "Comentários: explicam cada seção.",
                                "Adequação: fiel ao método da posição falsa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Métodos numéricos e convergência.",
                                "Programação: Loops, condicionais e funções.",
                                "Engenharia Civil: Equações não-lineares em estruturas.",
                                "Análise Numérica: Comparação com bisseção/secante.",
                                "Computação Científica: Implementação em software como MATLAB/Python."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, o pseudocódigo do Método da Posição Falsa resolve equações não-lineares em análises estruturais (ex: deformações não-lineares em vigas ou pilares sob grandes cargas), equilíbrio de fundações em solos plásticos ou cálculo de vazão em redes hidráulicas com perdas não-lineares, permitindo simulações computacionais precisas e eficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Executar uma iteração manual",
                            "description": "Realizar cálculos manuais de uma iteração completa para f(x) = x^2 - 2 em [1, 2], determinando o novo intervalo e aproximação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o intervalo inicial e verificar condições",
                                  "subSteps": [
                                    "Identifique a função f(x) = x² - 2",
                                    "Defina os extremos iniciais a = 1 e b = 2",
                                    "Calcule f(a) = 1² - 2 = -1 (negativo)",
                                    "Calcule f(b) = 2² - 2 = 2 (positivo)",
                                    "Confirme mudança de sinal: f(a) * f(b) < 0"
                                  ],
                                  "verification": "Verifique se f(a) < 0 e f(b) > 0, garantindo existência de raiz pelo Teorema do Valor Intermediário",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora básica"
                                  ],
                                  "tips": "Sempre priorize intervalos pequenos para convergência rápida",
                                  "learningObjective": "Compreender as condições iniciais necessárias para o método da posição falsa",
                                  "commonMistakes": [
                                    "Ignorar verificação de sinais opostos",
                                    "Erro aritmético em f(a) ou f(b)",
                                    "Escolher extremos sem mudança de sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o ponto de posição falsa c",
                                  "subSteps": [
                                    "Lembre a fórmula: c = (a * f(b) - b * f(a)) / (f(b) - f(a))",
                                    "Substitua valores: numerador = 1*2 - 2*(-1) = 2 + 2 = 4",
                                    "Denominador = f(b) - f(a) = 2 - (-1) = 3",
                                    "Calcule c = 4 / 3 ≈ 1.3333",
                                    "Registre c com precisão de 4 casas decimais"
                                  ],
                                  "verification": "Confirme c ≈ 1.3333 comparando com cálculo manual ou calculadora",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora"
                                  ],
                                  "tips": "Mantenha frações exatas (4/3) antes de aproximar para evitar erros de arredondamento",
                                  "learningObjective": "Dominar a fórmula interpoladora linear do método da posição falsa",
                                  "commonMistakes": [
                                    "Inverter numerador ou denominador",
                                    "Esquecer sinal negativo em f(a)",
                                    "Arredondar prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar a função no ponto c",
                                  "subSteps": [
                                    "Calcule f(c) = (4/3)² - 2 = 16/9 - 18/9 = -2/9 ≈ -0.2222",
                                    "Anote o sinal de f(c): negativo",
                                    "Compare sinal de f(c) com f(a) e f(b)",
                                    "Registre f(c) exato e aproximado",
                                    "Verifique cálculo: (4/3)² = 1.7778, menos 2 = -0.2222"
                                  ],
                                  "verification": "Resultado f(c) = -2/9 < 0 deve coincidir com cálculo independente",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para verificação"
                                  ],
                                  "tips": "Use frações para exatidão: prefira -2/9 a aproximações iniciais",
                                  "learningObjective": "Aplicar avaliação funcional precisa em pontos interpolados",
                                  "commonMistakes": [
                                    "Erro no quadrado de fração",
                                    "Confundir sinal de f(c)",
                                    "Não registrar tanto exato quanto aproximado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Atualizar o intervalo baseado no sinal de f(c)",
                                  "subSteps": [
                                    "Se f(c) tem mesmo sinal que f(a) (ambos negativos), defina novo a = c (a=4/3), b=2 permanece",
                                    "Novo intervalo: [4/3, 2] ≈ [1.3333, 2]",
                                    "Confirme mudança de sinal no novo intervalo: f(a novo)<0, f(b)>0",
                                    "Calcule comprimento novo: 2 - 4/3 = 2/3 ≈0.6667 (reduzido de 1)",
                                    "Documente o novo intervalo claramente"
                                  ],
                                  "verification": "Novo intervalo [4/3, 2] com sinais opostos confirmados",
                                  "estimatedTime": "7 minutos",
                                  "materials": [
                                    "Papel para tabela de iterações"
                                  ],
                                  "tips": "Desenhe uma linha numérica para visualizar redução do intervalo",
                                  "learningObjective": "Implementar regra de atualização para convergência monotônica",
                                  "commonMistakes": [
                                    "Atualizar errado o extremo (ex: b=c em vez de a=c)",
                                    "Não verificar novo sinal",
                                    "Manter intervalo antigo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Determinar a aproximação e registrar resultados",
                                  "subSteps": [
                                    "Aproximação da iteração: use c = 4/3 ≈1.3333 como estimativa da raiz √2",
                                    "Calcule erro relativo aproximado: |c - √2| / √2 (√2≈1.4142, erro≈0.058)",
                                    "Registre tabela: iteração 1 | a=1 | b=2 | c=1.3333 | f(c)=-0.2222 | novo [1.3333,2]",
                                    "Compare com valor real √2≈1.4142",
                                    "Prepare para próxima iteração se necessário"
                                  ],
                                  "verification": "Aproximação 1.3333 plausível, intervalo reduzido corretamente",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela impressa ou papel",
                                    "Valor referência √2=1.414213562"
                                  ],
                                  "tips": "Sempre inclua tabela para rastrear múltiplas iterações",
                                  "learningObjective": "Interpretar resultados da iteração e avaliar precisão inicial",
                                  "commonMistakes": [
                                    "Usar média em vez de c como aproximação",
                                    "Ignorar registro tabular",
                                    "Erro no erro relativo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x)=x²-2 em [1,2]: f(1)=-1, f(2)=2, c=(1*2-2*(-1))/(2-(-1))=4/3≈1.3333, f(c)=-2/9≈-0.2222<0 (mesmo sinal f(1)), novo intervalo [1.3333,2], aproximação=1.3333 (erro ~5.8% vs √2≈1.4142).",
                              "finalVerifications": [
                                "c calculado corretamente como 4/3 ≈1.3333",
                                "f(c) = -2/9 ≈ -0.2222 com sinal negativo",
                                "Novo intervalo [4/3, 2] com sinais opostos confirmados",
                                "Comprimento do intervalo reduzido de 1 para 2/3",
                                "Aproximação registrada como 1.3333",
                                "Tabela de iteração completa e precisa"
                              ],
                              "assessmentCriteria": [
                                "Precisão aritmética em todos os cálculos (erro <0.001)",
                                "Correta aplicação da fórmula de c e regra de atualização",
                                "Verificação explícita de sinais em cada etapa",
                                "Registro claro de valores exatos (frações) e aproximados",
                                "Interpretação correta da redução de intervalo e erro",
                                "Uso adequado de tabela para documentação"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teorema do Valor Intermediário e interpolação linear",
                                "Programação: Implementação em loops while para automação",
                                "Física/Engenharia: Modelagem de equilíbrio em vigas ou tensões",
                                "Estatística: Análise de convergência e tolerâncias numéricas"
                              ],
                              "realWorldApplication": "Em engenharia civil, aplica-se para resolver equações não-lineares em análise estrutural, como determinar cargas críticas onde deformação zero (ex: buckling em colunas) ou pontos de equilíbrio em fundações, otimizando projetos sem software inicialmente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Implementar em linguagem de programação",
                            "description": "Codificar o método em MATLAB ou Python, incluindo entrada de função, intervalo inicial e saída da raiz aproximada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função objetivo e parâmetros iniciais",
                                  "subSteps": [
                                    "Escolha ou defina a função f(x) não-linear a ser resolvida (ex: f(x) = x^3 - 2x - 5).",
                                    "Defina os intervalos iniciais a e b onde f(a) * f(b) < 0.",
                                    "Especifique parâmetros como tolerância (tol = 1e-6) e número máximo de iterações (max_iter = 100).",
                                    "Crie variáveis para armazenar histórico de iterações (opcional para depuração).",
                                    "Implemente entrada de parâmetros via função ou argumentos."
                                  ],
                                  "verification": "Execute o código até essa parte e confirme que f(a) e f(b) têm sinais opostos via print.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Python 3.x ou MATLAB instalado",
                                    "Editor de código (VS Code, Jupyter Notebook ou MATLAB Editor)",
                                    "Bibliotecas: numpy (Python) ou built-in (MATLAB)"
                                  ],
                                  "tips": "Sempre teste f(a) e f(b) manualmente antes de codificar para garantir bracketing da raiz.",
                                  "learningObjective": "Entender e codificar a configuração inicial necessária para o método da posição falsa.",
                                  "commonMistakes": [
                                    "Escolher a e b sem mudança de sinal",
                                    "Definir tolerância muito baixa inicialmente",
                                    "Esquecer importações de bibliotecas numéricas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o cálculo do ponto da posição falsa",
                                  "subSteps": [
                                    "Calcule o ponto c usando a fórmula: c = a - f(a) * (b - a) / (f(b) - f(a)).",
                                    "Avalie f(c) para determinar o sinal.",
                                    "Crie uma função auxiliar defina_posicao_falsa(a, b, f) que retorne c e f(c).",
                                    "Adicione tratamento para evitar divisão por zero (f(b) ≈ f(a)).",
                                    "Teste isoladamente com valores fixos de a, b e f."
                                  ],
                                  "verification": "Chame a função com valores conhecidos e verifique se c está entre a e b via print.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Mesmo ambiente do Step 1",
                                    "Calculadora para validação manual"
                                  ],
                                  "tips": "Use np.sign() em Python para verificar sinais de forma robusta.",
                                  "learningObjective": "Dominar a fórmula geométrica do método da posição falsa e sua implementação numérica.",
                                  "commonMistakes": [
                                    "Erro na fórmula (confundir com secante)",
                                    "Não tratar f(b) == f(a)",
                                    "Perda de precisão em subtrações (use tipos float64)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar o loop iterativo e critérios de convergência",
                                  "subSteps": [
                                    "Inicie loop while com condição |b - a| > tol e iter < max_iter.",
                                    "Dentro do loop: calcule c e f(c), atualize intervalos (se f(a)*f(c) < 0 então b = c, senão a = c).",
                                    "Armazene iterações, a, b, c em listas para histórico.",
                                    "Implemente parada por tolerância no intervalo ou na função f(c) < tol.",
                                    "Adicione contador de iterações e break se exceder max_iter."
                                  ],
                                  "verification": "Execute loop com poucos iter manualmente e confira redução do intervalo via prints.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Ambiente anterior",
                                    "Exemplo de função conhecida (ex: f(x)=cos(x)-x)"
                                  ],
                                  "tips": "Use um laço for com range(max_iter) como fallback para while infinito.",
                                  "learningObjective": "Implementar a iteração convergente com salvaguardas contra loops infinitos.",
                                  "commonMistakes": [
                                    "Atualização errada de intervalos",
                                    "Condição de parada inadequada",
                                    "Não inicializar contador de iterações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar com saída, testes e visualização",
                                  "subSteps": [
                                    "Após loop, defina raiz = (a + b)/2 ou c como aproximação.",
                                    "Imprima resultados: raiz, número de iterações, erro estimado |f(raiz)|.",
                                    "Adicione plot da função e marcações dos intervalos (matplotlib ou MATLAB plot).",
                                    "Teste com múltiplas funções e intervalos para validar.",
                                    "Crie função completa falsa_position(f, a, b, tol, max_iter) para reutilização."
                                  ],
                                  "verification": "Compare raiz com valor conhecido (ex: solver analítico) e erro < tol.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Biblioteca de plot: matplotlib (Python) ou plot() (MATLAB)",
                                    "Funções de teste variadas"
                                  ],
                                  "tips": "Salve histórico para plotar convergência (semilogy de erro vs iter).",
                                  "learningObjective": "Completar implementação com saída robusta e visualização para validação.",
                                  "commonMistakes": [
                                    "Saída prematura sem convergência",
                                    "Plot incorreto dos intervalos",
                                    "Falta de testes com funções reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente em Python para f(x) = x**3 - 2*x - 5 no intervalo [1, 3]:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef f(x): return x**3 - 2*x - 5\n\ndef falsa_position(f, a, b, tol=1e-6, max_iter=100):\n    if f(a)*f(b) >= 0: raise ValueError('Sinais iguais')\n    hist_a, hist_b, hist_c = [a], [b], []\n    for i in range(max_iter):\n        c = a - f(a)*(b-a)/(f(b)-f(a))\n        fc = f(c)\n        hist_c.append(c)\n        if abs(b-a) < tol or abs(fc) < tol: break\n        if f(a)*fc < 0: b = c\n        else: a = c\n        hist_a.append(a); hist_b.append(b)\n    raiz = (a+b)/2\n    print(f'Raiz: {raiz}, Iter: {i+1}, f(raiz): {f(raiz)}')\n    return raiz, hist_a, hist_b, hist_c\n\nraiz, ha, hb, hc = falsa_position(f, 1, 3)\n# Plot: x = np.linspace(0.5,3.5); plt.plot(x,f(x)); plt.plot(hc, [0]*len(hc),'ro'); plt.show()",
                              "finalVerifications": [
                                "O código converge para a raiz correta dentro da tolerância em < max_iter iterações.",
                                "Intervalos [a,b] reduzem monotonicamente até |b-a| < tol.",
                                "f(a)*f(b) < 0 mantido em todas as iterações.",
                                "Função lida com entradas inválidas (sinais iguais) com erro apropriado.",
                                "Plot ou histórico mostra convergência visual.",
                                "Testado com pelo menos 3 funções diferentes (quadrática, cúbica, transcendental)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro final |f(raiz)| < 1e-6.",
                                "Eficiência: Número de iterações < 20 para tol=1e-6.",
                                "Robustez: Trata casos degenerados (f(b)=f(a), não convergência).",
                                "Clareza: Código comentado, variáveis nomeadas intuitivamente.",
                                "Reutilizabilidade: Função modular aceitando f, a, b como parâmetros.",
                                "Visualização: Gráfico de convergência ou função incluído."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Análise de métodos iterativos e convergência.",
                                "Programação Computacional: Estruturas de controle (loops, condicionais) e funções.",
                                "Engenharia Civil: Modelagem de equações não-lineares em estruturas (ex: equilíbrio de cabos).",
                                "Análise de Dados: Visualização de resultados numéricos com plots.",
                                "Ética Computacional: Validação e tratamento de erros em simulações."
                              ],
                              "realWorldApplication": "Em engenharia civil, o método resolve equações não-lineares como as de deformação em vigas curvas, equilíbrio de treliças sob grandes deslocamentos ou fluxo em canais abertos, onde solvers analíticos falham, permitindo simulações precisas em softwares como ANSYS ou custom scripts para otimização estrutural."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Convergência, Erro e Aplicações",
                        "description": "Análise da convergência linear modificada, critérios de parada e problemas potenciais como convergência lenta em um lado.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Definir critérios de parada",
                            "description": "Estabelecer critérios como |b - a| < ε, |f(x)| < ε ou máximo de iterações N, com ε típico de 10^-6.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a importância dos critérios de parada",
                                  "subSteps": [
                                    "Explicar por que os métodos numéricos iterativos precisam de critérios de parada para evitar loops infinitos.",
                                    "Discutir os riscos de convergência lenta ou divergência sem critérios adequados.",
                                    "Identificar cenários onde a precisão excessiva consome recursos computacionais desnecessários.",
                                    "Relacionar com o método da posição falsa, onde o intervalo [a,b] é reduzido iterativamente.",
                                    "Estudar exemplos de falha sem critérios, como iterações ilimitadas."
                                  ],
                                  "verification": "Responda a 3 perguntas de compreensão sobre os riscos e benefícios dos critérios de parada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notebook com acesso a internet, vídeo introdutório sobre métodos numéricos (ex: Khan Academy).",
                                  "tips": "Anote os trade-offs entre precisão e eficiência computacional.",
                                  "learningObjective": "Entender o papel fundamental dos critérios de parada na eficiência e confiabilidade de algoritmos numéricos.",
                                  "commonMistakes": "Confundir critérios de parada com garantias de convergência absoluta."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e descrever os tipos comuns de critérios de parada",
                                  "subSteps": [
                                    "Descrever o critério de tamanho de intervalo: |b - a| < ε.",
                                    "Explicar o critério de valor da função: |f(x)| < ε.",
                                    "Detalhar o critério de número máximo de iterações: N máximo.",
                                    "Comparar os critérios em termos de robustez para o método da posição falsa.",
                                    "Analisar quando combinar critérios (ex: |b-a|<ε OU N>100)."
                                  ],
                                  "verification": "Liste e defina corretamente os 3 critérios principais com fórmulas matemáticas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta para esboços, software como MATLAB ou Python para visualização.",
                                  "tips": "Use diagramas de fluxo para ilustrar a lógica de decisão nos critérios.",
                                  "learningObjective": "Dominar as fórmulas e aplicações dos critérios de parada específicos para equações não-lineares.",
                                  "commonMistakes": "Ignorar que |f(x)|<ε pode falhar se f tiver raízes múltiplas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir valores típicos para ε e número máximo de iterações",
                                  "subSteps": [
                                    "Explicar a escolha de ε típico (ex: 10^-6 para precisão de máquina dupla).",
                                    "Discutir fatores influenciadores: precisão requerida, hardware disponível e natureza do problema.",
                                    "Definir N máximo baseado em convergência esperada (ex: 100-1000 iterações).",
                                    "Calcular impacto de ε em exemplos simples, como precisão decimal.",
                                    "Ajustar ε para contextos de engenharia civil, onde 10^-4 pode bastar para aproximações estruturais."
                                  ],
                                  "verification": "Justifique a escolha de ε=10^-6 e N=200 para um problema dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora científica, tabela de precisão numérica.",
                                  "tips": "Teste diferentes ε em uma calculadora para ver o efeito na precisão.",
                                  "learningObjective": "Selecionar valores apropriados de ε e N adaptados ao contexto de engenharia.",
                                  "commonMistakes": "Escolher ε muito pequeno (ex: 10^-15) levando a underflow ou tempo excessivo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e verificar os critérios no algoritmo",
                                  "subSteps": [
                                    "Escrever pseudocódigo incorporando os critérios no loop do método da posição falsa.",
                                    "Codificar em Python ou MATLAB com os critérios definidos.",
                                    "Executar o algoritmo em um exemplo e registrar o número de iterações e erro final.",
                                    "Analisar logs para confirmar parada correta.",
                                    "Testar casos extremos (convergência lenta, não-convergência)."
                                  ],
                                  "verification": "Execute o código e demonstre parada correta em pelo menos 2 exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (Python/Jupyter Notebook), função teste f(x)=x^3 - x - 2.",
                                  "tips": "Inclua prints de iteração, a, b, f(a), f(b) para depuração visual.",
                                  "learningObjective": "Integrar critérios de parada de forma prática em um algoritmo numérico funcional.",
                                  "commonMistakes": "Esquecer de atualizar o contador de iterações dentro do loop."
                                }
                              ],
                              "practicalExample": "Ao resolver f(x) = e^x - 3x^2 = 0 usando o método da posição falsa com [a,b]=[0,1], defina critérios: |b-a| < 10^-6 OU |f(c)| < 10^-6 OU 200 iterações. O algoritmo para na iteração 45 com erro <10^-6.",
                              "finalVerifications": [
                                "Critérios |b-a|<ε e |f(x)|<ε definidos com fórmulas corretas.",
                                "Valor de ε=10^-6 justificado adequadamente.",
                                "N máximo selecionado com base em convergência esperada.",
                                "Pseudocódigo ou código implementado sem erros lógicos.",
                                "Teste em exemplo concreto mostra parada correta.",
                                "Análise de erros comuns evitados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática dos critérios (30%).",
                                "Adequação da escolha de ε e N ao contexto (25%).",
                                "Clareza e completude do pseudocódigo (20%).",
                                "Evidências de testes e verificações (15%).",
                                "Integração com aplicações em engenharia civil (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Teoria de Erros.",
                                "Programação: Estruturas de controle e loops em Python/MATLAB.",
                                "Estatística: Medidas de precisão e intervalos de confiança.",
                                "Física/Engenharia: Modelagem de problemas não-lineares em estruturas."
                              ],
                              "realWorldApplication": "Na análise não-linear de estruturas civis, como cálculo de deformações em vigas sob grandes deslocamentos, os critérios de parada garantem soluções eficientes para equações de equilíbrio, evitando simulações infinitas em softwares como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Analisar taxa de convergência",
                            "description": "Explicar a ordem de convergência φ ≈ 1.618 (número de ouro) e estimar o erro |x_{n+1} - r| ≈ C |x_n - r|^φ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Convergência e Ordem",
                                  "subSteps": [
                                    "Revise a definição de convergência linear e superlinear.",
                                    "Estude a definição geral de ordem de convergência φ, onde |e_{n+1}| ≈ C |e_n|^φ.",
                                    "Identifique que para o Método da Posição Falsa, φ satisfaz φ(φ-1)=1, levando a φ ≈ 1.618.",
                                    "Compare com outros métodos: bissecção (φ=1), Newton (φ=2).",
                                    "Calcule numericamente φ resolvendo φ^2 - φ - 1 = 0."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que φ é o número de ouro e compare com outros métodos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, calculadora, tabela comparativa de métodos numéricos.",
                                  "tips": "Visualize graficamente a relação φ(φ-1)=1 para intuitar o valor.",
                                  "learningObjective": "Dominar a definição matemática de ordem de convergência e seu significado para o Método da Posição Falsa.",
                                  "commonMistakes": [
                                    "Confundir ordem φ com razão de convergência constante C.",
                                    "Ignorar que φ >1 implica superlinearidade.",
                                    "Usar aproximação φ=1.6 em vez de 1.618."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Ordem de Convergência φ para o Método da Posição Falsa",
                                  "subSteps": [
                                    "Lembre a iteração do método: x_{n+1} = (a_n f(b_n) - b_n f(a_n)) / (f(b_n) - f(a_n)).",
                                    "Assuma convergência para raiz r, com e_n = x_n - r.",
                                    "Desenvolva a análise assintótica assumindo f''(r) ≠ 0 e f'(r) ≠ 0.",
                                    "Derive a equação φ(φ-1)=1 a partir do limite |e_{n+1}| / |e_n|^φ → C.",
                                    "Resolva analiticamente φ = (1 + √5)/2 ≈ 1.618."
                                  ],
                                  "verification": "Reproduza a derivação em um quadro ou documento, confirmando φ ≈ 1.618.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de derivadas, software simbólico como SymPy ou Mathematica (opcional), notas de análise numérica.",
                                  "tips": "Use expansões de Taylor de segunda ordem para f(a_n) e f(b_n).",
                                  "learningObjective": "Derivar rigorosamente a ordem φ específica do Método da Posição Falsa.",
                                  "commonMistakes": [
                                    "Esquecer termos de ordem superior na expansão de Taylor.",
                                    "Assumir f'(r)=0 incorretamente.",
                                    "Confundir com derivação do Método da Secante (φ=1.618 também, mas diferente)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar e Analisar o Erro Usando a Fórmula Assintótica",
                                  "subSteps": [
                                    "Calcule erros sucessivos e_n = |x_n - r| para uma sequência de iterações.",
                                    "Estime C plotando log(|e_{n+1}|) vs log(|e_n|) para verificar inclinação φ ≈ 1.618.",
                                    "Aplique |x_{n+1} - r| ≈ C |x_n - r|^φ para prever erros futuros.",
                                    "Compare erro estimado com erro real em 5-10 iterações.",
                                    "Avalie sensibilidade a intervalos iniciais [a,b]."
                                  ],
                                  "verification": "Gere gráfico log-log mostrando reta com slope φ e compute erro relativo <5%.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python/MATLAB/Excel para plotagem, função de teste f(x)=x^3 - 2x -5.",
                                  "tips": "Use intervalos iniciais próximos da raiz para convergência rápida.",
                                  "learningObjective": "Aplicar a fórmula de erro para estimar e prever precisão numérica.",
                                  "commonMistakes": [
                                    "Usar log natural vs log10 inconsistente.",
                                    "Não normalizar erros próximos de zero.",
                                    "Ignorar que C depende de f''(r)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Aplicar em Contexto Prático",
                                  "subSteps": [
                                    "Analise como φ=1.618 afeta número de iterações vs bissecção.",
                                    "Teste com função não-linear de engenharia civil, ex: equilíbrio de viga.",
                                    "Discuta trade-offs: robustez vs velocidade de Newton.",
                                    "Registre tabela de erros e predições.",
                                    "Conclua quando usar análise de convergência em software."
                                  ],
                                  "verification": "Relatório curto (1 página) com análise, gráfico e conclusões.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software numérico, exemplo de equação civil (ex: f(x)=x^2 - k para carga).",
                                  "tips": "Automatize com script para múltiplos intervalos iniciais.",
                                  "learningObjective": "Interpretar taxa de convergência para decisões em problemas reais.",
                                  "commonMistakes": [
                                    "Superestimar convergência em funções patológicas.",
                                    "Não considerar custo computacional por iteração.",
                                    "Generalizar φ para todos os métodos bracketing."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva f(x) = x^3 - 2x^2 - 5x + 6 = 0 (modelo simplificado de deslocamento em viga) com [a,b]=[1,2]. Compute 10 iterações, estime φ via regressão log-log, prediga e_10 usando e_5 e verifique com raiz real ≈1.7918.",
                              "finalVerifications": [
                                "Explica corretamente φ ≈1.618 como solução de φ(φ-1)=1.",
                                "Deriva ou reproduz a análise assintótica do método.",
                                "Estima C e prediz erros com erro relativo <10%.",
                                "Gera gráfico log-log confirmando slope φ.",
                                "Compara com bissecção em exemplo numérico.",
                                "Identifica aplicação em problema de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de φ (100% correta).",
                                "Qualidade do gráfico log-log (R^2 >0.98).",
                                "Exatidão de predições de erro (<5% relativo).",
                                "Profundidade da interpretação prática.",
                                "Correção conceitual em comparações.",
                                "Clareza no relatório ou explicação oral."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equação característica φ^2 - φ -1=0 e número de ouro em sequências Fibonacci.",
                                "Computação: Implementação numérica e análise de complexidade O(n) vs superlinear.",
                                "Física: Modelos não-lineares em mecânica estrutural.",
                                "Estatística: Regressão linear para estimar φ e C."
                              ],
                              "realWorldApplication": "Em engenharia civil, analisar a taxa de convergência φ≈1.618 no Método da Posição Falsa otimiza solvers numéricos para equações não-lineares em análise de estruturas (ex: equilíbrio não-linear de cabos ou pórticos), reduzindo tempo de simulação em softwares como ANSYS ou SAP2000, garantindo precisão em predições de deformações sob cargas extremas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Aplicar a problemas de engenharia civil",
                            "description": "Resolver equações não-lineares como equilíbrio de vigas ou fluxo em tubulações, usando o método para encontrar raízes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema de engenharia civil como equação não-linear",
                                  "subSteps": [
                                    "Identificar o problema específico, como equilíbrio de vigas ou fluxo em tubulações.",
                                    "Derivar a função f(x) = 0 que modela o fenômeno físico.",
                                    "Definir o domínio físico da variável x (ex: diâmetro D > 0).",
                                    "Simplificar a equação mantendo a fidelidade ao modelo real.",
                                    "Documentar as unidades e constantes envolvidas."
                                  ],
                                  "verification": "Equação f(x) = 0 escrita corretamente e validada com valores conhecidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de engenharia civil",
                                    "Papel e calculadora",
                                    "Software como Python ou MATLAB"
                                  ],
                                  "tips": "Use diagramas esquemáticos do problema para visualizar a formulação.",
                                  "learningObjective": "Modelar problemas reais de engenharia em equações não-lineares acionáveis.",
                                  "commonMistakes": [
                                    "Omitir termos importantes do modelo físico",
                                    "Ignorar restrições de domínio físico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar intervalos iniciais [a, b] adequados",
                                  "subSteps": [
                                    "Avaliar o sinal de f(x) em pontos iniciais para localizar mudança de sinal.",
                                    "Escolher a e b tais que f(a) * f(b) < 0 e o intervalo seja razoável fisicamente.",
                                    "Plotar f(x) graficamente para confirmar a existência de raiz.",
                                    "Verificar unicidade da raiz no intervalo via análise da derivada.",
                                    "Ajustar intervalos se necessário para melhor convergência."
                                  ],
                                  "verification": "Confirmação de f(a) e f(b) com sinais opostos e gráfico mostrando raiz.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráfica ou software de plotagem (Python/MATLAB)",
                                    "Calculadora"
                                  ],
                                  "tips": "Comece com intervalos amplos e refine iterativamente.",
                                  "learningObjective": "Garantir condições de convergência do método da posição falsa.",
                                  "commonMistakes": [
                                    "Escolher intervalos sem mudança de sinal",
                                    "Intervalos muito amplos levando a lentidão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações do método da posição falsa",
                                  "subSteps": [
                                    "Calcular o ponto c = b - f(b)*(b-a)/(f(b)-f(a)).",
                                    "Avaliar f(c) e atualizar o intervalo: se f(a)*f(c) < 0, b = c; senão a = c.",
                                    "Repetir iterações até |b - a| < tolerância ou |f(c)| < epsilon.",
                                    "Registrar valores de a, b, c, f(c) e iterações em tabela.",
                                    "Implementar em código para automação se manual for impraticável."
                                  ],
                                  "verification": "Tabela de iterações completa com convergência observada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python ou MATLAB para implementação",
                                    "Planilha Excel para tabela manual"
                                  ],
                                  "tips": "Monitore o comportamento de convergência; pare se estagnar.",
                                  "learningObjective": "Aplicar corretamente o algoritmo do método da posição falsa.",
                                  "commonMistakes": [
                                    "Erro no cálculo de c (divisão por zero aproximada)",
                                    "Parada prematura sem critério"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar convergência, erro e interpretar resultados",
                                  "subSteps": [
                                    "Calcular erro absoluto |x_{n+1} - x_n| e relativo.",
                                    "Verificar se f(raiz) ≈ 0 e ordem de convergência.",
                                    "Interpretar a raiz no contexto físico (ex: validar unidades e viabilidade).",
                                    "Comparar com soluções analíticas ou experimentais se disponíveis.",
                                    "Documentar limitações e sugestões de melhoria."
                                  ],
                                  "verification": "Relatório com gráficos de erro e interpretação física da solução.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de plotagem",
                                    "Referências bibliográficas"
                                  ],
                                  "tips": "Use log do erro para visualizar convergência linear/superlinear.",
                                  "learningObjective": "Avaliar robustez da solução numérica em aplicações reais.",
                                  "commonMistakes": [
                                    "Ignorar erros de arredondamento",
                                    "Interpretação física incorreta"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolver f(D) = (8 f L Q²)/(π² g D⁵) - h_f = 0 para o diâmetro D de tubulação, com Q=0.1 m³/s, L=100m, h_f=5m, f=0.02, g=9.81 m/s². Intervalo inicial [0.05, 0.2] m. O método converge para D ≈ 0.12 m, validando dimensionamento hidráulico.",
                              "finalVerifications": [
                                "Raiz converge com |b-a| < 1e-6.",
                                "f(raiz) < 1e-8.",
                                "Solução fisicamente viável (ex: D positivo e realista).",
                                "Número de iterações < 20.",
                                "Erro relativo < 0.1%.",
                                "Gráfico de convergência mostra monotonicidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão da raiz (erro < 1e-6).",
                                "Correta formulação da equação não-linear.",
                                "Implementação fiel do método da posição falsa.",
                                "Análise completa de erro e convergência.",
                                "Interpretação contextual em engenharia civil.",
                                "Eficiência (poucas iterações)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Métodos Numéricos e Análise de Erros.",
                                "Física: Mecânica dos Fluidos e Estruturas.",
                                "Programação: Algoritmos em Python/MATLAB.",
                                "Engenharia Ambiental: Sistemas Hidráulicos."
                              ],
                              "realWorldApplication": "Dimensionamento de tubulações em redes de abastecimento de água e esgoto, análise de equilíbrio em vigas de pontes e edifícios, otimizando projetos para eficiência, segurança e redução de custos em obras civis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Método de Newton-Raphson",
                    "description": "Algoritmo iterativo que utiliza a derivada da função para aceleração quadrática na aproximação de raízes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Formulação Matemática do Método de Newton-Raphson",
                        "description": "Apresenta a base teórica do método, incluindo a derivação da fórmula iterativa que utiliza a derivada da função para aproximar raízes de equações não-lineares f(x) = 0.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Entender a aproximação linear local",
                            "description": "Compreender como o método usa a tangente à curva f(x) no ponto inicial x0 para estimar a raiz próxima, baseada na expansão de Taylor de primeira ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Conceitos Fundamentais de Funções e Derivadas",
                                  "subSteps": [
                                    "Defina uma função f(x) contínua e diferenciável.",
                                    "Explique o que representa a derivada f'(x) como taxa de variação instantânea.",
                                    "Identifique o ponto inicial x0 próximo à raiz de f(x) = 0.",
                                    "Discuta por que aproximações lineares são úteis para funções não-lineares localmente.",
                                    "Calcule f(x0) e f'(x0) para um exemplo simples como f(x) = x² - 2."
                                  ],
                                  "verification": "Responda corretamente a perguntas sobre definições e calcule valores para um exemplo dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora básica",
                                    "Gráfico de f(x) impresso ou digital"
                                  ],
                                  "tips": "Comece com funções simples como polinômios para construir intuição.",
                                  "learningObjective": "Compreender os pré-requisitos matemáticos para aproximações lineares.",
                                  "commonMistakes": [
                                    "Confundir derivada com a função original",
                                    "Esquecer que f'(x) é a inclinação da tangente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Expansão de Taylor de Primeira Ordem",
                                  "subSteps": [
                                    "Estude a fórmula da expansão de Taylor em torno de x0: f(x) ≈ f(x0) + f'(x0)(x - x0).",
                                    "Derive intuitivamente essa aproximação a partir da definição de derivada.",
                                    "Compare com a reta tangente y = f(x0) + f'(x0)(x - x0).",
                                    "Aplique a um exemplo numérico: expanda f(x) = sin(x) em x0 = 0.",
                                    "Verifique a precisão da aproximação para pontos próximos a x0."
                                  ],
                                  "verification": "Escreva a fórmula de Taylor e aplique-a corretamente a pelo menos dois exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de derivadas comuns",
                                    "Software de plotagem como Desmos ou GeoGebra",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Visualize a tangente tocando a curva apenas em x0; ela diverge rapidamente.",
                                  "learningObjective": "Dominar a base teórica da aproximação linear via Taylor.",
                                  "commonMistakes": [
                                    "Usar ordens superiores sem necessidade",
                                    "Ignorar o termo f(x0) na expansão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Aproximação Linear para Encontrar Raízes",
                                  "subSteps": [
                                    "Defina o problema: encontrar x1 tal que f(x1) ≈ 0 usando a tangente em x0.",
                                    "Resolva f(x0) + f'(x0)(x1 - x0) = 0 para x1 = x0 - f(x0)/f'(x0).",
                                    "Demonstre geometricamente: a interseção da tangente com o eixo x.",
                                    "Teste com f(x) = x³ - x - 2, x0 = 1.5.",
                                    "Compare x1 com o valor real da raiz."
                                  ],
                                  "verification": "Derive e aplique a iteração de Newton-Raphson manualmente para um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para cálculos",
                                    "Gráfico da função e tangente"
                                  ],
                                  "tips": "Garanta f'(x0) ≠ 0 para evitar divisão por zero.",
                                  "learningObjective": "Conectar a expansão de Taylor à fórmula iterativa do método.",
                                  "commonMistakes": [
                                    "Confundir o sinal na fórmula de iteração",
                                    "Não verificar se x0 está próximo da raiz"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Interpretar a Aproximação Geometricamente",
                                  "subSteps": [
                                    "Desenhe o gráfico de f(x), marque x0, f(x0), tangente e ponto x1.",
                                    "Explique por que a tangente fornece uma boa estimativa local.",
                                    "Discuta limitações: convergência quadrática perto da raiz, mas sensibilidade inicial.",
                                    "Simule duas iterações em software para observar melhoria.",
                                    "Analise o erro: |x1 - raiz| << |x0 - raiz|."
                                  ],
                                  "verification": "Crie um esboço gráfico rotulado e explique a convergência em palavras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de plotagem online (Desmos)",
                                    "Papel quadriculado",
                                    "Vídeo tutorial curto sobre Newton-Raphson"
                                  ],
                                  "tips": "Use cores diferentes para curva, tangente e eixo x no gráfico.",
                                  "learningObjective": "Internalizar a intuição geométrica da aproximação local.",
                                  "commonMistakes": [
                                    "Desenhar tangentes erradas",
                                    "Ignorar o comportamento global da função"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x² - 4 com raiz em x=2, inicie em x0=3. A tangente em x0 é y = 6(x-3) + 2. Interseção com y=0 dá x1=3 - 2/6 ≈ 2.666, mais próximo de 2 que 3.",
                              "finalVerifications": [
                                "Explicar verbalmente a origem da fórmula de Newton-Raphson via Taylor.",
                                "Derivar x_{n+1} = x_n - f(x_n)/f'(x_n) a partir da aproximação linear.",
                                "Plotar e interpretar um gráfico de exemplo com tangentes sucessivas.",
                                "Identificar quando a aproximação falha (ex: f'(x0)=0).",
                                "Calcular duas iterações manualmente para uma função não-linear.",
                                "Comparar precisão da aproximação linear vs. valor exato."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da expansão de Taylor (100% correto).",
                                "Clareza na explicação geométrica e intuitiva.",
                                "Correção nos cálculos numéricos de exemplos.",
                                "Identificação de pelo menos 3 limitações da aproximação.",
                                "Qualidade do gráfico: rótulos completos e escalas adequadas.",
                                "Conexão explícita com o método de Newton-Raphson."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Expansões de Taylor e derivadas.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física: Aproximações lineares em movimento harmônico.",
                                "Engenharia Computacional: Otimização e solvers de EDOs.",
                                "Estatística: Regressão linear local."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado no método de Newton-Raphson para resolver equações não-lineares em análise estrutural, como calcular deslocamentos em vigas sob cargas não-lineares ou tensões em solos elasto-plásticos, onde iterações rápidas convergem para soluções precisas em softwares como SAP2000."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Derivar a fórmula iterativa",
                            "description": "Derivar a expressão x_{n+1} = x_n - f(x_n)/f'(x_n) a partir da interseção da reta tangente com o eixo x.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito geométrico da reta tangente como aproximação linear",
                                  "subSteps": [
                                    "Revise a definição de reta tangente à curva y = f(x) no ponto x_n: ela representa a melhor aproximação linear local da função nesse ponto.",
                                    "Identifique que a tangente passa pelo ponto (x_n, f(x_n)) e tem inclinação f'(x_n).",
                                    "Visualize graficamente: desenhe a curva y = f(x), marque x_n, f(x_n) e a tangente tocando a curva.",
                                    "Entenda que a raiz da equação f(x) = 0 está próxima da interseção da tangente com o eixo x.",
                                    "Discuta por que isso melhora a aproximação linear em relação a métodos como bissecção."
                                  ],
                                  "verification": "Desenhe um gráfico simples mostrando a tangente e sua interseção com o eixo x, rotulando x_n e x_{n+1}.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Calculadora gráfica ou software como GeoGebra (opcional)"
                                  ],
                                  "tips": "Comece com funções simples como f(x) = x² para visualizar melhor a curvatura.",
                                  "learningObjective": "Compreender a interpretação geométrica da tangente como base para a iteração de Newton-Raphson.",
                                  "commonMistakes": [
                                    "Confundir tangente com secante.",
                                    "Ignorar a importância da derivada como inclinação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever a equação da reta tangente no ponto x_n",
                                  "subSteps": [
                                    "Lembre a forma ponto-inclinação da reta: y - y_1 = m (x - x_1), onde (x_1, y_1) = (x_n, f(x_n)) e m = f'(x_n).",
                                    "Substitua: y - f(x_n) = f'(x_n) (x - x_n).",
                                    "Expanda a equação: y = f'(x_n)(x - x_n) + f(x_n).",
                                    "Verifique com um exemplo numérico simples para confirmar.",
                                    "Anote a equação geral da tangente."
                                  ],
                                  "verification": "Escreva corretamente a equação da tangente para f(x) = x² - 2 em x_n = 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel",
                                    "Caneta",
                                    "Tabela de derivadas comuns"
                                  ],
                                  "tips": "Memorize a forma compacta y ≈ f(x_n) + f'(x_n)(x - x_n).",
                                  "learningObjective": "Formular matematicamente a aproximação linear da função no ponto de iteração atual.",
                                  "commonMistakes": [
                                    "Usar f(x_n) em vez de f'(x_n) como inclinação.",
                                    "Esquecer o sinal na expansão."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Encontrar a interseção da reta tangente com o eixo x",
                                  "subSteps": [
                                    "Defina y = 0 na equação da tangente para encontrar o ponto de interseção com o eixo x.",
                                    "Substitua y = 0: 0 - f(x_n) = f'(x_n) (x - x_n).",
                                    "Simplifique: -f(x_n) = f'(x_n) (x - x_n).",
                                    "Resolva para x: x = x_n - f(x_n)/f'(x_n).",
                                    "Rotule essa interseção como x_{n+1}, a próxima aproximação da raiz."
                                  ],
                                  "verification": "Calcule x_{n+1} para f(x) = x² - 2, x_n = 1, f'(x) = 2x, e verifique numericamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para cálculos algébricos"
                                  ],
                                  "tips": "Assuma f'(x_n) ≠ 0; discuta o que acontece se for zero.",
                                  "learningObjective": "Identificar geometricamente x_{n+1} como a projeção da tangente no eixo x.",
                                  "commonMistakes": [
                                    "Invertar o sinal ao isolar x.",
                                    "Dividir incorretamente por f'(x_n)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar e interpretar a fórmula iterativa do Método de Newton-Raphson",
                                  "subSteps": [
                                    "Escreva a fórmula final: x_{n+1} = x_n - f(x_n)/f'(x_n).",
                                    "Interprete: subtrai a razão entre o valor da função e sua derivada (correção newtoniana).",
                                    "Compare com iterações anteriores para ver convergência quadrática.",
                                    "Discuta condições de convergência (próximo da raiz, f' ≠ 0).",
                                    "Teste com 2-3 iterações em um exemplo para validar."
                                  ],
                                  "verification": "Derive a fórmula completa do zero e aplique em um exemplo até convergência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem como Desmos",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Use LaTeX ou notação clara para registrar a derivação final.",
                                  "learningObjective": "Consolidar a derivação e compreender sua eficiência iterativa.",
                                  "commonMistakes": [
                                    "Esquecer de assumir f contínua e diferenciável.",
                                    "Não testar numericamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere f(x) = x² - 2 (raiz ≈ √2 ≈ 1.414). Inicie com x_0 = 1. Calcule f(1) = -1, f'(1) = 2, então x_1 = 1 - (-1)/2 = 1.5. Próxima: f(1.5) ≈ 0.25, f'(1.5)=3, x_2 ≈ 1.4167. Converge rapidamente à raiz.",
                              "finalVerifications": [
                                "Pode desenhar e explicar graficamente a tangente e x_{n+1}.",
                                "Escreve corretamente a equação da tangente em qualquer f(x_n).",
                                "Deriva x_{n+1} = x_n - f(x_n)/f'(x_n) sem erros algébricos.",
                                "Aplica a fórmula em um exemplo numérico com 3 iterações.",
                                "Identifica quando o método pode falhar (f'=0).",
                                "Explica a convergência quadrática intuitivamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação (sem erros de sinal ou divisão).",
                                "Clareza na explicação geométrica e passos intermediários.",
                                "Uso correto de notação matemática (subscritos, LaTeX).",
                                "Capacidade de aplicar em exemplo prático com cálculos exatos.",
                                "Identificação de limitações e condições de uso.",
                                "Profundidade na interpretação (aproximação linear vs. global)."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Derivadas e linearização de Taylor.",
                                "Programação Computacional: Implementação em Python ou MATLAB para iterações.",
                                "Física/Engenharia: Aproximações em equilíbrio de estruturas (equações não-lineares).",
                                "Estatística: Otimização numérica em regressão não-linear.",
                                "Geometria Analítica: Equações de retas e interseções."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usado para resolver equações não-lineares em análise de estruturas (ex.: deformações em vigas sob cargas não-lineares), cálculo de perfis hidráulicos em canais ou otimização de seções transversais em fundações, onde iterações rápidas são essenciais para simulações computacionais em softwares como ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Aplicar em equação escalar simples",
                            "description": "Calcular manualmente duas iterações para uma função não-linear como f(x) = x^2 - 2, partindo de x0 = 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função não-linear, sua derivada e o chute inicial",
                                  "subSteps": [
                                    "Identifique a equação escalar: f(x) = x² - 2 = 0.",
                                    "Calcule a derivada: f'(x) = 2x.",
                                    "Escolha o chute inicial x₀ = 1.",
                                    "Escreva a fórmula do Método de Newton-Raphson: x_{n+1} = x_n - f(x_n)/f'(x_n).",
                                    "Verifique se f'(x₀) ≠ 0 para garantir validade."
                                  ],
                                  "verification": "Confirme que f(x), f'(x) e x₀ estão corretamente anotados em uma tabela ou papel.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel, lápis, calculadora básica",
                                  "tips": "Anote tudo em uma tabela com colunas para iteração, x_n, f(x_n), f'(x_n), correção e x_{n+1}.",
                                  "learningObjective": "Compreender os componentes fundamentais necessários para iniciar o método.",
                                  "commonMistakes": "Esquecer de zerar a equação (f(x)=0) ou calcular derivada errada (ex: derivada de x² é 2x, não 2x²)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a primeira iteração (calcular x₁)",
                                  "subSteps": [
                                    "Calcule f(x₀) = (1)² - 2 = -1.",
                                    "Calcule f'(x₀) = 2*(1) = 2.",
                                    "Compute a correção: f(x₀)/f'(x₀) = -1/2 = -0.5.",
                                    "Calcule x₁ = x₀ - correção = 1 - (-0.5) = 1.5.",
                                    "Registre o valor de x₁ na tabela."
                                  ],
                                  "verification": "Verifique se x₁ ≈ 1.5 comparando com cálculo manual repetido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel com tabela, calculadora",
                                  "tips": "Use parênteses em cálculos para evitar erros de ordem de operações.",
                                  "learningObjective": "Aplicar a fórmula do Newton-Raphson para uma iteração completa.",
                                  "commonMistakes": "Invertir o sinal na subtração da correção ou dividir incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a segunda iteração (calcular x₂)",
                                  "subSteps": [
                                    "Calcule f(x₁) = (1.5)² - 2 = 2.25 - 2 = 0.25.",
                                    "Calcule f'(x₁) = 2*(1.5) = 3.",
                                    "Compute a correção: f(x₁)/f'(x₁) = 0.25/3 ≈ 0.0833.",
                                    "Calcule x₂ = x₁ - correção = 1.5 - 0.0833 ≈ 1.4167.",
                                    "Registre x₂ na tabela e arredonde para 4 casas decimais se necessário."
                                  ],
                                  "verification": "Confirme x₂ ≈ 1.4167 testando f(x₂) ≈ 0 (deve ser muito pequeno).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel com tabela atualizada, calculadora",
                                  "tips": "Mantenha precisão com 4-5 casas decimais para evitar acúmulo de erros.",
                                  "learningObjective": "Reforçar a aplicação iterativa do método em uma segunda rodada.",
                                  "commonMistakes": "Usar x₀ em vez de x₁ para f e f', ou erro em multiplicação (1.5²=2.25)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e verificar convergência",
                                  "subSteps": [
                                    "Compare x₀=1, x₁=1.5, x₂≈1.4167 com o valor conhecido √2≈1.4142.",
                                    "Calcule |x₂ - x₁| para checar tolerância (≈0.0833).",
                                    "Avalie f(x₂)≈ (1.4167)² - 2 ≈ 0.007 (pequeno, indica convergência).",
                                    "Discuta se mais iterações seriam necessárias.",
                                    "Documente observações sobre comportamento do método."
                                  ],
                                  "verification": "Os valores convergem para ≈1.414 e f(x₂) < 0.01.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Tabela completa, calculadora",
                                  "tips": "Grafique mentalmente: o método converge quadraticamente perto da raiz.",
                                  "learningObjective": "Interpretar resultados e avaliar eficácia do método.",
                                  "commonMistakes": "Ignorar sinal de f(x) ou não checar derivada zero."
                                }
                              ],
                              "practicalExample": "Resolva x² - 2 = 0 manualmente com Newton-Raphson: x₀=1 → x₁=1.5 → x₂≈1.4167, aproximando √2 usado em cálculos de distâncias em projetos civis.",
                              "finalVerifications": [
                                "Tabela completa com x₀, x₁, x₂, f(x_n) e f'(x_n) corretos.",
                                "x₁ = 1.5 e x₂ ≈ 1.4167 (erro <1%).",
                                "|x₂ - x₁| < 0.1 indica convergência inicial.",
                                "f(x₂) ≈ 0.007 (resíduo pequeno).",
                                "f'(x_n) ≠ 0 em todas iterações.",
                                "Explicação oral da fórmula aplicada."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de f(x) e f'(x) (100% correto).",
                                "Aplicação correta da fórmula em ambas iterações.",
                                "Tabela organizada e verificações explícitas.",
                                "Análise de convergência com valores numéricos.",
                                "Identificação de erros potenciais evitados.",
                                "Tempo total dentro de 50 minutos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial (derivadas).",
                                "Programação: Implementar loop em Python para automação.",
                                "Física: Resolver equações de equilíbrio em vigas.",
                                "Estatística: Análise de erro e convergência."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usa-se Newton-Raphson para resolver equações não-lineares em análise estrutural, como deformações em cabos ou equilíbrio de fundações, onde iterações manuais ajudam a validar códigos computacionais antes de simulações em software como ANSYS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Algoritmo Iterativo e Implementação",
                        "description": "Descreve o pseudocódigo e os passos computacionais para implementar o método em linguagens de programação, incluindo cálculo numérico da derivada.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Escrever o pseudocódigo completo",
                            "description": "Construir o algoritmo com inicialização de x0, loop iterativo, cálculo de f(x_n) e f'(x_n), atualização e verificação de convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função, derivada e parâmetros iniciais",
                                  "subSteps": [
                                    "Escreva a definição da função f(x) e sua derivada f'(x) em pseudocódigo.",
                                    "Escolha e inicialize o chute inicial x0.",
                                    "Defina a tolerância de convergência (epsilon) e o número máximo de iterações (max_iter).",
                                    "Inicialize variáveis auxiliares como contador de iterações (n = 0).",
                                    "Documente os parâmetros com comentários explicativos."
                                  ],
                                  "verification": "Verifique se f(x), f'(x), x0, epsilon e max_iter estão declarados corretamente no início do pseudocódigo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou editor de texto simples; referência à fórmula do Método de Newton-Raphson.",
                                  "tips": "Use notação clara como 'f(x) ← expressão' para atribuições.",
                                  "learningObjective": "Entender e implementar a inicialização necessária para o algoritmo iterativo.",
                                  "commonMistakes": "Esquecer de definir f'(x) ou usar valor inadequado para x0 que cause divisão por zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar o loop iterativo principal",
                                  "subSteps": [
                                    "Inicie o loop com 'ENQUANTO' ou 'WHILE' baseado na condição de não convergência e iterações máximas.",
                                    "Incrementar o contador de iterações no início ou fim do loop.",
                                    "Adicione uma condição de saída para exceder max_iter.",
                                    "Use indentação para delimitar o corpo do loop claramente.",
                                    "Inclua comentário explicando o propósito do loop."
                                  ],
                                  "verification": "Confirme que o loop tem condições duplas: tolerância e max_iter, sem loop infinito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de pseudocódigo ou IDE com sintaxe destacada; fluxograma do algoritmo.",
                                  "tips": "Teste mentalmente com valores pequenos para garantir que o loop rode pelo menos uma vez.",
                                  "learningObjective": "Dominar a estrutura de controle de loop com múltiplas condições de parada.",
                                  "commonMistakes": "Colocar o incremento de iterações fora do loop ou usar '==' em vez de '<' para tolerância."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar cálculos de f(x_n), f'(x_n) e atualização",
                                  "subSteps": [
                                    "Calcule f(x_n) usando a função definida.",
                                    "Calcule f'(x_n) na iteração atual.",
                                    "Atualize x_{n+1} = x_n - f(x_n) / f'(x_n).",
                                    "Armazene ou atualize x_n para a próxima iteração.",
                                    "Adicione comentários inline para cada cálculo."
                                  ],
                                  "verification": "Simule uma iteração manualmente com números para validar a fórmula de atualização.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora ou software como Python para testar fórmulas; tabela de exemplo numérico.",
                                  "tips": "Sempre verifique se f'(x_n) ≠ 0 para evitar divisão por zero; adicione uma verificação opcional.",
                                  "learningObjective": "Aplicar corretamente a iteração core do Método de Newton-Raphson.",
                                  "commonMistakes": "Inverter a ordem de f e f' nos cálculos ou esquecer o sinal negativo na atualização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar verificação de convergência e saída",
                                  "subSteps": [
                                    "Dentro do loop, calcule o erro: |x_{n+1} - x_n| ou |f(x_{n+1})|.",
                                    "Adicione condição 'SE erro < epsilon, SAIR do loop'.",
                                    "Fora do loop, exiba o resultado final x aproximado, número de iterações e erro.",
                                    "Inclua tratamento para não convergência (ex: mensagem de erro após max_iter).",
                                    "Finalize com 'FIM' do algoritmo."
                                  ],
                                  "verification": "Execute pseudocódigo mentalmente até convergência e confira saídas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplo numérico resolvido manualmente; debugger mental ou ferramenta de simulação.",
                                  "tips": "Prefira critério duplo: delta_x e f(x) para robustez.",
                                  "learningObjective": "Implementar critérios precisos de parada e tratamento de resultados.",
                                  "commonMistakes": "Usar tolerância absoluta sem considerar escala da função ou omitir saída de resultados."
                                }
                              ],
                              "practicalExample": "Para f(x) = x³ - 2x - 5 = 0 (equação comum em análise estrutural para deslocamentos não-lineares), f'(x) = 3x² - 2, x0 = 2, epsilon = 0.001, max_iter = 50. O pseudocódigo deve iterar até |x_{n+1} - x_n| < 0.001, resultando em x ≈ 2.0946 após ~5 iterações.",
                              "finalVerifications": [
                                "Pseudocódigo inicializa x0, epsilon e max_iter corretamente.",
                                "Loop inclui cálculos de f(x_n), f'(x_n) e atualização x_{n+1}.",
                                "Condições de convergência (|Δx| < epsilon E |f(x)| < epsilon) estão presentes.",
                                "Saída inclui valor aproximado, iterações usadas e status de convergência.",
                                "Comentários explicam cada seção principal.",
                                "Não há loops infinitos ou divisões por zero não tratadas."
                              ],
                              "assessmentCriteria": [
                                "Presença de todos os elementos obrigatórios (inicialização, loop, cálculos, verificação).",
                                "Lógica iterativa correta conforme fórmula de Newton-Raphson.",
                                "Clareza e indentação adequadas no pseudocódigo.",
                                "Tratamento robusto de convergência e casos de falha.",
                                "Documentação completa com comentários acionáveis.",
                                "Simulação manual confirma convergência para exemplo padrão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial (derivadas) e análise numérica.",
                                "Programação: Estruturas de controle (loops, condicionais) e pseudocódigo.",
                                "Engenharia Civil: Solução de equações não-lineares em estruturas (ex: flambagem de colunas).",
                                "Física: Equilíbrios dinâmicos e estáticos não-lineares."
                              ],
                              "realWorldApplication": "No contexto da Engenharia Civil, o pseudocódigo do Método de Newton-Raphson é essencial para resolver equações não-lineares em análises estruturais, como calcular deslocamentos em vigas com grandes deformações, pontos de equilíbrio em cabos suspensos ou tensões em fundações sob cargas não-lineares, permitindo simulações precisas em softwares como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Implementar cálculo da derivada numérica",
                            "description": "Usar diferenças finitas forward ou central para aproximar f'(x) quando a derivada analítica não está disponível, com fórmula δf/δx ≈ [f(x+h) - f(x)]/h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de diferenças finitas forward e central",
                                  "subSteps": [
                                    "Estude a definição de derivada como limite de δf/δx quando δx → 0.",
                                    "Analise a fórmula forward: f'(x) ≈ [f(x+h) - f(x)] / h.",
                                    "Analise a fórmula central: f'(x) ≈ [f(x+h) - f(x-h)] / (2h).",
                                    "Discuta o erro de truncamento: O(h) para forward e O(h²) para central.",
                                    "Escolha um valor inicial para h, como 1e-6, considerando precisão numérica."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre forward e central, incluindo ordens de erro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de análise numérica (ex: livro Burden & Faires)",
                                    "Calculadora ou papel para exemplos manuais"
                                  ],
                                  "tips": "Visualize graficamente as diferenças finitas plotando f(x), f(x+h) e f(x-h).",
                                  "learningObjective": "Entender as bases matemáticas das aproximações numéricas de derivadas.",
                                  "commonMistakes": [
                                    "Confundir forward com central.",
                                    "Ignorar o impacto de h muito pequeno (erro de arredondamento)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função de derivada forward em Python",
                                  "subSteps": [
                                    "Defina uma função genérica def numerical_derivative_forward(f, x, h):",
                                    "Calcule f(x+h) e f(x), subtraia e divida por h.",
                                    "Retorne o resultado.",
                                    "Teste com f(x) = x**2 em x=2, h=0.001 (esperado ≈4).",
                                    "Adicione tratamento de erro para h=0."
                                  ],
                                  "verification": "Execute o código e verifique se para f(x)=sin(x) em x=0 retorna valor próximo a 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Editor de código (VS Code ou Jupyter Notebook)"
                                  ],
                                  "tips": "Use funções lambda para testar rapidamente diferentes f(x).",
                                  "learningObjective": "Codificar uma aproximação numérica básica de derivada.",
                                  "commonMistakes": [
                                    "Esquecer de importar math para funções como sin.",
                                    "Usar h fixo sem parâmetro ajustável."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a função de derivada central e compará-la",
                                  "subSteps": [
                                    "Crie def numerical_derivative_central(f, x, h): com [f(x+h) - f(x-h)] / (2*h).",
                                    "Compare resultados forward vs central para f(x)=exp(x) em x=1 (analítico=e≈2.718).",
                                    "Meça o erro absoluto em relação à derivada analítica.",
                                    "Teste com diferentes h (1e-3, 1e-6, 1e-9) e observe convergência.",
                                    "Crie uma função wrapper que escolha automaticamente forward ou central."
                                  ],
                                  "verification": "Plote erros vs h para ambas as métodos usando matplotlib.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com numpy e matplotlib",
                                    "Jupyter Notebook para visualizações"
                                  ],
                                  "tips": "Para h muito pequeno, use numpy.float64 para precisão.",
                                  "learningObjective": "Implementar e comparar métodos de maior precisão.",
                                  "commonMistakes": [
                                    "Dividir por 2*h incorretamente.",
                                    "Não capturar exceções em f(x-h) para funções não definidas em domínio negativo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e integrar no contexto de Newton-Raphson",
                                  "subSteps": [
                                    "Integre a derivada numérica em uma iteração de Newton-Raphson para resolver f(x)=0.",
                                    "Exemplo: Resolva x**3 - 2x - 5 = 0 com x0=2.",
                                    "Execute 10 iterações e verifique convergência.",
                                    "Analise sensibilidade ao h e ajuste ótimo.",
                                    "Documente o código com comentários e crie um relatório de precisão."
                                  ],
                                  "verification": "A solução converge para raiz conhecida (≈2.0946) com erro <1e-6.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python anterior",
                                    "Função Newton-Raphson base"
                                  ],
                                  "tips": "Use loops while com tolerância para parada automática.",
                                  "learningObjective": "Aplicar derivada numérica em algoritmo iterativo real.",
                                  "commonMistakes": [
                                    "Não atualizar x em cada iteração.",
                                    "Escolher h fixo sem otimização."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente a derivada numérica central para f(x) = cos(x) em x = π/4 (≈0.7854), com h=1e-5. Resultado esperado ≈ -0.7071. Compare com derivada analítica -sin(π/4) e calcule erro relativo. Integre em Newton-Raphson para encontrar raiz de cos(x) - x = 0.",
                              "finalVerifications": [
                                "O código forward e central produzem aproximações com erro <1e-4 para funções teste.",
                                "Gráficos de erro vs h mostram convergência esperada (linear para forward, quadrática para central).",
                                "Integração em Newton-Raphson converge em <20 iterações para exemplos padrão.",
                                "Código é modular, reutilizável e inclui tratamento de erros.",
                                "Relatório documenta escolhas de h e limitações numéricas.",
                                "Testes com múltiplas funções (polinômios, trigonométricas, exponenciais) passam."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro relativo <1e-5 em testes analíticos.",
                                "Eficiência: Tempo de execução <1s para 100 avaliações.",
                                "Robustez: Lida com h inválidos e funções não diferenciáveis.",
                                "Clareza: Código comentado e funções bem nomeadas.",
                                "Análise: Discussão de trade-offs entre forward/central e escolha de h.",
                                "Integração: Funciona seamless no loop de Newton-Raphson."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Erros de Aproximação.",
                                "Programação: Desenvolvimento de Funções e Debugging Numérico.",
                                "Engenharia Civil: Simulações em Mecânica dos Solos e Estruturas.",
                                "Física: Modelagem de Dinâmica onde derivadas analíticas são complexas.",
                                "Estatística: Sensibilidade a parâmetros numéricos."
                              ],
                              "realWorldApplication": "Em simulações de engenharia civil, como análise não-linear de estruturas em software como ANSYS ou SAP2000, onde derivadas de funções de carga ou rigidez não são analiticamente triviais, permitindo iterações rápidas no método de Newton-Raphson para equilíbrio estático."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Codificar em MATLAB ou Python",
                            "description": "Escrever uma função iterativa em MATLAB (usando while e tol=1e-6) ou Python (com numpy) para resolver f(x)=cos(x)-x=0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir as funções f(x) e sua derivada f'(x)",
                                  "subSteps": [
                                    "Analise a equação f(x) = cos(x) - x = 0 e compute f'(x) = -sin(x) - 1 manualmente",
                                    "Em Python com NumPy: defina def f(x): return np.cos(x) - x e def fprime(x): return -np.sin(x) - 1",
                                    "Em MATLAB: defina f = @(x) cos(x) - x e fprime = @(x) -sin(x) - 1",
                                    "Teste as funções com x=0: f(0) deve ser ~0.4597, f'(0) ~ -1",
                                    "Escolha um chute inicial x0, como 0 ou 1"
                                  ],
                                  "verification": "Execute f(0) e fprime(0); resultados devem coincidir com cálculos manuais",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com NumPy instalado ou MATLAB; calculadora para verificação manual",
                                  "tips": "Sempre use radianos para funções trigonométricas; importe numpy as np no Python",
                                  "learningObjective": "Traduzir expressões matemáticas analíticas em código executável",
                                  "commonMistakes": "Usar graus em vez de radianos; erro de sinal na derivada f'(x)"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar a função principal de Newton-Raphson",
                                  "subSteps": [
                                    "Crie uma função que receba x0, tol=1e-6, max_iter=100",
                                    "Em Python: def newton_raphson(x0, tol=1e-6, max_iter=100): ...",
                                    "Em MATLAB: function [root, iter] = newton_raphson(x0, tol, max_iter) ...",
                                    "Inicialize variáveis: iter=0, x = x0",
                                    "Retorne a raiz e número de iterações ao final"
                                  ],
                                  "verification": "Chame a função sem loop ainda; verifique se parâmetros são aceitos sem erro",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (Jupyter, Spyder para Python; MATLAB Editor)",
                                  "tips": "Use docstrings em Python ou comentários em MATLAB para documentar parâmetros",
                                  "learningObjective": "Construir funções modulares com parâmetros configuráveis",
                                  "commonMistakes": "Esquecer de definir tol e max_iter como opcionais; nomes de variáveis inconsistentes"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop iterativo com critério de parada",
                                  "subSteps": [
                                    "Inicie loop while iter < max_iter",
                                    "Calcule fx = f(x), fpx = fprime(x), delta = fx / fpx",
                                    "Atualize x_new = x - delta",
                                    "Verifique parada: if abs(x_new - x) < tol or abs(fx) < tol, break",
                                    "Atualize x = x_new, iter +=1",
                                    "Em Python/MATLAB: implemente exatamente assim no loop while"
                                  ],
                                  "verification": "Execute com poucas iterações manualmente; veja se x atualiza corretamente",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmos do step anterior; debugger ou print statements",
                                  "tips": "Adicione print/log de cada iteração para depuração: print(f'Iter {iter}: x={x}')",
                                  "learningObjective": "Implementar algoritmos iterativos com controle de convergência",
                                  "commonMistakes": "Divisão por zero se f'(x)=0 (raro aqui); loop infinito sem max_iter"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, validar e refinar a implementação",
                                  "subSteps": [
                                    "Chame a função: root = newton_raphson(0); verifique root ≈ 0.739085",
                                    "Teste com x0=1; deve convergir similarmente",
                                    "Adicione plot de convergência (opcional: vetor de xs vs iter)",
                                    "Compare com solução analítica conhecida ou scipy.optimize",
                                    "Adicione tratamento de erro: if iter==max_iter, avise não convergido"
                                  ],
                                  "verification": "Raiz final satisfaz |f(root)| < 1e-6 e <20 iterações",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Bibliotecas extras: matplotlib para plot (Python); built-in plot (MATLAB)",
                                  "tips": "Salve código em .py ou .m; rode em ambiente interativo para testes rápidos",
                                  "learningObjective": "Validar numericamente soluções computacionais contra expectativas",
                                  "commonMistakes": "Chute inicial ruim levando a divergência; não checar f(root) final"
                                }
                              ],
                              "practicalExample": "Para f(x)=cos(x)-x=0 com x0=0, tol=1e-6:\nPython: import numpy as np\ndef f(x): return np.cos(x)-x\ndef fprime(x): return -np.sin(x)-1\ndef newton_raphson(x0, tol=1e-6, max_iter=100):\n    x = x0; iter=0\n    while iter < max_iter:\n        fx = f(x); fpx = fprime(x)\n        if abs(fx) < tol: break\n        x = x - fx/fpx; iter +=1\n    return x, iter\nroot, it = newton_raphson(0)  # root ≈ 0.739085, it ≈ 5\nMATLAB similar com @(x) e while.",
                              "finalVerifications": [
                                "Código executa sem erros de sintaxe ou runtime",
                                "Converge para raiz ≈0.739085 com |f(root)| < 1e-6",
                                "Número de iterações < 20 para x0=0 ou 1",
                                "Funciona para ambos MATLAB e Python",
                                "Tratamento de max_iter evita loops infinitos",
                                "Delta final < tol confirma convergência"
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro na raiz < 1e-6",
                                "Eficiência: iterações mínimas (<10 ideal)",
                                "Legibilidade: código comentado e indentado",
                                "Robustez: lida com parâmetros default e erros",
                                "Modularidade: funções f/fprime separadas",
                                "Documentação: comentários explicam passos matemáticos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial e métodos numéricos",
                                "Programação: Estruturas de controle (loops, funções)",
                                "Engenharia: Modelagem computacional de problemas não-lineares",
                                "Física: Equações de equilíbrio em sistemas dinâmicos"
                              ],
                              "realWorldApplication": "Em Engenharia Civil, resolve equações não-lineares para calcular tensões em vigas com grandes deformações, vazão em redes hidráulicas com perdas não-lineares ou equilíbrio em fundações sob cargas complexas, permitindo simulações precisas sem soluções analíticas fechadas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Análise de Convergência e Aplicações",
                        "description": "Analisa a ordem de convergência quadrática, condições para sucesso e aplicações em problemas de engenharia civil como equilíbrio de estruturas não-lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Identificar critérios de parada",
                            "description": "Definir tolerância absoluta |x_{n+1}-x_n| < ε, relativa |f(x_n)| < ε ou máximo de iterações N_max=100.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Critérios de Parada em Métodos Iterativos",
                                  "subSteps": [
                                    "Defina convergência em métodos numéricos como o processo onde as aproximações x_n se aproximam da raiz exata.",
                                    "Explique por que critérios de parada são necessários: evitar loops infinitos e garantir precisão computacional.",
                                    "Diferencie parada prematura (subestima precisão) de iterações excessivas (custo computacional alto).",
                                    "Revise a fórmula geral do Método de Newton-Raphson: x_{n+1} = x_n - f(x_n)/f'(x_n).",
                                    "Discuta o papel dos critérios na análise de convergência quadrática do método."
                                  ],
                                  "verification": "Escreva uma definição clara dos critérios de parada e explique em 2-3 frases por que eles são essenciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notebook com exemplos de Newton-Raphson"
                                  ],
                                  "tips": "Use analogias como 'freio em um carro' para visualizar a parada do algoritmo.",
                                  "learningObjective": "Compreender o propósito fundamental dos critérios de parada em iterações numéricas.",
                                  "commonMistakes": [
                                    "Confundir convergência com estabilidade",
                                    "Ignorar o impacto no tempo de computação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar o Critério de Tolerância Absoluta",
                                  "subSteps": [
                                    "Defina o critério: |x_{n+1} - x_n| < ε, onde ε é uma tolerância pequena (ex: 1e-6).",
                                    "Calcule manualmente para 3 iterações de um exemplo simples, verificando a condição.",
                                    "Escolha valores apropriados de ε baseado na precisão desejada (máquina vs. aplicação).",
                                    "Implemente logicamente: se delta_x < ε, pare e retorne x_{n+1}.",
                                    "Teste com ε variando de 1e-3 a 1e-10 para observar número de iterações."
                                  ],
                                  "verification": "Resolva um problema manualmente e identifique a iteração onde |x_{n+1} - x_n| < 1e-6.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou Python para cálculos rápidos"
                                  ],
                                  "tips": "Sempre use ε consistente com a precisão dos dados de entrada na engenharia.",
                                  "learningObjective": "Aplicar e calcular o critério de tolerância absoluta corretamente.",
                                  "commonMistakes": [
                                    "Escolher ε muito pequeno levando a overflow",
                                    "Usar |x_n| em vez de diferença"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Critérios de Tolerância Relativa e Residual",
                                  "subSteps": [
                                    "Defina tolerância relativa: |x_{n+1} - x_n| / |x_n| < ε (útil para raízes grandes).",
                                    "Explique critério residual: |f(x_n)| < ε, medindo quão próximo f(x) é de zero.",
                                    "Compare os três critérios com um fluxograma: absoluta para pequenas raízes, relativa para grandes, residual para robustez.",
                                    "Implemente em pseudocódigo: if (|f(x_n)| < ε or |delta_x| < ε * |x_n|), pare.",
                                    "Analise vantagens: residual detecta platôs onde delta_x é pequeno mas f não é zero."
                                  ],
                                  "verification": "Para uma função dada, aplique ambos critérios e compare iterações necessárias.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software Python ou MATLAB",
                                    "Gráfico de f(x) para visualização"
                                  ],
                                  "tips": "Prefira residual para funções não-lineares em engenharia onde f' pode ser zero.",
                                  "learningObjective": "Diferenciar e selecionar critérios relativos/residuais adequadamente.",
                                  "commonMistakes": [
                                    "Dividir por zero em relativa se x_n ≈ 0",
                                    "Confundir |f(x_n)| com |x_n|"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar Máximo de Iterações e Implementação Completa",
                                  "subSteps": [
                                    "Defina N_max = 100 como salvaguarda contra divergência ou oscilação.",
                                    "Estruture o loop: inicialize contador i=0; while i < N_max and not criterios: itere; i +=1.",
                                    "Teste cenários: convergência rápida, lenta, divergência (ex: f'(x)=0).",
                                    "Registre saídas: x_final, iterações usadas, motivo de parada.",
                                    "Valide com exemplo: se N_max atingido, avise 'não convergiu'."
                                  ],
                                  "verification": "Escreva e execute pseudocódigo completo que para corretamente em todos cenários.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (Python/Jupyter)",
                                    "Funções de teste pré-definidas"
                                  ],
                                  "tips": "Comece N_max baixo (10) para depuração, aumente para produção.",
                                  "learningObjective": "Implementar critérios completos com proteção contra falhas.",
                                  "commonMistakes": [
                                    "Esquecer incrementar contador",
                                    "Não reportar motivo de parada"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva x^3 - 2x - 5 = 0 com Newton-Raphson, x0=2. Use ε=1e-6 absoluta/relativa/residual e N_max=100. Registre iterações até parada e verifique f(x_final) ≈ 0.",
                              "finalVerifications": [
                                "Implementa corretamente |x_{n+1}-x_n| < ε.",
                                "Aplica tolerância relativa sem divisão por zero.",
                                "Usa |f(x_n)| < ε como critério robusto.",
                                "Para em N_max=100 com mensagem de falha.",
                                "Compara resultados entre critérios para mesma função.",
                                "Valida precisão final com raiz conhecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de cada critério (90%+ correto).",
                                "Implementação funcional sem erros lógicos.",
                                "Seleção apropriada de ε baseado no contexto.",
                                "Análise de convergência com pelo menos 3 exemplos.",
                                "Relato claro do motivo e iterações de parada.",
                                "Tratamento de casos edge (divergência, x=0)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Loops while e condicionais em Python/MATLAB.",
                                "Análise Numérica: Teoria de erros e estabilidade.",
                                "Engenharia Computacional: Otimização em simulações FEM.",
                                "Estatística: Tolerâncias ligadas a intervalos de confiança."
                              ],
                              "realWorldApplication": "Em análises não-lineares de estruturas civis (ex: flambagem de pilares), critérios de parada garantem simulações eficientes em software como ANSYS, evitando desperdício computacional em projetos de pontes ou edifícios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.3"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Analisar ordem de convergência quadrática",
                            "description": "Explicar e verificar empiricamente que o erro e_{n+1} ≈ C e_n^2, demonstrando aceleração rápida perto da raiz.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a teoria da convergência quadrática no Método de Newton-Raphson",
                                  "subSteps": [
                                    "Relembrar a fórmula do Método de Newton-Raphson: x_{n+1} = x_n - f(x_n)/f'(x_n)",
                                    "Explicar o conceito de erro e_n = |x_n - α|, onde α é a raiz exata",
                                    "Derivar ou recordar que para convergência quadrática, e_{n+1} ≈ C e_n², com C = |f''(α)/(2 f'(α))|",
                                    "Discutir condições para convergência quadrática: f diferenciável duas vezes, f'(α) ≠ 0, chute inicial próximo da raiz",
                                    "Comparar com convergência linear (e_{n+1} ≈ K e_n, K<1)"
                                  ],
                                  "verification": "Escrever a relação e_{n+1} ≈ C e_n² e identificar C em termos de derivadas",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de métodos numéricos",
                                    "Notas de aula sobre Newton-Raphson"
                                  ],
                                  "tips": "Use um quadro ou papel para anotar as fórmulas chave; foque na intuição da aceleração perto da raiz",
                                  "learningObjective": "Compreender teoricamente por que o método exibe convergência quadrática",
                                  "commonMistakes": [
                                    "Confundir ordem 2 com linear; ignorar a necessidade de f'(α) ≠ 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e configurar um exemplo numérico apropriado",
                                  "subSteps": [
                                    "Escolher f(x) = x² - 2 (raiz α = √2 ≈ 1.414213562)",
                                    "Calcular f'(x) = 2x e f''(x) = 2 para verificar C = |2/(2*√2)| ≈ 0.353",
                                    "Definir chute inicial x_0 próximo da raiz, ex: x_0 = 1.5",
                                    "Decidir tolerância para parada, ex: 10^{-10}, e máximo de iterações",
                                    "Preparar tabela para registrar x_n, f(x_n), e_n (usando α exato)"
                                  ],
                                  "verification": "Confirmar que f'(α) ≠ 0 e estimar C teórico",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy para α exato"
                                  ],
                                  "tips": "Escolha funções simples mas representativas de problemas em engenharia civil, como equilíbrio não-linear",
                                  "learningObjective": "Preparar um caso de teste controlado para análise empírica",
                                  "commonMistakes": [
                                    "Chute inicial muito distante, causando divergência; usar raiz inexata para e_n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método e computar sequências de erros",
                                  "subSteps": [
                                    "Implementar Newton-Raphson em Python ou MATLAB: loop até convergência",
                                    "Registrar lista de x_n e calcular e_n = |x_n - α| a cada iteração",
                                    "Executar com x_0 = 1.5 e coletar pelo menos 10 iterações",
                                    "Calcular razões r_n = e_{n+1} / e_n² e verificar se r_n ≈ C constante",
                                    "Repetir com chute diferente (ex: x_0 = 1.2) para confirmar"
                                  ],
                                  "verification": "Gerar tabela com n, x_n, e_n, r_n mostrando r_n estabilizando em ~0.35",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy (código: def newton(f, df, x0, tol=1e-10, maxiter=20): ...)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use print ou pandas DataFrame para tabela clara; evite underflow com log(erros)",
                                  "learningObjective": "Verificar empiricamente a relação quadrática através de computação",
                                  "commonMistakes": [
                                    "Erro de arredondamento em e_n pequeno; não registrar erros absolutos corretos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e visualizar a convergência quadrática",
                                  "subSteps": [
                                    "Plotar log10(e_n) vs n: deve mostrar curvatura indicando aceleração",
                                    "Plotar log10(e_{n+1}) vs log10(e_n): reta com slope ≈ 2",
                                    "Calcular slope via regressão linear nos últimos pontos",
                                    "Comparar r_n com C teórico e discutir aceleração (erros caem de forma super-rápida)",
                                    "Testar com função diferente, ex: f(x)=cos(x)-x (raiz ~0.739), para generalizar"
                                  ],
                                  "verification": "Slope do gráfico log-log próximo de 2 (erro <5%)",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matplotlib/Seaborn para plots",
                                    "SciPy para regressão linear"
                                  ],
                                  "tips": "Use plt.loglog para escala log-log; foque em iterações finais onde aproximação é válida",
                                  "learningObjective": "Demonstrar visual e numericamente a ordem 2 e aceleração rápida",
                                  "commonMistakes": [
                                    "Plotar sem log, mascarando quadrática; incluir iterações iniciais no slope"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e tirar conclusões",
                                  "subSteps": [
                                    "Explicar por que convergência é lenta inicialmente mas explode perto da raiz",
                                    "Discutir limitações: sensibilidade a chute inicial, custo de f'",
                                    "Relacionar com aplicações: quando usar Newton vs bissecção",
                                    "Documentar relatório com tabelas, plots e afirmação 'confirmada convergência quadrática'",
                                    "Propor extensão: analisar ordem para métodos modificados"
                                  ],
                                  "verification": "Escrever parágrafo resumindo evidências empíricas e teóricas",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documento Word/LaTeX para relatório"
                                  ],
                                  "tips": "Enfatize 'empiricamente verificado' vs prova teórica",
                                  "learningObjective": "Sintetizar análise para comunicação clara",
                                  "commonMistakes": [
                                    "Ignorar que quadrática requer proximidade inicial; super-generalizar sem testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x² - 2, α=√2, x0=1.5: iterações mostram e1≈0.0858, e2≈0.00037 (e2≈0.35*e1²), e3≈4.8e-8, demonstrando erros caindo de quadrático para insignificante em 3 passos.",
                              "finalVerifications": [
                                "Explicar corretamente e_{n+1} ≈ C e_n² com C teórico",
                                "Gerar tabela com r_n convergindo para C",
                                "Plot log-log com slope ≈2",
                                "Identificar aceleração rápida após 2-3 iterações",
                                "Comparar com método linear para contraste",
                                "Relatório escrito confirmando análise empírica"
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação numérica (erros <1e-10)",
                                "Correta identificação de C teórico e empírico (erro <10%)",
                                "Qualidade dos gráficos: slope log-log entre 1.9-2.1",
                                "Explicação clara da aceleração quadrática",
                                "Tratamento de pelo menos 2 exemplos diferentes",
                                "Relatório estruturado com interpretação"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/MATLAB",
                                "Estatística: Regressão linear para slope de convergência",
                                "Física/Engenharia: Modelos não-lineares em estruturas civis (ex: equilíbrio de vigas)",
                                "Matemática: Análise assintótica e log-log plots",
                                "Ciência de Dados: Visualização de dados numéricos"
                              ],
                              "realWorldApplication": "Em engenharia civil, analisar convergência quadrática acelera solução de equações não-lineares em análise de estruturas (ex: deformações em cabos ou solos), reduzindo iterações computacionais de centenas para poucas perto da solução estável."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Aplicar em problema de engenharia civil",
                            "description": "Resolver numericamente uma equação não-linear de deformação em vigas, como f(δ) = P L^3 / (3 E I) - δ - k δ^3 = 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema físico e definir parâmetros",
                                  "subSteps": [
                                    "Identificar as variáveis da equação: P (carga), L (comprimento), E (módulo de elasticidade), I (momento de inércia), k (coeficiente não-linear), δ (deformação)",
                                    "Explicar o modelo: termo linear P L^3/(3 E I) representa deformação elástica pequena; termo -δ -k δ^3 modela não-linearidades geométricas ou materiais",
                                    "Selecionar valores realistas: ex. P=5000 N, L=3 m, E=2.1e11 Pa (aço), I=1e-4 m^4, k=1e6 N/m^3",
                                    "Definir critérios numéricos: tolerância ε=1e-6, iterações máximas=20, chute inicial δ₀=0.01 m",
                                    "Verificar consistência de unidades (SI)"
                                  ],
                                  "verification": "Lista de parâmetros documentada com valores e justificativa física; chute inicial plausível (δ₀ < L/100)",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Referências de mecânica dos materiais, calculadora, editor de texto",
                                  "tips": "Consulte tabelas de propriedades de vigas para valores realistas de I e E",
                                  "learningObjective": "Entender a origem física da equação não-linear de deformação em vigas",
                                  "commonMistakes": "Usar unidades inconsistentes (ex: misturar N e kgf); subestimar k levando a soluções irreais"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a função f(δ) e sua derivada f'(δ)",
                                  "subSteps": [
                                    "Escrever f(δ) = P L³/(3 E I) - δ - k δ³",
                                    "Calcular derivada analítica: f'(δ) = -1 - 3 k δ²",
                                    "Verificar derivada por diferenciação numérica ou software simbólico (opcional)",
                                    "Discutir condições: f'(δ) ≠ 0 para convergência local do Newton-Raphson",
                                    "Implementar funções em pseudocódigo ou Python: def f(delta): ...; def df(delta): ..."
                                  ],
                                  "verification": "Derivada correta confirmada por teste numérico: |f'(δ_num) - df(δ_num)| < 1e-3",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou Python/Jupyter Notebook com sympy",
                                  "tips": "Use sympy para derivada simbólica: sympy.diff(f, delta)",
                                  "learningObjective": "Dominar derivação analítica para métodos de Newton-Raphson",
                                  "commonMistakes": "Erro no sinal da derivada (esquecer negativo); confundir potência δ³ com δ² na derivada"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o algoritmo de Newton-Raphson",
                                  "subSteps": [
                                    "Inicializar: delta = delta0, iter=0, erro=inf",
                                    "Loop while erro > ε and iter < max_iter:",
                                    "Calcular f_val = f(delta), df_val = df(delta)",
                                    "Atualizar delta_new = delta - f_val / df_val",
                                    "erro = abs(delta_new - delta), delta = delta_new, iter +=1"
                                  ],
                                  "verification": "Código executável que roda sem erros e produz iterações",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com numpy (para precisão), Jupyter Notebook",
                                  "tips": "Adicione print de cada iteração para depuração: print(iter, delta, f_val)",
                                  "learningObjective": "Implementar corretamente o iterativo de Newton-Raphson",
                                  "commonMistakes": "Divisão por zero (f'≈0); não atualizar delta corretamente; loop infinito sem max_iter"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar, analisar convergência e validar resultados",
                                  "subSteps": [
                                    "Rodar o código com parâmetros definidos e registrar iterações",
                                    "Plotar gráfico de δ vs iteração e |f(δ)| vs iteração",
                                    "Verificar convergência: número de iterações <10, resíduo final <ε",
                                    "Comparar com solução linear aproximada: δ_lin = P L³/(3 E I)",
                                    "Interpretar: δ > δ_lin devido ao termo não-linear; plausibilidade física"
                                  ],
                                  "verification": "Gráficos mostram convergência quadrática; δ final físico (ex: <1% de L)",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com matplotlib para plots",
                                  "tips": "Use logscale no eixo y para erro para visualizar convergência quadrática",
                                  "learningObjective": "Analisar taxa de convergência e validar numericamente",
                                  "commonMistakes": "Ignorar divergência (δ cresce); não plotar para diagnóstico visual"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e discutir implicações em engenharia civil",
                                  "subSteps": [
                                    "Calcular tensão máxima σ = (M c)/I com M=P L/4, c=altura/2",
                                    "Avaliar segurança: σ < σ_admissível?",
                                    "Variar parâmetros (ex: aumentar P) e observar não-linearidades",
                                    "Discutir limitações: modelo 1D, pequenas rotações assumidas",
                                    "Relatar relatório: código, resultados, conclusões"
                                  ],
                                  "verification": "Relatório com interpretação física e sensibilidade de parâmetros",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto para relatório",
                                  "tips": "Use δ para estimar flecha em normas ABNT NBR 6120",
                                  "learningObjective": "Conectar solução numérica a projeto estrutural real",
                                  "commonMistakes": "Interpretar δ irreal como válida; ignorar contexto de grandes deformações"
                                }
                              ],
                              "practicalExample": "Viga simplesmente apoiada de L=3m, P=5000N central, E=2.1e11 Pa, I=1e-4 m^4, k=1e6 N/m^3. Chute δ₀=0.01m. Newton-Raphson converge em 5 iterações para δ≈0.015m (vs δ_lin≈0.0127m), mostrando aumento de 18% por não-linearidade.",
                              "finalVerifications": [
                                "Solução converge em ≤10 iterações com resíduo |f(δ)|<1e-6",
                                "Gráficos confirmam convergência quadrática (erro halves por iteração)",
                                "δ físico plausível: 0.1-1% de L e δ > solução linear",
                                "Código reproduzível sem erros",
                                "Análise de sensibilidade a ±20% em P ou k",
                                "Interpretação alinhada com mecânica (ex: tensão limite)"
                              ],
                              "assessmentCriteria": [
                                "Correção da implementação: f, f' e iteração exatas (teste unitário)",
                                "Análise de convergência: gráficos e taxa quantitativa",
                                "Validação física: comparação linear/não-linear e plausibilidade",
                                "Relatório claro com código comentado e conclusões",
                                "Tratamento de erros: detecção de divergência ou f'=0",
                                "Criatividade: extensão a 2D ou otimização de parâmetros"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial e métodos numéricos",
                                "Programação: Algoritmos iterativos em Python/NumPy",
                                "Física: Mecânica dos sólidos e não-linearidades geométricas",
                                "Engenharia de Software: Validação e testes unitários",
                                "Estatística: Análise de sensibilidade e Monte Carlo"
                              ],
                              "realWorldApplication": "Análise de flechas em vigas de pontes ou edifícios sob ventos/cargas sísmicas extremas, onde deformações grandes ativam não-linearidades, auxiliando no dimensionamento seguro conforme normas como ABNT NBR 6123 e prevenção de colapsos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.4",
                            "name": "Detectar falhas de convergência",
                            "description": "Identificar casos de divergência (chute inicial ruim, f'=0) e mitigar com hibridização ou bounds.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as causas comuns de falha de convergência no método de Newton-Raphson",
                                  "subSteps": [
                                    "Revisar a fórmula iterativa do método: x_{n+1} = x_n - f(x_n)/f'(x_n)",
                                    "Analisar impacto de chute inicial ruim: plotar função e trajetórias divergentes",
                                    "Estudar caso f'(x_n) ≈ 0: divisão por zero ou passos gigantes",
                                    "Identificar oscilações e convergência lenta como variantes de divergência",
                                    "Exemplificar com funções como f(x) = x^3 - 2x + 2"
                                  ],
                                  "verification": "Criar um diagrama resumindo 4 causas principais com exemplos gráficos",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de plotagem (Python/MATLAB)",
                                    "Folha de papel ou software de desenho",
                                    "Referência: livro de métodos numéricos"
                                  ],
                                  "tips": "Sempre plote a função e sua derivada para visualização intuitiva",
                                  "learningObjective": "Reconhecer conceitualmente e visualmente as falhas de convergência",
                                  "commonMistakes": "Ignorar o papel da derivada na estabilidade; confundir divergência com erro de precisão"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar critérios de detecção de falhas de convergência",
                                  "subSteps": [
                                    "Definir critérios: |x_{n+1} - x_n| > threshold_div, |f'(x_n)| < epsilon, n > max_iter",
                                    "Codificar loop de Newton-Raphson com flags de detecção (divergencia, zero_derivada)",
                                    "Adicionar logging para registrar valores de x_n, f(x_n), f'(x_n) em cada iteração",
                                    "Testar com chutes iniciais ruins e derivada zero",
                                    "Implementar parada segura para evitar loops infinitos"
                                  ],
                                  "verification": "Executar código em 3 cenários falhos e confirmar que flags são ativadas corretamente",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ambiente de programação (Python com NumPy ou MATLAB)",
                                    "Funções de teste pré-definidas"
                                  ],
                                  "tips": "Use tolerâncias adaptativas: epsilon = 1e-10 para derivada",
                                  "learningObjective": "Desenvolver código robusto capaz de detectar falhas em tempo real",
                                  "commonMistakes": "Definir thresholds fixos muito rígidos; não logar iterações para debug"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver estratégias de mitigação: hibridização e bounds",
                                  "subSteps": [
                                    "Implementar hibridização: se falha detectada, alternar com bissecção em intervalo [a,b]",
                                    "Aplicar bounds: restringir x_{n+1} a um intervalo viável baseado em análise da função",
                                    "Codificar fallback: se |f'(x_n)| < epsilon, usar passo de secante ou gradiente finito",
                                    "Testar hibridização em exemplo divergente: recuperar convergência",
                                    "Otimizar: escolher bounds iniciais via gráfico ou estimativa"
                                  ],
                                  "verification": "Comparar convergência original vs mitigada em 2 funções, medindo iterações necessárias",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código da etapa 2",
                                    "Documentação de métodos híbridos"
                                  ],
                                  "tips": "Inicie bounds com [x0 - delta, x0 + delta] onde delta = 2*|f(x0)/f'(x0)|",
                                  "learningObjective": "Aplicar técnicas corretivas para transformar algoritmos falhos em robustos",
                                  "commonMistakes": "Não validar bounds (podem excluir raiz); hibridizar sem checar monotonicidade"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e analisar a detecção e mitigação em aplicações",
                                  "subSteps": [
                                    "Executar testes completos com 5 funções não-lineares variadas",
                                    "Medir métricas: taxa de detecção, tempo de mitigação, precisão final",
                                    "Analisar relatórios de log para padrões de falha em engenharia civil",
                                    "Refinar código baseado em resultados: ajustar thresholds",
                                    "Documentar casos de sucesso e falha residual"
                                  ],
                                  "verification": "Gerar relatório com tabelas comparativas de performance antes/depois",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código completo das etapas anteriores",
                                    "Planilha para métricas (Excel/Google Sheets)"
                                  ],
                                  "tips": "Use asserts unitários para automação de validação",
                                  "learningObjective": "Avaliar eficácia de detecção e mitigação quantitativamente",
                                  "commonMistakes": "Testar apenas funções 'fáceis'; ignorar custo computacional da hibridização"
                                }
                              ],
                              "practicalExample": "Resolva f(x) = x^3 - 2x^2 + x - 1 = 0 (raiz ~0.7). Com x0=3 (chute ruim), Newton-Raphson diverge (x1≈4.5). Detecte |Δx|>1 ou n>20, aplique hibridização com bissecção em [0,2], convergindo em 8 iterações totais.",
                              "finalVerifications": [
                                "Algoritmo detecta e para em chutes iniciais ruins sem crash",
                                "Flag de f'(x_n)<1e-8 ativa fallback corretamente",
                                "Hibridização recupera pelo menos 80% dos casos divergentes",
                                "Solução final atende |f(x)|<1e-6 em <50 iterações",
                                "Logs registram todas falhas com causas claras",
                                "Bounds evitam saídas para valores irreais (ex: x>100)"
                              ],
                              "assessmentCriteria": [
                                "Taxa de detecção de falhas >95% em testes variados",
                                "Mitigação reduz iterações divergentes em >50%",
                                "Código é legível, com comentários e tratamento de exceções",
                                "Precisão da raiz final dentro de 1e-8",
                                "Análise inclui gráficos de convergência mitigada",
                                "Relatório demonstra aplicação em contexto de engenharia civil"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Tratamento de exceções e controle de fluxo robusto",
                                "Matemática: Teoremas de convergência (ex: contração de Banach)",
                                "Engenharia Civil: Modelos não-lineares em análise estrutural",
                                "Estatística: Análise de sensibilidade a parâmetros iniciais"
                              ],
                              "realWorldApplication": "Na engenharia civil, ao resolver equações não-lineares para deformações em vigas ou flambagem de colunas (ex: f(δ) = Pδ / (EI) + δ^3 / L^3 - Δ = 0), falhas de convergência podem invalidar dimensionamentos; detecção e hibridização garantem soluções confiáveis para projetos seguros contra colapsos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Método da Secante",
                    "description": "Variante do Newton-Raphson que aproxima a derivada por diferenças finitas, sem necessidade de derivadas analíticas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Definição e Fórmula Iterativa do Método da Secante",
                        "description": "Introdução ao método da secante como variante do Newton-Raphson, utilizando uma aproximação da derivada por diferenças finitas divididas, eliminando a necessidade de derivadas analíticas explícitas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Compreender a motivação e as diferenças em relação ao método de Newton-Raphson",
                            "description": "Explicar por que o método da secante é útil em problemas de engenharia civil onde a derivada analítica da função não linear f(x) = 0 não é facilmente obtível, destacando a aproximação f'(x_i) ≈ [f(x_{i+1}) - f(x_i)] / (x_{i+1} - x_i).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Newton-Raphson",
                                  "subSteps": [
                                    "Estude a fórmula iterativa do Newton-Raphson: x_{i+1} = x_i - f(x_i)/f'(x_i).",
                                    "Identifique que requer derivada analítica f'(x).",
                                    "Discuta cenários onde f'(x) é conhecida e fácil de computar.",
                                    "Examine vantagens: convergência quadrática rápida.",
                                    "Liste pré-requisitos: função diferenciável e f'(x_i) ≠ 0."
                                  ],
                                  "verification": "Resuma em 3 frases as características principais do método, incluindo dependência da derivada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Referência ao livro de métodos numéricos (ex: Burden & Faires)"
                                  ],
                                  "tips": "Desenhe o gráfico de uma função não-linear para visualizar iterações.",
                                  "learningObjective": "Compreender os fundamentos e requisitos do método de Newton-Raphson.",
                                  "commonMistakes": [
                                    "Confundir com métodos de primeira ordem",
                                    "Ignorar necessidade de derivada exata"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Limitações do Newton-Raphson em Engenharia Civil",
                                  "subSteps": [
                                    "Analise equações não-lineares comuns em engenharia civil, como equilíbrio de cabos ou deformações plásticas.",
                                    "Liste casos onde f(x) é complexa (ex: funções implícitas ou experimentais).",
                                    "Discuta dificuldades em obter f'(x) analiticamente: expressões complicadas ou dados empíricos.",
                                    "Calcule tempo/custo de derivadas simbólicas em software como MATLAB.",
                                    "Avalie impactos: lentidão ou impossibilidade em problemas reais."
                                  ],
                                  "verification": "Cite 2 exemplos de problemas civis onde derivada é difícil e explique por quê.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de problemas de engenharia civil (ex: equação de catenária)",
                                    "Calculadora ou Python para testes rápidos"
                                  ],
                                  "tips": "Pense em funções piecewise ou com experimentos de campo.",
                                  "learningObjective": "Reconhecer contextos práticos onde Newton-Raphson falha.",
                                  "commonMistakes": [
                                    "Subestimar complexidade de derivadas reais",
                                    "Ignorar dados numéricos em vez de analíticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Motivação e Fórmula do Método da Secante",
                                  "subSteps": [
                                    "Apresente a fórmula: x_{i+1} = x_i - f(x_i) * (x_i - x_{i-1}) / (f(x_i) - f(x_{i-1})).",
                                    "Explique aproximação numérica: f'(x_i) ≈ [f(x_i) - f(x_{i-1})] / (x_i - x_{i-1}).",
                                    "Compare com Newton: sem derivada analítica, usa apenas avaliações de f.",
                                    "Discuta convergência: superlinear (ordem ~1.618), ainda rápida.",
                                    "Liste requisitos: duas aproximações iniciais x_0 e x_1 próximas da raiz."
                                  ],
                                  "verification": "Derive a fórmula da secante a partir da aproximação da derivada em 1 parágrafo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para derivação",
                                    "Software como Excel para simular avaliações de f"
                                  ],
                                  "tips": "Visualize a reta secante no gráfico da função.",
                                  "learningObjective": "Entender como a secante evita derivadas analíticas.",
                                  "commonMistakes": [
                                    "Confundir com método da falsa posição",
                                    "Esquecer necessidade de dois pontos iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Diferenças e Vantagens em Contextos de Engenharia",
                                  "subSteps": [
                                    "Tabela comparativa: derivada (analítica vs numérica), convergência, custo computacional.",
                                    "Simule iterações lado a lado para f(x) = x^3 - 2x - 5.",
                                    "Avalie em engenharia civil: secante útil para funções black-box ou experimentais.",
                                    "Discuta desvantagens da secante: convergência mais lenta, sensível a iniciais.",
                                    "Conclua quando escolher cada método."
                                  ],
                                  "verification": "Crie uma tabela de prós/contras e aplique a um exemplo civil.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python script para iterações",
                                    "Exemplo de problema não-linear civil"
                                  ],
                                  "tips": "Use tolerância pequena para comparar número de iterações.",
                                  "learningObjective": "Diferenciar claramente os métodos e justificar uso da secante.",
                                  "commonMistakes": [
                                    "Achar secante sempre superior",
                                    "Não considerar precisão inicial"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de uma treliça não-linear sob carga, resolva f(x) = k*x^3 + m*sin(x) - P = 0 para deformação x, onde k e m são empíricos. Newton requer derivada complexa; secante usa apenas f em pontos vizinhos, simulável em Excel com 5 iterações para precisão de 10^-4.",
                              "finalVerifications": [
                                "Explique verbalmente a aproximação da derivada na secante.",
                                "Identifique 3 cenários civis onde secante é preferível.",
                                "Compare número de avaliações de f: Newton vs Secante em exemplo.",
                                "Descreva gráfico da secante vs tangente de Newton.",
                                "Justifique convergência da secante sem derivada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula da secante (80% correto).",
                                "Identificação correta de limitações do Newton-Raphson (pelo menos 2 exemplos reais).",
                                "Comparação quantitativa de convergência (ex: iterações/tolerância).",
                                "Aplicação contextual a engenharia civil com justificativa.",
                                "Ausência de confusões entre métodos (verificação em simulação).",
                                "Clareza em explicações verbais ou escritas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Análise de erro e ordem de convergência.",
                                "Programação: Implementação em Python/MATLAB para métodos iterativos.",
                                "Física Aplicada: Modelagem de estruturas não-lineares em mecânica.",
                                "Estatística: Uso de dados experimentais para funções black-box."
                              ],
                              "realWorldApplication": "Na engenharia civil, o método da secante é aplicado em software como SAP2000 para resolver equilíbrios não-lineares em pontes ou edifícios sob ventos fortes, onde funções de rigidez derivam de testes de laboratório sem formas analíticas fechadas, economizando tempo de modelagem."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Derivar a fórmula iterativa da secante",
                            "description": "Obter e memorizar a fórmula x_{i+1} = x_i - f(x_i) * (x_i - x_{i-1}) / [f(x_i) - f(x_{i-1})], aplicando-a manualmente a uma equação não linear simples como f(x) = x^2 - 2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais do Método da Secante",
                                  "subSteps": [
                                    "Revise o problema de encontrar raízes de f(x) = 0 usando aproximações iterativas.",
                                    "Identifique a necessidade de dois pontos iniciais x_{i-1} e x_i, ao contrário do método de Newton que usa derivada.",
                                    "Visualize geometricamente: a reta secante entre (x_{i-1}, f(x_{i-1})) e (x_i, f(x_i)) intersecta o eixo x na próxima aproximação x_{i+1}.",
                                    "Compare brevemente com o método da bissecção para destacar a eficiência quadrática.",
                                    "Anote os pressupostos: f contínua e f(x_{i-1}) * f(x_i) < 0 opcionalmente para convergência."
                                  ],
                                  "verification": "Desenhe um gráfico simples mostrando pontos, reta secante e interseção com eixo x.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora gráfica ou software como Desmos para plotar f(x)"
                                  ],
                                  "tips": "Sempre comece visualizando a função para intuitar a convergência.",
                                  "learningObjective": "Entender a motivação geométrica e os requisitos iniciais do método da secante.",
                                  "commonMistakes": [
                                    "Confundir secante com tangente (método de Newton)",
                                    "Esquecer a necessidade de dois pontos iniciais",
                                    "Ignorar sinais opostos das funções para garantir raiz entre pontos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Equação da Reta Secante",
                                  "subSteps": [
                                    "Calcule a inclinação m da reta secante: m = [f(x_i) - f(x_{i-1})] / (x_i - x_{i-1}).",
                                    "Escreva a equação da reta ponto-inclinação usando o ponto (x_i, f(x_i)): y - f(x_i) = m (x - x_i).",
                                    "Alternativamente, use o ponto (x_{i-1}, f(x_{i-1})) para verificação cruzada.",
                                    "Substitua valores simbólicos para manter generalidade.",
                                    "Simplifique a expressão para y = m(x - x_i) + f(x_i)."
                                  ],
                                  "verification": "Escreva a equação da reta corretamente para pontos genéricos e verifique com números simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Lápis e borracha"
                                  ],
                                  "tips": "Mantenha os símbolos consistentes: use subscritos i-1 e i claramente.",
                                  "learningObjective": "Derivar a equação linear que aproxima f(x) localmente via secante.",
                                  "commonMistakes": [
                                    "Invertar numerador e denominador na inclinação",
                                    "Usar derivada analítica em vez de finita",
                                    "Confundir ordem dos pontos na subtração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Encontrar a Interseção da Secante com o Eixo X",
                                  "subSteps": [
                                    "Defina y = 0 na equação da reta: 0 - f(x_i) = m (x_{i+1} - x_i).",
                                    "Resolva para x_{i+1}: x_{i+1} = x_i - f(x_i) / m.",
                                    "Substitua m: x_{i+1} = x_i - f(x_i) / ([f(x_i) - f(x_{i-1})] / (x_i - x_{i-1})).",
                                    "Simplifique a divisão por fração: x_{i+1} = x_i - f(x_i) * (x_i - x_{i-1}) / [f(x_i) - f(x_{i-1})].",
                                    "Verifique algebraicamente que é equivalente à forma usando x_{i-1}."
                                  ],
                                  "verification": "Derive a fórmula completa x_{i+1} = x_i - f(x_i) * (x_i - x_{i-1}) / [f(x_i) - f(x_{i-1})] sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para álgebra simbólica",
                                    "Exemplo numérico simples para teste"
                                  ],
                                  "tips": "Faça a simplificação devagar, multiplicando numerador e denominador por (x_i - x_{i-1}).",
                                  "learningObjective": "Obter a fórmula iterativa resolvendo geometricamente para a raiz aproximada.",
                                  "commonMistakes": [
                                    "Erros de sinal ao subtrair f(x_i)",
                                    "Dividir incorretamente pela fração de m",
                                    "Esquecer parênteses em f(x_i) - f(x_{i-1})"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Memorizar e Aplicar a Fórmula a um Exemplo Prático",
                                  "subSteps": [
                                    "Recite a fórmula de memória 5 vezes: x_{i+1} = x_i - f(x_i) * (x_i - x_{i-1}) / [f(x_i) - f(x_{i-1})].",
                                    "Para f(x) = x² - 2, escolha x_0 = 1, x_1 = 2; compute f(1)= -1, f(2)=2.",
                                    "Calcule x_2 = 2 - 2*(2-1)/(2 - (-1)) = 2 - 2*1/3 ≈ 1.333.",
                                    "Continue para x_3 usando x_1=2, x_2≈1.333, e verifique convergência para √2 ≈1.414.",
                                    "Registre 3 iterações em tabela para visualizar."
                                  ],
                                  "verification": "Aplique corretamente 3 iterações e obtenha aproximações convergindo para √2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela impressa para iterações"
                                  ],
                                  "tips": "Use aproximação √2 conhecida para validar convergência rápida.",
                                  "learningObjective": "Memorizar a fórmula e demonstrar aplicação manual precisa.",
                                  "commonMistakes": [
                                    "Erro aritmético em cálculos manuais",
                                    "Confundir índices i e i-1 nas iterações",
                                    "Não normalizar diferenças para evitar divisão por zero"
                                  ]
                                }
                              ],
                              "practicalExample": "Para encontrar a raiz positiva de f(x) = x² - 2 = 0 (aprox. √2), inicie com x_0 = 1, x_1 = 2. Compute: f(1) = -1, f(2) = 2. Então x_2 = 2 - 2*(2-1)/(2-(-1)) = 2 - 2/3 ≈ 1.333. Próxima: f(1.333)≈0.777, x_3 ≈1.414 (próximo de √2).",
                              "finalVerifications": [
                                "Recitar a fórmula iterativa sem erros.",
                                "Derivar a fórmula do zero em menos de 5 minutos.",
                                "Aplicar manualmente 3 iterações a f(x)=x²-2 com precisão de 3 casas decimais.",
                                "Explicar geometricamente por que converge.",
                                "Identificar quando o método falha (ex: divisão por zero).",
                                "Comparar com método de Newton para mesma função."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica (sem erros de sinal ou simplificação).",
                                "Compreensão conceitual demonstrada em diagrama geométrico.",
                                "Aplicação numérica correta com tabela de iterações convergentes.",
                                "Memorização e recitação fluida da fórmula.",
                                "Identificação de pelo menos 2 erros comuns e como evitá-los.",
                                "Explicação de condições de convergência."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python ou MATLAB para automação.",
                                "Engenharia Civil: Resolver equações não-lineares em análise de estruturas (ex: equilíbrio de cabos).",
                                "Física: Modelagem de oscilações não-lineares ou fluxos.",
                                "Estatística: Otimização em regressão não-linear."
                              ],
                              "realWorldApplication": "Em engenharia civil, o método da secante resolve equações não-lineares surgidas na análise de deformações em vigas curvas, cálculo de perfis de cabos suspensos ou otimização de seções transversais em fundações, onde derivadas analíticas são difíceis de obter."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Aplicar iterações manuais iniciais",
                            "description": "Executar 3-5 iterações manuais do método da secante para resolver uma equação não linear relevante à engenharia civil, como equilíbrio de forças em estruturas, usando valores iniciais x_0 e x_1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a equação não linear e valores iniciais",
                                  "subSteps": [
                                    "Identifique uma equação não linear relevante à engenharia civil, como f(x) = x³ - 2x² - 5x + 6 = 0, representando equilíbrio de forças em uma treliça.",
                                    "Escolha valores iniciais x₀ e x₁ próximos da raiz estimada, baseados em análise gráfica ou chute inicial (ex: x₀ = 1, x₁ = 2).",
                                    "Calcule f(x₀) e f(x₁) usando uma calculadora.",
                                    "Monte uma tabela com colunas: iteração, x_{n-1}, x_n, f(x_{n-1}), f(x_n), x_{n+1}.",
                                    "Verifique se f(x₀) e f(x₁) têm sinais opostos ou estão próximos para garantir convergência."
                                  ],
                                  "verification": "Tabela inicial preenchida com x₀, x₁, f(x₀) e f(x₁) corretos, sem erros aritméticos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora científica, software de planilha opcional para tabela.",
                                  "tips": "Use uma estimativa gráfica rápida plotando f(x) em papel para escolher x₀ e x₁ eficazes.",
                                  "learningObjective": "Compreender a importância da escolha de valores iniciais para a convergência do método da secante.",
                                  "commonMistakes": "Escolher x₀ e x₁ muito distantes da raiz, levando a convergência lenta; ignorar cálculo preciso de f(x)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a primeira iteração (calcular x₂)",
                                  "subSteps": [
                                    "Aplique a fórmula da secante: x₂ = x₁ - f(x₁) * (x₁ - x₀) / (f(x₁) - f(x₀)).",
                                    "Calcule o numerador f(x₁) * (x₁ - x₀) com precisão decimal.",
                                    "Calcule o denominador f(x₁) - f(x₀), verificando se não é zero.",
                                    "Divida e subtraia do x₁ para obter x₂, registrando na tabela.",
                                    "Calcule f(x₂) para preparar a próxima iteração."
                                  ],
                                  "verification": "x₂ calculado corretamente com pelo menos 4 casas decimais, e f(x₂) computado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora com funções trigonométricas/exponenciais, tabela da Step 1.",
                                  "tips": "Mantenha pelo menos 5 casas decimais em cálculos intermediários para evitar erros de arredondamento.",
                                  "learningObjective": "Dominar o cálculo da primeira iteração da fórmula da secante manualmente.",
                                  "commonMistakes": "Confundir a ordem de x₀ e x₁ na fórmula; divisão por zero se f(x₁) ≈ f(x₀)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações subsequentes (calcular x₃, x₄ e x₅)",
                                  "subSteps": [
                                    "Para x₃: Use x₂ e x₁ como novos x_n e x_{n-1}, aplique fórmula: x₃ = x₂ - f(x₂)(x₂ - x₁)/(f(x₂) - f(x₁)).",
                                    "Registre na tabela e calcule f(x₃).",
                                    "Repita para x₄ usando x₃ e x₂.",
                                    "Repita para x₅ usando x₄ e x₃, parando se |x_{n+1} - x_n| < 0.001.",
                                    "Observe a redução no erro entre iterações consecutivas."
                                  ],
                                  "verification": "Tabela completa com x₂ a x₅, f(x) correspondentes e erros decrescentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora, tabela atualizada.",
                                  "tips": "Atualize a tabela iterativamente para visualizar a convergência em tempo real.",
                                  "learningObjective": "Executar múltiplas iterações manuais e observar o comportamento de convergência quadrática.",
                                  "commonMistakes": "Perder a rastreabilidade dos índices (x_{n-1} vs x_n); arredondamentos prematuros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar convergência e validar a solução",
                                  "subSteps": [
                                    "Calcule o erro absoluto |x_{n+1} - x_n| para as últimas iterações.",
                                    "Verifique critério de parada: erro < 10^{-4} ou máximo de 5 iterações.",
                                    "Compare a raiz aproximada com valor conhecido ou método alternativo (ex: bissecção).",
                                    "Interprete o resultado no contexto da engenharia civil (ex: deformação máxima na estrutura).",
                                    "Documente observações sobre precisão e número de iterações."
                                  ],
                                  "verification": "Relatório curto com raiz final, erro e interpretação contextual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela final, calculadora, referência de raiz exata se disponível.",
                                  "tips": "Plote os pontos x_n vs n em gráfico simples para visualizar convergência.",
                                  "learningObjective": "Avaliar a eficácia do método da secante e critérios de parada em problemas reais.",
                                  "commonMistakes": "Ignorar falta de convergência; não contextualizar a solução."
                                }
                              ],
                              "practicalExample": "Resolva f(x) = x³ - 2x² - 5x + 6 = 0 (equilíbrio de forças em treliça: x = deformação em cm). x₀=1, f(1)=-0; x₁=2, f(2)=0. Calcule: x₂ ≈ 1.5 (detalhes em tabela). Após 4 iterações, x₅ ≈ 1.231, erro < 0.001, deformação estável na estrutura.",
                              "finalVerifications": [
                                "Tabela de iterações completa com 3-5 passos e cálculos precisos.",
                                "Erro entre iterações finais < 0.001.",
                                "Raiz aproximada consistente com sinal de f(x) mudando.",
                                "Interpretação correta no contexto de engenharia civil.",
                                "Nenhum erro aritmético em f(x) ou fórmula da secante.",
                                "Critério de parada explicitamente verificado."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos manuais (erro < 0.01 nos valores finais).",
                                "Correta aplicação da fórmula da secante em todas as iterações.",
                                "Escolha adequada de x₀ e x₁ levando a convergência rápida.",
                                "Análise de erros e convergência documentada.",
                                "Conexão clara com aplicação em engenharia civil.",
                                "Tabela organizada e completa."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar o algoritmo em Python ou MATLAB para automação.",
                                "Cálculo Numérico: Comparar com métodos como Newton-Raphson.",
                                "Estatística: Análise de erro de truncamento e arredondamento.",
                                "Física: Modelagem de equações não lineares em mecânica estrutural."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para calcular deformações não lineares em vigas sob grandes cargas, otimizando projetos de pontes e edifícios para evitar colapsos, integrando com software como ANSYS para validação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Algoritmo e Implementação Computacional",
                        "description": "Desenvolvimento do pseudocódigo e implementação prática em software numérico, considerando critérios de parada e tratamento de casos degenerados.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Escrever o pseudocódigo completo do algoritmo",
                            "description": "Construir o fluxograma e pseudocódigo incluindo inicialização de x0 e x1, loop iterativo até tolerância ε (ex: 10^-6) ou máximo de iterações, verificando se |x_{i+1} - x_i| < ε ou |f(x_{i+1})| < ε.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função f(x), parâmetros de entrada e critérios de convergência",
                                  "subSteps": [
                                    "Escreva a definição da função f(x) em pseudocódigo, usando uma equação não-linear exemplo como f(x) = x^3 - 2x + 1.",
                                    "Defina os parâmetros iniciais: x0 (chute inicial), x1 (segundo chute), ε (tolerância, ex: 10^-6), max_iter (máximo de iterações, ex: 100).",
                                    "Especifique os critérios de parada: |x_{i+1} - x_i| < ε OU |f(x_{i+1})| < ε.",
                                    "Inclua um contador de iterações i = 0.",
                                    "Anote comentários explicando cada parâmetro."
                                  ],
                                  "verification": "Verifique se todos os parâmetros estão declarados com valores iniciais e critérios claros; leia em voz alta para confirmar lógica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para rascunho",
                                    "Editor de texto ou ferramenta de pseudocódigo como Draw.io para fluxograma opcional"
                                  ],
                                  "tips": "Use nomes de variáveis descritivos como 'tolerancia' em vez de 'eps' para clareza.",
                                  "learningObjective": "Compreender e documentar os componentes fundamentais do Método da Secante.",
                                  "commonMistakes": [
                                    "Esquecer de definir f(x) explicitamente",
                                    "Usar tolerância muito baixa sem justificativa",
                                    "Confundir critérios de parada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever a seção de inicialização das variáveis",
                                  "subSteps": [
                                    "Inicie o pseudocódigo com 'INÍCIO' ou 'ALGORITMO Secante'.",
                                    "Declare e inicialize: x0 ← valor_inicial, x1 ← valor_inicial_diferente, i ← 0.",
                                    "Calcule f_x0 ← f(x0) e f_x1 ← f(x1) para verificação inicial de f_x1 ≠ f_x0.",
                                    "Adicione verificação inicial: SE f_x1 = f_x0 ENTÃO erro 'Chutes iniciais inválidos'.",
                                    "Inclua comentários para cada linha."
                                  ],
                                  "verification": "Execute mentalmente as inicializações com valores numéricos exemplo (x0=0, x1=1) e confirme saídas esperadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Referência ao fluxograma do Método da Secante"
                                  ],
                                  "tips": "Sempre calcule f(x0) e f(x1) antecipadamente para evitar divisão por zero no loop.",
                                  "learningObjective": "Implementar corretamente a configuração inicial para garantir convergência.",
                                  "commonMistakes": [
                                    "Não verificar se f(x1) ≠ f(x0)",
                                    "Inicializar x0 = x1",
                                    "Esquecer contador de iterações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop iterativo principal",
                                  "subSteps": [
                                    "Escreva 'ENQUANTO i < max_iter E |x1 - x0| >= ε E |f(x1)| >= ε FAÇA'.",
                                    "Calcule x2 ← x1 - f(x1) * (x1 - x0) / (f(x1) - f_x0).",
                                    "Atualize f_x0 ← f(x0), mas corrija para f_x0 ← f(x1), f_x1 ← f(x2).",
                                    "Atualize x0 ← x1, x1 ← x2, i ← i + 1.",
                                    "Adicione impressão opcional de iteração para depuração: 'ITERAÇÃO i: x1 = valor'."
                                  ],
                                  "verification": "Simule 2-3 iterações manualmente com x0=0, x1=1 para f(x)=x^2-2 e verifique se x converge para √2 ≈1.414.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para simulação manual",
                                    "Papel quadriculado para traçar fluxograma"
                                  ],
                                  "tips": "Use a fórmula exata da secante: evite confundir com falsi posição.",
                                  "learningObjective": "Codificar a iteração core do método garantindo atualizações corretas de variáveis.",
                                  "commonMistakes": [
                                    "Erro na fórmula: usar f(x0) em vez de f(x1) no numerador",
                                    "Não atualizar f_x0/f_x1",
                                    "Loop infinito sem condições"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar saída, tratamento de erros e finalização",
                                  "subSteps": [
                                    "Após o loop: SE i >= max_iter ENTÃO 'Não convergiu'.",
                                    "SENÃO 'Solução aproximada: x = x1, f(x1) = valor, iterações = i'.",
                                    "Inclua 'FIM' do algoritmo.",
                                    "Adicione seção de erros: divisão por zero se |f(x1)-f(x0)| < δ pequeno.",
                                    "Revise todo o pseudocódigo para consistência e clareza."
                                  ],
                                  "verification": "Leia o pseudocódigo completo e simule com exemplo até convergência ou max_iter.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto para formatação final"
                                  ],
                                  "tips": "Formate com indentação para legibilidade, como em programação real.",
                                  "learningObjective": "Completar o algoritmo com saídas robustas e tratamento de falhas.",
                                  "commonMistakes": [
                                    "Esquecer mensagem de não-convergência",
                                    "Output incorreto de variáveis",
                                    "Falta de 'FIM'"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x^3 - 2x - 5 = 0 (equação em análise de deformações em vigas): INÍCIO; x0 ← 2, x1 ← 3, ε ← 10^-6, max_iter ← 100, i ← 0; f_x0 ← f(x0), f_x1 ← f(x1); SE f_x1 = f_x0 ERRO; ENQUANTO i < 100 E |x1-x0| >= ε E |f(x1)| >= ε: x2 ← x1 - f_x1*(x1-x0)/(f_x1-f_x0); x0 ← x1; x1 ← x2; f_x0 ← f_x1; f_x1 ← f(x2); i ← i+1; FIM ENQUANTO; SE i=100 'Não convergiu' SENÃO 'Raiz: ' + x1; FIM. (Converge para ≈2.094).",
                              "finalVerifications": [
                                "Pseudocódigo inicializa x0, x1, ε, max_iter corretamente.",
                                "Loop usa fórmula exata da secante sem erros aritméticos.",
                                "Critérios de parada incluem ambos |Δx| < ε e |f(x)| < ε.",
                                "Atualizações de variáveis x0←x1, x1←x2 e f valores são consistentes.",
                                "Inclui tratamento de erro para f(x1)=f(x0) e não-convergência.",
                                "Estrutura clara com INÍCIO, ENQUANTO, FIM e comentários."
                              ],
                              "assessmentCriteria": [
                                "Precisão da fórmula iterativa (100% match com método secante).",
                                "Completude dos critérios de convergência e parada.",
                                "Clareza e legibilidade do pseudocódigo (indentação, comentários).",
                                "Robustez: tratamento de casos edge como não-convergência.",
                                "Lógica correta verificada por simulação manual de 3 iterações.",
                                "Adequação ao contexto: menção a f(x) não-linear em engenharia."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e métodos iterativos.",
                                "Programação: Estruturas de controle (loops, condicionais) em pseudocódigo.",
                                "Engenharia Civil: Aplicações em equilíbrio não-linear de estruturas.",
                                "Física: Modelagem de equações diferenciais em mecânica dos solos.",
                                "Computação: Preparação para implementação em Python/MATLAB."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, usado para resolver equações não-lineares em análise de estruturas (ex: calcular deslocamentos em vigas com grandes deformações) ou hidráulica (vazão em canais com perfis não-lineares), onde métodos analíticos falham, permitindo simulações precisas em softwares como ANSYS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Implementar o método em MATLAB ou Python",
                            "description": "Codificar o método da secante em MATLAB seguindo exemplos de Chapra & Canale (2002), testando em problemas como solução de equações de vigas ou reservatórios, plotando convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Algoritmo do Método da Secante e Configurar o Ambiente",
                                  "subSteps": [
                                    "Estude a fórmula do método da secante: x_{i+1} = x_i - f(x_i) * (x_i - x_{i-1}) / (f(x_i) - f(x_{i-1})).",
                                    "Revise exemplos de Chapra & Canale (2002), Capítulo 6, para entender iterações e critérios de parada (ex: tolerância 1e-6, máximo 100 iterações).",
                                    "Instale ou abra MATLAB/Python (recomendado: Python com NumPy e Matplotlib via Anaconda).",
                                    "Defina a função de teste: f(x) = x^3 - 2x - 5 (raiz ~2.094).",
                                    "Planeje variáveis: chute inicial x0, x1, tol, max_iter."
                                  ],
                                  "verification": "Ambiente pronto: execute 'import numpy as np; import matplotlib.pyplot as plt' sem erros e anote pseudocódigo do algoritmo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro Chapra & Canale (2002), Python/MATLAB instalado, editor de código (VS Code/Jupyter).",
                                  "tips": "Comece com Python para portabilidade; MATLAB é similar com funções vetoriais.",
                                  "learningObjective": "Compreender a lógica iterativa da secante e preparar ferramentas computacionais.",
                                  "commonMistakes": "Ignorar critérios de parada levando a loops infinitos; usar chutes iniciais ruins."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a Função Principal do Método da Secante",
                                  "subSteps": [
                                    "Defina def secant(f, x0, x1, tol=1e-6, max_iter=100):",
                                    "Inicialize listas para rastrear iterações: iter_list = [], x_list = [].",
                                    "Loop while: calcule f_x0 = f(x0), f_x1 = f(x1); se abs(f_x1) < tol, retorne x1.",
                                    "Calcule x2 = x1 - f_x1 * (x1 - x0) / (f_x1 - f_x0); atualize x0=x1, x1=x2.",
                                    "Append iterações e x à lista; incremente contador, break se max_iter.",
                                    "verification]: "
                                  ],
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código, documentação NumPy/MATLAB.",
                                  "tips": "Use print ou fprintf para debug de valores intermediários.",
                                  "learningObjective": "Codificar corretamente a iteração da secante com controle de erro.",
                                  "commonMistakes": "Divisão por zero se f(x_i) ≈ f(x_{i-1}); adicionar check if abs(f_x1 - f_x0) < 1e-12."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar em Problema de Engenharia Civil (Equação de Viga)",
                                  "subSteps": [
                                    "Defina f(x) = (x^3)/3 - 10*x^2 + 100*x - 2000 para deformação em viga (raiz ~9.5).",
                                    "Chutes: x0=1, x1=10; execute secant(f,1,10).",
                                    "Compare com solução analítica ou Newton-Raphson.",
                                    "Teste segundo problema: reservatório f(x)= e^x - 3x^2 (hidráulica).",
                                    "Registre número de iterações e erro final."
                                  ],
                                  "verification": "Código converge para raiz correta (±1e-6) em <50 iterações para ambos problemas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Problemas de Chapra ou engenharia civil (viga cantilever deformação).",
                                  "tips": "Escolha chutes próximos da raiz para convergência rápida.",
                                  "learningObjective": "Aplicar método a equações não-lineares reais da engenharia.",
                                  "commonMistakes": "Função f mal definida (ex: esquecer unidades); não escalar para problemas grandes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar Convergência e Analisar Resultados",
                                  "subSteps": [
                                    "Colete iter_list e x_list da função.",
                                    "Plote: plt.plot(iter_list, x_list, 'o-'); xlabel('Iterações'), ylabel('x'), title('Convergência Secante').",
                                    "Adicione linha horizontal na raiz verdadeira.",
                                    "Calcule erros: abs(x_true - x_list).",
                                    "Salve figura e relatório: iterações usadas, precisão."
                                  ],
                                  "verification": "Gráfico mostra convergência linear; salva como PNG sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matplotlib (Python) ou plot() (MATLAB).",
                                  "tips": "Log scale para erro se necessário: plt.yscale('log').",
                                  "learningObjective": "Visualizar e validar comportamento de convergência.",
                                  "commonMistakes": "Listas vazias se loop não append; plot errada (eixo invertido)."
                                }
                              ],
                              "practicalExample": "Implemente secante para f(x) = EI * d^4w/dx^4 - q(x) = 0 em viga simply supported (aprox. não-linear), com x0=0.1L, x1=0.2L, L=10m, convergindo à deflexão máxima em 8 iterações.",
                              "finalVerifications": [
                                "Função converge para raízes conhecidas em <30 iterações.",
                                "Gráficos de convergência mostram redução de erro.",
                                "Código executa sem erros/avisos em Python/MATLAB.",
                                "Resultados batem com Chapra exemplos (±0.1%).",
                                "Relatório inclui iterações, erro final e plots salvos.",
                                "Testes em 2+ problemas de engenharia civil passam."
                              ],
                              "assessmentCriteria": [
                                "Correção algorítmica: fórmula secante exata.",
                                "Eficiência: <20 iterações para tol=1e-6.",
                                "Robustez: trata singularidades e max_iter.",
                                "Documentação: comentários em código e relatório.",
                                "Visualização: plots claros com labels/anotações.",
                                "Precisão: erro < tol em problemas reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica (ordem de convergência superlinear).",
                                "Programação: Estruturas de loop e funções modulares.",
                                "Engenharia Mecânica: Modelos de deformação não-linear.",
                                "Estatística: Análise de erro e tolerâncias."
                              ],
                              "realWorldApplication": "Em engenharia civil, resolve equações não-lineares para análise de estruturas (vigas com grandes deformações), reservatórios hidráulicos (balanço de massa não-linear) e otimização de fundações, permitindo simulações rápidas sem métodos analíticos complexos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Tratar casos especiais e erros numéricos",
                            "description": "Identificar e corrigir problemas como divisão por zero (quando f(x_i) ≈ f(x_{i-1})), escolha de pontos iniciais próximos da raiz e superposição de pontos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar casos especiais e erros comuns no Método da Secante",
                                  "subSteps": [
                                    "Estude a fórmula da secante: x_{n+1} = x_n - f(x_n) * (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1}))",
                                    "Liste erros principais: divisão por zero (f(x_n) ≈ f(x_{n-1})), pontos iniciais próximos da raiz, superposição de pontos (x_n ≈ x_{n-1})",
                                    "Analise impacto: convergência lenta, falha ou loop infinito",
                                    "Revise exemplos matemáticos de funções como f(x) = x^3 - 2x + 1"
                                  ],
                                  "verification": "Crie um diagrama ou tabela resumindo 3 erros comuns e suas causas",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook Jupyter, calculadora simbólica (SymPy), documentação do método da secante",
                                  "tips": "Use gráficos de f(x) para visualizar onde erros ocorrem",
                                  "learningObjective": "Compreender as fontes matemáticas de falhas no algoritmo",
                                  "commonMistakes": "Ignorar tolerância numérica em comparações de floats"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar detecção e prevenção de divisão por zero",
                                  "subSteps": [
                                    "Adicione verificação condicional: if abs(f(x_n) - f(x_{n-1})) < epsilon, pare ou ajuste",
                                    "Defina epsilon (ex: 1e-10) baseado em precisão de máquina",
                                    "Implemente fallback: use método da bisseção ou perturbe pontos",
                                    "Teste com função onde f(x_i) ≈ f(x_{i-1}), como perto de extremos",
                                    "Registre log de detecção para depuração"
                                  ],
                                  "verification": "Execute código com caso problemático e confirme que detecta e evita divisão por zero",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy, editor de código (VS Code ou Jupyter)",
                                  "tips": "Use np.isclose() para comparações seguras de floats",
                                  "learningObjective": "Desenvolver lógica condicional robusta para estabilidade numérica",
                                  "commonMistakes": "Definir epsilon muito pequeno, causando falsos positivos"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar escolha e validação de pontos iniciais",
                                  "subSteps": [
                                    "Crie função para validar x0 e x1: verifique f(x0)*f(x1) < 0 e distância mínima",
                                    "Estabeleça regra: |x1 - x0| > delta (ex: 1e-6) e longe da raiz estimada",
                                    "Se inválido, sugira pontos automáticos via gráfico ou derivação",
                                    "Integre ao algoritmo principal com loop de retry",
                                    "Teste com raízes conhecidas e pontos ruins"
                                  ],
                                  "verification": "Gere pontos ruins intencionalmente e confirme que o código os rejeita/ajusta",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python, bibliotecas Matplotlib para plotar intervalos iniciais",
                                  "tips": "Plot f(x) no intervalo [x0-1, x1+1] para inspeção visual",
                                  "learningObjective": "Garantir inicialização robusta para convergência confiável",
                                  "commonMistakes": "Escolher pontos baseados só em chute, sem validação"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Tratar superposição de pontos e verificações de convergência",
                                  "subSteps": [
                                    "Monitore |x_n - x_{n-1}| < tol_convergencia após iterações",
                                    "Implemente contador de iterações máx (ex: 100) e detecção de estagnação",
                                    "Para superposição, perturbe x_{n+1} = x_n + epsilon aleatório pequeno",
                                    "Adicione critério de parada composto: tolerância em f(x) e x",
                                    "Valide com simulações longas"
                                  ],
                                  "verification": "Rode 5 iterações com pontos próximos e confirme parada ou correção sem loop",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Python com random module, testes unitários (pytest)",
                                  "tips": "Combine múltiplos critérios para evitar falsos terminais",
                                  "learningObjective": "Implementar salvaguardas contra não-convergência",
                                  "commonMistakes": "Não limitar iterações, causando loops infinitos"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar implementação completa",
                                  "subSteps": [
                                    "Crie suíte de testes: 3 casos normais, 3 problemáticos (div/0, próximos, superpostos)",
                                    "Meça precisão, tempo e logs de erros corrigidos",
                                    "Compare com solvers built-in (SciPy.root_scalar)",
                                    "Otimize código para Engenharia Civil (ex: funções de equilíbrio estrutural)",
                                    "Documente relatório de testes"
                                  ],
                                  "verification": "Todos testes passam com precisão < 1e-8 e sem crashes",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Jupyter, SciPy, exemplos de funções civis (ex: f(x)=k*x^3 - P)",
                                  "tips": "Use asserts em testes para automação",
                                  "learningObjective": "Validar robustez do algoritmo em cenários reais",
                                  "commonMistakes": "Testar só casos ideais, ignorando edge cases"
                                }
                              ],
                              "practicalExample": "Implemente o método da secante para f(x) = x^3 - 2x^2 + x - 1 (raiz ~0.7). Use x0=0.5, x1=0.51 (superpostos). O código deve detectar, perturbar x1 para 0.6 e convergir em <20 iterações, evitando div/0.",
                              "finalVerifications": [
                                "Algoritmo detecta e corrige div/0 em 100% dos testes",
                                "Pontos iniciais inválidos são rejeitados ou ajustados automaticamente",
                                "Convergência em <50 iterações para funções padrão",
                                "Sem loops infinitos ou NaN em edge cases",
                                "Precisão final |f(x_final)| < 1e-10",
                                "Logs claros de erros detectados e ações tomadas"
                              ],
                              "assessmentCriteria": [
                                "Correta identificação de 4+ casos especiais com explicação matemática",
                                "Código implementa todas verificações com epsilon/tol adequados",
                                "Testes cobrem 80%+ de cenários problemáticos com sucesso",
                                "Eficiência: tempo de execução <2s por teste",
                                "Documentação inclui exemplos e depuração",
                                "Aplicação correta em contexto de Engenharia Civil"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Tratamento de exceções e testes unitários",
                                "Matemática: Análise numérica e estabilidade de algoritmos",
                                "Engenharia Civil: Modelagem de não-linearidades em estruturas",
                                "Computação Científica: Uso de bibliotecas NumPy/SciPy",
                                "Estatística: Análise de sensibilidade a parâmetros iniciais"
                              ],
                              "realWorldApplication": "Em simulações de estruturas civis, como análise não-linear de vigas sob grandes deformações, onde equações de equilíbrio f(x)=0 podem ter raízes sensíveis a inicializações ruins; garante convergência robusta em softwares como ANSYS ou códigos customizados para dimensionamento seguro."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Análise de Convergência e Aplicações",
                        "description": "Estudo da ordem de convergência superlinear (aproximadamente 1.618), erros de truncamento e arredondamento, com exemplos em problemas de engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Calcular a ordem de convergência",
                            "description": "Demonstrar que a convergência é de ordem φ = (1 + √5)/2 ≈ 1.618 via limite log|ε_{i+1}| / log|ε_i|, comparando com a quadrática do Newton-Raphson.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição teórica da ordem de convergência para o método da secante",
                                  "subSteps": [
                                    "Estude a fórmula assintótica do erro para o método da secante: ε_{i+1} ≈ C * ε_i^φ, onde φ = (1 + √5)/2.",
                                    "Derive ou memorize que φ satisfaz φ^2 = φ + 1, derivado da recorrência do método.",
                                    "Compare com Newton-Raphson, onde φ = 2 (convergência quadrática).",
                                    "Entenda o limite diagnóstico: φ = lim (log|ε_{i+1}| / log|ε_i|) quando i → ∞.",
                                    "Anote exemplos de funções não-lineares comuns em engenharia civil, como equações de equilíbrio."
                                  ],
                                  "verification": "Escreva a fórmula do limite e explique verbalmente a diferença com Newton-Raphson.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de métodos numéricos, notas de aula, calculadora para √5.",
                                  "tips": "Visualize φ como o número áureo para lembrar sua origem geométrica.",
                                  "learningObjective": "Compreender a base teórica da superlinearidade de ordem φ no método da secante.",
                                  "commonMistakes": "Confundir ordem φ com taxa de convergência linear (φ=1); ignorar o limite assintótico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método da secante e gerar sequência de aproximações e erros",
                                  "subSteps": [
                                    "Escolha uma função não-linear, ex: f(x) = e^x - 3x^2 (modelo de carga em estruturas).",
                                    "Selecione pontos iniciais x0 e x1 próximos da raiz.",
                                    "Implemente o iterativo: x_{i+1} = x_i - f(x_i)(x_i - x_{i-1}) / (f(x_i) - f(x_{i-1})).",
                                    "Compute pelo menos 10-15 iterações até |ε| < 10^{-10}.",
                                    "Calcule erros ε_i = |x_i - x^*| usando a raiz exata ou valor de alta precisão."
                                  ],
                                  "verification": "Lista de 10 iterações com x_i, f(x_i) e ε_i tabulados corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software Python/MATLAB com numpy, ou planilha Excel para iterações manuais.",
                                  "tips": "Use precisão dupla e evite overflow com funções logarítmicas futuras.",
                                  "learningObjective": "Gerar dados empíricos de convergência para análise numérica.",
                                  "commonMistakes": "Pontos iniciais ruins causando divergência; arredondamento prematuro em ε_i."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular numericamente a ordem de convergência via limite logarítmico",
                                  "subSteps": [
                                    "Para i de 5 a n-1, compute r_i = log|ε_{i+1}| / log|ε_i| (use log natural ou base 10).",
                                    "Plote r_i vs i para visualizar convergência para φ ≈ 1.618.",
                                    "Calcule média dos últimos 5 r_i e desvio padrão.",
                                    "Compare com φ = (1 + sqrt(5))/2 computado numericamente.",
                                    "Teste sensibilidade variando pontos iniciais."
                                  ],
                                  "verification": "Gráfico ou tabela mostrando r_i aproximando 1.618 com erro < 0.01 nos últimos termos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com matplotlib para plot, ou Excel para cálculos/tabulações.",
                                  "tips": "Filtre iterações iniciais onde ε_i é grande (log negativo grande).",
                                  "learningObjective": "Aplicar o diagnóstico logarítmico para estimar φ empiricamente.",
                                  "commonMistakes": "Dividir por log|ε_i| próximo de zero; usar ε_i sem módulo absoluto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com convergência quadrática do Newton-Raphson e analisar",
                                  "subSteps": [
                                    "Implemente Newton-Raphson para a mesma função: x_{i+1} = x_i - f(x_i)/f'(x_i).",
                                    "Gere ε_i e r_i = log|ε_{i+1}| / log|ε_i| para Newton (deve → 2).",
                                    "Compare tabelas/plots de secante vs Newton: velocidade e precisão.",
                                    "Discuta trade-offs: secante não precisa de derivada, mas convergência mais lenta.",
                                    "Relacione a aplicações em engenharia civil onde derivadas são caras."
                                  ],
                                  "verification": "Relatório comparativo com valores finais de φ_secante ≈1.618 e φ_Newton ≈2.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Mesmo software do passo 2, adicionando função derivada.",
                                  "tips": "Use mesma semente inicial para x0 em ambos métodos.",
                                  "learningObjective": "Demonstrar superioridade quadrática de Newton vs superlinear de secante.",
                                  "commonMistakes": "Esquecer derivada em Newton; comparar iterações desiguais."
                                }
                              ],
                              "practicalExample": "Para f(x) = x^3 - 2x - 5 = 0 (equação de momento fletor em viga), com x0=2, x1=3. Após 12 iterações da secante, r_i estabiliza em 1.617; Newton converge em 6 iterações com r_i→1.999.",
                              "finalVerifications": [
                                "Sequência r_i converge para φ ≈1.618 com erro <1%.",
                                "Comparação mostra Newton 2-3x mais rápido em iterações.",
                                "Tabela de erros ε_i decresce consistentemente.",
                                "Gráfico de log|ε| vs iteração é linear com inclinação -φ.",
                                "Teste com segunda função confirma generalidade.",
                                "Sem divergências ou NaNs nos cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo de φ: erro <0.005.",
                                "Qualidade da implementação: código livre de bugs, converge corretamente.",
                                "Análise comparativa: identificação clara de diferenças.",
                                "Visualizações: plots informativos e legíveis.",
                                "Relacionamento com teoria: citações corretas de fórmulas.",
                                "Profundidade: testes de sensibilidade incluídos.",
                                "Clareza: documentação passo a passo."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: implementação em Python/MATLAB.",
                                "Estatística: análise de convergência via médias e desvios.",
                                "Física/Engenharia: modelagem de equações não-lineares em estruturas.",
                                "Matemática Pura: números áureos e sequências de Fibonacci."
                              ],
                              "realWorldApplication": "Em engenharia civil, calcular ordem de convergência assegura eficiência em solvers para equações não-lineares de equilíbrio estático em pontes ou análise de flambagem, onde secante é preferida por não requerer derivadas analíticas caras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.3"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Avaliar critérios de parada e precisão",
                            "description": "Analisar trade-offs entre tolerâncias absolutas/relativas, máximo de iterações e impacto em aplicações como otimização de seções transversais em estruturas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Tipos de Critérios de Parada",
                                  "subSteps": [
                                    "Defina tolerância absoluta (ε_abs): critério |f(x_n) - f(x_{n-1})| < ε_abs ou |x_n - x_{n-1}| < ε_abs.",
                                    "Defina tolerância relativa (ε_rel): critério |x_n - x_{n-1}| / |x_{n-1}| < ε_rel.",
                                    "Explique o critério de máximo de iterações (max_iter): parar após N iterações para evitar loops infinitos.",
                                    "Compare com exemplos numéricos simples usando o método da secante.",
                                    "Discuta quando cada critério é apropriado com base na escala da solução."
                                  ],
                                  "verification": "Liste e formule os três critérios principais com exemplos numéricos corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel e calculadora",
                                    "Software de programação (Python ou MATLAB)",
                                    "Notas sobre método da secante"
                                  ],
                                  "tips": "Use exemplos com valores pequenos para visualizar diferenças entre absoluto e relativo.",
                                  "learningObjective": "Identificar e formular corretamente os critérios de parada absolutos, relativos e de iterações máximas.",
                                  "commonMistakes": [
                                    "Confundir tolerância absoluta com relativa em problemas de grande escala",
                                    "Ignorar a normalização na tolerância relativa",
                                    "Definir max_iter muito baixo sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Trade-offs entre Critérios",
                                  "subSteps": [
                                    "Avalie prós e contras da tolerância absoluta: precisa para soluções pequenas, mas insensível a escalas grandes.",
                                    "Avalie prós e contras da tolerância relativa: escalável, mas problemática perto de zero.",
                                    "Discuta trade-offs com max_iter: garante terminação, mas pode sacrificar precisão.",
                                    "Crie uma tabela comparativa de cenários (ex: solução esperada ~1 vs ~1000).",
                                    "Simule trade-offs alterando parâmetros em um código simples do método da secante."
                                  ],
                                  "verification": "Crie uma tabela de trade-offs com pelo menos 3 cenários e justifique escolhas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Código Python básico para secante",
                                    "Gráficos de convergência"
                                  ],
                                  "tips": "Teste com funções conhecidas como f(x) = x^2 - 2 para raízes próximas de 1 e 100.",
                                  "learningObjective": "Analisar quantitativamente os trade-offs entre precisão, eficiência computacional e robustez dos critérios.",
                                  "commonMistakes": [
                                    "Escolher tol_abs para problemas escalados sem ajuste",
                                    "Definir tol_rel muito apertada causando iterações excessivas",
                                    "Subestimar impacto de max_iter em convergência lenta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Impacto na Precisão e Convergência",
                                  "subSteps": [
                                    "Meça precisão: compare solução final com valor exato ou alta precisão.",
                                    "Analise velocidade de convergência: número de iterações vs precisão alcançada.",
                                    "Estude sensibilidade: varie ε_abs, ε_rel e max_iter, plote gráficos de erro.",
                                    "Considere estabilidade numérica no método da secante (ordem quadrática).",
                                    "Quantifique impacto: calcule tempo de CPU e erro residual para combinações."
                                  ],
                                  "verification": "Gere gráficos mostrando iterações vs erro para 3 combinações de critérios.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Função teste não-linear como f(x) = e^x - 3x^2",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use log-scale para erros em gráficos para melhor visualização.",
                                  "learningObjective": "Quantificar o impacto dos critérios na precisão final, número de iterações e estabilidade.",
                                  "commonMistakes": [
                                    "Não logar erros para análise",
                                    "Ignorar overflow/underflow em tol_rel perto de zero",
                                    "Confundir convergência com precisão global"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Otimização de Seções Transversais",
                                  "subSteps": [
                                    "Modele problema: minimize área de seção transversal de viga sujeita a tensão máxima (equação não-linear).",
                                    "Implemente método da secante com critérios variáveis.",
                                    "Avalie trade-offs: tol apertada aumenta precisão mas custo computacional em iterações múltiplas.",
                                    "Compare resultados: precisão vs tempo para design seguro de estruturas.",
                                    "Recomende critérios ótimos baseados em normas de engenharia (ex: precisão 1e-6 para dimensões)."
                                  ],
                                  "verification": "Implemente e rode simulação para viga, relatando critérios escolhidos e justificativa.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python customizado",
                                    "Dados de material (aço: E=200GPa, σ_max=250MPa)",
                                    "Normas ABNT NBR para estruturas"
                                  ],
                                  "tips": "Inicie com chute inicial realista baseado em cálculo analítico aproximado.",
                                  "learningObjective": "Aplicar critérios de parada em problema real de engenharia civil, balanceando precisão e eficiência.",
                                  "commonMistakes": [
                                    "Chutes iniciais ruins levando a não-convergência",
                                    "Ignorar restrições físicas como seção mínima",
                                    "Escolher critérios sem considerar impacto em segurança estrutural"
                                  ]
                                }
                              ],
                              "practicalExample": "Em otimização de viga simply supported com carga distribuída q=10kN/m, span L=5m, use secante para resolver σ_max = M*y/I = fy, onde M_max= qL^2/8. Defina ε_rel=1e-6, ε_abs=1e-4, max_iter=50. Analise: com ε_rel apertada, converge em 8 iterações com área=0.023m²; solta max_iter=20 para em impreciso 5%. Trade-off: precisão alta garante segurança, mas iterações extras em otimização multi-viga.",
                              "finalVerifications": [
                                "Explique diferenças entre ε_abs e ε_rel com fórmula e exemplo numérico.",
                                "Crie tabela de trade-offs para 3 cenários escalados.",
                                "Gere gráfico de convergência para método da secante com critérios variados.",
                                "Implemente código para otimização de seção transversal e rode simulação.",
                                "Justifique critérios ótimos para aplicação em estruturas civis.",
                                "Identifique 3 erros comuns em escolha de critérios e como evitá-los."
                              ],
                              "assessmentCriteria": [
                                "Correção conceitual dos critérios (fórmulas e definições: 20%)",
                                "Análise quantitativa de trade-offs com simulações (30%)",
                                "Qualidade de gráficos e tabelas de impacto na convergência (20%)",
                                "Aplicação prática em exemplo de engenharia civil (20%)",
                                "Justificativas claras e conexão com normas reais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Análise de erro e convergência de métodos iterativos.",
                                "Programação Computacional: Implementação em Python/MATLAB para simulações.",
                                "Mecânica dos Materiais: Modelagem de tensões em seções transversais.",
                                "Otimização: Trade-offs em problemas de engenharia restritos.",
                                "Estatística: Análise de sensibilidade e incertezas numéricas."
                              ],
                              "realWorldApplication": "No dimensionamento de vigas em pontes ou edifícios, critérios de parada inadequados podem levar a seções sub ou superdimensionadas, impactando custos (até 20% a mais) e segurança (falha por precisão baixa em cargas extremas), conforme normas como Eurocode ou ABNT NBR 6118."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Aplicar em problemas reais de engenharia civil",
                            "description": "Resolver numericamente uma equação não linear de um problema prático, como deformação em solos ou fluxo em canais, usando o método da secante e validando com bibliografia (ex: Yang et al., 2005).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e formular o problema real de engenharia civil como equação não linear",
                                  "subSteps": [
                                    "Pesquise problemas práticos em engenharia civil, como deformação em solos ou fluxo em canais abertos.",
                                    "Selecione um exemplo específico, ex: deformação ε em solo onde f(ε) = σ₀ * exp(ε / C) - σ_aplicada = 0.",
                                    "Derive a equação não linear a partir das leis físicas (ex: lei de Hooke hiperbólica ou equação de Manning para fluxo).",
                                    "Defina parâmetros reais: σ_aplicada = 200 kPa, σ₀ = 50 kPa, C = 0.1.",
                                    "Escreva a função f(x) e sua forma explícita para implementação."
                                  ],
                                  "verification": "Equação f(x)=0 está claramente definida com parâmetros reais e derivada documentada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livros de geotecnia (ex: Terzaghi), artigos (Yang et al., 2005), caderno ou software de anotações.",
                                  "tips": "Comece com unidades consistentes (kPa, adimensional) para evitar erros dimensionais.",
                                  "learningObjective": "Formular problemas reais como equações não lineares acionáveis.",
                                  "commonMistakes": "Ignorar condições de contorno ou usar parâmetros irreais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar implementação do método da secante: escolher pontos iniciais e tolerâncias",
                                  "subSteps": [
                                    "Escolha dois pontos iniciais x0 e x1 próximos da raiz esperada (ex: x0=0.1, x1=0.2 para ε).",
                                    "Defina critérios de parada: tolerância ε=1e-6, máximo 100 iterações.",
                                    "Escreva pseudocódigo: x_{n+1} = x_n - f(x_n)*(x_n - x_{n-1}) / (f(x_n) - f(x_{n-1})).",
                                    "Teste manualmente 1-2 iterações em papel para validar setup.",
                                    "Prepare ambiente de programação (Python ou MATLAB)."
                                  ],
                                  "verification": "Pseudocódigo e pontos iniciais testados manualmente com resultados coerentes.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python (NumPy), MATLAB ou Excel; calculadora.",
                                  "tips": "Pontos iniciais devem brackear a raiz ou serem próximos para convergência quadrática.",
                                  "learningObjective": "Configurar corretamente o método da secante para problemas físicos.",
                                  "commonMistakes": "Pontos iniciais idênticos ou f(x0)=f(x1)=0, causando divisão por zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e executar o método da secante numericamente",
                                  "subSteps": [
                                    "Codifique a função f(x) no software escolhido.",
                                    "Implemente o loop de iterações, registrando x_n, f(x_n) e erro a cada passo.",
                                    "Execute até convergência ou máximo de iterações.",
                                    "Plote gráfico de convergência (x_n vs n) e f(x) vs x.",
                                    "Registre número de iterações e valor final de ε."
                                  ],
                                  "verification": "Código roda sem erros, produz raiz convergida (ex: ε ≈ 0.35) e gráficos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python (com Matplotlib), MATLAB; computador.",
                                  "tips": "Use vetores para armazenar histórico e facilitar análise.",
                                  "learningObjective": "Aplicar programação numérica ao método da secante.",
                                  "commonMistakes": "Erro de indexação no loop ou tolerância muito rigorosa causando loop infinito."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a solução com bibliografia e analisar convergência",
                                  "subSteps": [
                                    "Compare resultado numérico com solução analítica aproximada ou tabela de Yang et al., 2005.",
                                    "Calcule erro relativo: |ε_num - ε_lit| / ε_lit < 5%.",
                                    "Analise taxa de convergência plotando log(erro) vs iterações (deve ser ~2).",
                                    "Teste sensibilidade variando parâmetros (ex: σ_aplicada ±10%).",
                                    "Documente discrepâncias e justifique (ex: aproximações no modelo)."
                                  ],
                                  "verification": "Comparação com referência bibliográfica mostra concordância dentro de 5%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Artigo Yang et al., 2005; software de plotagem.",
                                  "tips": "Busque soluções exatas ou benchmarks em literatura para validação robusta.",
                                  "learningObjective": "Validar soluções numéricas contra dados experimentais/literatura.",
                                  "commonMistakes": "Não citar fonte corretamente ou ignorar unidades na comparação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e preparar relatório de aplicação",
                                  "subSteps": [
                                    "Interprete o resultado físico: ex: deformação ε=0.35 implica risco de assentamento.",
                                    "Discuta limitações do método e do modelo (ex: solo linear vs real).",
                                    "Sugira melhorias: métodos híbridos ou refinamento de malha.",
                                    "Escreva relatório com equação, código, gráficos e conclusões.",
                                    "Apresente como isso se aplica em projetos reais."
                                  ],
                                  "verification": "Relatório completo com interpretação física e limitações.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Editor de texto (Word, LaTeX); gráficos gerados.",
                                  "tips": "Enfatize impacto prático para conectar teoria à engenharia.",
                                  "learningObjective": "Comunicar resultados numéricos em contexto de engenharia.",
                                  "commonMistakes": "Focar só em números sem interpretação física."
                                }
                              ],
                              "practicalExample": "Em um projeto de fundação, resolva f(ε) = 50 * exp(ε / 0.1) - 200 = 0 para deformação ε em solo argiloso sob carga 200 kPa. Usando secante com x0=0.1, x1=0.2, converge em ~5 iterações para ε≈0.35 (35% deformação), validado com Yang et al. (2005) que reporta 0.34-0.36.",
                              "finalVerifications": [
                                "Equação não linear derivada corretamente de problema real.",
                                "Método da secante converge em <20 iterações com erro <1e-5.",
                                "Resultado valida com bibliografia (erro relativo <5%).",
                                "Gráficos de convergência e f(x) gerados e analisados.",
                                "Relatório interpreta implicações para engenharia civil.",
                                "Sensibilidade a parâmetros testada."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação do problema (30%).",
                                "Correção da implementação numérica (25%).",
                                "Qualidade da validação bibliográfica (20%).",
                                "Análise de convergência e interpretação (15%).",
                                "Clareza do relatório e gráficos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Análise de métodos iterativos.",
                                "Programação Computacional: Implementação em Python/MATLAB.",
                                "Geotecnia: Modelos constitutivos de solos.",
                                "Hidráulica: Aplicações em fluxo não uniforme em canais.",
                                "Estatística: Análise de sensibilidade e erro."
                              ],
                              "realWorldApplication": "Engenheiros civis usam isso para prever assentamentos em fundações de edifícios, dimensionar canais de irrigação evitando erosão por fluxo crítico, ou analisar estabilidade de taludes, otimizando projetos com precisão numérica validada por literatura."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Método de Iteração de Ponto Fixo",
                    "description": "Transforma a equação em forma de ponto fixo e itera até convergência, dependendo da contração do operador.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Transformação em Forma de Ponto Fixo",
                        "description": "Processo de reescrever uma equação não-linear f(x) = 0 na forma equivalente x = g(x), garantindo que a solução de f(x) = 0 seja um ponto fixo de g(x), e selecionando g(x) de modo a promover convergência rápida.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Identificar formas adequadas de g(x)",
                            "description": "Dado f(x) = 0, propor diferentes reformulações x = g(x) e avaliar intuitivamente sua adequação baseada na monotonicidade e no comportamento da função g(x) em um intervalo inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Propor múltiplas reformulações da equação f(x) = 0 na forma x = g(x)",
                                  "subSteps": [
                                    "Analise a equação f(x) = 0 e identifique o termo com x isolado.",
                                    "Reescreva isolando x de diferentes maneiras, adicionando ou subtraindo termos para criar equivalências.",
                                    "Gere pelo menos três formas distintas de g(x), garantindo que f(g(x)) = 0 implique x = g(x).",
                                    "Registre cada g(x) com sua derivação passo a passo.",
                                    "Verifique algebricamente se cada reformulação é equivalente à original."
                                  ],
                                  "verification": "Lista de pelo menos três g(x) propostas com derivações corretas e verificação de equivalência.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora gráfica ou software como GeoGebra",
                                    "Exemplo de f(x) impresso"
                                  ],
                                  "tips": "Priorize reformulações que mantenham g(x) suave e contínua; evite divisões por zero potenciais.",
                                  "learningObjective": "Dominar a geração de reformulações equivalentes x = g(x) a partir de f(x) = 0.",
                                  "commonMistakes": [
                                    "Isolar incorretamente levando a não-equivalência",
                                    "Gerar menos de três opções",
                                    "Ignorar domínios reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar a monotonicidade de cada função g(x)",
                                  "subSteps": [
                                    "Calcule a derivada g'(x) para cada g(x) proposta.",
                                    "Determine os sinais de g'(x) em um intervalo inicial relevante [a, b] onde a raiz é esperada.",
                                    "Classifique cada g(x) como crescente (g'(x) > 0), decrescente (g'(x) < 0) ou não monótona.",
                                    "Plote ou esboce g(x) e g'(x) para visualização intuitiva.",
                                    "Discuta implicações: monotonicidade favorece convergência em iterações."
                                  ],
                                  "verification": "Tabela ou relatório com g'(x), sinais e classificação de monotonicidade para cada g(x).",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de plotagem (Desmos ou MATLAB)",
                                    "Tabela de valores de teste"
                                  ],
                                  "tips": "Use o teste da primeira derivada; foque em intervalos onde |g'(x)| é controlável.",
                                  "learningObjective": "Aplicar análise de derivadas para avaliar monotonicidade de g(x).",
                                  "commonMistakes": [
                                    "Erro no cálculo de g'(x)",
                                    "Avaliar monotonicidade fora do intervalo relevante",
                                    "Confundir sinal de g'(x) com magnitude"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o comportamento de g(x) no intervalo inicial",
                                  "subSteps": [
                                    "Defina um intervalo inicial [a, b] contendo a raiz aproximada de f(x) = 0.",
                                    "Verifique se g([a, b]) ⊆ [a, b] (g(a) ≥ a e g(b) ≤ b, ou vice-versa para decrescente).",
                                    "Estime |g'(x)| no intervalo; idealmente sup |g'(x)| < 1 para contratividade.",
                                    "Avalie iterações iniciais: compute x1 = g(x0), x2 = g(x1) para x0 em [a,b].",
                                    "Observe atração para a raiz ou divergência."
                                  ],
                                  "verification": "Relatório com verificação de mapeamento do intervalo, valores de |g'(x)| e 3-5 iterações iniciais.",
                                  "estimatedTime": "30-35 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha Excel ou Python para iterações",
                                    "Gráfico de g(x) vs. identidade"
                                  ],
                                  "tips": "Escolha x0 próximo da raiz estimada; plote g(x) contra y=x para visualizar atração.",
                                  "learningObjective": "Interpretar comportamento iterativo de g(x) baseado em derivadas e mapeamento de intervalos.",
                                  "commonMistakes": [
                                    "Intervalo inicial inadequado sem raiz",
                                    "Ignorar |g'(x)| >1",
                                    "Parar iterações cedo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar reformulações e selecionar a forma adequada de g(x)",
                                  "subSteps": [
                                    "Compile resultados de monotonicidade, mapeamento e |g'(x)| para todas g(x).",
                                    "Classifique cada g(x) por critérios: convergência rápida (baixo sup|g'(x)|), monotonicidade, estabilidade.",
                                    "Selecione a melhor g(x) e justifique com evidências numéricas e gráficas.",
                                    "Teste convergência completa com 10 iterações.",
                                    "Documente limitações da escolha."
                                  ],
                                  "verification": "Conclusão clara com g(x) selecionada, tabela comparativa e trajetória de convergência.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Resumo dos passos anteriores",
                                    "Software para iterações múltiplas"
                                  ],
                                  "tips": "Prefira g(x) com sup|g'(x)| mais próximo de 0; valide com múltiplos x0.",
                                  "learningObjective": "Sintetizar análises para decidir adequação intuitiva de g(x).",
                                  "commonMistakes": [
                                    "Selecionar baseada só em uma métrica",
                                    "Justificativa vaga sem dados",
                                    "Não testar convergência final"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x³ - 2x - 5 = 0 (raiz ≈ 2.1 em [2,3]), proponha: g₁(x) = (5 + 2x)^{1/3}, g₂(x) = (x³ - 5)/2, g₃(x) = x - (x³ - 2x - 5)/ (3x² - 2). Avalie: g₁ é monótona crescente, g([2,3])⊆[2,3], sup|g₁'(x)|≈0.4<1 (converge rápido); g₂ diverge pois |g₂'(x)|>1; g₃ é approx. Newton, converge mas menos intuitiva para ponto fixo simples. Escolha g₁.",
                              "finalVerifications": [
                                "Pelo menos três g(x) propostas corretamente.",
                                "Monotonicidade e |g'(x)| avaliados com precisão no intervalo.",
                                "Comportamento iterativo demonstrado com convergência para uma g(x).",
                                "Seleção justificada com comparação quantitativa.",
                                "Gráficos ou tabelas suportam intuição.",
                                "Equivalência algébrica confirmada para todas g(x)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas reformulações (25%)",
                                "Correção na análise de monotonicidade e derivadas (25%)",
                                "Qualidade da avaliação de intervalo e contratividade (20%)",
                                "Profundidade da comparação e justificativa (15%)",
                                "Uso de exemplos numéricos/gráficos (10%)",
                                "Clareza e completude da documentação (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções e cálculo diferencial.",
                                "Programação: Implementação de loops iterativos em Python/MATLAB.",
                                "Física/Engenharia: Modelagem de equilíbrios não-lineares em estruturas.",
                                "Estatística: Análise de convergência e erro numérico."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao analisar deformações não-lineares em fundações sob carga variável (f(x)=0 de equilíbrio), uma g(x) adequada acelera simulações computacionais, reduzindo tempo de projeto de pontes ou barragens, evitando divergências que invalidariam resultados estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Escolher g(x) para otimizar convergência",
                            "description": "Comparar múltiplas formas de g(x) para a mesma equação, selecionando aquela com derivada de módulo menor que 1 em um intervalo [a, b] que contenha a raiz, utilizando gráficos ou cálculos preliminares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a equação e propor múltiplas formas g(x)",
                                  "subSteps": [
                                    "Leia e entenda a equação não-linear f(x) = 0.",
                                    "Reorganize algebraicamente a equação em pelo menos 3 formas diferentes x = g(x), garantindo que g(α) = α onde α é a raiz.",
                                    "Verifique se cada g(x) é contínua e diferenciável no domínio esperado.",
                                    "Documente cada transformação realizada.",
                                    "Priorize formas simples para facilitar cálculos posteriores."
                                  ],
                                  "verification": "Lista com 3-4 g(x) válidas onde g(α) ≈ α para uma aproximação conhecida da raiz.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Software de álgebra simbólica opcional (ex: SymPy)"
                                  ],
                                  "tips": "Escolha rearranjos que isolam x de forma natural, evitando divisões por zero ou funções não definidas no intervalo.",
                                  "learningObjective": "Dominar a geração de transformações equivalentes em forma de ponto fixo.",
                                  "commonMistakes": [
                                    "Criar g(x) onde g(α) ≠ α",
                                    "Formas excessivamente complexas",
                                    "Ignorar domínio de definição"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o intervalo [a, b] contendo a raiz",
                                  "subSteps": [
                                    "Use métodos preliminares como bisseção ou gráfico para localizar um intervalo [a, b] onde f(a) e f(b) têm sinais opostos ou f muda monotonicamente.",
                                    "Confirme que a raiz α está em [a, b] com sinal de f ou aproximação inicial.",
                                    "Garanta que [a, b] seja pequeno o suficiente para análise prática, mas cubra a raiz.",
                                    "Calcule valores de f(a) e f(b) para validação.",
                                    "Ajuste [a, b] se necessário para garantir unicidade da raiz."
                                  ],
                                  "verification": "Intervalo [a, b] com f(a)*f(b) ≤ 0 e comprimento razoável (ex: <2).",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Calculadora gráfica",
                                    "Papel quadriculado",
                                    "Software de plotagem (ex: Desmos, Python Matplotlib)"
                                  ],
                                  "tips": "Comece com um intervalo amplo e refine usando avaliações de f(x).",
                                  "learningObjective": "Localizar intervalos confiáveis contendo raízes de equações não-lineares.",
                                  "commonMistakes": [
                                    "Escolher intervalo sem mudança de sinal",
                                    "Intervalo muito amplo levando a |g'|>1",
                                    "Múltiplas raízes no intervalo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e analisar |g'(x)| para cada g(x) no intervalo",
                                  "subSteps": [
                                    "Derive g'(x) analiticamente para cada g(x).",
                                    "Avalie o máximo de |g'(x)| no [a, b], usando cálculo (máximos/mínimos) ou avaliação em pontos críticos e extremos.",
                                    "Verifique se max |g'(x)| < 1 para todas as g(x) candidatas.",
                                    "Calcule |g'(x)| em pontos amostrados (ex: 5-10 pontos uniformes).",
                                    "Registre valores numéricos ou gráficos de |g'(x)|."
                                  ],
                                  "verification": "Tabela ou gráfico mostrando max |g'(x)| < 1 para g(x) viáveis.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha (Excel/Google Sheets)",
                                    "Python ou MATLAB para derivação numérica"
                                  ],
                                  "tips": "Se g'(x) complexa, use aproximação numérica de derivadas.",
                                  "learningObjective": "Aplicar teorema de convergência da iteração de ponto fixo via Lipschitz constante K = max |g'(x)| < 1.",
                                  "commonMistakes": [
                                    "Erro no cálculo de g'(x)",
                                    "Avaliar fora de [a,b]",
                                    "Confundir |g'(α)| com max |g'(x)|"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar g(x) e selecionar a ótima para convergência",
                                  "subSteps": [
                                    "Classifique as g(x) pelo menor max |g'(x)| (quanto menor, mais rápida a convergência).",
                                    "Elimine g(x) com max |g'(x)| ≥ 1.",
                                    "Entre as viáveis, escolha a com K mais próximo de 0.",
                                    "Justifique a escolha com valores numéricos e taxa de convergência esperada (erro ~ K^n).",
                                    "Teste 2-3 iterações iniciais para preview."
                                  ],
                                  "verification": "Seleção justificada da melhor g(x) com K mínimo documentado.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Tabela comparativa em papel ou planilha"
                                  ],
                                  "tips": "A convergência linear tem taxa |e_{n+1}| ≈ K |e_n|, priorize K pequeno.",
                                  "learningObjective": "Otimizar escolha de g(x) para máxima eficiência computacional.",
                                  "commonMistakes": [
                                    "Selecionar baseada em g(x) simples ao invés de |g'|",
                                    "Ignorar g(x) com K próximo a 1"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar escolha com gráficos e testes preliminares",
                                  "subSteps": [
                                    "Plote f(x), g(x) e y=x no [a,b] para visualizar interseção e atração.",
                                    "Plote |g'(x)| vs x para confirmar máximo.",
                                    "Execute 5-10 iterações com x0 em [a,b] para observar convergência.",
                                    "Compare número de iterações entre g(x) candidatas.",
                                    "Documente observações e conclusões."
                                  ],
                                  "verification": "Gráficos e tabela de iterações mostrando convergência rápida da g(x) selecionada.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Software de plotagem (Python Matplotlib, MATLAB, Desmos)",
                                    "Notebook Jupyter opcional"
                                  ],
                                  "tips": "Use zoom nos gráficos para detalhes perto da raiz.",
                                  "learningObjective": "Usar visualização e simulação para validar teoria numérica.",
                                  "commonMistakes": [
                                    "Escala errada nos gráficos",
                                    "x0 fora de [a,b]",
                                    "Parar iterações cedo demais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação f(x) = x^3 - 2x^2 + x - 1 = 0 com raiz ≈ 1.618 no intervalo [1, 2] (f(1)= -1 <0, f(2)=1>0). Proponha: g1(x) = 1 + 2x^2 - x^3? Não: rearranjos corretos como g1(x) = (1 - x + 2x^2)^{1/3}, g2(x) = x^2 - (x^3 - x +1)/2? Use g1(x) = 1 / (1 - x + 2x), wait padrão: g1(x) = [1 + (2x^2 - x)]^{1/3} ajustado. Calcule max |g1'(x)| ≈0.3, g2(x)=x - f(x)/(3x^2-4x+1) Newton-like mas fixed: foque em algébrico. g1 converge lento, g2 rápido.",
                              "finalVerifications": [
                                "Lista pelo menos 3 g(x) válidas para uma f(x) dada.",
                                "Identifica corretamente intervalo [a,b] com raiz.",
                                "Calcula max |g'(x)| <1 com precisão <0.01.",
                                "Seleciona g(x) com menor K e justifica.",
                                "Gráficos confirmam convergência em <10 iterações.",
                                "Testa iterações sem divergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos rearranjos g(x) e derivadas (100% correto).",
                                "Qualidade do intervalo [a,b] (contém raiz única).",
                                "Análise completa de |g'(x)| com valores numéricos.",
                                "Justificativa lógica da escolha ótima.",
                                "Uso efetivo de gráficos e testes iterativos.",
                                "Documentação clara e organizada."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar plots e iterações em Python/NumPy.",
                                "Física/Engenharia: Modelos não-lineares em estática de estruturas.",
                                "Análise de Dados: Otimização de hiperparâmetros em ML iterativo.",
                                "Matemática Aplicada: Teoria de ponto fixo em otimização.",
                                "Design Computacional: Acelerar solvers em FEM."
                              ],
                              "realWorldApplication": "Em engenharia civil, ao simular deslocamentos não-lineares em vigas ou fundações sob cargas extremas via software FEM (ex: ANSYS), escolher g(x) ótima reduz iterações de 1000+ para <50, economizando horas de computação em projetos de pontes ou edifícios altos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Verificar equivalência da transformação",
                            "description": "Confirmar que as soluções de x = g(x) coincidem exatamente com as raízes de f(x) = 0, testando algebricamente e graficamente em exemplos simples como x^2 - 3x + 2 = 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a equação original f(x) = 0 e identificar suas raízes",
                                  "subSteps": [
                                    "Escreva a equação f(x) = 0 explicitamente, por exemplo, f(x) = x² - 3x + 2 = 0.",
                                    "Fatore ou resolva algebricamente para encontrar as raízes exatas (ex: (x-1)(x-2)=0, raízes x=1 e x=2).",
                                    "Calcule f(x) nas raízes identificadas para confirmar que f(1)=0 e f(2)=0.",
                                    "Registre as raízes em uma tabela para referência futura.",
                                    "Discuta o significado físico ou contextual das raízes no problema de engenharia."
                                  ],
                                  "verification": "Confirme que f(x)=0 nas raízes encontradas e liste-as corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, calculadora ou software como MATLAB/Excel para fatoração.",
                                  "tips": "Sempre fatorize polinômios quadráticos usando fórmula de Bhaskara se necessário.",
                                  "learningObjective": "Compreender e resolver analiticamente equações não-lineares simples.",
                                  "commonMistakes": "Esquecer de verificar se as raízes satisfazem f(x)=0; confundir raízes múltiplas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar a transformação para a forma de ponto fixo x = g(x)",
                                  "subSteps": [
                                    "Reescreva f(x)=0 na forma x = g(x), por exemplo, x = (x² + 2)/3 para f(x)=x²-3x+2=0.",
                                    "Verifique algebricamente que x = g(x) implica f(x)=0: substitua e simplifique.",
                                    "Calcule g(x) nas raízes conhecidas: g(1)=1 e g(2)=2.",
                                    "Analise a derivada g'(x) para verificar convergência (|g'(x)|<1 nas raízes).",
                                    "Documente a função g(x) e suas propriedades iniciais."
                                  ],
                                  "verification": "Mostre que substituir x=g(x) recupera f(x)=0 e que raízes de f satisfazem g.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora simbólica (Wolfram Alpha ou SymPy), papel para derivação.",
                                  "tips": "Escolha g(x) tal que sua derivada seja pequena perto das raízes para boa convergência.",
                                  "learningObjective": "Dominar a reformulação de equações em forma iterativa de ponto fixo.",
                                  "commonMistakes": "Escolher transformação que não preserve todas as raízes; ignorar derivada de g."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar equivalência algebricamente",
                                  "subSteps": [
                                    "Prove que se f(a)=0, então a = g(a): substitua e mostre igualdade.",
                                    "Prove o inverso: se a = g(a), então f(a)=0, expandindo x - g(x) = 0.",
                                    "Teste numericamente em pontos próximos às raízes para consistência.",
                                    "Identifique condições para equivalência (ex: g contínua e injetiva localmente).",
                                    "Registre provas em formato formal com equações."
                                  ],
                                  "verification": "Apresente provas bidirecionais mostrando equivalência exata.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de papel para provas algébricas, software de álgebra computacional.",
                                  "tips": "Use substituição direta: f(x) = x - g(x) para mostrar equivalência imediata.",
                                  "learningObjective": "Desenvolver rigor matemático em provas de equivalência funcional.",
                                  "commonMistakes": "Provar apenas um sentido; assumir sem provar unicidade das soluções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar equivalência graficamente",
                                  "subSteps": [
                                    "Plote y = f(x) e identifique interseções com eixo x (raízes).",
                                    "Plote y = x e y = g(x), identifique interseções (pontos fixos).",
                                    "Sobreponha gráficos de f(x) = x - g(x) com zeros e compare.",
                                    "Use zoom nas raízes para visualizar coincidência exata.",
                                    "Anote coordenadas das interseções e compare com raízes algébricas."
                                  ],
                                  "verification": "Gráficos mostram interseções coincidentes nas mesmas abscissas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de plotagem (Desmos, MATLAB, GeoGebra ou Python Matplotlib).",
                                  "tips": "Use escalas apropriadas e legendas claras para facilitar comparação.",
                                  "learningObjective": "Interpretar visualmente equivalências em métodos numéricos.",
                                  "commonMistakes": "Escalas inadequadas que mascaram coincidências; ignorar múltiplas raízes."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar resultados e testar em exemplo adicional",
                                  "subSteps": [
                                    "Compile tabela comparando raízes de f(x)=0 e pontos fixos de g(x).",
                                    "Teste em outra equação simples, ex: x² - x - 2 = 0, transformando adequadamente.",
                                    "Discuta limitações (ex: múltiplas raízes ou divergência).",
                                    "Conclua sobre equivalência geral da transformação.",
                                    "Prepare relatório resumido com gráficos e provas."
                                  ],
                                  "verification": "Tabela e conclusão confirmam equivalência em múltiplos casos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha Excel para tabelas, software de plotagem.",
                                  "tips": "Sempre teste com pelo menos dois exemplos para generalizar.",
                                  "learningObjective": "Integrar análises algébrica e gráfica para validação robusta.",
                                  "commonMistakes": "Generalizar de um exemplo sem teste adicional; omitir limitações."
                                }
                              ],
                              "practicalExample": "Para f(x) = x² - 3x + 2 = 0 (raízes x=1, x=2), transforme em x = g(x) = (x² + 2)/3. Verifique: g(1) = (1+2)/3=1, g(2)=(4+2)/3=2. Graficamente, interseções de y=x e y=g(x) ocorrem em x=1 e x=2, coincidentes com zeros de f(x).",
                              "finalVerifications": [
                                "Raízes de f(x)=0 satisfazem x=g(x).",
                                "Pontos fixos de g(x) satisfazem f(x)=0.",
                                "Provas algébricas bidirecionais documentadas.",
                                "Gráficos mostram coincidência visual exata.",
                                "Teste em exemplo adicional confirma generalidade.",
                                "Tabela resume comparações numéricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das raízes e pontos fixos calculados (erro < 10^-6).",
                                "Corretude das provas algébricas (lógica impecável).",
                                "Qualidade dos gráficos (clareza, escalas, legendas).",
                                "Profundidade da análise de convergência via g'(x).",
                                "Capacidade de generalizar para outros exemplos.",
                                "Relatório estruturado e completo."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar plots em Python/MATLAB para visualização.",
                                "Análise Numérica: Ligação com teorema do ponto fixo de Brouwer.",
                                "Física/Engenharia: Equilíbrios em estruturas civis modelados por não-lineares.",
                                "Estatística: Validação gráfica similar a testes de hipóteses visuais."
                              ],
                              "realWorldApplication": "Em engenharia civil, verificar se iterações de ponto fixo para equilíbrio de vigas ou fluxos hidráulicos convergem às soluções exatas de equações de deformação não-linear, evitando erros em projetos de pontes ou barragens."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Teorema do Ponto Fixo e Condições de Convergência",
                        "description": "Fundamentação teórica baseada no Teorema do Ponto Fixo de Banach, que garante a existência e unicidade de um ponto fixo e convergência da iteração se g(x) for uma contração em um intervalo fechado [a, b], com Lipschitz constante k < 1.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Aplicar o teorema de contração",
                            "description": "Verificar se g(x) satisfaz |g'(x)| ≤ k < 1 para todo x em [a, b], calculando o máximo de |g'(x)| e estimando o erro máximo após n iterações como |x_n - x^*| ≤ k^n / (1 - k) |x_1 - x_0|.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema, a função g(x) e o intervalo [a, b]",
                                  "subSteps": [
                                    "Identifique a equação não-linear f(x) = 0 a ser resolvida.",
                                    "Reformule f(x) = 0 como x = g(x), escolhendo uma forma adequada de g(x).",
                                    "Selecione um intervalo fechado [a, b] que contenha uma raiz aproximada de f(x) = 0.",
                                    "Verifique se g(x) é contínua e diferenciável em [a, b].",
                                    "Calcule g(a) e g(b) preliminarmente."
                                  ],
                                  "verification": "Confirme que [a, b] é fechado e finito, g é C1 em [a, b], e valores iniciais de g(a), g(b) estão definidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora gráfica",
                                    "Software como Python ou MATLAB (opcional)"
                                  ],
                                  "tips": "Escolha g(x) tal que a iteração intuitivamente convirja, como g(x) = x - λ f(x) com λ pequeno.",
                                  "learningObjective": "Preparar os elementos fundamentais para aplicação do teorema de contração.",
                                  "commonMistakes": "Escolher intervalo muito amplo onde g não é contração ou sem raiz; ignorar diferenciabilidade de g."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar se g mapeia [a, b] em si mesmo (g([a, b]) ⊆ [a, b])",
                                  "subSteps": [
                                    "Calcule g(a) e verifique se g(a) ≥ a.",
                                    "Calcule g(b) e verifique se g(b) ≤ b.",
                                    "Analise o comportamento de g em pontos críticos dentro de (a, b), resolvendo g'(x) = 0.",
                                    "Determine o mínimo e máximo de g(x) em [a, b] usando teorema dos valores extremos.",
                                    "Confirme que min g(x) ≥ a e max g(x) ≤ b."
                                  ],
                                  "verification": "Todos os valores extremos de g(x) em [a, b] satisfazem a ⊆ g([a, b]) ⊆ [a, b].",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora gráfica",
                                    "Gráfico de g(x) via software"
                                  ],
                                  "tips": "Plote g(x) - x para visualizar interseções e mapeamento.",
                                  "learningObjective": "Garantir a hipótese de espaço completo invariante no teorema do ponto fixo.",
                                  "commonMistakes": "Ignorar pontos críticos internos; assumir mapeamento só pelos extremos sem análise completa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular |g'(x)| e determinar a constante de Lipschitz k = sup_{[a,b]} |g'(x)|",
                                  "subSteps": [
                                    "Compute a derivada g'(x).",
                                    "Encontre os pontos onde |g'(x)| pode atingir máximo: extremos de |g'(x)| resolvendo (|g'(x)|)' = 0, e endpoints.",
                                    "Avalie |g'(x)| nesses pontos e identifique o supremo k.",
                                    "Verifique se k < 1.",
                                    "Se k ≥ 1, ajuste g(x) ou [a, b] e repita."
                                  ],
                                  "verification": "k é calculado corretamente como máximo de |g'(x)| em [a, b] e k < 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora gráfica",
                                    "Software para plotar |g'(x)|"
                                  ],
                                  "tips": "Use desigualdade média do valor para estimar sup |g'| se analítico difícil.",
                                  "learningObjective": "Aplicar condição suficiente de contração via derivada.",
                                  "commonMistakes": "Confundir sup |g'(x)| com |g'(ponto fixo)|; erro em cálculo de derivada segunda para extremos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estimar o erro máximo após n iterações e concluir convergência",
                                  "subSteps": [
                                    "Escolha x0 inicial em [a, b] e compute x1 = g(x0).",
                                    "Use a fórmula |x_n - x^*| ≤ (k^n / (1 - k)) |x1 - x0|.",
                                    "Calcule o erro bound para um n desejado (ex: n=10).",
                                    "Interprete o bound: quanto menor k, mais rápida convergência.",
                                    "Documente todas as verificações para relatório."
                                  ],
                                  "verification": "Fórmula de erro aplicada corretamente com valores numéricos consistentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha Excel ou Python para potências de k"
                                  ],
                                  "tips": "Comece com n pequeno para testar; k próximo de 0 acelera convergência.",
                                  "learningObjective": "Quantificar taxa de convergência e precisão do método.",
                                  "commonMistakes": "Usar fórmula errada (confundir com k^n |x0 - x^*|); esquecer fator 1/(1-k)."
                                }
                              ],
                              "practicalExample": "Na engenharia civil, para resolver x² = 2 (exemplo simplificado de cálculo de comprimento característico em estruturas), use g(x) = (x + 2/x)/2 no intervalo [1, 2]. Verifique: g([1,2]) = [√2 ≈1.414, 1.5] ⊆ [1,2]; g'(x) = 0.5(1 - 2/x²), |g'(x)| ≤ 0.5 = k <1 (máx em x=1); erro após n=10: |x_{10} - x^*| ≤ (0.5^{10}/0.5) |x1 - x0| ≈ 0.002 |x1 - x0|.",
                              "finalVerifications": [
                                "g([a,b]) ⊆ [a,b] confirmado com valores extremos.",
                                "k = sup |g'(x)| calculado corretamente e k < 1.",
                                "Fórmula de erro aplicada com valores numéricos precisos.",
                                "Ponto fixo único garantido pelo teorema.",
                                "Convergência linear com taxa k demonstrada.",
                                "Exemplo numérico inicial converge dentro do bound."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de g'(x) e k (exato ou com erro <1%).",
                                "Verificação completa de mapeamento do intervalo.",
                                "Correta aplicação da estimativa de erro.",
                                "Interpretação qualitativa da convergência.",
                                "Documentação clara com gráficos ou tabelas.",
                                "Identificação de ajustes se k ≥1."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Derivadas e teorema dos valores extremos.",
                                "Análise Numérica: Métodos iterativos e análise de erro.",
                                "Programação Computacional: Implementação em Python/MATLAB.",
                                "Álgebra Linear: Espaços completos e contrações métricas."
                              ],
                              "realWorldApplication": "Em engenharia civil, aplica-se em simulações numéricas de estruturas não-lineares, como cálculo iterativo de deslocamentos em vigas sob grandes deformações ou equilíbrio hidráulico em redes de tubulações, garantindo convergência rápida e controle de erro em softwares como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Analisar taxa de convergência",
                            "description": "Calcular a constante de Lipschitz k = sup |g'(x)| e prever o número de iterações necessárias para um erro tolerado ε, comparando com métodos lineares como bissecção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular a derivada g'(x) e determinar a constante de Lipschitz k",
                                  "subSteps": [
                                    "Identifique o intervalo [a, b] onde g(x) é contínua e g([a,b]) ⊆ [a,b].",
                                    "Calcule a derivada g'(x) analiticamente para a função g dada.",
                                    "Avalie |g'(x)| em pontos críticos e extremos do intervalo para encontrar sup |g'(x)| = k.",
                                    "Verifique se k < 1; caso contrário, ajuste g(x) ou intervalo."
                                  ],
                                  "verification": "Confirme que k = sup |g'(x)| < 1 com cálculo explícito ou gráfico de |g'(x)|.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, calculadora gráfica, software como Desmos ou Python (SymPy para derivadas simbólicas).",
                                  "tips": "Use o teorema do valor médio para justificar k = sup |g'(x)|.",
                                  "learningObjective": "Compreender a relação entre a derivada de g e a contração de Banach.",
                                  "commonMistakes": "Esquecer de considerar o supremo em todo o intervalo; calcular apenas em um ponto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar condições de convergência usando o teorema do ponto fixo",
                                  "subSteps": [
                                    "Confirme que g é contínua e diferenciável em [a,b].",
                                    "Verifique g([a,b]) ⊆ [a,b] avaliando g(a) e g(b).",
                                    "Use k < 1 para garantir convergência única para o ponto fixo p.",
                                    "Estime o erro inicial |x0 - p| ≤ (b - a)/2."
                                  ],
                                  "verification": "Liste as três condições do teorema e marque cada uma como satisfeita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de verificação, gráfico da função g(x) e f(x) = x.",
                                  "tips": "Plote g(x) e a reta y=x para visualização intuitiva.",
                                  "learningObjective": "Aplicar o teorema de Banach para validar convergência.",
                                  "commonMistakes": "Ignorar a condição g([a,b]) ⊆ [a,b]; assumir k < 1 sem cálculo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Prever o número de iterações N para erro tolerado ε",
                                  "subSteps": [
                                    "Lembre a estimativa de erro: |x_n - p| ≤ k^n / (1 - k) * diam([a,b]).",
                                    "Defina ε desejado (ex: 10^{-6}).",
                                    "Resolva k^N < ε (1 - k) para N ≈ log(ε (1 - k)) / log(k).",
                                    "Arredonde N para cima e teste iterativamente para confirmação.",
                                    "Registre N para diferentes ε."
                                  ],
                                  "verification": "Calcule N e simule primeiras iterações para ver se erro < ε em N passos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora ou Python/MATLAB para log e simulação.",
                                  "tips": "Use log na base natural ou comum; verifique log(k) < 0 já que k < 1.",
                                  "learningObjective": "Quantificar a taxa de convergência linear de ordem 1.",
                                  "commonMistakes": "Usar fórmula errada (confundir com quadrática); não arredondar para cima."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar taxa de convergência com o método da bissecção",
                                  "subSteps": [
                                    "Lembre que bissecção tem erro ≤ (b-a)/2^n, independente de f'.",
                                    "Calcule N_bissec para mesmo ε: n > log((b-a)/(2ε)) / log(2).",
                                    "Compare N_fixo vs N_bissec: avalie se k é pequeno o suficiente para vantagem.",
                                    "Discuta trade-offs: bissecção sempre converge, ponto fixo depende de g.",
                                    "Registre tabela comparativa."
                                  ],
                                  "verification": "Crie tabela com N, ε e método; grafique log(erros) vs n.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Planilha Excel ou Python para tabelas e gráficos.",
                                  "tips": "Bissecção é O(log(1/ε)), ponto fixo é O(log(1/ε)/|log k|).",
                                  "learningObjective": "Analisar eficiência relativa de métodos iterativos.",
                                  "commonMistakes": "Esquecer que bissecção requer f contínua e mudança de sinal."
                                }
                              ],
                              "practicalExample": "Em análise estrutural, resolva x = e^{-k x} para deslocamento em pilar sob carga (k=0.5, [0,2]). Calcule g(x)=e^{-0.5 x}, g'(x)=-0.5 e^{-0.5 x}, k≈0.5<1. Para ε=10^{-6}, N≈14 iterações vs 21 na bissecção.",
                              "finalVerifications": [
                                "k calculado corretamente com k < 1.",
                                "Número de iterações N previsto e validado por simulação.",
                                "Comparação quantitativa com bissecção (tabela ou gráfico).",
                                "Condições do teorema do ponto fixo explicitamente verificadas.",
                                "Erro final < ε após N iterações.",
                                "Gráfico de convergência mostrando taxa linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de k (erro < 1%).",
                                "Correção da fórmula de N (exata).",
                                "Análise comparativa profunda (fatores como dependência de g').",
                                "Uso adequado de ferramentas numéricas.",
                                "Clareza na documentação de passos e verificações.",
                                "Identificação de potenciais ajustes em g para melhor k."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise real (teorema do valor médio, contrações).",
                                "Computação: Implementação numérica em Python (loops iterativos, análise de erro).",
                                "Física/Engenharia: Modelagem de equações não-lineares em estruturas civis.",
                                "Estatística: Análise de convergência e intervalos de confiança para erros."
                              ],
                              "realWorldApplication": "Em engenharia civil, analisar convergência acelera simulações de equilíbrio não-linear em pontes ou barragens, prevendo iterações para precisão em deformações, otimizando tempo computacional vs métodos robustos como bissecção em softwares como ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Algoritmo de Iteração e Critérios de Parada",
                        "description": "Implementação prática do algoritmo iterativo x_{n+1} = g(x_n), com inicialização x_0, iterações até critério de parada baseado em erro absoluto, relativo ou diferença entre iterações sucessivas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Implementar o algoritmo em pseudocódigo",
                            "description": "Escrever pseudocódigo completo para o método, incluindo escolha de x_0, tolerância ε, máximo de iterações N_max, e loop com atualização x_{n+1} = g(x_n) e verificação de |x_{n+1} - x_n| < ε.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os Parâmetros Iniciais do Algoritmo",
                                  "subSteps": [
                                    "Relembrar a forma do problema de ponto fixo: dada f(x) = 0, reescrevê-la como x = g(x).",
                                    "Selecionar um chute inicial x_0 próximo à solução estimada, baseado em análise gráfica ou conhecimento do problema.",
                                    "Definir a tolerância ε (ex: 10^{-6}) para o critério de convergência |x_{n+1} - x_n| < ε.",
                                    "Estabelecer o número máximo de iterações N_max (ex: 100) para evitar loops infinitos.",
                                    "Documentar todos os parâmetros com justificativa breve."
                                  ],
                                  "verification": "Verifique se todos os parâmetros (x_0, ε, N_max, g(x)) estão listados com valores exemplo e justificativas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráfico da função g(x)",
                                    "Referência teórica do método"
                                  ],
                                  "tips": "Escolha x_0 dentro do intervalo de atração do ponto fixo para garantir convergência rápida.",
                                  "learningObjective": "Identificar e justificar os parâmetros essenciais para inicializar o algoritmo de iteração de ponto fixo.",
                                  "commonMistakes": [
                                    "Escolher ε muito pequeno causando não convergência prática",
                                    "Definir N_max baixo ignorando problemas de convergência lenta",
                                    "Não especificar g(x) claramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar a Inicialização no Pseudocódigo",
                                  "subSteps": [
                                    "Iniciar o pseudocódigo com cabeçalho: ALGORITMO_PONTO_FIXO(g, x0, ε, N_max).",
                                    "Declarar variáveis: x_atual ← x0, n ← 0, convergiu ← falso.",
                                    "Incluir comentários explicando cada declaração.",
                                    "Adicionar entrada de parâmetros via input ou parâmetros de função.",
                                    "Testar sintaxe básica escrevendo apenas esta seção."
                                  ],
                                  "verification": "Execute mentalmente a inicialização com valores exemplo; confirme que x_atual = x0 e n=0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto simples",
                                    "Modelo de pseudocódigo padrão"
                                  ],
                                  "tips": "Use convenções claras como ← para atribuição e indentação para blocos.",
                                  "learningObjective": "Criar a estrutura inicial robusta do pseudocódigo com declarações de variáveis corretas.",
                                  "commonMistakes": [
                                    "Confundir atribuição com comparação",
                                    "Esquecer de inicializar o contador n",
                                    "Não declarar flag de convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Loop Principal de Iteração",
                                  "subSteps": [
                                    "Iniciar loop ENQUANTO n < N_max E não convergiu FAÇA.",
                                    "Calcular x_proxima ← g(x_atual).",
                                    "Verificar diferença: diff ← |x_proxima - x_atual|.",
                                    "Se diff < ε, então convergiu ← verdadeiro.",
                                    "Atualizar x_atual ← x_proxima e n ← n + 1.",
                                    "Incrementar contador fora da verificação condicional."
                                  ],
                                  "verification": "Simule 3 iterações manualmente; confirme que x_atual é atualizado corretamente e diff calculada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Função g(x) exemplo"
                                  ],
                                  "tips": "Priorize a condição de parada dentro do loop para eficiência.",
                                  "learningObjective": "Codificar logicamente o coração do algoritmo: iteração e verificação incremental.",
                                  "commonMistakes": [
                                    "Atualizar n antes da verificação de convergência",
                                    "Usar diferença errada como |g(x)-x| em vez de |x_{n+1}-x_n|",
                                    "Loop infinito por falta de incremento de n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar com Critérios de Parada e Saída",
                                  "subSteps": [
                                    "Fechar o loop e adicionar saída: SE convergiu ENTÃO retornar x_atual como solução.",
                                    "SENÃO, reportar 'Não convergiu em N_max iterações' e retornar x_atual ou erro.",
                                    "Incluir saída de resultados: imprimir n, x_atual, diff final.",
                                    "Adicionar comentários finais resumindo o algoritmo.",
                                    "Revisar todo o pseudocódigo por completude e lógica."
                                  ],
                                  "verification": "Rode simulação completa até parada; confirme saída correta em casos de convergência e não-convergência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo completo anterior",
                                    "Casos teste: convergente e não-convergente"
                                  ],
                                  "tips": "Sempre inclua tratamento de falha para robustez em aplicações reais.",
                                  "learningObjective": "Completar o algoritmo com saídas claras e manuseio de exceções.",
                                  "commonMistakes": [
                                    "Não tratar caso de não-convergência",
                                    "Retornar valor incorreto após loop",
                                    "Falta de saída informativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver a equação de equilíbrio em uma viga não-linear x = 0.5 * sin(x) + 0.2 * x^2 (modelando deformação), defina g(x) = 0.5 * sin(x) + 0.2 * x^2, x0=0.1, ε=10^{-5}, N_max=50. Escreva o pseudocódigo completo e simule as primeiras 5 iterações manualmente, anotando x_n e diff.",
                              "finalVerifications": [
                                "Pseudocódigo inclui declaração explícita de x0, ε, N_max e função g.",
                                "Loop atualiza x_{n+1} = g(x_n) e verifica |x_{n+1} - x_n| < ε.",
                                "Contador n incrementa corretamente e respeita N_max.",
                                "Saída diferencia convergência de falha, retornando x_final e iterações usadas.",
                                "Comentários explicam cada seção principal.",
                                "Simulação manual com exemplo converge ou para corretamente."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todos elementos do algoritmo presentes (95-100%).",
                                "Correção lógica: Loop e condições implementados sem erros (90-100%).",
                                "Clareza e legibilidade: Sintaxe pseudocódigo padrão, indentação e comentários (85-95%).",
                                "Robustez: Tratamento de não-convergência e saídas informativas (80-90%).",
                                "Precisão na descrição de g(x) e critérios de parada (90-100%).",
                                "Adequação ao contexto de engenharia civil (ex: relevância de g(x))."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica e convergência de sequências.",
                                "Programação: Estruturas de loop, condicionais e funções em pseudocódigo.",
                                "Engenharia Civil: Modelagem de problemas não-lineares em estruturas e solos.",
                                "Física: Equações de equilíbrio dinâmico aproximadas por iterações.",
                                "Computação Científica: Implementação em linguagens como Python ou MATLAB."
                              ],
                              "realWorldApplication": "Na engenharia civil, o algoritmo de iteração de ponto fixo é usado para resolver equações não-lineares em análise de estruturas, como calcular deformações em cabos de suspensão ou recalques em fundações de solo, onde modelos lineares falham, permitindo simulações precisas em softwares como ANSYS ou SAP2000."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Aplicar critérios de parada",
                            "description": "Implementar e comparar critérios como erro absoluto |x_{n+1} - x_n| < ε, erro relativo |x_{n+1} - x_n| / |x_{n+1}| < ε, ou resíduo |f(x_{n+1})| < ε, em problemas de engenharia civil como equilíbrio de estruturas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Tipos de Critérios de Parada",
                                  "subSteps": [
                                    "Estude a definição de erro absoluto: |x_{n+1} - x_n| < ε",
                                    "Analise o erro relativo: |x_{n+1} - x_n| / |x_{n+1}| < ε",
                                    "Revise o critério de resíduo: |f(x_{n+1})| < ε",
                                    "Compare vantagens e desvantagens de cada critério em contextos numéricos",
                                    "Identifique quando usar cada um em problemas não-lineares"
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre os três critérios e dê um exemplo numérico simples para cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre métodos numéricos, calculadora ou software como MATLAB/Python",
                                  "tips": "Use ε = 10^{-6} como valor padrão inicial para testes.",
                                  "learningObjective": "Diferenciar e explicar os três principais critérios de parada em iterações numéricas.",
                                  "commonMistakes": "Confundir erro absoluto com relativo; ignorar que erro relativo evita problemas com escalas grandes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Critérios no Algoritmo de Iteração de Ponto Fixo",
                                  "subSteps": [
                                    "Escreva o pseudocódigo básico da iteração de ponto fixo: x_{n+1} = g(x_n)",
                                    "Incorpore o loop de verificação para erro absoluto dentro do algoritmo",
                                    "Adicione condições para erro relativo e resíduo como opções selecionáveis",
                                    "Defina parâmetros iniciais: x_0, ε, máximo de iterações (ex: 1000)",
                                    "Teste o pseudocódigo manualmente com valores iniciais simples"
                                  ],
                                  "verification": "Execute o pseudocódigo à mão para 5 iterações e confirme que o critério para corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de texto para pseudocódigo, papel e lápis para simulação manual",
                                  "tips": "Estruture o algoritmo com um flag booleano para alternar entre critérios.",
                                  "learningObjective": "Integrar múltiplos critérios de parada em um algoritmo iterativo funcional.",
                                  "commonMistakes": "Esquecer de inicializar contadores de iterações; usar |x_n| em vez de |x_{n+1}| no erro relativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar e Testar os Critérios em um Exemplo Simples",
                                  "subSteps": [
                                    "Implemente o algoritmo em Python ou MATLAB com funções para cada critério",
                                    "Teste com g(x) = cos(x) + x/2, x_0 = 1, ε = 10^{-8}",
                                    "Registre número de iterações e valor final para cada critério",
                                    "Compare resultados: convergência, precisão e eficiência",
                                    "Gere gráficos de x_n vs. n para visualizar convergência"
                                  ],
                                  "verification": "Código roda sem erros e produz resultados com erro < ε para todos critérios.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (NumPy/Matplotlib) ou MATLAB, computador",
                                  "tips": "Use print statements para logar iterações e valores de erro.",
                                  "learningObjective": "Implementar e validar critérios de parada em código computacional.",
                                  "commonMistakes": "Dividir por zero no erro relativo (verifique se x_{n+1} ≠ 0); exceder iterações máximas sem aviso."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Problemas de Engenharia Civil: Equilíbrio de Estruturas",
                                  "subSteps": [
                                    "Modele um problema não-linear simples: equilíbrio de uma treliça com deformação geométrica não-linear",
                                    "Formule g(x) derivado da equação de equilíbrio: ex. x_{n+1} = (P - k*x_n^2)/c",
                                    "Implemente o algoritmo completo com escolha de critério",
                                    "Compare critérios: analise impacto na precisão da deformação calculada",
                                    "Valide contra solução analítica ou software de referência"
                                  ],
                                  "verification": "Solução converge para todos critérios e deformação final está dentro de 1% da referência.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software de programação, dados do problema (P=10kN, k=1000N/m, c=500N/m)",
                                  "tips": "Escolha ε baseado na tolerância de engenharia (ex: 10^{-4} para deslocamentos em mm).",
                                  "learningObjective": "Aplicar critérios de parada em modelagem real de estruturas civis.",
                                  "commonMistakes": "Não linearizar corretamente a equação de equilíbrio; ignorar unidades inconsistentes."
                                }
                              ],
                              "practicalExample": "Em uma treliça simples sob carga P=10kN, resolva a equação não-linear de deslocamento δ: P = k*δ + c*δ^3 usando iteração de ponto fixo g(δ) = (P - c*δ^3)/k. Implemente com ε=10^{-5}, compare critérios: erro absoluto para δ<1mm, relativo para escalabilidade, resíduo para fidelidade à equação original. Resultado: δ≈0.015m após 12-18 iterações dependendo do critério.",
                              "finalVerifications": [
                                "Algoritmo implementado corretamente para todos três critérios",
                                "Testes com exemplo simples convergem dentro de ε especificado",
                                "Aplicação em estrutura converge e resultados validados",
                                "Comparação quantitativa de iterações e precisão entre critérios",
                                "Gráficos de convergência gerados e analisados",
                                "Código comentado e reutilizável"
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erros finais < ε para todos testes (peso 25%)",
                                "Eficiência: Diferença <20% em iterações entre critérios (peso 20%)",
                                "Implementação: Código limpo, modular e sem bugs (peso 20%)",
                                "Análise: Comparação clara com tabelas/gráficos (peso 15%)",
                                "Aplicação contextual: Adequação ao problema de estruturas (peso 10%)",
                                "Documentação: Explicação de escolhas de ε e g(x) (peso 10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Análise de convergência de métodos iterativos",
                                "Programação Computacional: Implementação de loops e condicionais em Python/MATLAB",
                                "Engenharia Estrutural: Modelagem não-linear de equilíbrio",
                                "Estatística: Avaliação de incertezas em critérios de parada",
                                "Física: Princípios de estática e deformação em materiais"
                              ],
                              "realWorldApplication": "Em análises não-lineares de edifícios altos ou pontes (ex: software ETABS/ANSYS), critérios de parada garantem convergência eficiente em simulações de vento ou sismos, evitando iterações excessivas que aumentam tempo computacional em projetos reais de engenharia civil."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Resolver problemas numéricos aplicados",
                            "description": "Aplicar o método a equações não-lineares reais da engenharia civil, como f(x) = x^3 - 2x - 5 = 0 para cargas em vigas, registrando iterações, erros e validando com soluções conhecidas ou software como MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o problema para iteração de ponto fixo",
                                  "subSteps": [
                                    "Identifique a equação não-linear f(x) = 0 do problema real de engenharia civil, como f(x) = x^3 - 2x - 5 = 0 representando cargas em vigas.",
                                    "Reformule f(x) = 0 na forma x = g(x), escolhendo uma g(x) que garanta convergência (|g'(x)| < 1 na vizinhança da raiz).",
                                    "Selecione um chute inicial x0 próximo da raiz estimada, baseado em análise gráfica ou conhecimento do problema.",
                                    "Defina tolerância de erro (ex: 10^-6) e número máximo de iterações (ex: 100).",
                                    "Registre os parâmetros iniciais em uma tabela."
                                  ],
                                  "verification": "Confirme que g(x) está definida corretamente e |g'(x)| < 1 calculado em pontos próximos à raiz esperada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora gráfica, software como MATLAB ou Python para plotar f(x) e g(x).",
                                  "tips": "Teste múltiplas formas de g(x) se a primeira não convergir rapidamente.",
                                  "learningObjective": "Compreender como transformar equações não-lineares em problemas de ponto fixo adequados para iteração.",
                                  "commonMistakes": "Escolher g(x) com derivada maior que 1 em módulo, levando a divergência; ignorar análise inicial da raiz."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o algoritmo de iteração",
                                  "subSteps": [
                                    "Escreva o pseudocódigo ou código em MATLAB/Python: enquanto erro > tolerância e iterações < max, compute x_{n+1} = g(x_n).",
                                    "Inicialize x_n = x0 e crie colunas para n, x_n, g(x_n), erro absoluto |x_{n+1} - x_n|.",
                                    "Programe cálculo de erro relativo ou absoluto em cada iteração.",
                                    "Inclua critério de parada: erro < tol ou iterações excedidas.",
                                    "Teste o código com valores iniciais simples para depuração."
                                  ],
                                  "verification": "Execute uma iteração manual e compare com o código para matching exato.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (MATLAB, Python/Jupyter), computador.",
                                  "tips": "Use loops while para controle preciso e vetores para armazenar histórico de iterações.",
                                  "learningObjective": "Dominar a codificação do método de iteração de ponto fixo com critérios de parada.",
                                  "commonMistakes": "Confundir erro absoluto com relativo; não inicializar variáveis corretamente causando loops infinitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações e registrar dados",
                                  "subSteps": [
                                    "Rode o algoritmo para o problema f(x) = x^3 - 2x - 5 = 0 com x0 = 2 (raiz ≈2.094).",
                                    "Registre pelo menos 10 iterações ou até convergência, anotando x_n, erro e g(x_n) em tabela.",
                                    "Plote a convergência: gráfico de x_n vs n e erro vs n.",
                                    "Analise velocidade de convergência observando redução do erro.",
                                    "Salve resultados em arquivo ou screenshot."
                                  ],
                                  "verification": "Tabela completa com convergência para raiz conhecida (verifique se x_final ≈ 2.094).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem (MATLAB plot, Python matplotlib), tabela em Excel.",
                                  "tips": "Escolha x0 que acelere convergência; monitore erro a cada 2-3 iterações.",
                                  "learningObjective": "Executar iterações numéricas e visualizar padrões de convergência em problemas reais.",
                                  "commonMistakes": "Arredondamentos excessivos em cálculos manuais; parar iterações prematuramente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar erros e validar solução",
                                  "subSteps": [
                                    "Calcule erro verdadeiro comparando x_final com raiz exata ou solução analítica aproximada.",
                                    "Valide substituindo x_final em f(x) e confirme |f(x_final)| < tol.",
                                    "Compare resultados com software padrão como fsolve no MATLAB.",
                                    "Discuta razões de divergência se ocorrer e ajuste g(x).",
                                    "Documente conclusões em relatório curto."
                                  ],
                                  "verification": "Relatório mostra |f(x_final)| < 10^-6 e matching com MATLAB dentro de 10^-5.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "MATLAB ou equivalente para validação, documento Word/PDF.",
                                  "tips": "Sempre valide numericamente com f(x) = 0 como métrica final.",
                                  "learningObjective": "Avaliar precisão numérica e validar soluções computacionais.",
                                  "commonMistakes": "Ignorar validação externa; confundir erro de iteração com erro verdadeiro."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e generalizar para problemas de engenharia civil",
                                  "subSteps": [
                                    "Aplique o método a outro problema similar, como equilíbrio de forças em estruturas.",
                                    "Adapte parâmetros (tol, max_iter) baseado no contexto físico.",
                                    "Discuta limitações do método em cenários reais (ex: não-linearidades fortes).",
                                    "Crie função reutilizável em código para múltiplas equações.",
                                    "Registre lições aprendidas para problemas futuros."
                                  ],
                                  "verification": "Solução de problema adicional converge e é validada corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código anterior, novos dados de engenharia civil.",
                                  "tips": "Use unidades físicas consistentes ao interpretar resultados.",
                                  "learningObjective": "Generalizar o método para aplicações práticas em engenharia.",
                                  "commonMistakes": "Não considerar contexto físico, levando a chutes iniciais ruins."
                                }
                              ],
                              "practicalExample": "Para cargas distribuídas em vigas cantilever, resolva f(x) = x^3 - 2x - 5 = 0 onde x representa deflexão máxima. Reformule como x = (x^3 - 5)^{1/2} + algo ajustado, inicie com x0=2, itere até erro<10^-6, valide com MATLAB fsolve obtendo x≈2.094, confirmando deflexão segura < limite estrutural.",
                              "finalVerifications": [
                                "Tabela de iterações completa com pelo menos 8-10 linhas mostrando convergência.",
                                "|f(x_final)| < tolerância especificada.",
                                "Gráficos de convergência plotados e analisados.",
                                "Matching com solução de software externo dentro de 0.1%.",
                                "Relatório documenta g(x), parâmetros e lições.",
                                "Código executável e comentado fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão da reformulação em g(x) e escolha de x0 (30%).",
                                "Correção do algoritmo e registro de erros (25%).",
                                "Análise de convergência e validação (20%).",
                                "Generalização e aplicação real (15%).",
                                "Clareza de documentação e gráficos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em MATLAB/Python reforça competências computacionais.",
                                "Física/Estruturas: Modelagem de cargas em vigas conecta com mecânica dos materiais.",
                                "Matemática Numérica: Integra com análise de erros e métodos iterativos.",
                                "Engenharia de Software: Boas práticas de codificação e depuração."
                              ],
                              "realWorldApplication": "Em engenharia civil, resolve equações para deflexões em vigas, tensões em cabos ou equilíbrio hidráulico em barragens, permitindo simulações rápidas sem solvers proprietários caros, otimizando projetos de pontes e edifícios."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Ajuste de Curvas",
                "description": "Métodos para ajustar funções a conjuntos de dados experimentais.",
                "totalSkills": 51,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Método dos Mínimos Quadrados Lineares",
                    "description": "Técnica para ajustar uma função linear a dados experimentais minimizando a soma dos quadrados dos resíduos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.1.1",
                        "name": "Resíduos e Função Objetivo",
                        "description": "Compreender os resíduos como diferenças entre valores observados e preditos, e a minimização da soma dos quadrados dos resíduos como função objetivo no ajuste linear.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.1",
                            "name": "Calcular resíduos em dados experimentais",
                            "description": "Dado um conjunto de dados experimentais (x_i, y_i) e um modelo linear y = a + b x, calcular os resíduos e_i = y_i - (a + b x_i) para cada ponto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados experimentais e parâmetros do modelo",
                                  "subSteps": [
                                    "Receba o conjunto de dados experimentais com pares (x_i, y_i) para i = 1 a n.",
                                    "Identifique os parâmetros do modelo linear: intercepto a e inclinação b.",
                                    "Organize os dados em uma tabela com colunas para x_i, y_i, y_hat_i (a ser calculado) e e_i (a ser calculado).",
                                    "Verifique se todos os valores estão corretos e sem erros de digitação.",
                                    "Anote o número de pontos de dados n."
                                  ],
                                  "verification": "Confirme que a tabela está completa com x_i e y_i listados corretamente e a, b anotados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou planilha Excel/Google Sheets",
                                    "Conjunto de dados experimentais fornecido"
                                  ],
                                  "tips": "Use uma planilha para facilitar cálculos repetitivos; rotule claramente cada coluna.",
                                  "learningObjective": "Compreender a estrutura dos dados e preparar o ambiente para cálculos precisos.",
                                  "commonMistakes": [
                                    "Confundir x_i com y_i",
                                    "Usar valores errados de a ou b do modelo ajustado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os valores preditos y_hat_i para cada ponto",
                                  "subSteps": [
                                    "Para cada i, calcule y_hat_i = a + b * x_i usando a fórmula do modelo linear.",
                                    "Registre y_hat_i na tabela ao lado de cada x_i e y_i.",
                                    "Use uma calculadora ou função de planilha para precisão decimal.",
                                    "Repita para todos os n pontos de dados.",
                                    "Arredonde para o mesmo número de casas decimais dos dados originais (ex: 2 decimais)."
                                  ],
                                  "verification": "Some todos y_hat_i e compare com soma esperada se fornecida; verifique se y_hat_1 = a + b*x_1 manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica ou planilha com fórmulas",
                                    "Tabela preparada no step 1"
                                  ],
                                  "tips": "Copie a fórmula y_hat = $A$1 + $B$1 * x_i em planilhas para auto-preenchimento.",
                                  "learningObjective": "Dominar o cálculo das predições do modelo linear para dados experimentais.",
                                  "commonMistakes": [
                                    "Erro aritmético em multiplicação b*x_i",
                                    "Esquecer de adicionar o intercepto a"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os resíduos e_i para cada ponto",
                                  "subSteps": [
                                    "Para cada i, calcule e_i = y_i - y_hat_i.",
                                    "Registre e_i na tabela correspondente.",
                                    "Preste atenção aos sinais: resíduos positivos se y_i > y_hat_i.",
                                    "Verifique cálculos cruzando: e_i + y_hat_i deve igualar y_i.",
                                    "Calcule estatísticas básicas opcionais: média dos e_i (deve ser próxima de zero)."
                                  ],
                                  "verification": "Para cada ponto, confirme e_i = y_i - (a + b*x_i) manualmente em pelo menos 2 pontos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou planilha",
                                    "Tabela com y_hat_i preenchida"
                                  ],
                                  "tips": "Resíduos pequenos indicam bom ajuste; sinais alternados são ideais.",
                                  "learningObjective": "Aplicar a definição exata de resíduo e interpretá-lo como erro de predição.",
                                  "commonMistakes": [
                                    "Inverter a subtração (y_hat - y)",
                                    "Ignorar sinais negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar os resíduos calculados",
                                  "subSteps": [
                                    "Liste todos os e_i em uma coluna final da tabela.",
                                    "Calcule a soma dos resíduos (deve ser próxima de zero em MQL).",
                                    "Identifique o resíduo máximo em valor absoluto e seu ponto.",
                                    "Crie um gráfico simples de e_i vs x_i para visualizar padrões.",
                                    "Registre observações sobre homocedasticidade ou heterocedasticidade."
                                  ],
                                  "verification": "Soma dos e_i ≈ 0 e gráfico sem padrões óbvios (aleatório).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha com gráficos ou papel milimetrado",
                                    "Tabela completa"
                                  ],
                                  "tips": "Use scatter plot em Excel para e_i vs x_i; procure por funnel shape (problema).",
                                  "learningObjective": "Interpretar resíduos como diagnóstico do modelo de regressão.",
                                  "commonMistakes": [
                                    "Não verificar soma dos resíduos",
                                    "Interpretar erroneamente padrões no gráfico"
                                  ]
                                }
                              ],
                              "practicalExample": "Dados experimentais de testes de compressão em concreto: x = [1, 2, 3, 4] (cargas em kN), y = [2.5, 4.0, 5.6, 7.1] (deformações em mm). Modelo ajustado: y = 0.2 + 1.6x. Cálculos: y_hat = [1.8, 3.4, 5.0, 6.6]; e = [0.7, 0.6, 0.6, 0.5].",
                              "finalVerifications": [
                                "Todos os e_i foram calculados corretamente usando e_i = y_i - (a + b x_i).",
                                "Sinais e magnitudes dos resíduos correspondem aos dados de exemplo.",
                                "Soma dos resíduos é aproximadamente zero.",
                                "Tabela completa com x_i, y_i, y_hat_i e e_i.",
                                "Gráfico de resíduos vs x_i mostra dispersão aleatória.",
                                "Identificados resíduos máximo e mínimo."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erro < 0.01).",
                                "Uso correto da fórmula de resíduo em todos os pontos.",
                                "Organização clara da tabela de dados.",
                                "Interpretação adequada dos resíduos (ex: diagnóstico de ajuste).",
                                "Verificação de soma dos resíduos e análise gráfica.",
                                "Tempo de execução dentro do estimado total (70 minutos)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceitos de erro e regressão linear.",
                                "Programação: Implementação em Python (numpy) ou Excel para automação.",
                                "Física Experimental: Análise de dados de ensaios laboratoriais.",
                                "Matemática: Álgebra linear e operações matriciais implícitas."
                              ],
                              "realWorldApplication": "Em engenharia civil, calcular resíduos valida modelos de regressão em testes de materiais (ex: curva tensão-deformação em concreto), identificando se o modelo linear é adequado ou se falhas experimentais existem, essencial para projetos estruturais seguros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2",
                            "name": "Formular a soma dos quadrados dos resíduos",
                            "description": "Escrever a expressão matemática S = Σ e_i² e explicar por que minimizá-la leva ao melhor ajuste linear em termos de critério de mínimos quadrados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de resíduos em regressão linear",
                                  "subSteps": [
                                    "Defina resíduo e_i como a diferença entre o valor observado y_i e o valor predito ŷ_i da reta de ajuste: e_i = y_i - ŷ_i.",
                                    "Interprete graficamente: plote pontos de dados e a reta de regressão, destacando as distâncias verticais (resíduos).",
                                    "Discuta a importância: resíduos medem o erro do modelo; zero ideal significa ajuste perfeito.",
                                    "Exemplo simples: dados de altura vs peso, calcule e_i para 3 pontos manualmente.",
                                    "Relacione com engenharia civil: resíduos em medições de deformação de vigas sob carga."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é um resíduo e dê um exemplo numérico com cálculo correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Gráfico impresso ou software como GeoGebra/Excel com dados de exemplo",
                                    "Dados de amostra: (x,y) = (1,2), (2,3.1), (3,5)"
                                  ],
                                  "tips": "Sempre visualize graficamente; use regla para medir distâncias em plots manuais.",
                                  "learningObjective": "Dominar a definição e interpretação gráfica de resíduos como erros de predição.",
                                  "commonMistakes": [
                                    "Confundir resíduo com distância euclidiana (use apenas vertical)",
                                    "Ignorar sinal do resíduo (pode cancelar somas)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a soma dos resíduos ao quadrado",
                                  "subSteps": [
                                    "Escreva a expressão S = Σ_{i=1}^n e_i², onde n é o número de observações.",
                                    "Expanda para o contexto linear: ŷ_i = a + b x_i, então e_i = y_i - (a + b x_i).",
                                    "Calcule manualmente S para um conjunto pequeno de dados (3-5 pontos).",
                                    "Verifique unidades: quadrados garantem S positivo e em unidades ao quadrado de y.",
                                    "Pratique notação: use subscrito i para cada ponto de dados."
                                  ],
                                  "verification": "Escreva corretamente a fórmula S e compute para dados dados: confirme valor numérico exato.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Excel",
                                    "Folha com dados de exemplo de engenharia: deformação vs tempo em viga",
                                    "Quadro branco para derivação"
                                  ],
                                  "tips": "Comece com n=2 para simplicidade antes de expandir.",
                                  "learningObjective": "Escrever e calcular a função objetivo S de forma precisa.",
                                  "commonMistakes": [
                                    "Esquecer o expoente 2 (leva a soma que pode ser zero)",
                                    "Usar |e_i| em vez de e_i² (muda o critério)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar por que usar quadrados nos resíduos",
                                  "subSteps": [
                                    "Discuta propriedades: quadrados tornam todos resíduos positivos, evitam cancelamentos, penalizam erros grandes mais.",
                                    "Compare com soma absoluta Σ|e_i|: menos diferenciador para outliers.",
                                    "Relacione com derivabilidade: S é suave, permite cálculo analítico de mínimos via derivadas.",
                                    "Exemplo numérico: compare S com Σ e_i e Σ|e_i| para mesmos dados com outlier.",
                                    "Contexto engenharia: em ajustes de curvas de carga, outliers (medições ruins) devem pesar mais."
                                  ],
                                  "verification": "Justifique em parágrafo por que quadrados são preferidos, com exemplo comparativo correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela comparativa em Excel",
                                    "Gráfico mostrando impacto de outlier em diferentes somas"
                                  ],
                                  "tips": "Pense em otimização: quadrados criam 'parábola' fácil de minimizar.",
                                  "learningObjective": "Entender as vantagens matemáticas e práticas do quadrado.",
                                  "commonMistakes": [
                                    "Achar que quadrados são arbitrários (são padrão por razões estatísticas)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar a minimização de S como critério de melhores quadrados",
                                  "subSteps": [
                                    "Defina: o melhor ajuste é a + b que minimiza S (menor erro quadrático médio).",
                                    "Intuição: S=0 perfeito; menor S = melhor predição em média quadrática.",
                                    "Derive brevemente: ∂S/∂a = 0 e ∂S/∂b = 0 levam às fórmulas normais.",
                                    "Verifique com software: ajuste linha em dados e veja resíduos somados.",
                                    "Aplicação: em engenharia civil, minimizar S para calibrar modelo de regressão em ensaios de materiais."
                                  ],
                                  "verification": "Descreva o processo de minimização e confirme com cálculo que parâmetros reduzem S.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software Python/MATLAB com leastsq ou Excel Solver",
                                    "Dados reais de tração em concreto"
                                  ],
                                  "tips": "Use gradiente descendente mentalmente: mova reta para reduzir S.",
                                  "learningObjective": "Compreender por que argmin S define o 'melhor' ajuste linear.",
                                  "commonMistakes": [
                                    "Confundir com média aritmética (S minimiza MSE, não MAE)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ensaio de compressão de pilares de concreto, dados: carga (x_i em kN) vs deformação (y_i em mm). Plote pontos, ajuste reta ŷ = a + b x, calcule e_i para cada, some e_i² = S ≈ 0.045. Minimize S variando a,b para prever deformação segura.",
                              "finalVerifications": [
                                "Escreve corretamente S = Σ e_i² com notação precisa.",
                                "Calcula S numericamente para 5 pontos com erro <1%.",
                                "Explica graficamente resíduos e por que quadrados.",
                                "Justifica minimização verbalmente sem erros.",
                                "Aplica a dados de engenharia civil com interpretação correta.",
                                "Compara S antes/depois de ajuste ótimo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática (100% correta).",
                                "Profundidade na justificativa dos quadrados (cobre propriedades chave).",
                                "Correção nos cálculos numéricos (erro <0.01).",
                                "Clareza na explicação intuitiva e gráfica.",
                                "Relevância ao contexto de engenharia (exemplo prático).",
                                "Compreensão da minimização (menciona derivadas ou intuição)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: relação com variância e erro quadrático médio (MSE).",
                                "Programação: implementação em Python (numpy.polyfit) ou MATLAB.",
                                "Física: modelagem de leis lineares em materiais (Hooke).",
                                "Cálculo: otimização via derivadas parciais.",
                                "Engenharia de Software: validação de modelos preditivos."
                              ],
                              "realWorldApplication": "Na engenharia civil, formula S para ajustar curvas de degradação de estruturas sob fadiga (ex: pontes), calibrar sensores em monitoramento SHM (Structural Health Monitoring), ou regressão em dados de solos para previsão de assentamentos, garantindo modelos precisos para segurança e design."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3",
                            "name": "Interpretar propriedades dos resíduos",
                            "description": "Analisar resíduos para verificar pressupostos como independência, homocedasticidade e normalidade, identificando possíveis violações no ajuste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular e visualizar resíduos do modelo de mínimos quadrados lineares",
                                  "subSteps": [
                                    "Ajuste o modelo de regressão linear aos dados usando software como Python (statsmodels) ou R.",
                                    "Extraia os resíduos padronizados: resíduo = (y_observado - y_predito) / desvio_padrão.",
                                    "Gere plots iniciais: resíduos vs. valores ajustados, resíduos vs. ordem de observação e histograma de resíduos.",
                                    "Salve os gráficos em alta resolução para análise posterior.",
                                    "Documente os valores médios e desvios dos resíduos."
                                  ],
                                  "verification": "Confirme que os plots foram gerados sem erros e que a média dos resíduos é próxima de zero.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (bibliotecas: statsmodels, matplotlib, seaborn), Jupyter Notebook, conjunto de dados de exemplo (ex: teste de compressão de concreto).",
                                  "tips": "Use resíduos padronizados para facilitar comparações entre observações.",
                                  "learningObjective": "Compreender o cálculo e visualização básica de resíduos para diagnóstico inicial.",
                                  "commonMistakes": "Confundir resíduos brutos com padronizados; ignorar outliers nos plots iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar independência dos resíduos",
                                  "subSteps": [
                                    "Plote resíduos ordenados vs. índice de tempo/ordem de coleta.",
                                    "Procure por padrões como autocorrelação (ex: tendências lineares ou cíclicas).",
                                    "Aplique teste de Durbin-Watson para quantificar autocorrelação.",
                                    "Interprete p-valor: p > 0.05 sugere independência.",
                                    "Registre qualquer evidência de dependência temporal ou espacial."
                                  ],
                                  "verification": "O teste de Durbin-Watson retorna valor entre 1.5-2.5 e ausência de padrões visuais nos plots.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (statsmodels.durbin_watson), R (dwtest), dados com possível estrutura temporal.",
                                  "tips": "Em dados de engenharia civil, considere ordem de coleta em experimentos sequenciais.",
                                  "learningObjective": "Identificar violações de independência e seu impacto em inferências.",
                                  "commonMistakes": "Assumir independência sem plotar vs. ordem; ignorar dados não estacionários."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar homocedasticidade dos resíduos",
                                  "subSteps": [
                                    "Plote resíduos vs. valores ajustados (fitted values).",
                                    "Verifique dispersão constante: procure funil (heterocedasticidade) ou padrões quadráticos.",
                                    "Aplique teste de Breusch-Pagan ou White para confirmar.",
                                    "Se violado, explore transformações como log ou Box-Cox.",
                                    "Documente o p-valor e conclusão visual."
                                  ],
                                  "verification": "Plot sem padrões de dispersão variável e p-valor > 0.05 no teste.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python (statsmodels.stats.diagnostic.het_breuschpagan), matplotlib para scale-location plot.",
                                  "tips": "Use plot de resíduos vs. leverage para detectar pontos influentes junto.",
                                  "learningObjective": "Diagnosticar variância não constante e propor correções.",
                                  "commonMistakes": "Interpretar erroneamente funis invertidos; não testar estatisticamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar normalidade dos resíduos",
                                  "subSteps": [
                                    "Gere QQ-plot (quantis-teóricos vs. quantis-amostra).",
                                    "Crie histograma com curva normal sobreposta.",
                                    "Aplique teste de Shapiro-Wilk ou Kolmogorov-Smirnov.",
                                    "Analise desvios nos caudas do QQ-plot.",
                                    "Registre estatística do teste e p-valor."
                                  ],
                                  "verification": "QQ-plot alinhado à linha reta, p-valor > 0.05 no teste de normalidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (scipy.stats.probplot, shapiro), seaborn.distplot.",
                                  "tips": "Para amostras grandes (>50), QQ-plot é mais confiável que testes.",
                                  "learningObjective": "Detectar não-normalidade e entender implicações para intervalos de confiança.",
                                  "commonMistakes": "Usar testes em amostras muito grandes (sensíveis); ignorar assimetria leve."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar violações e propor ajustes",
                                  "subSteps": [
                                    "Compile resultados de todos os testes e plots.",
                                    "Classifique violações: crítica (ex: heterocedasticidade forte) vs. menor.",
                                    "Sugira remédios: modelo robusto, transformações, inclusão de variáveis.",
                                    "Reajuste o modelo se necessário e reavalie resíduos.",
                                    "Escreva relatório com conclusões e recomendações."
                                  ],
                                  "verification": "Relatório identifica pelo menos uma violação hipotética e propõe solução válida.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Relatório em Markdown/PDF, software de modelagem.",
                                  "tips": "Priorize violações que afetam predições em engenharia (ex: extrapolação).",
                                  "learningObjective": "Sintetizar análises para decisões informadas no ajuste de curvas.",
                                  "commonMistakes": "Ignorar violações menores que acumulam erro; não retestar após ajustes."
                                }
                              ],
                              "practicalExample": "Em um teste de compressão de pilares de concreto, ajuste um modelo linear de resistência (y) vs. idade (x). Calcule resíduos e identifique heterocedasticidade nos pilares mais velhos (dispersão maior devido a cura variável), confirmando com Breusch-Pagan (p=0.01). Ajuste com pesos inversos à variância para correção.",
                              "finalVerifications": [
                                "Média dos resíduos próxima de zero (teste t).",
                                "Ausência de padrões nos plots de diagnóstico.",
                                "Testes de pressupostos passam (p>0.05).",
                                "Relatório interpreta corretamente pelo menos duas propriedades.",
                                "Modelo reajustado melhora R² ajustado.",
                                "Identificação de outliers ou pontos influentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos e plots (sem erros de código).",
                                "Interpretação correta de padrões visuais e testes estatísticos.",
                                "Profundidade dos substeps executados (mínimo 80% completos).",
                                "Qualidade do relatório: claro, conciso e acionável.",
                                "Criatividade em sugestões de correção para violações.",
                                "Tempo respeitado e documentação de materiais usados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: testes de hipóteses e p-valores.",
                                "Programação Computacional: manipulação de dados em Python/R.",
                                "Engenharia de Materiais: análise de experimentos de concreto.",
                                "Análise de Dados: visualização com matplotlib/seaborn.",
                                "Matemática Aplicada: propriedades de regressão linear."
                              ],
                              "realWorldApplication": "Na engenharia civil, interpretar resíduos garante predições confiáveis em projetos de estruturas, como prever deformações em vigas sob carga, evitando falhas por violações não detectadas que superestimam confiança em simulações de elementos finitos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.2",
                        "name": "Modelo Linear e Matriz de Design",
                        "description": "Definir o modelo de regressão linear múltipla y = X β + ε, onde X é a matriz de design, β os coeficientes e ε o vetor de erros.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.2.1",
                            "name": "Construir a matriz de design X",
                            "description": "Para regressão linear simples ou múltipla, montar a matriz X incluindo coluna de 1's para o intercepto, a partir de dados experimentais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Organizar os Dados Experimentais",
                                  "subSteps": [
                                    "Colete os dados experimentais em formato tabular (planilha ou array).",
                                    "Identifique a variável dependente (Y) e as independentes (X1, X2, ..., Xk).",
                                    "Registre o número de observações (n) e verifique por valores ausentes ou outliers.",
                                    "Padronize as unidades das variáveis (ex: dias para idade, MPa para resistência).",
                                    "Crie uma tabela inicial com colunas para cada variável independente e Y."
                                  ],
                                  "verification": "Confirme que a tabela tem n linhas e colunas para Y e todas as Xi sem dados faltantes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha (Excel/Google Sheets), editor de texto ou software como Python (Pandas) ou MATLAB.",
                                  "tips": "Use nomes de colunas descritivos para evitar confusão entre variáveis.",
                                  "learningObjective": "Preparar dados estruturados prontos para modelagem matricial.",
                                  "commonMistakes": "Ignorar valores ausentes, que podem invalidar a regressão; confundir Y com Xi."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar a Estrutura do Modelo e Adicionar Coluna de Intercepto",
                                  "subSteps": [
                                    "Defina o modelo: simples (uma Xi) ou múltipla (múltiplas Xi).",
                                    "Crie uma nova coluna inicial preenchida com 1's para todos os n casos (intercepto β0).",
                                    "Posicione essa coluna como a primeira (X[:,0] = 1).",
                                    "Confirme que o comprimento da coluna de 1's é igual a n.",
                                    "Nomeie a coluna como 'intercepto' ou 'ones'."
                                  ],
                                  "verification": "A matriz parcial tem n linhas e 1 coluna inicial de todos 1's.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo software da planilha ou script Python: np.ones(n).",
                                  "tips": "Sempre inclua 1's para permitir intercepto não-zero; teste com sum(coluna) == n.",
                                  "learningObjective": "Entender o papel da coluna de 1's no modelo Y = Xβ + ε.",
                                  "commonMistakes": "Esquecer a coluna de 1's ou colocá-la em posição errada; usar 0's por engano."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir as Colunas das Variáveis Independentes",
                                  "subSteps": [
                                    "Adicione colunas sequenciais para cada Xi, copiando os valores dos dados originais.",
                                    "Para regressão simples: apenas uma coluna Xi após os 1's.",
                                    "Para múltipla: adicione X1, X2, ..., Xk na ordem do modelo.",
                                    "Garanta que cada coluna tenha exatamente n valores alinhados com as observações.",
                                    "Rotule colunas claramente (ex: 'idade_dias', 'carga_kN')."
                                  ],
                                  "verification": "Matriz X tem dimensões n x (k+1), com valores idênticos aos dados originais nas colunas Xi.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de manipulação matricial (NumPy, MATLAB) ou planilha avançada.",
                                  "tips": "Use funções como np.column_stack([ones, X1, X2]) em Python para eficiência.",
                                  "learningObjective": "Montar a matriz X completa para o sistema de equações normais.",
                                  "commonMistakes": "Desalinhar linhas entre observações; inverter ordem de colunas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Inspecionar a Matriz de Design X",
                                  "subSteps": [
                                    "Verifique dimensões: shape(X) == (n, k+1).",
                                    "Confirme coluna 1: todos elementos == 1.",
                                    "Inspecione estatísticas básicas: média, min/max por coluna.",
                                    "Teste consistência: corrija eventuais erros de digitação ou desalinhamento.",
                                    "Salve/exporte a matriz para uso em estimação de β (ex: (X^T X)^-1 X^T Y)."
                                  ],
                                  "verification": "Todas as verificações passam sem discrepâncias nos dados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Funções de inspeção (np.shape, np.allclose, df.describe() em Pandas).",
                                  "tips": "Visualize a matriz com print ou plot para spotting erros rápidos.",
                                  "learningObjective": "Garantir integridade da matriz X antes da regressão.",
                                  "commonMistakes": "Não verificar dimensões, levando a erros em multiplicações matriciais."
                                }
                              ],
                              "practicalExample": "Dados experimentais em engenharia civil: 5 testes de concreto com idade (dias): [7, 14, 21, 28, 35] e resistência (MPa): [20, 25, 30, 32, 35]. Para regressão simples: X = [[1,7], [1,14], [1,21], [1,28], [1,35]]. Para múltipla, adicione cimento (kg/m³): [300, 320, 340, 360, 380], X = [[1,7,300], [1,14,320], ...].",
                              "finalVerifications": [
                                "Matriz X possui dimensões corretas: n linhas por (k+1) colunas.",
                                "Primeira coluna contém exclusivamente 1's.",
                                "Valores nas colunas Xi coincidem exatamente com os dados experimentais.",
                                "Nenhuma linha ou coluna vazia ou com NaN.",
                                "Estatísticas descritivas por coluna são consistentes com dados originais.",
                                "Matriz é utilizável para computar (X^T X) sem singularidade óbvia."
                              ],
                              "assessmentCriteria": [
                                "Correta identificação e organização das variáveis independentes.",
                                "Presença e posicionamento preciso da coluna de intercepto.",
                                "Dimensões e alinhamento perfeito da matriz X.",
                                "Ausência de erros de transcrição ou desalinhamento de dados.",
                                "Validações completas demonstrando compreensão do modelo linear.",
                                "Capacidade de estender para regressão múltipla."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Construção e manipulação de matrizes.",
                                "Estatística: Fundamentos de regressão e mínimos quadrados.",
                                "Programação: Uso de arrays e funções matriciais em Python/MATLAB.",
                                "Engenharia Civil: Análise de dados de ensaios experimentais em materiais."
                              ],
                              "realWorldApplication": "Na engenharia civil, a matriz X é essencial para modelar relações como resistência de concreto versus idade e composição em projetos de estruturas, permitindo previsões precisas de desempenho e otimização de misturas para segurança e custo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.2.2",
                            "name": "Formular o problema de minimização",
                            "description": "Escrever o problema de otimização min_β || y - X β ||² e relacioná-lo à norma euclidiana dos resíduos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Modelo Linear e a Matriz de Design",
                                  "subSteps": [
                                    "Identifique as variáveis: vetor de observações y (n x 1), matriz de design X (n x p), vetor de parâmetros β (p x 1).",
                                    "Entenda o modelo y = X β + ε, onde ε representa os erros/resíduos aleatórios.",
                                    "Desenhe um diagrama simples mostrando y, X, β e ε.",
                                    "Liste as suposições básicas do modelo linear (linearidade, independência dos erros, etc.).",
                                    "Escreva um exemplo pequeno com n=3, p=2 para visualizar."
                                  ],
                                  "verification": "Construa um exemplo numérico simples e confirme que y ≈ X β sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou software como MATLAB/Octave; tabela de dados de exemplo.",
                                  "tips": "Use notação consistente: y em negrito para vetores, X maiúsculo para matriz.",
                                  "learningObjective": "Compreender os componentes fundamentais do modelo de regressão linear.",
                                  "commonMistakes": "Confundir dimensões de X (linhas = observações, colunas = preditores); ignorar o termo de erro ε."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Calcular os Resíduos",
                                  "subSteps": [
                                    "Defina os resíduos como e = y - X β, um vetor n x 1.",
                                    "Calcule e para um β arbitrário em um exemplo numérico.",
                                    "Discuta por que minimizar |e| faz sentido: resíduos pequenos indicam bom ajuste.",
                                    "Visualize resíduos graficamente (gráfico de resíduos vs preditores previstos).",
                                    "Explique a norma euclidiana ||e|| = sqrt(∑ e_i²) como distância geométrica."
                                  ],
                                  "verification": "Compute e para dois β diferentes e compare ||e||.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou Python/MATLAB para multiplicação matricial; gráfico de dispersão.",
                                  "tips": "Sempre verifique dimensões: X β deve ser n x 1 para subtrair de y.",
                                  "learningObjective": "Dominar a definição e interpretação geométrica dos resíduos.",
                                  "commonMistakes": "Esquecer de transpor vetores (β deve ser coluna); calcular resíduos sem o modelo ajustado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a Função Objetivo de Minimização",
                                  "subSteps": [
                                    "Escreva a soma dos quadrados dos resíduos: S(β) = ∑_{i=1}^n e_i² = ||y - X β||².",
                                    "Expanda em forma matricial: S(β) = (y - X β)^T (y - X β).",
                                    "Simplifique a expressão: y^T y - 2 β^T X^T y + β^T X^T X β.",
                                    "Identifique que minimizar S(β) é equivalente a minimizar ||e||².",
                                    "Pratique reescrevendo para um exemplo com 3 pontos de dados."
                                  ],
                                  "verification": "Derive a expressão expandida de S(β) e confirme com cálculo numérico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel para álgebra matricial; software para validar expansão.",
                                  "tips": "Lembre-se: ||v||² = v^T v para vetores reais.",
                                  "learningObjective": "Formular precisamente o problema de otimização em notação matricial.",
                                  "commonMistakes": "Erro no sinal da expansão (deve ser -2 β^T X^T y); confundir ||.|| com |.| escalar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar à Norma Euclidiana e Interpretar",
                                  "subSteps": [
                                    "Explique geometricamente: min ||y - X β||² projeta y no espaço coluna de X.",
                                    "Discuta propriedades: S(β) é quadrática convexa, mínimo único se X^T X invertível.",
                                    "Compare com norma L2: ||e||_2² = soma quadrados.",
                                    "Aplique a um contexto de engenharia: ajuste de linha de regressão.",
                                    "Resuma: o problema é min_β ||y - X β||² s.a. β livre."
                                  ],
                                  "verification": "Descreva em palavras o significado geométrico e escreva a formulação final.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráfico vetorial (projeção ortogonal); exemplo de dados civis (carga vs deformação).",
                                  "tips": "Pense em X β como a projeção mais próxima de y.",
                                  "learningObjective": "Conectar a formulação matemática à interpretação geométrica e prática.",
                                  "commonMistakes": "Ignorar invertibilidade de X^T X; confundir minimização de ||e|| vs ||e||²."
                                }
                              ],
                              "practicalExample": "Em engenharia civil, ajuste uma reta (deformação = β0 + β1 * carga) a 5 pontos de dados de um teste de tração em concreto: y = [0.1, 0.25, 0.4, 0.55, 0.7], X = [1 10; 1 25; 1 40; 1 55; 1 70]. Formule min_β ||y - X β||² para encontrar β que minimiza resíduos.",
                              "finalVerifications": [
                                "Escreva corretamente min_β ||y - X β||² com dimensões apropriadas.",
                                "Expanda S(β) = (y - X β)^T (y - X β) sem erros algébricos.",
                                "Explique a relação com norma euclidiana dos resíduos em 2 frases.",
                                "Aplique a um exemplo numérico pequeno e compute S(β) para β teste.",
                                "Identifique o papel de X como matriz de design no problema.",
                                "Descreva geometricamente como o mínimo corresponde à projeção ortogonal."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matricial e dimensões (100% correto).",
                                "Correta expansão algébrica de S(β) (sem erros de sinal ou transposta).",
                                "Compreensão conceitual: ligação clara entre minimização e norma L2.",
                                "Aplicação prática: formulação correta em exemplo real.",
                                "Profundidade geométrica: explicação de projeção no espaço coluna.",
                                "Clareza na comunicação: títulos e passos lógicos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: multiplicação matricial, normas vetoriais, projeções.",
                                "Estatística: regressão linear, suposições do modelo de mínimos quadrados.",
                                "Programação: implementação em Python (numpy.linalg.lstsq) ou MATLAB.",
                                "Cálculo: derivadas parciais para solução normal (∂S/∂β = 0).",
                                "Engenharia Civil: modelagem de dados experimentais em estruturas."
                              ],
                              "realWorldApplication": "Na engenharia civil, formulação usada para ajustar curvas de carga-deformação em testes de materiais, calibrar modelos de estruturas ou prever assentamentos de fundações a partir de dados de campo, minimizando erros de previsão para designs seguros e econômicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.2.3",
                            "name": "Entender condicionamento da matriz X",
                            "description": "Avaliar o condicionamento da matriz de Gram Xᵀ X, relacionando com autovalores e multicolinearidade nos dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de condicionamento de matrizes",
                                  "subSteps": [
                                    "Defina o número de condicionamento κ(A) como a razão entre o maior e o menor valor singular de A.",
                                    "Relacione o condicionamento com a sensibilidade da solução de sistemas lineares Ax = b a perturbações.",
                                    "Discuta o impacto em métodos numéricos como decomposição QR ou SVD.",
                                    "Compare matrizes bem condicionadas (κ ≈ 1) com mal condicionadas (κ >> 1).",
                                    "Estude exemplos simples de matrizes 2x2 com diferentes níveis de condicionamento."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que significa κ(A) > 10^6 e forneça um exemplo numérico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de álgebra linear (ex: Strang), calculadora ou Python/Jupyter com NumPy.",
                                  "tips": "Sempre normalize as colunas da matriz para melhorar o condicionamento inicial.",
                                  "learningObjective": "Dominar a definição e implicações do número de condicionamento em sistemas lineares.",
                                  "commonMistakes": "Confundir número de condicionamento com determinante zero (singularidade)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e analisar a matriz de Gram XᵀX",
                                  "subSteps": [
                                    "Construa a matriz de design X para um modelo linear simples (ex: regressão linear com intercepto).",
                                    "Calcule XᵀX explicitamente para uma matriz pequena (n=3 pontos, p=2 parâmetros).",
                                    "Verifique propriedades: XᵀX é simétrica e semidefinida positiva.",
                                    "Discuta por que XᵀX é central no método dos mínimos quadrados (solução β = (XᵀX)^{-1} Xᵀ y).",
                                    "Implemente o cálculo em software para validar."
                                  ],
                                  "verification": "Gere XᵀX para dados de exemplo e confirme simetria e autovalores não-negativos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Jupyter Notebook com NumPy/SciPy, dados de exemplo em CSV (ex: medidas de vigas).",
                                  "tips": "Use np.dot(X.T, X) em Python para eficiência computacional.",
                                  "learningObjective": "Entender a formação da matriz de Gram e suas propriedades algébricas.",
                                  "commonMistakes": "Esquecer de centralizar os dados, levando a multicolinearidade artificial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar autovalores de XᵀX com o condicionamento",
                                  "subSteps": [
                                    "Calcule autovalores de XᵀX usando decomposição espectral.",
                                    "Defina o número de condicionamento κ(XᵀX) = λ_max / λ_min, onde λ são autovalores.",
                                    "Interprete: autovalores pequenos indicam direções instáveis na solução.",
                                    "Use SVD de X para obter autovalores de XᵀX (σ_i^2).",
                                    "Plote espectro de autovalores para visualizar o gap entre λ_max e λ_min."
                                  ],
                                  "verification": "Compute κ para duas matrizes X: uma ortogonal (boa) e uma colinear (ruim).",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python com NumPy (np.linalg.eig, np.linalg.svd), Matplotlib para plots.",
                                  "tips": "Verifique se todos autovalores são positivos; zero indica singularidade.",
                                  "learningObjective": "Ligar autovalores diretamente ao condicionamento numérico.",
                                  "commonMistakes": "Ignorar autovalores próximos de zero como 'pequenos erros numéricos'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar multicolinearidade e impactos práticos",
                                  "subSteps": [
                                    "Defina multicolinearidade como colunas de X quase lineares dependentes.",
                                    "Meça via VIF (Variance Inflation Factor) ou condição κ > 30.",
                                    "Simule dados com multicolinearidade (ex: adicionar coluna redundante).",
                                    "Discuta soluções: remoção de variáveis, ridge regression.",
                                    "Aplique a um caso de engenharia civil e avalie estabilidade das estimativas β."
                                  ],
                                  "verification": "Gere relatório com κ, VIF e varredura de sensibilidade em β.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com statsmodels (para VIF), dados reais de engenharia (ex: cargas em estruturas).",
                                  "tips": "Sempre reporte κ junto com R² em ajustes de regressão.",
                                  "learningObjective": "Conectar condicionamento teórico a problemas reais de multicolinearidade.",
                                  "commonMistakes": "Atribuir variância alta em β apenas a ruído, ignorando condicionamento."
                                }
                              ],
                              "practicalExample": "Em um ajuste de curva para prever deformação de vigas sob carga (y = deformação, X = [1, carga, comprimento]), construa X com 10 medições. Calcule XᵀX, autovalores [100, 0.01], κ=10^4, indicando multicolinearidade entre 'carga' e 'comprimento'; resolva adicionando ridge regularization.",
                              "finalVerifications": [
                                "Calcule corretamente κ(XᵀX) para matriz de exemplo fornecida.",
                                "Identifique autovalor mínimo < 10^{-6} como sinal de problema.",
                                "Explique impacto de κ alto na variância de β.",
                                "Gere plot de espectro de autovalores.",
                                "Proponha mitigação para κ > 100.",
                                "Valide com VIF > 5 em pelo menos uma variável."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de autovalores e κ (erro < 1%).",
                                "Interpretação correta da relação com multicolinearidade.",
                                "Uso adequado de ferramentas numéricas sem erros de implementação.",
                                "Explicação clara de implicações em mínimos quadrados.",
                                "Identificação de pelo menos 3 soluções para mau condicionamento.",
                                "Aplicação coerente ao contexto de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência em regressão linear e testes de significância.",
                                "Programação: Implementação em Python/MATLAB para análise numérica.",
                                "Física/Engenharia: Modelagem de sistemas lineares em estruturas civis.",
                                "Álgebra Linear: Decomposição em valores singulares (SVD)."
                              ],
                              "realWorldApplication": "Na análise de estruturas civis, avaliar condicionamento de X em modelos de regressão para prever falhas em pontes garante estimativas robustas de parâmetros, evitando erros catastróficos em simulações de carga devido a multicolinearidade em variáveis como espessura e material."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.3",
                        "name": "Equações Normais e Solução Analítica",
                        "description": "Derivar e resolver as equações normais Xᵀ X β = Xᵀ y para obter os estimadores de mínimos quadrados β̂ = (Xᵀ X)⁻¹ Xᵀ y.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.3.1",
                            "name": "Derivar as equações normais",
                            "description": "Partir da função objetivo S(β) e aplicar derivadas parciais para obter o sistema linear Xᵀ X β = Xᵀ y.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e formular a função objetivo S(β)",
                                  "subSteps": [
                                    "Revise o problema de mínimos quadrados lineares: minimizar a soma dos quadrados dos resíduos ε = y - Xβ.",
                                    "Escreva a função objetivo S(β) = εᵀ ε = (y - Xβ)ᵀ (y - Xβ).",
                                    "Identifique os componentes: y (vetor de observações n×1), X (matriz de design n×p), β (vetor de parâmetros p×1).",
                                    "Verifique a dimensionalidade para garantir compatibilidade matricial.",
                                    "Expanda simbolicamente para um caso simples com p=2 para intuição."
                                  ],
                                  "verification": "Escreva S(β) corretamente em notação matricial e expanda para um exemplo 2D.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor LaTeX/Mathematica",
                                    "Notas de aula sobre mínimos quadrados"
                                  ],
                                  "tips": "Use notação consistente; lembre-se que S(β) é escalar e quadrática em β.",
                                  "learningObjective": "Formular precisamente a função objetivo do método dos mínimos quadrados.",
                                  "commonMistakes": [
                                    "Confundir transposta de X com Xᵀ",
                                    "Esquecer que ε é vetor coluna"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expandir a expressão de S(β)",
                                  "subSteps": [
                                    "Expanda S(β) = yᵀ y - 2 βᵀ Xᵀ y + βᵀ Xᵀ X β usando propriedades de transposta (Aᵀ B C = (Cᵀ Bᵀ A)ᵀ, mas foque em bilineares).",
                                    "Confirme que yᵀ y é constante, -2 βᵀ Xᵀ y é linear em β, e βᵀ Xᵀ X β é quadrática.",
                                    "Verifique simetria: Xᵀ X é simétrica positiva definida (assumindo X de posto completo).",
                                    "Escreva em componentes: S(β) = Σ (y_i - Σ x_{ij} β_j)² para validar.",
                                    "Teste com dados numéricos pequenos (n=3, p=1)."
                                  ],
                                  "verification": "Expanda S(β) e identifique termos constante, linear e quadrático corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora matricial ou software como MATLAB/Octave",
                                    "Exemplo de dados de ajuste de reta"
                                  ],
                                  "tips": "Lembre-se da regra (A+B)ᵀ(A+B) = AᵀA + AᵀB + BᵀA + BᵀB.",
                                  "learningObjective": "Expandir algebricamente S(β) em termos matriciais.",
                                  "commonMistakes": [
                                    "Erro no sinal do termo cruzado (-2 em vez de +2)",
                                    "Confundir Xᵀ y com yᵀ X"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as derivadas parciais ∂S/∂β_k",
                                  "subSteps": [
                                    "Lembre que para função quadrática S(β) = c - 2 bᵀ β + βᵀ A β, ∇S = -2b + 2 A β.",
                                    "Aqui, A = Xᵀ X, b = Xᵀ y, então ∂S/∂β = -2 Xᵀ y + 2 Xᵀ X β.",
                                    "Derive componente a componente: ∂S/∂β_k = -2 Σ_i x_{ik} (y_i - Σ_j x_{ij} β_j).",
                                    "Use regra da cadeia para resíduos lineares.",
                                    "Simplifique para obter ∇S(β) = 2 Xᵀ (X β - y).",
                                    "Confirme com expansão escalar."
                                  ],
                                  "verification": "Escreva o vetor gradiente ∇S(β) = 2 Xᵀ X β - 2 Xᵀ y.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de cálculo matricial (ex: Magnus & Neudecker)",
                                    "Software simbólico como SymPy"
                                  ],
                                  "tips": "Pense em S como norma L2 ao quadrado; gradiente aponta para direção de aumento.",
                                  "learningObjective": "Computar corretamente o gradiente de S(β) usando cálculo matricial.",
                                  "commonMistakes": [
                                    "Fator 2 errado (esquecer ou duplicar)",
                                    "Transpor incorretamente Xᵀ (X β)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir gradiente zero para obter equações normais",
                                  "subSteps": [
                                    "Defina ∇S(β) = 0 para mínimo: 2 Xᵀ X β - 2 Xᵀ y = 0.",
                                    "Simplifique para Xᵀ X β = Xᵀ y.",
                                    "Verifique que é sistema linear simétrico Ax = b com A = Xᵀ X, b = Xᵀ y.",
                                    "Discuta condições: Xᵀ X invertível se X posto completo.",
                                    "Resolva analiticamente para p=1 (β = (Xᵀ X)^{-1} Xᵀ y).",
                                    "Valide com exemplo numérico."
                                  ],
                                  "verification": "Derive e escreva Xᵀ X β = Xᵀ y a partir de ∂S/∂β_k = 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de dados reais de engenharia civil",
                                    "Solver de sistemas lineares"
                                  ],
                                  "tips": "As equações normais são o coração analítico do OLS.",
                                  "learningObjective": "Concluir a derivação das equações normais e interpretá-las.",
                                  "commonMistakes": [
                                    "Ignorar o fator 2 ao zerar",
                                    "Escrever X Xᵀ em vez de Xᵀ X"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga de concreto, dados de deflexão y = [0.1, 0.3, 0.5, 0.8] m sob cargas x = [1,2,3,4] kN. Ajuste y = β0 + β1 x. Compute S(β), derive ∂S/∂β0 = 0 e ∂S/∂β1 = 0, resolva Xᵀ X β = Xᵀ y para β ≈ [0.02, 0.12].",
                              "finalVerifications": [
                                "Escreve S(β) = (y - Xβ)ᵀ (y - Xβ) corretamente.",
                                "Expande e identifica termos corretos.",
                                "Computa ∇S(β) = 2 Xᵀ (Xβ - y).",
                                "Deriva Xᵀ X β = Xᵀ y zerando o gradiente.",
                                "Valida com exemplo numérico (erro < 1e-6).",
                                "Explica verbalmente o processo em 2 minutos."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na expansão e derivação (100%).",
                                "Uso preciso de notação matricial e transpostas.",
                                "Identificação correta de termos quadrático, linear e constante.",
                                "Tratamento adequado de fator 2 no gradiente.",
                                "Validação numérica com exemplo prático.",
                                "Clareza na explicação de subpassos."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Derivadas parciais e gradientes.",
                                "Álgebra Linear: Operações matriciais, sistemas lineares simétricos.",
                                "Estatística: Propriedades do estimador BLUE no OLS.",
                                "Programação: Implementação em Python (numpy.linalg.solve).",
                                "Física: Modelagem de regressão em mecânica estrutural."
                              ],
                              "realWorldApplication": "Na engenharia civil, derivar equações normais permite solução analítica exata para ajuste de curvas em monitoramento de estruturas, como prever deformações em barragens via regressão linear, evitando iterações numéricas em softwares como MATLAB para projetos iniciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.3.2",
                            "name": "Resolver equações normais para regressão simples",
                            "description": "Para y = a + b x, calcular analiticamente b = (n Σ x y - Σ x Σ y)/(n Σ x² - (Σ x)²) e a = ȳ - b x̄.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados e calcular somas estatísticas básicas",
                                  "subSteps": [
                                    "Liste os pares de dados (x_i, y_i) para n observações.",
                                    "Calcule n (número de pontos de dados).",
                                    "Compute Σx (soma de todos x_i) e Σy (soma de todos y_i).",
                                    "Calcule as médias x̄ = Σx / n e ȳ = Σy / n.",
                                    "Registre todos os valores em uma tabela organizada."
                                  ],
                                  "verification": "Verifique se as somas batem com recálculo manual e médias estão corretas (diferença < 0.01).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel, lápis, calculadora científica ou planilha Excel.",
                                  "tips": "Use uma tabela para organizar: colunas para x, y, x², xy; evite arredondamentos prematuros.",
                                  "learningObjective": "Dominar o preparo inicial de dados para regressão linear simples.",
                                  "commonMistakes": "Esquecer de contar n corretamente; confundir Σx com x̄."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular somas cruzadas necessárias (Σxy e Σx²)",
                                  "subSteps": [
                                    "Para cada par (x_i, y_i), calcule x_i * y_i e some todos para obter Σxy.",
                                    "Para cada x_i, calcule x_i² e some todos para obter Σx².",
                                    "Confirme os cálculos multiplicando de volta alguns termos.",
                                    "Atualize a tabela com as novas colunas Σxy e Σx².",
                                    "Verifique dimensionalidade: unidades de Σxy devem ser consistentes com x*y."
                                  ],
                                  "verification": "Recalcule Σxy e Σx² usando uma fórmula alternativa ou software para validação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora com funções de soma; planilha para automação opcional.",
                                  "tips": "Calcule xy e x² ponto a ponto para evitar erros de propagação.",
                                  "learningObjective": "Executar cálculos precisos de produtos e quadrados para equações normais.",
                                  "commonMistakes": "Erro de sinal em produtos negativos; esquecer de elevar ao quadrado corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver para o coeficiente angular b",
                                  "subSteps": [
                                    "Substitua na fórmula do numerador: n * Σxy - Σx * Σy.",
                                    "Substitua no denominador: n * Σx² - (Σx)².",
                                    "Calcule b = numerador / denominador.",
                                    "Arredonde b para 4 casas decimais e anote com unidades.",
                                    "Interprete: b indica a inclinação da reta de regressão."
                                  ],
                                  "verification": "Confirme que denominador > 0 (evita divisão por zero); teste com dados conhecidos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora de alta precisão; papel para mostrar passos algébricos.",
                                  "tips": "Fatore (Σx)² como (Σx)*(Σx) para clareza; use parênteses em calculadoras.",
                                  "learningObjective": "Aplicar analiticamente a fórmula de b nas equações normais.",
                                  "commonMistakes": "Inverter numerador e denominador; erro em (Σx)² vs Σx²."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o intercepto a e validar a solução",
                                  "subSteps": [
                                    "Use a = ȳ - b * x̄.",
                                    "Substitua os valores conhecidos de ȳ, b e x̄.",
                                    "Calcule SSE = Σ(y_i - (a + b x_i))² para verificação (deve ser mínimo).",
                                    "Escreva a equação final y = a + b x.",
                                    "Plote os pontos e a reta para inspeção visual."
                                  ],
                                  "verification": "Previsões da equação devem aproximar os dados originais (erro médio < 5%).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gráfico de papel milimetrado ou software como Desmos/Excel para plotagem.",
                                  "tips": "Sempre valide com pelo menos um ponto: y_predito ≈ y_observado.",
                                  "learningObjective": "Completar a regressão linear e validar analiticamente.",
                                  "commonMistakes": "Ordem errada em a = ȳ - b x̄; ignorar verificação de ajuste."
                                }
                              ],
                              "practicalExample": "Em um teste de tração de concreto, dados: x (carga em kN): [0, 10, 20, 30, 40]; y (deformação %): [0, 0.05, 0.12, 0.18, 0.25]. Calcule b ≈ 0.00625 kN⁻¹, a ≈ 0, resultando em deformação = 0.00625 * carga, útil para prever falhas estruturais.",
                              "finalVerifications": [
                                "Cálculo de b e a coincide com solução verificada em software (ex: Python numpy.polyfit).",
                                "Denominador da fórmula de b é positivo e não-zero.",
                                "Equação prevê valores y dentro de 10% dos dados originais.",
                                "Gráfico mostra reta ajustada aos pontos sem desvios sistemáticos.",
                                "Todas somas (Σx, Σy, etc.) recálculadas manualmente batem.",
                                "Interpretação correta: b como taxa de mudança, a como valor inicial."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erros < 0.001 em coeficientes.",
                                "Completude: todas somas e passos documentados.",
                                "Validação: SSE calculado e mínimo demonstrado.",
                                "Clareza: tabela organizada e equação final explícita.",
                                "Interpretação: explicação contextual em engenharia civil.",
                                "Eficiência: tempo total < 50 minutos com acurácia."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Correlação e coeficiente de determinação R².",
                                "Programação: Implementar em Python (numpy.linalg.lstsq) para automação.",
                                "Física/Mecânica: Modelagem de relações lineares em materiais (Hooke).",
                                "Cálculo: Derivação das equações normais via minimização de resíduos."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para calibrar curvas de carga-deformação em testes de materiais, prevendo comportamentos de vigas e lajes sob tensão, otimizando projetos de pontes e edifícios contra colapsos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.3.3",
                            "name": "Resolver numericamente para regressão múltipla",
                            "description": "Usar decomposição ou inversão para resolver Xᵀ X β = Xᵀ y, considerando estabilidade numérica (ref. Chapra & Canale).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados e formar as matrizes das equações normais",
                                  "subSteps": [
                                    "Colete os dados de entrada: matriz X (n x (p+1), incluindo coluna de 1s para intercepto) e vetor y (n x 1).",
                                    "Calcule a matriz A = Xᵀ X (p+1 x p+1).",
                                    "Calcule o vetor b = Xᵀ y (p+1 x 1).",
                                    "Verifique dimensões e ausência de valores ausentes.",
                                    "Escalone os dados se necessário para melhorar condicionamento."
                                  ],
                                  "verification": "Matrizes A e b formadas corretamente, com dimensões adequadas e simetria em A.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software numérico (MATLAB, Python com NumPy/SciPy), dados de exemplo, livro Chapra & Canale.",
                                  "tips": "Sempre inclua a coluna de 1s em X para o termo constante.",
                                  "learningObjective": "Dominar a formulação das equações normais para regressão múltipla.",
                                  "commonMistakes": "Esquecer a coluna de 1s em X; não verificar NaNs ou infs nos dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar condicionamento e estabilidade numérica da matriz A",
                                  "subSteps": [
                                    "Calcule o número de condicionamento cond(A) = ||A|| * ||A⁻¹||.",
                                    "Verifique autovalores de A para confirmar positiva definida (todos > 0).",
                                    "Identifique multicolinearidade entre colunas de X via correlação ou VIF.",
                                    "Decida o método: inversão direta se cond < 10⁴; senão, decomposição QR ou SVD.",
                                    "Registre métricas de estabilidade."
                                  ],
                                  "verification": "Relatório com cond(A), autovalores mínimos e decisão de método documentados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Funções cond() ou svd() no software numérico.",
                                  "tips": "Use normais Frobenius ou 2-norma para condicionamento.",
                                  "learningObjective": "Compreender impactos do il-condicionamento em soluções numéricas.",
                                  "commonMistakes": "Ignorar multicolinearidade; usar inversão direta em matrizes mal-condicionadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar método numérico estável para resolver A β = b",
                                  "subSteps": [
                                    "Se cond bom e A positiva definida: use decomposição Cholesky.",
                                    "Caso contrário: decomposição QR de X (não de A) e resolva por projeção.",
                                    "Alternativa: SVD de X para solução robusta.",
                                    "Implemente no software: β = inv(A) * b ou equivalente estável.",
                                    "Calcule resíduos e R² para初步 validação."
                                  ],
                                  "verification": "Coeficientes β obtidos sem warnings de singularidade ou NaNs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Bibliotecas SciPy.linalg ou MATLAB backslash operator.",
                                  "tips": "Prefira QR/SVD sobre inversão explícita para estabilidade.",
                                  "learningObjective": "Implementar soluções numéricas estáveis para sistemas lineares em regressão.",
                                  "commonMistakes": "Resolver diretamente X β = y em vez de normais; pivoteamento inadequado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar os resultados da regressão",
                                  "subSteps": [
                                    "Calcule predições ŷ = X β e resíduos e = y - ŷ.",
                                    "Avalie métricas: R², RMSE, intervalos de confiança via covariância.",
                                    "Compare com solução analítica se p pequeno.",
                                    "Teste sensibilidade a perturbações numéricas.",
                                    "Documente coeficientes e insights."
                                  ],
                                  "verification": "Métricas de ajuste acima de thresholds aceitáveis (ex: R² > 0.8).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Funções de regressão ou métricas personalizadas no software.",
                                  "tips": "Use regressão robusta se outliers presentes.",
                                  "learningObjective": "Avaliar qualidade e confiabilidade da solução numérica.",
                                  "commonMistakes": "Interpretar β sem contexto físico; ignorar resíduos altos."
                                }
                              ],
                              "practicalExample": "Em Engenharia Civil, ajuste um modelo de regressão múltipla para prever a deformação máxima em vigas (y) baseado em carga aplicada (x1) e espessura da viga (x2). Dados: 20 experimentos com X = [1, carga, espessura]. Forme A = XᵀX, resolva via QR para β estável, obtendo β ≈ [0.1, 0.05, -0.2].",
                              "finalVerifications": [
                                "Matriz A é simétrica positiva definida com autovalores > 0.",
                                "Número de condicionamento cond(A) < 10⁵.",
                                "Coeficientes β produzem R² > 0.85 e resíduos normais.",
                                "Solução insensível a ruído de 1% nos dados.",
                                "Resultados coincidem com função regressão built-in dentro de 1e-6.",
                                "Sem warnings de singularidade no solver."
                              ],
                              "assessmentCriteria": [
                                "Correta formulação de A e b (100% precisão dimensional).",
                                "Avaliação adequada de condicionamento e escolha de método estável.",
                                "Implementação numérica sem erros ou NaNs.",
                                "Validação completa com métricas quantitativas.",
                                "Consideração explícita de estabilidade (ref. Chapra & Canale).",
                                "Relatório claro com interpretações."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposições QR, Cholesky e SVD.",
                                "Estatística: Validação de modelos de regressão e análise de resíduos.",
                                "Programação Computacional: Uso de bibliotecas NumPy/SciPy ou MATLAB.",
                                "Engenharia de Dados: Tratamento de multicolinearidade em experimentos."
                              ],
                              "realWorldApplication": "Na análise de dados experimentais de estruturas civis, como calibrar modelos preditivos de deformação em pontes sob cargas variáveis e temperaturas, garantindo precisão numérica para evitar sub ou superestimações em projetos de engenharia."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.4",
                        "name": "Implementação e Avaliação Computacional",
                        "description": "Implementar o método em software numérico e avaliar a qualidade do ajuste com métricas como R² e resíduos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.4.1",
                            "name": "Implementar mínimos quadrados em pseudocódigo",
                            "description": "Escrever algoritmo para calcular β̂ usando multiplicação de matrizes e inversão, com dados de entrada de engenharia civil (ex. ajuste de deformação vs. carga).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados de entrada e definir matrizes X e y",
                                  "subSteps": [
                                    "Colete dados reais de engenharia civil, como cargas (x) e deformações (y).",
                                    "Adicione uma coluna de 1s à matriz X para incluir o intercepto β0.",
                                    "Formate X como matriz n x 2 (n amostras, 2 colunas: 1 e x) e y como vetor n x 1.",
                                    "Defina funções auxiliares em pseudocódigo para transposição de matriz (X^T).",
                                    "Valide dimensões: X deve ser n x 2, y n x 1."
                                  ],
                                  "verification": "Verifique se X tem dimensões corretas e coluna de 1s usando print de matrizes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Conjunto de dados exemplo (planilha Excel ou CSV)",
                                    "Editor de texto para pseudocódigo",
                                    "Calculadora matricial online"
                                  ],
                                  "tips": "Sempre inclua a coluna de 1s para modelos com intercepto; teste com dados pequenos (n=4-5).",
                                  "learningObjective": "Compreender como estruturar dados para regressão linear simples usando matrizes.",
                                  "commonMistakes": [
                                    "Esquecer a coluna de 1s em X",
                                    "Confundir linhas e colunas nas dimensões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar multiplicação de matrizes para X^T X e X^T y",
                                  "subSteps": [
                                    "Escreva pseudocódigo para multiplicação genérica de matrizes A x B.",
                                    "Calcule X^T usando transposição (troca linhas/colunas).",
                                    "Compute X^T X (resultado 2x2) com loops duplos para soma de produtos.",
                                    "Compute X^T y (resultado 2x1) similarmente.",
                                    "Armazene resultados em variáveis A = X^T X e b = X^T y."
                                  ],
                                  "verification": "Teste com matrizes unitárias: X^T X deve ser identidade para X ortogonal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Pseudocódigo template para multiplicação",
                                    "Ferramenta de simulação como Python REPL para validar manualmente"
                                  ],
                                  "tips": "Use loops for i,j para multiplicação: resultado[i][j] += A[i][k] * B[k][j].",
                                  "learningObjective": "Dominar multiplicação matricial em pseudocódigo para computação eficiente.",
                                  "commonMistakes": [
                                    "Índices errados em loops (off-by-one)",
                                    "Não transpor corretamente X"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar inversão de matriz 2x2 para (X^T X)^{-1}",
                                  "subSteps": [
                                    "Lembre fórmula para inversa 2x2: para [[a,b],[c,d]], inv = 1/det * [[d,-b],[-c,a]] onde det=ad-bc.",
                                    "Escreva pseudocódigo para calcular determinante.",
                                    "Implemente a fórmula de inversa, verificando det != 0.",
                                    "Aplique a A = X^T X para obter inv_A.",
                                    "Adicione tratamento de erro se det ≈ 0 (matriz singular)."
                                  ],
                                  "verification": "Inverta uma matriz conhecida, como identidade, e multiplique para obter identidade de volta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Fórmulas de álgebra linear impressas",
                                    "Calculadora para verificar det manualmente"
                                  ],
                                  "tips": "Para 2x2 é analítico; evite métodos numéricos desnecessários para simplicidade.",
                                  "learningObjective": "Aplicar inversão matricial analítica em contextos de regressão.",
                                  "commonMistakes": [
                                    "Erro no sinal da inversa (ex: -b vira +b)",
                                    "Dividir por det=0 sem aviso"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular coeficientes β̂ e validar o algoritmo completo",
                                  "subSteps": [
                                    "Multiplique inv_A por b: β̂ = inv_A * (X^T y).",
                                    "Implemente multiplicação 2x2 por 2x1.",
                                    "Gere predições ŷ = X β̂ e calcule resíduo SSE = sum((y - ŷ)^2).",
                                    "Escreva função principal que integra todos os passos.",
                                    "Teste com dados de exemplo e compare β̂ com solução analítica."
                                  ],
                                  "verification": "SSE deve ser mínimo e β̂ coincidir com regressão manual (ex: Excel).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dados de exemplo prontos",
                                    "Ferramenta de plotagem para ŷ vs y"
                                  ],
                                  "tips": "Mantenha código modular com funções separadas para reutilização.",
                                  "learningObjective": "Integrar componentes para obter solução completa dos mínimos quadrados.",
                                  "commonMistakes": [
                                    "Erro de propagação em multiplicações finais",
                                    "Ignorar normalização de dados"
                                  ]
                                }
                              ],
                              "practicalExample": "Dados: Cargas (kN): [0, 10, 20, 30, 40]; Deformações (mm): [0.05, 0.12, 0.18, 0.25, 0.31]. Monte X = [[1,0],[1,10],[1,20],[1,30],[1,40]], y=[0.05,0.12,0.18,0.25,0.31]. Pseudocódigo deve outputar β̂ ≈ [0.048, 0.0065] (intercepto e inclinação).",
                              "finalVerifications": [
                                "Pseudocódigo executa sem erros sintáticos ou lógicos.",
                                "β̂ calculado coincide com solução analítica (ex: β1 = (n sum(xy) - sum(x)sum(y)) / (n sum(x^2) - (sum(x))^2).",
                                "Predições ŷ se aproximam de y com SSE baixo.",
                                "Matriz singular é detectada e tratada.",
                                "Dimensões de todas matrizes intermediárias são corretas.",
                                "Código é legível com comentários."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: Fórmulas de X^T X, inversa e multiplicação exatas.",
                                "Eficiência: Loops otimizados sem redundâncias.",
                                "Robustez: Tratamento de casos edge (det=0, n<2).",
                                "Clareza: Pseudocódigo indentado, variáveis nomeadas intuitivamente.",
                                "Validação: Inclui testes com exemplo fornecido.",
                                "Modularidade: Funções separadas para operações matriciais."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Multiplicação, transposição e inversão de matrizes.",
                                "Programação: Estruturas de loops, funções e controle de erros em pseudocódigo.",
                                "Estatística: Fundamentos de regressão linear e mínimos quadrados.",
                                "Engenharia Civil: Modelagem de relações carga-deformação em testes de materiais."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para calibrar modelos de deformação em vigas sob carga, prevendo falhas estruturais em pontes ou edifícios a partir de dados experimentais de ensaios destrutivos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.4.2",
                            "name": "Calcular coeficiente de determinação R²",
                            "description": "Computar R² = 1 - (SS_res / SS_tot), onde SS_res é soma quadrados resíduos e SS_tot soma quadrados total, para validar o ajuste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados observados e preditos para o cálculo",
                                  "subSteps": [
                                    "Colete os valores observados (y_obs) e preditos (y_pred) do modelo de regressão linear ajustado.",
                                    "Calcule a média dos valores observados (y_mean) usando a fórmula média = soma(y_obs) / n.",
                                    "Verifique se os arrays têm o mesmo comprimento e sem valores ausentes.",
                                    "Organize os dados em uma estrutura computacional (ex: listas ou arrays NumPy).",
                                    "Salve os dados em variáveis nomeadas claramente para uso posterior."
                                  ],
                                  "verification": "Confirme que y_mean foi calculado corretamente comparando com cálculo manual de um subconjunto pequeno.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python com NumPy; conjunto de dados de exemplo (ex: tensão vs. deformação); editor de código (Jupyter Notebook).",
                                  "tips": "Use np.mean() para eficiência; sempre imprima y_mean para inspeção visual.",
                                  "learningObjective": "Compreender a importância da média como referência para variância total.",
                                  "commonMistakes": "Esquecer de tratar valores NaN ou usar comprimentos diferentes para y_obs e y_pred."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Soma dos Quadrados Totais (SS_tot)",
                                  "subSteps": [
                                    "Compute os desvios dos valores observados em relação à média: dev = y_obs - y_mean.",
                                    "Eleve os desvios ao quadrado: sq_dev = dev ** 2.",
                                    "Some todos os quadrados: SS_tot = soma(sq_dev).",
                                    "Implemente em código: ss_tot = np.sum((y_obs - y_mean) ** 2).",
                                    "Valide com um exemplo pequeno: para [1,3], média=2, SS_tot=4."
                                  ],
                                  "verification": "SS_tot deve ser positivo e zero apenas se todos y_obs forem iguais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com NumPy; dados preparados do Step 1.",
                                  "tips": "Evite loops manuais; vetorização NumPy é mais rápida e precisa.",
                                  "learningObjective": "Dominar o cálculo da variância total explicada pelos dados.",
                                  "commonMistakes": "Usar y_pred em vez de y_obs; esquecer de elevar ao quadrado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Soma dos Quadrados dos Resíduos (SS_res)",
                                  "subSteps": [
                                    "Compute os resíduos: res = y_obs - y_pred.",
                                    "Eleve os resíduos ao quadrado: sq_res = res ** 2.",
                                    "Some os quadrados: SS_res = soma(sq_res).",
                                    "Implemente em código: ss_res = np.sum((y_obs - y_pred) ** 2).",
                                    "Verifique se SS_res < SS_tot para bom ajuste (intuitivamente)."
                                  ],
                                  "verification": "SS_res deve ser não-negativo e menor que SS_tot em modelos úteis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com NumPy; y_obs, y_pred e y_mean do Step 1.",
                                  "tips": "Plote resíduos vs. preditos para inspeção visual de padrões.",
                                  "learningObjective": "Entender os resíduos como medida de erro do modelo.",
                                  "commonMistakes": "Confundir sinal dos resíduos (use absoluto só se necessário, mas aqui é quadrado)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar o Coeficiente de Determinação R² e Interpretar",
                                  "subSteps": [
                                    "Calcule R² = 1 - (SS_res / SS_tot).",
                                    "Implemente em código: r2 = 1 - (ss_res / ss_tot).",
                                    "Trate casos especiais: se SS_tot == 0, R² indefinido; imprima mensagem.",
                                    "Interprete: R² próximo de 1 indica bom ajuste; <0.7 pode ser ruim.",
                                    "Gere relatório com R² e gráfico de ajuste (scatter y_obs vs y_pred)."
                                  ],
                                  "verification": "R² deve estar entre 0 e 1 (ou negativo para pior que média).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy/Matplotlib; resultados dos Steps anteriores.",
                                  "tips": "Use np.isclose() para comparações; sempre valide divisão por zero.",
                                  "learningObjective": "Aplicar fórmula de R² e interpretar qualidade do ajuste.",
                                  "commonMistakes": "Dividir por SS_tot zero; interpretar R² como causalidade."
                                }
                              ],
                              "practicalExample": "Em um teste de tração de concreto, dados: y_obs = [0.1, 0.2, 0.35, 0.5], y_pred = [0.12, 0.19, 0.36, 0.48]. y_mean ≈ 0.2875, SS_tot ≈ 0.0703, SS_res ≈ 0.0013, R² ≈ 0.9815 (excelente ajuste para previsão de deformação).",
                              "finalVerifications": [
                                "R² calculado está entre -∞ e 1, tipicamente 0-1.",
                                "SS_res ≤ SS_tot.",
                                "Código reproduz R² idêntico ao rodar múltiplas vezes.",
                                "Gráfico scatter mostra pontos próximos à linha y=x.",
                                "Interpretação verbal correta (ex: '91% da variância explicada').",
                                "Teste com dados perfeitos: R²=1.0."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro < 1e-6 vs. valor analítico.",
                                "Código limpo, comentado e reproduzível.",
                                "Interpretação correta de R² (proporção de variância explicada).",
                                "Tratamento de edge cases (SS_tot=0).",
                                "Visualizações incluídas para validação.",
                                "Eficiência: uso de vetorização, não loops."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceitos de variância e regressão.",
                                "Programação: Manipulação de arrays NumPy e funções.",
                                "Engenharia de Materiais: Avaliação de modelos em testes mecânicos.",
                                "Análise de Dados: Métricas de qualidade em machine learning."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, R² avalia quão bem um modelo linear prediz deformações em vigas sob carga, auxiliando na otimização de estruturas seguras e econômicas, como em pontes ou edifícios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.4.3",
                            "name": "Avaliar matriz de Gram e autovalores",
                            "description": "Calcular autovalores de Xᵀ X para diagnosticar condicionamento e singularidade (ref. Kincaid & Cheney).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir a Matriz de Gram XᵀX",
                                  "subSteps": [
                                    "Colete os dados de entrada na forma de matriz X (n x p, onde n > p).",
                                    "Verifique se X está centralizada (subtraia a média das colunas se necessário).",
                                    "Compute XᵀX usando multiplicação matricial.",
                                    "Armazene a matriz resultante como uma matriz simétrica positiva semi-definida.",
                                    "Confirme as dimensões: deve ser p x p."
                                  ],
                                  "verification": "Verifique se XᵀX é simétrica (XᵀX = (XᵀX)ᵀ) e dimensões corretas usando trace ou det.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python (NumPy), MATLAB ou calculadora matricial; dados de exemplo de regressão linear.",
                                  "tips": "Use funções built-in como np.dot(X.T, X) para eficiência numérica.",
                                  "learningObjective": "Entender a construção da matriz de Gram como base para análise espectral.",
                                  "commonMistakes": "Esquecer de centralizar X, levando a autovalores enviesados; confundir XᵀX com XXᵀ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Autovalores e Autovetores",
                                  "subSteps": [
                                    "Aplique o método de decomposição espectral em XᵀX.",
                                    "Ordene autovalores em ordem decrescente (λ₁ ≥ λ₂ ≥ ... ≥ λₚ).",
                                    "Identifique autovetores correspondentes normalizados.",
                                    "Verifique a relação: XᵀX v = λ v para cada par.",
                                    "Registre autovalores próximos a zero."
                                  ],
                                  "verification": "Confirme que a soma dos autovalores equals trace(XᵀX) e produto equals det(XᵀX).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Bibliotecas NumPy.linalg.eig ou MATLAB eig(); referência Kincaid & Cheney cap. 7.",
                                  "tips": "Use eigvals apenas se não precisar de autovetores para economizar tempo.",
                                  "learningObjective": "Dominar o cálculo numérico de autovalores para matrizes simétricas.",
                                  "commonMistakes": "Não ordenar autovalores, dificultando análise; ignorar precisão numérica em autovalores pequenos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diagnosticar o Número de Condição",
                                  "subSteps": [
                                    "Identifique λ_max (maior autovalor) e λ_min (menor autovalor > 0).",
                                    "Calcule cond(X) ≈ sqrt(λ_max / λ_min).",
                                    "Classifique: cond < 10² bom; 10²-10⁶ moderado; >10⁶ ruim.",
                                    "Compare com cond(X) direto para validação.",
                                    "Documente o impacto em soluções de mínimos quadrados."
                                  ],
                                  "verification": "Simule perturbação nos dados e verifique estabilidade da solução.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "NumPy para sqrt e ratios; gráficos de autovalores.",
                                  "tips": "Use log-scale para visualizar gaps em autovalores.",
                                  "learningObjective": "Avaliar il-condicionamento via espectro de autovalores.",
                                  "commonMistakes": "Usar λ_min = 0 em vez do menor positivo; confundir cond(X) com cond(XᵀX)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Singularidade e Multicolinearidade",
                                  "subSteps": [
                                    "Identifique autovalores |λ| < ε (ε=1e-10 típico).",
                                    "Conte o número de autovalores efetivos (rank da matriz).",
                                    "Analise gaps entre autovalores para detectar multicolinearidade.",
                                    "Relacione com VIF (Variance Inflation Factor) se aplicável.",
                                    "Recomende regularização se singular."
                                  ],
                                  "verification": "Teste rank(XᵀX) == rank(X) e verifique se det(XᵀX) ≈ 0 indica singularidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Threshold ε configurável; plot de scree para visualização.",
                                  "tips": "Em engenharia civil, dados de sensores frequentemente têm multicolinearidade.",
                                  "learningObjective": "Diagnosticar problemas de singularidade em ajustes de curvas.",
                                  "commonMistakes": "Definir ε muito pequeno, ignorando ruído numérico; não considerar contexto físico."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e Reportar Resultados",
                                  "subSteps": [
                                    "Resuma métricas: cond number, rank efetivo, autovalores dominantes.",
                                    "Discuta implicações para mínimos quadrados (sensibilidade a ruído).",
                                    "Sugira ações: remover variáveis, regularizar (Ridge).",
                                    "Gere relatório com tabelas e gráficos.",
                                    "Valide com exemplo real de engenharia civil."
                                  ],
                                  "verification": "Compare diagnósticos com solução analítica conhecida.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Matplotlib/Plots para visualizações; template de relatório.",
                                  "tips": "Sempre contextualize com o problema de ajuste de curvas.",
                                  "learningObjective": "Comunicar análises espectrais de forma acionável.",
                                  "commonMistakes": "Superestimar problemas sem evidência estatística; ignorar trade-offs de regularização."
                                }
                              ],
                              "practicalExample": "Em um projeto de engenharia civil, ajuste uma reta y = a x + b a dados de deformação vs. carga em uma viga (X = [ones, x_col]). Compute XᵀX (2x2), autovalores [λ1=100, λ2=1e-5], cond≈316, diagnosticando multicolinearidade devido a dados quase lineares, recomendando remoção de pontos outlier.",
                              "finalVerifications": [
                                "Autovalores calculados com precisão numérica (erro <1e-10).",
                                "Número de condição matches cálculo direto de X.",
                                "Rank detectado equals dimensões independentes físicas.",
                                "Relatório inclui gráficos de autovalores ordenados.",
                                "Recomendações alinhadas com diagnóstico (ex: regularização).",
                                "Validação cruzada com solução estável."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de autovalores (90%+ match com referência).",
                                "Correta interpretação de cond number e singularidade.",
                                "Uso apropriado de thresholds e visualizações.",
                                "Profundidade da análise de multicolinearidade.",
                                "Clareza e completude do relatório.",
                                "Aplicação contextual a problemas de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Similar a PCA para redução de dimensionalidade em dados multivariados.",
                                "Física: Análise modal em vibrações estruturais (autovalores de rigidez).",
                                "Computação: Algoritmos numéricos para decomposição QL ou Lanczos.",
                                "Matemática Aplicada: Teoria espectral em operadores auto-adjuntos."
                              ],
                              "realWorldApplication": "Na engenharia civil, avaliar XᵀX em ajuste de curvas para dados de monitoramento estrutural (ex: sensores IoT em pontes) detecta multicolinearidade de ventos/temperatura, previne erros em predições de fadiga e otimiza modelos preditivos para manutenção preditiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Equações Normais e Matriz de Gram",
                    "description": "Sistema de equações derivado do mínimos quadrados linear, envolvendo a matriz de Gram para solução.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Método dos Mínimos Quadrados Linear",
                        "description": "Fundamentação teórica do método dos mínimos quadrados para ajuste de curvas lineares, minimizando a soma dos quadrados dos resíduos entre valores observados e preditos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Formular o problema de ajuste de curvas",
                            "description": "Dado um conjunto de dados experimentais (x_i, y_i), formular a função objetivo para minimizar a soma dos quadrados dos resíduos ε_i = y_i - ∑ β_j φ_j(x_i), onde φ_j são funções base lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o conjunto de dados e selecionar funções base lineares",
                                  "subSteps": [
                                    "Colete ou revise o conjunto de dados experimentais {(x_i, y_i)} para i=1 a n.",
                                    "Escolha funções base φ_j(x) que sejam lineares nos parâmetros β_j, como φ_1(x)=1 (constante), φ_2(x)=x (linear), φ_3(x)=x² (quadrática).",
                                    "Verifique se o número de funções base (p) é menor que n para evitar superdeterminação.",
                                    "Registre os valores de x_i e y_i em uma tabela organizada.",
                                    "Confirme que os dados representam uma relação física relevante no contexto da engenharia civil."
                                  ],
                                  "verification": "Lista de funções base φ_j(x) anotada corretamente com pelo menos 2-3 exemplos e tabela de dados completa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou planilha Excel/Google Sheets",
                                    "Conjunto de dados experimentais exemplo (ex: carga vs. deflexão)"
                                  ],
                                  "tips": "Comece com funções base simples (polinomiais de baixo grau) para evitar overfitting.",
                                  "learningObjective": "Compreender como dados experimentais e funções base formam a base do modelo de ajuste.",
                                  "commonMistakes": [
                                    "Escolher funções não-lineares nos parâmetros (ex: exp(βx))",
                                    "Ignorar outliers nos dados iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o modelo preditivo e calcular resíduos",
                                  "subSteps": [
                                    "Escreva o modelo: ŷ_i = ∑_{j=1}^p β_j φ_j(x_i).",
                                    "Para cada i, calcule o resíduo ε_i = y_i - ŷ_i.",
                                    "Expresse ε_i explicitamente: ε_i = y_i - ∑_{j=1}^p β_j φ_j(x_i).",
                                    "Crie uma matriz Φ onde Φ_{i j} = φ_j(x_i) para representar o modelo em forma matricial (opcional inicial).",
                                    "Verifique com um ponto de dados: calcule ε para β arbitrários."
                                  ],
                                  "verification": "Fórmula de ε_i escrita corretamente para todos os i, com exemplo numérico para um dado ponto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python (NumPy) ou MATLAB",
                                    "Tabela de dados do Step 1"
                                  ],
                                  "tips": "Use notação vetorial para clareza: ε = y - Φ β.",
                                  "learningObjective": "Dominar a definição de resíduos como diferença entre observado e predito.",
                                  "commonMistakes": [
                                    "Confundir ordem da subtração (ε_i = pred - y_i)",
                                    "Esquecer soma sobre j"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a função objetivo de mínimos quadrados",
                                  "subSteps": [
                                    "Defina a função objetivo J(β) = ∑_{i=1}^n ε_i² = ∑_{i=1}^n (y_i - ∑_{j=1}^p β_j φ_j(x_i))².",
                                    "Expanda para mostrar dependência quadrática em β.",
                                    "Escreva em forma matricial: J(β) = ||y - Φ β||² = (y - Φ β)^T (y - Φ β).",
                                    "Identifique que J é convexa e tem mínimo único se Φ tem posto cheio.",
                                    "Teste com dados pequenos: compute J para diferentes β."
                                  ],
                                  "verification": "Função J(β) expressa corretamente em notação escalar e matricial, com expansão verificada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de álgebra simbólica (SymPy em Python ou Mathematica)",
                                    "Matriz Φ construída"
                                  ],
                                  "tips": "Sempre expanda J para ver termos lineares, quadráticos e constante.",
                                  "learningObjective": "Formular precisamente o problema de otimização não-constrita.",
                                  "commonMistakes": [
                                    "Usar soma absoluta em vez de quadrados",
                                    "Esquecer o expoente 2 nos resíduos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a formulação e preparar para resolução",
                                  "subSteps": [
                                    "Confirme que minimizar J(β) leva às equações normais: Φ^T Φ β = Φ^T y.",
                                    "Verifique dimensionalidade: J é escalar, ∇J=0 dá p equações.",
                                    "Discuta condições para solução única (Φ coluna-linearmente independente).",
                                    "Implemente uma função J em código para dados exemplo.",
                                    "Compare J para β ótimo vs. ruim."
                                  ],
                                  "verification": "Gradiente de J derivado corretamente e equações normais identificadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "Código template para J(β)"
                                  ],
                                  "tips": "Use np.linalg.norm(y - Phi @ beta)**2 para validação rápida.",
                                  "learningObjective": "Conectar formulação à solução via derivadas.",
                                  "commonMistakes": [
                                    "Assumir Φ quadrada",
                                    "Ignorar multicolinearidade das φ_j"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um teste de viga simplesmente apoiada, dados de deflexão y_i (mm) vs. posição x_i (m): (0,0), (0.5,1.2), (1.0,4.8), (1.5,10.8), (2.0,19.2). Use φ1=1, φ2=x, φ3=x^3 para modelar deflexão cúbica. Formule J(β) = ∑ (y_i - (β1 + β2 x_i + β3 x_i^3))^2.",
                              "finalVerifications": [
                                "Pode escrever ε_i corretamente para qualquer conjunto dado.",
                                "Formula J(β) em forma escalar e matricial sem erros.",
                                "Identifica funções base lineares adequadas para dados civis.",
                                "Computa J para valores β teste com precisão.",
                                "Explica ligação com equações normais.",
                                "Valida com exemplo numérico completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de resíduos (100% correto).",
                                "Correta formulação de J(β) em ambas notações (escalar/matricial).",
                                "Seleção apropriada de funções base (linearidade nos β).",
                                "Validação numérica sem erros de cálculo.",
                                "Compreensão conceitual (explicação oral ou escrita).",
                                "Preparação para próximos passos (equações normais)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear e análise de resíduos.",
                                "Álgebra Linear: Matrizes, normas e mínimos quadrados.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física/Mecânica: Modelagem de experimentos estruturais."
                              ],
                              "realWorldApplication": "Na engenharia civil, formula-se esse problema para calibrar modelos de deformação em solos (consolidação), prever deflexões em vigas ou ajustar curvas de retenção de água em barragens, permitindo simulações precisas e otimização de projetos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Derivar as condições de mínimo",
                            "description": "Aplicar derivadas parciais da função objetivo em relação aos coeficientes β_j e igualar a zero para obter o sistema de equações normais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função objetivo S(β) no método dos mínimos quadrados",
                                  "subSteps": [
                                    "Escreva a forma geral da função objetivo: S(β) = ∑_{i=1}^n [y_i - ∑_{j=1}^p β_j x_{ij}]^2",
                                    "Identifique os resíduos r_i = y_i - ∑_{j=1}^p β_j x_{ij} como a diferença entre valores observados e preditos",
                                    "Explique que o objetivo é minimizar S(β), que mede o erro total quadrático",
                                    "Considere o caso simples de regressão linear univariada para intuitição: S(β_0, β_1) = ∑ (y_i - β_0 - β_1 x_i)^2",
                                    "Verifique a dimensionalidade: n observações, p coeficientes"
                                  ],
                                  "verification": "Escrever corretamente S(β) para um conjunto de dados dado com p=2 e n=3",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Folha com exemplo de dados de regressão linear",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Visualize S(β) como uma superfície parabolóide com mínimo único em regressão linear sem multicolinearidade",
                                  "learningObjective": "Compreender a função objetivo como soma quadrática dos erros de predição",
                                  "commonMistakes": [
                                    "Esquecer o expoente ^2 nos resíduos",
                                    "Confundir y_i com x_{ij}",
                                    "Ignorar a dependência em múltiplas variáveis independentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a derivada parcial ∂S/∂β_k",
                                  "subSteps": [
                                    "Expanda S(β) e aplique a derivada parcial: ∂S/∂β_k = ∑_{i=1}^n 2 r_i ⋅ ∂r_i/∂β_k",
                                    "Determine ∂r_i/∂β_k = -x_{ik}, pois r_i = y_i - ∑ β_j x_{ij}",
                                    "Simplifique: ∂S/∂β_k = -2 ∑_{i=1}^n r_i x_{ik}",
                                    "Repita para cada k de 1 a p, formando um conjunto de equações",
                                    "Pratique com p=1 (regressão simples): ∂S/∂β_1 = -2 ∑ (y_i - β_1 x_i) x_i"
                                  ],
                                  "verification": "Derivar e simplificar ∂S/∂β_k para um exemplo com p=2, obtendo -2 ∑ r_i x_{ik}",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo numérico com matriz X de 3x2",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Use a regra da cadeia sistematicamente; lembre que apenas o termo com β_k afeta a derivada para cada i",
                                  "learningObjective": "Dominar o cálculo de derivadas parciais da função quadrática S(β)",
                                  "commonMistakes": [
                                    "Esquecer o fator 2 da derivada do quadrado",
                                    "Sinal errado no ∂r_i/∂β_k",
                                    "Não somar sobre todos i"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer as condições de mínimo igualando ∂S/∂β_k = 0",
                                  "subSteps": [
                                    "Defina ∂S/∂β_k = 0 para cada k: ∑_{i=1}^n r_i x_{ik} = 0",
                                    "Interprete geometricamente: os resíduos são ortogonais às colunas de X",
                                    "Escreva em forma matricial: ∑_{i=1}^n (y_i - ∑ β_j x_{ij}) x_{ik} = 0 para todo k",
                                    "Expanda: ∑ y_i x_{ik} = ∑_{j=1}^p β_j ∑ x_{ij} x_{ik}",
                                    "Verifique para regressão simples: condições levam a médias ponderadas"
                                  ],
                                  "verification": "A partir de ∂S/∂β_k, obter ∑ r_i x_{ik} = 0 e expandir corretamente",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Matriz X e vetor y de exemplo",
                                    "Gráfico de resíduos ortogonais"
                                  ],
                                  "tips": "Pense em projeção ortogonal: o mínimo ocorre quando predito é projeção de y em espaço de colunas de X",
                                  "learningObjective": "Aplicar a condição de mínimo de função diferenciável",
                                  "commonMistakes": [
                                    "Não dividir pelo -2 (mas como =0, irrelevante)",
                                    "Confundir índices i e k/j",
                                    "Ignorar ortogonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular o sistema de equações normais",
                                  "subSteps": [
                                    "Colete equações para todos k: X^T y = X^T X β",
                                    "Identifique a matriz de Gram G = X^T X e vetor b = X^T y",
                                    "Escreva o sistema linear G β = b",
                                    "Discuta invertibilidade: requer X com colunas linearmente independentes",
                                    "Resolva para β: β = (X^T X)^{-1} X^T y"
                                  ],
                                  "verification": "Transformar as p equações em X^T X β = X^T y para um X 3x2",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo matricial completo",
                                    "Calculadora matricial ou Python/Octave"
                                  ],
                                  "tips": "Sempre verifique se X^T X é definida positiva para mínimo único",
                                  "learningObjective": "Reconhecer as equações normais como solução analítica dos mínimos quadrados",
                                  "commonMistakes": [
                                    "Inverter a ordem em X^T X β = X^T y",
                                    "Confundir X^T y com y^T X",
                                    "Esquecer transposição"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere ajuste linear y ≈ β_0 + β_1 x com dados: (x1=1,y1=2), (x2=2,y2=3), (x3=3,y3=5). S(β0,β1) = (2-β0-β1)^2 + (3-β0-2β1)^2 + (5-β0-3β1)^2. ∂S/∂β0 = -2[(2-β0-β1) + (3-β0-2β1) + (5-β0-3β1)] = 0 → 10 = 3β0 + 6β1. ∂S/∂β1 = -2[1(2-β0-β1) + 2(3-β0-2β1) + 3(5-β0-3β1)] = 0 → 20 = 6β0 + 14β1. Matriz: [[3,6],[6,14]] β = [10,20]. Solução: β0≈1.0, β1≈1.5.",
                              "finalVerifications": [
                                "Escrever S(β) e suas derivadas parciais corretamente para p=2",
                                "Igualar ∂S/∂β_k=0 e obter ∑ r_i x_{ik}=0",
                                "Formular X^T X β = X^T y para dados numéricos",
                                "Interpretar ortogonalidade dos resíduos",
                                "Resolver sistema para β em exemplo simples",
                                "Verificar se β minimiza S computando S em β e vizinhos"
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de derivadas parciais (sem erros algébricos)",
                                "Correta transição para forma matricial das equações normais",
                                "Compreensão conceitual da ortogonalidade e mínimo",
                                "Capacidade de aplicar a um exemplo numérico completo",
                                "Identificação de pré-condições (colunas independentes de X)",
                                "Clareza na explicação verbal ou escrita do processo"
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Derivadas parciais e otimização",
                                "Álgebra Linear: Multiplicação matricial, sistemas lineares e projeções",
                                "Estatística: Regressão linear e análise de mínimos quadrados",
                                "Programação Numérica: Implementação em Python (numpy.linalg.lstsq)",
                                "Geometria Analítica: Projeção ortogonal em subespaços"
                              ],
                              "realWorldApplication": "Em engenharia civil, derivação das condições de mínimo permite ajustar curvas a dados de ensaios de materiais (ex.: relação tensão-deformação), prevendo comportamentos estruturais com mínimo erro, essencial para dimensionamento de vigas e lajes sob cargas reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Interpretar resíduos ponderados",
                            "description": "Explicar a extensão para resíduos ponderados no contexto de dados com variâncias diferentes, ajustando o método para problemas de engenharia civil com medições imprecisas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Resíduos em Mínimos Quadrados Ordinários",
                                  "subSteps": [
                                    "Relembre a definição de resíduos como a diferença entre valores observados e preditos: e_i = y_i - ŷ_i.",
                                    "Calcule resíduos para um conjunto de dados simples sem ponderação usando equações normais.",
                                    "Plote resíduos vs. preditos para identificar padrões como heterocedasticidade (variâncias variáveis).",
                                    "Discuta por que variâncias diferentes invalidam suposições de mínimos quadrados ordinários (MQO).",
                                    "Identifique sinais de medições imprecisas em dados de engenharia civil, como em levantamentos topográficos."
                                  ],
                                  "verification": "Construa um gráfico de resíduos que mostre variância crescente e explique o problema.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, planilha Excel ou Python (NumPy/Matplotlib), dados de exemplo de deformações estruturais.",
                                  "tips": "Sempre normalize os resíduos dividindo pelo desvio padrão estimado para comparação.",
                                  "learningObjective": "Compreender limitações do MQO com dados de variâncias heterogêneas.",
                                  "commonMistakes": "Ignorar heterocedasticidade ao assumir variâncias iguais em todos os pontos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Conceito de Pesos Baseados em Variâncias",
                                  "subSteps": [
                                    "Defina pesos w_i = 1/σ_i², onde σ_i² é a variância da i-ésima observação.",
                                    "Explique que pesos maiores são dados a medições mais precisas (menor variância).",
                                    "Discuta fontes de variância em engenharia civil: ruído instrumental em teodolitos vs. GPS preciso.",
                                    "Calcule pesos para um conjunto de dados hipotético com variâncias conhecidas ou estimadas.",
                                    "Compare distribuições ponderadas vs. não ponderadas usando soma ponderada de resíduos."
                                  ],
                                  "verification": "Calcule e liste pesos para 5 pontos de dados com variâncias dadas, verificando soma de pesos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Calculadora científica, software como MATLAB ou Python (SciPy), tabela de variâncias de instrumentos civis.",
                                  "tips": "Use variâncias conhecidas de manuais de equipamentos para realismo.",
                                  "learningObjective": "Dominar cálculo e justificativa de pesos inversamente proporcionais à variância.",
                                  "commonMistakes": "Confundir peso com inverso da variância (usar w_i = σ_i em vez de 1/σ_i²)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Aplicar Resíduos Ponderados",
                                  "subSteps": [
                                    "Estenda equações normais para MQ Ponderado (MQP): A^T W A β = A^T W y, onde W é diagonal de pesos.",
                                    "Calcule resíduos ponderados: e_i^w = w_i^{1/2} (y_i - ŷ_i).",
                                    "Ajuste um modelo linear simples com pesos e compute resíduos ponderados.",
                                    "Analise resíduos ponderados: devem ser ~N(0,1) se o modelo for adequado.",
                                    "Interprete desvios: resíduos ponderados grandes indicam outliers ou modelo inadequado em dados imprecisos."
                                  ],
                                  "verification": "Resolva um sistema MQP de 3 parâmetros e confirme que resíduos ponderados têm variância unitária.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (NumPy, SciPy.optimize.leastsq com pesos), ou MATLAB, conjunto de dados de nivelamento topográfico.",
                                  "tips": "Implemente W como matriz diagonal para evitar erros de indexação.",
                                  "learningObjective": "Aplicar formalmente MQP e interpretar resíduos normalizados.",
                                  "commonMistakes": "Esquecer de multiplicar por sqrt(w_i) nos resíduos ponderados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resíduos Ponderados em Contexto de Engenharia Civil",
                                  "subSteps": [
                                    "Aplique MQP a dados reais: medições de deslocamentos em uma barragem com diferentes precisões.",
                                    "Gere Q-Q plot e teste de Shapiro-Wilk nos resíduos ponderados para normalidade.",
                                    "Identifique e diagnostique problemas: ex., instrumento falho causa resíduo ponderado >3.",
                                    "Recomende ações: rejeitar dados outliers ou recalibrar instrumentos baseados em resíduos.",
                                    "Documente relatório: resuma achados com gráficos e implicações para projeto civil."
                                  ],
                                  "verification": "Produza relatório de 1 página com interpretação de resíduos em exemplo civil.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Dados reais/simulados de engenharia civil (ex., IBGE topografia), software de plotagem (Matplotlib/Origin).",
                                  "tips": "Foquem em resíduos padronizados |e_i^w| > 2.5 como flags de alerta.",
                                  "learningObjective": "Interpretar resíduos ponderados para decisões em projetos civis com dados imprecisos.",
                                  "commonMistakes": "Interpretar resíduos absolutos sem ponderação em dados heterogêneos."
                                }
                              ],
                              "practicalExample": "Em um levantamento topográfico para uma ponte, use medições de ângulos com teodolito (σ=0.5\") e GPS (σ=2cm). Aplique MQP para ajustar coordenadas, identifique resíduo ponderado alto no GPS devido a obstrução, e ajuste o modelo excluindo-o para precisão final de 1cm.",
                              "finalVerifications": [
                                "Explicar verbalmente diferença entre resíduos MQO e MQP com exemplo numérico.",
                                "Calcular corretamente pesos e resíduos ponderados para novo dataset.",
                                "Gerar gráfico de resíduos ponderados mostrando normalidade.",
                                "Diagnosticar outlier em dados civis baseado em |e^w| > 2.5.",
                                "Redigir parágrafo de interpretação para relatório de engenharia.",
                                "Comparar precisão de ajuste MQO vs MQP em termos de σ estimada."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de pesos (erro <1%).",
                                "Correta derivação/extensão das equações normais ponderadas.",
                                "Interpretação qualitativa e quantitativa de resíduos (normalidade, outliers).",
                                "Aplicação contextualizada a problemas civis com medições imprecisas.",
                                "Clareza em gráficos e relatórios (rótulos, escalas adequadas).",
                                "Identificação de pelo menos 3 erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de normalidade e heterocedasticidade (Shapiro-Wilk, Breusch-Pagan).",
                                "Programação: Implementação numérica em Python/MATLAB para otimização ponderada.",
                                "Física/Mecânica: Modelagem de incertezas em deformações estruturais.",
                                "Gestão de Projetos: Decisões baseadas em análise de dados imprecisos em obras civis."
                              ],
                              "realWorldApplication": "Na análise de monitoramento de barragens, MQP com resíduos ponderados permite detectar rachaduras precocemente apesar de sensores de baixa precisão em áreas remotas, evitando falhas catastróficas e otimizando manutenção com custo reduzido em 20-30%."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Equações Normais",
                        "description": "Sistema de equações lineares simétrico e positivo definido resultante da minimização dos mínimos quadrados, representado como A β = b.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Construir o vetor b das equações normais",
                            "description": "Calcular o vetor b com elementos b_j = ∑ y_i φ_j(x_i), utilizando dados de ajuste de curvas em problemas de engenharia civil como regressão linear simples ou múltipla.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados de entrada e definir as funções base φ_j",
                                  "subSteps": [
                                    "Colete os dados observados: pares (x_i, y_i) para i=1 até n.",
                                    "Defina o modelo polinomial ou linear: por exemplo, para regressão linear simples, φ_1(x) = 1 (constante) e φ_2(x) = x.",
                                    "Liste explicitamente todas as funções base φ_j(x) para j=1 até m (número de parâmetros).",
                                    "Crie uma tabela com colunas para x_i, y_i e cada φ_j(x_i).",
                                    "Verifique se os dados estão limpos (sem valores ausentes ou outliers evidentes)."
                                  ],
                                  "verification": "Tabela completa preenchida com valores numéricos para todos φ_j(x_i).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Dados de exemplo de engenharia civil (ex: cargas e deformações)"
                                  ],
                                  "tips": "Use funções de planilha como =1 para φ_1 e =A2 para φ_2(x_i) para automatizar.",
                                  "learningObjective": "Compreender a relação entre dados observados e funções base no método dos mínimos quadrados.",
                                  "commonMistakes": [
                                    "Confundir índices i (observações) com j (parâmetros)",
                                    "Esquecer a função constante φ_1(x)=1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o primeiro elemento b_1 = ∑ y_i φ_1(x_i)",
                                  "subSteps": [
                                    "Preencha a coluna y_i * φ_1(x_i) para cada i (φ_1(x_i)=1, então é apenas y_i).",
                                    "Some todos os valores: b_1 = ∑_{i=1}^n y_i * 1.",
                                    "Registre o valor de b_1 com precisão decimal adequada (ex: 4 casas).",
                                    "Verifique o cálculo manualmente para n pequeno.",
                                    "Anote unidades se aplicável (ex: deformação em mm)."
                                  ],
                                  "verification": "Soma b_1 calculada e conferida com pelo menos duas métodos (manual e planilha).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou planilha com função SOMA"
                                  ],
                                  "tips": "Em planilhas, use =SOMA(B2:B10*C2:C10) adaptado para φ_1.",
                                  "learningObjective": "Dominar o cálculo da projeção dos y_i na direção constante.",
                                  "commonMistakes": [
                                    "Usar média em vez de soma",
                                    "Inverter multiplicação y_i * φ_j"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os elementos restantes b_j para j ≥ 2",
                                  "subSteps": [
                                    "Para cada j ≥ 2, calcule y_i * φ_j(x_i) para todos i.",
                                    "Some: b_j = ∑_{i=1}^n y_i φ_j(x_i).",
                                    "Repita para todos j até m (ex: b_2 = ∑ y_i x_i para linear simples).",
                                    "Use vetores ou colunas paralelas para eficiência.",
                                    "Conferir dimensionalidade: b_j deve ter unidades consistentes com y * φ_j."
                                  ],
                                  "verification": "Todos b_j calculados e tabela de somas completa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha com colunas múltiplas",
                                    "Software como MATLAB ou Python (opcional)"
                                  ],
                                  "tips": "Automatize com fórmulas arrastáveis para evitar erros de cópia.",
                                  "learningObjective": "Aplicar a fórmula geral b_j em contextos multivariados.",
                                  "commonMistakes": [
                                    "Erro em φ_j (ex: usar x^2 em vez de x)",
                                    "Somas parciais em vez de totais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar o vetor b e validar o cálculo",
                                  "subSteps": [
                                    "Agrupe os b_j em vetor coluna: b = [b_1, b_2, ..., b_m]^T.",
                                    "Calcule normas ou verifique se ||b|| faz sentido fisicamente.",
                                    "Compare com solução analítica conhecida para modelo simples.",
                                    "Implemente em código simples (ex: Python loop) para confirmação.",
                                    "Documente o vetor final com contexto do problema."
                                  ],
                                  "verification": "Vetor b escrito em formato matemático e numérico, validado por método alternativo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para notação vetorial",
                                    "Editor de código como Jupyter Notebook"
                                  ],
                                  "tips": "Represente como lista ou array: b = np.array([b1, b2]).",
                                  "learningObjective": "Integrar cálculos em estrutura vetorial para equações normais.",
                                  "commonMistakes": [
                                    "Ordem errada dos elementos",
                                    "Confundir b com vetor de parâmetros β"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga de concreto sob cargas crescentes: dados x_i = [0, 1, 2, 3, 4] kN, y_i = [0, 0.1, 0.22, 0.31, 0.42] mm. Para y = β1 + β2 x, φ1=1, φ2=x. Então b1 = ∑ y_i = 1.05, b2 = ∑ x_i y_i = 2.75, b = [1.05, 2.75]^T.",
                              "finalVerifications": [
                                "Cálculo de b_j reproduzido manualmente sem erros.",
                                "Vetor b usado corretamente em A β = b para resolver β.",
                                "Mudança em um y_i altera b_j proporcionalmente.",
                                "Unidades de b_j consistentes com y * φ_j.",
                                "Resultado converge para modelo conhecido (ex: regressão simples)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos somatórios (erro < 0.1%).",
                                "Correta identificação e aplicação de φ_j.",
                                "Eficiência no uso de ferramentas computacionais.",
                                "Explicação clara da fórmula b_j = ∑ y_i φ_j(x_i).",
                                "Validação cruzada com exemplo real.",
                                "Documentação completa do processo."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Projeção ortogonal em mínimos quadrados.",
                                "Programação: Implementação em loops Python ou MATLAB.",
                                "Álgebra Linear: Vetores e produtos escalares.",
                                "Física/Engenharia: Modelagem de deformações em estruturas."
                              ],
                              "realWorldApplication": "Em engenharia civil, constrói o lado direito das equações normais para ajustar curvas de calibragem de sensores em pontes, prevendo deformações sob carga via regressão, otimizando projetos de vigas e lajes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Montar a matriz A das equações normais",
                            "description": "Formar a matriz simétrica A com elementos a_{jk} = ∑ φ_j(x_i) φ_k(x_i), identificando-a como a matriz de Gram das funções base.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados e funções base",
                                  "subSteps": [
                                    "Identifique as funções base φ_j(x) para j = 1 a m, como polinômios (ex: φ1(x)=1, φ2(x)=x, φ3(x)=x²).",
                                    "Liste todos os pontos de dados x_i (i=1 a n) e valores observados y_i, se aplicável.",
                                    "Defina o tamanho da matriz A como m x m, onde m é o número de funções base.",
                                    "Anote os pesos w_i se o problema usar mínimos quadrados ponderados (caso contrário, w_i=1).",
                                    "Crie uma tabela inicial com linhas para j e colunas para k."
                                  ],
                                  "verification": "Listas completas de φ_j, x_i e tabela vazia m x m prontas para preenchimento.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado ou planilha Excel",
                                    "Calculadora ou software como MATLAB/Python",
                                    "Enunciado do problema com dados"
                                  ],
                                  "tips": "Comece com m pequeno (2-3 funções) para prática; visualize funções base graficamente se possível.",
                                  "learningObjective": "Compreender os insumos necessários para formar a matriz das equações normais.",
                                  "commonMistakes": [
                                    "Confundir funções base φ_j com os valores y_i observados",
                                    "Esquecer de incluir todas as funções base especificadas no problema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os elementos a_jk",
                                  "subSteps": [
                                    "Para cada par (j,k) com j ≤ k (aproveitando simetria), compute a_jk = ∑_{i=1}^n φ_j(x_i) * φ_k(x_i) * w_i.",
                                    "Calcule os valores φ_j(x_i) para todos i e j, armazenando em uma tabela auxiliar.",
                                    "Some os produtos para cada (j,k), verificando cálculos intermediários.",
                                    "Preencha a parte superior da tabela com a_jk e copie para a inferior (a_kj = a_jk).",
                                    "Verifique a diagonal (j=k): a_jj = ∑ φ_j(x_i)² deve ser positiva."
                                  ],
                                  "verification": "Todos os a_jk calculados corretamente com pelo menos um cálculo spot-check duplicado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha para tabela auxiliar de φ_j(x_i)",
                                    "Software NumPy para validação opcional"
                                  ],
                                  "tips": "Use simetria para calcular apenas metade dos elementos e transpor; arredonde consistentemente.",
                                  "learningObjective": "Dominar o cálculo do produto interno discreto entre funções base.",
                                  "commonMistakes": [
                                    "Índices errados em sum (usar i ou j incorretamente)",
                                    "Esquecer multiplicação por pesos w_i",
                                    "Erro aritmético em somas longas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e verificar a matriz A",
                                  "subSteps": [
                                    "Monte a matriz A posicionando a_jk na linha j, coluna k.",
                                    "Confirme simetria: A = A^T, verificando a_ji = a_ij para i ≠ j.",
                                    "Calcule determinante ou traço para sanity check se m pequeno.",
                                    "Escreva A em notação matricial formal.",
                                    "Teste com multiplicação por vetor de coeficientes para ver se gera vetor b das equações normais."
                                  ],
                                  "verification": "Matriz A escrita corretamente, simétrica e com elementos exatos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para matriz",
                                    "Software como MATLAB para plotar matriz"
                                  ],
                                  "tips": "Use notação LaTeX ou simbólica para clareza; verifique transposta manualmente.",
                                  "learningObjective": "Construir a matriz simétrica A a partir dos elementos calculados.",
                                  "commonMistakes": [
                                    "Inverter linhas/colunas ao montar",
                                    "Não garantir simetria exata devido a erros de arredondamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar A como matriz de Gram",
                                  "subSteps": [
                                    "Explique que a_jk = <φ_j, φ_k> no produto interno discreto ∑ φ_j(x_i) φ_k(x_i).",
                                    "Relacione com definição de matriz de Gram em espaços de funções.",
                                    "Discuta propriedades: simétrica, definida semi positiva.",
                                    "Compare com caso contínuo ∫ φ_j φ_k dx.",
                                    "Aplique contexto: A φ = b nas equações normais para mínimos quadrados."
                                  ],
                                  "verification": "Definição e propriedades da matriz de Gram explicadas por escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de álgebra linear ou referência online sobre Gram matrix",
                                    "Notas de aula sobre ajuste de curvas"
                                  ],
                                  "tips": "Pense em ortogonalidade: se diagonal dominante, bases quase ortogonais.",
                                  "learningObjective": "Reconhecer a interpretação teórica de A como matriz de Gram das funções base.",
                                  "commonMistakes": [
                                    "Confundir com matriz de covariância",
                                    "Ignorar normalização ou pesos no inner product"
                                  ]
                                }
                              ],
                              "practicalExample": "Para dados x_i = [0,1,2], funções base φ1(x)=1, φ2(x)=x (m=2, n=3). Calcule: φ1(x)=[1,1,1], φ2(x)=[0,1,2]. Então a11=1+1+1=3, a12=0+1+2=3, a21=3, a22=0+1+4=5. A = [[3,3],[3,5]]. Verifique simetria e note como Gram matrix.",
                              "finalVerifications": [
                                "Matriz A é simétrica (A = A^T).",
                                "Elementos diagonais positivos (definida positiva).",
                                "Cálculos de a_jk batem com spot-checks manuais.",
                                "Identificada corretamente como matriz de Gram.",
                                "Preparada para resolver A α = b nas equações normais.",
                                "Sem erros aritméticos em pelo menos 80% dos elementos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de produtos internos (erro <1%).",
                                "Correta montagem e verificação de simetria.",
                                "Explicação clara da interpretação como matriz de Gram.",
                                "Uso apropriado de simetria para eficiência.",
                                "Sanity checks realizados (ex: traço positivo).",
                                "Integração com contexto de ajuste de curvas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: produto interno e matrizes de Gram.",
                                "Estatística: base teórica dos mínimos quadrados ordinários.",
                                "Programação: implementação em NumPy (np.dot(Phi.T, Phi)).",
                                "Análise Numérica: condicionamento de A para resolução.",
                                "Engenharia Civil: modelagem de regressão em dados experimentais."
                              ],
                              "realWorldApplication": "Na engenharia civil, montar A permite ajustar curvas a dados de ensaios de materiais (ex: curva tensão-deformação), gerando modelos preditivos para dimensionamento de estruturas via regressão polinomial, minimizando erros em simulações computacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Resolver o sistema A β = b",
                            "description": "Aplicar métodos diretos como decomposição Cholesky para resolver o sistema simétrico positivo definido, considerando aplicações numéricas em MATLAB ou software similar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar se a matriz A é simétrica positiva definida (SPD)",
                                  "subSteps": [
                                    "Confirmar simetria: A = A^T",
                                    "Verificar positivos definitos: todos autovalores > 0 ou testes de Cholesky iniciais",
                                    "Calcular determinante ou traço para indícios iniciais",
                                    "Analisar contexto do problema (ex: matriz de Gram em ajuste de curvas)",
                                    "Documentar propriedades para justificativa"
                                  ],
                                  "verification": "Matriz passa nos testes de simetria e positivos definitos sem erros numéricos",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Matriz A de exemplo, MATLAB ou Python (eig, choltest)",
                                  "tips": "Use cond(A) < 1e12 para checar condicionamento antes",
                                  "learningObjective": "Identificar pré-condições para aplicação de Cholesky",
                                  "commonMistakes": "Ignorar condicionamento ruim levando a instabilidade numérica"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar a decomposição Cholesky: A = L L^T",
                                  "subSteps": [
                                    "Inicializar L como matriz triangular inferior unitária",
                                    "Aplicar fórmula: l_{ii} = sqrt(a_{ii} - sum l_{ik}^2), l_{ji} = (a_{ji} - sum l_{jk} l_{ik}) / l_{ii}",
                                    "Implementar algoritmo passo a passo manualmente para pequena matriz",
                                    "Verificar A ≈ L * L' computacionalmente",
                                    "Ajustar para precisão numérica se necessário"
                                  ],
                                  "verification": "L * L^T reproduz A com erro < 1e-10",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel e lápis para manual, MATLAB (chol(A)) para verificação",
                                  "tips": "Comece com matriz 3x3 para prática manual",
                                  "learningObjective": "Executar decomposição Cholesky manual e algorítmica",
                                  "commonMistakes": "Arredondamento em sqrt levando a L não exata"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o sistema triangular: Ly = b e L^T β = y",
                                  "subSteps": [
                                    "Forward substitution: y1 = b1 / l11, yi = (bi - sum l_{ik} yk) / l_{ii}",
                                    "Backward substitution: βn = yn / l_{nn}, βi = (yi - sum l_{jk} βk) / l_{ii} para j=i",
                                    "Implementar funções separadas para forward e backward",
                                    "Calcular β final",
                                    "Verificar consistência com A β = b"
                                  ],
                                  "verification": "Residual ||A β - b|| < 1e-8",
                                  "estimatedTime": "30 minutos",
                                  "materials": "L de step anterior, vetor b, MATLAB (mldivide ou manual)",
                                  "tips": "Implemente em loop para evitar recursão",
                                  "learningObjective": "Dominar substituições forward e backward",
                                  "commonMistakes": "Confundir índices em substituições levando a β errada"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar em MATLAB ou software similar",
                                  "subSteps": [
                                    "Escrever script MATLAB: [L] = chol(A); y = L\\b; beta = L'\\y",
                                    "Gerar matriz A de exemplo SPD (ex: gallery('randsvd',n))",
                                    "Comparar com solução direta A\\b",
                                    "Analisar tempo de execução vs Gaussian elimination",
                                    "Testar com ruído numérico e múltiplos tamanhos"
                                  ],
                                  "verification": "Soluções coincidem e tempo Cholesky é menor para SPD",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB ou Octave, exemplos de gallery",
                                  "tips": "Use tic/toc para benchmark",
                                  "learningObjective": "Aplicar Cholesky numericamente de forma eficiente",
                                  "commonMistakes": "Não pivotear, mas Cholesky não precisa para SPD exata"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar solução no contexto de ajuste de curvas",
                                  "subSteps": [
                                    "Gerar dados de exemplo (carga vs deformação)",
                                    "Construir matriz de Gram A = X^T X",
                                    "Resolver β e plotar curva ajustada",
                                    "Calcular R^2 ou erro médio quadrático",
                                    "Interpretar coeficientes β fisicamente"
                                  ],
                                  "verification": "Curva ajustada reproduz dados com baixo erro",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Dados sintéticos, MATLAB plot",
                                  "tips": "Adicione regularização se A mal-condicionada",
                                  "learningObjective": "Conectar Cholesky a aplicações reais em engenharia",
                                  "commonMistakes": "Interpretar β sem contexto físico"
                                }
                              ],
                              "practicalExample": "Em teste de viga: dados de 5 pontos (carga [1,2,3,4,5], deformação [0.1,0.2,0.31,0.41,0.52]). A = X^T X onde X tem coluna 1s e cargas. Resolver A β = X^T deformação para β = [deform0, rigidez].",
                              "finalVerifications": [
                                "||A β - b||_2 < 1e-10",
                                "Cholesky converge sem warning de não-SPD",
                                "Solução coincide com A\\b",
                                "Tempo de Cholesky < tempo de LU para n>10",
                                "Aplicação real: R^2 > 0.95 no ajuste",
                                "Estabilidade numérica: cond(L) razoável"
                              ],
                              "assessmentCriteria": [
                                "Precisão da decomposição (erro <1e-12)",
                                "Correção das substituições forward/backward",
                                "Eficiência computacional demonstrada",
                                "Validação contextual em engenharia civil",
                                "Código MATLAB limpo e comentado",
                                "Análise de erros comuns evitados"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear mínima quadrados",
                                "Física: Modelagem constitutiva em estruturas",
                                "Programação: Algoritmos numéricos em MATLAB",
                                "Otimização: Sistemas lineares em problemas inversos"
                              ],
                              "realWorldApplication": "Na engenharia civil, resolve equações normais para ajuste de curvas em dados experimentais de ensaios de materiais, como relação tensão-deformação em concretos, permitindo previsão de comportamento estrutural e dimensionamento seguro."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.1",
                              "10.1.7.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.3",
                        "name": "Matriz de Gram e Condicionamento",
                        "description": "Matriz associada aos produtos internos das funções base, analisando suas propriedades de condicionamento, autovalores e estabilidade numérica na solução.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.3.1",
                            "name": "Construir a matriz de Gram",
                            "description": "Definir e calcular a matriz de Gram G_{jk} = <φ_j, φ_k> = ∑ φ_j(x_i) φ_k(x_i), relacionando-a diretamente à matriz A das equações normais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os dados de entrada e funções base",
                                  "subSteps": [
                                    "Liste os pontos de dados x_i disponíveis no conjunto de ajuste de curvas.",
                                    "Defina as funções base φ_j(x) para j = 1 até m (ex: φ1(x)=1, φ2(x)=x, φ3(x)=x²).",
                                    "Confirme o número de pontos n e o grau do polinômio m, garantindo n > m para superdeterminação.",
                                    "Registre os valores y_i se necessário para contexto, mas foque em φ_j(x_i).",
                                    "Crie uma tabela com linhas para x_i e colunas para cada φ_j(x_i)."
                                  ],
                                  "verification": "Verifique se a tabela de valores φ_j(x_i) está completa e sem erros de cálculo inicial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou planilha Excel",
                                    "Dados do problema de ajuste de curvas"
                                  ],
                                  "tips": "Comece com funções base simples para evitar confusão; use notação matricial Φ onde linhas são x_i e colunas φ_j.",
                                  "learningObjective": "Compreender a relação entre pontos de dados e funções base na definição do produto interno.",
                                  "commonMistakes": [
                                    "Confundir φ_j com y_i",
                                    "Esquecer de avaliar φ em todos os x_i",
                                    "Usar índices errados para j e k"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os elementos G_{jk} = ∑_{i=1}^n φ_j(x_i) φ_k(x_i)",
                                  "subSteps": [
                                    "Para cada par (j,k) com j,k = 1 a m, compute o produto φ_j(x_i) * φ_k(x_i) para todo i.",
                                    "Some os produtos sobre i=1 até n para obter G_{jk}.",
                                    "Note que G é simétrica: G_{jk} = G_{kj}, calcule apenas triângulo superior e transpose.",
                                    "Use fórmula explícita: G = Φ^T Φ, onde Φ é a matriz de Vandermonde.",
                                    "Registre cálculos em uma tabela para rastreabilidade."
                                  ],
                                  "verification": "Confira simetria (G_{jk} == G_{kj}) e diagonais G_{jj} > 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python (NumPy) ou MATLAB",
                                    "Tabela de φ_j(x_i) do passo 1"
                                  ],
                                  "tips": "Implemente em código para automação: G = np.dot(Phi.T, Phi); evite cálculos manuais para m>3.",
                                  "learningObjective": "Dominar o cálculo do produto interno discreto que define a matriz de Gram.",
                                  "commonMistakes": [
                                    "Erro aritmético em somas longas",
                                    "Índices invertidos j/k",
                                    "Normalizar incorretamente os φ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar e verificar a matriz de Gram G",
                                  "subSteps": [
                                    "Organize os elementos G_{jk} em uma matriz m x m, com linhas j e colunas k.",
                                    "Confirme propriedades: simétrica positiva definida (se bases linearmente independentes).",
                                    "Calcule determinante ou autovalores para checar condicionamento (cond(G) = σ_max/σ_min).",
                                    "Compare com matriz A das equações normais: A = G para regressão sem pesos.",
                                    "Visualize a matriz em formato tabular ou heatmap."
                                  ],
                                  "verification": "G deve ser simétrica e det(G) ≠ 0; cond(G) < 10^6 para bom condicionamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de álgebra linear (NumPy, MATLAB)",
                                    "Matriz Φ"
                                  ],
                                  "tips": "Use np.linalg.cond(G) para condicionamento; se alto, considere bases ortogonais.",
                                  "learningObjective": "Construir e validar a matriz de Gram como base para soluções das equações normais.",
                                  "commonMistakes": [
                                    "Montagem errada da matriz (linhas/colunas trocadas)",
                                    "Ignorar verificação de simetria",
                                    "Confundir G com ΦΦ^T"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar G à matriz A das equações normais e analisar condicionamento",
                                  "subSteps": [
                                    "Lembre equações normais: A β = b, onde A = Φ^T Φ = G, b = Φ^T y.",
                                    "Compare G com A explicitamente usando os dados y_i.",
                                    "Analise condicionamento: compute autovalores e identifique ill-conditioning se n≈m.",
                                    "Discuta implicações: bom condicionamento leva a soluções estáveis.",
                                    "Documente como G afeta a estabilidade do ajuste de curvas."
                                  ],
                                  "verification": "Confirme A == G e discuta impacto de cond(G) na solução β.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vetor y_i",
                                    "Software para autovalores (np.linalg.eig)"
                                  ],
                                  "tips": "Para engenharia civil, alto cond(G) indica multicolinearidade em bases polinomiais altas.",
                                  "learningObjective": "Integrar a matriz de Gram ao framework completo de ajuste de curvas via equações normais.",
                                  "commonMistakes": [
                                    "Confundir G com b",
                                    "Ignorar análise de condicionamento",
                                    "Não relacionar explicitamente com A"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere ajuste linear: x_i = [0,1,2,3], y_i = [1,2,4,5]. Funções: φ1(x)=1, φ2(x)=x. Matriz Φ = [[1,0],[1,1],[1,2],[1,3]]. G = Φ^T Φ = [[4, 6], [6, 14]]. Verifique: G11=∑1²=4, G12=∑x_i=0+1+2+3=6, etc. Cond(G)≈14. Relaciona com A em min||y - Φβ||².",
                              "finalVerifications": [
                                "Matriz G é simétrica e elementos diagonais positivos.",
                                "G = Φ^T Φ computado corretamente para todos elementos.",
                                "Relacionamento G = A das equações normais confirmado.",
                                "Condição da matriz analisada (cond(G) calculado).",
                                "Propriedades (positiva definida) verificadas via autovalores.",
                                "Cálculos manuais coincidem com código computacional."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de elementos G_{jk} (erro < 0.1%).",
                                "Correta montagem e verificação de simetria.",
                                "Análise adequada de condicionamento com interpretação.",
                                "Relacionamento explícito com equações normais.",
                                "Uso eficiente de ferramentas computacionais.",
                                "Documentação clara de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: produtos internos, autovalores e condicionamento de matrizes.",
                                "Estatística: regressão linear múltipla e multicolinearidade.",
                                "Programação Numérica: implementação em Python/NumPy ou MATLAB.",
                                "Análise Numérica: estabilidade de sistemas lineares superdeterminados.",
                                "Engenharia Computacional: modelagem em softwares como ANSYS ou MATLAB."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, a matriz de Gram é usada no ajuste de curvas para modelar deformações em vigas sob carga (ex: regressão polinomial de dados experimentais), avaliando condicionamento para prever falhas estruturais com precisão, evitando soluções instáveis em simulações de elementos finitos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.2",
                            "name": "Analisar o condicionamento da matriz",
                            "description": "Calcular o número de condicionamento cond(G) = ||G|| ||G^{-1}||, identificando problemas de ill-condicionamento em ajustes de curvas com funções base polinomiais de alto grau.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos de norma de matriz e número de condicionamento",
                                  "subSteps": [
                                    "Revise definições de normas de matrizes comuns (norma 2/espectral, Frobenius, máxima).",
                                    "Aprenda a fórmula cond(G) = ||G|| * ||G^{-1}|| para normas subordinadas.",
                                    "Estude o significado: cond(G) ≈ 1 indica bem condicionado; >10^6 indica ill-condicionado.",
                                    "Relacione com autovalores: cond_2(G) = λ_max / λ_min.",
                                    "Discuta impacto em sistemas lineares Ax=b: amplificação de erros."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula e critérios de ill-condicionamento com exemplo numérico simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang), Python com NumPy/SciPy",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use norma 2 para condicionamento espectral, mais relevante em ajustes de curvas.",
                                  "learningObjective": "Compreender teoricamente normas e condicionamento para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir norma de vetor com norma de matriz",
                                    "Ignorar que cond depende da norma escolhida"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e calcular a norma ||G|| da matriz de Gram",
                                  "subSteps": [
                                    "Construa G para ajuste polinomial: G_{ij} = Σ φ_i(x_k) φ_j(x_k), onde φ são bases polinomiais.",
                                    "Escolha pontos de dados reais (ex: medidas em engenharia civil).",
                                    "Implemente cálculo de G em software (numpy.dot(X.T, X) para design matrix X).",
                                    "Calcule ||G|| usando função built-in (np.linalg.norm(G, 2)).",
                                    "Verifique manualmente para matriz pequena 2x2."
                                  ],
                                  "verification": "Mostre código e output de ||G|| para uma G 3x3 exemplo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python/NumPy/SciPy/MATLAB",
                                    "Dados de exemplo: pontos (x,y) de curva de viga"
                                  ],
                                  "tips": "Normalizar dados (x em [-1,1]) para reduzir condicionamento inicial.",
                                  "learningObjective": "Calcular corretamente a norma da matriz de Gram em contexto de ajuste.",
                                  "commonMistakes": [
                                    "Usar pontos não escalados levando a G mal condicionado prematuramente",
                                    "Erro em índices de G (off-diagonal)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a inversa G^{-1} e sua norma ||G^{-1}||",
                                  "subSteps": [
                                    "Verifique se G é invertível (det(G) ≠ 0, rank completo).",
                                    "Compute G^{-1} usando np.linalg.inv(G) ou solve.",
                                    "Calcule ||G^{-1}|| com a mesma norma de ||G||.",
                                    "Analise singularidades ou warnings numéricos para alto grau.",
                                    "Compare com decomposição SVD para validação (UΣV^T, inv via Σ^{-1})."
                                  ],
                                  "verification": "Apresente G^{-1} e ||G^{-1}||, confirmando ||G|| * ||G^{-1}|| ≈ cond via np.linalg.cond.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/NumPy (linalg.inv, linalg.norm)",
                                    "MATLAB equivalente"
                                  ],
                                  "tips": "Para matrizes grandes, prefira cond() direto em vez de inv explícita.",
                                  "learningObjective": "Dominar computação numérica segura de inversa e norma.",
                                  "commonMistakes": [
                                    "Tentativa de inv em matriz singular causando NaN",
                                    "Norma inconsistente entre G e inv"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar cond(G) e analisar ill-condicionamento",
                                  "subSteps": [
                                    "Multiplique ||G|| * ||G^{-1}|| para obter cond(G).",
                                    "Compare com np.linalg.cond(G, 2) para validação.",
                                    "Aumente grau polinomial (ex: de 2 para 5) e observe cond crescer exponencialmente.",
                                    "Interprete: cond > 10^{10} indica instabilidade em coeficientes de ajuste.",
                                    "Discuta Runge phenomenon em polinômios altos."
                                  ],
                                  "verification": "Gere gráfico de cond vs grau polinomial e explique tendência.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python/MATLAB com plotting (matplotlib)",
                                    "Dados extensos para simulação"
                                  ],
                                  "tips": "Use ortogonalização (ex: Legendre) para mitigar ill-condicionamento.",
                                  "learningObjective": "Avaliar e interpretar condicionamento em ajustes polinomiais.",
                                  "commonMistakes": [
                                    "Interpretar cond baixo como sempre bom, ignorando precisão máquina",
                                    "Não escalar dados"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar análise em ajuste de curvas reais e propor soluções",
                                  "subSteps": [
                                    "Aplique a dados de engenharia civil (ex: subsidência de solo vs tempo).",
                                    "Ajuste com graus variados, compute cond(G) e residual do ajuste.",
                                    "Identifique grau ótimo (baixo cond e bom fit).",
                                    "Proponha alternativas: splines, bases ortogonais.",
                                    "Documente relatório com gráficos de cond e curvas ajustadas."
                                  ],
                                  "verification": "Relatório com análise completa, incluindo cond para 3 cenários.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Dados reais CSV",
                                    "Python full stack (pandas, numpy, matplotlib)"
                                  ],
                                  "tips": "Sempre reporte cond em logs de modelagem para alertas.",
                                  "learningObjective": "Integrar análise de condicionamento em workflow de modelagem.",
                                  "commonMistakes": [
                                    "Overfitting sem checar cond",
                                    "Ignorar correlação de dados"
                                  ]
                                }
                              ],
                              "practicalExample": "Dados de carga vs deformação em viga de concreto: pontos [(0,0), (1,0.1), (2,0.4), (3,0.9), (4,1.6)]. Para grau 1: G = [[5, 10], [10, 30]], cond≈3.2 (bom). Grau 3: G 4x4 mal condicionado cond>10^8, coeficientes instáveis, oscilações no ajuste.",
                              "finalVerifications": [
                                "cond(G) calculado corretamente para pelo menos 3 matrizes de Gram variadas.",
                                "Identificação precisa de ill-condicionamento (threshold 10^6+).",
                                "Gráfico de cond vs grau polinomial gerado e analisado.",
                                "Explicação do impacto em soluções de equações normais.",
                                "Sugestão de mitigação (ex: redução de grau ou bases ortogonais).",
                                "Validação cruzada com np.linalg.cond()"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos de normas e inversa (erro <1e-10).",
                                "Correta interpretação qualitativa de cond (causas e efeitos).",
                                "Eficiência computacional (uso de funções otimizadas vs loops).",
                                "Qualidade de visualizações (gráficos claros de cond e ajustes).",
                                "Criatividade em exemplos reais de engenharia civil.",
                                "Documentação completa com código reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores e SVD para normas.",
                                "Análise Numérica: estabilidade e erro de arredondamento.",
                                "Programação: implementação eficiente em Python/MATLAB.",
                                "Estatística: regressão linear e diagnósticos de multicolinearidade.",
                                "Engenharia Computacional: modelagem em FEA/Simulações."
                              ],
                              "realWorldApplication": "Em engenharia civil, análise de condicionamento da matriz de Gram previne instabilidades em ajustes de curvas para previsão de deformações em estruturas, calibração de sensores IoT em pontes ou modelagem de solos, evitando erros catastróficos em simulações de falha."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.3",
                            "name": "Interpretar autovalores da matriz de Gram",
                            "description": "Examinar autovalores e autofunções para avaliar singularidade e estabilidade, relacionando com otimização em problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Matriz de Gram e Autovalores",
                                  "subSteps": [
                                    "Defina matriz de Gram como G = A^T A, onde A é a matriz de dados.",
                                    "Explique autovalores como soluções de det(G - λI) = 0.",
                                    "Discuta autofunções como vetores v onde G v = λ v.",
                                    "Relacione autovalores com normas e condicionamento.",
                                    "Identifique que autovalores positivos indicam semi-definida positiva."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e forneça um exemplo 2x2 simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang), calculadora ou Python/MATLAB"
                                  ],
                                  "tips": "Use decomposição espectral para visualizar; foque em propriedades simétricas.",
                                  "learningObjective": "Compreender a origem e propriedades básicas de autovalores da matriz de Gram.",
                                  "commonMistakes": [
                                    "Confundir com autovalores de A diretamente",
                                    "Ignorar que G é sempre semi-definida positiva",
                                    "Esquecer normalização dos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Autovalores e Autofunções de uma Matriz de Gram",
                                  "subSteps": [
                                    "Construa uma matriz A de exemplo com dados de engenharia (ex: medições de deformação).",
                                    "Compute G = A^T A manualmente ou via software.",
                                    "Resolva a equação característica para encontrar λ_i.",
                                    "Calcule autofunções normalizadas para cada λ_i.",
                                    "Verifique ortogonalidade das autofunções."
                                  ],
                                  "verification": "Execute cálculo em software e confira que G v = λ v para cada par.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software NumPy/Python ou MATLAB, papel e lápis para 2x2"
                                  ],
                                  "tips": "Para matrizes grandes, use funções prontas como eig() mas entenda o processo.",
                                  "learningObjective": "Dominar o cálculo prático de autovalores em contexto de Gram.",
                                  "commonMistakes": [
                                    "Erro numérico em cálculos manuais",
                                    "Não normalizar autofunções",
                                    "Confundir autovalores com singular values"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Autovalores para Avaliar Singularidade e Condicionamento",
                                  "subSteps": [
                                    "Verifique se algum λ_i = 0 (indica singularidade e dependência linear nos dados).",
                                    "Calcule o número de condicionamento cond(G) = λ_max / λ_min.",
                                    "Avalie estabilidade: cond > 10^6 sugere ill-conditioned.",
                                    "Analise distribuição de λ_i para identificar direções principais de variância.",
                                    "Relacione com equações normais: pequenos λ_i causam instabilidade em inversão."
                                  ],
                                  "verification": "Classifique uma matriz de exemplo como bem ou mal condicionada com justificativa.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplos de matrizes de dados civis, planilha para ratios"
                                  ],
                                  "tips": "Logaritme os λ_i para visualizar gaps; priorize λ_min.",
                                  "learningObjective": "Interpretar quantitativamente autovalores para diagnósticos de problemas.",
                                  "commonMistakes": [
                                    "Ignorar autovalores próximos de zero como 'quase singulares'",
                                    "Usar norma errada para condicionamento",
                                    "Não considerar escala dos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Interpretação com Otimização em Engenharia Civil",
                                  "subSteps": [
                                    "Aplique em ajuste de curvas para dados de carga em vigas.",
                                    "Discuta como mau condicionamento afeta soluções de mínimos quadrados.",
                                    "Explore regularização (ex: ridge) para mitigar pequenos λ_i.",
                                    "Simule otimização com restrições baseadas em estabilidade.",
                                    "Avalie impacto em projetos reais como previsão de falhas estruturais."
                                  ],
                                  "verification": "Escreva relatório curto ligando interpretação a um problema civil específico.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Dados reais de engenharia civil (ex: datasets públicos), software de plotagem"
                                  ],
                                  "tips": "Use SVD para comparação; pense em trade-offs de precisão vs estabilidade.",
                                  "learningObjective": "Conectar teoria matemática a aplicações práticas em otimização civil.",
                                  "commonMistakes": [
                                    "Subestimar efeitos em engenharia prática",
                                    "Não considerar ruído nos dados",
                                    "Focar só em teoria sem exemplo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em ajuste de curvas para medições de deformação em uma viga de concreto sob carga variável: construa A com colunas de posições e cargas, compute G, encontre λ_min ≈ 10^-8 indicando ill-conditioning devido a multicolinearidade nos dados, levando a soluções instáveis sem regularização.",
                              "finalVerifications": [
                                "Calcule corretamente autovalores de uma G 3x3 fornecida.",
                                "Identifique singularidade se λ=0 e explique implicações.",
                                "Compute cond(G) e classifique condicionamento.",
                                "Relacione λ_i a estabilidade em otimização.",
                                "Aplique interpretação em um dataset civil simples.",
                                "Explique autofunções como direções principais."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de autovalores (erro < 1e-6).",
                                "Correta identificação de singularidade/condicionamento.",
                                "Interpretação qualitativa e quantitativa coerente.",
                                "Conexão clara com problemas de engenharia civil.",
                                "Uso apropriado de software e verificações.",
                                "Relatório lógico com exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição espectral e SVD.",
                                "Estatística: Análise de componentes principais (PCA).",
                                "Otimização: Mínimos quadrados e regularização.",
                                "Engenharia Computacional: Análise numérica de estabilidade.",
                                "Física: Modos normais em estruturas vibrantes."
                              ],
                              "realWorldApplication": "Na análise de estruturas civis, interpretar autovalores da matriz de Gram de dados sensoriais (ex: strain gauges em pontes) detecta multicolinearidade, previne erros em modelos preditivos de fadiga e otimiza designs para estabilidade computacional e física."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.3.2"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.4",
                            "name": "Aplicar regularização para ill-condicionamento",
                            "description": "Implementar técnicas como ridge regression adicionando λI à matriz de Gram para melhorar o condicionamento em cenários reais de dados ruidosos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Diagnosticar ill-condicionamento na matriz de Gram",
                                  "subSteps": [
                                    "Construir a matriz de Gram G = X^T X a partir dos dados de entrada X",
                                    "Calcular autovalores e autovetores de G usando decomposição espectral",
                                    "Computar o número de condicionamento cond(G) = λ_max / λ_min",
                                    "Analisar a distribuição de autovalores para identificar valores próximos de zero",
                                    "Visualizar espectro de autovalores em escala logarítmica"
                                  ],
                                  "verification": "Número de condicionamento > 10^6 ou autovalores mínimos < 10^-10",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (NumPy, SciPy), MATLAB ou Octave; conjunto de dados de exemplo com multicolinearidade",
                                  "tips": "Use np.linalg.cond() no NumPy para cálculo rápido do condicionamento",
                                  "learningObjective": "Identificar quantitativamente problemas de condicionamento na matriz de Gram",
                                  "commonMistakes": "Ignorar autovalores pequenos sem checar o ratio cond; confundir com det(G)=0"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender e configurar regularização Ridge",
                                  "subSteps": [
                                    "Estudar a formulação Ridge: minimizar ||y - Xβ||^2 + λ||β||^2",
                                    "Entender o efeito matemático: G_ridge = G + λI",
                                    "Escolher método para selecionar λ (cross-validation, L-curve ou heurística como fração do traço de G)",
                                    "Implementar função para testar múltiplos λ e plotar curvas de trade-off bias-variance",
                                    "Validar teoricamente que λI desloca autovalores mínimos para λ"
                                  ],
                                  "verification": "Gráfico de L-curve mostra trade-off ótimo; autovalores deslocados corretamente",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Documentação Ridge Regression; código Python com scikit-learn para CV",
                                  "tips": "Comece com λ = 0.01 * trace(G)/n para dados ruidosos",
                                  "learningObjective": "Selecionar λ ótimo para equilibrar ajuste e estabilidade",
                                  "commonMistakes": "Escolher λ fixo sem validação; superestimar λ levando a subajuste"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar regularização na matriz de Gram",
                                  "subSteps": [
                                    "Modificar G_ridge = G + λ * np.eye(n_features)",
                                    "Resolver sistema normal regularizado: β = G_ridge^{-1} (X^T y)",
                                    "Usar decomposição SVD ou Cholesky para inversão estável",
                                    "Comparar soluções original vs regularizada em termos de resíduos e normas",
                                    "Testar sensibilidade adicionando ruído gaussiano aos dados"
                                  ],
                                  "verification": "Solução Ridge converge e cond(G_ridge) < 10^3",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python/MATLAB; dados sintéticos ruidosos gerados via np.random",
                                  "tips": "Prefira SVD para evitar inversão direta em matrizes grandes",
                                  "learningObjective": "Implementar computacionalmente a correção Ridge",
                                  "commonMistakes": "Esquecer de escalar λ corretamente; usar I de dimensão errada"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e aplicar em cenário real de Engenharia Civil",
                                  "subSteps": [
                                    "Carregar dados reais de ajuste de curvas (ex: deformações vs tempo em estruturas)",
                                    "Aplicar pipeline completo: diagnóstico, regularização, solução",
                                    "Avaliar métricas: R^2, RMSE, estabilidade a perturbações",
                                    "Plotar curvas ajustadas original vs Ridge para visualização",
                                    "Documentar relatório com comparações quantitativas"
                                  ],
                                  "verification": "Melhoria em RMSE > 20% e solução estável a ±5% ruído",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Dados de assentamento de fundações ou medições sísmicas; Jupyter Notebook",
                                  "tips": "Salve seeds para reprodutibilidade em testes de ruído",
                                  "learningObjective": "Aplicar regularização em contexto prático e interpretar resultados",
                                  "commonMistakes": "Não normalizar dados antes; ignorar outliers nos dados reais"
                                }
                              ],
                              "practicalExample": "Em um estudo de assentamento diferencial de fundações em solo argiloso, dados de nivelamento (X: tempo e cargas, y: deformações) apresentam multicolinearidade devido a medições ruidosas. Aplicar Ridge com λ=0.05 reduz cond de 10^8 para 10^2, estabilizando predições de deformações futuras.",
                              "finalVerifications": [
                                "Número de condicionamento da G_ridge < 10^4",
                                "Solução estável a adição de 5% ruído gaussiano nos dados",
                                "Redução de pelo menos 15% no RMSE comparado ao ajuste não regularizado",
                                "Autovalores mínimos de G_ridge ≥ λ escolhido",
                                "Coeficientes β com normas razoáveis (não explosivos)",
                                "Visualização de curvas ajustadas sem oscilações anômalas"
                              ],
                              "assessmentCriteria": [
                                "Correta identificação de ill-condicionamento com métricas quantitativas",
                                "Seleção justificada de λ via método validado (CV ou L-curve)",
                                "Implementação precisa de G + λI sem erros dimensionais",
                                "Análise comparativa robusta (métricas e plots)",
                                "Interpretação correta dos impactos na engenharia (estabilidade preditiva)",
                                "Código limpo, comentado e reprodutível"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear e análise de variância",
                                "Programação Numérica: Álgebra linear computacional (SVD, eigen)",
                                "Análise de Dados: Tratamento de multicolinearidade e feature engineering",
                                "Engenharia de Estruturas: Modelagem de respostas dinâmicas ruidosas"
                              ],
                              "realWorldApplication": "Na previsão de deformações em barragens ou pontes sob monitoramento contínuo, onde dados instrumentais são ruidosos devido a vibrações ambientais; regularização garante modelos estáveis para alertas de manutenção preditiva e otimização de projetos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Condicionamento no Ajuste de Curvas",
                    "description": "Análise da estabilidade numérica do ajuste, considerando o condicionamento da matriz de dados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Condicionamento Numérico de Matrizes",
                        "description": "Conceito fundamental sobre o condicionamento de matrizes no contexto do ajuste de curvas, medindo a sensibilidade da solução a perturbações nos dados de entrada, especialmente na matriz de dados do problema de mínimos quadrados.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Calcular o número de condição de uma matriz",
                            "description": "Implementar o cálculo do número de condição cond(A) = ||A|| * ||A^{-1}|| usando normas como a norma 2 ou infinito, aplicando a funções MATLAB ou Python para matrizes oriundas de dados de ajuste de curvas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais do Número de Condição",
                                  "subSteps": [
                                    "Estude a definição: cond(A) = ||A|| * ||A^{-1}||, onde ||.|| é uma norma de matriz compatível.",
                                    "Revise normas comuns: norma 2 (espectral, maior valor singular) e norma infinito (máxima soma de linhas absolutas).",
                                    "Entenda a inversa A^{-1} e sua relação com a estabilidade numérica.",
                                    "Aprenda a interpretação: cond(A) ≈ 1 indica matriz bem condicionada; valores altos (>10^6) indicam il-condicionamento.",
                                    "Discuta relevância no ajuste de curvas: matrizes mal condicionadas amplificam erros em soluções de mínimos quadrados."
                                  ],
                                  "verification": "Explique em suas palavras a fórmula cond(A) e dê um exemplo verbal de interpretação para uma matriz 2x2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notebook com internet",
                                    "Documentação NumPy/MATLAB sobre normas",
                                    "Artigo introdutório sobre condicionamento numérico"
                                  ],
                                  "tips": "Use analogias: cond(A) mede sensibilidade da solução Ax=b a perturbações em A ou b.",
                                  "learningObjective": "Dominar a teoria por trás do número de condição e sua importância em problemas de engenharia.",
                                  "commonMistakes": [
                                    "Confundir norma de matriz com norma de vetor",
                                    "Ignorar que normas devem ser subordinadas (compatíveis)",
                                    "Achar que cond(A)=0 é possível (só se A singular)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Ambiente Computacional e Criar Matriz Exemplo",
                                  "subSteps": [
                                    "Instale/inicie Python com NumPy (ou MATLAB).",
                                    "Importe bibliotecas: import numpy as np.",
                                    "Gere uma matriz exemplo de ajuste de curvas: A = np.array([[1, 1], [1, 2], [1, 3]]).T para torná-la quadrada aproximada (ou use Vandermonde).",
                                    "Verifique propriedades básicas: shape, det(A), rank(A).",
                                    "Salve o código em um script Jupyter Notebook para reutilização."
                                  ],
                                  "verification": "Execute o código e confirme que A é criada corretamente com det(A) ≠ 0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "NumPy instalado",
                                    "Exemplo de dados de ajuste: x = [1,2,3], y simulados"
                                  ],
                                  "tips": "Para matrizes de ajuste real, use np.vander(x, increasing=True) para base polinomial.",
                                  "learningObjective": "Preparar ambiente pronto para cálculos numéricos de matrizes de engenharia civil.",
                                  "commonMistakes": [
                                    "Esquecer de transpor matriz retangular",
                                    "Usar dados não normalizados levando a il-condicionamento precoce",
                                    "Não checar singularidade antes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Normas de A e A^{-1}",
                                  "subSteps": [
                                    "Calcule ||A||_2: np.linalg.norm(A, 2) ou ord=2.",
                                    "Calcule ||A||_∞: np.linalg.norm(A, np.inf).",
                                    "Compute A_inv = np.linalg.inv(A).",
                                    "Calcule ||A^{-1}||_2 e ||A^{-1}||_∞ de forma similar.",
                                    "Compare com função built-in: np.linalg.cond(A, 2) para validação."
                                  ],
                                  "verification": "Imprima valores de ||A||_2, ||A^{-1}||_2 e confirme que cond manual ≈ cond built-in (erro <1%).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do Step 2",
                                    "Documentação np.linalg.norm e inv"
                                  ],
                                  "tips": "Para matrizes grandes, prefira norma 2; normalize dados de entrada para reduzir cond.",
                                  "learningObjective": "Implementar computacionalmente as componentes da fórmula cond(A).",
                                  "commonMistakes": [
                                    "Usar norma errada (ex: frobenius não é subordinada para cond)",
                                    "Inverter matriz singular causando erro NumPy",
                                    "Arredondamento em normas manuais sem usar funções vetoriais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar o Número de Condição e Interpretar Resultados",
                                  "subSteps": [
                                    "Calcule cond_2(A) = np.linalg.norm(A, 2) * np.linalg.norm(np.linalg.inv(A), 2).",
                                    "Calcule cond_inf(A) similarmente.",
                                    "Interprete: se cond > 10^10, avise 'il-condicionado' e sugira regularização.",
                                    "Teste com matriz perturbada: A_pert = A + 0.01*np.random.rand(*A.shape); compare cond.",
                                    "Registre em log: valor exato, implicações para precisão em ajuste de curvas."
                                  ],
                                  "verification": "Gere relatório com cond valores e interpretação escrita para A e A_pert.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "Gráfico opcional: plt.semilogy(cond values)"
                                  ],
                                  "tips": "Use np.linalg.cond() para benchmark rápido; foque em consistência entre normas.",
                                  "learningObjective": "Aplicar fórmula completa e analisar sensibilidade numérica.",
                                  "commonMistakes": [
                                    "Multiplicar normas incompatíveis (ex: ||A||_2 * ||A^{-1}||_inf)",
                                    "Não tratar exceções de inversa para A singular",
                                    "Ignorar escala: normalize A primeiro"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar a Matrizes Reais de Ajuste de Curvas em Engenharia Civil",
                                  "subSteps": [
                                    "Gere matriz Vandermonde para ajuste polinomial: x = np.linspace(0,10,5); A = np.vander(x, 2).",
                                    "Simule dados ruidosos de deformação em vigas: y = a + b*x + noise.",
                                    "Calcule cond(A) pré e pós-normalização (A_norm = A / np.linalg.norm(A)).",
                                    "Avalie impacto: resolva least squares e compare erros com cond alto.",
                                    "Documente função reutilizável: def compute_cond(A): return np.linalg.norm(A,2)*np.linalg.norm(np.linalg.inv(A),2)."
                                  ],
                                  "verification": "Execute em dataset simulado e confirme redução de cond com normalização (>50% melhor).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Dados exemplo: posições de sensores em viga",
                                    "SciPy para least squares opcional"
                                  ],
                                  "tips": "Em prática civil, cond alto em Vandermonde indica pontos mal espaçados; reespaçe sensores.",
                                  "learningObjective": "Integrar cálculo de cond em workflow de ajuste de curvas reais.",
                                  "commonMistakes": [
                                    "Usar matriz não quadrada diretamente (use pseudoinversa para cond generalizado)",
                                    "Não considerar ruído propagado por cond",
                                    "Sobrepujar precisão double sem ir para quad"
                                  ]
                                }
                              ],
                              "practicalExample": "Para dados de deformação em uma viga sob carga (x=[0,2,4,6,8], y=[0,1.2,2.5,3.8,5.1] + noise), forme A = np.vander(x, 2) (5x2, use cond de submatriz 2x2 ou normal eqs). Calcule cond_2(A) ≈ 1.2e4, indicando moderado il-condicionamento; normalize x para reduzir a ~10.",
                              "finalVerifications": [
                                "Implementar função compute_cond(A, p=2) que retorna cond e flag de il-condicionamento (>1e12).",
                                "Aplicar a 3 matrizes diferentes e interpretar todos os cond valores corretamente.",
                                "Comparar manual vs built-in com erro relativo <1e-10.",
                                "Gerar relatório com gráficos de cond vs normalização.",
                                "Explicar verbalmente como cond afeta precisão em ajuste de curvas civis.",
                                "Testar com matriz singular e tratar exceções adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: cond calculado com erro <1e-12 vs built-in.",
                                "Correção conceitual: explicação clara de fórmula e interpretação.",
                                "Robustez: código lida com matrizes singulares ou retangulares.",
                                "Eficiência: tempo de execução <1s para matriz 100x100.",
                                "Aplicação contextual: ligação explícita com ajuste de curvas em engenharia.",
                                "Documentação: código comentado e relatório legível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: análise de erros e estabilidade.",
                                "Programação Científica: uso de NumPy/SciPy para álgebra linear.",
                                "Estatística: propagação de erros em regressão linear.",
                                "Engenharia Computacional: modelagem de estruturas civis.",
                                "Física Aplicada: análise de deformações e estabilidade de vigas."
                              ],
                              "realWorldApplication": "Em engenharia civil, calcular cond(A) para matrizes de ajuste de curvas oriundas de dados de sensores em estruturas (ex: monitoramento de pontes) previne erros amplificados em previsões de falhas, garantindo segurança e otimizando designs contra il-condicionamento devido a colinearidade de dados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Interpretar o impacto do condicionamento na estabilidade",
                            "description": "Analisar valores de cond(A) para classificar matrizes como bem condicionadas (cond < 10^3) ou mal condicionadas (>10^6), relacionando com erros amplificados em soluções de ajustes de curvas lineares e não-lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de número de condição cond(A)",
                                  "subSteps": [
                                    "Defina o número de condição como cond(A) = ||A|| * ||A^{-1}||, geralmente usando normas como a norma 2 (valores singulares máximos e mínimos).",
                                    "Explique que cond(A) ≈ 1 indica matriz bem condicionada, enquanto valores altos (>10^6) indicam ill-condicionamento.",
                                    "Discuta como o condicionamento afeta a sensibilidade da solução Ax = b a perturbações em b ou A.",
                                    "Relacione com estabilidade numérica: erros relativos na solução são amplificados por cond(A).",
                                    "Revise normas de matrizes comuns (1, 2, ∞) e sua relação com cond(A)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que cond(A) representa e dê um exemplo simples de amplificação de erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Álgebra Numérica (ex: Burden & Faires)",
                                    "Notebook com Python/NumPy ou MATLAB"
                                  ],
                                  "tips": "Use analogia: cond(A) alto é como uma alavanca longa – pequenos erros na entrada causam grandes desvios na saída.",
                                  "learningObjective": "Entender a definição matemática e intuitiva do número de condição e sua implicação na estabilidade numérica.",
                                  "commonMistakes": [
                                    "Confundir cond(A) com determinante (det(A) pequeno não implica ill-condicionamento)",
                                    "Ignorar que cond(A) é sempre ≥1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular cond(A) para matrizes de exemplo",
                                  "subSteps": [
                                    "Gere matrizes de teste: uma identidade (bem condicionada), uma de Hilbert (mal condicionada).",
                                    "Calcule autovalores ou valores singulares usando software para obter cond(A) = σ_max / σ_min.",
                                    "Compare cond(A) para matrizes 3x3 e 5x5, observando o crescimento com o tamanho.",
                                    "Implemente função em Python/MATLAB: np.linalg.cond(A) ou cond(A,'2').",
                                    "Registre valores e classifique preliminarmente (bem: <10^3, mal: >10^6)."
                                  ],
                                  "verification": "Produza output de código mostrando cond(A) para pelo menos 3 matrizes diferentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "MATLAB ou Octave",
                                    "Matrizes de exemplo pré-definidas"
                                  ],
                                  "tips": "Sempre normalize matrizes para evitar escalas afetarem a norma; teste com norma 2 para precisão.",
                                  "learningObjective": "Dominar o cálculo prático de cond(A) usando ferramentas computacionais.",
                                  "commonMistakes": [
                                    "Usar norma errada (ex: Frobenius em vez de 2 para SVD)",
                                    "Não inverter corretamente para normas sem SVD"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar matrizes baseado em thresholds de cond(A)",
                                  "subSteps": [
                                    "Estabeleça critérios: bem condicionada (<10^3), moderada (10^3-10^6), mal condicionada (>10^6).",
                                    "Analise 4 matrizes de ajuste de curvas (Vandermonde para polinômios lineares/não-lineares).",
                                    "Crie tabela: matriz, cond(A), classificação, razão (grau polinomial alto causa ill-condicionamento).",
                                    "Discuta trade-offs: mais parâmetros em modelo aumentam cond(A).",
                                    "Classifique e justifique com exemplos numéricos."
                                  ],
                                  "verification": "Crie e preencha tabela de classificação para 4 matrizes fornecidas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel ou Jupyter Notebook",
                                    "Matrizes de Vandermonde geradas"
                                  ],
                                  "tips": "Para curvas não-lineares, linearize e verifique matriz Jacobiana.",
                                  "learningObjective": "Aplicar thresholds padrão para classificar condicionamento em contextos de ajuste de curvas.",
                                  "commonMistakes": [
                                    "Thresholds arbitrários sem contexto (use 10^3/10^6 para double precision)",
                                    "Ignorar escala dos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impacto na estabilidade de ajustes de curvas",
                                  "subSteps": [
                                    "Simule ajuste de curvas lineares: dados com ruído pequeno, resolva com matrizes bem/mal condicionadas.",
                                    "Meça amplificação: erro na solução ≈ cond(A) * erro relativo nos dados.",
                                    "Para não-lineares (ex: exponencial), use Gauss-Newton e analise cond(Jacobiana).",
                                    "Compare soluções: plot curvas ajustadas e resíduos para casos condicionados diferentemente.",
                                    "Quantifique: relative error = ||x_true - x_computed|| / ||x_true|| vs cond(A)."
                                  ],
                                  "verification": "Gere plots comparativos mostrando amplificação de erros em caso mal condicionado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com SciPy.optimize.curve_fit",
                                    "Dados sintéticos de curvas (linear, polinomial, exp)"
                                  ],
                                  "tips": "Adicione ruído gaussiano pequeno (1e-6) para simular perturbações reais.",
                                  "learningObjective": "Relacionar cond(A) com amplificação de erros em soluções de ajustes lineares e não-lineares.",
                                  "commonMistakes": [
                                    "Não perturbar os dados corretamente",
                                    "Confundir erro de modelo com erro numérico"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar interpretações e estratégias de mitigação",
                                  "subSteps": [
                                    "Resuma: alto cond(A) leva a instabilidade, especialmente em altos graus polinomiais.",
                                    "Discuta mitigação: regularização (ridge), ortogonalização, reescalonamento dados.",
                                    "Aplique em exemplo civil: ajuste de curva de deformação em vigas.",
                                    "Avalie trade-offs: precisão vs estabilidade.",
                                    "Documente relatório com conclusões."
                                  ],
                                  "verification": "Escreva parágrafo sintetizando impacto e uma estratégia de mitigação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Relatório template",
                                    "Exemplos de engenharia civil"
                                  ],
                                  "tips": "Priorize reescalonamento de variáveis para reduzir cond(A) sem perder info.",
                                  "learningObjective": "Interpretar globalmente o impacto e propor soluções práticas.",
                                  "commonMistakes": [
                                    "Sugestões inviáveis (ex: usar precisão arbitrária sem hardware)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em ajuste polinomial de 5º grau para dados de subsidência de solo (x de 0-10m, y deformação), a matriz Vandermonde tem cond(A) ≈ 10^8 (>10^6, mal condicionada). Adicionando ruído 1e-6 em y, o erro nos coeficientes explode para 10^2, distorcendo previsões de colapso estrutural.",
                              "finalVerifications": [
                                "Calcula corretamente cond(A) para matriz 4x4 de Vandermonde.",
                                "Classifica matrizes com cond=10^2 (bem), 10^5 (moderada), 10^7 (mal).",
                                "Simula e demonstra amplificação de erro por fator cond(A).",
                                "Explica impacto em ajuste não-linear via Jacobiana.",
                                "Propõe pelo menos 2 mitigação para ill-condicionamento.",
                                "Relaciona com estabilidade em contexto de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de cond(A) (±5% erro relativo).",
                                "Correta classificação usando thresholds padrão.",
                                "Demonstração clara de amplificação de erros via simulação.",
                                "Análise qualitativa e quantitativa integrada.",
                                "Uso apropriado de software e visualizações.",
                                "Conexão explícita com ajustes lineares/não-lineares."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição SVD e normas de matrizes.",
                                "Estatística: Análise de resíduos e validação de modelos de regressão.",
                                "Programação Numérica: Implementação de solvers estáveis (QR em vez de Gauss direto).",
                                "Engenharia Computacional: Otimização em problemas de minimos quadrados.",
                                "Física Aplicada: Modelagem de sistemas lineares em estruturas civis."
                              ],
                              "realWorldApplication": "Na engenharia civil, ao ajustar curvas para prever deformações em fundações sob carga (ex: dados de ensaios de solo), matrizes mal condicionadas amplificam erros de medição, levando a projetos superdimensionados ou falhas; interpretar cond(A) garante modelos estáveis para simulações FEM confiáveis."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Aplicar reescalonamento para melhorar condicionamento",
                            "description": "Realizar normalização de colunas ou linhas da matriz de dados (usando médias e desvios padrão) para reduzir o número de condição em problemas de ajuste de curvas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar o condicionamento inicial da matriz",
                                  "subSteps": [
                                    "Carregue a matriz de dados do problema de ajuste de curvas (ex: matriz de design X com colunas de variáveis independentes).",
                                    "Calcule o número de condição usando a norma 2: cond(X) = ||X||₂ * ||X⁻¹||₂ ou função np.linalg.cond(X) em Python.",
                                    "Identifique se cond(X) > 10⁶, indicando mau condicionamento.",
                                    "Registre o valor inicial para comparação futura.",
                                    "Visualize a matriz com histograma das colunas para observar escalas desiguais."
                                  ],
                                  "verification": "Confirme que o número de condição foi calculado e registrado corretamente, comparando com valor teórico para matrizes teste.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy e Matplotlib; matriz de dados exemplo (CSV ou array).",
                                  "tips": "Use np.linalg.cond(matriz, p=2) para precisão; evite matrizes singulares.",
                                  "learningObjective": "Compreender e quantificar o impacto do mau condicionamento numérico em matrizes.",
                                  "commonMistakes": "Esquecer de usar a inversa pseudoinversa para matrizes não quadradas; ignorar normas adequadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular estatísticas de normalização por coluna",
                                  "subSteps": [
                                    "Para cada coluna j da matriz X, calcule a média μⱼ = np.mean(X[:, j]).",
                                    "Calcule o desvio padrão σⱼ = np.std(X[:, j], ddof=0).",
                                    "Verifique se σⱼ > 0 para evitar divisão por zero; caso contrário, ajuste.",
                                    "Armazene μ e σ em vetores para uso posterior.",
                                    "Compare escalas entre colunas para justificar a necessidade de reescalonamento."
                                  ],
                                  "verification": "Valores de μ e σ coincidem com cálculos manuais em subconjunto de dados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com NumPy; matriz X carregada.",
                                  "tips": "Use ddof=0 para desvio padrão populacional em contextos de ajuste.",
                                  "learningObjective": "Dominar o cálculo de estatísticas descritivas para normalização.",
                                  "commonMistakes": "Usar desvio padrão amostral (ddof=1) em vez de populacional; ignorar colunas constantes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar reescalonamento (normalização z-score) à matriz",
                                  "subSteps": [
                                    "Crie X_norm[:, j] = (X[:, j] - μⱼ) / σⱼ para cada coluna j.",
                                    "Implemente em loop ou vetorizado: X_norm = (X - μ) / σ com broadcasting.",
                                    "Salve a matriz original e normalizada para backup.",
                                    "Confirme que as colunas de X_norm têm média ~0 e desvio ~1.",
                                    "Ajuste manualmente se necessário para colunas com σ=0 (ex: centralizar apenas)."
                                  ],
                                  "verification": "np.mean(X_norm, axis=0) ≈ 0 e np.std(X_norm, axis=0) ≈ 1 para todas colunas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy; vetores μ e σ do step anterior.",
                                  "tips": "Use np.newaxis para broadcasting eficiente em arrays multidimensionais.",
                                  "learningObjective": "Executar normalização padronizada de forma precisa e eficiente.",
                                  "commonMistakes": "Aplicar normalização por linha em vez de coluna; esquecer subtração da média."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar melhoria e aplicar no ajuste de curvas",
                                  "subSteps": [
                                    "Calcule cond(X_norm) e compare com cond(X_original).",
                                    "Execute ajuste de curvas (mínimos quadrados) em X e X_norm: β = (X^T X)^(-1) X^T y.",
                                    "Compare resíduos e estabilidade dos coeficientes β.",
                                    "Desnormalice coeficientes se necessário: β_original = β_norm * σ / algo (ajustar fórmula).",
                                    "Documente a redução no condicionamento e impacto na precisão."
                                  ],
                                  "verification": "Redução de pelo menos 1-2 ordens de magnitude em cond; resíduos semelhantes ou melhores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com NumPy e SciPy (least_squares); vetor y de resposta.",
                                  "tips": "Use np.linalg.lstsq para soluções estáveis; plote resíduos para visualização.",
                                  "learningObjective": "Avaliar eficácia do reescalonamento em problemas reais de ajuste.",
                                  "commonMistakes": "Não desnormalizar predições finais; ignorar multicolinearidade residual."
                                }
                              ],
                              "practicalExample": "Em um ensaio de compressão de pilares de concreto, matriz X tem colunas: [1 (intercepto), deformação (0.001-0.01), idade (7-28 dias)]. cond(X)=10^8. Após reescalonamento, cond(X_norm)=10^5, permitindo ajuste estável da curva tensão-deformação σ = β0 + β1 ε + β2 ε².",
                              "finalVerifications": [
                                "Número de condição reduzido em pelo menos 10x.",
                                "Médias das colunas normalizadas próximas de 0 (±1e-10).",
                                "Desvios padrão das colunas normalizadas próximos de 1 (±1e-10).",
                                "Coeficientes de ajuste com erros relativos <1%.",
                                "Resíduos do ajuste normais sem outliers numéricos.",
                                "Código reproduzível gera mesmos resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de μ e σ (erro <1e-6).",
                                "Implementação correta do reescalonamento vetorizado.",
                                "Comparação quantitativa de cond antes/depois.",
                                "Interpretação correta da melhoria no contexto de engenharia.",
                                "Uso adequado de funções numéricas estáveis.",
                                "Documentação clara dos passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Normalização z-score e análise descritiva.",
                                "Programação Numérica: Uso de NumPy/SciPy para álgebra linear.",
                                "Análise Numérica: Teoria de condicionamento e estabilidade.",
                                "Engenharia de Materiais: Modelagem experimental de curvas tensão-deformação."
                              ],
                              "realWorldApplication": "Na análise de dados de ensaios destrutivos em estruturas civis (ex: fadiga de vigas), reescalonamento evita erros numéricos em softwares como ANSYS ou MATLAB, garantindo dimensionamentos seguros e precisos de elementos como lajes e pilares."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Matriz de Gram no Ajuste de Curvas",
                        "description": "Construção e propriedades da matriz de Gram G = A^T A, central no método dos mínimos quadrados para ajuste de curvas, e sua relação direta com o condicionamento do problema.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Construir a matriz de Gram a partir de dados",
                            "description": "Gerar a matriz de Gram G para um conjunto de dados de engenharia civil (ex.: pontos de medição de deformações), implementando em software numérico como MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de Matriz de Gram e preparar o conjunto de dados",
                                  "subSteps": [
                                    "Revise a definição: a matriz de Gram G = A^T * A, onde A é a matriz de design com funções base avaliadas nos pontos de dados.",
                                    "Identifique o contexto: para dados de deformações em engenharia civil, como pontos (t_i, ε_i) onde t é tempo e ε é deformação.",
                                    "Colete ou gere dados exemplo: pelo menos 5 pontos, ex.: t = [1, 2, 3, 4, 5], ε = [0.1, 0.2, 0.3, 0.35, 0.4].",
                                    "Defina funções base para ajuste, ex.: polinômio linear {1, t} ou quadrático {1, t, t^2}.",
                                    "Salve dados em arquivo .csv ou .mat para MATLAB."
                                  ],
                                  "verification": "Escreva uma explicação de 3 frases sobre o papel da matriz G no condicionamento do ajuste de curvas e liste suas funções base escolhidas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Notas de aula sobre ajuste de curvas, editor de texto para dados .csv, documentação MATLAB sobre matrizes.",
                                  "tips": "Comece com funções base simples para evitar complexidade inicial; visualize dados com plot(t, ε).",
                                  "learningObjective": "Entender o propósito matemático da matriz de Gram no contexto de mínimos quadrados para dados de engenharia civil.",
                                  "commonMistakes": "Confundir G com a matriz de covariância; ignorar o número de funções base igual ao número de colunas de A."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Carregar e inspecionar dados no MATLAB",
                                  "subSteps": [
                                    "Abra MATLAB e carregue dados: use readtable('dados.csv') ou load('dados.mat').",
                                    "Extraia vetores: t = dados.t; epsilon = dados.epsilon; n = length(t).",
                                    "Visualize: plot(t, epsilon, 'o'); xlabel('Tempo'); ylabel('Deformação');",
                                    "Verifique estatísticas básicas: mean(epsilon), std(epsilon), size(t).",
                                    "Confirme ausência de NaN ou outliers: any(isnan(t)) ou isoutlier(epsilon)."
                                  ],
                                  "verification": "Execute comandos e confirme que o gráfico mostra pontos coerentes sem erros de carregamento.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "MATLAB instalado (versão R2020+ recomendada), arquivo de dados preparado.",
                                  "tips": "Use ; no final de comandos para suprimir output desnecessário; nomeie variáveis claramente.",
                                  "learningObjective": "Dominar carregamento e inspeção preliminar de dados experimentais de deformações no MATLAB.",
                                  "commonMistakes": "Índices errados em vetores (MATLAB é 1-based); não tratar unidades inconsistentes em t e ε."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz de design A",
                                  "subSteps": [
                                    "Defina número de funções base m, ex.: m=2 para linear.",
                                    "Inicialize A: A = zeros(n, m);",
                                    "Preencha colunas: A(:,1) = ones(n,1); A(:,2) = t; (adicione mais para graus superiores).",
                                    "Verifique dimensões: size(A) deve ser [n, m] com n >= m.",
                                    "Exiba A: disp(A) ou format short para visualização."
                                  ],
                                  "verification": "Confirme size(A) == [5 2] e que colunas são ortogonais ou condicionado adequadamente com cond(A).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ambiente MATLAB ativo com dados carregados.",
                                  "tips": "Use loops for i=1:m para funções mais complexas como t.^2; vetorize sempre que possível.",
                                  "learningObjective": "Construir corretamente a matriz de design A para funções base em ajuste de deformações.",
                                  "commonMistakes": "Erro de transposição (A deve ter linhas = pontos, colunas = funções); escalas muito diferentes entre colunas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e validar a matriz de Gram G",
                                  "subSteps": [
                                    "Calcule G: G = A' * A;",
                                    "Exiba G: disp(G); verifique se é simétrica: isequal(G, G').",
                                    "Calcule autovalores: eig(G) para checar positivos.",
                                    "Avalie condicionamento: cond(G) < 1e10 indica bom condicionamento.",
                                    "Salve resultado: save('matrizG.mat', 'G');"
                                  ],
                                  "verification": "G é simétrica, diagonal positiva, e cond(G) razoável; compare com cálculo manual para n pequeno.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "MATLAB com A construída.",
                                  "tips": "Use format long para precisão; normalize colunas de A se cond alto.",
                                  "learningObjective": "Implementar computacionalmente G = A^T A e validar suas propriedades.",
                                  "commonMistakes": "Esquecer transposição (A'*A não A*A'); overflow em dados grandes sem normalização."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e documentar a matriz de Gram",
                                  "subSteps": [
                                    "Analise elementos: G(1,1) = n, G(1,2)=sum(t), etc.",
                                    "Discuta condicionamento: se cond(G)>1e12, sugira funções base ortogonais.",
                                    "Compare com ajuste: beta = G \\ (A'*epsilon);",
                                    "Documente em relatório: inclua código, G e interpretação.",
                                    "Teste sensibilidade: adicione ruído a epsilon e recalcule."
                                  ],
                                  "verification": "Escreva parágrafo explicando implicações de G para estabilidade do ajuste de deformações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto ou MATLAB Live Script para relatório.",
                                  "tips": "Use publish para converter script em HTML; sempre comente código.",
                                  "learningObjective": "Interpretar G no contexto de condicionamento para problemas reais de engenharia civil.",
                                  "commonMistakes": "Ignorar off-diagonais grandes indicando multicolinearidade; não testar com ruído realista."
                                }
                              ],
                              "practicalExample": "Para dados de deformação em uma viga: t=[1;2;3;4;5], ε=[0.1;0.22;0.31;0.39;0.48]. Funções base: {1, t}. A=[1 1;1 2;1 3;1 4;1 5], G=A'*A = [5 15; 15 55]. Em MATLAB: A=[ones(5,1), t]; G=A'*A; resulta em G = [5 15;15 55], cond(G)=55.",
                              "finalVerifications": [
                                "Matriz G é simétrica e positiva semi-definida (autovalores >=0).",
                                "Dimensões de G são [m x m], onde m=numero de funções base.",
                                "Cálculo manual de pelo menos um elemento coincide com MATLAB.",
                                "cond(G) calculado e interpretado corretamente.",
                                "Código completo roda sem erros e produz plot de dados.",
                                "Relatório inclui interpretação para dados de deformações."
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo de G (erro <1e-10 vs manual).",
                                "Correta construção de A com funções base adequadas.",
                                "Validação completa (simetria, autovalores, condicionamento).",
                                "Código limpo, comentado e reproduzível.",
                                "Interpretação contextualizada para engenharia civil.",
                                "Tratamento de edge cases como dados colineares."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: produtos internos e decomposição espectral.",
                                "Programação Numérica: manipulação de matrizes em MATLAB/Octave.",
                                "Estatística: teoria de mínimos quadrados e multicolinearidade.",
                                "Análise Numérica: análise de condicionamento e estabilidade.",
                                "Engenharia de Materiais: modelagem de deformações em estruturas."
                              ],
                              "realWorldApplication": "Em monitoramento de integridade estrutural de pontes ou barragens, a matriz de Gram avalia o condicionamento do ajuste de curvas para prever deformações a partir de sensores, evitando soluções instáveis que poderiam levar a diagnósticos errados de falhas."
                            },
                            "estimatedTime": "0.75 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Avaliar condicionamento via decomposição da matriz de Gram",
                            "description": "Usar decomposição em valores singulares (SVD) da matriz de Gram para identificar singularidades e calcular o número de condição efetivo no ajuste de curvas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir a Matriz de Gram a partir dos Dados de Ajuste de Curvas",
                                  "subSteps": [
                                    "Colete os dados de entrada: pontos (x_i, y_i) para o ajuste de curvas.",
                                    "Defina a base de funções (ex: polinômios de grau n) para o modelo.",
                                    "Calcule os elementos da matriz de Gram G_{jk} = ∫ φ_j(x) φ_k(x) w(x) dx ou soma discreta ∑ φ_j(x_i) φ_k(x_i).",
                                    "Implemente a integração numérica ou soma em software (ex: Python com NumPy).",
                                    "Verifique simetria e positividade semi-definida da matriz resultante."
                                  ],
                                  "verification": "Matriz G é simétrica e todos os autovalores são não-negativos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dados de exemplo em CSV",
                                    "Python com NumPy/SciPy",
                                    "Documentação de integração numérica"
                                  ],
                                  "tips": "Use pesos w(x) apropriados para dados não-uniformes; normalize funções base se necessário.",
                                  "learningObjective": "Entender como a matriz de Gram representa a sobreposição das funções base no ajuste.",
                                  "commonMistakes": [
                                    "Erro na indexação das funções base",
                                    "Ignorar pesos ou normalização",
                                    "Confundir soma discreta com integral contínua"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Decomposição em Valores Singulares (SVD) da Matriz de Gram",
                                  "subSteps": [
                                    "Implemente SVD usando biblioteca numérica: G = U Σ V^T.",
                                    "Extraia os valores singulares σ_i da diagonal de Σ.",
                                    "Ordene os valores singulares em ordem decrescente.",
                                    "Calcule os vetores singulares esquerdos U e direitos V.",
                                    "Valide a reconstrução: norm(G - U @ Σ @ V.T) < epsilon."
                                  ],
                                  "verification": "Reconstrução da matriz G com erro < 1e-10.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python: np.linalg.svd()",
                                    "Matriz G do passo anterior"
                                  ],
                                  "tips": "Use full_matrices=False para eficiência em matrizes quadradas.",
                                  "learningObjective": "Dominar o uso computacional de SVD para decompor matrizes simétricas positivas.",
                                  "commonMistakes": [
                                    "Não ordenar σ_i",
                                    "Confundir U e V",
                                    "Ignorar precisão numérica em σ pequenos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Singularidades Analisando os Valores Singulares",
                                  "subSteps": [
                                    "Defina um limiar de tolerância ε (ex: 1e-10 * σ_max) para singularidades.",
                                    "Classifique σ_i como zero se |σ_i| < ε.",
                                    "Conte o número de σ_i significativos (rank efetivo).",
                                    "Visualize o espectro de σ_i em gráfico logarítmico.",
                                    "Discuta implicações: rank < dimensão indica multicolinearidade."
                                  ],
                                  "verification": "Gráfico mostra gap claro entre σ significativos e nulos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matplotlib para plot",
                                    "Valores singulares de SVD"
                                  ],
                                  "tips": "Escolha ε baseado na precisão da máquina e ruído dos dados.",
                                  "learningObjective": "Reconhecer singularidades via SVD e seu impacto na invertibilidade.",
                                  "commonMistakes": [
                                    "Limiar fixo inadequado",
                                    "Não plotar em escala log",
                                    "Contar todos σ > 0 como significativos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o Número de Condição Efetivo",
                                  "subSteps": [
                                    "Identifique σ_max (maior σ_i > ε) e σ_min (menor σ_i > ε).",
                                    "Compute cond(G) = σ_max / σ_min.",
                                    "Interprete: cond < 10^3 bom; > 10^6 il-condicionado.",
                                    "Compare com autovalores para validação (já que G simétrica).",
                                    "Registre cond em relatório com contexto dos dados."
                                  ],
                                  "verification": "Valor de cond coincide com np.linalg.cond(G, p=None).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Valores singulares filtrados",
                                    "Função np.linalg.cond()"
                                  ],
                                  "tips": "Use p='fro' para norma Frobenius se necessário.",
                                  "learningObjective": "Calcular e interpretar o número de condição via SVD.",
                                  "commonMistakes": [
                                    "Incluir σ=0 em σ_min",
                                    "Usar σ_max / σ_1 em vez de efetivo",
                                    "Ignorar escala dos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar o Impacto no Ajuste de Curvas",
                                  "subSteps": [
                                    "Simule ajuste com G il-condicionada: resolva sistema G β = b.",
                                    "Compare soluções com ruído adicionado vs sem ruído.",
                                    "Analise sensibilidade dos coeficientes β aos dados.",
                                    "Proponha regularização (ex: truncar SVD pequenos σ).",
                                    "Conclua sobre estabilidade do modelo de ajuste."
                                  ],
                                  "verification": "Ajuste com truncagem SVD reduz variação em β > 50%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Sistema completo de ajuste",
                                    "Dados com ruído sintético"
                                  ],
                                  "tips": "Adicione ruído gaussiano ~1% para testar sensibilidade.",
                                  "learningObjective": "Ligar condicionamento numérico à robustez do ajuste de curvas.",
                                  "commonMistakes": [
                                    "Não quantificar impacto",
                                    "Omitir regularização",
                                    "Testar só com dados perfeitos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de engenharia civil, ajuste uma curva polinomial de grau 5 aos dados de deformação de uma viga sob carga (x=posições, y=deformações medidas). Construa G via soma discreta, aplique SVD: σ = [1e3, 500, 100, 1e-2, 1e-12, 1e-15]. cond ≈ 1e5 indica il-condicionamento; trunque σ<1e-5 para estabilizar coeficientes β, melhorando previsão de falhas estruturais.",
                              "finalVerifications": [
                                "Construção correta de G simétrica positiva.",
                                "SVD reconstrói G com alta precisão.",
                                "Identificação precisa de rank efetivo e singularidades.",
                                "Cálculo de cond(G) matches biblioteca.",
                                "Demonstração de impacto no ajuste com ruído.",
                                "Proposta válida de mitigação (ex: regularização SVD)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica em todos cálculos (erro <1e-8).",
                                "Interpretação correta de cond >10^4 como problemático.",
                                "Uso adequado de limiares para σ efetivos.",
                                "Análise qualitativa e quantitativa do condicionamento.",
                                "Aplicação prática em exemplo real de engenharia.",
                                "Clareza em relatórios e visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Propriedades de SVD e normas de matriz.",
                                "Estatística: Análise de multicolinearidade em regressão.",
                                "Programação Numérica: Implementação eficiente em Python/NumPy.",
                                "Engenharia Computacional: Estabilidade em simulações FEM.",
                                "Análise Numérica: Condicionamento e regularização."
                              ],
                              "realWorldApplication": "Na análise estrutural de pontes, SVD da Gram avalia se dados de sensores (deformações) permitem ajuste confiável de modelos preditivos, detectando multicolinearidade para evitar erros em previsões de colapso sob cargas extremas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.1",
                              "10.1.7.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.3",
                        "name": "Análise de Autovalores para Estabilidade Numérica",
                        "description": "Uso de autovalores e autofunções da matriz de Gram para quantificar a estabilidade numérica do ajuste de curvas, identificando modos il-condicionados.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.3.1",
                            "name": "Calcular autovalores da matriz de Gram",
                            "description": "Computar o espectro de autovalores de G usando funções eig() em MATLAB ou numpy.linalg.eig em Python, para matrizes de ajuste de curvas com dados reais de engenharia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir a Matriz de Gram a partir de Dados de Engenharia",
                                  "subSteps": [
                                    "Colete dados reais de engenharia civil, como cargas (x) e deformações (y) em uma viga para ajuste polinomial de grau 2.",
                                    "Forme a matriz de design X com colunas [1, x, x²] para n pontos de dados.",
                                    "Calcule G = Xᵀ X manualmente ou usando multiplicação matricial para entender a estrutura."
                                  ],
                                  "verification": "Verifique se G é simétrica positiva semidefinida imprimindo-a e confirmando G == G.T.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Dados de exemplo: x = [0,1,2,3,4], y = [0,1,3,6,10]",
                                    "Calculadora matricial ou papel"
                                  ],
                                  "tips": "Use dados com possível multicolinearidade, como pontos quase lineares, para testar.",
                                  "learningObjective": "Compreender a origem da matriz de Gram no contexto de ajuste de curvas.",
                                  "commonMistakes": [
                                    "Esquecer de centralizar dados se necessário",
                                    "Erro na formação de X (poderes errados)",
                                    "Não verificar simetria"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente de Programação e Carregar Dados",
                                  "subSteps": [
                                    "Instale numpy via pip se necessário e importe: import numpy as np.",
                                    "Defina os vetores x e y com dados reais de deformação de vigas sob carga.",
                                    "Construa X = np.vander(x, 3, increasing=True) e compute G = X.T @ X."
                                  ],
                                  "verification": "Execute print(G) e confirme que corresponde ao cálculo manual do Step 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Jupyter Notebook ou IDE como VS Code",
                                    "Biblioteca numpy"
                                  ],
                                  "tips": "Use np.vander para eficiência em polinômios; teste com N=5 pontos.",
                                  "learningObjective": "Dominar a implementação computacional da matriz de Gram em Python.",
                                  "commonMistakes": [
                                    "Usar vander com increasing=False",
                                    "Erro de shape em X.T @ X",
                                    "Dados não numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Autovalores usando numpy.linalg.eig",
                                  "subSteps": [
                                    "Aplique eigenvalues, eigenvectors = np.linalg.eig(G).",
                                    "Extraia autovalores como np.sort(eigenvalues) para ordenação.",
                                    "Para MATLAB alternativo: [V,D] = eig(G); eigenvalues = diag(D)."
                                  ],
                                  "verification": "Confirme que autovalores são reais e não-negativos com np.all(eigenvalues >= 0) e print.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "numpy.linalg",
                                    "Código do Step 2"
                                  ],
                                  "tips": "Use np.linalg.eigvals(G) se só precisar de autovalores para velocidade.",
                                  "learningObjective": "Executar computação de espectro de autovalores de forma precisa.",
                                  "commonMistakes": [
                                    "Confundir eig com svd",
                                    "Não ordenar autovalores",
                                    "Ignorar autovalores complexos devido a erros numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Autovalores para Estabilidade Numérica",
                                  "subSteps": [
                                    "Calcule o número de condicionamento cond = eigenvalues[0]/eigenvalues[-1].",
                                    "Identifique autovalores próximos de zero indicando multicolinearidade.",
                                    "Compare com norma de G e residual do ajuste de curvas para validação."
                                  ],
                                  "verification": "Se cond > 1e6, reporte instabilidade; plote log(eigenvalues) para visualização.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "matplotlib para plot",
                                    "Código anterior"
                                  ],
                                  "tips": "Log-scale para visualizar autovalores pequenos; teste perturbando dados.",
                                  "learningObjective": "Interpretar autovalores no contexto de condicionamento em ajuste de curvas.",
                                  "commonMistakes": [
                                    "cond = max/min ao invés de min/max para ratio",
                                    "Ignorar autovalores zero",
                                    "Não relacionar com erro de ajuste"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de vigas de concreto: dados x=[0,50,100,150,200] kN, y=[0,0.5,1.8,3.2,5.0] mm. Construa G para polinômio grau 2, compute autovalores [1.2e6, 4.5e3, 1.2e-2]. Pequeno autovalor indica instabilidade em coeficientes altos graus.",
                              "finalVerifications": [
                                "Matriz G simétrica e G == X.T @ X confirmada.",
                                "Autovalores computados corretamente e ordenados.",
                                "Número de condicionamento calculado e interpretado (>1e10 = ill-conditioned).",
                                "Identificados autovalores próximos de zero para multicolinearidade.",
                                "Resultados validados com dados perturbados.",
                                "Código reproduzível em MATLAB equivalente."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: autovalores coincidem com analíticos em 1e-10.",
                                "Correta interpretação: ligação explícita com estabilidade do ajuste.",
                                "Eficiência: código limpo, uso otimizado de funções.",
                                "Robustez: lida com casos singulares sem crash.",
                                "Documentação: comentários explicando cada linha chave.",
                                "Visualização: gráfico de autovalores em escala log."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: decomposição espectral e propriedades de Gram.",
                                "Programação Numérica: estabilidade de algoritmos eig.",
                                "Estatística: detecção de multicolinearidade em regressão.",
                                "Engenharia Computacional: análise de condicionamento em simulações FEM."
                              ],
                              "realWorldApplication": "Na engenharia civil, analisar autovalores de G em ajuste de curvas para modelar deformações em pontes sob carga variável, detectando multicolinearidade que causa erros em previsões de falha estrutural, evitando projetos superestimados."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.2",
                            "name": "Determinar razão de condição via autovalores",
                            "description": "Calcular cond_2(G) = λ_max / λ_min, onde λ são autovalores, e analisar como pequenas perturbações afetam os coeficientes do ajuste de curvas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Matriz Gram e Autovalores no Ajuste de Curvas",
                                  "subSteps": [
                                    "Revise o método dos mínimos quadrados lineares para ajuste de curvas: β = (X^T X)^{-1} X^T y.",
                                    "Identifique a matriz Gram G = X^T X, onde X é a matriz de Vandermonde ou design para bases polinomiais.",
                                    "Explique que autovalores λ de G medem a elongação nas direções principais e indicam condicionamento.",
                                    "Discuta por que λ_max / λ_min quantifica a sensibilidade à perturbações.",
                                    "Estude propriedades: G é simétrica positiva semidefinida, autovalores reais não-negativos."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o papel de cond_2(G) no contexto de estabilidade numérica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Notebook Jupyter com NumPy/SciPy",
                                    "Notas de aula sobre mínimos quadrados"
                                  ],
                                  "tips": "Visualize autovalores como escalas de uma elipse: λ_min pequeno significa direção frágil.",
                                  "learningObjective": "Entender conceitualmente como autovalores de G determinam o condicionamento do problema de ajuste.",
                                  "commonMistakes": [
                                    "Confundir G com X",
                                    "Assumir autovalores sempre positivos sem verificar rank de X",
                                    "Ignorar normalização de dados que afeta G"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Matriz G e Calcular seus Autovalores",
                                  "subSteps": [
                                    "Colete dados reais (ex: pontos de deformação vs. tempo em estrutura civil).",
                                    "Monte a matriz de design X para base polinomial (ex: colunas 1, t, t^2).",
                                    "Calcule G = X^T X manualmente para pequena X (2x2 ou 3x3).",
                                    "Use software (NumPy eig ou MATLAB eigs) para autovalores de G maior.",
                                    "Ordene autovalores: λ_max = max(λ), λ_min = min(λ > 0), verifique ill-conditioning se cond > 10^6."
                                  ],
                                  "verification": "Para uma X 5x3 dada, compute G e liste λ ordenados; confirme ||G v - λ v|| < 1e-10 para autovetor v.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy/Matplotlib",
                                    "MATLAB ou Octave",
                                    "Dados exemplo: subsidência de solo (10 pontos)"
                                  ],
                                  "tips": "Sempre centre e escale dados antes para melhorar condicionamento inicial.",
                                  "learningObjective": "Dominar o cálculo prático de autovalores para matrizes Gram em cenários reais.",
                                  "commonMistakes": [
                                    "Erro em transposição X^T",
                                    "Usar autovalores complexos sem diagnosticar",
                                    "Selecionar λ_min = 0 sem checar singularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar e Interpretar a Razão de Condição cond_2(G)",
                                  "subSteps": [
                                    "Calcule cond_2(G) = λ_max / λ_min explicitamente.",
                                    "Classifique: cond < 10^3 bem condicionado; 10^3-10^6 moderado; >10^6 mal condicionado.",
                                    "Compare com ||G||_2 * ||G^{-1}||_2 para validação.",
                                    "Plote espectro de autovalores (gap entre λ_max e λ_min).",
                                    "Discuta implicações: alto cond amplifica erros em β."
                                  ],
                                  "verification": "Para G exemplo, compute cond_2 e estime erro relativo em β: |Δβ|/|β| ≈ cond * |Δy|/|y|.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de plotagem (Matplotlib)",
                                    "Calculadora simbólica (SymPy para exatos)"
                                  ],
                                  "tips": "Log-scale para plot de λ evita overflow em cond grande.",
                                  "learningObjective": "Calcular e interpretar cond_2(G) como métrica de estabilidade.",
                                  "commonMistakes": [
                                    "Usar média aritmética em vez de max/min",
                                    "Esquecer de excluir λ=0",
                                    "Confundir cond_2 com cond_1 (trace)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto de Perturbações nos Coeficientes",
                                  "subSteps": [
                                    "Perturbe y com ruído gaussiano pequeno (ε = 1e-6 * std(y)).",
                                    "Reajuste β_original e β_perturbado; compute ||Δβ|| / ||β||.",
                                    "Relacione Δβ ≈ cond_2(G) * ε via análise de erro backward/forward.",
                                    "Teste com bases diferentes (ex: polinomial vs. Chebyshev) e compare cond.",
                                    "Simule em contexto civil: perturbação em medições de strain gauges."
                                  ],
                                  "verification": "Demonstre numericamente que ||Δβ|| / ||β|| ≈ cond_2 * ε para 3 níveis de ruído.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python para simulação Monte Carlo",
                                    "Dados de engenharia civil (ex: CSV de deflectometer)"
                                  ],
                                  "tips": "Use QR ou SVD para decomposição estável em vez de inv(G).",
                                  "learningObjective": "Quantificar como perturbações propagam via cond_2(G) para decisões de modelagem.",
                                  "commonMistakes": [
                                    "Perturbar X em vez de y",
                                    "Ignorar correlação em ruído real",
                                    "Sobrepor cond com overfitting"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de subsidência de uma barragem: dados (t, s) com 20 pontos. Monte X para P2(t)=a+bt+ct^2, G=X^T X. Autovalores [1e5, 10, 0.01], cond_2=1e7. Perturbe s com 0.1% ruído: coef c varia 1000%, indicando necessidade de regularização ou base ortogonal.",
                              "finalVerifications": [
                                "Calcule corretamente autovalores e cond_2 para matriz G 4x4 fornecida.",
                                "Explique verbalmente o impacto de cond alto em coeficientes de ajuste.",
                                "Simule perturbação e quantifique erro relativo em β.",
                                "Identifique quando cond_2 indica reformulação do problema.",
                                "Compare cond_2 com norma de G^{-1} para validação.",
                                "Aplique a dados civis e recomende mitigação (ex: Tikhonov)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de autovalores (erro <1e-8).",
                                "Interpretação correta de cond_2 e thresholds.",
                                "Análise quantitativa de perturbações com evidência numérica.",
                                "Uso apropriado de software e visualizações claras.",
                                "Conexão explícita com estabilidade em engenharia civil.",
                                "Identificação de erros comuns e prevenções."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição espectral e normas de matriz.",
                                "Análise Numérica: Erros de arredondamento e estabilidade backward.",
                                "Estatística: Inferência em regressão e multicolinearidade.",
                                "Engenharia Computacional: Condicionamento em FEM e otimização.",
                                "Física Aplicada: Modelagem de deformações elásticas via autovalores."
                              ],
                              "realWorldApplication": "Na engenharia civil, ao ajustar curvas para prever deformações em pontes ou barragens a partir de sensores, um cond_2(G) alto (>10^8) sinaliza que erros de medição (ex: vibrações) podem invalidar coeficientes, levando a decisões erradas de manutenção e risco de falha estrutural."
                            },
                            "estimatedTime": "0.75 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.3",
                            "name": "Interpretar autofunções para diagnóstico de problemas",
                            "description": "Examinar autofunções associadas a autovalores pequenos para identificar direções de instabilidade no espaço dos parâmetros do modelo de curva ajustada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos de autovalores e autofunções no contexto de condicionamento",
                                  "subSteps": [
                                    "Relembre que autovalores pequenos indicam direções de alta sensibilidade na matriz Hessiana aproximada do ajuste de curvas.",
                                    "Entenda que autofunções são vetores que definem as direções de variação nos parâmetros do modelo.",
                                    "Identifique a matriz relevante (ex: matriz de informação de Fisher ou Hessiana normalizada) obtida do ajuste.",
                                    "Liste os autovalores em ordem crescente para priorizar os menores.",
                                    "Discuta numericamente o limiar para 'pequeno' autovalor (ex: próximo de zero ou ratio cond > 10^6)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o papel das autofunções em instabilidades paramétricas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de álgebra linear (PDF ou notebook Jupyter)",
                                    "Software: Python com NumPy/SciPy ou MATLAB"
                                  ],
                                  "tips": "Use logaritmo dos autovalores para visualizar escalas.",
                                  "learningObjective": "Compreender a relação matemática entre autovalores pequenos e instabilidade direcional.",
                                  "commonMistakes": "Confundir autovalores com autofunções; ignorar normalização das autofunções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e extrair autofunções associadas a autovalores pequenos",
                                  "subSteps": [
                                    "Ordene os autovalores e selecione os 2-3 menores (tipicamente < 10^-3 vezes o maior).",
                                    "Extraia as autofunções correspondentes usando funções como eig() em MATLAB ou eigh() em SciPy.",
                                    "Normalize as autofunções para soma de quadrados = 1.",
                                    "Armazene em uma matriz onde colunas são autofunções ordenadas por autovalores crescentes.",
                                    "Verifique ortogonalidade das autofunções com produto escalar próximo de zero."
                                  ],
                                  "verification": "Gere um plot de autovalores e confirme seleção das autofunções menores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notebook Jupyter com dados de exemplo de ajuste de curva",
                                    "Bibliotecas: NumPy, SciPy, Matplotlib"
                                  ],
                                  "tips": "Salve autofunções em formato vetorial para análise posterior.",
                                  "learningObjective": "Selecionar corretamente componentes instáveis do espectro de autovalores.",
                                  "commonMistakes": "Selecionar autovalores errados; não normalizar vetores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar componentes das autofunções para diagnosticar instabilidades",
                                  "subSteps": [
                                    "Examine as componentes absolutas da autofunção: grandes valores indicam parâmetros instáveis.",
                                    "Identifique parâmetros com |componente| > 0.5 como direções principais de instabilidade.",
                                    "Mapeie parâmetros do modelo (ex: coeficientes a0, a1 em polinômio) às componentes.",
                                    "Calcule contribuições relativas: componente^2 * 1/autovalor para sensibilidade.",
                                    "Visualize com bar plot das componentes para clareza."
                                  ],
                                  "verification": "Descreva quais parâmetros são instáveis e por quê, com base na autofunção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos gerados em Python/MATLAB",
                                    "Dados simulados de ajuste de curva com ruído"
                                  ],
                                  "tips": "Foque em autofunções com autovalores < 1% do maior para diagnósticos precisos.",
                                  "learningObjective": "Traduzir autofunções em insights sobre parâmetros problemáticos.",
                                  "commonMistakes": "Ignorar sinais das componentes; confundir magnitude com direção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar diagnóstico e propor correções",
                                  "subSteps": [
                                    "Perturbe parâmetros ao longo da direção da autofunção e observe variação na curva ajustada.",
                                    "Compare com curvas de confiança (ex: elipses de erro baseadas em autovalores).",
                                    "Proponha fixes: reparametrização, regularização (ridge), ou modelo mais simples.",
                                    "Documente relatório com plots de sensibilidade e recomendações.",
                                    "Teste em dados reais para confirmação."
                                  ],
                                  "verification": "Gere relatório resumindo diagnóstico e simulações de perturbação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramentas de plotagem avançada (Matplotlib/Plotly)",
                                    "Dados de engenharia civil reais"
                                  ],
                                  "tips": "Use perturbações pequenas (1e-6) escaladas pelo autovalor.",
                                  "learningObjective": "Aplicar interpretação para soluções práticas de condicionamento ruim.",
                                  "commonMistakes": "Não validar com simulações; superestimar fixes sem teste."
                                }
                              ],
                              "practicalExample": "Em um ajuste de curva exponencial para dados de deflexão vs carga em uma viga de concreto (modelo y = a * (1 - exp(-b*x)) + c), o menor autovalor λ1=1e-8 associa-se à autofunção [0.1, 0.95, 0.3], indicando que o parâmetro 'b' (taxa de saturação) é altamente instável; perturbações em b causam grandes variações na previsão de deflexão máxima.",
                              "finalVerifications": [
                                "Lista corretamente autovalores pequenos e suas autofunções.",
                                "Identifica parâmetros instáveis com base em componentes dominantes.",
                                "Explica impacto na estabilidade do modelo com exemplo numérico.",
                                "Propõe pelo menos duas estratégias de mitigação.",
                                "Valida interpretação via simulação de perturbação.",
                                "Gera visualizações claras de direções instáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de autofunções relevantes (90%+ correção).",
                                "Profundidade da interpretação de componentes (cobertura de todas as direções).",
                                "Qualidade das visualizações e simulações (clareza e relevância).",
                                "Criatividade nas propostas de correção (viáveis e justificadas).",
                                "Compreensão conceitual demonstrada em relatório (sem erros fundamentais).",
                                "Eficiência temporal (completa em <2h com resultados acionáveis)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição espectral e análise de matrizes.",
                                "Estatística: Análise de sensibilidade e intervalos de confiança em regressão.",
                                "Programação Numérica: Uso de solvers eigendecomposição em SciPy/MATLAB.",
                                "Engenharia Computacional: Otimização e condicionamento em modelos físicos.",
                                "Análise de Dados: Visualização de alta dimensionalidade."
                              ],
                              "realWorldApplication": "Na análise de monitoramento estrutural de pontes, ao ajustar curvas de deformação temporal, o diagnóstico via autofunções revela parâmetros sensíveis a ruído sensorial, permitindo reparametrização para previsões confiáveis de fadiga e manutenção preventiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.1",
                              "10.1.7.3.3.2"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.4",
                            "name": "Simular impacto de ruído com Monte Carlo",
                            "description": "Gerar números aleatórios para adicionar ruído aos dados, resolver múltiplos ajustes e quantificar variância nos parâmetros devido ao condicionamento ruim.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Conjunto de Dados e Avaliar Condicionamento Inicial",
                                  "subSteps": [
                                    "Selecione um conjunto de dados real ou sintético para ajuste de curvas, como pontos de deformação vs. carga em uma viga.",
                                    "Calcule a matriz de Vandermonde ou equivalente para o modelo polinomial proposto.",
                                    "Realize análise de autovalores da matriz para quantificar o condicionamento ruim (cond number alto).",
                                    "Documente os parâmetros nominais do ajuste sem ruído.",
                                    "Defina o nível de ruído (ex: 1-5% do sinal) baseado em incertezas experimentais típicas."
                                  ],
                                  "verification": "Matriz de condicionamento calculada e autovalores listados; parâmetros nominais obtidos com erro residual baixo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de programação (Python com NumPy/SciPy ou MATLAB)",
                                    "Conjunto de dados de exemplo (CSV com x,y)"
                                  ],
                                  "tips": "Use funções prontas como np.linalg.cond() para condicionamento; visualize autovalores em gráfico logarítmico.",
                                  "learningObjective": "Compreender como o condicionamento afeta a sensibilidade a ruídos nos parâmetros ajustados.",
                                  "commonMistakes": [
                                    "Ignorar normalização dos dados levando a escalas desbalanceadas",
                                    "Escolher modelo polinomial de alta ordem sem justificativa",
                                    "Confundir autovalores com valores singulares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e Adicionar Ruído Aleatório aos Dados",
                                  "subSteps": [
                                    "Defina um gerador de números aleatórios (ex: distribuição normal com média 0 e desvio padrão σ).",
                                    "Gere N amostras de ruído (N=1000+) para cada ponto de dado.",
                                    "Adicione ruído a cada conjunto de dados original: y_noisy = y + noise.",
                                    "Crie um loop ou vetorização para gerar múltiplos conjuntos ruidosos.",
                                    "Salve ou armazene os conjuntos para simulações subsequentes."
                                  ],
                                  "verification": "Histograma do ruído gerado mostra distribuição normal; amostras ruidosas variam em torno dos dados originais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Bibliotecas: NumPy.random.normal(), SciPy.stats",
                                    "Script Jupyter Notebook para visualização"
                                  ],
                                  "tips": "Use semente fixa (np.random.seed(42)) para reprodutibilidade; teste com σ pequeno primeiro.",
                                  "learningObjective": "Dominar geração de ruído gaussiano realista simulando erros de medição.",
                                  "commonMistakes": [
                                    "Ruído assimétrico ou com média não zero",
                                    "Gerar ruído correlacionado sem intenção",
                                    "Número insuficiente de amostras levando a variância mal estimada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Múltiplos Ajustes de Curvas com Dados Ruidosos",
                                  "subSteps": [
                                    "Configure um loop Monte Carlo para M iterações (M=500-1000).",
                                    "Para cada iteração: resolva o sistema linear (np.linalg.lstsq) para parâmetros ajustados.",
                                    "Armazene os vetores de parâmetros de cada ajuste em uma matriz.",
                                    "Monitore tempo de computação e convergência.",
                                    "Visualize trajetórias dos parâmetros ao longo das iterações."
                                  ],
                                  "verification": "Matriz de parâmetros tem shape (M, num_params); loop completa sem erros numéricos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Funções: np.linalg.lstsq(), matplotlib para plots",
                                    "Hardware com boa performance para loops"
                                  ],
                                  "tips": "Vetorize onde possível para eficiência; use progress bar (tqdm) para loops longos.",
                                  "learningObjective": "Implementar simulação Monte Carlo para propagação de incertezas em ajustes lineares.",
                                  "commonMistakes": [
                                    "Singularidade em alguns ajustes devido a ruído extremo",
                                    "Poucas iterações M levando a estimativas instáveis",
                                    "Não tratar casos de falha no solver"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Quantificar Variância dos Parâmetros",
                                  "subSteps": [
                                    "Calcule estatísticas descritivas: média, desvio padrão, variância para cada parâmetro.",
                                    "Gere boxplots ou histogramas da distribuição dos parâmetros.",
                                    "Compare variâncias com o condicionamento inicial (correlação esperada).",
                                    "Calcule coeficiente de variação (CV = std/mean) para sensibilidade relativa.",
                                    "Interprete resultados: identifique parâmetros mais afetados pelo ruído."
                                  ],
                                  "verification": "Tabela de estatísticas gerada; gráficos mostram variância ampliada em parâmetros sensíveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pandas para DataFrames de stats",
                                    "Seaborn/Matplotlib para visualizações avançadas"
                                  ],
                                  "tips": "Relacione variância observada com autovalores pequenos; normalize parâmetros para comparação.",
                                  "learningObjective": "Quantificar e interpretar impacto do condicionamento ruim via variância Monte Carlo.",
                                  "commonMistakes": [
                                    "Confundir variância amostral com desvio padrão",
                                    "Ignorar viés nos parâmetros médios",
                                    "Não correlacionar com análise de autovalores"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um experimento de ensaio de compressão em concreto, dados de carga vs. deformação são ruidosos devido a sensores. Simule 1000 ajustes de uma reta y = a*x + b com ruído gaussiano σ=0.01. Observe que 'a' (módulo de elasticidade) varia 20% devido a condicionamento ruim em dados quase colineares.",
                              "finalVerifications": [
                                "Distribuição dos parâmetros mostra variância quantificada com std > 5% em coeficientes sensíveis.",
                                "Gráficos de boxplot confirmam correlação entre autovalores pequenos e alta variância.",
                                "Número de iterações M é suficiente (teste de convergência da std).",
                                "Resultados reprodutíveis com semente fixa.",
                                "Interpretação liga variância ao condicionamento da matriz.",
                                "Tempo total de simulação < 5 minutos para M=1000."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração de ruído (distribuição N(0,σ) validada por QQ-plot).",
                                "Eficiência computacional do loop Monte Carlo (vetorizado onde possível).",
                                "Correta quantificação de variância (uso de np.var(ddof=1)).",
                                "Visualizações claras e interpretáveis dos resultados.",
                                "Análise qualitativa conectando condicionamento a impactos práticos.",
                                "Código modular e comentado para reutilização."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Propagação de incertezas e métodos Monte Carlo.",
                                "Programação: Otimização de loops e análise numérica com SciPy.",
                                "Física/Mecânica: Modelagem de materiais com erros experimentais.",
                                "Matemática: Álgebra linear (autovalores, mínimos quadrados).",
                                "Engenharia de Software: Validação numérica de modelos."
                              ],
                              "realWorldApplication": "Em projetos de estruturas civis, simulações Monte Carlo avaliam confiabilidade de modelos de degradação de materiais sob ruído de sensores IoT, auxiliando na previsão de falhas e dimensionamento seguro de pontes ou edifícios."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.1",
                              "10.1.7.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Método dos Resíduos Ponderados",
                    "description": "Extensão do mínimos quadrados com pesos para dados com variâncias desiguais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Limitações do Mínimos Quadrados Ordinário e Motivação para Pesos",
                        "description": "Compreensão das limitações do método dos mínimos quadrados ordinário (MQO) quando aplicado a dados com variâncias desiguais e introdução à necessidade de ponderação nos resíduos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Identificar variâncias desiguais em conjuntos de dados",
                            "description": "Analisar um conjunto de dados experimentais da engenharia civil para identificar heterogeneidade nas variâncias dos erros de medição, justificando a inadequação do MQO padrão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Explorar o Conjunto de Dados",
                                  "subSteps": [
                                    "Carregue o conjunto de dados experimentais de engenharia civil (ex: medições de deformação em testes de concreto).",
                                    "Realize estatística descritiva: média, desvio padrão, min/max para variáveis dependente e independente.",
                                    "Crie gráficos iniciais: scatter plot de y vs x para visualizar dispersão.",
                                    "Identifique faixas de valores onde a dispersão parece variar (ex: maior variância em valores altos de carga).",
                                    "Documente observações preliminares sobre possível heterogeneidade."
                                  ],
                                  "verification": "Gráficos gerados mostram dispersão variável e relatório com estatísticas descritivas salvo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software Python (pandas, matplotlib) ou R; dataset exemplo de testes de materiais civis (CSV com colunas: carga, deformação).",
                                  "tips": "Use log-escala no eixo y se suspeitar de variância proporcional.",
                                  "learningObjective": "Compreender a estrutura dos dados e identificar sinais visuais iniciais de heteroscedasticidade.",
                                  "commonMistakes": "Ignorar outliers que podem mascarar padrões de variância; não escalar variáveis adequadamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ajustar Modelo MQO e Calcular Resíduos",
                                  "subSteps": [
                                    "Ajuste um modelo linear simples via Mínimos Quadrados Ordinário (MQO).",
                                    "Calcule resíduos: e_i = y_i - ŷ_i para cada observação.",
                                    "Armazene resíduos em uma nova coluna no dataset.",
                                    "Calcule estatísticas dos resíduos: média (deve ser ~0), variância total.",
                                    "Salve o modelo e resíduos para análise posterior."
                                  ],
                                  "verification": "Modelo ajustado com R² reportado e array de resíduos gerado sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Bibliotecas Python (scikit-learn ou statsmodels) ou R (lm()); mesmo dataset.",
                                  "tips": "Verifique suposições do MQO (linearidade, normalidade) brevemente antes de prosseguir.",
                                  "learningObjective": "Executar MQO padrão e obter resíduos como base para detecção de violações.",
                                  "commonMistakes": "Confundir resíduos padronizados com resíduos brutos; não verificar multicolinearidade se múltiplas variáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Visualizar Padrões de Heteroscedasticidade nos Resíduos",
                                  "subSteps": [
                                    "Plote resíduos vs. valores preditos (ŷ) ou variável independente (x).",
                                    "Plote resíduos vs. unidades indexadas para detectar padrões.",
                                    "Adicione banda de confiança (±2 desvios) e observe funil (dispersão crescente).",
                                    "Crie plot de resíduos quadrados vs. ŷ para variância.",
                                    "Anote evidências qualitativas de variâncias desiguais."
                                  ],
                                  "verification": "Plots salvos mostram padrão de 'funil' ou dispersão não constante nos resíduos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matplotlib/Seaborn (Python) ou ggplot2 (R); resíduos do step anterior.",
                                  "tips": "Use escala logarítmica nos resíduos se variância for multiplicativa.",
                                  "learningObjective": "Detectar visualmente heteroscedasticidade como pré-requisito para testes formais.",
                                  "commonMistakes": "Interpretar ruído aleatório como padrão; plots mal rotulados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar Testes Estatísticos e Justificar Inadequação do MQO",
                                  "subSteps": [
                                    "Aplique teste de Breusch-Pagan ou White para heteroscedasticidade (p-valor < 0.05 indica rejeição de homoscedasticidade).",
                                    "Calcule variâncias condicionais em bins de x ou ŷ.",
                                    "Interprete resultados: variâncias desiguais violam suposição de MQO (variância constante).",
                                    "Justifique: MQO subestima erros em regiões de alta variância, levando a inferências enviesadas.",
                                    "Redija relatório com plots, testes e conclusão."
                                  ],
                                  "verification": "Relatório com p-valor do teste, interpretação e justificativa escrita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Statsmodels (Python) ou lmtest (R); todos outputs anteriores.",
                                  "tips": "Combine teste visual + estatístico para robustez; considere tamanho amostral.",
                                  "learningObjective": "Aplicar testes formais e conectar violações à teoria do MQO.",
                                  "commonMistakes": "Ignorar tamanho da amostra em testes; confundir heteroscedasticidade com não-linearidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Propor Alternativas",
                                  "subSteps": [
                                    "Resuma achados em um relatório estruturado.",
                                    "Explique impacto: intervalos de confiança inválidos no MQO.",
                                    "Proponha próximos passos: MQO ponderado com pesos 1/σ²_i.",
                                    "Simule correção rápida com pesos inversos à variância estimada.",
                                    "Arquive todo código e outputs."
                                  ],
                                  "verification": "Relatório final completo com proposta de MQO ponderado implementada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Jupyter Notebook ou R Markdown; código completo.",
                                  "tips": "Mantenha código reproduzível com seeds para randomização.",
                                  "learningObjective": "Sintetizar análise e motivar métodos avançados como resíduos ponderados.",
                                  "commonMistakes": "Não quantificar impacto da heteroscedasticidade; pular simulação de correção."
                                }
                              ],
                              "practicalExample": "Em testes de compressão de cilindros de concreto (dataset: idade do concreto em dias vs. resistência à compressão MPa), plote resíduos do MQO vs. idade: observe variância crescente em idades avançadas devido a heterogeneidade material. Teste Breusch-Pagan dá p=0.001, confirmando inadequação do MQO para predições precisas em estruturas civis.",
                              "finalVerifications": [
                                "Plots de resíduos mostram padrão claro de heteroscedasticidade (funil).",
                                "Teste estatístico rejeita homoscedasticidade (p<0.05).",
                                "Relatório justifica verbalmente limitações do MQO com evidências.",
                                "Código reproduzível gera mesmos resultados.",
                                "Proposta de pesos para MQO demonstrada.",
                                "Estatísticas descritivas dos resíduos reportadas corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção visual (80% acerto em padrões simulados).",
                                "Correta implementação e interpretação de testes (p-valor e conclusão).",
                                "Justificativa teórica completa ligando variância desigual a violações MQO.",
                                "Qualidade dos plots: legíveis, anotados, com bandas de confiança.",
                                "Relatório claro, conciso e acionável (nota >8/10).",
                                "Eficiência temporal: completado em <2h com resultados válidos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses e análise de resíduos.",
                                "Programação: Manipulação de dados em Python/R.",
                                "Engenharia Civil: Modelagem de materiais heterogêneos.",
                                "Matemática: Álgebra linear em regressão.",
                                "Gestão de Projetos: Validação de modelos para decisões de engenharia."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios, dados de sensores (ex: strain gauges) exibem variância crescente com carga alta; detectar heteroscedasticidade evita erros em predições de falha estrutural, motivando MQO ponderado para normas de segurança (ex: ABNT NBR 6118)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Explicar o impacto dos pesos nos resíduos",
                            "description": "Descrever como os pesos, tipicamente inversos às variâncias, corrigem o viés em ajustes de curvas para dados com precisão variável, com exemplos em problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as limitações do Método dos Mínimos Quadrados Ordinário (MQO)",
                                  "subSteps": [
                                    "Revisar a fórmula do MQO: minimizar a soma dos quadrados dos resíduos ε_i = y_i - ŷ_i.",
                                    "Explicar heteroscedasticidade: variâncias σ_i² diferentes para cada ponto de dados.",
                                    "Analisar como MQO dá peso igual a todos os resíduos, causando viés em dados com precisão variável.",
                                    "Visualizar com gráfico: pontos com alto ruído distorcem a curva ajustada.",
                                    "Discutir impacto em engenharia civil: medições de deformação em vigas com erros maiores em extremidades."
                                  ],
                                  "verification": "Criar um gráfico manual ou em software mostrando viés do MQO em dados simulados heterogêneos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para esboço",
                                    "Excel ou Python (biblioteca matplotlib) para gráfico",
                                    "Dataset exemplo de deformações em viga"
                                  ],
                                  "tips": [
                                    "Sempre plote os dados com barras de erro para visualizar variâncias.",
                                    "Comece com dados simples para intuição."
                                  ],
                                  "learningObjective": "Identificar como MQO falha ao tratar todos os resíduos igualmente em cenários de precisão variável.",
                                  "commonMistakes": [
                                    "Confundir variância com desvio padrão sem elevar ao quadrado.",
                                    "Ignorar a influência desproporcional de pontos ruidosos.",
                                    "Não considerar o contexto de engenharia onde precisão varia espacialmente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de pesos nos resíduos ponderados",
                                  "subSteps": [
                                    "Apresentar a fórmula do MQP: minimizar ∑ w_i (y_i - ŷ_i)², onde w_i são pesos.",
                                    "Explicar que pesos amplificam a influência de pontos precisos (alta w_i) e atenuam ruidosos.",
                                    "Derivar intuitivamente: peso inverso à incerteza para 'normalizar' resíduos.",
                                    "Comparar MQO (w_i=1 para todos) vs MQP em equação.",
                                    "Simular ajuste lado a lado em software para ver diferença visual."
                                  ],
                                  "verification": "Implementar MQO e MQP em código simples e comparar curvas ajustadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com numpy e scipy.optimize",
                                    "Jupyter Notebook",
                                    "Dataset de exemplo com variâncias conhecidas"
                                  ],
                                  "tips": [
                                    "Use w_i = 1/σ_i² para pesos ótimos em erros gaussianos.",
                                    "Teste com valores extremos de variância para ver impacto."
                                  ],
                                  "learningObjective": "Compreender a transição de MQO para MQP e o papel dos pesos na correção de viés.",
                                  "commonMistakes": [
                                    "Usar pesos como σ_i em vez de 1/σ_i².",
                                    "Esquecer de normalizar pesos (soma=1 não é obrigatória, mas útil).",
                                    "Não visualizar antes e depois."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a escolha de pesos como inversos às variâncias",
                                  "subSteps": [
                                    "Derivar matematicamente: para erros independentes N(0, σ_i²), o estimador ML usa w_i = 1/σ_i².",
                                    "Discutir estimativa de σ_i²: de repetições, réplicas ou modelo empírico.",
                                    "Calcular pesos para um dataset exemplo: listar σ_i, computar w_i.",
                                    "Analisar impacto: resíduos ponderados ε_i√w_i devem ter variância ~1.",
                                    "Aplicar a engenharia civil: variâncias maiores em medições remotas ou sob carga dinâmica."
                                  ],
                                  "verification": "Calcular pesos para 5 pontos dados e verificar se ∑ w_i ε_i² diminui vs MQO.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora ou Python (numpy)",
                                    "Tabela de dados com variâncias simuladas",
                                    "Referência: Montgomery 'Applied Statistics' capítulo sobre regressão ponderada"
                                  ],
                                  "tips": [
                                    "Se σ_i desconhecida, use 1/σ̂_i² de resíduos do MQO inicial.",
                                    "Log da variância para linearizar se necessário."
                                  ],
                                  "learningObjective": "Dominar a justificativa estatística para w_i = 1/σ_i² e seu cálculo prático.",
                                  "commonMistakes": [
                                    "Usar desvio padrão ao invés de variância no denominador.",
                                    "Não verificar normalidade dos resíduos ponderados.",
                                    "Escolher pesos arbitrários sem base estatística."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar o impacto com exemplo em engenharia civil",
                                  "subSteps": [
                                    "Definir exemplo: ajuste de curva de deformação vs carga em viga, com σ maior em cargas altas.",
                                    "Computar MQO: mostrar viés na região precisa.",
                                    "Aplicar MQP com w_i=1/σ_i²: curva corrigida alinha melhor com dados precisos.",
                                    "Quantificar melhoria: comparar R² ponderado, resíduos padronizados.",
                                    "Interpretar: melhor previsão para projeto seguro da estrutura."
                                  ],
                                  "verification": "Produzir relatório curto com gráficos MQO vs MQP e métricas de ajuste.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python/MATLAB para ajuste",
                                    "Dataset real/simulado de testes de viga (ex: 10 pontos carga-deformação)",
                                    "Software de plotagem"
                                  ],
                                  "tips": [
                                    "Escolha dataset onde variância aumenta com magnitude (comum em eng. civil).",
                                    "Use Q-Q plot para validar resíduos."
                                  ],
                                  "learningObjective": "Aplicar conceito a contexto real e quantificar benefícios dos pesos.",
                                  "commonMistakes": [
                                    "Não escalar dados, causando overflow numérico.",
                                    "Interpretar erroneamente: pesos não 'removem' dados ruins, mas os ponderam.",
                                    "Ignorar confiança nos parâmetros ajustados."
                                  ]
                                }
                              ],
                              "practicalExample": "Em testes de carga de uma viga de concreto, medições de deformação central têm σ=0.01 mm (alta precisão), enquanto extremidades têm σ=0.05 mm (baixa precisão devido a sensores). MQO superestima rigidez central; MQP com w=1/σ² corrige, alinhando curva com dados confiáveis para dimensionamento seguro.",
                              "finalVerifications": [
                                "Explicar verbalmente a fórmula MQP e por que w_i=1/σ_i² corrige viés.",
                                "Calcular pesos e ajustar curva para dataset dado com <10% erro em resíduos padronizados.",
                                "Identificar heteroscedasticidade em gráfico de resíduos vs predito.",
                                "Comparar MQO vs MQP em exemplo civil, mostrando melhoria quantitativa (ex: AIC menor).",
                                "Discutir limitações: pesos errados pioram ajuste.",
                                "Implementar MQP em código e validar com dados conhecidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: explicação correta de viés e correção por pesos (80%).",
                                "Cálculos numéricos: pesos e soma ponderada exatos (90%).",
                                "Visualizações: gráficos claros MQO vs MQP com resíduos (100%).",
                                "Aplicação contextual: ligação relevante a eng. civil (85%).",
                                "Análise crítica: discussão de suposições e erros potenciais (75%).",
                                "Clareza de comunicação: relatório ou apresentação concisa."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Modelos lineares generalizados e máxima verossimilhança.",
                                "Física/Engenharia Mecânica: Modelagem constitutiva com incertezas experimentais.",
                                "Programação: Otimização numérica (scipy.optimize, leastsq).",
                                "Probabilidade: Distribuições gaussianas heterogêneas.",
                                "Gestão de Projetos: Análise de risco em dados de campo."
                              ],
                              "realWorldApplication": "Na análise de estruturas civis como pontes ou barragens, onde dados de sensores IoT têm variâncias variáveis por localização/clima, MQP garante modelos preditivos precisos para manutenção preditiva e conformidade com normas como ABNT NBR 6118, evitando super ou subdimensionamento."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.3",
                            "name": "Comparar MQO e Método dos Resíduos Ponderados",
                            "description": "Comparar os critérios de minimização de resíduos no MQO (soma de quadrados) versus MRP (soma de quadrados ponderados), destacando melhorias na estimativa de parâmetros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método dos Mínimos Quadrados Ordinário (MQO)",
                                  "subSteps": [
                                    "Defina o MQO como o método que minimiza a soma dos quadrados dos resíduos (SSR = Σ(y_i - ŷ_i)^2).",
                                    "Escreva a fórmula matemática do critério de minimização e explique o pressuposto de homocedasticidade (variâncias iguais).",
                                    "Derive brevemente as equações normais para estimativa de parâmetros β.",
                                    "Discuta limitações quando variâncias dos erros diferem entre observações.",
                                    "Calcule manualmente SSR para um conjunto de dados simples com 5 pontos."
                                  ],
                                  "verification": "Construa a tabela de resíduos e confirme que SSR é mínimo via derivadas parciais zero.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, calculadora, planilha Excel ou Python (biblioteca NumPy).",
                                  "tips": "Sempre normalize os dados antes para evitar problemas numéricos.",
                                  "learningObjective": "Compreender o fundamento matemático e premissas do MQO.",
                                  "commonMistakes": "Ignorar a suposição de variâncias iguais, levando a estimativas enviesadas em dados heterocedásticos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Método dos Resíduos Ponderados (MRP)",
                                  "subSteps": [
                                    "Explique o MRP como extensão do MQO, minimizando Σ w_i (y_i - ŷ_i)^2, onde w_i = 1/σ_i^2.",
                                    "Discuta como estimar os pesos w_i a partir de variâncias conhecidas ou estimadas.",
                                    "Derive as equações normais ponderadas para β: (X^T W X) β = X^T W y.",
                                    "Compare graficamente resíduos ponderados vs não ponderados.",
                                    "Implemente MRP em software para os mesmos dados do Step 1."
                                  ],
                                  "verification": "Verifique se a matriz W é diagonal e positiva definida.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software Python (SciPy.optimize ou statsmodels), dados de exemplo em CSV.",
                                  "tips": "Use pesos inversamente proporcionais à variância para priorizar observações precisas.",
                                  "learningObjective": "Dominar a formulação matemática do MRP e sua relação com variâncias heterogêneas.",
                                  "commonMistakes": "Escolher pesos arbitrários sem base em σ_i, invalidando a minimização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar os Critérios de Minimização MQO vs MRP",
                                  "subSteps": [
                                    "Escreva lado a lado as funções objetivo: SSR_MQO vs SSR_MRP.",
                                    "Analise matematicamente por que MRP é superior em heterocedasticidade (menor variância em β).",
                                    "Calcule coeficientes de determinação (R²) ajustado para ambos os métodos.",
                                    "Gere gráficos de resíduos: padronizados no MQO vs ponderados no MRP.",
                                    "Quantifique a diferença em estimativas de parâmetros para dados simulados."
                                  ],
                                  "verification": "Confirme que resíduos ponderados no MRP têm variância constante ≈1.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Gráficos em Matplotlib ou Excel, conjuntos de dados com variâncias conhecidas.",
                                  "tips": "Simule dados com σ_i crescente para visualizar vantagens do MRP.",
                                  "learningObjective": "Identificar diferenças qualitativas e quantitativas nos critérios de minimização.",
                                  "commonMistakes": "Confundir pesos com normalização, aplicando-os incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Melhorias na Estimativa de Parâmetros com MRP",
                                  "subSteps": [
                                    "Compare variâncias assintóticas de β: Var(β_MQO) vs Var(β_MRP) = (X^T W X)^{-1}.",
                                    "Avalie intervalos de confiança mais estreitos no MRP.",
                                    "Teste hipóteses sobre melhor ajuste via F-test ponderado.",
                                    "Discuta cenários onde MQO falha e MRP succeeds (ex: dados de sensores imprecisos).",
                                    "Resuma tabela comparativa: prós, contras e critérios de escolha."
                                  ],
                                  "verification": "Calcule e compare erros padrão de β em ambos os métodos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Tabela comparativa em documento, software para testes estatísticos.",
                                  "tips": "Sempre valide pesos com plot de 1/w_i vs x_i para detectar padrões.",
                                  "learningObjective": "Avaliar impactos práticos do MRP nas estimativas de parâmetros.",
                                  "commonMistakes": "Superestimar melhorias sem dados reais de variância."
                                }
                              ],
                              "practicalExample": "Em um ensaio de compressão de concreto, dados de carga (x) vs deformação (y) têm variâncias crescentes com x (sensores menos precisos em cargas altas). Aplique MQO: β enviesado. MRP com w_i = 1/σ_i^2 (σ_i ∝ x): β mais preciso, R²_adj = 0.92 vs 0.85.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença nas funções objetivo MQO vs MRP.",
                                "Implementar ambos em código e comparar β e Var(β).",
                                "Identificar heterocedasticidade em gráfico de resíduos.",
                                "Escolher corretamente MRP para dados com variâncias desiguais.",
                                "Calcular manualmente pesos para 3 observações.",
                                "Discutir limitação do MQO em contexto de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das equações normais ponderadas (80% correto).",
                                "Correta identificação de heterocedasticidade em dados simulados.",
                                "Comparação quantitativa de R² e erros padrão (diferença <10%).",
                                "Explicação clara de quando usar MRP vs MQO.",
                                "Implementação prática sem erros de código.",
                                "Análise de melhorias em estimativas de parâmetros."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e testes de hipóteses em regressão.",
                                "Programação Numérica: Otimização matricial com NumPy/SciPy.",
                                "Análise de Dados Experimentais: Tratamento de erros em laboratórios.",
                                "Otimização: Métodos de minimização ponderada."
                              ],
                              "realWorldApplication": "Na engenharia civil, ao modelar curvas de degradação de materiais (ex: fadiga em vigas), dados de sensores IoT têm precisões variadas; MRP melhora estimativas de parâmetros para previsão de vida útil, otimizando manutenção preditiva e reduzindo custos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.2",
                        "name": "Formulação Matemática do Método dos Resíduos Ponderados",
                        "description": "Derivação formal das equações do método dos resíduos ponderados, incluindo matriz de pesos e equações normais generalizadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.2.1",
                            "name": "Derivar as equações normais ponderadas",
                            "description": "Obter as equações normais para o modelo y = Xβ + ε, onde os pesos W são diagonais com elementos 1/σ_i², resultando em (X^T W X) β = X^T W y.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o modelo de regressão linear e introduzir os pesos ponderados",
                                  "subSteps": [
                                    "Escreva o modelo linear geral: y = Xβ + ε, onde y é o vetor de observações, X a matriz de design, β os parâmetros e ε o vetor de erros.",
                                    "Defina as variâncias dos erros: Var(ε_i) = σ_i² para cada observação i.",
                                    "Introduza os pesos: w_i = 1/σ_i², formando a matriz diagonal W = diag(w_1, w_2, ..., w_n).",
                                    "Explique conceitualmente por que pesos inversamente proporcionais à variância dão mais importância a observações precisas.",
                                    "Verifique dimensionalidade: y (n×1), X (n×p), β (p×1), W (n×n)."
                                  ],
                                  "verification": "Construa um exemplo simples com n=3, p=2 e escreva explicitamente W como matriz diagonal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Referência de regressão linear (opcional)"
                                  ],
                                  "tips": "Sempre normalize os pesos para que a soma seja 1 se necessário, mas aqui foque em w_i = 1/σ_i².",
                                  "learningObjective": "Compreender a motivação e notação para regressão linear ponderada (WLS).",
                                  "commonMistakes": [
                                    "Confundir w_i com σ_i em vez de 1/σ_i²",
                                    "Esquecer que W é diagonal",
                                    "Ignorar dimensões matriciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a função objetivo dos mínimos quadrados ponderados",
                                  "subSteps": [
                                    "Recorde os mínimos quadrados ordinários (OLS): minimizar ||y - Xβ||² = (y - Xβ)^T (y - Xβ).",
                                    "Generalize para WLS: minimizar S(β) = (y - Xβ)^T W (y - Xβ), onde os resíduos são ponderados.",
                                    "Expanda a expressão: S(β) = y^T W y - 2 β^T X^T W y + β^T X^T W X β.",
                                    "Confirme que S(β) é uma função quadrática convexa em β.",
                                    "Discuta intuitivamente: observações com maior w_i penalizam mais os resíduos."
                                  ],
                                  "verification": "Escreva S(β) para um caso toy com 2 observações e verifique expansão escalar.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Use propriedades de transposta: (AB)^T = B^T A^T para manipular termos.",
                                  "learningObjective": "Derivar e interpretar a soma ponderada dos quadrados dos resíduos em forma matricial.",
                                  "commonMistakes": [
                                    "Esquecer o fator 2 na expansão linear",
                                    "Colocar W fora do quadrático incorretamente",
                                    "Confundir com OLS não ponderado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a derivada da função objetivo em relação a β",
                                  "subSteps": [
                                    "Lembre regras de diferenciação matricial: d/dβ (β^T A β) = 2 A β (se A simétrica), d/dβ (c^T β) = c.",
                                    "Derive termo a termo: dS/dβ = d/dβ [y^T W y] = 0 (constante), d/dβ [-2 β^T X^T W y] = -2 X^T W y, d/dβ [β^T X^T W X β] = 2 X^T W X β.",
                                    "Combine: ∇S(β) = -2 X^T W (y - Xβ).",
                                    "Verifique simetria: X^T W X é simétrica positiva definida (assumindo X cheios de posto).",
                                    "Pratique com escalares para intuíção: para p=1, reduz a derivada escalar."
                                  ],
                                  "verification": "Compute ∇S(β) para β fixo em um exemplo numérico pequeno e confirme numericamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela de derivadas matriciais",
                                    "SymPy ou MATLAB para verificação"
                                  ],
                                  "tips": "Mantenha o sinal negativo em mente: resíduos positivos levam a ajustes negativos.",
                                  "learningObjective": "Aplicar cálculo matricial para derivar o gradiente da função de perda ponderada.",
                                  "commonMistakes": [
                                    "Erros de sinal na derivada linear",
                                    "Fator 2 esquecido ou mal colocado",
                                    "Não usar simetria de X^T W X"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver as equações normais definindo a derivada a zero",
                                  "subSteps": [
                                    "Defina ∇S(β) = 0: -2 X^T W (y - Xβ) = 0 ⇒ X^T W (y - Xβ) = 0.",
                                    "Reorganize: X^T W X β = X^T W y.",
                                    "Interprete: as equações normais ponderadas, análogas às OLS (W=I).",
                                    "Discuta solvabilidade: β_hat = (X^T W X)^{-1} X^T W y se invertível.",
                                    "Conclua ligação com máxima verossimilhança sob erros heteroscedásticos gaussianos."
                                  ],
                                  "verification": "Derive as equações para um caso simples (p=1) e resolva β explicitamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplo numérico pré-preparado"
                                  ],
                                  "tips": "Pense em X^T W (y - Xβ) como condições de ortogonalidade ponderada.",
                                  "learningObjective": "Obter e interpretar as equações normais finais para WLS.",
                                  "commonMistakes": [
                                    "Não cancelar o -2 corretamente",
                                    "Esquecer transposições",
                                    "Confundir com forma OLS"
                                  ]
                                }
                              ],
                              "practicalExample": "Em monitoramento de uma ponte, y contém deformações medidas por sensores com σ_1=0.1 (alta precisão), σ_2=0.5 (baixa). X=[1, x1; 1, x2] para modelo linear. Derive (X^T W X) β = X^T W y com w1=1/0.01=100, w2=1/0.25=4, priorizando o sensor preciso.",
                              "finalVerifications": [
                                "Pode escrever corretamente S(β) = (y - Xβ)^T W (y - Xβ)?",
                                "Derivada ∇S(β) = -2 X^T W (y - Xβ) está precisa?",
                                "Equações normais finais: (X^T W X) β = X^T W y?",
                                "Explica por que W=diag(1/σ_i²)?",
                                "Aplica em um exemplo numérico toy?",
                                "Identifica quando X^T W X é invertível?"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de cada passo (sem erros algébricos).",
                                "Compreensão conceitual: explica pesos e ponderação intuitivamente.",
                                "Uso correto de notação matricial e transposições.",
                                "Capacidade de verificar com exemplos numéricos simples.",
                                "Identificação de erros comuns e precauções.",
                                "Conexão com OLS como caso especial (W=I)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Máxima verossimilhança para erros heteroscedásticos.",
                                "Programação: Implementação em Python (numpy.linalg.solve(X.T @ W @ X, X.T @ W @ y)).",
                                "Física/Engenharia: Modelagem de dados experimentais com incertezas variáveis.",
                                "Otimização: Gradiente descendente ponderado em machine learning."
                              ],
                              "realWorldApplication": "Na engenharia civil, derivação essencial para ajuste ponderado de curvas em dados de topografia ou sensores IoT em estruturas, onde medições têm variâncias distintas (ex.: GPS preciso vs. inclinômetros ruidosos), melhorando previsões de deformações e segurança."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.2",
                            "name": "Construir a matriz de pesos W",
                            "description": "Calcular a matriz diagonal de pesos W a partir das variâncias conhecidas ou estimadas dos dados, aplicando em contextos como medições geotécnicas com erros variáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e coletar variâncias das observações",
                                  "subSteps": [
                                    "Liste todas as observações ou dados disponíveis no conjunto de medições geotécnicas.",
                                    "Para cada observação i, determine a variância conhecida σ_i² a partir de especificações do instrumento ou histórico de dados.",
                                    "Se variâncias não forem conhecidas, estime-as usando métodos como desvio padrão amostral ou análise de repetições de medições.",
                                    "Registre as variâncias em uma tabela ou vetor unidimensional, garantindo unidades consistentes.",
                                    "Verifique se todas as variâncias são positivas e realistas para o contexto."
                                  ],
                                  "verification": "Confirme que há um vetor de variâncias com o mesmo número de elementos que as observações e todos valores > 0.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Dados de medições geotécnicas (ex: resistências de solo)",
                                    "Planilha Excel ou software como Python (NumPy)",
                                    "Tabela de especificações de instrumentos"
                                  ],
                                  "tips": "Priorize variâncias de fontes confiáveis; para estimativas, use pelo menos 5-10 repetições por medição.",
                                  "learningObjective": "Compreender como obter ou estimar variâncias precisas para dados experimentais com erros variáveis.",
                                  "commonMistakes": [
                                    "Usar desvio padrão em vez de variância (lembre: variância = σ²).",
                                    "Ignorar unidades diferentes nas medições.",
                                    "Atribuir variância zero a qualquer observação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os pesos individuais w_i",
                                  "subSteps": [
                                    "Para cada variância var_i, calcule o peso w_i = 1 / var_i.",
                                    "Use uma calculadora ou script para computar todos os w_i simultaneamente.",
                                    "Arredonde os pesos para um número razoável de casas decimais (ex: 4-6) para evitar erros numéricos.",
                                    "Armazene os w_i em um vetor coluna ou linha.",
                                    "Confirme que todos w_i são positivos e inversamente proporcionais às variâncias."
                                  ],
                                  "verification": "Verifique se w_i aumenta quando var_i diminui, e some os w_i para um valor total esperado.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Calculadora científica ou Python/MATLAB com NumPy",
                                    "Vetor de variâncias do Step 1"
                                  ],
                                  "tips": "Implemente em código para grandes conjuntos: w = 1 / np.diag(var).",
                                  "learningObjective": "Dominar o cálculo dos pesos como inverso das variâncias para ponderação.",
                                  "commonMistakes": [
                                    "Calcular w_i = 1 / σ_i em vez de 1 / σ_i².",
                                    "Arredondar excessivamente, perdendo precisão.",
                                    "Confundir pesos com probabilidades (não normalizar aqui)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e validar a matriz diagonal W",
                                  "subSteps": [
                                    "Crie uma matriz quadrada n x n (n = número de observações) inicializada com zeros.",
                                    "Preencha a diagonal principal com os w_i calculados: W_{ii} = w_i.",
                                    "Confirme que elementos fora da diagonal são zero.",
                                    "Salve a matriz em formato legível (ex: LaTeX, CSV ou array NumPy).",
                                    "Valide propriedades: diagonal, simétrica, definida positiva (autovalores >0)."
                                  ],
                                  "verification": "Multiplique W por um vetor teste; resultado deve escalar apenas componentes diagonais.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Software de álgebra linear (MATLAB, Python NumPy/SciPy, ou Excel)",
                                    "Vetor de pesos do Step 2"
                                  ],
                                  "tips": "Em Python: W = np.diag(1 / variances); sempre teste com np.linalg.eigvals(W) > 0.",
                                  "learningObjective": "Construir matriz diagonal de pesos e verificar suas propriedades matemáticas.",
                                  "commonMistakes": [
                                    "Colocar pesos fora da diagonal.",
                                    "Usar matriz identidade em vez de ponderada.",
                                    "Não verificar definitude positiva."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e otimizar a matriz W no contexto do método",
                                  "subSteps": [
                                    "Integre W preliminarmente no modelo de resíduos ponderados: minimize (resíduos)^T W (resíduos).",
                                    "Teste sensibilidade alterando variâncias em ±10% e observe impacto nos pesos.",
                                    "Ajuste variâncias se necessário com base em diagnósticos (ex: resíduos padronizados).",
                                    "Documente a matriz final com justificativas para cada w_i.",
                                    "Prepare para uso em software de ajuste de curvas."
                                  ],
                                  "verification": "Simule ajuste com W e sem; ponderado deve dar menor soma de resíduos quadrados ponderados.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Software de otimização (SciPy optimize, MATLAB lsqnonlin)",
                                    "Dados completos do problema"
                                  ],
                                  "tips": "Sempre normalize resíduos com W para diagnóstico: |r_i * sqrt(w_i)| < 2-3.",
                                  "learningObjective": "Aplicar e validar W em contexto real de minimização ponderada.",
                                  "commonMistakes": [
                                    "Não testar sensibilidade a variâncias incertas.",
                                    "Esquecer documentação das fontes de variâncias.",
                                    "Usar W em modelos não lineares sem linearização."
                                  ]
                                }
                              ],
                              "practicalExample": "Em medições geotécnicas de resistência ao cisalhamento de solo: 4 amostras com variâncias 0.01, 0.04, 0.0025, 0.09 (MPa²). Pesos: 100, 25, 400, 11.11. Matriz W = diag(100, 25, 400, 11.11). Usada para ajustar curva tensão-deformação ponderada por precisão das medições.",
                              "finalVerifications": [
                                "Matriz W é diagonal com n elementos na diagonal.",
                                "Todos w_ii > 0 e trace(W) = soma(w_i).",
                                "W é simétrica e definida positiva (autovalores positivos).",
                                "Pesos inversamente proporcionais às variâncias originais.",
                                "Integração teste: resíduos ponderados têm variância unitária.",
                                "Documentação completa de fontes de variâncias."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos de w_i (erro < 1e-6).",
                                "Correta construção da matriz diagonal sem off-diagonais.",
                                "Validação de propriedades matriciais (definitude positiva).",
                                "Justificativa adequada para variâncias estimadas.",
                                "Aplicação correta em simulação de ajuste de curvas.",
                                "Clareza na documentação e exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Estimação de variâncias e testes de hipóteses.",
                                "Álgebra Linear: Propriedades de matrizes diagonais e autovalores.",
                                "Programação Computacional: Implementação em NumPy/MATLAB para grandes dados.",
                                "Engenharia de Medições: Análise de incertezas em sensores geotécnicos."
                              ],
                              "realWorldApplication": "Em projetos de fundações civis, constrói W para dados de sondagens CPT com variâncias variáveis por profundidade, permitindo ajuste preciso de perfis de resistência de solo e previsão segura de capacidade de carga, reduzindo riscos de colapso."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.3",
                            "name": "Avaliar condicionamento da matriz X^T W X",
                            "description": "Analisar o condicionamento numérico da matriz de Gram ponderada X^T W X, relacionando com autovalores para garantir estabilidade na solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Condicionamento Numérico de Matrizes",
                                  "subSteps": [
                                    "Definir o número de condicionamento κ(A) = ||A|| * ||A⁻¹|| para uma matriz A.",
                                    "Explicar que para matrizes simétricas positivas definidas (SPD), κ(A) ≈ λ_max / λ_min, onde λ são autovalores.",
                                    "Discutir impactos de alto condicionamento: amplificação de erros de arredondamento na solução de sistemas lineares.",
                                    "Relacionar com estabilidade em métodos de ajuste como mínimos quadrados ponderados.",
                                    "Estudar exemplos simples de matrizes 2x2 bem e mal condicionadas."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a relação entre autovalores e condicionamento, com um exemplo numérico simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Álgebra Numérica (ex: Golub & Van Loan)",
                                    "Notebook com Python/NumPy ou MATLAB"
                                  ],
                                  "tips": "Foquem em matrizes SPD comuns em métodos dos resíduos ponderados, onde X^T W X é SPD se W for diagonal positiva.",
                                  "learningObjective": "Dominar a definição e implicações do condicionamento numérico em contextos de otimização.",
                                  "commonMistakes": [
                                    "Confundir condicionamento com determinantes ou traço da matriz.",
                                    "Ignorar que κ ≥ 1 sempre, com κ=1 para matrizes bem escalonadas.",
                                    "Não considerar propriedades SPD da matriz."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Matriz de Gram Ponderada X^T W X",
                                  "subSteps": [
                                    "Coletar dados: matriz X (n x p) com funções base e variáveis independentes, vetor de pesos W (diagonal n x n com w_i > 0).",
                                    "Verificar dimensionalidade: X^T W X resulta em p x p.",
                                    "Implementar multiplicação matricial: calcular W X primeiro, depois X^T (W X).",
                                    "Confirmar propriedades: simétrica (X^T W X = (X^T W X)^T) e positiva definida (se rank(X)=p e W positiva).",
                                    "Testar com dados sintéticos pequenos (ex: n=5, p=2)."
                                  ],
                                  "verification": "Gerar X^T W X corretamente e verificar simetria comparando A == A.T.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software NumPy/Python ou MATLAB",
                                    "Dados de exemplo de ajuste de curvas (planilha Excel)"
                                  ],
                                  "tips": "Use broadcasting no NumPy para eficiência; normalize colunas de X para melhorar condicionamento inicial.",
                                  "learningObjective": "Construir e validar a matriz de Gram ponderada a partir de dados reais.",
                                  "commonMistakes": [
                                    "Erro na ordem de multiplicação (WX vs XW).",
                                    "Pesos w_i negativos ou zero.",
                                    "Não verificar rank de X antes."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Autovalores da Matriz X^T W X",
                                  "subSteps": [
                                    "Implementar decomposição espectral: eigvals = np.linalg.eigvals(A) ou [V,D] = eig(A).",
                                    "Ordenar autovalores: λ_max e λ_min (absolutos para SPD).",
                                    "Verificar positivos: todos λ > 0 para PD; tolerância numérica ~1e-10.",
                                    "Analisar espectro: plotar autovalores para visualizar gap entre max e min.",
                                    "Comparar com trace(A) = sum(λ_i) para validação."
                                  ],
                                  "verification": "Autovalores somam ao traço da matriz e produto ao determinante (até precisão numérica).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca NumPy/SciPy ou MATLAB Eigenvalue Toolbox",
                                    "Gráficos via Matplotlib"
                                  ],
                                  "tips": "Para matrizes grandes, use eigsh() para autovalores extremos apenas.",
                                  "learningObjective": "Computar e interpretar o espectro de autovalores de X^T W X.",
                                  "commonMistakes": [
                                    "Usar eig() em vez de eigh() para simétricas (perda de precisão).",
                                    "Não ordenar λ.",
                                    "Ignorar autovalores próximos de zero indicando singularidade."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Interpretar o Número de Condicionamento",
                                  "subSteps": [
                                    "Calcular κ = λ_max / λ_min.",
                                    "Classificar: bem condicionado (κ < 10^3), moderado (10^3-10^6), mal (κ > 10^6).",
                                    "Relacionar com erro relativo na solução: ||δx|| / ||x|| ≤ κ * ||δb|| / ||b||.",
                                    "Testar regularização: adicionar αI à diagonal e reavaliar κ.",
                                    "Documentar thresholds para estabilidade em Engenharia Civil."
                                  ],
                                  "verification": "Interpretar κ em um relatório curto: 'Matriz mal condicionada, risco de instabilidade'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python/MATLAB com funções eig",
                                    "Referências de thresholds numéricos"
                                  ],
                                  "tips": "Log10(κ) para escalas intuitivas; monitore em iterações de otimização.",
                                  "learningObjective": "Quantificar e interpretar condicionamento para decisões de modelagem.",
                                  "commonMistakes": [
                                    "Dividir por λ_max em vez de λ_min.",
                                    "Usar norma 2 sem relação explícita com autovalores.",
                                    "Não considerar ruído nos dados afetando W."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Relacionar Condicionamento com Estabilidade da Solução",
                                  "subSteps": [
                                    "Resolver sistema (X^T W X) β = X^T W y para parâmetros β.",
                                    "Simular erros: adicionar ruído a y e observar variação em β.",
                                    "Comparar com métodos alternativos (ex: ridge regression para melhorar κ).",
                                    "Avaliar em contexto: resíduos, R², previsões em dados de engenharia.",
                                    "Recomendar ações: recolher mais dados, mudar funções base se κ alto."
                                  ],
                                  "verification": "Demonstrar numericamente que alto κ amplifica erros em β.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dados reais de Engenharia Civil (ex: deformações em vigas)",
                                    "Solver np.linalg.solve()"
                                  ],
                                  "tips": "Use cond(A) built-in no NumPy para validação rápida.",
                                  "learningObjective": "Conectar condicionamento à robustez prática de soluções de ajuste.",
                                  "commonMistakes": [
                                    "Não simular erros de entrada.",
                                    "Ignorar multicolinearidade em colunas de X.",
                                    "Concluir estabilidade sem testes empíricos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de deformações em uma viga de concreto (n=20 medições), X=[1, x, x²] para polinômio quadrático, W=diag(1/σ_i²) com variâncias de sensores. Calcule X^T W X (3x3), autovalores [1e-4, 1e2, 1e5], κ=1e9 → mal condicionado devido a multicolinearidade em x altos; sugira centrar x.",
                              "finalVerifications": [
                                "Calcular corretamente κ a partir de autovalores para matriz exemplo.",
                                "Classificar condicionamento e justificar threshold.",
                                "Simular impacto de ruído em solução β.",
                                "Propor mitigação (ex: regularização) para κ alto.",
                                "Relacionar com estabilidade em ajuste de curvas reais.",
                                "Verificar propriedades SPD de X^T W X."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos de autovalores e κ (erro <1e-10).",
                                "Interpretação correta de impactos na estabilidade.",
                                "Uso apropriado de ferramentas computacionais.",
                                "Identificação de erros comuns e mitigação.",
                                "Aplicação contextual a problemas de Engenharia Civil.",
                                "Clareza em relatórios e visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição espectral e normas matriciais.",
                                "Programação Numérica: Implementação eficiente de eigendecomposição.",
                                "Estatística: Pesos em regressão e multicolinearidade.",
                                "Otimização: Regularização em mínimos quadrados.",
                                "Engenharia Computacional: Análise de elementos finitos."
                              ],
                              "realWorldApplication": "Na simulação de estruturas civis, avaliar condicionamento de X^T W X garante soluções estáveis para previsão de deformações sob carga, evitando falhas em projetos de pontes ou edifícios devido a erros numéricos amplificados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.3",
                        "name": "Implementação Computacional e Aplicação",
                        "description": "Aplicação prática do método em software numérico para ajuste de curvas em problemas de engenharia civil, incluindo validação.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.3.1",
                            "name": "Resolver o sistema linear ponderado",
                            "description": "Implementar a solução β = (X^T W X)^{-1} X^T W y usando decomposição QR ou Cholesky para eficiência e precisão numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados de entrada: Matrizes X, y e W",
                                  "subSteps": [
                                    "Colete os dados observados y e a matriz de design X para o problema de ajuste de curvas ponderado.",
                                    "Defina a matriz diagonal de pesos W baseada na incerteza de cada observação (ex: W_ii = 1/σ_i²).",
                                    "Verifique dimensões: X (n x p), y (n x 1), W (n x n) diagonal.",
                                    "Normalize ou escale os dados se necessário para estabilidade numérica.",
                                    "Implemente em código: Crie arrays numpy para X, y, W."
                                  ],
                                  "verification": "Execute código para imprimir shapes e valores amostrais de X, y, W; confirme W é diagonal positiva.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Python com NumPy",
                                    "Jupyter Notebook",
                                    "Dados de exemplo de deformação em vigas"
                                  ],
                                  "tips": "Use np.diag para criar W rapidamente; visualize com plt.imshow(W) para confirmar diagonal.",
                                  "learningObjective": "Compreender o papel de X, y e W no sistema linear ponderado.",
                                  "commonMistakes": [
                                    "Esquecer de tornar W diagonal",
                                    "Usar pesos incorretos (ex: σ_i em vez de 1/σ_i²)",
                                    "Dimensões incompatíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar as matrizes A = X^T W X e b = X^T W y",
                                  "subSteps": [
                                    "Calcule W_y = W @ y usando multiplicação matricial.",
                                    "Calcule b = X.T @ W_y.",
                                    "Calcule X_W = X.T @ W.",
                                    "Calcule A = X_W @ X.",
                                    "Verifique se A é simétrica positiva definida (spd) com np.allclose(A, A.T) e eigenvalues positivos."
                                  ],
                                  "verification": "Imprima A e b; confirme A simétrica e cond(A) < 1e12 para condicionamento razoável.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "NumPy",
                                    "SciPy para eigenvalues (opcional)",
                                    "Notebook com dados do Step 1"
                                  ],
                                  "tips": "Evite loops; use operações vetoriais para eficiência. Salve A e b em variáveis.",
                                  "learningObjective": "Dominar o pré-processamento matricial para o sistema normal ponderado.",
                                  "commonMistakes": [
                                    "Erro na ordem de multiplicação (X^T W X vs X W X)",
                                    "Não transpor X corretamente",
                                    "Ignorar verificação de simetria"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar decomposição Cholesky para resolver A β = b",
                                  "subSteps": [
                                    "Confirme A spd com teste de Cholesky trial.",
                                    "Use scipy.linalg.cho_solve ou implemente manualmente: L = cholesky(A), solve Ly = b, L^T β = y.",
                                    "Alternativa QR: Q, R = qr(A), β = solve(R.T @ R, R.T @ Q.T @ b) mas prefira Cholesky para spd.",
                                    "Capture warnings de não-spd e fallback para QR.",
                                    "Obtenha β = cho_solve((L, lower=True), b)."
                                  ],
                                  "verification": "Compare solução com np.linalg.solve(A, b); erro relativo < 1e-10.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "SciPy.linalg",
                                    "NumPy",
                                    "Documentação SciPy Cholesky"
                                  ],
                                  "tips": "Sempre verifique spd antes; Cholesky é 2x mais rápida que QR para spd.",
                                  "learningObjective": "Aplicar decomposições numéricas estáveis para sistemas lineares spd.",
                                  "commonMistakes": [
                                    "Usar Cholesky em matriz não-spd (causa NaN)",
                                    "Confundir lower/upper triangular",
                                    "Ignorar condicionamento alto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a solução e computar resíduos ponderados",
                                  "subSteps": [
                                    "Calcule y_pred = X @ β.",
                                    "Resíduos: r = y - y_pred; resíduos ponderados: sqrt(W) @ r.",
                                    "Compute R² ponderado ou soma quadrados mínimos.",
                                    "Teste com dados sintéticos: gere y = X β_true + noise, confira β ≈ β_true.",
                                    "Analise sensibilidade variando W."
                                  ],
                                  "verification": "Resíduos ponderados ~ N(0,1); β converge para verdadeiros parâmetros.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Matplotlib para plots de resíduos",
                                    "SciPy.stats para testes",
                                    "Dados sintéticos gerados"
                                  ],
                                  "tips": "Plot Q-Q plot de resíduos para normalidade; use seed para reprodutibilidade.",
                                  "learningObjective": "Avaliar precisão e robustez da solução numérica.",
                                  "commonMistakes": [
                                    "Não ponderar resíduos na validação",
                                    "Overfitting sem cross-validation",
                                    "Ignorar outliers em W"
                                  ]
                                }
                              ],
                              "practicalExample": "Em engenharia civil, ajuste uma curva de deformação δ = β0 + β1 L + β2 L² para dados de uma viga com pesos inversos à variância medida por strain gauges. Use X = [1, L, L²], y = δ_obs, W = diag(1/σ_δ²). Implemente para prever deformação em L=10m.",
                              "finalVerifications": [
                                "Solução β coincide com np.linalg.solve dentro de 1e-12.",
                                "Decomposição Cholesky succeeds sem warnings.",
                                "Resíduos ponderados têm média zero e variância ~1.",
                                "Solução estável para perturbações pequenas em dados.",
                                "Tempo de execução < 1ms para n=1000.",
                                "Código modular e comentado roda em ambiente limpo."
                              ],
                              "assessmentCriteria": [
                                "Correção numérica: erro relativo < 1e-10.",
                                "Eficiência: usa Cholesky/QR em vez de solve genérico.",
                                "Robustez: trata casos não-spd com fallback.",
                                "Validação completa: inclui testes sintéticos e plots.",
                                "Clareza de código: funções separadas, docstrings.",
                                "Documentação: explica escolhas de decomposição."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: estimação por Mínimos Quadrados Ponderados (MLE).",
                                "Programação: Otimização numérica com SciPy/NumPy.",
                                "Álgebra Linear: Propriedades de matrizes spd e decomposições.",
                                "Engenharia de Software: Testes unitários para funções numéricas.",
                                "Física/Mecânica: Modelagem de deformações em estruturas."
                              ],
                              "realWorldApplication": "Na engenharia civil, resolve regressões ponderadas para calibração de sensores em monitoramento estrutural (ex: pontes), onde medições têm variâncias diferentes devido a ruído ambiental, garantindo previsões precisas de fadiga e segurança."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.2",
                            "name": "Implementar em MATLAB ou Python",
                            "description": "Codificar o algoritmo MRP em MATLAB (usando mldivide com pesos) ou Python (numpy.linalg.solve), testando com dados simulados de deformação em estruturas civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e preparar dados simulados",
                                  "subSteps": [
                                    "Instale bibliotecas necessárias: NumPy e Matplotlib para Python, ou MATLAB base.",
                                    "Gere dados simulados de deformação: defina pontos x (ex: [0, 0.25, 0.5, 0.75, 1]), deformações δ verdadeiras baseadas em modelo teórico (ex: viga cantilever δ = (P L^3)/(3EI) * funções), adicione ruído gaussiano.",
                                    "Defina pesos w_i baseados em precisão do sensor (ex: w_i = 1/σ_i² onde σ_i é desvio padrão do sensor).",
                                    "Escolha grau do polinômio de aproximação (ex: n=2 para quadrático)."
                                  ],
                                  "verification": "Dados gerados e pesos calculados; execute print/disp para visualizar arrays x, y_obs, weights.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Python: NumPy, Matplotlib",
                                    "MATLAB: Editor",
                                    "Documentação NumPy.linalg e MATLAB mldivide"
                                  ],
                                  "tips": "Use np.random.normal para ruído realista; normalize x para [0,1] se necessário.",
                                  "learningObjective": "Preparar dataset realista simulando medições experimentais em estruturas civis.",
                                  "commonMistakes": [
                                    "Esquecer de adicionar ruído aos dados verdadeiros",
                                    "Pesos iguais para todos pontos (ignora variância)",
                                    "Escala inconsistente em x e y"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir base de funções e calcular resíduos iniciais",
                                  "subSteps": [
                                    "Escolha funções base φ_j(x) (ex: polinômios 1, x, x²).",
                                    "Calcule matriz A onde A_ij = w_i^{1/2} * φ_j(x_i).",
                                    "Defina vetor b onde b_j = sum(w_i^{1/2} * y_i * φ_j(x_i)).",
                                    "Implemente função para resíduos r_i = y_i - sum(c_j φ_j(x_i)) (inicialmente sem coeficientes)."
                                  ],
                                  "verification": "Matriz A e vetor b têm dimensões corretas (m x n onde m=pontos, n=grau+1); verifique com np.shape ou size().",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Código Python/MATLAB iniciado",
                                    "Referência teórica MRP"
                                  ],
                                  "tips": "Use np.meshgrid ou loops vetorizados para eficiência; teste com dados sem ruído primeiro.",
                                  "learningObjective": "Construir formulação matricial do MRP para minimização de resíduos ponderados.",
                                  "commonMistakes": [
                                    "Confundir pesos w_i com sqrt(w_i)",
                                    "Índices errados em loops (off-by-one)",
                                    "Funções base não normalizadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o sistema linear para coeficientes",
                                  "subSteps": [
                                    "Em Python: use numpy.linalg.solve(A, b) para c = solve(A,b).",
                                    "Em MATLAB: use c = A \\ b (mldivide com pesos já incorporados).",
                                    "Capture resíduos ponderados: r_pond = sqrt(w) * (y - phi @ c).",
                                    "Calcule métricas iniciais: soma quadrados resíduos ponderados SSR = r_pond.T @ r_pond."
                                  ],
                                  "verification": "Sistema resolve sem singular warning; coeficientes c têm valores razoáveis (ex: ordem de magnitude similar a y).",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Documentação numpy.linalg.solve",
                                    "MATLAB mldivide help"
                                  ],
                                  "tips": "Verifique cond(A) < 1e10 para estabilidade; use lsqr se mal-condicionado.",
                                  "learningObjective": "Aplicar solvers lineares para estimar coeficientes otimizados no MRP.",
                                  "commonMistakes": [
                                    "Usar inv(A) em vez de solve (numéricamente instável)",
                                    "Esquecer sqrt(w) na matriz A",
                                    "Resolver sem pesos (MRP vira MQ)"
                                  ]
                                },
                                {
                                  "stepNumber": "4",
                                  "title": "Avaliar ajuste e visualizar resultados",
                                  "subSteps": [
                                    "Calcule y_ajust = phi @ c onde phi é matriz de funções base em x.",
                                    "Plote: x vs y_obs (scatter), x vs y_ajust (linha), resíduos vs x.",
                                    "Compute R² ponderado: 1 - SSR / SST onde SST = sum(w*(y-mean(y))^2).",
                                    "Compare com ajuste não-ponderado para validar pesos."
                                  ],
                                  "verification": "Gráficos mostram ajuste suave; R² > 0.95 para dados simulados; resíduos aleatórios (não patterned).",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Matplotlib.pyplot ou MATLAB plot",
                                    "Funções np.polyval equivalente"
                                  ],
                                  "tips": "Use subplot(2,1) para ajuste e resíduos; adicione legendas e labels com unidades (mm para deformação).",
                                  "learningObjective": "Interpretar qualidade do ajuste via visualização e métricas no contexto de engenharia civil.",
                                  "commonMistakes": [
                                    "Eixo y invertido em resíduos",
                                    "R² não-ponderado (subestima pesos)",
                                    "Plot sem zoom em regiões críticas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar robustez e documentar implementação",
                                  "subSteps": [
                                    "Varie ruído e pesos; rode 10 simulações e compute média R².",
                                    "Teste com dados reais simulados de viga (ex: carga distribuída).",
                                    "Adicione comentários no código e função reutilizável def mrp_fit(x,y,w,phi_degree).",
                                    "Salve resultados em arquivo .csv ou .mat."
                                  ],
                                  "verification": "Média R² > 0.92 em testes; código roda em <1s para 100 pontos; função testada com dados novos.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Jupyter Notebook ou MATLAB Live Script para documentação"
                                  ],
                                  "tips": "Use assert para testes unitários; versione com Git.",
                                  "learningObjective": "Garantir robustez da implementação para aplicações em SHM estrutural.",
                                  "commonMistakes": [
                                    "Testes só com dados ideais",
                                    "Falta de modularidade (código colado)",
                                    "Ignorar overflow em grandes datasets"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule deformações em viga cantilever de 1m, E=200GPa, I=1e-4m⁴, P=1kN: x=[0,0.2,0.4,0.6,0.8,1.0], δ_true = [0, 0.0167*x.^2 .* (3-2*x)], adicione ruído σ=[0.001,0.002,0.001,0.003,0.002,0.001], w=1/σ². Ajuste polinômio quadrático; espere c ≈ [0, 0.0334, -0.0167].",
                              "finalVerifications": [
                                "Código executa sem erros em Python e MATLAB.",
                                "Coeficientes recuperam δ_true com erro <5%.",
                                "Gráficos mostram resíduos ponderados < 2σ.",
                                "R² ponderado > 0.95 em dados ruidosos.",
                                "Função mrp_fit funciona com novos dados.",
                                "Documentação inclui exemplo reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Correta incorporação de pesos na matriz A (verificação numérica).",
                                "Estabilidade numérica: cond(A) < 1e12.",
                                "Qualidade ajuste: SSR mínimo vs não-ponderado.",
                                "Visualizações claras com métricas anotadas.",
                                "Robustez: performance em 5 datasets variados.",
                                "Código limpo, comentado e modular."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Solução de sistemas Ax=b.",
                                "Estatística: Minimização de resíduos ponderados (regressão weighted).",
                                "Programação: Vetorização NumPy/MATLAB.",
                                "Engenharia Estrutural: Modelos de deformação em vigas.",
                                "Visualização de Dados: Plots para validação experimental."
                              ],
                              "realWorldApplication": "No monitoramento de saúde estrutural (SHM) de pontes e edifícios, sensores MEMS medem deformações com variâncias diferentes; MRP ajusta modelos preditivos ponderados para detectar danos precocemente, otimizando manutenção preditiva."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.3",
                            "name": "Validar o ajuste com métricas ponderadas",
                            "description": "Calcular resíduos ponderados padronizados, R² ponderado e intervalos de confiança para avaliar a qualidade do ajuste em dados reais de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados e calcular resíduos ponderados",
                                  "subSteps": [
                                    "Carregue o conjunto de dados reais de engenharia civil (ex: carga vs. deformação em viga) usando pandas ou numpy.",
                                    "Defina os pesos (w_i) baseados na variância inversa dos dados experimentais.",
                                    "Ajuste o modelo ponderado usando scipy.optimize.curve_fit com pesos.",
                                    "Calcule resíduos ponderados: r_i * sqrt(w_i), onde r_i = y_i - y_pred_i."
                                  ],
                                  "verification": "Verifique se os resíduos ponderados foram computados corretamente comparando com cálculo manual para os primeiros 5 pontos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com numpy, scipy, pandas; conjunto de dados CSV de testes estruturais.",
                                  "tips": "Use np.sqrt(weights) no curve_fit para normalização automática.",
                                  "learningObjective": "Compreender e implementar cálculo de resíduos em regressão ponderada.",
                                  "commonMistakes": "Esquecer de multiplicar resíduos pelos pesos; usar pesos não normalizados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Padronizar os resíduos ponderados",
                                  "subSteps": [
                                    "Calcule o desvio padrão dos resíduos ponderados: sigma = sqrt(sum(w_i * r_i^2) / (n - p)).",
                                    "Padronize: z_i = (r_i * sqrt(w_i)) / sigma.",
                                    "Gere histograma ou Q-Q plot dos z_i para visualização.",
                                    "Verifique normalidade com teste Shapiro-Wilk.",
                                    "Identifique outliers onde |z_i| > 2.5."
                                  ],
                                  "verification": "Os resíduos padronizados devem ter média próxima de 0 e variância ~1; confirme com np.mean e np.var.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com scipy.stats, matplotlib para plots.",
                                  "tips": "Salve sigma para uso posterior em intervalos de confiança.",
                                  "learningObjective": "Padronizar resíduos para análise estatística independente de escala.",
                                  "commonMistakes": "Dividir por desvio padrão não ponderado; ignorar graus de liberdade (n-p)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular R² ponderado",
                                  "subSteps": [
                                    "Calcule SST_ponderado = sum(w_i * (y_i - y_mean_ponderado)^2), onde y_mean_ponderado = sum(w_i * y_i)/sum(w_i).",
                                    "Calcule SSR_ponderado = sum(w_i * r_i^2).",
                                    "R²_ponderado = 1 - SSR_ponderado / SST_ponderado.",
                                    "Compare com R² não ponderado para validar melhoria."
                                  ],
                                  "verification": "R² deve estar entre 0 e 1; teste com dados sintéticos onde R²=1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com numpy para somas ponderadas.",
                                  "tips": "Implemente função customizada para evitar bibliotecas que não suportam pesos.",
                                  "learningObjective": "Medir proporção de variância explicada em regressões ponderadas.",
                                  "commonMistakes": "Usar média aritmética simples em vez de ponderada para y_mean."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular intervalos de confiança e avaliar ajuste",
                                  "subSteps": [
                                    "Use covariância da matrix de curve_fit para IC dos parâmetros: param ± 1.96 * sqrt(cov_diag) * sigma.",
                                    "Calcule IC de predições: y_pred ± t * sigma * sqrt(1/w_i + distancia杠杆).",
                                    "Plote resíduos vs. predições e IC para inspeção visual.",
                                    "Defina critérios: R² > 0.9, 95% resíduos |z| < 2, IC estreitos.",
                                    "Documente relatório com métricas e plots."
                                  ],
                                  "verification": "IC não se sobrepõem a zero para parâmetros significativos; resíduos aleatórios no plot.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com scipy.stats para t-distribution, matplotlib/seaborn para plots.",
                                  "tips": "Ajuste alpha=0.05 para 95% IC; use degrees of freedom corretos.",
                                  "learningObjective": "Integrar métricas para validação robusta de modelos em dados reais.",
                                  "commonMistakes": "Ignorar correlação entre resíduos; usar z em vez de t para amostras pequenas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e validar qualidade geral do ajuste",
                                  "subSteps": [
                                    "Compare métricas com benchmarks de literatura em engenharia civil.",
                                    "Realize teste F ponderado para significância global.",
                                    "Simule cenários de falha (ex: remover outlier) e reavalie.",
                                    "Conclua se o modelo é adequado para predição em projeto real."
                                  ],
                                  "verification": "Relatório escrito confirmando aceitação/rejeição do modelo com justificativa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Jupyter notebook para documentação; referências bibliográficas.",
                                  "tips": "Salve todos os plots em PDF para relatório.",
                                  "learningObjective": "Interpretar métricas holisticamente para decisões de engenharia.",
                                  "commonMistakes": "Aceitar R² alto ignorando resíduos sistemáticos."
                                }
                              ],
                              "practicalExample": "Em testes de compressão de pilares de concreto (dados: carga aplicada em kN vs. deformação em mm, n=20 pontos com pesos baseados em duplicatas experimentais), calcule resíduos padronizados médios |z|<1.8, R²_ponderado=0.95 e IC de 95% para coeficiente de rigidez entre 150-170 kN/mm, validando o modelo para dimensionamento estrutural.",
                              "finalVerifications": [
                                "Resíduos padronizados têm distribuição normal (p-value Shapiro >0.05).",
                                "R² ponderado > 0.90 para dados de engenharia civil.",
                                "95% dos |z_i| < 2.0, sem padrões nos plots de resíduos.",
                                "Intervalos de confiança dos parâmetros não incluem zero.",
                                "Predições dentro de IC observadas em dados de validação.",
                                "Teste F indica significância global (p<0.01)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica das métricas (erro <1% vs. analítico).",
                                "Qualidade visual dos plots (resíduos aleatórios, sem heterocedasticidade).",
                                "Correta implementação de pesos em todas as fórmulas.",
                                "Interpretação física das métricas no contexto civil.",
                                "Relatório completo com código reproduzível e conclusões.",
                                "Eficiência computacional (tempo <2s para n=100)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de normalidade e inferência.",
                                "Programação: Otimização numérica com scipy.",
                                "Engenharia Mecânica: Modelagem constitutiva de materiais.",
                                "Análise de Dados: Validação de modelos preditivos.",
                                "Qualidade e Confiabilidade: Controle de processos experimentais."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios, validar modelos de ajuste ponderado garante predições seguras de deformações sob carga, otimizando dimensionamento, reduzindo custos e evitando falhas estruturais como no caso de colapsos por subestimação de variância experimental."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.4",
                            "name": "Aplicar em problema de engenharia civil",
                            "description": "Usar MRP para ajustar curvas de regressão em dados de ensaios de solos ou cargas estruturais com variâncias desiguais, interpretando resultados físicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e analisar o conjunto de dados experimentais",
                                  "subSteps": [
                                    "Coletar dados de ensaios de solos (ex.: resistência ao cisalhamento vs. tensão normal) ou cargas estruturais, registrando valores observados e estimativas de variância para cada ponto.",
                                    "Calcular variâncias iniciais usando desvio padrão amostral ou dados de repetições de ensaios.",
                                    "Visualizar dados com gráficos de dispersão, destacando heteroscedasticidade (variâncias desiguais).",
                                    "Identificar outliers e decidir sobre remoção ou tratamento.",
                                    "Normalizar ou transformar dados se necessário para linearidade aproximada."
                                  ],
                                  "verification": "Gráfico de dispersão com barras de erro mostrando variâncias desiguais e relatório inicial de estatísticas descritivas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Planilha Excel ou Python (pandas, matplotlib), dados reais de ensaios de solos/cargas.",
                                  "tips": "Use log-transformação para variâncias multiplicativas comuns em solos.",
                                  "learningObjective": "Identificar heteroscedasticidade e preparar dados para ponderação.",
                                  "commonMistakes": "Ignorar variâncias desiguais, assumindo homoscedasticidade; não documentar fontes de dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o modelo matemático do MRP",
                                  "subSteps": [
                                    "Definir o modelo de regressão: y = f(x, β) + ε, onde pesos w_i = 1/σ_i².",
                                    "Escolher forma funcional (linear, polinomial, exponencial) baseada em conhecimento físico (ex.: lei de Mohr-Coulomb para solos).",
                                    "Codificar função de minimização de soma ponderada de quadrados: min Σ w_i (y_i - f(x_i))^2.",
                                    "Implementar em software: usar scipy.optimize.curve_fit com sigma para pesos em Python.",
                                    "Testar com dados sintéticos para validar implementação."
                                  ],
                                  "verification": "Código funcional que ajusta dados sintéticos com variâncias conhecidas, reproduzindo parâmetros verdadeiros.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python (numpy, scipy, matplotlib) ou MATLAB/R, editor de código (Jupyter Notebook).",
                                  "tips": "Inverta variâncias corretamente: pesos altos para pontos precisos.",
                                  "learningObjective": "Formular e codificar o problema de otimização ponderada.",
                                  "commonMistakes": "Confundir pesos com variâncias; usar OLS padrão em vez de WLS."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular pesos e ajustar a curva de regressão",
                                  "subSteps": [
                                    "Estimar variâncias σ_i² para cada ponto usando repetições ou modelo bootstrapped.",
                                    "Computar matriz de pesos diagonal W.",
                                    "Executar ajuste: obter parâmetros β, covariância e intervalos de confiança.",
                                    "Plotar curva ajustada, resíduos ponderados e Q-Q plot para normalidade.",
                                    "Comparar com ajuste não-ponderado para demonstrar melhoria."
                                  ],
                                  "verification": "Gráficos de ajuste com R² ponderado > 0.9 e resíduos aleatórios (sem padrões).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Mesmo ambiente de programação do step 2, dados preparados.",
                                  "tips": "Use pesos estabilizados (ex.: w_i = 1/(σ_i² + ε)) para evitar singularidades.",
                                  "learningObjective": "Aplicar ponderação para minimizar impacto de variâncias altas.",
                                  "commonMistakes": "Pesos zero ou infinitos; não escalar variáveis independentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e validar fisicamente",
                                  "subSteps": [
                                    "Analisar parâmetros β em contexto físico (ex.: ângulo de atrito φ de solos).",
                                    "Verificar resíduos ponderados: média zero, variância unitária, sem autocorrelação.",
                                    "Realizar testes de significância (t-test em β, F-test global).",
                                    "Simular cenários de engenharia: prever falha em fundação baseada na curva.",
                                    "Documentar relatório com conclusões e limitações."
                                  ],
                                  "verification": "Relatório com interpretação física coerente e testes estatísticos aprovados (p-valores < 0.05).",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software de plotagem, normas ABNT NBR para relatórios técnicos.",
                                  "tips": "Relacione β com equações fundamentais da mecânica dos solos.",
                                  "learningObjective": "Conectar resultados estatísticos a princípios físicos da engenharia civil.",
                                  "commonMistakes": "Interpretação estatística sem contexto físico; ignorar não-linearidades."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar o modelo em aplicação real",
                                  "subSteps": [
                                    "Aplicar curva a problema novo (ex.: dimensionar estaca com dados de CPT).",
                                    "Comparar predições com dados independentes ou normas (ex.: NBR 6122).",
                                    "Sensibilidade: variar pesos e observar impacto em β.",
                                    "Otimizar hiperparâmetros se necessário (ex.: robustez a outliers).",
                                    "Preparar visualizações para apresentação."
                                  ],
                                  "verification": "Predições dentro de 10% de valores experimentais/validados e relatório final completo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Dados de validação independentes, normas técnicas.",
                                  "tips": "Use cross-validation k-fold para robustez.",
                                  "learningObjective": "Garantir aplicabilidade prática e confiabilidade do modelo.",
                                  "commonMistakes": "Overfitting a dados ruidosos; não testar em conjunto independente."
                                }
                              ],
                              "practicalExample": "Em ensaio triaxial de solo coesivo, dados de tensão de pico vs. confinamento mostram variâncias crescentes. Use MRP para ajustar τ = c + σ tanφ, com pesos 1/σ², obtendo c=20kPa, φ=25°, prevendo capacidade de fundação de 150kPa.",
                              "finalVerifications": [
                                "Curva ajustada reproduz >95% variância explicada com resíduos randômicos.",
                                "Parâmetros físicos coerentes com literatura (ex.: φ entre 20-40° para solos).",
                                "Código executável e reproduzível compartilha resultados idênticos.",
                                "Relatório interpreta impactos em projeto civil (ex.: fator de segurança).",
                                "Testes de sensibilidade mostram estabilidade do modelo.",
                                "Comparação com OLS mostra superioridade do MRP (menor AIC)."
                              ],
                              "assessmentCriteria": [
                                "Precisão do ajuste: R²_ponderado > 0.92 e resíduos normalizados.",
                                "Correção da implementação: pesos corretos e minimização converge.",
                                "Interpretação física: ligação explícita com mecânica dos solos/estruturas.",
                                "Qualidade de visualizações: gráficos claros com legendas e escalas.",
                                "Relatório completo: estrutura, referências e limitações discutidas.",
                                "Eficiência computacional: tempo de execução <1min para 100 pontos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência em regressão linear generalizada.",
                                "Programação: Otimização numérica e análise de dados.",
                                "Física/Mecânica dos Solos: Leis constitutivas e comportamento material.",
                                "Gestão de Projetos: Análise de incertezas em dimensionamento.",
                                "Ética Profissional: Transparência em modelagem de riscos geotécnicos."
                              ],
                              "realWorldApplication": "Dimensionamento de fundações em solos heterogêneos, análise de fadiga em vigas de pontes com cargas variáveis, previsão de assentamentos em aterros, otimizando projetos para reduzir custos e riscos de falha estrutural em obras civis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.5",
                    "name": "Ajuste Não-Linear de Curvas",
                    "description": "Métodos iterativos baseados em otimização para funções não-lineares, resolvendo equações não-lineares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.5.1",
                        "name": "Formulação do Problema de Ajuste Não-Linear",
                        "description": "Definição do problema de ajuste de curvas não-lineares como minimização de uma função de erro não-linear, envolvendo parâmetros desconhecidos em modelos funcionais complexos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.1.1",
                            "name": "Formular o problema de mínimos quadrados não-lineares",
                            "description": "Construir a função objetivo como soma dos quadrados dos resíduos para dados experimentais ajustados a um modelo não-linear, identificando parâmetros iniciais e restrições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e Analisar Dados Experimentais",
                                  "subSteps": [
                                    "Reúna os dados experimentais relevantes, incluindo variáveis independentes (x) e dependentes (y) de experimentos em engenharia civil, como testes de compressão de concreto ao longo do tempo.",
                                    "Visualize os dados usando gráficos de dispersão para identificar padrões não-lineares, como curvas exponenciais ou logarítmicas.",
                                    "Limpe os dados removendo outliers ou valores ausentes, calculando estatísticas descritivas (média, desvio padrão).",
                                    "Documente as condições experimentais, unidades e possíveis fontes de erro.",
                                    "Defina o intervalo de x e y para o ajuste."
                                  ],
                                  "verification": "Gráfico de dispersão gerado e relatório de estatísticas descritivas salvo, confirmando que os dados estão prontos para modelagem.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou Python (pandas/matplotlib)",
                                    "Dados experimentais reais ou simulados"
                                  ],
                                  "tips": "Sempre plote os dados primeiro para 'ver' a não-linearidade antes de prosseguir.",
                                  "learningObjective": "Compreender a importância de dados de qualidade na formulação de problemas de ajuste não-linear.",
                                  "commonMistakes": [
                                    "Ignorar outliers sem justificativa",
                                    "Não converter unidades adequadamente",
                                    "Usar dados lineares para modelo não-linear"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Definir o Modelo Não-Linear",
                                  "subSteps": [
                                    "Escolha um modelo físico/teórico apropriado para os dados, ex: y = a * exp(-b*x) para decaimento de resistência em materiais.",
                                    "Identifique os parâmetros desconhecidos (a, b, etc.) e expresse o modelo como y = f(x; θ), onde θ são os parâmetros.",
                                    "Justifique a escolha do modelo com base em teoria da engenharia civil ou literatura.",
                                    "Escreva a equação explicitamente com símbolos.",
                                    "Verifique se o modelo é diferenciável para otimização posterior."
                                  ],
                                  "verification": "Equação do modelo documentada com justificativa e parâmetros listados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Literatura técnica (livros de engenharia civil)",
                                    "Software de simbólico como SymPy"
                                  ],
                                  "tips": "Baseie-se em conhecimento físico para evitar overfitting com modelos complexos desnecessários.",
                                  "learningObjective": "Selecionar modelos não-lineares relevantes para problemas reais de engenharia.",
                                  "commonMistakes": [
                                    "Escolher modelo sem base teórica",
                                    "Confundir parâmetros com variáveis",
                                    "Ignorar restrições físicas nos parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir os Resíduos e Construir a Função Objetivo",
                                  "subSteps": [
                                    "Defina o resíduo para cada ponto i como r_i = y_i - f(x_i; θ).",
                                    "Formule a função objetivo como S(θ) = ∑_{i=1}^n r_i² = ∑_{i=1}^n [y_i - f(x_i; θ)]².",
                                    "Escreva a função explicitamente para o modelo escolhido.",
                                    "Considere resíduos ponderados se houver variância heterogênea nos dados.",
                                    "Implemente uma função computacional simples para calcular S(θ) com valores teste."
                                  ],
                                  "verification": "Função objetivo S(θ) implementada e calculada para θ inicial arbitrário, produzindo valor finito.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python (NumPy) ou MATLAB",
                                    "Editor de código"
                                  ],
                                  "tips": "Use resíduos absolutos apenas se justificado; quadrados penalizam erros grandes mais.",
                                  "learningObjective": "Construir matematicamente a função de mínimos quadrados para ajuste não-linear.",
                                  "commonMistakes": [
                                    "Usar |r_i| em vez de r_i²",
                                    "Esquecer soma sobre todos os pontos",
                                    "Não linearizar indevidamente o modelo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Parâmetros Iniciais e Restrições",
                                  "subSteps": [
                                    "Estime valores iniciais θ_0 baseados em conhecimento físico, gráficos ou linearização aproximada.",
                                    "Defina restrições, ex: θ_j > 0 para parâmetros físicos positivos, ou limites superiores/inferiores.",
                                    "Formule o problema como minimizar S(θ) sujeito a g_k(θ) ≤ 0 e h_l(θ) = 0.",
                                    "Teste sensibilidade de θ_0 calculando S(θ_0).",
                                    "Documente todas as restrições com justificativas."
                                  ],
                                  "verification": "Lista de θ_0 e restrições documentada, com S(θ_0) computado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gráficos dos dados",
                                    "Documentação teórica"
                                  ],
                                  "tips": "Boas estimativas iniciais evitam convergência local em mínimos falsos.",
                                  "learningObjective": "Preparar o problema para otimização considerando praticidade numérica.",
                                  "commonMistakes": [
                                    "θ_0 irrealistas levando a falha numérica",
                                    "Restrições muito rígidas",
                                    "Ignorar acoplamento entre parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar a Formulação Completa do Problema",
                                  "subSteps": [
                                    "Revise a formulação completa: dados, modelo, S(θ), θ_0, restrições.",
                                    "Simule um conjunto de dados e verifique se S(θ) diminui com ajustes lógicos em θ.",
                                    "Compare com formulações lineares para destacar diferenças.",
                                    "Prepare relatório resumindo o problema formulado.",
                                    "Identifique potenciais issues numéricos (ex: singularidades)."
                                  ],
                                  "verification": "Relatório validado com simulação confirmando formulação correta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código de simulação",
                                    "Relatório template"
                                  ],
                                  "tips": "Sempre valide com dados sintéticos gerados pelo modelo para testar.",
                                  "learningObjective": "Garantir robustez na formulação antes da otimização.",
                                  "commonMistakes": [
                                    "Não testar numericamente",
                                    "Esquecer normalização de dados",
                                    "Formulação inconsistente de unidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Em testes de envelhecimento de concreto, dados de resistência à compressão y vs. tempo x seguem y = σ_max * (1 - exp(-kt)). Formule S(θ) = ∑ [y_i - σ_max*(1-exp(-k x_i))]² com θ = [σ_max, k], θ_0 = [50 MPa, 0.1 dia⁻¹], restrição k > 0.",
                              "finalVerifications": [
                                "Função objetivo S(θ) corretamente expressa como soma de quadrados dos resíduos.",
                                "Modelo não-linear f(x; θ) alinhado com dados e teoria física.",
                                "Parâmetros iniciais θ_0 realistas e computacionalmente viáveis.",
                                "Restrições definidas e justificadas para todos os parâmetros relevantes.",
                                "Cálculo de S(θ_0) finito e razoável em magnitude.",
                                "Documentação completa incluindo equações, justificativas e código de protótipo."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na definição de resíduos e função objetivo (30%)",
                                "Adequação do modelo e estimativas iniciais à aplicação em engenharia civil (25%)",
                                "Incorporação correta de restrições físicas e numéricas (20%)",
                                "Clareza e completude da documentação e validação (15%)",
                                "Demonstração prática via código ou cálculo manual (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Compreensão de resíduos e mínimos quadrados.",
                                "Programação: Implementação em Python/ MATLAB para otimização.",
                                "Física/Mecânica: Modelos constitutivos em engenharia de materiais.",
                                "Otimização Numérica: Preparação para métodos como Levenberg-Marquardt.",
                                "Análise de Dados: Limpeza e visualização prévia."
                              ],
                              "realWorldApplication": "Na engenharia civil, formulação de mínimos quadrados não-lineares é essencial para calibrar modelos de degradação de estruturas (ex: corrosão em vigas de concreto armado), prevendo vida útil e otimizando manutenção com base em dados de monitoramento in loco."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.2",
                            "name": "Identificar equações não-lineares implícitas",
                            "description": "Reconhecer quando o ajuste leva a sistemas de equações não-lineares derivadas da condição de otimalidade, diferenciando de casos lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Ajuste de Curvas Lineares",
                                  "subSteps": [
                                    "Defina ajuste de curvas como minimização do erro quadrático médio (EQM).",
                                    "Derive as equações normais para ajuste linear y = a + b x.",
                                    "Resolva o sistema linear resultante e observe sua forma matricial A θ = b.",
                                    "Identifique que as equações são lineares em relação aos parâmetros θ.",
                                    "Compare com dados de exemplo simples, como linha reta."
                                  ],
                                  "verification": "Derive corretamente as equações lineares para um modelo y = a + b x e resolva para parâmetros dados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Texto sobre regressão linear"
                                  ],
                                  "tips": "Sempre escreva o modelo funcional explicitamente antes de derivar.",
                                  "learningObjective": "Compreender a linearidade nas equações de otimalidade para ajustes lineares.",
                                  "commonMistakes": [
                                    "Confundir linearidade do modelo com linearidade dos parâmetros",
                                    "Esquecer de minimizar o EQM corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Modelos Não-Lineares e Condições de Otimalidade",
                                  "subSteps": [
                                    "Defina modelo não-linear como y = f(x, θ), onde f é não-linear em θ.",
                                    "Estabeleça a condição de otimalidade: gradiente do EQM zero, ∂S/∂θ_i = 0.",
                                    "Escreva as equações parciais: ∑ [ (y_i - f(x_i, θ)) * ∂f/∂θ_i ] = 0 para cada θ_i.",
                                    "Observe que essas equações são implícitas e geralmente não-lineares em θ.",
                                    "Discuta métodos de solução numérica como Newton-Raphson."
                                  ],
                                  "verification": "Escreva as condições de otimalidade para um modelo y = a * exp(b x) e identifique sua não-linearidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de álgebra simbólica como SymPy ou Mathematica",
                                    "Exemplos de modelos não-lineares"
                                  ],
                                  "tips": "Foque nas derivadas parciais ∂f/∂θ_i para ver a dependência não-linear.",
                                  "learningObjective": "Reconhecer a origem das equações não-lineares nas condições de mínimos quadrados.",
                                  "commonMistakes": [
                                    "Assumir linearidade se o modelo parece 'simples'",
                                    "Ignorar o papel das derivadas parciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Equações Não-Lineares Implícitas",
                                  "subSteps": [
                                    "Analise um modelo dado: verifique se f(x, θ) é linear ou não-linear em θ.",
                                    "Derive as equações de otimalidade e classifique como lineares (resolvíveis analiticamente) ou não-lineares (implícitas).",
                                    "Diferencie casos: linear se equações são Af + b = 0; não-linear se envolvem produtos ou potências de θ.",
                                    "Use critérios: presença de θ em não-linearidades em f ou ∂f/∂θ.",
                                    "Teste com exemplos mistos, como polinomial vs exponencial."
                                  ],
                                  "verification": "Classifique corretamente 3 modelos (linear, não-linear implícito, linearizável) com derivação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de 5 modelos de curvas comuns em Engenharia Civil",
                                    "Planilha para derivação"
                                  ],
                                  "tips": "Pergunte: 'As equações finais são lineares em todos os θ?' Se não, é não-linear implícita.",
                                  "learningObjective": "Diferenciar precisamente equações lineares de não-lineares derivadas da otimalidade.",
                                  "commonMistakes": [
                                    "Confundir não-linearidade do modelo com a das equações",
                                    "Não derivar explicitamente as condições"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Diferenciação e Aplicação em Contextos Reais",
                                  "subSteps": [
                                    "Selecione dados reais de Engenharia Civil, como curva de retenção de solo.",
                                    "Ajuste um modelo não-linear e derive/verifique as equações implícitas.",
                                    "Compare com ajuste linear aproximado e discuta limitações.",
                                    "Implemente uma verificação numérica simples para confirmar não-linearidade.",
                                    "Documente casos onde linearização falha."
                                  ],
                                  "verification": "Analise um dataset real e identifique corretamente se leva a equações não-lineares implícitas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Dataset de exemplo (e.g., carga-deformação em concreto)",
                                    "Python/MATLAB para plotagem"
                                  ],
                                  "tips": "Use gráficos residuais para validar a necessidade de não-linear.",
                                  "learningObjective": "Aplicar identificação em problemas práticos de Engenharia Civil.",
                                  "commonMistakes": [
                                    "Escolher modelo inadequado sem testar linearidade",
                                    "Ignorar singularidades nas equações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um experimento de deformação de vigas de concreto, dados (x= carga, y= deformação) são ajustados por y = a / (1 + exp(-b (x - c))). Derivando ∂S/∂a, ∂S/∂b, ∂S/∂c, obtém-se sistema não-linear implícito devido a produtos e exponenciais em θ = {a,b,c}, exigindo solvers numéricos.",
                              "finalVerifications": [
                                "Deriva corretamente condições de otimalidade para 3 modelos não-lineares.",
                                "Classifica com 100% acerto 5 casos mistos (linear vs não-linear).",
                                "Explica verbalmente a diferença entre linearidade do modelo e das equações.",
                                "Identifica não-linearidade implícita em um dataset real sem erros.",
                                "Propõe método numérico adequado para solução."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das equações de otimalidade (matemática correta).",
                                "Capacidade de diferenciar linear de não-linear com justificativa clara.",
                                "Uso correto de terminologia (implícita, otimalidade, EQM).",
                                "Aplicação prática em contexto de Engenharia Civil.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Profundidade nos substeps com exemplos numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Derivadas parciais e gradientes.",
                                "Estatística: Regressão e análise de mínimos quadrados.",
                                "Programação Numérica: Solvers iterativos como fsolve em Python.",
                                "Física Aplicada: Modelagem de materiais em Engenharia."
                              ],
                              "realWorldApplication": "Na análise de curvas de retenção de umidade em solos para projetos de fundações, identificar equações não-lineares implícitas permite escolher algoritmos de otimização adequados, evitando erros em simulações de estabilidade geotécnica e otimizando projetos de barragens ou aterros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.3",
                            "name": "Aplicar resíduos ponderados no ajuste",
                            "description": "Incorporar pesos nos resíduos para priorizar dados com maior precisão, ajustando a função de erro em contextos de engenharia civil com medições heterogêneas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de resíduos ponderados",
                                  "subSteps": [
                                    "Defina resíduos como a diferença entre valores observados e preditos pela curva de ajuste.",
                                    "Explique por que pesos são necessários em medições heterogêneas, como em sensores de deformação com diferentes precisões.",
                                    "Estude fórmulas básicas: resíduo ponderado w_i * (y_i - f(x_i, β))^2.",
                                    "Revise variância e como pesos são tipicamente w_i = 1/σ_i².",
                                    "Analise um gráfico de dados com variâncias desiguais para visualizar o impacto."
                                  ],
                                  "verification": "Resuma em 3 frases o papel dos pesos nos resíduos e forneça um exemplo numérico simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de ajuste de curvas (ex: 'Numerical Methods for Engineers'), calculadora, papel e lápis.",
                                  "tips": "Use analogia: pesos como 'confiança' em testemunhas em um julgamento.",
                                  "learningObjective": "Identificar quando e por que usar resíduos ponderados em ajustes não-lineares.",
                                  "commonMistakes": "Confundir pesos com normalização de dados; assumir variância uniforme."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar pesos apropriados para os dados",
                                  "subSteps": [
                                    "Colete metadados de precisão das medições (ex: desvios padrão de sensores).",
                                    "Calcule pesos como inverso da variância: w_i = 1/σ_i² para cada ponto.",
                                    "Escolha método alternativo se variâncias desconhecidas (ex: pesos baseados em repetibilidade).",
                                    "Normalize pesos para soma unitária se necessário para estabilidade numérica.",
                                    "Crie uma tabela comparando pesos não-ponderados vs. ponderados."
                                  ],
                                  "verification": "Gere uma tabela de 5 pontos de dados com pesos calculados e justifique escolhas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha Excel ou Google Sheets, dados de exemplo de medições civis.",
                                  "tips": "Registre fontes de erro de medição (ex: strain gauges vs. extensômetros).",
                                  "learningObjective": "Selecionar e calcular pesos baseados em precisão de dados heterogêneos.",
                                  "commonMistakes": "Usar pesos iguais para todos os pontos; ignorar unidades nos desvios padrão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e implementar a função de erro ponderada",
                                  "subSteps": [
                                    "Modifique a soma de quadrados dos resíduos: S(β) = Σ w_i * (y_i - f(x_i, β))^2.",
                                    "Integre na equação de minimização para ajuste não-linear (ex: Levenberg-Marquardt).",
                                    "Codifique em Python usando SciPy.optimize.curve_fit com sigma=1/sqrt(w).",
                                    "Teste com dados sintéticos para validar implementação.",
                                    "Compare curvas ajustadas ponderada vs. não-ponderada graficamente."
                                  ],
                                  "verification": "Execute código e mostre gráficos de ajuste antes/depois dos pesos.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com NumPy, SciPy, Matplotlib; Jupyter Notebook.",
                                  "tips": "Use sigma em curve_fit para pesos automáticos: sigma = 1/np.sqrt(weights).",
                                  "learningObjective": "Incorporar pesos na formulação matemática e computacional do ajuste.",
                                  "commonMistakes": "Esquecer de elevar ao quadrado os resíduos; overflow numérico com pesos altos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e validar o ajuste ponderado",
                                  "subSteps": [
                                    "Calcule métricas: R² ponderado, RMSE ponderado, χ² reduzido.",
                                    "Analise resíduos padronizados ponderados para normalidade e homocedasticidade.",
                                    "Realize teste de significância dos parâmetros ajustados.",
                                    "Compare com ajuste não-ponderado usando teste F ou AIC.",
                                    "Documente melhorias em precisão para pontos de alta confiança."
                                  ],
                                  "verification": "Relatório com métricas numéricas e conclusão sobre superioridade do ponderado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python estendido com statsmodels ou SciPy.stats.",
                                  "tips": "Plote resíduos vs. preditos para detectar padrões restantes.",
                                  "learningObjective": "Validar eficácia dos resíduos ponderados em ajustes não-lineares.",
                                  "commonMistakes": "Interpretar R² sem contexto ponderado; ignorar multicolinearidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em contexto de engenharia civil",
                                  "subSteps": [
                                    "Selecione dataset real: ex. deformação em viga sob carga com sensores variados.",
                                    "Ajuste modelo não-linear (ex. hiperbólica para assentamento).",
                                    "Interprete resultados: priorização de medições precisas em relatórios.",
                                    "Simule cenários de falha de sensor e re-ajuste.",
                                    "Gere relatório final com recomendações."
                                  ],
                                  "verification": "Submeta relatório com ajuste completo e insights práticos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Dataset de exemplo (ex. de testes de carga em estruturas).",
                                  "tips": "Integre com normas ABNT para relatórios de ensaios.",
                                  "learningObjective": "Aplicar resíduos ponderados em problemas reais de engenharia civil.",
                                  "commonMistakes": "Sobreajuste por pesos extremos; negligenciar outliers válidos."
                                }
                              ],
                              "practicalExample": "Em um teste de compressão de concreto, medições de deformação de strain gauges (alta precisão, σ=0.01%) recebem peso 100x maior que extensômetros manuais (σ=0.1%). Ajuste não-linear da curva tensão-deformação prioriza strain gauges, resultando em predição mais precisa do pico de resistência.",
                              "finalVerifications": [
                                "Cálculo correto de pesos baseado em variâncias fornecidas.",
                                "Função de erro minimizada com pesos implementada sem erros numéricos.",
                                "Gráficos mostram melhor ajuste para pontos de alta precisão.",
                                "Métricas de qualidade (R², RMSE) melhoradas vs. não-ponderado.",
                                "Resíduos ponderados distribuídos normalmente (teste Shapiro-Wilk p>0.05).",
                                "Relatório interpreta impactos em decisões de engenharia."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática dos resíduos ponderados (20%).",
                                "Correta implementação computacional e código limpo (25%).",
                                "Análise estatística robusta com métricas apropriadas (20%).",
                                "Interpretação contextual em engenharia civil (20%).",
                                "Clareza e completude do relatório final (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência bayesiana e máxima verossimilhança.",
                                "Programação: Otimização numérica em Python/MATLAB.",
                                "Física/Mecânica: Modelagem de materiais heterogêneos.",
                                "Gestão de Projetos: Análise de incertezas em medições de campo."
                              ],
                              "realWorldApplication": "Em monitoramento de estruturas (ex: pontes), pesos priorizam dados de acelerômetros de alta resolução sobre vibrometros baratos, melhorando predições de fadiga e segurança, conforme normas como Eurocode 8."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.2",
                        "name": "Métodos Iterativos de Otimização",
                        "description": "Técnicas iterativas como Newton-Gauss e Levenberg-Marquardt para resolver o problema de otimização não-linear no ajuste de curvas.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.2.1",
                            "name": "Implementar o método de Newton para equações não-lineares",
                            "description": "Usar iterações baseadas na matriz Jacobiana e Hessiana para aproximar soluções de sistemas não-lineares oriundos do ajuste de curvas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formulação do problema e revisão teórica",
                                  "subSteps": [
                                    "Defina o sistema de equações não-lineares f(x) = 0, onde x é um vetor de parâmetros (ex.: parâmetros de curva no ajuste não-linear).",
                                    "Revise a iteração do método de Newton: x_{k+1} = x_k - J^{-1} f(x_k), onde J é a Jacobiana.",
                                    "Explique o papel da Hessiana em contextos de otimização, como aproximação para mínimos quadrados.",
                                    "Discuta condições de convergência quadrática e critérios de parada (ex.: ||f(x)|| < ε).",
                                    "Identifique o contexto de ajuste de curvas: resíduos r_i = y_i - f(x_i, θ), levando a ∇S(θ) = 0."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando a formulação e derive a iteração Newton para um sistema 2x2 simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Métodos Numéricos (ex.: Burden & Faires)",
                                    "Notas de aula sobre ajuste não-linear",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": [
                                    "Visualize graficamente a convergência para entender a atração quadrática.",
                                    "Comece com sistemas pequenos para intuição."
                                  ],
                                  "learningObjective": "Compreender a base matemática do método de Newton para sistemas não-lineares e sua aplicação em otimização.",
                                  "commonMistakes": [
                                    "Confundir Jacobiana (primeira derivada) com Hessiana (segunda derivada).",
                                    "Ignorar singularidades na Jacobiana.",
                                    "Não considerar inicialização sensível."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computação da Jacobiana e Hessiana",
                                  "subSteps": [
                                    "Defina a Jacobiana J(θ) = ∂f/∂θ para o sistema f(θ) = 0 derivado do ajuste.",
                                    "Implemente analiticamente as derivadas parciais para um exemplo de curva (ex.: y = a*exp(b*x)).",
                                    "Discuta aproximação numérica da Jacobiana via diferenças finitas se analítica for complexa.",
                                    "Calcule a Hessiana H(θ) = ∂²S/∂θ² para o caso de Newton completo em otimização.",
                                    "Teste a Jacobiana em um ponto inicial com valores numéricos conhecidos."
                                  ],
                                  "verification": "Compute manualmente e verifique numericamente a Jacobiana para um sistema 2D, comparando com derivadas simbólicas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software simbólico (SymPy ou Mathematica)",
                                    "Planilha Excel para testes numéricos",
                                    "Documentação de ajuste não-linear"
                                  ],
                                  "tips": [
                                    "Use diferenciação automática em Python (Autograd) para validar derivadas.",
                                    "Sempre normalize os dados para melhorar numérica."
                                  ],
                                  "learningObjective": "Dominar o cálculo preciso da Jacobiana e introdução à Hessiana para iterações Newton.",
                                  "commonMistakes": [
                                    "Erros de sinal nas derivadas parciais.",
                                    "Usar aproximações numéricas sem verificar precisão.",
                                    "Esquecer termos de segunda ordem na Hessiana."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementação do algoritmo iterativo",
                                  "subSteps": [
                                    "Escreva código para inicializar θ_0, tolerância ε e máximo de iterações.",
                                    "Implemente o loop: compute f(θ_k), J(θ_k), resolva J δ = -f, atualize θ_{k+1} = θ_k + δ.",
                                    "Inclua uso da Hessiana se aplicável (ex.: para Newton completo: H δ = -∇S).",
                                    "Adicione critérios de parada e logging de resíduos e iterações.",
                                    "Integre ao contexto de ajuste: compute resíduos de dados reais e otimize."
                                  ],
                                  "verification": "Execute o código em um sistema teste e confirme que iterações reduzem ||f|| monotonicamente.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "MATLAB ou Julia",
                                    "Dados de exemplo de assentamento de solos"
                                  ],
                                  "tips": [
                                    "Use solvers lineares eficientes como np.linalg.solve.",
                                    "Monitore cond number da Jacobiana para detectar problemas."
                                  ],
                                  "learningObjective": "Implementar funcionalmente o método de Newton em código para sistemas não-lineares.",
                                  "commonMistakes": [
                                    "Loop infinito sem critério de parada.",
                                    "Inversão direta da Jacobiana (use solver).",
                                    "Inicial guess ruim levando a divergência."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação, análise de convergência e aplicação",
                                  "subSteps": [
                                    "Teste com problema conhecido (ex.: sistema de Rosenbrock adaptado).",
                                    "Aplique a ajuste não-linear de curva em dados de engenharia civil (ex.: deformação vs. carga).",
                                    "Analise taxa de convergência plotando log(resíduos) vs. iterações.",
                                    "Compare com outros métodos (ex.: Gradiente Descendente).",
                                    "Documente sensibilidade a θ_0 e ajustes na Jacobiana/Hessiana."
                                  ],
                                  "verification": "Gere relatório com plots de convergência e R² do ajuste final > 0.95.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Dados reais de engenharia (ex.: ensaios de solos)",
                                    "Matplotlib/Plots.jl para visualização",
                                    "Código fonte versionado"
                                  ],
                                  "tips": [
                                    "Varie θ_0 múltiplas vezes para robustez.",
                                    "Regularize Hessiana se ill-conditioned."
                                  ],
                                  "learningObjective": "Validar a implementação e aplicá-la a problemas reais de ajuste de curvas.",
                                  "commonMistakes": [
                                    "Sobreajuste sem validação cruzada.",
                                    "Ignorar warnings de singularidade.",
                                    "Não plotar para diagnóstico visual."
                                  ]
                                }
                              ],
                              "practicalExample": "Ajuste não-linear de uma curva exponencial y = a * exp(b * x) a dados de assentamento de fundações sob carga crescente: defina resíduos r(θ) = [y_i - a*exp(b*x_i)], resolva ∇S(θ) = J^T r(θ) = 0 via Newton com Jacobiana J das derivadas ∂r/∂θ, usando 10 pontos de dados reais simulados.",
                              "finalVerifications": [
                                "O algoritmo converge em <20 iterações para ε=1e-6.",
                                "Jacobiana e Hessiana coincidem com computação simbólica em 5 casas decimais.",
                                "R² do ajuste >0.98 em dados de teste.",
                                "Código roda sem erros numéricos e lida com falhas de convergência.",
                                "Plot de resíduos mostra redução quadrática.",
                                "Solução sensível a inicialização é documentada."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação teórica (derivadas corretas: 30%).",
                                "Eficiência e robustez do código (convergência consistente: 25%).",
                                "Qualidade do ajuste em exemplo prático (R² e resíduos: 20%).",
                                "Análise de erros e convergência (plots e discussão: 15%).",
                                "Documentação e clareza do código (10%).",
                                "Conexão com contexto de engenharia civil (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica (Python/NumPy para solvers lineares).",
                                "Análise Numérica (estabilidade e condicionamento de matrizes).",
                                "Estatística (métricas de ajuste como R² e validação).",
                                "Engenharia Computacional (simulações em estruturas).",
                                "Cálculo Avançado (derivadas multivariáveis)."
                              ],
                              "realWorldApplication": "Em engenharia civil, otimizar parâmetros de modelos constitutivos de solos (ex.: hiperbólico para assentamentos) a partir de ensaios de carga em campo, permitindo simulações precisas de fundações e previsão de deformações em projetos de edifícios e pontes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.2",
                            "name": "Aplicar o algoritmo Levenberg-Marquardt",
                            "description": "Combinar gradiente descendente e método de Newton com fator de amortecimento para convergência robusta em ajustes não-lineares com dados ruidosos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do Algoritmo Levenberg-Marquardt",
                                  "subSteps": [
                                    "Revise a função de custo para mínimos quadrados não-lineares: S(β) = Σ [y_i - f(x_i, β)]²",
                                    "Estude o gradiente J^T r e a matriz Jacobiana J, onde r é o vetor de resíduos",
                                    "Compreenda a aproximação da Hessiana H ≈ J^T J + λ I, com λ como fator de amortecimento",
                                    "Analise como λ grande aproxima gradiente descendente e λ pequeno aproxima Newton",
                                    "Identifique condições iniciais: parâmetros β₀ e λ₀"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como o algoritmo transita entre GD e Newton",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação do algoritmo LM (SciPy ou MATLAB), caderno de anotações, calculadora",
                                  "tips": "Desenhe diagramas fluxogramas para visualizar a transição de métodos",
                                  "learningObjective": "Compreender a combinação híbrida de métodos de otimização",
                                  "commonMistakes": "Confundir Jacobiana com Hessiana exata; ignorar o papel adaptativo de λ"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar Parâmetros e Preparar Dados",
                                  "subSteps": [
                                    "Colete dados experimentais ruidosos (ex: tensão vs. deformação em ensaio de solo)",
                                    "Defina função modelo não-linear f(x, β), ex: modelo hiperbólico para assentamentos",
                                    "Calcule resíduos iniciais r = y - f(x, β₀) e custo inicial S(β₀)",
                                    "Escolha β₀ razoável (valores iniciais plausíveis) e λ₀ = 0.001",
                                    "Implemente computação da Jacobiana J via diferenciação numérica ou analítica"
                                  ],
                                  "verification": "Confirme que custo inicial e Jacobiana são computados corretamente em código ou manualmente",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software Python (NumPy, SciPy.optimize.leastsq) ou MATLAB, conjunto de dados de exemplo",
                                  "tips": "Use valores β₀ próximos a estimativas lineares para aceleração",
                                  "learningObjective": "Preparar dados e parâmetros para iterações robustas",
                                  "commonMistakes": "Escolha ruim de β₀ levando a divergência; Jacobiana imprecisa por passos numéricos inadequados"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Iteração: Calcular Passo e Atualizar Parâmetros",
                                  "subSteps": [
                                    "Resolva o sistema (J^T J + λ I) δβ = -J^T r para obter δβ",
                                    "Atualize β_{k+1} = β_k + δβ",
                                    "Calcule custo novo S(β_{k+1}) e ganho ρ = [S(β_k) - S(β_{k+1})] / [δβ^T J^T r + 0.5 δβ^T (J^T J) δβ]",
                                    "Se ρ > 0.25, aceite passo e reduza λ (λ /= 10); senão rejeite e aumente λ (λ *= 10)",
                                    "Repita até convergência ou máximo de iterações"
                                  ],
                                  "verification": "Simule 1-2 iterações manualmente e verifique se λ ajusta corretamente",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Código Python/MATLAB implementando o loop iterativo, debugger",
                                  "tips": "Monitore ρ para diagnosticar problemas de convergência",
                                  "learningObjective": "Implementar o núcleo iterativo com adaptação de λ",
                                  "commonMistakes": "Fator de ajuste de λ muito agressivo causando oscilações; não normalizar J para escalas diferentes"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Convergência e Analisar Resultados",
                                  "subSteps": [
                                    "Defina critérios: ||δβ|| < ε, ||∇S|| < ε ou iterações > max_iter",
                                    "Calcule intervalos de confiança via matriz covariância (J^T J)^{-1} σ²",
                                    "Plote curvas ajustadas vs. dados para inspeção visual",
                                    "Avalie resíduos: teste de normalidade e homocedasticidade",
                                    "Compare com outros métodos (GD puro, Newton) para robustez"
                                  ],
                                  "verification": "Gere gráfico de convergência (custo vs. iteração) mostrando platô",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matplotlib/Plotly para visualizações, software estatístico opcional",
                                  "tips": "Use ε = 1e-6 para precisão em engenharia",
                                  "learningObjective": "Garantir convergência robusta e validar o ajuste",
                                  "commonMistakes": "Parar prematuramente sem verificar gradiente; ignorar multicolinearidade em J"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar e Testar em Caso Real de Engenharia Civil",
                                  "subSteps": [
                                    "Aplique a dados reais de assentamento de fundações (ex: curva σ-z)",
                                    "Otimize hiperparâmetros como λ₀ e fatores de ajuste",
                                    "Teste sensibilidade a ruído adicionando 5-10% erro gaussiano",
                                    "Documente código e resultados em relatório",
                                    "Valide predições com dados independentes"
                                  ],
                                  "verification": "Ajuste reproduz dados com R² > 0.95 e resíduos aleatórios",
                                  "estimatedTime": "2 horas",
                                  "materials": "Dados reais de ensaios geotécnicos, Jupyter Notebook",
                                  "tips": "Versione código com Git para rastrear mudanças",
                                  "learningObjective": "Aplicar LM em contexto prático de engenharia",
                                  "commonMistakes": "Sobreajuste (overfitting) sem validação cruzada; escalas de variáveis inconsistentes"
                                }
                              ],
                              "practicalExample": "Ajustar modelo hiperbólico S(z) = a * z / (b + z) a dados de assentamento de solo sob carga, usando dados ruidosos de placa de ensaio, para prever deformações em fundações.",
                              "finalVerifications": [
                                "Custo S(β) estabilizou em <1% da variação inicial",
                                "Norma do gradiente ||J^T r|| < 1e-6",
                                "Mudança nos parâmetros ||δβ|| < 1e-8",
                                "Resíduos mostram distribuição normal sem padrões",
                                "Gráfico de ajuste sobrepõe dados com precisão visual",
                                "Convergência em <50 iterações para dados típicos"
                              ],
                              "assessmentCriteria": [
                                "Precisão do ajuste: R² > 0.95 e RMSE < 5% do range de y",
                                "Robustez: Convergência consistente com ±10% ruído",
                                "Eficiência: <100 iterações e tempo <10s em dataset de 100 pontos",
                                "Implementação correta: λ adapta dinamicamente com ρ >0 na maioria das iterações",
                                "Análise completa: Intervalos de confiança reportados e resíduos analisados",
                                "Documentação: Código comentado e relatório com plots"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável (gradientes, Hessianas)",
                                "Programação: NumPy/SciPy para otimização numérica",
                                "Estatística: Análise de resíduos e inferência paramétrica",
                                "Física/Geotecnia: Modelagem constitutiva de solos e estruturas"
                              ],
                              "realWorldApplication": "Calibração de modelos de assentamento em projetos de fundações para prever deformações long-term em edifícios, barragens ou pavimentos, reduzindo riscos de falhas estruturais em solos compressíveis."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.3",
                            "name": "Avaliar convergência de métodos iterativos",
                            "description": "Definir critérios de parada baseados em tolerâncias em resíduos, gradientes e mudanças nos parâmetros, monitorando iterações em software numérico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Convergência em Métodos Iterativos",
                                  "subSteps": [
                                    "Estude definições de convergência linear, quadrática e superlinear.",
                                    "Analise resíduos (||F(x)||), norma do gradiente (||∇f(x)||) e mudança nos parâmetros (||x_{k+1} - x_k||).",
                                    "Revise condições de parada comuns em otimização não-linear.",
                                    "Compare métodos iterativos como Newton-Raphson e Gradiente Descendente.",
                                    "Identifique divergência e oscilação em iterações."
                                  ],
                                  "verification": "Resuma em um diagrama os três principais critérios de parada e explique cada um em 1-2 frases.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Artigos sobre otimização não-linear",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias como 'aproximação de raízes' para visualizar convergência.",
                                  "learningObjective": "Dominar os conceitos teóricos de convergência e critérios de parada.",
                                  "commonMistakes": [
                                    "Confundir resíduo com gradiente",
                                    "Ignorar normas adequadas (L1 vs L2 vs L∞)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Critérios de Parada com Tolerâncias Apropriadas",
                                  "subSteps": [
                                    "Escolha tolerâncias típicas: resíduo < 1e-6, gradiente < 1e-8, mudança < 1e-10.",
                                    "Implemente lógica condicional: pare se qualquer critério for satisfeito ou máx. iterações atingidas.",
                                    "Ajuste tolerâncias baseado no problema (ex: precisão em engenharia civil).",
                                    "Teste sensibilidade variando tolerâncias em exemplos simples.",
                                    "Documente justificativas para cada tolerância escolhida."
                                  ],
                                  "verification": "Crie um fluxograma com condições de parada e valide com um exemplo numérico manual.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB/Python (SciPy/NumPy)",
                                    "Planilha Excel para cálculos manuais"
                                  ],
                                  "tips": "Comece com tolerâncias conservadoras para evitar falsos positivos de convergência.",
                                  "learningObjective": "Selecionar e justificar tolerâncias para diferentes tipos de problemas.",
                                  "commonMistakes": [
                                    "Tolerâncias muito frouxas levando a soluções imprecisas",
                                    "Não considerar máximo de iterações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Monitoramento de Iterações em Software Numérico",
                                  "subSteps": [
                                    "Escreva código para registrar resíduo, gradiente e Δx a cada iteração.",
                                    "Gere gráficos de evolução (semilogy para resíduos).",
                                    "Integre critérios de parada no loop iterativo.",
                                    "Adicione logs e alertas para divergência.",
                                    "Teste com função benchmark como Rosenbrock."
                                  ],
                                  "verification": "Execute código e produza gráfico mostrando convergência com < 50 iterações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy, SciPy, Matplotlib",
                                    "Jupyter Notebook",
                                    "Exemplos de código de otimização"
                                  ],
                                  "tips": "Use %timeit para otimizar código e callbacks para monitoramento.",
                                  "learningObjective": "Desenvolver scripts para monitoramento automatizado de convergência.",
                                  "commonMistakes": [
                                    "Índices de array off-by-one em loops",
                                    "Escala errada em plots (linear vs log)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Interpretar Resultados de Convergência",
                                  "subSteps": [
                                    "Analise histórico de iterações para detectar padrões (ex: platô).",
                                    "Compare solução final com valor analítico conhecido.",
                                    "Avalie robustez variando condições iniciais.",
                                    "Relate métricas: iterações totais, tempo CPU, precisão alcançada.",
                                    "Proponha melhorias se convergência lenta."
                                  ],
                                  "verification": "Gere relatório de 1 página com análise de um caso, incluindo gráficos e conclusões.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código do Step 3",
                                    "Templates de relatório LaTeX/Word"
                                  ],
                                  "tips": "Sempre valide com múltiplas sementes iniciais para robustez.",
                                  "learningObjective": "Interpretar dados de convergência e diagnosticar problemas.",
                                  "commonMistakes": [
                                    "Aceitar convergência prematura sem validação",
                                    "Ignorar custo computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um problema de ajuste não-linear de curva tensão-deformação para concreto em estruturas civis, use método de Levenberg-Marquardt para minimizar resíduos entre dados experimentais e modelo hiperbólico. Monitore resíduo < 1e-5, ||∇χ²|| < 1e-7 e Δp < 1e-9, parando em 100 iterações máx., gerando gráfico de evolução para validar convergência em 20 iterações.",
                              "finalVerifications": [
                                "Define corretamente tolerâncias para resíduo, gradiente e Δx.",
                                "Implementa monitoramento com gráficos logarítmicos de resíduos.",
                                "Detecta e explica casos de não-convergência.",
                                "Valida solução com erro relativo < 1%.",
                                "Gera relatório com métricas de performance.",
                                "Ajusta parâmetros para otimizar iterações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de critérios (90% correção teórica).",
                                "Funcionalidade do código de monitoramento (roda sem erros, gráficos claros).",
                                "Análise qualitativa/quantitativa de convergência (profundidade e acurácia).",
                                "Eficiência: convergência em < 100 iterações para benchmark.",
                                "Relatório completo com interpretações e sugestões.",
                                "Robustez a condições iniciais variadas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB.",
                                "Estatística: Análise de resíduos e testes de ajuste.",
                                "Análise Numérica: Teoria de erros e estabilidade.",
                                "Engenharia Computacional: Simulações FEM em estruturas."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, avaliar convergência garante precisão em simulações de otimização de treliças ou ajuste de curvas de fadiga em pontes, evitando erros em dimensionamento que poderiam levar a falhas estruturais custosas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.3",
                        "name": "Análise de Condicionamento e Validação",
                        "description": "Estudo do condicionamento numérico, matriz de Gram e autovalores para avaliar a qualidade do ajuste não-linear em problemas de engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.3.1",
                            "name": "Calcular o condicionamento da matriz Jacobiana",
                            "description": "Determinar o número de condicionamento para identificar problemas de il-condicionamento em ajustes não-lineares, relacionando com autovalores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de matriz Jacobiana e seu papel no ajuste não-linear",
                                  "subSteps": [
                                    "Revise a definição de matriz Jacobiana como a matriz de derivadas parciais dos resíduos em relação aos parâmetros do modelo.",
                                    "Estude como a Jacobiana é usada no método dos mínimos quadrados não-lineares (Levenberg-Marquardt).",
                                    "Identifique cenários de il-condicionamento, onde pequenas mudanças nos dados causam grandes variações nos parâmetros.",
                                    "Relacione o condicionamento com a relação entre autovalores máximos e mínimos de J^T J.",
                                    "Analise exemplos simples de Jacobianas mal-condicionadas em contextos de engenharia."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o papel da Jacobiana e dê um exemplo de il-condicionamento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Notebook com Python (NumPy, SciPy)",
                                    "Artigos sobre otimização não-linear"
                                  ],
                                  "tips": "Comece com modelos lineares para contrastar com não-lineares; visualize a Jacobiana como uma 'sensibilidade' dos parâmetros.",
                                  "learningObjective": "Compreender a Jacobiana como base para análise de estabilidade em ajustes não-lineares.",
                                  "commonMistakes": [
                                    "Confundir Jacobiana com Hessiana",
                                    "Ignorar que Jacobiana não é simétrica",
                                    "Não relacionar com autovalores de J^T J"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz Jacobiana para um modelo não-linear específico",
                                  "subSteps": [
                                    "Defina o modelo não-linear, ex: y = a * exp(b * x) + c, e os resíduos r_i = y_i - modelo(x_i, params).",
                                    "Calcule analiticamente as derivadas parciais ∂r_i/∂p_j para cada parâmetro p_j.",
                                    "Implemente a Jacobiana numericamente usando diferenças finitas se analítica for complexa: J_ij ≈ (r(p_j + ε) - r(p_j - ε))/(2ε).",
                                    "Monte a matriz J com dimensões (n_dados x n_params) para um conjunto de dados de exemplo.",
                                    "Verifique a Jacobiana computando J * delta_params e comparando com variação nos resíduos."
                                  ],
                                  "verification": "Gere a Jacobiana para um dataset sintético e confirme que as derivadas estão corretas comparando analítico vs numérico.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy e SciPy.optimize",
                                    "Dataset de exemplo (ex: dados de deformação em vigas)",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Use ε = 1e-8 para diferenças finitas; sempre normalize os parâmetros para melhorar condicionamento.",
                                  "learningObjective": "Construir corretamente a Jacobiana para qualquer modelo não-linear.",
                                  "commonMistakes": [
                                    "Escolha errada de ε levando a erros de arredondamento",
                                    "Confundir resíduos com modelo predito",
                                    "Índices errados na matriz (linhas=dados, colunas=params)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular autovalores e valores singulares da Jacobiana",
                                  "subSteps": [
                                    "Compute a matriz simétrica J^T J para obter autovalores reais positivos.",
                                    "Use SVD (Singular Value Decomposition) da Jacobiana: J = U Σ V^T, onde Σ contém valores singulares σ_i.",
                                    "Calcule autovalores de J^T J usando eigendecomposição: λ_i = σ_i².",
                                    "Ordene os autovalores/autovalores singulares em ordem decrescente.",
                                    "Identifique os menores e maiores valores para preparar o cálculo de condicionamento."
                                  ],
                                  "verification": "Execute SVD/eig e liste os 3 maiores e 3 menores σ/√λ; compare com normas da matriz.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python: numpy.linalg.svd e numpy.linalg.eig",
                                    "MATLAB ou Octave para verificação",
                                    "Planilha para autovalores manuais em casos pequenos"
                                  ],
                                  "tips": "SVD é mais estável que inversão direta; ignore autovalores próximos de zero como rank-deficient.",
                                  "learningObjective": "Dominar decomposições para análise espectral da Jacobiana.",
                                  "commonMistakes": [
                                    "Usar eig em J diretamente (não simétrica)",
                                    "Confundir σ com √λ",
                                    "Não ordenar valores corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar o número de condicionamento e interpretar resultados",
                                  "subSteps": [
                                    "Calcule cond(J) = σ_max / σ_min (ou λ_max / λ_min para J^T J).",
                                    "Compare com thresholds: cond < 10^3 bom, >10^6 il-condicionado.",
                                    "Reescale parâmetros ou dados se cond alto, e recalcule.",
                                    "Interprete: alto cond indica sensibilidade numérica e incerteza nos parâmetros.",
                                    "Gere relatório com cond, autovalores e recomendações para melhoria."
                                  ],
                                  "verification": "Para um exemplo, compute cond e proponha rescaling se >10^4; valide com simulação de ruído.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código Python integrado dos steps anteriores",
                                    "Documentação SciPy para condition_number",
                                    "Gráficos de autovalores (matplotlib)"
                                  ],
                                  "tips": "Log-scale autovalores para visualizar gaps; cond ≈1 indica ortogonalidade perfeita.",
                                  "learningObjective": "Calcular e interpretar o condicionamento para validar ajustes não-lineares.",
                                  "commonMistakes": [
                                    "Usar ||J||_F ao invés de 2-norma para cond",
                                    "Ignorar σ_min=0 (singular)",
                                    "Não testar sensibilidade com ruído"
                                  ]
                                }
                              ],
                              "practicalExample": "Em engenharia civil, ajuste dados de assentamento de fundações com modelo hiperbólico y = a * x / (b + x). Compute Jacobiana 2x2 para params a,b em 10 pontos de dados. SVD dá σ_max=1e3, σ_min=1e-2 → cond=1e5 (il-condicionado). Rescale x por 100, recalcule cond=50 (aceitável).",
                              "finalVerifications": [
                                "Calcule cond para um novo dataset e identifique se >10^4.",
                                "Explique relação entre cond alto e barras de erro grandes nos params.",
                                "Implemente função Python que retorna cond(J) e autovalores.",
                                "Modifique dataset para induzir il-condicionamento e corrija.",
                                "Compare cond analítico vs numérico para modelo simples.",
                                "Gere gráfico de autovalores decrescentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da Jacobiana (erro <1e-6 vs analítico).",
                                "Correta interpretação de cond (alto=problema numérico).",
                                "Uso apropriado de SVD/eig sem erros dimensionais.",
                                "Identificação e correção de il-condicionamento.",
                                "Relatório claro com valores, gráficos e conclusões.",
                                "Eficiência computacional (tempo <5s para n=100)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Decomposições matriciais (SVD, eig).",
                                "Programação: Implementação em Python/NumPy para análise científica.",
                                "Estatística: Análise de incerteza em estimação de parâmetros.",
                                "Física/Engenharia: Modelagem de fenômenos não-lineares em estruturas.",
                                "Otimização: Sensibilidade em algoritmos de mínimos quadrados."
                              ],
                              "realWorldApplication": "Em engenharia civil, analisar condicionamento da Jacobiana em ajustes de curvas para previsão de deformações em barragens ou recalque de solos garante precisão em projetos, evitando falhas estruturais por erros numéricos em simulações de longo prazo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.3.2",
                            "name": "Construir e analisar a matriz de Gram",
                            "description": "Formar a matriz de Gram a partir das derivadas parciais para aproximar a Hessiana e avaliar a estabilidade do ajuste de curvas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo de ajuste não-linear e os dados",
                                  "subSteps": [
                                    "Defina o modelo não-linear y = f(x, θ), onde θ são os parâmetros a estimar.",
                                    "Colete ou gere dados de entrada x_i e observados y_i com ruído.",
                                    "Implemente uma função para calcular resíduos r_i = y_i - f(x_i, θ).",
                                    "Escolha valores iniciais θ_0 para os parâmetros.",
                                    "Estruture os dados em arrays ou vetores para computação numérica."
                                  ],
                                  "verification": "Verifique se os resíduos são calculados corretamente comparando com valores manuais para um ponto de dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy e SciPy; conjunto de dados exemplo (e.g., assentamento de fundações).",
                                  "tips": "Use valores iniciais razoáveis baseados em conhecimento do domínio para evitar convergência ruim.",
                                  "learningObjective": "Compreender a formulação do problema de ajuste não-linear e preparar dados para derivação.",
                                  "commonMistakes": "Ignorar unidades dos dados ou escolher θ_0 muito distantes da solução real."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as derivadas parciais e formar a matriz Jacobiana",
                                  "subSteps": [
                                    "Compute ∂f/∂θ_j para cada parâmetro θ_j e cada ponto de dado i.",
                                    "Use diferenciação numérica (forward/backward difference) ou analítica se possível.",
                                    "Monte a matriz J de dimensão (n_pontos x n_parâmetros) com J_{i,j} = ∂f/∂θ_j |_{x_i, θ_0}.",
                                    "Valide o Jacobiano com uma perturbação pequena nos parâmetros e verifique a aproximação.",
                                    "Armazene J em formato matricial para multiplicação eficiente."
                                  ],
                                  "verification": "Aplique a definição de derivada finita: |J numérico - J analítico| < 1e-6.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/NumPy para funções de derivada (scipy.misc.derivative ou autograd).",
                                  "tips": "Prefira derivadas analíticas para precisão em modelos complexos; numéricas para prototipagem rápida.",
                                  "learningObjective": "Dominar o cálculo do Jacobiano como base para aproximações da Hessiana.",
                                  "commonMistakes": "Erros de sinal nas derivadas ou confusão entre índices de linha/coluna em J."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz de Gram G = J^T J",
                                  "subSteps": [
                                    "Transpose a matriz J para obter J^T.",
                                    "Calcule o produto matricial G = J^T * J usando multiplicação otimizada.",
                                    "Confirme que G é simétrica: G == G^T.",
                                    "Verifique se G é positiva semi-definida computando autovalores mínimos >= 0.",
                                    "Salve G e seus dimensões (n_parâmetros x n_parâmetros)."
                                  ],
                                  "verification": "Teste simetria: np.allclose(G, G.T) == True; autovalores min >= -1e-10.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "NumPy para np.dot() ou @ operador; exemplo de dados com 50 pontos e 3 parâmetros.",
                                  "tips": "Use operações vetoriais para eficiência; evite loops explícitos em grandes datasets.",
                                  "learningObjective": "Construir corretamente a matriz de Gram como aproximação da Hessiana.",
                                  "commonMistakes": "Esquecer de transpor J ou usar multiplicação elemento-a-elemento (* em vez de dot)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a matriz de Gram para condicionamento e estabilidade",
                                  "subSteps": [
                                    "Calcule autovalores e autovetores de G usando decomposição espectral.",
                                    "Determine o número de condicionamento cond(G) = λ_max / λ_min.",
                                    "Identifique parâmetros mal condicionados (autovetores com λ pequeno).",
                                    "Interprete: cond < 10^4 indica bom condicionamento; reescale variáveis se necessário.",
                                    "Avalie estabilidade: sugira regularização se cond > 10^6."
                                  ],
                                  "verification": "Compare cond com valor teórico para modelo conhecido; trace(G) deve ser positivo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "SciPy.linalg.eig para autovalores; plotagem com Matplotlib para visualização.",
                                  "tips": "Visualize espectro de autovalores em log-scale para detectar gaps.",
                                  "learningObjective": "Interpretar análise de condicionamento para validar ajuste de curvas.",
                                  "commonMistakes": "Confundir λ_min com λ_max ou ignorar autovalores próximos a zero."
                                }
                              ],
                              "practicalExample": "Para dados de assentamento de fundações civis modelados por y = a * (1 - exp(-b*x)) + c, com θ = [a,b,c], compute J em θ_0 = [1,0.1,0], forme G e verifique cond(G) ≈ 150, indicando ajuste estável para previsão de deformações.",
                              "finalVerifications": [
                                "G é simétrica e positiva semi-definida (todos autovalores >= 0).",
                                "Número de condicionamento cond(G) calculado corretamente.",
                                "Jacobiano J tem dimensões corretas e derivadas precisas.",
                                "Análise identifica parâmetros correlacionados (via autovetores).",
                                "Sugestões de melhoria (e.g., reescalonamento) são válidas.",
                                "Código reproduzível gera G idêntica em múltiplas runs."
                              ],
                              "assessmentCriteria": [
                                "Precisão do Jacobiano (erro < 1e-5 vs. analítico).",
                                "Correção da construção de G (simetria e trace positivo).",
                                "Interpretação adequada do condicionamento (thresholds corretos).",
                                "Identificação de problemas de estabilidade com justificativa.",
                                "Eficiência computacional (tempo < 1s para 100 pontos).",
                                "Documentação clara do processo e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição espectral e propriedades de matrizes simétricas.",
                                "Cálculo Numérico: Diferenciação automática e aproximações da Hessiana.",
                                "Estatística: Análise de variância-covariância em regressão não-linear.",
                                "Programação: Otimização de código matricial em Python/NumPy."
                              ],
                              "realWorldApplication": "Em engenharia civil, analisar G em ajustes de curvas para modelar deformações em solos ou fadiga em concreto, garantindo que parâmetros estimados sejam estáveis para simulações de segurança estrutural e previsão de falhas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.3.3",
                            "name": "Validar o ajuste com métricas estatísticas",
                            "description": "Calcular R² ajustado, intervalos de confiança nos parâmetros e testes de significância para validar modelos não-lineares em dados reais de engenharia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular o R² Ajustado para avaliar o ajuste do modelo",
                                  "subSteps": [
                                    "Carregue os dados reais de engenharia e o modelo não-linear ajustado usando a biblioteca apropriada (ex: statsmodels em Python).",
                                    "Calcule o R² ordinário usando a fórmula: 1 - (SS_res / SS_tot), onde SS_res é a soma dos quadrados dos resíduos e SS_tot é a soma dos quadrados totais.",
                                    "Ajuste para o número de parâmetros: R²_aj = 1 - (1 - R²) * (n - 1) / (n - k - 1), onde n é o número de observações e k o número de parâmetros.",
                                    "Compare o R² ajustado com benchmarks típicos para dados de engenharia (ex: >0.85 para bons ajustes).",
                                    "Registre o valor e plote resíduos vs preditos para visual inspeção inicial."
                                  ],
                                  "verification": "Verifique se o R² ajustado foi calculado corretamente comparando com função built-in (ex: statsmodels summary) e se está entre 0 e 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com numpy, scipy, statsmodels; dados reais (ex: CSV de testes de creep em concreto); Jupyter Notebook.",
                                  "tips": "Sempre use R² ajustado em vez do ordinário para modelos não-lineares com múltiplos parâmetros para evitar superestimação.",
                                  "learningObjective": "Compreender e aplicar a penalização pelo número de parâmetros no R² para validação imparcial.",
                                  "commonMistakes": "Confundir R² ordinário com ajustado; ignorar n pequeno que inflaciona o valor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar Intervalos de Confiança para os Parâmetros do Modelo",
                                  "subSteps": [
                                    "Extraia os coeficientes estimados do modelo ajustado (ex: usando .params em statsmodels).",
                                    "Calcule os erros padrão dos parâmetros via matriz de covariância (ex: .cov_params()).",
                                    "Construa intervalos de confiança a 95% usando distribuição t de Student: param ± t_crit * SE, onde t_crit é do valor crítico da t-table.",
                                    "Verifique se os intervalos não incluem zero para parâmetros esperados positivos/negativos.",
                                    "Plote os intervalos em um gráfico de barras para visualização."
                                  ],
                                  "verification": "Confirme que os intervalos foram calculados corretamente reproduzindo com .conf_int() da biblioteca e interpretando largura (estreitos indicam precisão).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com statsmodels ou scipy.stats; tabela t de Student; dados do modelo ajustado.",
                                  "tips": "Use nível de confiança 95% padrão em engenharia; intervalos estreitos indicam boa precisão dos dados.",
                                  "learningObjective": "Calcular e interpretar intervalos de confiança para avaliar a precisão das estimativas paramétricas.",
                                  "commonMistakes": "Usar distribuição normal em vez de t para amostras pequenas; ignorar correlações entre parâmetros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Testes de Significância nos Parâmetros",
                                  "subSteps": [
                                    "Para cada parâmetro, calcule o estatístico t: t = coef / SE_coef.",
                                    "Obtenha o p-valor associado usando distribuição t com df = n - k - 1.",
                                    "Compare p-valores com α=0.05: rejeite H0 (parâmetro=0) se p < 0.05.",
                                    "Reporte valores t, p-valores e estrelas de significância (* para p<0.05, ** para p<0.01).",
                                    "Analise multicolinearidade se múltiplos p-valores altos (use VIF se necessário)."
                                  ],
                                  "verification": "Valide com summary do modelo (ex: statsmodels) mostrando p-valores corretos e decisões de significância consistentes.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Python statsmodels para t-tests automáticos; scipy.stats.t para manual; dados paramétricos.",
                                  "tips": "Foco em significância prática além estatística: parâmetros pequenos mas significativos podem ser irrelevantes.",
                                  "learningObjective": "Aplicar testes t para determinar se parâmetros são estatisticamente distintos de zero.",
                                  "commonMistakes": "Interpretar p-valor como probabilidade do parâmetro ser zero; múltiplos testes sem correção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Métricas e Concluir a Validação do Modelo",
                                  "subSteps": [
                                    "Compile R² ajustado, intervalos de confiança e p-valores em um relatório único.",
                                    "Avalie holisticamente: bom ajuste se R²_aj alto, intervalos estreitos e p-valores baixos.",
                                    "Compare com modelo baseline (ex: linear) usando teste F ou AIC.",
                                    "Documente limitações (ex: heteroscedasticidade nos resíduos).",
                                    "Decida: aceite, rejeite ou refine o modelo."
                                  ],
                                  "verification": "Crie tabela summary com todas métricas; verifique se conclusão é suportada por evidências quantitativas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Jupyter Notebook para relatório; matplotlib para gráficos; modelo ajustado.",
                                  "tips": "Use AIC/BIC para comparação de modelos; sempre cheque resíduos para pressupostos.",
                                  "learningObjective": "Sintetizar métricas estatísticas para uma decisão informada sobre validade do modelo.",
                                  "commonMistakes": "Ignorar violações de pressupostos (normalidade resíduos); superestimar significância sem contexto prático."
                                }
                              ],
                              "practicalExample": "Em dados reais de creep em concreto (deformação vs tempo de 50 amostras), ajuste um modelo exponencial não-linear. Calcule R²_aj=0.92, intervalos de confiança para taxa de creep (0.015 ± 0.002/dia), e p-valores <0.001 para ambos parâmetros, validando o modelo para previsão de deformações em vigas de ponte.",
                              "finalVerifications": [
                                "R² ajustado > 0.85 para dados de engenharia típicos.",
                                "95% intervalos de confiança não incluem zero para parâmetros relevantes.",
                                "Pelo menos 80% dos parâmetros com p-valor < 0.05.",
                                "Resíduos aleatórios sem padrões (gráfico Q-Q e resíduos vs preditos).",
                                "Comparação favorável com modelo linear (ΔAIC < -2).",
                                "Relatório documenta todas métricas com interpretações."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de R² ajustado, IC e p-valores (erro <1%).",
                                "Correta interpretação: distingue significância estatística de prática.",
                                "Uso adequado de software e visualizações claras.",
                                "Identificação de erros comuns e limitações do modelo.",
                                "Conclusão lógica baseada em evidências quantitativas.",
                                "Relatório completo e profissional."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência paramétrica e testes de hipóteses.",
                                "Programação: Manipulação de dados em Python/R para análise numérica.",
                                "Engenharia Mecânica: Modelagem de materiais com comportamento não-linear.",
                                "Matemática Aplicada: Otimização não-linear e análise de erros.",
                                "Gestão de Projetos: Validação de modelos preditivos para decisões de engenharia."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, como previsão de assentamento em fundações ou fadiga em estruturas de aço, essas métricas validam modelos para garantir segurança e otimizar designs, evitando falhas custosas em pontes ou barragens."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.3.4",
                            "name": "Implementar simulações Monte Carlo para incertezas",
                            "description": "Gerar números aleatórios para propagar incertezas nos parâmetros do ajuste não-linear, avaliando distribuições de resíduos e previsões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo base e estimativas de parâmetros",
                                  "subSteps": [
                                    "Carregue os dados experimentais (x, y) em um ambiente Python com NumPy e SciPy.",
                                    "Ajuste o modelo não-linear inicial usando scipy.optimize.curve_fit para obter parâmetros estimados e matriz de covariância.",
                                    "Extraia os valores nominais dos parâmetros e seus desvios padrão da diagonal da covariância.",
                                    "Defina a função do modelo não-linear (ex: exponencial ou polinomial).",
                                    "Visualize o ajuste inicial com matplotlib para confirmação."
                                  ],
                                  "verification": "Verifique se o ajuste inicial reproduz os dados com R² > 0.9 e plote o gráfico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "SciPy",
                                    "Matplotlib",
                                    "Dados experimentais em CSV"
                                  ],
                                  "tips": "Use p0 para chute inicial nos parâmetros para evitar convergência local.",
                                  "learningObjective": "Compreender a base do ajuste não-linear e extração de incertezas.",
                                  "commonMistakes": [
                                    "Ignorar covariância correlacionada entre parâmetros.",
                                    "Chute inicial ruim levando a falha de convergência.",
                                    "Não normalizar dados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir distribuições probabilísticas de incerteza",
                                  "subSteps": [
                                    "Assuma distribuição normal multivariada para parâmetros usando a matriz de covariância.",
                                    "Se covariâncias forem desprezíveis, use distribuições independentes normais para cada parâmetro.",
                                    "Defina o número de simulações Monte Carlo (ex: N=10000).",
                                    "Gere a matriz de covariância Cholesky para amostragem eficiente (numpy.linalg.cholesky).",
                                    "Teste a geração de 100 amostras para validar médias e desvios."
                                  ],
                                  "verification": "Calcule média e desvio das amostras geradas e compare com valores nominais (erro < 5%).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "NumPy",
                                    "SciPy.stats"
                                  ],
                                  "tips": "Use multivariate_normal para simplicidade se covariâncias forem pequenas.",
                                  "learningObjective": "Modelar realisticamente as incertezas paramétricas.",
                                  "commonMistakes": [
                                    "Usar desvios independentes quando há correlação.",
                                    "N muito pequeno levando a variância alta.",
                                    "Distribuição errada (ex: uniforme em vez de normal)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop de simulação Monte Carlo",
                                  "subSteps": [
                                    "Gere N conjuntos de parâmetros amostrados.",
                                    "Para cada conjunto, compute o modelo ajustado nos pontos x dos dados.",
                                    "Calcule resíduos como y_dados - y_modelo para cada simulação.",
                                    "Armazene resíduos e parâmetros em arrays NumPy para eficiência.",
                                    "Monitore progresso com tqdm para loops longos."
                                  ],
                                  "verification": "Execute 1000 simulações e verifique tempo de execução < 10s e shape dos arrays.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "NumPy",
                                    "tqdm (opcional)"
                                  ],
                                  "tips": "Vetorize computações onde possível para acelerar.",
                                  "learningObjective": "Executar propagação de incertezas via simulação.",
                                  "commonMistakes": [
                                    "Loop lento sem vetorização.",
                                    "Overflow em funções não-lineares.",
                                    "Não armazenar todos os resíduos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar previsões e analisar distribuições",
                                  "subSteps": [
                                    "Defina pontos de previsão (ex: extrapolação além dos dados).",
                                    "Para cada simulação, compute previsões nos pontos novos.",
                                    "Calcule estatísticas: média, desvios, percentis (5%, 95%) para resíduos e previsões.",
                                    "Plote histogramas de resíduos por ponto e bandas de confiança nas previsões.",
                                    "Avalie normalidade dos resíduos com teste Shapiro-Wilk."
                                  ],
                                  "verification": "Histograma de resíduos deve ser centrado em zero com variância consistente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matplotlib",
                                    "SciPy.stats"
                                  ],
                                  "tips": "Use np.percentile para intervalos de confiança rápidos.",
                                  "learningObjective": "Interpretar resultados da propagação de incertezas.",
                                  "commonMistakes": [
                                    "Confundir resíduos com erros absolutos.",
                                    "Ignorar heterocedasticidade.",
                                    "Bandas de confiança muito estreitas por N baixo."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Visualizar e validar resultados finais",
                                  "subSteps": [
                                    "Crie plots: resíduos vs x com bandas, distribuições paramétricas, QQ-plot.",
                                    "Compare distribuições de resíduos originais vs simulados.",
                                    "Calcule métricas como média absoluta de desvios e cobertura de intervalos.",
                                    "Salve resultados em JSON/CSV e plots em PDF.",
                                    "Documente sensibilidade a N e suposições de distribuição."
                                  ],
                                  "verification": "Intervalos de confiança cobrem 90% dos dados simulados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matplotlib",
                                    "Seaborn (opcional)",
                                    "Pandas"
                                  ],
                                  "tips": "Use subplots para múltiplas visualizações compactas.",
                                  "learningObjective": "Comunicar incertezas de forma visual e quantitativa.",
                                  "commonMistakes": [
                                    "Plots sem legendas/escalas.",
                                    "Sobrepor muitas curvas sem transparência.",
                                    "Não testar convergência com N crescente."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um teste de deformação de concreto sob carga, ajuste um modelo exponencial y = a*(1-exp(-b*x)) com parâmetros a=10±0.5, b=0.1±0.01. Gere 10k simulações para propagar incertezas, obtendo distribuição de resíduos e bandas de previsão para cargas até 2x o teste máximo, avaliando risco de falha.",
                              "finalVerifications": [
                                "Distribuição de parâmetros simulados coincide com nominais (teste KS p>0.05).",
                                "Resíduos simulados têm média zero e variância similar à observada.",
                                "Bandas de confiança de 95% cobrem dados de validação.",
                                "Tempo de simulação escalável para N=50k.",
                                "Código reproduzível com seed fixo.",
                                "Visualizações mostram heterocedasticidade se presente."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação de amostragem multivariada (20%).",
                                "Propagação precisa de incertezas em resíduos/previsões (25%).",
                                "Análise estatística robusta com percentis e testes (20%).",
                                "Visualizações claras e interpretáveis (15%).",
                                "Eficiência computacional e documentação (10%).",
                                "Interpretação correta de resultados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Distribuições multivariadas e testes de normalidade.",
                                "Programação Computacional: Vetorização NumPy e otimização de loops.",
                                "Análise Numérica: Propagação de erros e condicionamento.",
                                "Engenharia Civil: Modelagem de materiais e previsão estrutural.",
                                "Visualização de Dados: Histogramas, QQ-plots e bandas de confiança."
                              ],
                              "realWorldApplication": "Na engenharia civil, simulações Monte Carlo avaliam incertezas em ajustes de curvas para prever deformações em vigas ou fadiga em cabos de pontes, permitindo dimensionamento seguro com quantificação de riscos probabilísticos em projetos sob normas como ABNT NBR."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.8",
                "name": "Redes Neurais Artificiais, Geração de Números Aleatórios e Método de Monte Carlo",
                "description": "Introdução a redes neurais, geração de números pseudo-aleatórios e simulações via Monte Carlo.",
                "totalSkills": 64,
                "atomicTopics": [
                  {
                    "id": "10.1.8.1",
                    "name": "Estrutura Básica de Redes Neurais Artificiais",
                    "description": "Componentes fundamentais como neurônios artificiais, camadas de entrada, ocultas e saída.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.1.1",
                        "name": "Neurônio Artificial",
                        "description": "Unidade computacional fundamental de uma rede neural artificial, responsável por receber entradas, aplicar pesos sinápticos, somar ponderadamente e aplicar uma função de ativação para gerar uma saída.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.1.1",
                            "name": "Identificar componentes do neurônio artificial",
                            "description": "Reconhecer e descrever os elementos essenciais de um neurônio artificial, incluindo entradas (x_i), pesos sinápticos (w_i), bias (b), soma ponderada (z = Σ w_i x_i + b) e função de ativação (f(z)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Entradas (x_i)",
                                  "subSteps": [
                                    "Defina entradas como variáveis de entrada que representam dados ou sinais recebidos pelo neurônio.",
                                    "Identifique exemplos de entradas no contexto de engenharia civil, como valores de carga, tensão ou variáveis ambientais.",
                                    "Explique que entradas podem ser um vetor com múltiplos valores (x1, x2, ..., xn).",
                                    "Discuta como entradas são normalizadas ou pré-processadas.",
                                    "Desenhe um diagrama simples mostrando entradas chegando ao neurônio."
                                  ],
                                  "verification": "Liste pelo menos 3 exemplos de entradas relevantes para problemas de engenharia civil e desenhe-as em um diagrama.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Imagem de neurônio artificial básico",
                                    "Vídeo introdutório sobre entradas em redes neurais"
                                  ],
                                  "tips": "Visualize entradas como 'sinais elétricos' semelhantes aos dendritos em neurônios biológicos.",
                                  "learningObjective": "Reconhecer entradas como os dados iniciais processados pelo neurônio artificial.",
                                  "commonMistakes": [
                                    "Confundir entradas com saídas do neurônio",
                                    "Ignorar que entradas podem ser múltiplas e vetoriais",
                                    "Não considerar pré-processamento de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Pesos Sinápticos (w_i)",
                                  "subSteps": [
                                    "Defina pesos como fatores de importância que modulam o impacto de cada entrada.",
                                    "Explique que pesos são ajustados durante o treinamento da rede neural.",
                                    "Discuta pesos positivos (amplificam) versus negativos (inibem).",
                                    "Calcule um exemplo simples: impacto de x1 com w1=0.5.",
                                    "Desenhe setas com pesos no diagrama do neurônio."
                                  ],
                                  "verification": "Anotar a fórmula de multiplicação entrada-peso e calcular para um exemplo dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Diagrama em branco do neurônio",
                                    "Tabela de exemplos de pesos"
                                  ],
                                  "tips": "Pense nos pesos como 'forças de conexão' ajustáveis, como coeficientes em equações de regressão.",
                                  "learningObjective": "Descrever o papel dos pesos na ponderação das entradas.",
                                  "commonMistakes": [
                                    "Confundir pesos com entradas",
                                    "Esquecer que pesos são aprendidos",
                                    "Não diferenciar sinal dos pesos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender o Bias (b)",
                                  "subSteps": [
                                    "Defina bias como um termo de intercepto que permite ativação mesmo sem entradas.",
                                    "Explique sua importância para não-linearidades e flexibilidade do modelo.",
                                    "Compare com equação de reta y = mx + b, onde b é o bias.",
                                    "Inclua bias no diagrama, mostrando adição após soma ponderada.",
                                    "Teste: o que acontece se bias=0?"
                                  ],
                                  "verification": "Explicar em uma frase por que o bias é essencial e modificá-lo em um diagrama.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico de linha com bias",
                                    "Exemplos numéricos de bias em engenharia"
                                  ],
                                  "tips": "Bias evita que o neurônio seja 'preguiçoso' quando entradas são zero.",
                                  "learningObjective": "Reconhecer o bias como ajuste independente das entradas.",
                                  "commonMistakes": [
                                    "Omitir bias na soma",
                                    "Confundir com pesos",
                                    "Pensar que bias é sempre positivo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a Soma Ponderada (z = Σ w_i x_i + b)",
                                  "subSteps": [
                                    "Escreva a fórmula completa: z = (w1*x1 + w2*x2 + ... + wn*xn) + b.",
                                    "Realize cálculo passo a passo para entradas dadas.",
                                    "Verifique unidades e escalas no contexto de engenharia civil.",
                                    "Desenhe a soma como um nó central no diagrama.",
                                    "Compare z com soma linear em problemas de otimização."
                                  ],
                                  "verification": "Calcular z corretamente para um conjunto de valores fornecidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou planilha Excel",
                                    "Exemplos numéricos impressos",
                                    "Diagrama atualizado"
                                  ],
                                  "tips": "Some pesos*entradas primeiro, depois adicione bias – ordem importa para depuração.",
                                  "learningObjective": "Executar e entender o cálculo da soma ponderada.",
                                  "commonMistakes": [
                                    "Esquecer o bias na soma",
                                    "Erro aritmético em multiplicações",
                                    "Não usar somatório Σ corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explorar a Função de Ativação (f(z))",
                                  "subSteps": [
                                    "Defina função de ativação como transformadora não-linear de z em saída.",
                                    "Descreva exemplos: sigmoide, ReLU, tanh.",
                                    "Aplique f(z) a um z calculado, e.g., sigmoide(z) = 1/(1+e^{-z}).",
                                    "Explique por que não-linearidade é crucial para redes profundas.",
                                    "Complete o diagrama com saída f(z)."
                                  ],
                                  "verification": "Calcular saída f(z) para um z dado e explicar seu papel.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de funções de ativação",
                                    "Gráficos de sigmoide/ReLU",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Sigmoide é comum para probabilidades em predições de engenharia.",
                                  "learningObjective": "Identificar e aplicar funções de ativação ao resultado da soma.",
                                  "commonMistakes": [
                                    "Usar identidade linear f(z)=z",
                                    "Confundir com soma ponderada",
                                    "Ignorar não-linearidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um problema de engenharia civil, entradas x1=2.5 (carga em kN), x2=1.2 (velocidade do vento m/s). Pesos w1=0.7, w2=-0.4, bias b=0.1. Calcule z = (0.7*2.5 + (-0.4)*1.2) + 0.1 = 1.75 - 0.48 + 0.1 = 1.37. Aplique sigmoide: f(1.37) ≈ 0.75, interpretado como 75% chance de deformação aceitável.",
                              "finalVerifications": [
                                "Desenhar diagrama completo do neurônio com todos componentes rotulados.",
                                "Calcular z e f(z) corretamente para 2 exemplos numéricos.",
                                "Explicar verbalmente o fluxo: entradas → pesos → soma + bias → ativação.",
                                "Identificar componentes em um diagrama dado sem rótulos.",
                                "Discutir remoção de um componente e seu impacto.",
                                "Listar 3 aplicações em engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e rotulagem de todos os 5 componentes.",
                                "Correção matemática nos cálculos de z e f(z).",
                                "Clareza e completude do diagrama desenhado.",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Relevância dos exemplos ao contexto de engenharia civil.",
                                "Identificação correta de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (produtos escalares) e funções não-lineares.",
                                "Biologia: Analogia com neurônios biológicos (dendritos, sinapses, axônio).",
                                "Programação: Implementação em Python com NumPy para simular neurônio.",
                                "Física: Modelagem de forças e somas vetoriais em estruturas.",
                                "Estatística: Normalização de entradas e interpretação probabilística de saídas."
                              ],
                              "realWorldApplication": "Na engenharia civil, componentes do neurônio artificial são fundamentais em redes neurais para prever falhas em pontes (entradas: cargas, vento, fadiga; pesos/bias ajustados por dados históricos; ativação para decisão binária de 'seguro/insseguro'), otimizando projetos e reduzindo custos com simulações preditivas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.1.2",
                            "name": "Calcular a saída de um neurônio",
                            "description": "Realizar o cálculo passo a passo da saída de um neurônio artificial dado um conjunto de entradas, pesos e bias, aplicando funções de ativação como sigmoide ou ReLU.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e preparar os componentes do neurônio",
                                  "subSteps": [
                                    "Liste todas as entradas do neurônio (x1, x2, ..., xn).",
                                    "Liste os pesos correspondentes a cada entrada (w1, w2, ..., wn).",
                                    "Identifique o valor do bias (b).",
                                    "Escolha e anote a função de ativação a ser usada (ex: ReLU ou sigmoide).",
                                    "Verifique se o número de entradas e pesos coincide."
                                  ],
                                  "verification": "Confirme que todos os valores estão anotados corretamente e pareados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Exemplo de dados de entrada"
                                  ],
                                  "tips": "Sempre use valores decimais precisos para evitar erros de arredondamento precoce.",
                                  "learningObjective": "Compreender os inputs necessários para o cálculo de um neurônio artificial.",
                                  "commonMistakes": [
                                    "Confundir pesos com entradas",
                                    "Esquecer o bias",
                                    "Usar função de ativação errada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a soma ponderada (z)",
                                  "subSteps": [
                                    "Calcule o produto de cada entrada pelo seu peso correspondente (xi * wi).",
                                    "Some todos os produtos obtidos (∑(xi * wi)).",
                                    "Adicione o bias à soma (z = ∑(xi * wi) + b).",
                                    "Registre o valor exato de z com pelo menos 4 casas decimais.",
                                    "Verifique o cálculo multiplicando e somando novamente."
                                  ],
                                  "verification": "z deve ser um número escalar; teste com soma manual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para cálculos intermediários"
                                  ],
                                  "tips": "Faça os cálculos em uma tabela para visualizar pares xi-wi claramente.",
                                  "learningObjective": "Dominar o cálculo da combinação linear das entradas ponderadas pelo bias.",
                                  "commonMistakes": [
                                    "Erro aritmético em multiplicações",
                                    "Esquecer de adicionar o bias",
                                    "Arredondar prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a função de ativação",
                                  "subSteps": [
                                    "Para ReLU: se z > 0, saída = z; senão, saída = 0.",
                                    "Para sigmoide: saída = 1 / (1 + e^(-z)), onde e é a base do log natural.",
                                    "Calcule o valor da saída usando fórmula exata ou aproximada.",
                                    "Use calculadora para funções exponenciais se necessário.",
                                    "Anote a fórmula usada e o resultado final."
                                  ],
                                  "verification": "Compare com calculadora online ou software para confirmação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabela de funções de ativação impressa"
                                  ],
                                  "tips": "Memorize: ReLU é simples para valores positivos; sigmoide comprime entre 0 e 1.",
                                  "learningObjective": "Aplicar corretamente funções de ativação comuns em neurônios.",
                                  "commonMistakes": [
                                    "Confundir ReLU com sigmoide",
                                    "Erro no cálculo exponencial",
                                    "Aplicar ativação antes da soma"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar a saída do neurônio",
                                  "subSteps": [
                                    "Recalcule z e aplique ativação para validação cruzada.",
                                    "Interprete o resultado: para ReLU, zero indica inatividade; sigmoide próximo de 1 é alta ativação.",
                                    "Discuta o impacto dos pesos (positivos aumentam ativação, negativos suprimem).",
                                    "Registre a saída final em contexto do exemplo.",
                                    "Teste sensibilidade alterando um peso e recalculando."
                                  ],
                                  "verification": "Saída consistente em recálculos independentes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel para anotações",
                                    "Software opcional como Python/Jupyter"
                                  ],
                                  "tips": "Pense no neurônio como um 'interruptor' biológico: soma decide se 'dispara'.",
                                  "learningObjective": "Interpretar o significado da saída no contexto de uma rede neural.",
                                  "commonMistakes": [
                                    "Ignorar interpretação",
                                    "Não validar cálculos",
                                    "Confundir saída com z"
                                  ]
                                }
                              ],
                              "practicalExample": "Entradas: x = [1.0, 0.5]; Pesos: w = [0.8, -0.2]; Bias: b = 0.1; Ativação: ReLU. Cálculo: z = (1*0.8) + (0.5*-0.2) + 0.1 = 0.8 - 0.1 + 0.1 = 0.8; Saída = ReLU(0.8) = 0.8.",
                              "finalVerifications": [
                                "Cálculo de z correto com valores fornecidos.",
                                "Aplicação precisa da função de ativação escolhida.",
                                "Interpretação coerente da saída (ativa/inativa).",
                                "Validação por recálculo ou ferramenta externa.",
                                "Identificação de erros comuns evitados.",
                                "Teste de sensibilidade com variação de parâmetros."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (erro < 0.01).",
                                "Correta identificação de todos componentes (entradas, pesos, bias, ativação).",
                                "Uso adequado de subpassos em cada etapa.",
                                "Interpretação qualitativa da saída.",
                                "Aplicação em exemplo prático sem erros.",
                                "Tempo respeitado e eficiência demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e funções não-lineares.",
                                "Programação: Implementação em Python (NumPy para vetores).",
                                "Estatística: Probabilidades em ativações sigmoide.",
                                "Engenharia Civil: Modelagem preditiva de cargas estruturais.",
                                "Física: Analogia com neurônios biológicos e sinais elétricos."
                              ],
                              "realWorldApplication": "Em engenharia civil, calcular saídas de neurônios em redes para prever falhas em estruturas, como deformações em pontes sob cargas variáveis, otimizando manutenção preventiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.1.3",
                            "name": "Comparar funções de ativação comuns",
                            "description": "Explicar e comparar funções de ativação como step, sigmoide, tanh, ReLU e softmax, destacando suas características, vantagens e aplicações em problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos básicos de funções de ativação",
                                  "subSteps": [
                                    "Defina o que é uma função de ativação e seu papel no neurônio artificial.",
                                    "Liste as funções comuns: step, sigmoide, tanh, ReLU e softmax.",
                                    "Explique a importância da não-linearidade para redes neurais.",
                                    "Identifique o problema de gradiente desaparecente em funções saturadas.",
                                    "Pesquise fórmulas matemáticas básicas de cada função."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando o conceito e liste as funções com fórmulas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notebook com Jupyter ou Google Colab",
                                    "Biblioteca Matplotlib e NumPy",
                                    "Artigo introdutório sobre neurônios artificiais"
                                  ],
                                  "tips": "Sempre associe o conceito a um diagrama simples de neurônio para fixar a ideia.",
                                  "learningObjective": "Entender o fundamento e a necessidade de funções de ativação em redes neurais.",
                                  "commonMistakes": [
                                    "Confundir função de ativação com função de perda",
                                    "Ignorar o impacto na retropropagação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar funções step, sigmoide e tanh",
                                  "subSteps": [
                                    "Implemente e plote a função step (threshold em 0).",
                                    "Calcule e visualize a sigmoide: f(x) = 1/(1 + e^{-x}), range [0,1].",
                                    "Analise tanh: f(x) = (e^x - e^{-x})/(e^x + e^{-x}), range [-1,1].",
                                    "Discuta derivadas e saturação nessas funções.",
                                    "Compare ranges de saída e centralização em zero."
                                  ],
                                  "verification": "Gere gráficos das três funções e suas derivadas em um notebook.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy, Matplotlib e SciPy",
                                    "Referência: 'Deep Learning' de Goodfellow (cap. 6)"
                                  ],
                                  "tips": "Use x de -10 a 10 para visualizar saturação claramente.",
                                  "learningObjective": "Dominar implementação e características das funções clássicas saturadas.",
                                  "commonMistakes": [
                                    "Esquecer de plotar derivadas",
                                    "Confundir range de sigmoide com tanh"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar ReLU e softmax",
                                  "subSteps": [
                                    "Implemente ReLU: max(0, x) e variantes como Leaky ReLU.",
                                    "Explique vantagens: ausência de saturação, gradientes simples.",
                                    "Implemente softmax para vetores: exp(x_i)/sum(exp(x)).",
                                    "Teste softmax em um vetor de logits de exemplo.",
                                    "Discuta uso em saídas de classificação multi-classe."
                                  ],
                                  "verification": "Crie código que aplica ReLU e softmax a dados de entrada e plote resultados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Bibliotecas NumPy e Matplotlib"
                                  ],
                                  "tips": "Teste ReLU com valores negativos para ver 'morte de neurônios'.",
                                  "learningObjective": "Compreender funções modernas e seu impacto no treinamento.",
                                  "commonMistakes": [
                                    "Aplicar softmax em valores individuais ao invés de vetores",
                                    "Ignorar dying ReLU"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar funções e destacar vantagens/desvantagens",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: range, derivada, saturação, vanishing gradient.",
                                    "Liste vantagens: step (simples), sigmoide (probabilística), ReLU (rápida).",
                                    "Descreva desvantagens: step (não diferenciável), tanh (vanishing).",
                                    "Discuta escolhas por camada: ReLU em hidden, softmax em output.",
                                    "Avalie computational cost aproximado."
                                  ],
                                  "verification": "Produza uma tabela Markdown ou Pandas DataFrame com a comparação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha ou Pandas para tabela",
                                    "Gráficos comparativos"
                                  ],
                                  "tips": "Ordene a tabela por popularidade atual (ReLU > tanh > etc.).",
                                  "learningObjective": "Capacitar-se a selecionar funções baseadas em critérios.",
                                  "commonMistakes": [
                                    "Generalizar desvantagens sem contexto de uso",
                                    "Omitir aplicações específicas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em contextos de engenharia civil",
                                  "subSteps": [
                                    "Identifique problemas: previsão de deformações (regressão com ReLU), classificação de falhas (softmax).",
                                    "Simule um dataset simples de cargas em vigas e teste ativações.",
                                    "Compare desempenho fictício: ReLU converge mais rápido em predições estruturais.",
                                    "Discuta hibridizações em NN para análise sísmica.",
                                    "Reflita sobre limitações em dados escassos de eng. civil."
                                  ],
                                  "verification": "Escreva um parágrafo ligando cada função a um problema real de eng. civil.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Dataset sintético de engenharia (ex: vigas.csv)",
                                    "TensorFlow/Keras opcional"
                                  ],
                                  "tips": "Use exemplos reais como previsão de assentamento de solos.",
                                  "learningObjective": "Conectar teoria a aplicações práticas na área.",
                                  "commonMistakes": [
                                    "Forçar aplicações irrelevantes",
                                    "Ignorar dados ruidosos em eng. civil"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de análise estrutural, use ReLU em camadas ocultas de uma NN para prever deformações em uma viga sob cargas variáveis (input: carga, material; output: deformação). Compare com sigmoide: ReLU treina 2x mais rápido sem vanishing gradient. Para classificar tipos de rachaduras em imagens de barragens (step, fina, crítica), aplique softmax na saída para probabilidades, alcançando 92% de acurácia em inspeções automatizadas.",
                              "finalVerifications": [
                                "Pode plotar e descrever curvas de todas as 5 funções corretamente.",
                                "Identifica vanishing gradient em sigmoide/tanh e solução com ReLU.",
                                "Explica por que softmax é ideal para classificação multi-classe em eng. civil.",
                                "Lista pelo menos 3 vantagens/desvantagens por função.",
                                "Sugere ativação apropriada para regressão vs. classificação em estruturas.",
                                "Implementa código funcional para pelo menos 3 funções."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas e gráficos (25%)",
                                "Profundidade da comparação e tabela (25%)",
                                "Relevância de aplicações em eng. civil (20%)",
                                "Qualidade dos códigos e visualizações (15%)",
                                "Clareza na explicação de erros comuns (10%)",
                                "Criatividade em exemplos práticos (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: derivadas e funções não-lineares (cálculo diferencial).",
                                "Programação: implementação numérica em Python/NumPy.",
                                "Estatística: interpretação de probabilidades via softmax.",
                                "Física/Eng. Civil: modelagem de comportamentos não-lineares em materiais."
                              ],
                              "realWorldApplication": "Na engenharia civil, ReLU acelera o treinamento de NNs para previsão de colapsos em pontes sob sismos, sigmoide modela probabilidades de falha em fundações, e softmax classifica defeitos em inspeções drone de barragens, otimizando manutenção preditiva e reduzindo custos em 30%."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.1.2",
                        "name": "Camada de Entrada",
                        "description": "Primeira camada da rede neural que recebe os dados de entrada do problema e os transmite diretamente para as camadas ocultas, sem processamento adicional além de possível normalização.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.2.1",
                            "name": "Representar dados na camada de entrada",
                            "description": "Definir o vetor de entrada para uma rede neural em contextos de engenharia civil, como vetores de cargas estruturais ou parâmetros geotécnicos, e entender sua dimensionalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Camada de Entrada em Redes Neurais",
                                  "subSteps": [
                                    "Estude a definição de camada de entrada como o primeiro estágio onde dados brutos são recebidos pela rede neural.",
                                    "Aprenda que o vetor de entrada é uma representação matricial unidimensional dos dados de entrada.",
                                    "Identifique a importância da dimensionalidade: número de neurônios na camada de entrada igual ao tamanho do vetor.",
                                    "Revise exemplos simples de vetores de entrada em contextos gerais, como imagens ou séries temporais.",
                                    "Discuta como dados de engenharia civil, como cargas ou parâmetros geotécnicos, se encaixam nesse modelo."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e crie um diagrama simples da camada de entrada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de redes neurais, slides sobre estrutura de RN, papel e caneta para diagrama.",
                                  "tips": "Use analogias como 'porta de entrada de uma casa' para visualizar o fluxo de dados.",
                                  "learningObjective": "Entender o papel e a estrutura básica da camada de entrada em redes neurais.",
                                  "commonMistakes": "Confundir dimensionalidade do vetor com número de camadas ocultas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Coletar Dados Relevantes de Engenharia Civil",
                                  "subSteps": [
                                    "Liste variáveis típicas: cargas axiais, momentos fletores, parâmetros geotécnicos como coesão e ângulo de atrito.",
                                    "Selecione um problema específico, ex: análise de viga sob carga distribuída.",
                                    "Colete dados de fontes reais ou simuladas: relatórios de projeto, bancos de dados geotécnicos.",
                                    "Registre unidades e faixas de valores para cada variável.",
                                    "Crie uma tabela com 5-10 amostras de dados para prática."
                                  ],
                                  "verification": "Apresente uma tabela com dados coletados, incluindo fontes e unidades.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilhas Excel, dados de projetos civis (ex: ABNT normas), software como MATLAB ou Python.",
                                  "tips": "Priorize dados com variação realista para simular cenários de engenharia.",
                                  "learningObjective": "Selecionar dados contextuais de engenharia civil adequados para vetores de entrada.",
                                  "commonMistakes": "Incluir variáveis irrelevantes ou ignorar unidades inconsistentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estruturar Dados em Vetor de Entrada e Definir Ordem",
                                  "subSteps": [
                                    "Ordene as variáveis logicamente: ex: [carga_axial, momento, módulo_elasticidade, comprimento].",
                                    "Converta a tabela em vetores: cada linha vira um vetor de entrada.",
                                    "Implemente em código: use NumPy para criar arrays.",
                                    "Visualize vetores com print ou plot para inspecionar estrutura.",
                                    "Ajuste ordem para consistência em todo dataset."
                                  ],
                                  "verification": "Gere e exiba 3 vetores de exemplo em código Python.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python com NumPy/Pandas, Jupyter Notebook, dados da tabela anterior.",
                                  "tips": "Mantenha ordem fixa para evitar mismatches durante treinamento.",
                                  "learningObjective": "Transformar dados tabulares em vetores de entrada padronizados.",
                                  "commonMistakes": "Alterar ordem entre amostras ou usar índices errados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Normalizar Dados e Verificar Dimensionalidade",
                                  "subSteps": [
                                    "Aplique normalização Min-Max ou Z-score para escalar features entre 0-1 ou média 0.",
                                    "Calcule dimensionalidade: len(vetor) define neurônios de entrada.",
                                    "Verifique consistência: todos vetores têm mesmo tamanho.",
                                    "Teste com dataset completo e ajuste outliers.",
                                    "Documente processo de normalização para reprodutibilidade."
                                  ],
                                  "verification": "Execute script que normaliza dados e imprime estatísticas pré/pós (média, std).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com Scikit-learn (para normalização), dados normalizados anteriores.",
                                  "tips": "Use funções prontas como MinMaxScaler para eficiência.",
                                  "learningObjective": "Preparar vetores normalizados e compreender impacto na dimensionalidade.",
                                  "commonMistakes": "Esquecer normalização, levando a dominância de features com escalas maiores."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar Representação Final da Camada de Entrada",
                                  "subSteps": [
                                    "Simule feedforward inicial com pesos aleatórios para testar entrada.",
                                    "Compare dimensionalidade com arquitetura da rede proposta.",
                                    "Analise correlações entre features para refinar seleção.",
                                    "Crie um pipeline completo de preprocessamento.",
                                    "Teste com dados de validação independentes."
                                  ],
                                  "verification": "Desenvolva um notebook completo com entrada validada e saída simulada.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "TensorFlow/Keras para simulação, notebook Jupyter completo.",
                                  "tips": "Salve preprocessador treinado para uso futuro no treinamento.",
                                  "learningObjective": "Validar integralmente a representação de dados na camada de entrada.",
                                  "commonMistakes": "Ignorar multicolinearidade entre features geotécnicas."
                                }
                              ],
                              "practicalExample": "Para análise de uma laje de concreto armado: vetor de entrada = [carga_viva (kN/m²), espessura (m), fy (MPa), fc (MPa), vão (m)]. Normalizado: [0.6, 0.15, 0.8, 0.7, 0.5]. Dimensionalidade: 5 neurônios na entrada para prever deflexão máxima.",
                              "finalVerifications": [
                                "Todos vetores têm dimensionalidade consistente (ex: 5 features).",
                                "Dados normalizados estão em faixa [0,1] ou Z-score.",
                                "Ordem das features é documentada e fixa.",
                                "Estatísticas pré/pós-normalização mostram escalas uniformes.",
                                "Simulação de feedforward roda sem erros de shape.",
                                "Pipeline é reproduzível com seed fixo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção de features relevantes (80%+ adequação contextual).",
                                "Corretude da normalização (erro < 1e-3 em escalas).",
                                "Consistência dimensional em todo dataset.",
                                "Clareza na documentação de processo e código.",
                                "Eficiência do pipeline (tempo de preprocess < 1s para 1000 amostras).",
                                "Validação com exemplo real de engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (vetores e matrizes).",
                                "Programação: Manipulação de arrays em Python/NumPy.",
                                "Estatística: Normalização e análise descritiva de dados.",
                                "Engenharia de Materiais: Parâmetros geotécnicos e mecânicos."
                              ],
                              "realWorldApplication": "Em projetos de fundações, representar parâmetros geotécnicos (coesão, φ) e cargas como vetor de entrada para RN prever capacidade de carga, otimizando dimensionamento e reduzindo custos em 15-20% via simulações precisas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.2.2",
                            "name": "Aplicar normalização de entradas",
                            "description": "Implementar técnicas de normalização (min-max ou z-score) nos dados da camada de entrada para melhorar a convergência do treinamento da rede neural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Normalização Min-Max e Z-Score",
                                  "subSteps": [
                                    "Estude a fórmula de normalização Min-Max: X_norm = (X - min) / (max - min)",
                                    "Estude a fórmula Z-Score: X_norm = (X - mean) / std",
                                    "Compare quando usar cada uma: Min-Max para dados limitados, Z-Score para distribuições gaussianas",
                                    "Analise exemplos numéricos simples com conjuntos de dados de 5-10 valores",
                                    "Discuta impactos na convergência de gradientes em redes neurais"
                                  ],
                                  "verification": "Resuma as diferenças e fórmulas em um documento ou notebook, confirmando com cálculos manuais corretos",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notebook Jupyter",
                                    "Biblioteca NumPy",
                                    "Documentação Scikit-learn sobre preprocessors"
                                  ],
                                  "tips": "Visualize distribuições antes/depois com histogramas para intuição",
                                  "learningObjective": "Dominar as fórmulas matemáticas e critérios de escolha entre Min-Max e Z-Score",
                                  "commonMistakes": [
                                    "Confundir Min-Max com escala 0-1 sem subtrair min",
                                    "Esquecer de calcular std corretamente no Z-Score"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Analisar o Conjunto de Dados de Entrada",
                                  "subSteps": [
                                    "Carregue dados de entrada relevantes (ex: medidas de deformação em estruturas civis)",
                                    "Calcule estatísticas descritivas: min, max, mean, std usando NumPy ou Pandas",
                                    "Identifique outliers e decida sobre tratamento (clipping ou remoção)",
                                    "Divida dados em train/test para validação futura",
                                    "Plote distribuições originais para baseline"
                                  ],
                                  "verification": "Gere relatório com estatísticas e plots confirmando valores corretos (ex: mean ≈ valor esperado)",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pandas",
                                    "Matplotlib/Seaborn",
                                    "Dataset de exemplo em CSV (ex: dados sensores civis)"
                                  ],
                                  "tips": "Use df.describe() para estatísticas rápidas; sempre verifique shape dos dados",
                                  "learningObjective": "Preparar dados de forma reprodutível e analisar pré-requisitos para normalização",
                                  "commonMistakes": [
                                    "Ignorar NaNs ou infs nos dados",
                                    "Não separar train/test antes de calcular stats (data leakage)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Normalização nos Dados",
                                  "subSteps": [
                                    "Aplique Min-MaxScaler ou StandardScaler do Scikit-learn nos dados de treino",
                                    "Calcule transformadores FIT apenas no treino e aplique em train/test",
                                    "Implemente manualmente com NumPy para validação (opcional)",
                                    "Verifique ranges: Min-Max [0,1], Z-Score mean~0 std~1",
                                    "Salve o scaler para uso futuro em produção"
                                  ],
                                  "verification": "Compare dados normalizados vs originais; confirme ranges e stats com asserts ou plots",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Scikit-learn (preprocessing)",
                                    "NumPy",
                                    "Joblib para salvar scaler"
                                  ],
                                  "tips": "Sempre fit no train, transform em ambos; use pipeline para automação",
                                  "learningObjective": "Implementar normalização de forma escalável e livre de vazamento de dados",
                                  "commonMistakes": [
                                    "Fit no dataset completo",
                                    "Aplicar scaler diferente em train/test"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Normalização na Rede Neural e Avaliar Convergência",
                                  "subSteps": [
                                    "Incorpore scaler na pipeline de dados para a camada de entrada da RNA",
                                    "Treine duas RNs idênticas: uma com dados normais, outra sem",
                                    "Monitore curvas de loss/accuracy por épocas",
                                    "Compare métricas: loss inicial, taxa de convergência, epochs to converge",
                                    "Ajuste hiperparâmetros se necessário e documente resultados"
                                  ],
                                  "verification": "Plots mostram convergência mais rápida (ex: loss menor após 10 épocas na versão normalizada)",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "TensorFlow/Keras ou PyTorch",
                                    "Matplotlib para plots de training",
                                    "Mesmo dataset pré-processado"
                                  ],
                                  "tips": "Use callbacks como EarlyStopping; fixe seeds para reprodutibilidade",
                                  "learningObjective": "Demonstrar empiricamente o benefício da normalização na estabilidade do treinamento",
                                  "commonMistakes": [
                                    "Treinar com learning rate inadequado mascarando efeitos",
                                    "Não fixar random seeds"
                                  ]
                                }
                              ],
                              "practicalExample": "Em análise de estruturas civis, normalize dados de sensores de deformação (em mm) e carga (em kN) de uma ponte: aplique Z-Score para capturar variações gaussianas, integrando na entrada de uma RNA que prevê fadiga; observe loss caindo de 0.5 para 0.1 em 20 épocas vs 50 sem normalização.",
                              "finalVerifications": [
                                "Dados normalizados têm range [0,1] para Min-Max ou mean=0/std=1 para Z-Score",
                                "Scaler foi fit apenas em treino e salvo corretamente",
                                "Curva de loss da RNA normalizada converge 20-50% mais rápido",
                                "Predições em test set têm menor MSE que baseline não-normalizado",
                                "Pipeline é reprodutível com seeds fixos",
                                "Nenhum data leakage detectado em stats de test"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática das fórmulas implementadas (100% match com Scikit-learn)",
                                "Ausência de vazamento de dados (stats de test independentes)",
                                "Melhoria mensurável na convergência (ex: >30% epochs a menos)",
                                "Código limpo, comentado e em pipeline modular",
                                "Plots e relatórios claros demonstrando impacto",
                                "Escolha justificada de scaler baseada em análise de dados"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de mean, std e distribuições",
                                "Programação: Manipulação de arrays com NumPy/Pandas",
                                "Engenharia de Dados: Pipelines de pré-processamento ETL",
                                "Matemática Aplicada: Escalares e gradientes em otimização",
                                "Engenharia Civil: Processamento de dados sensores em monitoramento estrutural"
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, normalizar dados de IoT em pontes ou edifícios acelera treinamento de RNAs para detecção precoce de falhas, reduzindo tempo de computação em 40% e melhorando precisão preditiva em análises de risco sísmico ou fadiga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.2.3",
                            "name": "Conectar camada de entrada a ocultas",
                            "description": "Descrever como os neurônios da camada de entrada se conectam aos da camada oculta via pesos, formando a matriz de pesos iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Dimensionar as Camadas de Entrada e Oculta",
                                  "subSteps": [
                                    "Defina o número de neurônios na camada de entrada (ex: n_entrada = 3 para features como carga, tensão, deformação).",
                                    "Defina o número de neurônios na camada oculta (ex: n_oculta = 4).",
                                    "Esboce diagramaticamente as camadas com neurônios representados como nós.",
                                    "Anote as dimensões esperadas para a matriz de pesos: n_entrada x n_oculta.",
                                    "Confirme que todas as conexões são fully connected (cada entrada conecta a todos os ocultos)."
                                  ],
                                  "verification": "Verifique se o diagrama mostra todas as conexões possíveis entre entrada e oculta sem falhas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação como Draw.io; notebook Jupyter com Python.",
                                  "tips": "Use setas para representar conexões e label pesos como variáveis (w_ij).",
                                  "learningObjective": "Compreender as dimensões e topologia fully connected das camadas.",
                                  "commonMistakes": "Confundir dimensões da matriz (lembre: linhas = entradas, colunas = ocultos)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar Pesos Aleatoriamente",
                                  "subSteps": [
                                    "Importe bibliotecas NumPy para geração de números aleatórios.",
                                    "Gere uma matriz de pesos com valores iniciais aleatórios usando np.random.randn(n_entrada, n_oculta).",
                                    "Escalone os pesos se necessário (ex: dividir por sqrt(n_entrada) para Xavier initialization).",
                                    "Armazene a matriz em uma variável (ex: W1).",
                                    "Exiba a matriz inicial para inspeção visual."
                                  ],
                                  "verification": "Execute print(W1.shape) e confirme dimensões (3,4); valores devem ser aleatórios não-zero.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy instalado; código exemplo: import numpy as np",
                                  "tips": "Use seed para reprodutibilidade: np.random.seed(42).",
                                  "learningObjective": "Aprender a inicializar pesos de forma aleatória e escalonada.",
                                  "commonMistakes": "Inicializar todos pesos como zero, causando simetria e falha no treinamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer as Conexões Via Produto Matricial",
                                  "subSteps": [
                                    "Represente entrada como vetor coluna X (shape: n_entrada x 1).",
                                    "Calcule saída da oculta antes da ativação: Z = W1 @ X (produto matricial).",
                                    "Implemente em código: Z = np.dot(W1, X.reshape(-1,1)).",
                                    "Verifique shape de Z: deve ser n_oculta x 1.",
                                    "Aplique função de ativação (ex: ReLU) para obter A = relu(Z)."
                                  ],
                                  "verification": "Teste com X de exemplo e confirme que Z tem shape correto e valores variam com pesos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Notebook Jupyter; função ReLU custom: def relu(z): return np.maximum(0,z)",
                                  "tips": "Use broadcasting NumPy para eficiência em batches.",
                                  "learningObjective": "Implementar a propagação forward das conexões entrada-oculta.",
                                  "commonMistakes": "Erro de shape no produto matricial; sempre reshape entrada para coluna."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Validar a Matriz de Pesos e Conexões",
                                  "subSteps": [
                                    "Crie um heatmap da matriz W1 usando matplotlib.",
                                    "Simule forward pass com múltiplos exemplos de entrada.",
                                    "Compare saídas com cálculo manual para um subconjunto.",
                                    "Documente a matriz inicial e final de um mini-treinamento.",
                                    "Salve o modelo com pesos em arquivo .npz."
                                  ],
                                  "verification": "Heatmap mostra variação de pesos; forward pass reproduz manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Matplotlib: import matplotlib.pyplot as plt; seaborn para heatmap.",
                                  "tips": "Ajuste escala de cores no heatmap para melhor visualização.",
                                  "learningObjective": "Validar visual e numericamente as conexões formadas.",
                                  "commonMistakes": "Ignorar transposição de matrizes; sempre cheque shapes."
                                }
                              ],
                              "practicalExample": "Em análise estrutural civil, com 3 entradas (carga=100kN, tensão=50MPa, deformação=0.01), camada oculta de 4 neurônios: inicialize W1 (3x4) aleatória, compute Z = W1 @ [100,50,0.01]^T, aplique ReLU para ativações ocultas usadas em previsão de falha.",
                              "finalVerifications": [
                                "Matriz W1 tem shape correto (n_entrada x n_oculta).",
                                "Forward pass Z = W1 @ X produz vetor de shape n_oculta.",
                                "Pesos são aleatórios e não-zero.",
                                "Visualização heatmap confirma conexões fully connected.",
                                "Código roda sem erros para batch de 10 entradas.",
                                "Manual check: para X=[1,0,0], Z primeira linha de W1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de dimensões da matriz de pesos (100%).",
                                "Correta inicialização aleatória e escalonamento (sem zeros).",
                                "Implementação sem erros de produto matricial/shape.",
                                "Visualização clara e interpretável.",
                                "Explicação verbal da conexão biológica/inspirada em sinapses.",
                                "Aplicação correta de ativação pós-conexão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (produtos matriciais, vetores).",
                                "Programação: Manipulação de arrays NumPy e visualização Matplotlib.",
                                "Estatística: Geração de aleatórios e inicialização em ML.",
                                "Engenharia Civil: Modelagem de entradas como variáveis estruturais (carga, tensão)."
                              ],
                              "realWorldApplication": "Em simulações de estabilidade de pontes via RNA, conectar entradas (sensores de vibração, vento, tráfego) à camada oculta permite prever deformações; pesos ajustados preveem falhas antes de colapsos reais, otimizando manutenção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.1.3",
                        "name": "Camadas Ocultas",
                        "description": "Camadas intermediárias compostas por múltiplos neurônios artificiais que realizam transformações não-lineares nos dados, permitindo que a rede aprenda representações complexas.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.3.1",
                            "name": "Determinar o número de camadas ocultas",
                            "description": "Analisar critérios para escolher o número de camadas ocultas e neurônios por camada, considerando complexidade do problema e risco de overfitting em aplicações civis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Camadas Ocultas",
                                  "subSteps": [
                                    "Defina camadas ocultas como as camadas intermediárias entre entrada e saída em uma RNA.",
                                    "Explique o papel delas em capturar não-linearidades e representações hierárquicas dos dados.",
                                    "Liste fatores chave: complexidade do problema, tamanho do dataset e poder computacional.",
                                    "Discuta trade-offs: mais camadas aumentam capacidade mas risco de overfitting.",
                                    "Revise exemplos simples de shallow vs deep networks."
                                  ],
                                  "verification": "Resuma em um diagrama os papéis das camadas ocultas e liste 3 fatores influenciadores corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notebook, slides ou vídeo sobre arquitetura de RNAs (ex: TensorFlow/PyTorch docs), papel e caneta para diagrama.",
                                  "tips": "Use analogias como 'camadas de processamento em uma fábrica' para visualizar.",
                                  "learningObjective": "Identificar o propósito e fatores que afetam o número de camadas ocultas.",
                                  "commonMistakes": "Confundir camadas ocultas com camadas de entrada/saída; ignorar limitações computacionais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar a Complexidade do Problema Específico",
                                  "subSteps": [
                                    "Classifique o problema: linear (poucas camadas) vs não-linear complexo (mais camadas).",
                                    "Analise dimensionalidade dos dados de entrada (ex: features em engenharia civil como tensão, deformação).",
                                    "Estime a profundidade hierárquica necessária (ex: detecção de padrões simples vs composições).",
                                    "Considere aplicações civis: previsão de falhas em estruturas requer mais camadas que regressão simples.",
                                    "Crie uma matriz de complexidade: linhas para tipos de problema, colunas para camadas sugeridas."
                                  ],
                                  "verification": "Produza uma tabela classificando 3 problemas civis (ex: análise de solos) por complexidade e camadas iniciais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Dataset de exemplo em engenharia civil (ex: Kaggle concrete strength), Excel ou Python pandas.",
                                  "tips": "Comece com problemas conhecidos: solos lineares (1-2 camadas), dinâmicas sísmicas (3+).",
                                  "learningObjective": "Mapear complexidade do problema para requisitos arquiteturais iniciais.",
                                  "commonMistakes": "Superestimar complexidade para problemas simples, levando a redes desnecessariamente profundas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Heurísticas para Selecionar Número de Camadas e Neurônios",
                                  "subSteps": [
                                    "Use regra empírica: camadas ocultas = log(dimensionalidade entrada) ou 2-3 para starters.",
                                    "Neurônios por camada: 2/3 da entrada + saída, ou potência de 2 próxima.",
                                    "Ajuste para civis: menos camadas para datasets pequenos para evitar overfitting.",
                                    "Teste variações: comece com 1 camada, adicione até convergência.",
                                    "Documente escolhas em um log: '2 camadas de 64 neurônios para previsão de cargas'."
                                  ],
                                  "verification": "Implemente uma RNA simples com 2 configurações e compare losses iniciais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com Keras/TensorFlow, dataset civil (ex: bridge load data).",
                                  "tips": "Monitore validation loss durante treinamento para guiar ajustes.",
                                  "learningObjective": "Escolher configurações iniciais baseadas em heurísticas adaptadas a contextos civis.",
                                  "commonMistakes": "Escolher números arbitrários sem base; ignorar assimetria entrada-saída."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Ajustar Considerando Risco de Overfitting",
                                  "subSteps": [
                                    "Divida dados: 70% train, 15% val, 15% test.",
                                    "Treine múltiplas arquiteturas e compare métricas (MSE, R²) em validation set.",
                                    "Aplique early stopping e dropout se overfitting detectado (gap train-val >10%).",
                                    "Use cross-validation k-fold para robustez em datasets civis limitados.",
                                    "Itere: reduza camadas se overfitting persistir."
                                  ],
                                  "verification": "Gere gráficos de train/val loss para 3 arquiteturas, identificando a ótima.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python com scikit-learn para CV, Matplotlib para plots.",
                                  "tips": "Priorize generalização: prefira modelo com menor val loss mesmo se train loss maior.",
                                  "learningObjective": "Otimizar arquitetura balanceando capacidade e generalização.",
                                  "commonMistakes": "Treinar só em train set; não monitorar overfitting em tempo real."
                                }
                              ],
                              "practicalExample": "Em um projeto de engenharia civil para prever a resistência à compressão do concreto baseado em 8 features (cimento, água, etc.), inicie com 2 camadas ocultas (64 e 32 neurônios), treine com dataset UCI Concrete, valide com early stopping e ajuste para 1 camada se overfitting ocorrer, alcançando MSE < 50.",
                              "finalVerifications": [
                                "A arquitetura escolhida converge em <50 épocas sem overfitting (gap loss <5%).",
                                "Métricas de validação superam baseline linear em 10-20%.",
                                "Log documenta heurísticas usadas e iterações realizadas.",
                                "Teste em hold-out set confirma generalização.",
                                "Explicação oral justifica escolhas para um problema civil específico.",
                                "Gráficos de loss curves mostram platô adequado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na avaliação de complexidade (80% match com referências).",
                                "Adequação das heurísticas aplicadas (alinhadas a 3+ regras padrão).",
                                "Detecção correta de overfitting em simulações (100% identificação).",
                                "Eficiência: tempo de treinamento <2x baseline.",
                                "Documentação completa com justificativas.",
                                "Generalização comprovada em dados não vistos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e testes de significância para validação.",
                                "Programação: Implementação em Python/Keras para experimentação.",
                                "Matemática: Otimização gradiente e funções de ativação não-lineares.",
                                "Engenharia Civil: Aplicação em modelagem de materiais e estruturas."
                              ],
                              "realWorldApplication": "Em projetos de infraestrutura civil, como otimização de misturas de concreto para barragens ou previsão de deformações em pontes sob cargas dinâmicas, determinando camadas ocultas reduz custos de protótipos físicos em 30-50% ao simular comportamentos complexos com precisão."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.3.2",
                            "name": "Calcular propagação forward nas ocultas",
                            "description": "Executar a propagação forward através de camadas ocultas, computando saídas camada por camada com pesos e ativações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais da Propagação Forward em Camadas Ocultas",
                                  "subSteps": [
                                    "Revise a fórmula básica: para uma camada oculta, compute z = W * x + b, onde W são pesos, x é entrada, b é bias.",
                                    "Entenda funções de ativação comuns (ex: ReLU, Sigmoid, Tanh) e como aplicá-las: a = f(z).",
                                    "Identifique dimensões das matrizes: entrada n x 1, W n x m para m neurônios na oculta.",
                                    "Estude o fluxo sequencial: saída de uma camada é entrada da próxima.",
                                    "Anote exemplos de shapes de tensores em uma rede feedforward."
                                  ],
                                  "verification": "Resuma em um diagrama as fórmulas e dimensões para uma rede com 2 camadas ocultas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta, diagrama de rede neural (impresso ou digital).",
                                  "tips": "Desenhe setas representando o fluxo de dados para visualizar melhor.",
                                  "learningObjective": "Dominar as equações matemáticas e notação para propagação forward em ocultas.",
                                  "commonMistakes": "Confundir multiplicação matricial com escalar; ignorar transposição de vetores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar Cálculo Manual para uma Camada Oculta Simples",
                                  "subSteps": [
                                    "Defina entrada x = [0.5, 0.3]^T, pesos W = [[0.1, 0.2, 0.4], [0.3, 0.5, 0.1]], bias b = [0.1, 0.2, 0.3].",
                                    "Calcule z = W * x + b manualmente, neurônio por neurônio.",
                                    "Aplique ativação ReLU: a_i = max(0, z_i) para cada neurônio.",
                                    "Verifique dimensões: saída deve ser vetor 3x1.",
                                    "Repita com Sigmoid para comparar ativações."
                                  ],
                                  "verification": "Os valores de z e a batem com cálculos em calculadora; anote resultados exatos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora científica, planilha em branco.",
                                  "tips": "Calcule linha por linha da matriz W para evitar erros aritméticos.",
                                  "learningObjective": "Realizar propagação forward manual com precisão numérica.",
                                  "commonMistakes": "Esquecer de somar bias após multiplicação; erro em sinal de ativação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Propagar Forward Através de Múltiplas Camadas Ocultas",
                                  "subSteps": [
                                    "Estenda o exemplo: segunda camada oculta com W2 = [[0.2, 0.1], [0.4, 0.3], [0.5, 0.6]], b2 = [0.1, 0.2].",
                                    "Use saída a1 da primeira camada como x2 para z2 = W2 * a1 + b2.",
                                    "Aplique ReLU novamente e compute saída final da segunda oculta.",
                                    "Rastreie valores intermediários em uma tabela.",
                                    "Teste com entrada diferente para validar generalização."
                                  ],
                                  "verification": "Crie uma tabela com entradas, z's, a's para todas camadas; confira somas parciais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha Excel ou papel quadriculado.",
                                  "tips": "Mantenha vetores coluna consistentes para multiplicação matricial.",
                                  "learningObjective": "Computar sequencialmente através de várias camadas ocultas.",
                                  "commonMistakes": "Usar saída não ativada como entrada da próxima; mismatch de dimensões."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Validar Propagação Forward em Código",
                                  "subSteps": [
                                    "Escreva função em Python com NumPy: def forward_hidden(X, W_list, b_list, activation='relu').",
                                    "Implemente loop por camadas ocultas, aplicando multiplicação e ativação.",
                                    "Teste com dados do passo 2 e 3; compare com cálculos manuais.",
                                    "Adicione print de intermediários para depuração.",
                                    "Experimente com batch de entradas (X 2x2)."
                                  ],
                                  "verification": "Resultados do código coincidem com manuais (erro < 1e-6); rode 3 testes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy instalado, Jupyter Notebook.",
                                  "tips": "Use np.dot para multiplicação eficiente; defina ativações como funções lambda.",
                                  "learningObjective": "Automatizar propagação forward para escalabilidade.",
                                  "commonMistakes": "Erro em broadcasting de bias; esquecer np.maximum para ReLU."
                                }
                              ],
                              "practicalExample": "Em uma rede para prever deformação em vigas: entrada [carga=100kN, comprimento=5m]. Primeira oculta (3 neurônios): W1=[[0.1,0.2],[0.3,0.4],[0.5,0.1]], b1=[0,0,0]. z1=[14,24,15], ReLU a1=[14,24,15]. Segunda oculta (2 neurônios): W2=[[0.2,0.3,0.1],[0.4,0.5,0.2]], b2=[0.1,0.1]. z2=[8.9,13.4], ReLU a2=[8.9,13.4]. Saída predita: deformação ≈0.002m.",
                              "finalVerifications": [
                                "Cálculos manuais coincidem com implementação em código (erro absoluto <0.001).",
                                "Dimensões de todas ativações são corretas (ex: oculta1: 3x1).",
                                "Mudança na entrada altera saídas proporcionalmente nas ocultas.",
                                "Funções de ativação mudam saídas como esperado (ReLU zera negativos).",
                                "Propagação completa sem NaN ou Inf em 10 execuções aleatórias.",
                                "Diagrama desenhado resume fluxo corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos intermediários (100% exatidão).",
                                "Correta aplicação de ativações e handling de dimensões.",
                                "Capacidade de estender a múltiplas camadas sem erros.",
                                "Implementação codificada funcional e eficiente.",
                                "Identificação e correção de erros comuns demonstrada.",
                                "Explicação clara do processo em palavras próprias."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Multiplicação de matrizes e vetores.",
                                "Programação: Uso de NumPy para computação vetorial.",
                                "Estatística: Interpretação de ativações como probabilidades transformadas.",
                                "Engenharia Civil: Modelagem preditiva de respostas estruturais."
                              ],
                              "realWorldApplication": "Em engenharia civil, calcular forward em camadas ocultas de uma RNA para prever falhas em estruturas sob carga dinâmica, permitindo simulações rápidas de vigas ou barragens sem métodos finitos caros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.3.3",
                            "name": "Explicar papel das camadas ocultas",
                            "description": "Descrever como as camadas ocultas capturam padrões não-lineares, como em predições de deformações em estruturas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica de uma rede neural artificial",
                                  "subSteps": [
                                    "Revise os componentes principais: camada de entrada, camadas ocultas e camada de saída.",
                                    "Identifique como os dados fluem da entrada para a saída através das conexões sinápticas.",
                                    "Diferencie redes com uma única camada (perceptron) de redes multicamadas.",
                                    "Desenhe um diagrama simples de uma rede neural com camadas ocultas.",
                                    "Explique o papel dos pesos e bias em cada camada."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama de rede neural com pelo menos uma camada oculta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou software de desenho como Draw.io; vídeo introdutório sobre redes neurais (ex: YouTube - 3Blue1Brown).",
                                  "tips": "Comece com um exemplo visual simples para fixar a estrutura antes de mergulhar em detalhes.",
                                  "learningObjective": "Entender a arquitetura fundamental de redes neurais e o posicionamento das camadas ocultas.",
                                  "commonMistakes": "Confundir camadas ocultas com a camada de saída; ignorar o fluxo unidirecional de dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar funções de ativação e introdução à não-linearidade",
                                  "subSteps": [
                                    "Estude funções comuns: ReLU, Sigmoid e Tanh, e como elas introduzem não-linearidade.",
                                    "Compare computação linear (sem ativação) vs. não-linear (com ativação).",
                                    "Simule manualmente uma soma ponderada seguida de ativação em um neurônio.",
                                    "Discuta por que redes lineares não podem capturar padrões complexos.",
                                    "Calcule exemplos numéricos simples de entrada-saída com e sem não-linearidade."
                                  ],
                                  "verification": "Resolva um exercício numérico mostrando que uma rede sem ativação é equivalente a uma regressão linear.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora ou Python/Jupyter Notebook com NumPy; tabela de funções de ativação.",
                                  "tips": "Use gráficos para visualizar como a ReLU 'quebra' a linearidade.",
                                  "learningObjective": "Dominar como funções de ativação permitem modelagem de relações não-lineares.",
                                  "commonMistakes": "Achar que funções de ativação são apenas 'normalizações'; subestimar o impacto da não-linearidade em múltiplas camadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar o papel das camadas ocultas na captura de padrões não-lineares",
                                  "subSteps": [
                                    "Explique como cada camada oculta transforma representações de dados em níveis mais abstratos.",
                                    "Descreva o conceito de 'representações hierárquicas' (ex: bordas → formas → objetos).",
                                    "Analise como múltiplas camadas ocultas compõem funções complexas via Universal Approximation Theorem.",
                                    "Compare desempenho de redes com 0, 1 e 2 camadas ocultas em um dataset simples.",
                                    "Discuta backpropagation e como camadas ocultas são treinadas para otimizar padrões."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que camadas ocultas são essenciais para padrões não-lineares, com referência ao teorema de aproximação universal.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Artigo ou vídeo sobre Universal Approximation Theorem; ferramenta como TensorFlow Playground.",
                                  "tips": "Experimente no TensorFlow Playground alterando número de camadas ocultas para ver o impacto visual.",
                                  "learningObjective": "Articular precisamente como camadas ocultas extraem e combinam features não-lineares.",
                                  "commonMistakes": "Pensar que camadas ocultas 'inventam' dados; confundir com overfitting sem regularização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o conceito a predições de deformações em estruturas civis",
                                  "subSteps": [
                                    "Defina o problema: prever deformações em vigas sob cargas variáveis usando dados de sensores.",
                                    "Monte um exemplo de rede: entrada (carga, material), camadas ocultas (padrões não-lineares de tensão), saída (deformação).",
                                    "Simule ou codifique uma rede simples prevendo deformação vs. modelo linear.",
                                    "Analise como camadas ocultas capturam interações não-lineares como fadiga ou plasticidade.",
                                    "Avalie melhorias no erro de predição com camadas ocultas adicionais."
                                  ],
                                  "verification": "Crie um gráfico comparando predições lineares vs. com camadas ocultas em dados sintéticos de deformação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com scikit-learn ou Keras; dataset sintético de deformações (gerar via fórmulas de engenharia).",
                                  "tips": "Use dados reais de simulações FEM se disponível para maior realismo.",
                                  "learningObjective": "Aplicar o conhecimento de camadas ocultas a um contexto de engenharia civil prático.",
                                  "commonMistakes": "Ignorar unidades físicas nas entradas/saídas; superestimar precisão sem validação cruzada."
                                }
                              ],
                              "practicalExample": "Em uma rede neural para prever deformações em uma ponte sob vento e tráfego: a camada de entrada recebe dados de sensores (velocidade do vento, peso de veículos); a primeira camada oculta detecta padrões lineares iniciais como tensão proporcional; camadas subsequentes capturam não-linearidades como vibrações ressonantes ou fadiga cumulativa, produzindo predições precisas de deformação máxima na saída.",
                              "finalVerifications": [
                                "Explicar verbalmente o que acontece se removermos todas as camadas ocultas de uma rede.",
                                "Identificar corretamente funções de ativação em um diagrama de rede neural.",
                                "Descrever um padrão não-linear capturado por camadas ocultas no exemplo de deformações.",
                                "Comparar acurácia de modelo linear vs. multicamadas em um teste simples.",
                                "Listar 3 limitações das camadas ocultas (ex: interpretabilidade, vanishing gradients).",
                                "Aplicar o conceito a outro domínio, como previsão de tráfego."
                              ],
                              "assessmentCriteria": [
                                "Clareza na explicação da não-linearidade (nota 1-5).",
                                "Precisão técnica sobre funções de ativação e teoremas (nota 1-5).",
                                "Uso correto de exemplos contextualizados em engenharia civil (nota 1-5).",
                                "Profundidade nos sub-passos e verificações (nota 1-5).",
                                "Capacidade de conectar teoria a aplicação prática (nota 1-5).",
                                "Ausência de erros comuns identificados (nota 1-5)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de pesos) e cálculo (gradientes em backpropagation).",
                                "Programação: Implementação em Python/TensorFlow para simulações de redes.",
                                "Física/Engenharia: Mecânica dos materiais e análise finita de elementos (FEM).",
                                "Estatística: Validação de modelos com métricas como MSE e validação cruzada."
                              ],
                              "realWorldApplication": "Nas inspeções preditivas de infraestrutura civil, como pontes e edifícios, onde redes neurais com camadas ocultas preveem deformações sob cargas dinâmicas, permitindo manutenção preventiva e evitando colapsos como no caso da Ponte Morandi (2018), otimizando custos e segurança pública."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.1.4",
                        "name": "Camada de Saída",
                        "description": "Última camada da rede neural que gera a predição final ou classificação, com função de ativação escolhida conforme o tipo de problema (regressão ou classificação).",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.4.1",
                            "name": "Selecionar função de ativação da saída",
                            "description": "Escolher funções adequadas para a camada de saída, como linear para regressão contínua (ex.: previsão de tensões) ou softmax para classificação multi-classe.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o tipo de problema de saída",
                                  "subSteps": [
                                    "Analise o objetivo da rede neural: é prever um valor contínuo (regressão) ou categorias discretas (classificação)?",
                                    "Examine os dados de saída: valores numéricos variados indicam regressão; rótulos categóricos indicam classificação.",
                                    "Considere subtipos: regressão linear para valores reais (ex.: tensão); classificação binária ou multi-classe.",
                                    "Documente o tipo de tarefa em um diagrama ou tabela para clareza.",
                                    "Verifique com exemplos do contexto de engenharia civil, como previsão de tensões vs. classificação de danos."
                                  ],
                                  "verification": "Crie um resumo escrito confirmando o tipo de problema com justificativa baseada nos dados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Dataset de exemplo (ex.: dados de tensões em vigas)",
                                    "Papel ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Sempre pergunte: 'O que a saída representa numericamente?' para evitar confusão.",
                                  "learningObjective": "Classificar corretamente o tipo de tarefa de saída como regressão ou classificação.",
                                  "commonMistakes": [
                                    "Confundir regressão com classificação ordinal",
                                    "Ignorar subtipos como multi-classe"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear funções de ativação adequadas por tipo de problema",
                                  "subSteps": [
                                    "Para regressão contínua: selecione linear (identidade) para saídas ilimitadas como tensões.",
                                    "Para classificação binária: use sigmoid para probabilidades entre 0 e 1.",
                                    "Para classificação multi-classe: aplique softmax para distribuir probabilidades somando 1.",
                                    "Liste alternativas e contraindicações: evite sigmoid em regressão (limita saída a [0,1]).",
                                    "Crie uma tabela de referência: colunas para tipo de problema, função recomendada e razão."
                                  ],
                                  "verification": "Preencha uma tabela com pelo menos 3 tipos de problemas e suas funções correspondentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela em Excel ou Google Sheets",
                                    "Documentação de bibliotecas como TensorFlow/Keras sobre ativações"
                                  ],
                                  "tips": "Lembre-se: a função deve mapear para o domínio esperado da saída real.",
                                  "learningObjective": "Associar funções de ativação específicas a tipos de tarefas de saída.",
                                  "commonMistakes": [
                                    "Usar softmax em regressão (probabilidades não somam para valores reais)",
                                    "Aplicar linear em multi-classe (sem normalização)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Justificar a escolha com base no contexto do problema",
                                  "subSteps": [
                                    "Avalie restrições do problema: ex., tensões positivas usam ReLU; ilimitadas usam linear.",
                                    "Considere gradientes e treinamento: softmax evita vanishing gradients em multi-classe.",
                                    "Compare com métricas: loss MSE para regressão linear; cross-entropy para softmax.",
                                    "Escreva uma justificativa de 3-5 frases ligando a escolha ao contexto de engenharia civil.",
                                    "Teste conceitualmente: simule entradas/saídas para validar."
                                  ],
                                  "verification": "Redija uma justificativa escrita aprovada por auto-revisão ou peer review.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de problemas de engenharia civil (previsão de tensões, classificação de falhas)",
                                    "Referências teóricas de redes neurais"
                                  ],
                                  "tips": "Pergunte: 'Essa função preserva a escala dos dados reais?'",
                                  "learningObjective": "Justificar seleções com argumentos teóricos e práticos.",
                                  "commonMistakes": [
                                    "Ignorar o range de saída (ex.: linear para probabilidades)",
                                    "Não considerar o tipo de loss function"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e validar a seleção em código",
                                  "subSteps": [
                                    "Configure uma camada de saída em Keras/TensorFlow com a função escolhida.",
                                    "Treine um modelo simples com dados de exemplo e inspecione saídas.",
                                    "Compare saídas com/ sem a função correta para observar diferenças.",
                                    "Meça performance com métricas adequadas (MSE para regressão, accuracy para classificação).",
                                    "Documente o código com comentários explicando a escolha."
                                  ],
                                  "verification": "Execute o código e capture saídas/screenshots mostrando saídas corretas no domínio esperado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ambiente Python com TensorFlow/Keras",
                                    "Dataset sintético de tensões ou classificações civis"
                                  ],
                                  "tips": "Comece com modelo mínimo viável (MLP simples) para foco na saída.",
                                  "learningObjective": "Implementar e validar funções de ativação em um contexto real.",
                                  "commonMistakes": [
                                    "Esquecer de compilar com loss compatível",
                                    "Não normalizar dados de entrada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de engenharia civil, para prever tensões contínuas em vigas sob carga (regressão), use ativação linear na saída para valores reais como 150.5 MPa. Para classificar tipos de dano em estruturas (ex.: rachadura leve/pesada/crítico), use softmax para probabilidades como [0.1, 0.7, 0.2]. Implemente em Keras: model.add(Dense(1, activation='linear')) para regressão.",
                              "finalVerifications": [
                                "Explicar verbalmente por que linear é inadequada para multi-classe.",
                                "Selecionar corretamente ativação para 3 cenários de engenharia civil dados.",
                                "Implementar camada de saída funcional sem erros de domínio.",
                                "Identificar e corrigir uma escolha errada em código fornecido.",
                                "Comparar outputs de linear vs. softmax em um teste simples.",
                                "Justificar escolha alinhada com loss function e métrica."
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa do tipo de problema (30%)",
                                "Mapeamento correto de funções de ativação (25%)",
                                "Justificativa teórica e contextual robusta (20%)",
                                "Implementação e validação prática sem erros (15%)",
                                "Documentação clara e exemplos relevantes (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propriedades de funções (linear, sigmoide, softmax) e seus limites.",
                                "Programação: Implementação em bibliotecas de ML como TensorFlow.",
                                "Estatística: Interpretação de probabilidades em softmax e losses.",
                                "Engenharia Civil: Aplicação em análise estrutural e previsão de falhas."
                              ],
                              "realWorldApplication": "Na engenharia civil, selecionar ativação linear permite prever tensões exatas em pontes para otimizar projetos; softmax classifica riscos sísmicos em edifícios, auxiliando decisões de manutenção preventiva e reduzindo custos com inspeções desnecessárias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.4.2",
                            "name": "Interpretar saídas da rede",
                            "description": "Interpretar os valores da camada de saída em termos probabilísticos ou contínuos, relacionando com problemas de engenharia civil como análise de falhas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Tipos de Saídas de Camada de Saída",
                                  "subSteps": [
                                    "Identifique funções de ativação comuns para saídas probabilísticas (ex: softmax) e contínuas (ex: linear, ReLU).",
                                    "Diferencie classificação (discreta, probabilística) de regressão (contínua).",
                                    "Revise a normalização das saídas para somar 1 em probabilidades.",
                                    "Analise exemplos de saídas raw vs ativadas.",
                                    "Registre diferenças em um diagrama comparativo."
                                  ],
                                  "verification": "Crie um quadro comparativo das funções de ativação e suas interpretações, sem erros conceituais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de bibliotecas como TensorFlow/Keras, caderno de anotações, calculadora.",
                                  "tips": "Use visualizações gráficas para entender curvas de ativação.",
                                  "learningObjective": "Distinguir tipos de saídas e suas funções de ativação associadas.",
                                  "commonMistakes": "Confundir ativação linear com sigmoide; ignorar normalização em softmax."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar Saídas Probabilísticas",
                                  "subSteps": [
                                    "Calcule probabilidades a partir de logits usando softmax manualmente.",
                                    "Interprete valores: probabilidade alta (>0.7) indica confiança; baixa sugere incerteza.",
                                    "Compare probabilidades entre classes para decisões (argmax).",
                                    "Avalie confiança com entropia ou variância.",
                                    "Pratique com dataset simples de classificação binária."
                                  ],
                                  "verification": "Interprete corretamente uma saída softmax exemplo, identificando classe mais provável e confiança.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/Jupyter Notebook, NumPy, exemplo de dataset Iris.",
                                  "tips": "Sempre verifique se probabilidades somam 1; use print() para debugar cálculos.",
                                  "learningObjective": "Converter e interpretar logits em probabilidades acionáveis.",
                                  "commonMistakes": "Interpretar logits diretamente como probabilidades; ignorar multiclasse."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Saídas Contínuas",
                                  "subSteps": [
                                    "Analise saídas lineares para valores reais (ex: previsão de tensão).",
                                    "Aplique escalas e thresholds para contextualizar (ex: MPa para engenharia).",
                                    "Calcule erros com métricas como MSE ou MAE.",
                                    "Visualize distribuições de saídas vs valores reais.",
                                    "Ajuste para unidades físicas relevantes."
                                  ],
                                  "verification": "Preveja e interprete uma saída contínua, relacionando com métricas de erro.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Jupyter Notebook, bibliotecas Scikit-learn/Matplotlib, dados sintéticos de regressão.",
                                  "tips": "Padronize saídas para facilitar interpretação; plote histogramas.",
                                  "learningObjective": "Mapear saídas contínuas para variáveis físicas mensuráveis.",
                                  "commonMistakes": "Esquecer inversa de normalização; interpretar valores raw sem contexto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Interpretações com Problemas de Engenharia Civil",
                                  "subSteps": [
                                    "Selecione caso: análise de falhas em vigas (probabilidade de colapso ou deformação contínua).",
                                    "Mapeie saídas da RNA para riscos (ex: P(falha)>0.5 = inspeção urgente).",
                                    "Simule cenários com dados de sensores estruturais.",
                                    "Documente decisões baseadas em saídas (relatório de engenharia).",
                                    "Valide com normas ABNT ou Eurocode."
                                  ],
                                  "verification": "Gere relatório interpretando saídas em contexto civil, com recomendações.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Dataset de engenharia civil (ex: Kaggle bridges), normas técnicas PDF.",
                                  "tips": "Integre com ferramentas como ANSYS para validação; pense em segurança.",
                                  "learningObjective": "Aplicar interpretações de RNA a análises reais de falhas estruturais.",
                                  "commonMistakes": "Ignorar incertezas em dados reais; superestimar precisão da RNA."
                                }
                              ],
                              "practicalExample": "Em uma RNA treinada para prever falhas em pontes, a saída softmax [0.1, 0.85, 0.05] indica 85% de probabilidade de 'falha por fadiga', acionando inspeção imediata; saída contínua de 0.75 MPa sugere deformação aceitável abaixo do limite de 1 MPa.",
                              "finalVerifications": [
                                "Explicar corretamente softmax vs linear em exemplos.",
                                "Interpretar confiança em probabilidades <0.5.",
                                "Relacionar saídas a thresholds de engenharia civil.",
                                "Calcular métricas de erro para saídas contínuas.",
                                "Gerar relatório de decisão baseado em saídas simuladas.",
                                "Identificar limitações de interpretação em dados ruidosos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (90%+ correto em tipos de saída).",
                                "Profundidade em cálculos manuais (sem erros aritméticos).",
                                "Relevância ao contexto civil (mapeamento claro a falhas).",
                                "Criatividade em exemplos práticos.",
                                "Completude de verificações e relatórios.",
                                "Uso adequado de métricas e visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: Cálculo de entropia e distribuições.",
                                "Engenharia Estrutural: Análise de falhas e normas de segurança.",
                                "Programação: Manipulação de arrays em Python/NumPy.",
                                "Matemática Aplicada: Funções de ativação e otimização."
                              ],
                              "realWorldApplication": "Em monitoramento de estruturas civis, interpretar saídas de RNA de sensores IoT para prever falhas em pontes ou edifícios, permitindo manutenção preditiva e evitando colapsos como o de Morandi (2018), otimizando custos e segurança pública."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.4.3",
                            "name": "Conectar ocultas à camada de saída",
                            "description": "Definir a matriz de pesos entre camadas ocultas e de saída, e calcular a saída final da rede.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Determinar dimensões e inicializar matriz de pesos oculto-saída",
                                  "subSteps": [
                                    "Identifique o número de neurônios na camada oculta (ex: h) e na camada de saída (ex: k).",
                                    "Defina a matriz de pesos W como uma matriz h x k.",
                                    "Inicialize os pesos com valores aleatórios pequenos (ex: usando distribuição uniforme [-0.1, 0.1]) ou Xavier/Glorot.",
                                    "Adicione vetor de bias b de tamanho k, inicializado similarmente.",
                                    "Armazene a matriz e bias em estrutura de dados apropriada (array ou dicionário)."
                                  ],
                                  "verification": "Confirme dimensões da matriz W (h linhas, k colunas) e valores iniciais entre -1 e 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy, papel e calculadora para protótipo manual",
                                  "tips": "Use np.random.uniform(-0.1, 0.1, (h, k)) para inicialização rápida e consistente.",
                                  "learningObjective": "Compreender como dimensões das camadas definem a estrutura da matriz de pesos.",
                                  "commonMistakes": "Confundir dimensões (linhas de entrada vs. colunas de saída); inicializar com valores muito grandes causando explosão de gradientes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular produto matricial entre saída oculta e pesos",
                                  "subSteps": [
                                    "Obtenha o vetor de saída da camada oculta, O_hidden (tamanho 1 x h para uma amostra).",
                                    "Compute Z_out = O_hidden @ W (produto matricial, resultando em 1 x k).",
                                    "Adicione o bias: Z_out = Z_out + b.",
                                    "Verifique se não há erros de broadcasting em arrays multidimensionais.",
                                    "Registre o valor de Z_out para inspeção."
                                  ],
                                  "verification": "Resultado Z_out tem tamanho k e valores numéricos finitos (sem NaN ou inf).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com NumPy (np.dot ou @ operator), Jupyter Notebook para depuração",
                                  "tips": "Use print(O_hidden.shape, W.shape) antes do produto para evitar erros de dimensão.",
                                  "learningObjective": "Executar corretamente o forward pass linear entre camadas.",
                                  "commonMistakes": "Inverter ordem do produto matricial (deve ser hidden x pesos, não o inverso); esquecer bias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar função de ativação e obter saída final",
                                  "subSteps": [
                                    "Escolha função de ativação para saída (ex: sigmoid para regressão/binário, softmax para multiclasse).",
                                    "Aplique ativação elemento-wise: output_final = activation(Z_out).",
                                    "Para sigmoid: 1 / (1 + exp(-Z_out)); normalize se necessário.",
                                    "Compare saída com rótulo esperado para uma amostra de teste.",
                                    "Salve output_final para uso em perda ou predição."
                                  ],
                                  "verification": "Saída final está no intervalo esperado (ex: [0,1] para sigmoid) e soma a 1 para softmax.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy/SciPy (np.tanh, scipy.special.expit para sigmoid)",
                                  "tips": "Implemente ativação customizada para evitar dependências; teste com Z_out = 0.",
                                  "learningObjective": "Integrar não-linearidade na camada final para modelagem realista.",
                                  "commonMistakes": "Aplicar ativação errada (ReLU na saída pode dar negativos indesejados); overflow em exp para sigmoid."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar a conexão completa",
                                  "subSteps": [
                                    "Execute forward pass end-to-end com dados de entrada simulados.",
                                    "Calcule perda simples (ex: MSE para regressão) entre output_final e target.",
                                    "Visualize pesos e ativações com plots (heatmap para W, linha para outputs).",
                                    "Teste sensibilidade alterando um peso e observando mudança na saída.",
                                    "Documente o processo em um relatório curto."
                                  ],
                                  "verification": "Perda é finita e saída muda coerentemente com alterações nos pesos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matplotlib para visualizações, dados de amostra (ex: array simples)",
                                  "tips": "Use seed para reproducibilidade: np.random.seed(42).",
                                  "learningObjective": "Garantir funcionamento holístico da conexão oculto-saída.",
                                  "commonMistakes": "Ignorar normalização de entrada oculta; não testar com batch size >1."
                                }
                              ],
                              "practicalExample": "Em uma RNA para prever deformação em vigas de concreto (Engenharia Civil), com 3 neurônios ocultos processando features como carga e material, defina W (3x1) com pesos iniciais [[0.1], [-0.05], [0.2]], bias [0.01]. Para O_hidden = [0.7, 0.4, 0.9], Z_out = [0.365], output_final = sigmoid(0.365) ≈ 0.59 (probabilidade de deformação crítica).",
                              "finalVerifications": [
                                "Matriz de pesos tem dimensões corretas (oculto x saída).",
                                "Produto matricial produz vetor de tamanho da saída sem erros numéricos.",
                                "Função de ativação aplicada corretamente (valores no range esperado).",
                                "Saída final coerente com entrada simulada e muda com pesos alterados.",
                                "Todo o forward pass executa sem exceções em múltiplas amostras.",
                                "Perda calculada é finita e razoável para dados de teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas dimensões e inicialização de W e b (100% correto).",
                                "Correção matemática do produto matricial e adição de bias (sem erros de forma).",
                                "Implementação exata da ativação escolhida (erro < 1e-6 vs. função built-in).",
                                "Validação end-to-end com exemplo numérico reproduzível.",
                                "Documentação clara de pesos, Z_out e output_final.",
                                "Tratamento de edge cases como zero hidden ou múltiplas saídas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (produtos matriciais, vetores).",
                                "Programação: Manipulação de arrays em Python/NumPy.",
                                "Estatística: Interpretação probabilística de saídas (sigmoid/softmax).",
                                "Engenharia Civil: Aplicação em previsão de falhas estruturais via RNA."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, conectar camadas ocultas à saída permite RNAs preverem resistência de materiais sob cargas variáveis, otimizando designs de pontes e edifícios, reduzindo custos e riscos de colapso via simulações preditivas precisas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.2",
                    "name": "Funções de Ativação em Redes Neurais",
                    "description": "Funções como sigmoide, tangente hiperbólica e ReLU para introduzir não-linearidade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.2.1",
                        "name": "Função Sigmoide",
                        "description": "A função sigmoide é uma das funções de ativação clássicas em redes neurais artificiais, que transforma entradas reais em saídas no intervalo (0,1), introduzindo não-linearidade essencial para modelar relações complexas em problemas de engenharia civil, como previsão de deformações estruturais.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.1.1",
                            "name": "Definir a fórmula da função sigmoide",
                            "description": "Compreender e reproduzir a fórmula matemática da função sigmoide: σ(x) = 1 / (1 + e^{-x}), explicando seu comportamento assintótico em x → ∞ (aproxima 1) e x → -∞ (aproxima 0).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os componentes fundamentais da função sigmoide",
                                  "subSteps": [
                                    "Revise a função exponencial e^{x}, sua propriedade de crescimento rápido para x positivo e decaimento para x negativo.",
                                    "Identifique o papel do denominador 1 + e^{-x} na compressão do valor para o intervalo (0,1).",
                                    "Explique verbalmente por que a fração 1 / (1 + e^{-x}) suaviza a transição de 0 a 1.",
                                    "Compare com a função degrau (step function) para destacar a suavidade.",
                                    "Anote os símbolos: σ(x), e (base do log natural), -x no expoente."
                                  ],
                                  "verification": "Escreva uma definição própria dos componentes e compare com a fórmula oficial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora gráfica ou app de funções (ex: Desmos)",
                                    "Referência rápida de funções exponenciais"
                                  ],
                                  "tips": "Visualize gráficos mentais: e^{-x} explode para x negativo, tornando denominador grande (σ≈0); para x positivo, e^{-x}≈0 (σ≈1).",
                                  "learningObjective": "Compreender os blocos matemáticos que formam a sigmoide e sua intuição.",
                                  "commonMistakes": [
                                    "Confundir e^{x} com e^{-x}",
                                    "Esquecer que e é ≈2.718, não 10",
                                    "Ignorar o sinal negativo no expoente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e reproduzir a fórmula exata",
                                  "subSteps": [
                                    "Escreva a fórmula σ(x) = 1 / (1 + e^{-x}) dez vezes de memória.",
                                    "Cubra a fórmula e recite em voz alta, justificando cada termo.",
                                    "Teste variações: substitua x por valores como 0, 1, -1 e calcule manualmente.",
                                    "Escreva a fórmula em notação LaTeX ou simbólica para prática.",
                                    "Crie um mnemônico: '1 sobre (1 + exp negativo x)'."
                                  ],
                                  "verification": "Reproduza a fórmula corretamente em um papel sem olhar, em menos de 30 segundos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para repetição",
                                    "Flashcards com fórmula coberta",
                                    "Calculadora para verificação numérica"
                                  ],
                                  "tips": "Associe à 'S' de sigmoide como 'suavizador' de 0 para 1.",
                                  "learningObjective": "Fixar a fórmula na memória de longo prazo para reprodução instantânea.",
                                  "commonMistakes": [
                                    "Escrever e^{x} em vez de e^{-x}",
                                    "Colocar parênteses errados no denominador",
                                    "Confundir com tanh ou ReLU"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o comportamento assintótico",
                                  "subSteps": [
                                    "Calcule limite x → ∞: e^{-x} → 0, então σ(x) → 1 / (1+0) = 1.",
                                    "Calcule limite x → -∞: e^{-x} → ∞, então σ(x) → 1 / ∞ = 0.",
                                    "Desenhe gráfico aproximado mostrando curvas assintóticas em y=0 e y=1.",
                                    "Explique por que isso modela probabilidades ou ativações 'binárias suaves'.",
                                    "Verifique com valores extremos: σ(10) ≈1, σ(-10)≈0."
                                  ],
                                  "verification": "Explique os limites em uma frase cada e calcule σ(5) e σ(-5) com erro <0.01.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos online (GeoGebra ou Python Matplotlib)",
                                    "Tabela de valores x de -10 a 10",
                                    "Livro de cálculo limites"
                                  ],
                                  "tips": "Use regra de L'Hôpital se precisar formalizar, mas foque na intuição exponencial.",
                                  "learningObjective": "Dominar os limites assintóticos e sua interpretação.",
                                  "commonMistakes": [
                                    "Invertar limites: achar que x→∞ vai a 0",
                                    "Esquecer que assíntotas são horizontais",
                                    "Confundir com crescimento linear"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e sintetizar o conhecimento",
                                  "subSteps": [
                                    "Plote ou calcule σ(x) para 5 pontos e confirme fórmula.",
                                    "Escreva um parágrafo resumindo fórmula + assíntotas.",
                                    "Compare sigmoide com outras ativações (ex: linear vai a ∞).",
                                    "Responda quiz: 'O que acontece em x=0? σ(0)=0.5'.",
                                    "Ensine a fórmula para um 'aluno imaginário'."
                                  ],
                                  "verification": "Quiz autoavaliado: fórmula, limites e σ(0) corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para plot",
                                    "Quiz impresso com 5 perguntas"
                                  ],
                                  "tips": "Sempre teste em x=0: σ(0)=1/(1+1)=0.5, ponto médio perfeito.",
                                  "learningObjective": "Integrar fórmula e assíntotas em compreensão coesa.",
                                  "commonMistakes": [
                                    "Achar que σ(x) atinge exatamente 0 ou 1",
                                    "Ignorar que é sempre entre 0 e 1 exclusiva",
                                    "Confundir com função logística geral"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede neural para prever risco de colapso de uma ponte (Engenharia Civil), a sigmoide transforma a soma ponderada de entradas (ex: tensão, carga) em uma probabilidade de falha: σ(5.2) ≈ 0.994 (alta risco), ajudando a decidir inspeções prioritárias.",
                              "finalVerifications": [
                                "Reproduz a fórmula σ(x) = 1 / (1 + e^{-x}) sem erros.",
                                "Explica corretamente limites: x→∞ →1, x→-∞ →0.",
                                "Calcula σ(0)=0.5 e dois valores extremos com precisão.",
                                "Desenha gráfico com assíntotas horizontais.",
                                "Justifica uso em ativações de redes neurais.",
                                "Diferencia de funções lineares ou degrau."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula (100% exata).",
                                "Correta descrição assintótica com cálculos de limite.",
                                "Demonstração prática via cálculo ou plot.",
                                "Explicação clara e concisa do comportamento.",
                                "Integração com contexto de redes neurais.",
                                "Ausência de erros comuns como inversão de limites."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de limites e funções exponenciais.",
                                "Programação: Implementar em Python (numpy: 1/(1+np.exp(-x))).",
                                "Estatística: Modelagem probabilística (logística).",
                                "Física: Comportamento de sistemas saturados (ex: diodos).",
                                "Engenharia de Software: Otimização em machine learning."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, funções sigmoide em redes neurais preveem probabilidades de falhas estruturais em pontes ou edifícios baseadas em sensores IoT, permitindo manutenção preditiva e alocação eficiente de recursos, evitando colapsos como o de Genoa (2018)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.1.2",
                            "name": "Analisar propriedades da sigmoide",
                            "description": "Identificar propriedades como derivada σ'(x) = σ(x)(1 - σ(x)), suavidade contínua, problema do vanishing gradient em redes profundas e sua interpretação probabilística em saídas de classificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar e compreender a fórmula da sigmoide e sua derivada",
                                  "subSteps": [
                                    "Defina a função sigmoide: σ(x) = 1 / (1 + e^{-x})",
                                    "Derive a derivada usando regras de cálculo: calcule σ'(x) manualmente",
                                    "Simplifique para obter σ'(x) = σ(x)(1 - σ(x))",
                                    "Plote σ(x) e σ'(x) usando software para visualização",
                                    "Analise o pico da derivada em x=0"
                                  ],
                                  "verification": "Derivação correta escrita e gráfico mostrando σ(x) entre 0-1 e σ'(x) com máximo 0.25 em x=0",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Papel e lápis",
                                    "Python com NumPy e Matplotlib",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use expansão de Taylor para e^{-x} se necessário; foque na simplicidade da derivada",
                                  "learningObjective": "Dominar a derivação exata da sigmoide e sua propriedade auto-derivável",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo na exponencial",
                                    "Não simplificar para σ(x)(1-σ(x))",
                                    "Confundir com tanh"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a suavidade contínua e limites da sigmoide",
                                  "subSteps": [
                                    "Verifique lim_{x→∞} σ(x) = 1 e lim_{x→-∞} σ(x) = 0",
                                    "Confirme continuidade e derivabilidade em todo ℝ",
                                    "Compare com funções de degrau (Heaviside) para destacar suavidade",
                                    "Calcule segunda derivada para convexidade",
                                    "Discuta intervalos de saturação (x < -4 ou x > 4)"
                                  ],
                                  "verification": "Gráficos e cálculos mostrando limites, continuidade e saturação",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Software de plotagem (Matplotlib ou Desmos)",
                                    "Folha de cálculo"
                                  ],
                                  "tips": "Use zoom em gráficos para ver suavidade perto de 0; teste valores extremos",
                                  "learningObjective": "Identificar como a sigmoide modela transições suaves em problemas não-lineares",
                                  "commonMistakes": [
                                    "Ignorar saturação levando a gradientes zero",
                                    "Confundir com linearidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar o problema do vanishing gradient",
                                  "subSteps": [
                                    "Explique como |σ'(x)| ≤ 0.25 causa gradientes pequenos em camadas profundas",
                                    "Simule backpropagation em uma rede de 5 camadas com sigmoide",
                                    "Compare gradientes com ReLU em mesma simulação",
                                    "Calcule gradiente médio em ativações saturadas",
                                    "Discuta soluções como inicialização Xavier ou ativações alternativas"
                                  ],
                                  "verification": "Simulação numérica mostrando gradientes < 10^{-3} após 3 camadas",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Python com NumPy ou TensorFlow simples",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use valores de entrada grandes para forçar saturação; log-scale nos gradientes",
                                  "learningObjective": "Compreender limitações da sigmoide em redes profundas",
                                  "commonMistakes": [
                                    "Não normalizar entradas",
                                    "Confundir com exploding gradients"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar interpretação probabilística em classificação",
                                  "subSteps": [
                                    "Interprete σ(x) como probabilidade P(y=1|x)",
                                    "Some saídas de múltiplas sigmoides para softmax em multi-classe",
                                    "Aplique em dataset binário (ex: falha/ não falha em estruturas)",
                                    "Calcule log-loss e sua relação com derivada",
                                    "Valide com predições em exemplo real"
                                  ],
                                  "verification": "Exemplo com predições probabilísticas somando a 1 e perda calculada corretamente",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Dataset simples CSV",
                                    "Python Scikit-learn para logit"
                                  ],
                                  "tips": "Normalize logits antes de sigmoide; use cross-entropy loss",
                                  "learningObjective": "Ligar sigmoide a modelos probabilísticos em classificação",
                                  "commonMistakes": [
                                    "Usar sigmoide em regressão multi-classe sem softmax",
                                    "Ignorar escala de logits"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de RNA para prever colapso de vigas em engenharia civil: use sigmoide na saída para P(colapso|estresse, material). Plote σ(estresse) mostrando transição suave de 0.1 a 0.9 entre 200-400 MPa, derive gradientes para otimizar pesos via backprop, identifique vanishing em rede profunda simulando 10 épocas.",
                              "finalVerifications": [
                                "Derivação de σ'(x) correta e simplificada",
                                "Gráficos de σ(x), σ'(x) com limites e saturação identificados",
                                "Simulação demonstrando vanishing gradient <0.01 após 4 camadas",
                                "Exemplo de classificação com probabilidades válidas [0,1]",
                                "Explicação verbal de 3 propriedades principais",
                                "Comparação com ReLU em gradientes"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivada e limites (100%)",
                                "Análise qualitativa/quantitativa do vanishing gradient",
                                "Correta interpretação probabilística com exemplo",
                                "Uso adequado de ferramentas computacionais",
                                "Identificação de erros comuns e soluções",
                                "Conexão clara com aplicações em RNA"
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Derivação e análise de funções",
                                "Probabilidade e Estatística: Interpretação como distribuição Bernoulli",
                                "Programação Computacional: Simulações em Python/NumPy",
                                "Engenharia Civil: Modelagem não-linear de materiais",
                                "Otimização: Backpropagation e gradientes descendentes"
                              ],
                              "realWorldApplication": "Em engenharia civil, sigmoides em RNAs predizem probabilidades de falha em estruturas (ex: pontes sob carga), detectam anomalias em sensores IoT de concreto armado, ou otimizam tráfego em simulações urbanas, onde suavidade modela transições graduais e probabilidades guiam decisões de manutenção preventiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.1.3",
                            "name": "Implementar sigmoide em programação",
                            "description": "Codificar a função sigmoide e sua derivada em Python ou MATLAB, aplicando-a a um vetor de entradas para simular ativação de neurônios em uma camada de rede neural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as fórmulas da função sigmoide e sua derivada",
                                  "subSteps": [
                                    "Estude a fórmula da sigmoide: σ(z) = 1 / (1 + e^{-z})",
                                    "Analise o comportamento: limite para z→∞ é 1, z→-∞ é 0, em z=0 é 0.5",
                                    "Derive a derivada: σ'(z) = σ(z) * (1 - σ(z))",
                                    "Verifique graficamente ou mentalmente: pico em z=0 com valor 0.25",
                                    "Compare com outras ativações como ReLU para contexto"
                                  ],
                                  "verification": "Explique verbalmente ou anote as fórmulas e comportamentos principais sem erros",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Calculadora ou Python para testes rápidos",
                                    "Documentação de funções de ativação (opcional)"
                                  ],
                                  "tips": "Use expansões de Taylor aproximadas para entender o comportamento perto de z=0",
                                  "learningObjective": "Dominar as equações matemáticas e propriedades da sigmoide e derivada para implementação precisa",
                                  "commonMistakes": [
                                    "Confundir sigmoide com tanh",
                                    "Esquecer o sinal negativo no expoente",
                                    "Ignorar que derivada depende da sigmoide em si"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função sigmoide em Python usando NumPy",
                                  "subSteps": [
                                    "Importe numpy as np",
                                    "Defina def sigmoid(z): onde z pode ser escalar ou array",
                                    "Calcule exp_neg_z = np.exp(-z)",
                                    "Retorne 1 / (1 + exp_neg_z)",
                                    "Teste com z=0 (deve retornar ~0.5)"
                                  ],
                                  "verification": "Execute sigmoid(0) == 0.5 e sigmoid(np.array([-2,2])) deve dar [~0.119, ~0.881]",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Python 3+ com NumPy instalado",
                                    "Jupyter Notebook ou IDE como VS Code",
                                    "Biblioteca Matplotlib para plot opcional"
                                  ],
                                  "tips": "Use np.exp para vetores; evite overflow com z grandes usando log-sigmoid se necessário",
                                  "learningObjective": "Codificar uma função vetorizada eficiente para sigmoide",
                                  "commonMistakes": [
                                    "Usar math.exp em vez de np.exp (falha em arrays)",
                                    "Retornar sem vetorização",
                                    "Esquecer import numpy"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a derivada da sigmoide em Python",
                                  "subSteps": [
                                    "Defina def sigmoid_derivative(z):",
                                    "Calcule sigma = sigmoid(z)",
                                    "Retorne sigma * (1 - sigma)",
                                    "Teste com z=0 (deve retornar 0.25)",
                                    "Compare computação direta vs. usando fórmula derivada manual"
                                  ],
                                  "verification": "sigmoid_derivative(0) == 0.25 e para z=np.array([0,1,-1]) valores ~[0.25, 0.1966, 0.1966]",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Mesmos do step 2",
                                    "Função sigmoid já implementada"
                                  ],
                                  "tips": "Reutilize a função sigmoid para eficiência; evite recomputar exp desnecessariamente",
                                  "learningObjective": "Implementar derivada analítica para uso em backpropagation de redes neurais",
                                  "commonMistakes": [
                                    "Calcular derivada numérica em vez de analítica (lenta)",
                                    "Erro em sigma*(1-sigma) como sigma*(sigma-1)",
                                    "Não vetorizar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar funções a vetor de entradas e simular ativação neural",
                                  "subSteps": [
                                    "Crie vetor z = np.linspace(-10,10,100)",
                                    "Calcule activations = sigmoid(z)",
                                    "Calcule derivatives = sigmoid_derivative(z)",
                                    "Plote usando plt.plot(z, activations) e plt.plot(z, derivatives)",
                                    "Simule camada: weights = np.random.rand(3,1); inputs = np.random.rand(3,1); net = np.dot(weights.T, inputs); out = sigmoid(net)"
                                  ],
                                  "verification": "Gráfico mostra sigmoide em S suave 0-1 e derivada em sino ~0.25 pico; simulação roda sem erros",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "NumPy e Matplotlib",
                                    "Jupyter para visualização interativa"
                                  ],
                                  "tips": "Normalize z para evitar overflow; use plt.grid() e labels para clareza",
                                  "learningObjective": "Simular ativação de neurônios em camada simples com entradas vetoriais",
                                  "commonMistakes": [
                                    "Overflow em np.exp(-z grande)",
                                    "Plot errada (eixos trocados)",
                                    "Não flatten arrays em dot product"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie z = np.array([-5, -2, 0, 2, 5]); activations = sigmoid(z); derivatives = sigmoid_derivative(z). Imprima: activations ≈ [0.0067, 0.1192, 0.5, 0.8808, 0.9933]; derivatives ≈ [0.0066, 0.1966, 0.25, 0.1966, 0.0066]. Plote para visualizar curva S e sino.",
                              "finalVerifications": [
                                "Sigmoide mapeia qualquer real para (0,1) sem overflow",
                                "Derivada em z=0 é exatamente 0.25",
                                "Funções vetorizadas funcionam em arrays de qualquer tamanho",
                                "Gráficos mostram comportamento assintótico correto",
                                "Simulação de camada neural produz saídas coerentes",
                                "Código roda em <1s para 1000 elementos"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: fórmulas exatas sem erros numéricos",
                                "Eficiência: vetorização com NumPy, sem loops",
                                "Testes abrangentes: casos edge (z grande/negativo/pequeno)",
                                "Visualização clara: plots rotulados e legíveis",
                                "Simulação neural: aplicação real a pesos/entradas aleatórios",
                                "Código limpo: funções modulares e comentadas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo (derivadas, limites, exponenciais)",
                                "Programação: Vetorização NumPy, funções puras",
                                "Engenharia Civil: Modelagem preditiva em estruturas via ML",
                                "Estatística: Geração de números aleatórios para inicialização",
                                "Física: Simulação de respostas não-lineares em materiais"
                              ],
                              "realWorldApplication": "Em engenharia civil, implemente sigmoide em redes neurais para prever falhas em estruturas (ex: deformação de vigas sob carga variável) a partir de dados de sensores IoT, otimizando manutenção preditiva via backpropagation."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.2.2",
                        "name": "Função Tangente Hiperbólica (tanh)",
                        "description": "A função tangente hiperbólica é uma função de ativação simétrica que mapeia entradas reais para o intervalo (-1,1), oferecendo centralização em zero, útil em problemas de regressão em engenharia civil como simulações de fluxos.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.2.1",
                            "name": "Definir a fórmula da tanh",
                            "description": "Reproduzir a fórmula tanh(x) = (e^x - e^{-x}) / (e^x + e^{-x}) ou equivalente sinh(x)/cosh(x), destacando seus limites assintóticos em ±1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar funções exponenciais básicas",
                                  "subSteps": [
                                    "Lembre-se da definição de e^x e e^{-x}.",
                                    "Calcule e^x para x=0, x=1 e x=-1 manualmente ou com calculadora.",
                                    "Entenda o comportamento assintótico: e^x → ∞ quando x → ∞, e^x → 0 quando x → -∞.",
                                    "Esboce graficamente y = e^x e y = e^{-x} em papel.",
                                    "Compare os gráficos para visualizar simetria."
                                  ],
                                  "verification": "Reproduzir corretamente os valores de e^0=1, e^1≈2.718, e^{-1}≈0.368 e descrever assíntotas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel e lápis",
                                    "Gráfico de funções exponenciais online (opcional)"
                                  ],
                                  "tips": "Use a aproximação e≈2.718 para cálculos manuais rápidos.",
                                  "learningObjective": "Compreender as propriedades fundamentais das funções exponenciais que formam a base da tanh.",
                                  "commonMistakes": [
                                    "Confundir e^x com 10^x",
                                    "Esquecer que e^{-x} = 1/e^x",
                                    "Ignorar o comportamento em -∞"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir sinh(x) e cosh(x)",
                                  "subSteps": [
                                    "Defina sinh(x) = (e^x - e^{-x})/2.",
                                    "Defina cosh(x) = (e^x + e^{-x})/2.",
                                    "Calcule sinh(0) = 0 e cosh(0) = 1.",
                                    "Verifique que cosh(x) é sempre positivo e par, sinh(x) é ímpar.",
                                    "Esboce curvas básicas de sinh e cosh."
                                  ],
                                  "verification": "Escrever as fórmulas exatas de sinh e cosh e calcular valores em x=0 corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela de valores exponenciais"
                                  ],
                                  "tips": "Lembre-se: sinh é 'senho' (ímpar), cosh é 'cosseno hiperbólico' (par e mínimo 1).",
                                  "learningObjective": "Dominar as definições de sinh e cosh como blocos de construção para tanh.",
                                  "commonMistakes": [
                                    "Trocar os sinais em sinh (subtrair em vez de somar)",
                                    "Esquecer o fator /2",
                                    "Confundir paridade das funções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e memorizar a fórmula da tanh(x)",
                                  "subSteps": [
                                    "Defina tanh(x) = sinh(x)/cosh(x).",
                                    "Expanda: tanh(x) = [(e^x - e^{-x})/2] / [(e^x + e^{-x})/2] = (e^x - e^{-x}) / (e^x + e^{-x}).",
                                    "Simplifique multiplicando numerador e denominador por e^x para forma alternativa: (1 - e^{-2x}) / (1 + e^{-2x}).",
                                    "Memorize as duas formas equivalentes.",
                                    "Calcule tanh(0) = 0 para verificar."
                                  ],
                                  "verification": "Reproduzir ambas as fórmulas sem consulta e simplificar corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para verificação numérica"
                                  ],
                                  "tips": "Visualize tanh como 'diferença sobre soma' das exponenciais para fixar na memória.",
                                  "learningObjective": "Reproduzir com precisão a fórmula da tanh em suas formas padrão.",
                                  "commonMistakes": [
                                    "Esquecer de cancelar o /2 na divisão sinh/cosh",
                                    "Invertar numerador e denominador",
                                    "Usar sinais errados nos expoentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar limites assintóticos da tanh(x)",
                                  "subSteps": [
                                    "Avalie lim x→∞ tanh(x): numerador e denominador dominados por e^x, então → (e^x)/(e^x) = 1.",
                                    "Avalie lim x→-∞ tanh(x): e^x →0, e^{-x}→∞, então → (-e^{-x})/(e^{-x}) = -1.",
                                    "Confirme com valores grandes: tanh(5)≈0.999, tanh(-5)≈-0.999.",
                                    "Esboce o gráfico da tanh mostrando assíntotas horizontais y=1 e y=-1.",
                                    "Compare com sigmoid (que vai de 0 a 1)."
                                  ],
                                  "verification": "Calcular e justificar corretamente os limites em ±∞ como ±1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Software de plotagem como Desmos ou Python (opcional)"
                                  ],
                                  "tips": "Pense em 'tanh satura em ±1 como uma sigmoide centrada em zero'.",
                                  "learningObjective": "Entender o comportamento limite da tanh, essencial para sua aplicação em redes neurais.",
                                  "commonMistakes": [
                                    "Dizer que limite é 0 ou ∞",
                                    "Confundir com limites de sinh/cosh",
                                    "Ignorar a direção de x→-∞"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede neural para previsão de deformações em estruturas civis, implemente tanh(x) em Python: def tanh(x): return (np.exp(x) - np.exp(-x)) / (np.exp(x) + np.exp(-x)). Teste com x=[-2,0,2] obtendo ≈[-0.964,0,0.964], visualizando normalização entre -1 e 1 para estabilidade numérica.",
                              "finalVerifications": [
                                "Reproduzir fórmula tanh(x) = (e^x - e^{-x}) / (e^x + e^{-x}) sem erros.",
                                "Escrever tanh(x) = sinh(x)/cosh(x) e definir sinh/cosh corretamente.",
                                "Justificar lim x→±∞ tanh(x) = ±1 com cálculo limite.",
                                "Calcular tanh(1) ≈ 0.7616 com precisão de 4 casas.",
                                "Esboçar gráfico com assíntotas horizontais.",
                                "Explicar por que tanh é preferida sobre sigmoide em camadas ocultas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na reprodução da fórmula (100% dos termos corretos).",
                                "Correta derivação de sinh/cosh para tanh.",
                                "Justificativa rigorosa dos limites assintóticos.",
                                "Compreensão de propriedades (ímpar, range [-1,1]).",
                                "Aplicação prática em contexto de redes neurais.",
                                "Ausência de erros comuns como sinais invertidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de limites e funções hiperbólicas.",
                                "Programação: Implementação numérica em Python/NumPy para ML.",
                                "Física: Analogia com soluções de equações diferenciais em mecânica.",
                                "Engenharia Civil: Modelagem não-linear em análise estrutural via RNA."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, a tanh é usada como função de ativação em redes neurais para prever respostas não-lineares de materiais em simulações de estruturas sob carga, normalizando saídas entre -1 e 1 para evitar gradientes explosivos durante o treinamento, como em otimização de vigas via Monte Carlo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.2.2",
                            "name": "Descrever propriedades da tanh",
                            "description": "Explicar derivada tanh'(x) = 1 - tanh²(x), vantagens sobre sigmoide (saídas centradas em zero, gradientes mais fortes) e desvantagens como vanishing gradient em saturação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e propriedades básicas da função tanh",
                                  "subSteps": [
                                    "Lembre a fórmula matemática: tanh(x) = (e^x - e^{-x}) / (e^x + e^{-x}) ou sinh(x)/cosh(x)",
                                    "Identifique o domínio: todos os reais (ℝ) e imagem: (-1, 1)",
                                    "Descreva propriedades: função ímpar (tanh(-x) = -tanh(x)), estritamente crescente, assíntotas horizontais em y=1 e y=-1",
                                    "Visualize o gráfico: forma sigmoidal centrada em zero, com ponto de inflexão em x=0",
                                    "Calcule valores chave: tanh(0)=0, lim x→∞ tanh(x)=1, lim x→-∞ tanh(x)=-1"
                                  ],
                                  "verification": "Escreva corretamente a fórmula, imagem e três propriedades principais em um papel ou documento",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora ou software de plotagem como Desmos/Python",
                                  "tips": "Pense na tanh como uma versão normalizada da sigmoide, centrada em zero para melhor convergência em redes neurais",
                                  "learningObjective": "Definir precisamente a função tanh e listar suas propriedades fundamentais",
                                  "commonMistakes": "Confundir tanh(x) com tan(x) (trigonométrica), que não é limitada"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e entender a derivada da tanh",
                                  "subSteps": [
                                    "Comece com a fórmula: tanh(x) = sinh(x)/cosh(x)",
                                    "Aplique a regra do quociente: tanh'(x) = [cosh²(x) - sinh²(x)] / cosh²(x) = 1 / cosh²(x) = sech²(x)",
                                    "Mostre a forma equivalente: tanh'(x) = 1 - tanh²(x)",
                                    "Calcule exemplos: tanh'(0) = 1, tanh'(∞) ≈ 0",
                                    "Plote ou esboce a derivada: máximo em x=0, decresce simetricamente para zero"
                                  ],
                                  "verification": "Derive tanh'(x) passo a passo e compute tanh'(1) ≈ 0.42 corretamente",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel para derivação, Python/MATLAB para verificação numérica",
                                  "tips": "Use a identidade cosh²(x) - sinh²(x) = 1 para simplificar rapidamente",
                                  "learningObjective": "Derivar tanh'(x) e expressá-la em formas equivalentes",
                                  "commonMistakes": "Esquecer a simplificação para 1 - tanh²(x), útil em backpropagation"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar tanh com sigmoide e destacar vantagens",
                                  "subSteps": [
                                    "Lembre sigmoide: σ(x) = 1/(1 + e^{-x}), range (0,1), não centrada",
                                    "Compare saídas: tanh centrada em zero (média ≈0), sigmoide positiva (média ≈0.5)",
                                    "Analise gradientes: tanh tem gradientes mais fortes em |x| médio devido a range simétrico",
                                    "Discuta convergência: zero-centering reduz bias em camadas ocultas",
                                    "Visualize: Plote ambas funções e derivadas para observar diferenças"
                                  ],
                                  "verification": "Liste duas vantagens da tanh sobre sigmoide com justificativa quantitativa (ex: range)",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráficos comparativos em Python (matplotlib) ou ferramenta online",
                                  "tips": "Em redes neurais, zero-centering acelera treinamento por equilíbrio de gradientes",
                                  "learningObjective": "Explicar vantagens da tanh em termos de saída e gradientes",
                                  "commonMistakes": "Ignorar que sigmoide é sempre positiva, causando shift em ativações"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar desvantagens da tanh, focando em vanishing gradient",
                                  "subSteps": [
                                    "Observe saturação: para |x| > 3, tanh(x) ≈ ±1, derivada ≈0",
                                    "Explique vanishing gradient: gradientes propagados multiplicam por valores <1, tendem a zero",
                                    "Compare com sigmoide: ambas sofrem, mas tanh satura bilateralmente",
                                    "Discuta impactos: treinamento lento em regiões saturadas",
                                    "Sugira mitigações: inicialização adequada (Xavier), ReLU como alternativa"
                                  ],
                                  "verification": "Descreva o problema de vanishing gradient com exemplo numérico (tanh(5)≈1, derivada≈0)",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel para cálculos, código Python para simular gradiente",
                                  "tips": "Monitore ativações durante treinamento para evitar saturação precoce",
                                  "learningObjective": "Reconhecer limitações da tanh e seu impacto no treinamento de redes",
                                  "commonMistakes": "Confundir vanishing com exploding gradient (gradientes >1)"
                                }
                              ],
                              "practicalExample": "Em Python com NumPy e Matplotlib: def tanh(x): return np.tanh(x); def sigmoid(x): return 1/(1+np.exp(-x)); x = np.linspace(-5,5,100); plt.plot(x, tanh(x), label='tanh'); plt.plot(x, sigmoid(x), label='sigmoid'); plt.plot(x, 1-tanh(x)**2, '--', label=\"tanh'\"); Compare visualmente saídas centradas e gradientes mais fortes da tanh em |x|<2.",
                              "finalVerifications": [
                                "Recitar fórmula de tanh(x) e tanh'(x) = 1 - tanh²(x) sem erros",
                                "Listar duas vantagens sobre sigmoide com exemplos numéricos",
                                "Explicar vanishing gradient com cálculo de derivada em x=4",
                                "Plotar tanh vs sigmoide e descrever diferenças chave",
                                "Discutir quando usar tanh em uma RNA simples",
                                "Identificar saturação em valores |x|>3"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: fórmulas e derivadas corretas (40%)",
                                "Compreensão comparativa: vantagens/desvantagens claras e justificadas (30%)",
                                "Análise visual/numérica: gráficos ou cálculos precisos (15%)",
                                "Aplicação contextual: ligação com treinamento de redes (10%)",
                                "Clareza na explicação: linguagem técnica acessível (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial e funções hiperbólicas",
                                "Programação: Implementação em bibliotecas de ML (TensorFlow/PyTorch)",
                                "Estatística: Otimização de gradiente descendente e backpropagation",
                                "Engenharia Civil Computacional: Normalização em modelos preditivos para análise estrutural"
                              ],
                              "realWorldApplication": "Em redes neurais para previsão de deformações em estruturas civis sob cargas dinâmicas, tanh normaliza entradas de sensores (deslocamentos centrados em zero), acelerando convergência e melhorando precisão em simulações de Monte Carlo integradas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.2.3",
                            "name": "Comparar tanh com sigmoide",
                            "description": "Analisar diferenças em termos de faixa de saída, gradientes e impacto no treinamento de redes neurais para problemas não-lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Função Sigmoide",
                                  "subSteps": [
                                    "Estude a fórmula matemática da sigmoide: σ(x) = 1 / (1 + e^{-x}).",
                                    "Plote o gráfico da sigmoide para x de -10 a 10 usando Python e Matplotlib.",
                                    "Calcule saídas para valores específicos: x=-5 (≈0), x=0 (0.5), x=5 (≈1).",
                                    "Derive a função: σ'(x) = σ(x) * (1 - σ(x)) e plote a derivada.",
                                    "Observe a faixa de saída (0 a 1) e o comportamento assintótico."
                                  ],
                                  "verification": "Gráficos da função e derivada plotados corretamente com rótulos adequados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "Bibliotecas NumPy e Matplotlib"
                                  ],
                                  "tips": "Use np.linspace para gerar pontos suaves no eixo x.",
                                  "learningObjective": "Compreender a forma, faixa de saída e derivada da função sigmoide.",
                                  "commonMistakes": [
                                    "Confundir a sigmoide com a tanh (faixa diferente)",
                                    "Esquecer de plotar a derivada para análise de gradientes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar a Função Tangente Hiperbólica (tanh)",
                                  "subSteps": [
                                    "Estude a fórmula: tanh(x) = (e^x - e^{-x}) / (e^x + e^{-x}) ou sinh(x)/cosh(x).",
                                    "Plote o gráfico da tanh para x de -10 a 10.",
                                    "Calcule saídas: x=-5 (≈-1), x=0 (0), x=5 (≈1).",
                                    "Derive: tanh'(x) = 1 - tanh(x)^2 e plote.",
                                    "Note a faixa de saída (-1 a 1) e simetria em torno de zero."
                                  ],
                                  "verification": "Gráficos comparáveis aos da sigmoide, com derivada mostrando pico em x=0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "Bibliotecas NumPy e Matplotlib"
                                  ],
                                  "tips": "Compare visualmente com o gráfico da sigmoide no mesmo plot.",
                                  "learningObjective": "Dominar a forma, faixa e derivada da tanh.",
                                  "commonMistakes": [
                                    "Ignorar a centralização em zero",
                                    "Calcular derivada incorretamente como sigmoide"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Faixas de Saída e Gradientes",
                                  "subSteps": [
                                    "Sobreponha gráficos de sigmoide e tanh em um plot único.",
                                    "Compare faixas: sigmoide (0-1, não centrada) vs. tanh (-1-1, centrada em 0).",
                                    "Analise derivadas: sigmoide máxima 0.25 em x=0; tanh máxima 1 em x=0.",
                                    "Calcule gradientes para |x|>3: ambos pequenos (vanishing gradient), mas tanh menos saturado.",
                                    "Discuta implicações: tanh preserva sinal, melhor para hidden layers."
                                  ],
                                  "verification": "Tabela ou relatório escrito com diferenças numéricas e gráficas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "NumPy, Matplotlib",
                                    "Planilha ou Markdown para tabela"
                                  ],
                                  "tips": "Use cores diferentes para cada função e adicione legendas.",
                                  "learningObjective": "Identificar diferenças quantitativas em saída e gradientes.",
                                  "commonMistakes": [
                                    "Afirmar que sigmoide é centrada em zero",
                                    "Ignorar que tanh tem gradiente mais íngreme perto de zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto no Treinamento de Redes Neurais",
                                  "subSteps": [
                                    "Explique vanishing gradient: gradientes pequenos em saturação dificultam backpropagation.",
                                    "Compare em problemas não-lineares (ex: XOR): sigmoide pior por não centralizar.",
                                    "Implemente rede simples (1 hidden layer) com cada ativação e treine.",
                                    "Compare curvas de loss e acurácia ao longo de épocas.",
                                    "Conclua: tanh geralmente melhor para hidden layers em problemas não-lineares."
                                  ],
                                  "verification": "Curvas de loss plotadas mostrando convergência mais rápida com tanh.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python",
                                    "TensorFlow/Keras ou PyTorch",
                                    "Dataset XOR simples"
                                  ],
                                  "tips": "Use learning rate baixo (0.1) e 100 épocas para observar diferenças.",
                                  "learningObjective": "Avaliar como diferenças afetam treinamento prático.",
                                  "commonMistakes": [
                                    "Usar dataset linear onde diferenças são mínimas",
                                    "Confundir output layer (sigmoide para probabilidades)"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma rede neural para classificar o dataset XOR usando Keras: uma com ativação sigmoide no hidden layer e outra com tanh. Treine ambas por 200 épocas e compare as curvas de loss. Observe que tanh converge mais rápido devido a gradientes melhores.",
                              "finalVerifications": [
                                "Explicar verbalmente as faixas de saída de sigmoide (0-1) e tanh (-1-1).",
                                "Desenhar à mão os gráficos de ambas funções e derivadas.",
                                "Identificar corretamente o problema de vanishing gradient em sigmoide.",
                                "Prever que tanh é preferível para camadas ocultas em RNR não-lineares.",
                                "Comparar numericamente derivadas em x=0 e x=3.",
                                "Discutir cenários onde sigmoide ainda é usada (ex: output para classificação binária)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das fórmulas e faixas de saída (100% correto).",
                                "Análise qualitativa e quantitativa de gradientes (com plots e cálculos).",
                                "Compreensão do impacto no vanishing gradient e backpropagation.",
                                "Evidência prática via experimento de treinamento (curvas de loss comparadas).",
                                "Uso correto de terminologia em redes neurais (hidden vs output layers).",
                                "Conexão clara com problemas não-lineares em engenharia."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções hiperbólicas e derivadas (cálculo diferencial).",
                                "Programação: Implementação numérica com NumPy e bibliotecas de ML.",
                                "Estatística: Normalização de dados e distribuições sigmoidais.",
                                "Engenharia Civil: Modelagem de comportamentos não-lineares em estruturas."
                              ],
                              "realWorldApplication": "Em simulações computacionais de engenharia civil, como previsão de deformações não-lineares em estruturas sob carga usando RNR, a tanh melhora o treinamento ao centralizar ativações, acelerando convergência em métodos de Monte Carlo para análise de incertezas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.2.3",
                        "name": "Função ReLU (Rectified Linear Unit)",
                        "description": "A função ReLU é uma ativação não-linear simples e eficiente, definida como ReLU(x) = max(0, x), amplamente usada em redes profundas para acelerar convergência em aplicações como detecção de falhas em estruturas civis.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.3.1",
                            "name": "Definir a fórmula da ReLU",
                            "description": "Descrever ReLU(x) = max(0, x), sua piecewise linearidade e comportamento: zero para x < 0 e linear para x ≥ 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender funções piecewise lineares",
                                  "subSteps": [
                                    "Defina o que é uma função piecewise linear: uma função definida por segmentos lineares em diferentes intervalos.",
                                    "Estude exemplos simples, como f(x) = x se x >= 0, 0 se x < 0.",
                                    "Discuta por que funções piecewise são úteis em redes neurais para modelar não-linearidades.",
                                    "Compare com funções lineares puras e suas limitações em aprendizado de máquina.",
                                    "Identifique intervalos de definição em funções piecewise."
                                  ],
                                  "verification": "Escreva um exemplo de função piecewise linear e identifique seus segmentos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráfico de exemplo impresso ou digital"
                                  ],
                                  "tips": "Comece com gráficos para visualizar os 'quebras' nos segmentos.",
                                  "learningObjective": "Compreender o conceito fundamental de funções piecewise lineares e sua relevância em ativações neurais.",
                                  "commonMistakes": [
                                    "Confundir piecewise com polinomial",
                                    "Ignorar os pontos de transição entre segmentos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a função max(0, x)",
                                  "subSteps": [
                                    "Defina a função max(a, b) como o maior valor entre a e b.",
                                    "Analise max(0, x): retorne 0 se x < 0, x se x >= 0.",
                                    "Calcule valores: max(0, -2) = 0, max(0, 0) = 0, max(0, 3) = 3.",
                                    "Desenhe o gráfico manualmente, identificando o eixo x como limite.",
                                    "Discuta propriedades: não-diferenciável em x=0, mas subgradiente útil em otimização."
                                  ],
                                  "verification": "Calcule e grafique max(0, x) para x em [-3, 3].",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Ferramenta de plotagem como Desmos ou GeoGebra"
                                  ],
                                  "tips": "Use uma tabela de valores para plotar pontos antes de conectar linhas.",
                                  "learningObjective": "Dominar a função max(0, x) como base para ReLU.",
                                  "commonMistakes": [
                                    "Esquecer que em x=0 retorna 0, não indefinido",
                                    "Plotar incorretamente para x<0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir formalmente a fórmula da ReLU",
                                  "subSteps": [
                                    "Estabeleça a notação: ReLU(x) = max(0, x).",
                                    "Escreva equivalentemente como definição piecewise: ReLU(x) = 0 se x < 0, x se x >= 0.",
                                    "Verifique consistência entre as duas formas com cálculos.",
                                    "Nomeie a sigla: Rectified Linear Unit e sua origem.",
                                    "Compare brevemente com leaky ReLU para contexto."
                                  ],
                                  "verification": "Escreva as duas formas da fórmula ReLU(x) sem consultar referências.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Referência rápida de funções de ativação"
                                  ],
                                  "tips": "Memorize usando mnemônica: 'ReLU retifica o negativo para zero'.",
                                  "learningObjective": "Formalizar e memorizar a definição exata de ReLU(x).",
                                  "commonMistakes": [
                                    "Escrever ReLU(x) = max(x, 0) invertido",
                                    "Incluir sigmoid na definição"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar comportamento e piecewise linearidade",
                                  "subSteps": [
                                    "Descreva comportamento: zero (constante) para x < 0, linear (inclinação 1) para x >= 0.",
                                    "Confirme piecewise linearidade: dois segmentos lineares unidos em x=0.",
                                    "Discuta vantagens: evita vanishing gradient, computacionalmente eficiente.",
                                    "Implemente um plot simples em Python ou ferramenta online.",
                                    "Teste com valores de entrada em contexto de neurônio: soma ponderada negativa/positiva."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o comportamento em cada região e desenhe o gráfico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com Matplotlib ou Desmos",
                                    "Exemplos de entradas neurais"
                                  ],
                                  "tips": "Pense em ReLU como 'desligando' neurônios para entradas negativas.",
                                  "learningObjective": "Analisar e articular as propriedades chave da ReLU.",
                                  "commonMistakes": [
                                    "Descrever como suave/curva em vez de linear piecewise",
                                    "Negar a linearidade para x>=0"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede neural para prever cargas em vigas de concreto, após calcular a soma ponderada z = -1.5 (compressão negativa simulada), aplique ReLU(z) = max(0, -1.5) = 0, ativando apenas deformações positivas; para z = 2.3, ReLU(z) = 2.3, propagando a ativação linear.",
                              "finalVerifications": [
                                "Escrever corretamente ReLU(x) = max(0, x) e sua forma piecewise.",
                                "Desenhar o gráfico preciso de ReLU(x) para x em [-5, 5].",
                                "Calcular ReLU(-3), ReLU(0), ReLU(4.2) sem erros.",
                                "Explicar verbalmente o comportamento para x < 0 e x >= 0.",
                                "Identificar ReLU como piecewise linear com dois segmentos.",
                                "Diferenciar ReLU de funções sigmóide ou tangente hiperbólica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula matemática (100% correto).",
                                "Correta descrição do comportamento piecewise.",
                                "Qualidade do gráfico: eixos corretos, segmentos lineares nítidos.",
                                "Exemplos numéricos sem erros de cálculo.",
                                "Compreensão de vantagens em redes neurais.",
                                "Articulação clara de linearidade e retificação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções piecewise e continuidade.",
                                "Programação: Implementação em Python (numpy.maximum(0, x)).",
                                "Engenharia Civil: Aplicações em modelagem preditiva de estruturas via ML.",
                                "Física: Analogia com retificação de sinais em sensores estruturais.",
                                "Estatística: Otimização de gradientes em treinamento de redes."
                              ],
                              "realWorldApplication": "Na engenharia civil, ReLU é usada em redes neurais convolucionais para análise de imagens de drones, detectando rachaduras em pontes: ativações zero para pixels de fundo irrelevantes aceleram o treinamento e melhoram a precisão em previsões de manutenção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.3.2",
                            "name": "Explicar vantagens e problemas da ReLU",
                            "description": "Discutir aceleração computacional, mitigação de vanishing gradient, problema dos 'neurônios mortos' (dead neurons) e variantes como Leaky ReLU.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Definição e Fórmula da ReLU",
                                  "subSteps": [
                                    "Estude a fórmula matemática da ReLU: f(x) = max(0, x).",
                                    "Compare visualmente com funções como Sigmoid e Tanh usando gráficos.",
                                    "Implemente a ReLU em código Python simples para observar o comportamento.",
                                    "Analise o output para entradas positivas e negativas.",
                                    "Desenhe o gráfico da ReLU manualmente para fixar a forma."
                                  ],
                                  "verification": "Crie um gráfico da ReLU e explique verbalmente sua forma piecewise linear.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notebook Jupyter ou Google Colab, bibliotecas Matplotlib e NumPy.",
                                  "tips": "Use valores de entrada variados (-5 a 5) para ver claramente o 'zeroing' de negativos.",
                                  "learningObjective": "Compreender a mecânica básica da ReLU como uma função não-linear simples.",
                                  "commonMistakes": "Confundir ReLU com uma função linear; lembrar que ela é piecewise linear."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Vantagens Computacionais e contra Vanishing Gradient",
                                  "subSteps": [
                                    "Calcule derivadas: mostre que a derivada da ReLU é 1 para x>0 e 0 para x<0.",
                                    "Compare tempo de computação com Sigmoid (evita exponenciais caras).",
                                    "Simule backpropagation em uma rede simples para demonstrar ausência de vanishing gradient.",
                                    "Meça aceleração: treine mini-redes com ReLU vs Sigmoid e compare epochs.",
                                    "Discuta impacto em redes profundas."
                                  ],
                                  "verification": "Execute um benchmark simples e relate redução de tempo >20%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com TensorFlow/Keras, timer para benchmarks.",
                                  "tips": "Use redes pequenas (2-3 camadas) para testes rápidos.",
                                  "learningObjective": "Identificar como ReLU acelera treinamento e evita gradientes nulos.",
                                  "commonMistakes": "Ignorar que vanishing gradient persiste em regiões saturadas de outras funções."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Problema dos 'Neurônios Mortos' (Dead Neurons)",
                                  "subSteps": [
                                    "Explique dead neurons: neurônios com input sempre negativo, output=0 e gradiente=0.",
                                    "Simule em código: inicialize pesos para forçar dead neurons.",
                                    "Meça percentual de dead neurons após treinamento.",
                                    "Discuta causas: inicialização de pesos ruim (ex: Xavier/He).",
                                    "Visualize ativações em uma rede treinada."
                                  ],
                                  "verification": "Identifique e quantifique dead neurons em uma simulação (>10% indica problema).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código Python com visualização de ativações (Matplotlib/Seaborn).",
                                  "tips": "Use inicialização He para mitigar, mas force problema alterando pesos.",
                                  "learningObjective": "Reconhecer e quantificar o problema de dead neurons na ReLU.",
                                  "commonMistakes": "Achar que dead neurons são raros; eles ocorrem em ~10-20% sem cuidados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar Variantes da ReLU para Mitigar Problemas",
                                  "subSteps": [
                                    "Implemente Leaky ReLU: f(x) = x if x>0 else αx (α=0.01).",
                                    "Compare com ReLU padrão em uma rede treinada.",
                                    "Teste ELU e PReLU brevemente.",
                                    "Avalie trade-offs: precisão vs complexidade computacional.",
                                    "Recomende uso baseado em cenários."
                                  ],
                                  "verification": "Treine redes comparativas e mostre melhora em dead neurons com Leaky ReLU.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "TensorFlow/Keras para variantes de ativação.",
                                  "tips": "Fixe seed para reproducibilidade nas comparações.",
                                  "learningObjective": "Compreender soluções como Leaky ReLU para problemas da ReLU vanilla.",
                                  "commonMistakes": "Escolher α muito alto em Leaky ReLU, reintroduzindo saturação."
                                }
                              ],
                              "practicalExample": "Em um projeto de previsão de deformações em vigas de concreto usando uma RNA, implemente ReLU em camadas ocultas: observe aceleração no treinamento (50% mais rápido que Sigmoid) mas detecte 15% dead neurons; mude para Leaky ReLU e reduza para <5%, melhorando precisão em 3%.",
                              "finalVerifications": [
                                "Explicar fórmula ReLU e derivada corretamente.",
                                "Listar 3 vantagens com justificativa matemática.",
                                "Definir e exemplificar dead neurons.",
                                "Comparar ReLU vs Leaky ReLU em prós/contras.",
                                "Executar benchmark simples com resultados.",
                                "Discutir impacto em redes profundas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de vantagens (computacional e gradient): 25%.",
                                "Profundidade na análise de dead neurons e causas: 25%.",
                                "Demonstração prática com código/gráficos: 20%.",
                                "Cobertura de variantes e recomendações: 15%.",
                                "Clareza e estrutura na discussão: 10%.",
                                "Conexão com aplicações reais: 5%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Derivadas e funções piecewise lineares.",
                                "Estatística: Inicialização de pesos (distribuições Xavier/He).",
                                "Engenharia Civil: Otimização em modelagem de estruturas via RNA.",
                                "Computação: Algoritmos de backpropagation e eficiência.",
                                "Física: Analogia com comportamentos não-lineares em materiais."
                              ],
                              "realWorldApplication": "Na engenharia civil, ReLUs aceleram simulações de Monte Carlo para análise de risco em barragens, mitigando vanishing gradients em redes profundas para previsão de falhas; Leaky ReLU previne dead neurons em datasets ruidosos de sensores estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.3.3",
                            "name": "Implementar ReLU em código",
                            "description": "Programar ReLU e sua derivada subgradiente em Python/MATLAB, testando em uma camada neural simples e comparando com sigmoide/tanh.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Função ReLU e sua Derivada Subgradiente",
                                  "subSteps": [
                                    "Estude a definição matemática: ReLU(x) = max(0, x)",
                                    "Analise a derivada subgradiente: 0 para x < 0, 1 para x > 0, e subgradiente [0,1] em x=0",
                                    "Revise brevemente sigmoide (1/(1+exp(-x))) e tanh ( (exp(x)-exp(-x))/(exp(x)+exp(-x)) ) para comparação posterior",
                                    "Desenhe gráficos manuais ou use ferramentas para visualizar as funções",
                                    "Explique por que ReLU mitiga vanishing gradients"
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças chave e a derivada subgradiente de ReLU",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para esboços",
                                    "NumPy e Matplotlib para gráficos iniciais",
                                    "Documentação oficial de ReLU (ex: papers de Hinton)"
                                  ],
                                  "tips": [
                                    "Use x=0 como ponto crítico para testes; subgradiente permite flexibilidade em otimizadores"
                                  ],
                                  "learningObjective": "Dominar a matemática exata de ReLU e sua derivada para implementação precisa",
                                  "commonMistakes": [
                                    "Assumir derivada em x=0 como indefinida sem subgradiente",
                                    "Confundir ReLU com leaky ReLU",
                                    "Ignorar não-diferenciabilidade em x=0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar ReLU e Derivada em Python",
                                  "subSteps": [
                                    "Instale/importe NumPy: import numpy as np",
                                    "Defina def relu(z): return np.maximum(0, z)",
                                    "Defina def relu_deriv(z): return (z > 0).astype(float)  # ou np.heaviside(z, 0.5) para subgradiente em 0",
                                    "Crie testes unitários: teste com arrays [-1,0,1] e verifique saídas [0,0,1] e derivadas [0,0,1]",
                                    "Adicione visualização: plote funções com Matplotlib"
                                  ],
                                  "verification": "Execute testes unitários e confirme saídas exatas com print ou assert",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": [
                                    "Use vetorização NumPy para eficiência; evite loops para arrays grandes"
                                  ],
                                  "learningObjective": "Codificar funções ReLU e derivada de forma vetorizada e testável",
                                  "commonMistakes": [
                                    "Usar if/else em loops em vez de np.maximum",
                                    "Retornar NaN em z=0 na derivada",
                                    "Esquecer importações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar ReLU em uma Camada Neural Simples",
                                  "subSteps": [
                                    "Defina uma camada: pesos W (2x3), bias b (1x3), entrada X (1x2)",
                                    "Compute forward: Z = X @ W + b; A = relu(Z)",
                                    "Simule backward: dZ = dA * relu_deriv(Z); dW = X.T @ dZ; db = sum(dZ)",
                                    "Teste com dados fictícios: X = [[1, -1]], W aleatório, assuma dA = [[0.5, 0.5]]",
                                    "Verifique dimensionalidade e valores numéricos"
                                  ],
                                  "verification": "Confirme que forward produz não-negativos e backward propaga gradientes corretamente (0 onde Z<0)",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "NumPy",
                                    "Jupyter Notebook",
                                    "Código das funções ReLU anteriores"
                                  ],
                                  "tips": [
                                    "Use np.random.seed(42) para reprodutibilidade; debugue com prints intermediários"
                                  ],
                                  "learningObjective": "Integrar ReLU em forward/backward pass de uma camada neural",
                                  "commonMistakes": [
                                    "Erro em broadcasting de bias",
                                    "Não transpor corretamente para dW",
                                    "Aplicar derivada no forward"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar ReLU com Sigmoide e Tanh",
                                  "subSteps": [
                                    "Implemente sigmoid(z): 1 / (1 + np.exp(-np.clip(z, -250, 250))) e derivada sigmoid(z)*(1-sigmoid(z))",
                                    "Implemente tanh(z): np.tanh(z) e derivada 1 - tanh(z)**2",
                                    "Repita forward/backward da camada com cada ativação usando mesmo Z",
                                    "Meça gradientes: compute norma de dZ para cada e compare (ReLU deve preservar melhor em valores altos)",
                                    "Plote gradientes vs. Z para visual comparação de vanishing"
                                  ],
                                  "verification": "Gere tabela/plots mostrando gradientes de ReLU > sigmoide/tanh para |Z|>2",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NumPy",
                                    "Matplotlib",
                                    "Código da camada anterior"
                                  ],
                                  "tips": [
                                    "Clip exp em sigmoid para evitar overflow; foque em regimes saturados"
                                  ],
                                  "learningObjective": "Demonstrar superioridade prática de ReLU via comparação empírica",
                                  "commonMistakes": [
                                    "Overflow em sigmoid sem clip",
                                    "Comparar apenas forward, ignorar gradientes",
                                    "Usar Z pequeno onde diferenças são mínimas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset simples de regressão para prever deformação em vigas de concreto (features: carga, comprimento), implemente uma rede com camada oculta ReLU: X (1x2) -> Z (1x4) via ReLU -> saída linear. Treine com gradiente descendente manual e observe convergência mais rápida que com tanh.",
                              "finalVerifications": [
                                "Código executa sem erros ou warnings em todos os testes",
                                "ReLU e derivada produzem saídas corretas em vetores de teste incluindo x=0",
                                "Gradientes em backward são zero onde Z<0 e preservados onde Z>0",
                                "Plots de comparação mostram ausência de vanishing gradients em ReLU vs. sigmoide/tanh",
                                "Dimensionalidades de forward/backward são consistentes",
                                "Resultados reprodutíveis com seed fixo"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: derivada subgradiente tratada corretamente (10%)",
                                "Eficiência do código: vetorizado, sem loops desnecessários (20%)",
                                "Testes abrangentes: unitários e comparações numéricas (20%)",
                                "Visualizações claras: plots de funções e gradientes (15%)",
                                "Legibilidade: funções modulares, comentários explicativos (15%)",
                                "Análise comparativa: evidência quantitativa de vantagens ReLU (20%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação NumPy/Python (DI-37 base computacional)",
                                "Cálculo Diferencial e Otimização em Engenharia Civil",
                                "Modelagem Estatística e Monte Carlo para simulações estruturais",
                                "Inteligência Artificial aplicada a previsão de materiais civis"
                              ],
                              "realWorldApplication": "Na Engenharia Civil, implementar ReLU em redes neurais permite modelar comportamentos não-lineares em análises estruturais, como previsão de colapso de pontes sob cargas variáveis ou otimização de misturas de concreto via deep learning, acelerando simulações que antes demandavam métodos numéricos caros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.3.4",
                            "name": "Aplicar ReLU em contexto de redes neurais",
                            "description": "Demonstrar como ReLU introduz não-linearidade em redes feedforward, ilustrando com exemplo de aproximação de funções não-lineares em engenharia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e propriedades da função ReLU",
                                  "subSteps": [
                                    "Estude a fórmula matemática da ReLU: f(x) = max(0, x).",
                                    "Analise o gráfico da ReLU, identificando a região linear para x > 0 e zero para x ≤ 0.",
                                    "Liste propriedades chave: não-linearidade, derivabilidade quase em toda parte, mitigação do vanishing gradient.",
                                    "Compare ReLU com funções lineares e sigmoide em termos de introdução de não-linearidade.",
                                    "Discuta dying ReLU como limitação e soluções iniciais."
                                  ],
                                  "verification": "Desenhe o gráfico da ReLU manualmente e explique verbalmente suas propriedades em 1 minuto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráfico da ReLU online ou software como Desmos"
                                  ],
                                  "tips": "Visualize o gráfico para internalizar a 'quebra' em x=0.",
                                  "learningObjective": "Dominar a matemática e intuição da ReLU para justificar seu uso em redes neurais.",
                                  "commonMistakes": [
                                    "Confundir ReLU com leaky ReLU",
                                    "Ignorar que ReLU é não-diferenciável em x=0",
                                    "Achar que ReLU é sempre linear"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função ReLU em código Python",
                                  "subSteps": [
                                    "Instale NumPy se necessário e crie um array de entradas variadas (positivas, negativas, zero).",
                                    "Escreva uma função def relu(x): return np.maximum(0, x).",
                                    "Teste a função com o array e plote entrada vs saída usando Matplotlib.",
                                    "Implemente a derivada da ReLU: 1 se x>0, 0 caso contrário.",
                                    "Verifique a derivada computando gradientes numéricos aproximados."
                                  ],
                                  "verification": "Execute o código e confirme que saída é zero para negativos e identidade para positivos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use np.where para derivada: np.where(x > 0, 1, 0).",
                                  "learningObjective": "Capacitar implementação prática da ReLU para uso em camadas neurais.",
                                  "commonMistakes": [
                                    "Usar max(0,x) sem import NumPy",
                                    "Esquecer plotagem para visualização",
                                    "Erro em derivada para x=0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar ReLU em uma rede neural feedforward simples",
                                  "subSteps": [
                                    "Defina uma rede de 2 camadas: input (1 neurônio) -> hidden (3 neurônios com ReLU) -> output (1 neurônio linear).",
                                    "Inicialize pesos e bias aleatoriamente com np.random.",
                                    "Implemente forward pass: z1 = W1*x + b1; a1 = relu(z1); z2 = W2*a1 + b2; y = z2.",
                                    "Teste com entrada x=1 e x=-1, observando como ReLU 'desliga' neurônios negativos.",
                                    "Compare forward pass sem ReLU (linear) vs com ReLU."
                                  ],
                                  "verification": "Imprima ativações e demonstre que ReLU introduz não-linearidade na saída.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código Python do Step 2",
                                    "NumPy"
                                  ],
                                  "tips": "Use seed para reproducibilidade: np.random.seed(42).",
                                  "learningObjective": "Construir e executar uma rede feedforward com ReLU para observar não-linearidade.",
                                  "commonMistakes": [
                                    "Erro de broadcasting em multiplicação de matrizes",
                                    "Esquecer bias",
                                    "Não comparar com versão linear"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar ReLU para aproximação de função não-linear em contexto de engenharia civil",
                                  "subSteps": [
                                    "Gere dados de uma função não-linear: y = x^2 para x em [-2,2], simulando curva tensão-deformação em materiais civis.",
                                    "Treine a rede do Step 3 com gradiente descendente simples (10 épocas, learning rate 0.1).",
                                    "Implemente backpropagation considerando derivada da ReLU.",
                                    "Plote predições vs dados reais, destacando como ReLU permite aproximação não-linear.",
                                    "Analise erro MSE antes/depois do treinamento."
                                  ],
                                  "verification": "MSE < 0.1 e gráfico mostra boa aproximação da parábola.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "NumPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Normalize dados se necessário para estabilidade.",
                                  "learningObjective": "Demonstrar utilidade da ReLU em modelagem não-linear para problemas de engenharia.",
                                  "commonMistakes": [
                                    "Learning rate muito alto causando divergência",
                                    "Gradientes zero em dying neurons",
                                    "Não plotar perda por época"
                                  ]
                                }
                              ],
                              "practicalExample": "Em engenharia civil, use uma rede com ReLU para aproximar a relação não-linear tensão-deformação em concreto (y ≈ x^2 para pequenas deformações), gerando 100 pontos de dados sintéticos, treinando a rede e prevendo comportamento sob carga para validar projeto de viga.",
                              "finalVerifications": [
                                "Implementar e executar forward/backward com ReLU corretamente.",
                                "Gráfico da rede com ReLU aproxima função não-linear melhor que linear.",
                                "Explicar verbalmente como ReLU introduz não-linearidade em feedforward.",
                                "Identificar dying ReLU em testes e propor leaky ReLU.",
                                "MSE de treinamento < 0.05 em exemplo prático.",
                                "Comparar saídas com/sem ReLU em 3 entradas diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação da ReLU e derivada (100% match com np.maximum).",
                                "Demonstração clara de não-linearidade via plots e comparações.",
                                "Qualidade da aproximação no exemplo de engenharia (MSE baixo).",
                                "Correta propagação de gradientes através da ReLU.",
                                "Análise de limitações como dying ReLU.",
                                "Clareza na documentação de código e explicações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções piecewise e derivadas subgradientes.",
                                "Programação: Implementação numérica e visualização de dados.",
                                "Estatística: Otimização via gradiente descendente e métricas de erro.",
                                "Engenharia Civil: Modelagem constitutiva de materiais não-lineares."
                              ],
                              "realWorldApplication": "Em engenharia civil, ReLU em redes neurais modela comportamentos não-lineares como colapso de estruturas sob carga dinâmica (ex: terremotos), prevendo deformações em vigas e otimizando designs resistentes via simulações preditivas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.2.1",
                              "10.1.8.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.2.4",
                        "name": "Importância da Não-Linearidade com Ativações",
                        "description": "As funções de ativação introduzem não-linearidade nas redes neurais, permitindo modelar funções complexas além de hiperplanos, essencial para soluções computacionais em problemas da engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.4.1",
                            "name": "Explicar necessidade de não-linearidade",
                            "description": "Compreender que sem ativações não-lineares, redes neurais se reduzem a regressão linear, incapaz de capturar interações complexas em dados de engenharia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da regressão linear e suas limitações",
                                  "subSteps": [
                                    "Definir regressão linear como um modelo que assume relações lineares entre variáveis independentes e dependentes.",
                                    "Explicar a equação básica y = wx + b e como ela produz hiperplanos lineares.",
                                    "Discutir limitações: incapacidade de capturar curvas, interações não-lineares ou padrões complexos em dados reais.",
                                    "Visualizar exemplos gráficos de dados não-lineares que falham com regressão linear.",
                                    "Relacionar com dados de engenharia civil, como deformação de vigas sob carga não proporcional."
                                  ],
                                  "verification": "Descrever verbalmente ou por escrito as limitações da regressão linear com um exemplo de engenharia.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notebook com Jupyter ou Google Colab",
                                    "Gráficos de regressão linear (ex: matplotlib)"
                                  ],
                                  "tips": [
                                    "Use gráficos para visualizar: plote dados reais de tensão vs. deformação que não são lineares."
                                  ],
                                  "learningObjective": "Identificar quando e por que a regressão linear falha em modelar fenômenos complexos.",
                                  "commonMistakes": [
                                    "Confundir regressão linear com regressão logística.",
                                    "Ignorar multicolinearidade em variáveis múltiplas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar que redes neurais sem ativações não-lineares equivalem a regressão linear",
                                  "subSteps": [
                                    "Explicar que cada neurônio sem ativação é uma transformação linear: soma ponderada mais bias.",
                                    "Mostrar matematicamente que composição de funções lineares (f(g(x))) resulta em função linear.",
                                    "Implementar uma rede neural de múltiplas camadas sem ativação em código e comparar com regressão linear simples.",
                                    "Verificar que os pesos da rede colapsam para uma única transformação linear equivalente.",
                                    "Testar com dados sintéticos não-lineares para mostrar falha idêntica à regressão linear."
                                  ],
                                  "verification": "Executar código que treina uma rede sem ativação e confirmar que performance é idêntica à regressão linear.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com TensorFlow/Keras ou PyTorch",
                                    "Dataset sintético não-linear (ex: senoide)"
                                  ],
                                  "tips": [
                                    "Use torch.nn.Linear() sem ativação e compare pesos finais com sklearn LinearRegression."
                                  ],
                                  "learningObjective": "Provar algebraicamente e empiricamente a equivalência de redes lineares a regressão linear.",
                                  "commonMistakes": [
                                    "Esquecer de remover bias ou normalizar dados, alterando resultados.",
                                    "Confundir profundidade com capacidade não-linear."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o papel das ativações não-lineares na captura de complexidade",
                                  "subSteps": [
                                    "Introduzir funções como ReLU, Sigmoid e Tanh e suas propriedades não-lineares.",
                                    "Explicar como ativações permitem que redes aproximem qualquer função contínua (Teorema de Aproximação Universal).",
                                    "Comparar treinamento de rede com e sem ativação em dados complexos, medindo métricas como MSE.",
                                    "Discutir como não-linearidades capturam interações: XOR problem ou padrões em engenharia.",
                                    "Analisar gradientes e como não-linearidades evitam vanishing/exploding gradients em deep nets."
                                  ],
                                  "verification": "Treinar duas redes idênticas (com/sem ativação) e plotar curvas de perda/performance divergentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmos do step 2, mais documentação de ativações (Keras docs)"
                                  ],
                                  "tips": [
                                    "Comece com ReLU para simplicidade; visualize ativações com histograms de valores pré/pós-ativação."
                                  ],
                                  "learningObjective": "Entender como ativações introduzem não-linearidade essencial para modelagem avançada.",
                                  "commonMistakes": [
                                    "Usar ativação linear por engano (identidade).",
                                    "Ignorar escala de dados afetando sigmoid/tanh."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o conceito a problemas de engenharia civil",
                                  "subSteps": [
                                    "Selecionar dataset real: previsão de deformação em estruturas sob cargas dinâmicas.",
                                    "Treinar modelo linear vs. não-linear e comparar precisão em validação.",
                                    "Explicar por que não-linearidade é crucial para capturar histerese ou plasticidade em materiais.",
                                    "Discutir implicações: segurança em pontes/paredes de contenção com modelagem inadequada.",
                                    "Generalizar para outros problemas: otimização topológica ou detecção de falhas."
                                  ],
                                  "verification": "Produzir relatório curto com gráficos comparativos e conclusão sobre necessidade de não-linearidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Dataset de engenharia civil (ex: Kaggle concrete strength)",
                                    "Bibliotecas de ML"
                                  ],
                                  "tips": [
                                    "Use cross-validation para robustez; foque em métricas como R² para relações não-lineares."
                                  ],
                                  "learningObjective": "Relacionar teoria à prática em contextos de engenharia civil.",
                                  "commonMistakes": [
                                    "Overfitting em dataset pequeno sem regularização.",
                                    "Não escalar features adequadamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de análise de vigas de concreto, use uma rede sem ativação para prever deformação sob carga: o modelo falha em capturar a fase plástica não-linear (após yield point), resultando em subestimação de 30% na deformação máxima. Com ReLU, o erro cai para <5%, permitindo simulações seguras.",
                              "finalVerifications": [
                                "Explicar em palavras próprias por que redes lineares são equivalentes a regressão linear.",
                                "Demonstrar com código simples a falha de uma rede sem ativação em dados XOR.",
                                "Comparar curvas de aprendizado de redes com/sem ativação em um dataset não-linear.",
                                "Identificar cenários de engenharia civil onde não-linearidade é essencial (ex: fadiga de materiais).",
                                "Citar o Teorema de Aproximação Universal e sua relevância.",
                                "Produzir gráfico mostrando hiperplano linear vs. fronteira não-linear."
                              ],
                              "assessmentCriteria": [
                                "Correção conceitual: definição precisa de linearidade e não-linearidade (30%)",
                                "Demonstração prática: código funcional e resultados comparativos (25%)",
                                "Profundidade de análise: ligação com teoremas e limitações matemáticas (20%)",
                                "Aplicação contextual: exemplos relevantes à engenharia civil (15%)",
                                "Clareza de comunicação: explicações claras e visualizações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e teoria de funções compostas",
                                "Física: Modelagem constitutiva não-linear de materiais",
                                "Estatística: Análise de resíduos e testes de não-linearidade",
                                "Computação: Algoritmos de otimização (gradiente descendente)",
                                "Engenharia Mecânica: Análise de tensões não-lineares em estruturas"
                              ],
                              "realWorldApplication": "Na engenharia civil, compreender a não-linearidade é vital para simular colapsos de edifícios sob terremotos, onde relações tensão-deformação são altamente não-lineares; redes sem ativações subestimariam riscos, levando a designs inseguros, enquanto modelos adequados otimizam custos e segurança em projetos como pontes suspensas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.4.2",
                            "name": "Comparar funções de ativação",
                            "description": "Avaliar sigmoide, tanh e ReLU em termos de desempenho, estabilidade numérica e adequação a problemas específicos como otimização em Monte Carlo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições e Fórmulas das Funções de Ativação",
                                  "subSteps": [
                                    "Estude a fórmula matemática da sigmoide: σ(x) = 1 / (1 + e^{-x})",
                                    "Analise a fórmula da tanh: tanh(x) = (e^x - e^{-x}) / (e^x + e^{-x})",
                                    "Examine a fórmula da ReLU: f(x) = max(0, x)",
                                    "Compare os intervalos de saída: sigmoide (0,1), tanh (-1,1), ReLU [0, ∞)",
                                    "Desenhe manualmente ou esboce os gráficos qualitativos de cada função"
                                  ],
                                  "verification": "Plotar os gráficos das três funções usando código e confirmar que correspondem às fórmulas esperadas",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Notebook Jupyter",
                                    "Referências: 'Deep Learning' de Goodfellow et al. (Capítulo 6)"
                                  ],
                                  "tips": "Use np.linspace para gerar valores de x amplos (-10 a 10) para visualizar comportamentos assintóticos",
                                  "learningObjective": "Compreender as expressões matemáticas e comportamentos qualitativos das funções sigmoide, tanh e ReLU",
                                  "commonMistakes": [
                                    "Confundir sigmoide com softmax",
                                    "Ignorar o comportamento em x negativo para ReLU",
                                    "Não normalizar os gráficos para comparação visual"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Gradientes e Problemas de Treinamento",
                                  "subSteps": [
                                    "Calcule os gradientes: σ'(x) = σ(x)(1 - σ(x)), tanh'(x) = 1 - tanh²(x), ReLU'(x) = 1 se x > 0 senão 0",
                                    "Identifique o problema de vanishing gradient na sigmoide e tanh para |x| grande",
                                    "Discuta dying ReLU: neurônios que param de atualizar devido a gradiente zero",
                                    "Compare saturação: sigmoide e tanh saturam em 0 e 1/-1, ReLU só em negativo",
                                    "Simule gradientes em valores extremos usando código"
                                  ],
                                  "verification": "Implementar função para calcular e plotar gradientes, observando regiões de saturação",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy, Matplotlib e SymPy para derivadas simbólicas",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Plote gradientes no mesmo gráfico das funções para visualização direta da relação",
                                  "learningObjective": "Avaliar o impacto dos gradientes no desempenho de treinamento das redes neurais",
                                  "commonMistakes": [
                                    "Achar que ReLU tem gradiente suave (é piecewise linear)",
                                    "Ignorar que tanh é centrada em zero, melhor que sigmoide para alguns casos",
                                    "Não testar gradientes em batches de dados reais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Estabilidade Numérica",
                                  "subSteps": [
                                    "Teste overflow/underflow na sigmoide para x muito grande/negativo (e^x explode)",
                                    "Compare com tanh, que usa e^x - e^{-x} mas ainda sofre em extremos",
                                    "Verifique ReLU: operação simples max(0,x), numericamente estável",
                                    "Implemente testes com valores extremos (x = ±1000) e observe NaNs ou Infs",
                                    "Discuta normalizações como Leaky ReLU para mitigar problemas"
                                  ],
                                  "verification": "Executar simulações numéricas e registrar valores output/gradiente sem erros de precisão",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy (np.exp, np.tanh)",
                                    "Notebook Jupyter para testes de precisão float64"
                                  ],
                                  "tips": "Use np.log1p e np.expm1 para implementações numericamente estáveis da sigmoide quando possível",
                                  "learningObjective": "Identificar vulnerabilidades numéricas de cada função em computação de precisão finita",
                                  "commonMistakes": [
                                    "Testar apenas em intervalos pequenos de x",
                                    "Confundir estabilidade com velocidade computacional",
                                    "Não checar gradientes em conjunto com a função"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Adequação a Problemas Específicos como Otimização em Monte Carlo",
                                  "subSteps": [
                                    "Avalie sigmoide para probabilidades em Monte Carlo (saída [0,1])",
                                    "Discuta tanh para simulações centradas (ex: desvios em análises estruturais)",
                                    "Prefira ReLU para deep networks em otimização estocástica devido a gradientes não-vanishing",
                                    "Simule uma rede simples para aproximação de integrais Monte Carlo com cada ativação",
                                    "Compare curvas de perda e convergência em experimentos"
                                  ],
                                  "verification": "Treinar mini-redes para um problema Monte Carlo e comparar métricas de perda final",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy, Scikit-learn ou PyTorch simples",
                                    "Notebook Jupyter",
                                    "Dataset sintético para Monte Carlo (ex: integral de f(x) aleatória)"
                                  ],
                                  "tips": "Use seed para reprodutibilidade e múltiplas runs para estatísticas de convergência",
                                  "learningObjective": "Selecionar funções de ativação baseadas em adequação a cenários como otimização Monte Carlo",
                                  "commonMistakes": [
                                    "Generalizar sem testes empíricos",
                                    "Ignorar custo computacional (ReLU mais rápida)",
                                    "Não considerar depth da rede"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Comparação e Recomendações",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para desempenho, estabilidade, adequação Monte Carlo",
                                    "Resuma prós/contras: ReLU (rápida, dying), Sigmoide (probabilística, vanishing), Tanh (centrada, vanishing)",
                                    "Discuta variantes: Leaky ReLU, Swish para melhorias",
                                    "Aplique a uma caso de engenharia civil (ex: previsão de cargas via NN + Monte Carlo)",
                                    "Documente conclusões em relatório curto"
                                  ],
                                  "verification": "Produzir tabela e relatório explicando escolhas para um problema específico",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Markdown ou LaTeX para tabela",
                                    "Referências de papers sobre ativações em DL"
                                  ],
                                  "tips": "Use pandas para gerar tabela automaticamente de experimentos",
                                  "learningObjective": "Formular recomendações contextualizadas para uso em problemas reais",
                                  "commonMistakes": [
                                    "Ser muito absoluto (depende do problema)",
                                    "Omitir trade-offs computacionais",
                                    "Não ligar a contexto de engenharia civil"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma rede neural simples para estimar a integral de uma função via Monte Carlo (ex: ∫ sin(x) dx de 0 a π). Treine três versões com sigmoide, tanh e ReLU como ativações ocultas, compare curvas de perda, tempo de convergência e precisão final. Observe que ReLU converge mais rápido sem vanishing gradients em redes profundas simulando otimizações estocásticas em análise de riscos estruturais.",
                              "finalVerifications": [
                                "Pode plotar e interpretar gráficos de funções e gradientes corretamente",
                                "Explica com exemplos o vanishing gradient em sigmoide/tanh vs. ReLU",
                                "Demonstra estabilidade numérica testando valores extremos sem NaNs",
                                "Compara desempenho em simulação Monte Carlo com métricas quantitativas",
                                "Recomenda ativação adequada para um problema dado com justificativa",
                                "Identifica quando usar variantes como Leaky ReLU"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e plotagem de fórmulas/gradientes (30%)",
                                "Análise correta de estabilidade e problemas de gradiente (25%)",
                                "Resultados empíricos válidos de experimentos comparativos (20%)",
                                "Recomendações contextualizadas e tabelas claras (15%)",
                                "Conexão explícita com aplicações em Monte Carlo (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: Saídas probabilísticas da sigmoide em Monte Carlo",
                                "Otimização Numérica: Impacto de gradientes na convergência de SGD",
                                "Engenharia Civil Computacional: Simulações de risco estrutural com NNs",
                                "Matemática Numérica: Estabilidade em computação científica",
                                "Programação Científica: Implementação eficiente em Python/NumPy"
                              ],
                              "realWorldApplication": "Em engenharia civil, ao modelar incertezas em cargas sísmicas via método Monte Carlo com redes neurais para previsão de falhas em estruturas, ReLU é preferida por sua estabilidade e velocidade em redes profundas, evitando vanishing gradients durante otimizações estocásticas longas, enquanto sigmoide pode ser usada para saídas de probabilidade de colapso."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.2.1",
                              "10.1.8.2.2",
                              "10.1.8.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.3",
                    "name": "Geração de Números Pseudo-Aleatórios",
                    "description": "Conceitos de aleatoriedade e propriedades desejáveis de sequências pseudo-aleatórias.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.3.1",
                        "name": "Conceito de Aleatoriedade",
                        "description": "Definição de aleatoriedade em contextos computacionais, distinguindo números aleatórios verdadeiros de pseudo-aleatórios, e sua importância em simulações numéricas como o Método de Monte Carlo.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.1.1",
                            "name": "Definir número aleatório ideal",
                            "description": "Explicar as propriedades estatísticas de um número aleatório uniforme no intervalo [0,1], incluindo independência e distribuição uniforme contínua.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Aleatoriedade",
                                  "subSteps": [
                                    "Defina aleatoriedade como a ausência de padrão previsível em uma sequência de números.",
                                    "Diferencie aleatoriedade verdadeira de pseudo-aleatoriedade.",
                                    "Explique por que números aleatórios são fundamentais em simulações computacionais.",
                                    "Discuta a importância do intervalo [0,1] como padrão universal.",
                                    "Identifique exemplos cotidianos de processos aleatórios, como lançamento de dados."
                                  ],
                                  "verification": "Escreva uma definição clara de aleatoriedade e justifique o uso do intervalo [0,1] em uma frase.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de probabilidade",
                                    "Vídeo introdutório sobre aleatoriedade (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use analogias como roleta para visualizar uniformidade.",
                                  "learningObjective": "Entender os fundamentos conceituais de aleatoriedade e seu papel em modelagens estocásticas.",
                                  "commonMistakes": [
                                    "Confundir aleatoriedade com imprevisibilidade simples",
                                    "Ignorar a escala normalizada [0,1]"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Distribuição Uniforme Contínua",
                                  "subSteps": [
                                    "Descreva a função densidade de probabilidade (PDF) f(x) = 1 para x em [0,1].",
                                    "Calcule a função de distribuição cumulativa (CDF) F(x) = x para x em [0,1].",
                                    "Verifique que a média é 0.5 e a variância é 1/12.",
                                    "Gere histogramas de amostras uniformes para visualizar a uniformidade.",
                                    "Compare com distribuições não-uniformes para destacar diferenças."
                                  ],
                                  "verification": "Plote um histograma de 1000 amostras uniformes e confirme que se aproxima de uma reta horizontal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Calculadora ou software de estatística"
                                  ],
                                  "tips": "Sempre normalize para [0,1] para facilitar transformações.",
                                  "learningObjective": "Dominar as propriedades matemáticas da distribuição uniforme contínua em [0,1].",
                                  "commonMistakes": [
                                    "Esquecer que é contínua, não discreta",
                                    "Calcular média incorretamente como 1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Independência entre Números Aleatórios",
                                  "subSteps": [
                                    "Defina independência estatística: Cov(X_i, X_j) = 0 para i ≠ j.",
                                    "Teste independência usando testes como correlação de Pearson ou runs test.",
                                    "Explique que independência implica ausência de autocorrelação.",
                                    "Simule sequências dependentes vs. independentes e compare estatísticas.",
                                    "Discuta implicações para métodos como Monte Carlo."
                                  ],
                                  "verification": "Calcule a matriz de correlação de 100 pares de números uniformes e confirme valores próximos a zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com SciPy para testes estatísticos",
                                    "Planilha Excel para cálculos manuais"
                                  ],
                                  "tips": "Verifique autocorrelação em lags 1-5 para detectar padrões.",
                                  "learningObjective": "Compreender e verificar a independência essencial em sequências aleatórias.",
                                  "commonMistakes": [
                                    "Confundir independência com não-linearidade",
                                    "Usar amostras pequenas para testes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar o Número Aleatório Ideal",
                                  "subSteps": [
                                    "Liste todas as propriedades: uniformidade, independência, infinito não-repetição.",
                                    "Compare com geradores pseudo-aleatórios reais (ex: Mersenne Twister).",
                                    "Discuta limitações computacionais e hardware RNG.",
                                    "Crie um checklist para avaliar um gerador.",
                                    "Aplique em um mini-exemplo de Monte Carlo."
                                  ],
                                  "verification": "Redija um parágrafo definindo o número aleatório ideal com todas as propriedades.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de geradores RNG em Python",
                                    "Artigo sobre propriedades ideais"
                                  ],
                                  "tips": "Lembre-se: ideal é teórico; prático é aproximado.",
                                  "learningObjective": "Integrar propriedades para definir um número aleatório perfeito.",
                                  "commonMistakes": [
                                    "Superestimar perfeição de algoritmos",
                                    "Omitir independência infinita"
                                  ]
                                }
                              ],
                              "practicalExample": "Em simulações Monte Carlo para análise de estruturas civis, gere 10.000 números uniformes [0,1] para modelar variações aleatórias de vento; transforme-os em velocidades via inversa CDF e compute distribuições de cargas máximas.",
                              "finalVerifications": [
                                "Explicar verbalmente a PDF e CDF da uniforme [0,1].",
                                "Gerar e plotar 5000 amostras, confirmando média ≈0.5 e variância ≈0.083.",
                                "Demonstrar independência com teste de correlação <0.01.",
                                "Definir número aleatório ideal em 3 frases.",
                                "Identificar falhas em uma sequência pseudo-aleatória dada.",
                                "Aplicar em mini-simulação Monte Carlo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição matemática (PDF, CDF, momentos).",
                                "Correta interpretação de uniformidade via visualizações.",
                                "Evidência de testes de independência válidos.",
                                "Integração completa de propriedades em definição.",
                                "Capacidade de aplicar em contexto prático.",
                                "Clareza e ausência de erros conceituais."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuições e testes de hipótese.",
                                "Programação: Implementação de RNG em Python/R.",
                                "Física: Modelagem estocástica de fenômenos naturais.",
                                "Engenharia Civil: Simulações Monte Carlo para riscos estruturais.",
                                "Matemática: Teoria da probabilidade contínua."
                              ],
                              "realWorldApplication": "Na engenharia civil, números aleatórios ideais são usados em métodos Monte Carlo para estimar probabilidades de falha em pontes sob cargas variáveis, otimizando designs seguros e econômicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.1.2",
                            "name": "Diferenciar aleatoriedade verdadeira e pseudo-aleatoriedade",
                            "description": "Comparar fontes físicas de aleatoriedade verdadeira (ex.: ruído térmico) com algoritmos determinísticos de pseudo-aleatoriedade, destacando limitações computacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Aleatoriedade Verdadeira",
                                  "subSteps": [
                                    "Defina aleatoriedade verdadeira como eventos imprevisíveis baseados em processos físicos quânticos ou caóticos.",
                                    "Identifique fontes comuns: ruído térmico em semicondutores, decaimento radioativo e ruído atmosférico.",
                                    "Explique propriedades chave: imprevisibilidade absoluta, alta entropia e independência de sementes iniciais.",
                                    "Pesquise exemplos reais de hardware RNG (Random Number Generators) como Intel RdRand.",
                                    "Discuta por que ela é considerada 'verdadeira' em termos probabilísticos."
                                  ],
                                  "verification": "Resuma em um parágrafo as fontes e propriedades, confirmando com uma fonte confiável como Wikipedia ou paper acadêmico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Artigos sobre 'True Random Number Generators'",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Use analogias como lançar uma moeda real vs. simular; foque em imprevisibilidade física."
                                  ],
                                  "learningObjective": "Diferenciar aleatoriedade verdadeira de processos determinísticos através de fontes físicas.",
                                  "commonMistakes": [
                                    "Confundir com aleatoriedade aparente em sistemas caóticos clássicos.",
                                    "Ignorar limitações práticas de hardware RNG.",
                                    "Achar que computadores podem gerar verdadeira aleatoriedade sem hardware especial."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Pseudo-Aleatoriedade e Algoritmos Determinísticos",
                                  "subSteps": [
                                    "Defina pseudo-aleatoriedade como sequências geradas por algoritmos determinísticos a partir de uma semente inicial.",
                                    "Estude geradores comuns: Linear Congruential Generator (LCG) e Mersenne Twister.",
                                    "Implemente um LCG simples em Python: X_{n+1} = (a * X_n + c) mod m.",
                                    "Analise características: periodicidade finita, reprodutibilidade e testes estatísticos (como DIEHARD).",
                                    "Gere uma sequência e observe padrões repetindo com a mesma semente."
                                  ],
                                  "verification": "Execute código Python para gerar 1000 números e plote o histograma; verifique se parece uniforme mas repetível.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python instalado (com numpy/matplotlib)",
                                    "Editor de código como VS Code",
                                    "Documentação de random module"
                                  ],
                                  "tips": [
                                    "Sempre fixe a semente com random.seed() para demonstrar determinismo; compare sequências idênticas."
                                  ],
                                  "learningObjective": "Implementar e analisar um PRNG básico, entendendo seu caráter determinístico.",
                                  "commonMistakes": [
                                    "Achar que PRNG são imprevisíveis se a semente for desconhecida.",
                                    "Usar períodos curtos sem testar periodicidade.",
                                    "Confundir uniformidade estatística com verdadeira imprevisibilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Aleatoriedade Verdadeira e Pseudo-Aleatoriedade",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: fontes, previsibilidade, entropia, custo computacional e uso em simulações.",
                                    "Discuta testes: Kolmogorov-Smirnov para uniformidade e correlação serial.",
                                    "Simule falhas: preveja próximo número em PRNG com semente conhecida vs. impossível em verdadeiro RNG.",
                                    "Analise limitações: PRNG falham em criptografia se seed exposta; verdadeiro RNG é lento e caro.",
                                    "Debata cenários: quando usar cada um em aplicações computacionais."
                                  ],
                                  "verification": "Preencha e discuta a tabela comparativa com um colega ou em autoavaliação, destacando 3 diferenças chave.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets",
                                    "Resultados dos códigos dos steps anteriores",
                                    "Paper 'Randomness in Computing'"
                                  ],
                                  "tips": [
                                    "Use métricas quantitativas como período do PRNG; foque em vulnerabilidades de segurança."
                                  ],
                                  "learningObjective": "Identificar diferenças qualitativas e quantitativas entre os dois tipos de aleatoriedade.",
                                  "commonMistakes": [
                                    "Superestimar qualidade de PRNG simples como random().",
                                    "Ignorar que ambos passam em testes estatísticos superficiais.",
                                    "Confundir pseudo-aleatoriedade com ruído numérico em floating-point."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Limitações Computacionais e Implicações Práticas",
                                  "subSteps": [
                                    "Explore limitações: computadores são determinísticos; verdadeiro RNG requer hardware híbrido.",
                                    "Discuta hibridização: seed PRNG com verdadeiro RNG (ex: /dev/random no Linux).",
                                    "Aplique ao contexto: em Monte Carlo para engenharia civil, PRNG é suficiente por reprodutibilidade.",
                                    "Avalie trade-offs: velocidade vs. qualidade em simulações de risco sísmico.",
                                    "Pesquise casos reais de falhas (ex: ataque a PRNG em cassinos online)."
                                  ],
                                  "verification": "Escreva um relatório curto (200 palavras) sobre quando usar cada tipo em engenharia computacional.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Acesso a fóruns como Stack Overflow sobre /dev/urandom",
                                    "Vídeos sobre LavaRand (Google's RNG)"
                                  ],
                                  "tips": [
                                    "Considere escalabilidade: PRNG para bilhões de amostras em Monte Carlo.",
                                    "Ligue a criptografia onde verdadeiro é essencial."
                                  ],
                                  "learningObjective": "Avaliar trade-offs computacionais e escolher o tipo adequado por aplicação.",
                                  "commonMistakes": [
                                    "Achar PRNG inadequado para todas simulações.",
                                    "Subestimar overhead de hardware RNG em dispositivos embarcados.",
                                    "Ignorar reprodutibilidade como vantagem em debug de simulações."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para prever falhas em uma ponte sob cargas sísmicas variáveis, use Python's random (PRNG) para gerar 10.000 cargas pseudo-aleatórias com semente fixa para reprodutibilidade. Compare com dados de um API de RNG verdadeiro (como random.org) e note como o PRNG permite resultados idênticos em runs múltiplos, essencial para validação em engenharia civil.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 fontes de aleatoriedade verdadeira e 2 PRNG comuns.",
                                "Demonstrar código que gera sequência repetível com PRNG.",
                                "Identificar em uma tabela por que PRNG falha em criptografia mas succeeds em Monte Carlo.",
                                "Discutir limitações computacionais de hardware RNG.",
                                "Aplicar conceito a um cenário de engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e fontes (80% acerto).",
                                "Capacidade de implementar e analisar PRNG (código funcional).",
                                "Profundidade na comparação (cobertura de previsibilidade, entropia e testes).",
                                "Análise crítica de limitações e trade-offs.",
                                "Relevância de exemplos ao contexto de engenharia civil.",
                                "Clareza em verificações finais e aplicações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Entropia térmica e mecânica quântica em fontes RNG.",
                                "Matemática: Teoria da probabilidade e testes estatísticos de uniformidade.",
                                "Ciência da Computação: Algoritmos determinísticos e complexidade.",
                                "Engenharia Civil: Simulações Monte Carlo para análise de riscos estruturais.",
                                "Segurança da Informação: RNG em criptografia para IoT em monitoramento de estruturas."
                              ],
                              "realWorldApplication": "Na engenharia civil, métodos Monte Carlo com PRNG simulam milhares de cenários de vento ou terremotos em projetos de pontes, permitindo otimização eficiente; para sistemas de monitoramento IoT em tempo real, RNG verdadeira garante chaves criptográficas seguras contra previsibilidade, evitando falhas como no caso de cassinos hackeados por padrões em PRNG fracos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.1.3",
                            "name": "Identificar aplicações em engenharia civil",
                            "description": "Relacionar a aleatoriedade com simulações de cargas aleatórias em estruturas ou propagação de incertezas em problemas de valor inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Aleatoriedade e Geração Pseudo-Aleatória",
                                  "subSteps": [
                                    "Defina aleatoriedade e números pseudo-aleatórios, destacando sua importância em simulações.",
                                    "Explique o papel do Método de Monte Carlo na modelagem de fenômenos incertos.",
                                    "Discuta limitações de determinismo em problemas reais de engenharia civil.",
                                    "Identifique fontes de aleatoriedade em engenharia, como variações climáticas ou materiais.",
                                    "Pratique gerando uma sequência pseudo-aleatória simples em software."
                                  ],
                                  "verification": "Capacidade de explicar verbalmente ou por escrito os conceitos com exemplos corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook com Python (biblioteca NumPy), vídeo tutorial sobre Monte Carlo (ex: Khan Academy).",
                                  "tips": "Use analogias cotidianas, como lançar dados, para visualizar aleatoriedade.",
                                  "learningObjective": "Compreender os fundamentos teóricos da aleatoriedade aplicados a simulações.",
                                  "commonMistakes": "Confundir pseudo-aleatoriedade com verdadeira aleatoriedade; ignorar sementes em geradores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Problemas em Engenharia Civil com Incertezas Inerentes",
                                  "subSteps": [
                                    "Liste problemas comuns: cargas de vento/terremoto em pontes, variação de resistência do solo.",
                                    "Classifique incertezas: aleatórias (cargas variáveis) vs. epistêmicas (falta de dados).",
                                    "Analise um caso: falha de estruturas devido a cargas imprevisíveis.",
                                    "Pesquise normas como ABNT NBR para tratamento de incertezas.",
                                    "Crie um mapa mental conectando incertezas a eventos reais."
                                  ],
                                  "verification": "Mapa mental completo com pelo menos 5 problemas identificados e classificados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Artigos da ASCE ou ABNT NBR 6120, papel/caneta para mapa mental.",
                                  "tips": "Comece com casos famosos como colapso da Ponte Tacoma Narrows para inspiração.",
                                  "learningObjective": "Reconhecer fontes de aleatoriedade em contextos de engenharia civil.",
                                  "commonMistakes": "Focar apenas em falhas catastróficas, ignorando incertezas cotidianas em projetos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar Aleatoriedade com Simulações de Cargas Aleatórias em Estruturas",
                                  "subSteps": [
                                    "Modele cargas aleatórias (ex: vento gaussiano) usando geradores pseudo-aleatórios.",
                                    "Simule resposta estrutural com Monte Carlo em software simples.",
                                    "Calcule estatísticas: média, desvio padrão de tensões máximas.",
                                    "Compare resultados com abordagens determinísticas.",
                                    "Interprete: como aleatoriedade afeta fatores de segurança."
                                  ],
                                  "verification": "Execução bem-sucedida de simulação com gráfico de distribuições gerado.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python/MATLAB com bibliotecas (NumPy, SciPy), modelo finito de viga simples.",
                                  "tips": "Use sementes fixas para reproduzir resultados e depurar.",
                                  "learningObjective": "Aplicar geração aleatória para simular cargas em estruturas.",
                                  "commonMistakes": "Usar distribuições erradas (ex: uniforme para cargas de vento que são normais)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Propagação de Incertezas em Problemas de Valor Inicial",
                                  "subSteps": [
                                    "Defina problemas de valor inicial em dinâmica estrutural (ex: equações diferenciais).",
                                    "Incorpore incertezas em condições iniciais via Monte Carlo.",
                                    "Simule propagação: como erros em velocidade inicial afetam trajetórias.",
                                    "Avalie sensibilidade: identifique parâmetros mais impactantes.",
                                    "Documente aplicações: previsão de vibrações em edifícios."
                                  ],
                                  "verification": "Relatório curto com gráficos de propagação de incertezas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software como MATLAB Simulink ou Python (odeint), equação de exemplo (amortecedor massa-mola).",
                                  "tips": "Visualize com histogramas para entender dispersão de resultados.",
                                  "learningObjective": "Modelar e analisar propagação de incertezas em sistemas dinâmicos.",
                                  "commonMistakes": "Negligenciar correlações entre variáveis incertas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Aplicações e Verificar Compreensão",
                                  "subSteps": [
                                    "Liste 5 aplicações específicas em engenharia civil usando aleatoriedade.",
                                    "Crie um fluxograma de workflow: problema → simulação → decisão.",
                                    "Debata limitações: custo computacional vs. precisão.",
                                    "Proponha melhorias: integração com redes neurais para previsão.",
                                    "Autoavalie conhecimento com quiz interno."
                                  ],
                                  "verification": "Fluxograma e lista de aplicações compartilhados e revisados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de diagrama (Draw.io), quiz online sobre Monte Carlo.",
                                  "tips": "Conecte com projetos reais para maior retenção.",
                                  "learningObjective": "Integrar conceitos em aplicações práticas identificáveis.",
                                  "commonMistakes": "Generalizar demais sem exemplos concretos de engenharia."
                                }
                              ],
                              "practicalExample": "Simular cargas de vento aleatórias em uma viga de ponte usando Python: gerar 1000 amostras gaussianas para velocidade do vento (média 20 m/s, desvio 5 m/s), calcular momentos fletores máximos e determinar percentil 95% para dimensionamento seguro.",
                              "finalVerifications": [
                                "Pode listar e explicar 3 aplicações de aleatoriedade em engenharia civil.",
                                "Executa simulação Monte Carlo básica sem erros.",
                                "Identifica diferenças entre simulação aleatória e determinística.",
                                "Descreve propagação de incertezas em um problema de valor inicial.",
                                "Cria mapa de conexões entre aleatoriedade e normas de projeto.",
                                "Avalia confiabilidade de uma estrutura sob cargas aleatórias."
                              ],
                              "assessmentCriteria": [
                                "Compreensão conceitual: distinção clara entre aleatoriedade e determinismo (0-4 pontos).",
                                "Aplicação prática: qualidade da simulação executada (0-4 pontos).",
                                "Análise crítica: identificação precisa de incertezas reais (0-4 pontos).",
                                "Síntese: número e relevância de aplicações listadas (0-4 pontos).",
                                "Comunicação: clareza no relatório ou apresentação (0-4 pontos).",
                                "Criatividade: propostas de integração interdisciplinar (0-4 pontos)."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: distribuições para modelar incertezas.",
                                "Programação Computacional: implementação em Python/MATLAB.",
                                "Física Aplicada: dinâmica de estruturas e equações diferenciais.",
                                "Gestão de Riscos: análise probabilística em projetos.",
                                "Inteligência Artificial: uso de Monte Carlo em treinamento de redes neurais."
                              ],
                              "realWorldApplication": "Engenheiros civis usam simulações Monte Carlo para projetar edifícios e pontes resistentes a cargas sísmicas ou de vento variáveis, garantindo fatores de segurança baseados em percentis de risco (ex: Eurocode ou ASCE 7), otimizando custos e prevenindo falhas como no caso do World Trade Center."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.3.2",
                        "name": "Números Pseudo-Aleatórios",
                        "description": "Princípios de geração de sequências pseudo-aleatórias usando algoritmos determinísticos, como o método da congruência linear multiplicativa.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.2.1",
                            "name": "Explicar o método da congruência linear",
                            "description": "Descrever a fórmula X_{n+1} = (a * X_n + c) mod m, identificando parâmetros (semente, multiplicador, incremento, módulo) e condições para bom período.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a fórmula básica do método da congruência linear",
                                  "subSteps": [
                                    "Leia e memorize a fórmula: X_{n+1} = (a * X_n + c) mod m",
                                    "Identifique que é um gerador linear congruencial (LCG) para números pseudo-aleatórios",
                                    "Compreenda que 'mod m' garante que os valores fiquem entre 0 e m-1",
                                    "Discuta por que é chamado de 'pseudo-aleatório': determinístico, mas aparenta aleatoriedade",
                                    "Compare brevemente com números verdadeiramente aleatórios"
                                  ],
                                  "verification": "Escreva a fórmula de memória e explique cada operação em voz alta",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora básica",
                                    "Referência: Wikipedia LCG ou livro de métodos numéricos"
                                  ],
                                  "tips": [
                                    "Visualize a fórmula como uma iteração recursiva",
                                    "Desenhe um diagrama de fluxo para X0 -> X1 -> X2"
                                  ],
                                  "learningObjective": "Compreender a estrutura matemática fundamental do LCG",
                                  "commonMistakes": [
                                    "Confundir 'mod' com divisão simples",
                                    "Ignorar que resultados são inteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e explicar os parâmetros da fórmula",
                                  "subSteps": [
                                    "Defina X_0 como a semente (seed): valor inicial inteiro entre 0 e m-1",
                                    "Explique 'a' como multiplicador: constante que 'estica' a sequência (tipicamente ímpar)",
                                    "Descreva 'c' como incremento: constante adicionada para evitar padrões (pode ser 0 em variantes)",
                                    "Detalhe 'm' como módulo: define o range [0, m-1] e tamanho máximo do período",
                                    "Discuta escolha de parâmetros: m=2^k comum por eficiência computacional"
                                  ],
                                  "verification": "Liste os 4 parâmetros com definições e exemplos numéricos em uma tabela",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Exemplos de parâmetros padrão (ex: a=1664525, c=1013904223, m=2^32)"
                                  ],
                                  "tips": [
                                    "Use mnemônicos: Semente (Start), Multiplicador (Multiply), Incremento (Increment), Módulo (Mod)"
                                  ],
                                  "learningObjective": "Dominar o papel e seleção de cada parâmetro no LCG",
                                  "commonMistakes": [
                                    "Confundir semente com módulo",
                                    "Escolher parâmetros ruins levando a período curto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar condições para um bom período (máximo possível)",
                                  "subSteps": [
                                    "Explique que o período máximo é m (full period)",
                                    "Liste teorema de Hull-Dobell: c coprimo com m; a-1 divisível por todos primos de m; se 4 divide m, então 4 divide a-1",
                                    "Discuta casos especiais: se c=0, período divide m; m primo simplifica",
                                    "Verifique com exemplo: parâmetros ruins (a=1) dão período 1",
                                    "Mencione testes empíricos além do teorema para qualidade pseudo-aleatória"
                                  ],
                                  "verification": "Escreva as 3 condições principais de Hull-Dobell e valide com parâmetros exemplo",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Teorema de Hull-Dobell impresso ou anotado",
                                    "Calculadora para coprimos (MDC)"
                                  ],
                                  "tips": [
                                    "Verifique coprimo com MDC(a,b)=1",
                                    "Teste parâmetros conhecidos como bons (ex: Numerical Recipes)"
                                  ],
                                  "learningObjective": "Aplicar critérios matemáticos para garantir longos períodos no LCG",
                                  "commonMistakes": [
                                    "Ignorar coprimos de c e m",
                                    "Confundir período com range"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar geração de sequência e análise prática",
                                  "subSteps": [
                                    "Escolha parâmetros: X0=1, a=5, c=3, m=16",
                                    "Calcule manualmente X1 a X5: X1=(5*1+3) mod16=8, etc.",
                                    "Observe a sequência: 1,8,11,6,13,4,7,14,9,0,...",
                                    "Verifique período: repete após 16? Sim, full period",
                                    "Normalize para [0,1]: Ui = Xi / m e plote para visual aleatoriedade"
                                  ],
                                  "verification": "Gere 10 termos corretos e identifique se período é full",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Gráfica simples ou Excel para plot",
                                    "Script Python opcional para verificação"
                                  ],
                                  "tips": [
                                    "Calcule passo a passo para evitar erros aritméticos",
                                    "Plote pontos para 'sentir' aleatoriedade"
                                  ],
                                  "learningObjective": "Executar e validar o LCG na prática",
                                  "commonMistakes": [
                                    "Erros em multiplicação modular (calcule antes do mod)",
                                    "Não normalizar para uso probabilístico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em simulação Monte Carlo para análise de carga em vigas de concreto: Use LCG com m=2^32, a=1664525, c=1013904223, X0=12345 para gerar 10.000 'cargas aleatórias' uniformes [0,1], multiplique por carga máxima para simular falhas estruturais e estimar probabilidade de colapso.",
                              "finalVerifications": [
                                "Recitar fórmula e parâmetros corretamente",
                                "Listar condições Hull-Dobell sem erros",
                                "Gerar sequência manual de 5 termos com parâmetros dados",
                                "Explicar por que parâmetros ruins falham",
                                "Normalizar Xi para Ui e descrever uso",
                                "Identificar full period em exemplo simples"
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula e parâmetros (100% correto)",
                                "Profundidade nas condições de período (cobre teorema completo)",
                                "Correção em cálculos manuais (sem erros aritméticos)",
                                "Clareza na explicação verbal/escrita",
                                "Conexão com aplicações práticas",
                                "Identificação de erros comuns e soluções"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra modular e teoria dos números",
                                "Programação: Implementação em Python/C++ (função iterativa)",
                                "Estatística: Testes de uniformidade e independência (Chi-quadrado)",
                                "Engenharia Computacional: Otimização de RNG em simulações",
                                "Probabilidade: Distribuição uniforme gerada"
                              ],
                              "realWorldApplication": "Na Engenharia Civil, o LCG é usado em métodos de Monte Carlo para simular cargas variáveis em pontes ou edifícios, avaliando riscos de falha sob incertezas (ex: vento aleatório, tráfego), permitindo decisões seguras em projetos sem hardware RNG caro."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.8.3.2.2",
                            "name": "Implementar gerador simples",
                            "description": "Esboçar pseudocódigo ou código MATLAB para gerar uma sequência pseudo-aleatória básica, testando com sementes iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Gerador Linear Congruencial (LCG)",
                                  "subSteps": [
                                    "Estude a fórmula básica do LCG: X_{n+1} = (a * X_n + c) mod m, onde X_0 é a semente.",
                                    "Identifique os parâmetros chave: m (módulo), a (multiplicador), c (incremento) e X_0 (semente inicial).",
                                    "Pesquise parâmetros recomendados para boas propriedades estatísticas (ex: m=2^31, a=1103515245, c=12345).",
                                    "Explique em suas palavras como o LCG produz pseudo-aleatoriedade.",
                                    "Calcule manualmente 3-5 iterações com uma semente simples para praticar."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando o LCG e calcule manualmente uma sequência curta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação MATLAB sobre rand(), artigos online sobre LCG (Wikipedia, livros de simulação), papel e caneta.",
                                  "tips": "Use parâmetros testados para evitar sequências curtas ou correlacionadas.",
                                  "learningObjective": "Dominar a teoria e fórmula do LCG para implementação correta.",
                                  "commonMistakes": "Confundir 'mod m' com divisão simples; escolher parâmetros ruins que geram períodos curtos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Esboçar o Pseudocódigo do Gerador",
                                  "subSteps": [
                                    "Defina variáveis: semente X0, parâmetros a, c, m e número de iterações N.",
                                    "Escreva o loop principal: enquanto i < N, calcule próximo X e normalize para [0,1] (X/m).",
                                    "Inclua entrada de semente e saída da sequência em array.",
                                    "Adicione comentários explicando cada linha.",
                                    "Teste logicamente o pseudocódigo com exemplo manual."
                                  ],
                                  "verification": "Pseudocódigo deve produzir sequência idêntica ao cálculo manual do Step 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto simples (Notepad++ ou papel), exemplos de pseudocódigo de RNG.",
                                  "tips": "Mantenha o pseudocódigo simples e legível, evitando otimizações prematuras.",
                                  "learningObjective": "Traduzir teoria em algoritmo estruturado e lógico.",
                                  "commonMistakes": "Esquecer o 'mod m' no loop; não normalizar para [0,1]."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Gerador em MATLAB",
                                  "subSteps": [
                                    "Abra MATLAB e crie script novo com parâmetros definidos como constantes.",
                                    "Implemente o loop for ou while baseado no pseudocódigo, armazenando em vetor.",
                                    "Adicione função para gerar sequência com semente input.",
                                    "Inclua plot de histograma para visualizar distribuição.",
                                    "Salve o script e rode testes iniciais."
                                  ],
                                  "verification": "Execute o código e confirme que gera sequência sem erros e matches cálculo manual.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB instalado, documentação 'rand' e 'hist' do MATLAB.",
                                  "tips": "Use uint32 para evitar overflow em m grande; teste com rng(seed) nativo para comparar.",
                                  "learningObjective": "Converter pseudocódigo em código MATLAB funcional e visual.",
                                  "commonMistakes": "Overflow numérico sem usar mod correto; esquecer de limpar workspace."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar com Diferentes Sementes e Validar",
                                  "subSteps": [
                                    "Gere sequências com 3 sementes diferentes (ex: 1, 42, 123) e compare.",
                                    "Plote histogramas e verifique uniformidade aproximada.",
                                    "Teste reprodutibilidade: mesma semente deve dar mesma sequência.",
                                    "Analise período detectando repetições.",
                                    "Compare com MATLAB rand() para similaridade estatística."
                                  ],
                                  "verification": "Relatório curto com plots e tabelas mostrando reprodutibilidade e uniformidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB com toolboxs básicos, funções hist, plot.",
                                  "tips": "Use N=1000 para testes; verifique autocorrelação básica.",
                                  "learningObjective": "Validar propriedades pseudo-aleatórias do gerador implementado.",
                                  "commonMistakes": "Ignorar overflow levando a NaNs; confundir aleatoriedade com uniformidade perfeita."
                                }
                              ],
                              "practicalExample": "Implemente um LCG em MATLAB com m=2^32, a=1664525, c=1013904223, X0=12345, gere 1000 números em [0,1], plote histograma e compare com rand(1000,1) usando mesma semente via rng(12345).",
                              "finalVerifications": [
                                "Código roda sem erros para N=10000.",
                                "Mesma semente reproduz sequência exata.",
                                "Diferentes sementes produzem sequências distintas.",
                                "Histograma mostra distribuição uniforme aproximada.",
                                "Período é pelo menos 1000 sem repetições precoces.",
                                "Normalização produz valores em [0,1]."
                              ],
                              "assessmentCriteria": [
                                "Pseudocódigo claro, completo e correto (20%).",
                                "Implementação MATLAB funcional e eficiente (30%).",
                                "Testes abrangentes com múltiplas sementes (20%).",
                                "Análise visual (histogramas) e estatística (10%).",
                                "Documentação com comentários e relatório (10%).",
                                "Propriedades pseudo-aleatórias demonstradas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Testes de uniformidade e independência.",
                                "Programação Computacional: Loops, vetores e visualização em MATLAB.",
                                "Engenharia Civil: Simulações Monte Carlo para análise estrutural.",
                                "Matemática Discreta: Aritmética modular e teoria dos números."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para análise de risco em estruturas civis, como modelar cargas aleatórias em pontes ou variabilidade em materiais para previsão de falhas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.8.3.2.3",
                            "name": "Avaliar determinismo da sequência",
                            "description": "Demonstrar que sequências pseudo-aleatórias são reproduzíveis dada a mesma semente, contrastando com aleatoriedade verdadeira.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e inicializar o gerador pseudo-aleatório com semente fixa",
                                  "subSteps": [
                                    "Instalar ou verificar Python (versão 3.x) e biblioteca random.",
                                    "Abrir um editor de código ou Jupyter Notebook.",
                                    "Importar o módulo random com 'import random'.",
                                    "Definir uma semente fixa, como random.seed(42), e executar o código."
                                  ],
                                  "verification": "Código executado sem erros, confirmando importação e semente aplicada via print(random.getstate()).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Editor de código (Jupyter Notebook ou VS Code)",
                                    "Acesso à internet para instalação se necessário"
                                  ],
                                  "tips": "Sempre use a mesma versão do Python para evitar variações entre implementações.",
                                  "learningObjective": "Entender o papel da semente em inicializar o estado determinístico do PRNG.",
                                  "commonMistakes": [
                                    "Esquecer de importar o módulo random",
                                    "Definir semente após gerar números",
                                    "Usar random.seed() com valor não inteiro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar múltiplas sequências pseudo-aleatórias usando a mesma semente",
                                  "subSteps": [
                                    "Definir uma função generate_sequence(n) que gera n números aleatórios após setar a semente.",
                                    "Chamar a função duas vezes: seq1 = generate_sequence(10); seq2 = generate_sequence(10).",
                                    "Imprimir ambas as sequências para inspeção visual."
                                  ],
                                  "verification": "Duas sequências de 10 números geradas e exibidas no console.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código Python do Step 1",
                                    "Jupyter Notebook para execução interativa"
                                  ],
                                  "tips": "Reinicie a semente antes de cada geração para simular reinicializações independentes.",
                                  "learningObjective": "Demonstrar a geração controlada de sequências reproduzíveis em PRNGs.",
                                  "commonMistakes": [
                                    "Não resetar a semente entre chamadas, consumindo estado sequencial",
                                    "Gerar sequências de tamanhos diferentes para comparação inválida",
                                    "Ignorar a ordem dos números na sequência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar sequências para verificar a reproduzibilidade determinística",
                                  "subSteps": [
                                    "Implementar uma função compare_sequences(seq1, seq2) que verifica se listas são idênticas.",
                                    "Executar a comparação e imprimir 'Sequências idênticas: True/False'.",
                                    "Analisar numericamente com np.allclose() se usando NumPy para precisão de ponto flutuante."
                                  ],
                                  "verification": "Função de comparação retorna True para sequências com mesma semente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca NumPy (opcional: pip install numpy)",
                                    "Código das sequências anteriores"
                                  ],
                                  "tips": "Use tolerância em comparações de floats devido a precisão numérica.",
                                  "learningObjective": "Validar empiricamente o determinismo de sequências pseudo-aleatórias.",
                                  "commonMistakes": [
                                    "Comparar apenas visualmente sem verificação programática",
                                    "Esquecer tolerância para erros de arredondamento em floats",
                                    "Confundir igualdade exata com aproximação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar com sementes diferentes e discutir aleatoriedade verdadeira",
                                  "subSteps": [
                                    "Gerar seq3 com semente diferente (ex: random.seed(123)) e comparar com seq1.",
                                    "Simular true random discutindo fontes como /dev/urandom vs PRNG.",
                                    "Documentar conclusões em um relatório curto sobre determinismo vs imprevisibilidade."
                                  ],
                                  "verification": "Seq3 difere de seq1 e explicação escrita contrastando PRNG com true random.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "Documentador (Markdown ou texto)"
                                  ],
                                  "tips": "Pesquise fontes de entropia real para enriquecer a discussão.",
                                  "learningObjective": "Diferenciar propriedades de PRNG determinísticos de fontes verdadeiramente aleatórias.",
                                  "commonMistakes": [
                                    "Assumir PRNG como true random sem teste",
                                    "Ignorar consumo de estado em múltiplas gerações sem reset",
                                    "Não documentar o contraste conceitual"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e sintetizar o determinismo da sequência",
                                  "subSteps": [
                                    "Executar experimento completo 3 vezes para confirmação.",
                                    "Calcular estatísticas básicas (média, desvio) das sequências idênticas.",
                                    "Redigir conclusão afirmando reprodutibilidade dada semente fixa."
                                  ],
                                  "verification": "Relatório com resultados consistentes e conclusão correta.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Todos códigos anteriores",
                                    "Ferramenta de estatística (NumPy/Pandas opcional)"
                                  ],
                                  "tips": "Registre sementes usadas para total reprodutibilidade.",
                                  "learningObjective": "Sintetizar evidências para afirmar o caráter determinístico de PRNGs.",
                                  "commonMistakes": [
                                    "Não repetir experimentos para robustez",
                                    "Confundir variabilidade entre sementes com falha determinística",
                                    "Omitir discussão de ciclo/periodo do PRNG"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python para simulação Monte Carlo: ```python import random; random.seed(42); seq1 = [random.random() for _ in range(5)]; random.seed(42); seq2 = [random.random() for _ in range(5)]; print(seq1 == seq2)  # True; random.seed(123); seq3 = [random.random() for _ in range(5)]; print(seq1 == seq3)  # False ``` Demonstra seq1 == seq2 mas != seq3.",
                              "finalVerifications": [
                                "Sequências geradas com mesma semente são idênticas em múltiplas execuções.",
                                "Sequências com sementes diferentes variam previsivelmente.",
                                "Código roda sem erros em reinicializações.",
                                "Conclusão escrita diferencia PRNG de true random.",
                                "Estatísticas das sequências idênticas coincidem exatamente."
                              ],
                              "assessmentCriteria": [
                                "Correta configuração e uso de semente para reprodutibilidade.",
                                "Implementação precisa de comparações de sequências.",
                                "Análise adequada do contraste com aleatoriedade verdadeira.",
                                "Documentação clara de resultados e conclusões.",
                                "Eficiência temporal dentro dos estimados (total < 2h)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Congruências lineares e teoria de números em LCGs.",
                                "Computação: Algoritmos determinísticos e estados finitos.",
                                "Estatística: Testes de uniformidade e independência em sequências.",
                                "Física: Modelagem estocástica em simulações dinâmicas.",
                                "Engenharia: Validação de simulações Monte Carlo em estruturas."
                              ],
                              "realWorldApplication": "Em análises Monte Carlo para dimensionamento de estruturas civis, sementes fixas garantem reprodutibilidade de resultados, facilitando depuração, comparação de modelos e certificação regulatória em projetos de engenharia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.3.3",
                        "name": "Propriedades Desejáveis de Sequências Pseudo-Aleatórias",
                        "description": "Características estatísticas essenciais como uniformidade, independência, ausência de correlação serial, longo período e portabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.3.1",
                            "name": "Listar e descrever propriedades principais",
                            "description": "Detalhar uniformidade (teste qui-quadrado), independência (teste de runs), período máximo (2^m -1 para m-bit) e baixa correlação serial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e listar as propriedades principais de sequências pseudo-aleatórias",
                                  "subSteps": [
                                    "Revise a definição de números pseudo-aleatórios (PNGs) e sua importância em simulações.",
                                    "Liste as quatro propriedades principais: uniformidade, independência, período máximo e baixa correlação serial.",
                                    "Explique brevemente o papel de cada propriedade na qualidade da sequência.",
                                    "Crie um diagrama ou tabela resumindo as propriedades e seus testes associados.",
                                    "Discuta por que essas propriedades são desejáveis em aplicações de Monte Carlo."
                                  ],
                                  "verification": "Crie uma lista numerada com as quatro propriedades e uma frase curta para cada; compartilhe com um colega para validação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto sobre geração de números aleatórios",
                                    "Papel e caneta ou software de diagramação como Draw.io"
                                  ],
                                  "tips": "Use mnemônicos para lembrar as propriedades: U-I-P-C (Uniformidade, Independência, Período, Correlação).",
                                  "learningObjective": "Compreender e listar com precisão as propriedades essenciais de PNGs.",
                                  "commonMistakes": [
                                    "Confundir pseudo-aleatório com verdadeiramente aleatório",
                                    "Omitir o período máximo como 2^m - 1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever a propriedade de uniformidade e o teste qui-quadrado",
                                  "subSteps": [
                                    "Defina uniformidade: distribuição igual de valores em intervalos unitários.",
                                    "Explique o teste qui-quadrado: compara frequências observadas vs. esperadas em bins.",
                                    "Implemente um exemplo simples em Python ou MATLAB dividindo [0,1) em 10 bins.",
                                    "Calcule a estatística qui-quadrado e compare com valor crítico para m=9 (graus de liberdade).",
                                    "Interprete resultados: p-valor > 0.05 indica uniformidade aceitável."
                                  ],
                                  "verification": "Gere 1000 números pseudo-aleatórios, aplique o teste e documente se passa ou falha.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com numpy e scipy",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use bins iguais para evitar viés; gere amostras grandes (>1000) para confiabilidade.",
                                  "learningObjective": "Aplicar e interpretar o teste qui-quadrado para validar uniformidade.",
                                  "commonMistakes": [
                                    "Usar bins desiguais",
                                    "Ignorar graus de liberdade no teste"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar independência, período máximo e teste de runs",
                                  "subSteps": [
                                    "Defina independência: ausência de padrões previsíveis entre números consecutivos.",
                                    "Descreva o teste de runs: conta sequências de runs acima/abaixo da mediana.",
                                    "Explique período máximo: comprimento antes de repetição, idealmente 2^m - 1 para m bits.",
                                    "Exemplo com LCG: parâmetros que maximizam período (a=mult, c=inc, m=mod).",
                                    "Aplique teste de runs em uma sequência e calcule Z-score para independência."
                                  ],
                                  "verification": "Gere uma sequência LCG com período máximo e execute teste de runs; verifique se Z está entre -1.96 e 1.96.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python para LCG",
                                    "Tabelas de valores críticos para teste de runs"
                                  ],
                                  "tips": "Para LCG full-period, use c=1, m=2^k, a=1+4c ou Hull-Dobell criteria.",
                                  "learningObjective": "Avaliar independência via teste de runs e entender condições para período máximo.",
                                  "commonMistakes": [
                                    "Confundir runs com autocorrelação",
                                    "Escolher parâmetros ruins para LCG"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar baixa correlação serial e sintetizar todas as propriedades",
                                  "subSteps": [
                                    "Defina baixa correlação serial: coeficiente de autocorrelação próximo de zero para lags.",
                                    "Calcule autocorrelação para lag=1 em uma sequência longa.",
                                    "Compare limites: |ρ_k| < 1/√N para N amostras.",
                                    "Sintetize: discuta trade-offs e como falhas afetam simulações Monte Carlo.",
                                    "Crie um checklist para validar uma sequência PNG completa."
                                  ],
                                  "verification": "Produza um relatório de 1 página listando todas propriedades com exemplos de testes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software R ou Python pandas para autocorrelação",
                                    "Artigo sobre testes de PNGs"
                                  ],
                                  "tips": "Use lagplot em Python para visualizar correlações; foque em lags pequenos.",
                                  "learningObjective": "Integrar todas propriedades e avaliar qualidade global de PNGs.",
                                  "commonMistakes": [
                                    "Ignorar lags múltiplos",
                                    "Não considerar tamanho da amostra em limites"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere 10.000 números pseudo-aleatórios com LCG (a=1664525, c=1013904223, m=2^32), teste uniformidade com qui-quadrado (deve passar), independência com runs (Z≈0), verifique período próximo de máximo plotando a sequência, e autocorrelação lag-1 <0.01. Use em simulação Monte Carlo para carga em vigas de concreto.",
                              "finalVerifications": [
                                "Liste corretamente as 4 propriedades principais sem omissões.",
                                "Explique o teste qui-quadrado com fórmula e interpretação.",
                                "Descreva condições para período máximo em geradores lineares.",
                                "Aplique teste de runs a uma sequência exemplo.",
                                "Calcule autocorrelação serial e interprete resultado.",
                                "Discuta impacto de falhas em aplicações de engenharia."
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem e descrição (90% correto).",
                                "Profundidade nos testes estatísticos (fórmulas e exemplos).",
                                "Capacidade de implementação prática em código.",
                                "Síntese interdisciplinar com Monte Carlo.",
                                "Clareza e organização do relatório final.",
                                "Identificação correta de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes qui-quadrado e runs.",
                                "Programação: Implementação de LCG em Python/MATLAB.",
                                "Engenharia Civil: Simulações Monte Carlo para análise estrutural.",
                                "Matemática: Teoria dos números e propriedades modulares.",
                                "Ciência da Computação: Algoritmos de PRNGs."
                              ],
                              "realWorldApplication": "Em engenharia civil, sequências pseudo-aleatórias com essas propriedades são usadas em métodos de Monte Carlo para simular cargas variáveis em pontes ou edifícios, garantindo resultados confiáveis em análises de risco sem padrões que distorçam as probabilidades."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.8.3.3.2",
                            "name": "Aplicar testes de qualidade",
                            "description": "Explicar testes como poker, gaps ou spectral para validar propriedades em uma sequência gerada, referenciando baterias de testes como Diehard.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios dos Testes de Qualidade para Sequências Pseudo-Aleatórias",
                                  "subSteps": [
                                    "Estude as propriedades desejáveis de sequências pseudo-aleatórias: independência, uniformidade e ausência de padrões.",
                                    "Revise testes específicos: Poker (distribuição de mãos de poker), Gaps (distribuição de gaps entre ocorrências), Spectral (análise em domínio de frequência).",
                                    "Analise a bateria Diehard: entenda sua composição de 15 testes estatísticos rigorosos.",
                                    "Compare testes individuais com baterias completas para validar múltiplas propriedades.",
                                    "Identifique limitações dos testes e quando usá-los."
                                  ],
                                  "verification": "Resuma em um documento os princípios de cada teste e liste 3 exemplos de falhas detectáveis.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação Diehard (site oficial ou PDF)",
                                    "Artigos sobre testes de aleatoriedade (NIST SP 800-22)",
                                    "Livro 'The Art of Computer Programming' Vol. 2 de Knuth (capítulo sobre RNGs)"
                                  ],
                                  "tips": [
                                    "Comece com visualizações gráficas de falhas em geradores ruins para intuitividade.",
                                    "Use tabelas para comparar testes por propriedade testada."
                                  ],
                                  "learningObjective": "Explicar como testes como Poker, Gaps e Spectral validam propriedades independência e uniformidade em sequências pseudo-aleatórias.",
                                  "commonMistakes": [
                                    "Confundir testes de uniformidade com independência.",
                                    "Ignorar o tamanho mínimo da sequência necessário para testes confiáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Testes Individuais em uma Sequência Gerada",
                                  "subSteps": [
                                    "Gere uma sequência pseudo-aleatória usando um gerador simples como Linear Congruential Generator (LCG).",
                                    "Implemente o teste Poker: conte frequências de 'mãos' de 5 dígitos e compare com distribuição χ².",
                                    "Aplique o teste Gaps: meça distâncias entre ocorrências de um valor e verifique distribuição exponencial.",
                                    "Execute o teste Spectral: aplique FFT e verifique ausência de picos no espectro.",
                                    "Automatize os testes em código Python ou MATLAB."
                                  ],
                                  "verification": "Execute os testes em uma sequência de 10^6 números e gere relatório com p-valores > 0.01.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com bibliotecas NumPy, SciPy (para χ² e FFT)",
                                    "Código fonte de LCG",
                                    "Ferramentas online como ENT ou DIEHARDer"
                                  ],
                                  "tips": [
                                    "Normalize a sequência para [0,1] antes dos testes.",
                                    "Registre sementes para reprodutibilidade."
                                  ],
                                  "learningObjective": "Implementar e aplicar testes Poker, Gaps e Spectral para validar uniformidade e independência.",
                                  "commonMistakes": [
                                    "Usar sequências curtas (menos de 10^5), levando a falsos positivos.",
                                    "Erro na discretização para teste Poker."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Baterias de Testes Completas como Diehard",
                                  "subSteps": [
                                    "Instale e configure a suíte Diehard ou equivalente (TestU01, NIST STS).",
                                    "Gere sequências candidatas com diferentes parâmetros de geradores (ex: Mersenne Twister vs. LCG).",
                                    "Execute a bateria completa: monitore todos os 15 testes do Diehard.",
                                    "Registre falhas e ajuste parâmetros do gerador para passar nos testes.",
                                    "Compare resultados entre geradores ruins e bons."
                                  ],
                                  "verification": "Produza um relatório mostrando pelo menos uma sequência que passa em 90% dos testes Diehard.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Suite Diehard (binário ou Docker)",
                                    "TestU01 library",
                                    "Geradores RNG em C/Python"
                                  ],
                                  "tips": [
                                    "Execute em máquina com boa CPU para testes computacionalmente intensos.",
                                    "Salve saídas em log para análise posterior."
                                  ],
                                  "learningObjective": "Usar baterias como Diehard para validar rigorosamente sequências pseudo-aleatórias.",
                                  "commonMistakes": [
                                    "Interpretar p-valores isolados sem contexto estatístico.",
                                    "Não considerar correlações entre testes."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Validar Propriedades Desejáveis",
                                  "subSteps": [
                                    "Interprete p-valores: rejeite se <0.01, suspeite se múltiplos falham.",
                                    "Mapeie falhas para propriedades: ex. spectral falha indica periodicidade.",
                                    "Documente recomendações para geradores em aplicações de Monte Carlo.",
                                    "Teste sequências em cenários reais de Engenharia Civil (ex. simulação de cargas).",
                                    "Crie checklist para validação futura de sequências."
                                  ],
                                  "verification": "Crie um relatório final com análise de uma sequência, confirmando ou rejeitando sua qualidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilhas Excel para tabulação de p-valores",
                                    "Relatórios gerados pelos testes"
                                  ],
                                  "tips": [
                                    "Use gráficos de p-valores para visualização rápida.",
                                    "Considere testes adaptativos para sequências longas."
                                  ],
                                  "learningObjective": "Analisar resultados de testes para confirmar propriedades desejáveis em sequências pseudo-aleatórias.",
                                  "commonMistakes": [
                                    "Aceitar sequências com falhas marginais em aplicações críticas.",
                                    "Ignorar viés do gerador em domínios específicos."
                                  ]
                                }
                              ],
                              "practicalExample": "Gere 10^7 números com LCG (a=1664525, c=1013904223, m=2^32). Aplique teste Poker: conte mãos e calcule χ²=12.5 (p=0.19, passa). Execute Diehard: falha em 'Birthday Spacings' indica correlação; mude semente e reteste até passar.",
                              "finalVerifications": [
                                "Sequência passa em pelo menos 90% dos testes individuais (Poker, Gaps, Spectral).",
                                "Bateria Diehard reporta sem falhas críticas (todos p-valores >0.001).",
                                "Gráficos espectrais mostram espectro branco (sem picos).",
                                "Checklist de propriedades (uniformidade, independência) confirmada.",
                                "Relatório inclui interpretação e recomendações.",
                                "Código reproduzível gera resultados consistentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação: testes replicam referências padrão (erro <1%).",
                                "Interpretação correta: identifica falhas e propriedades violadas.",
                                "Eficiência computacional: testes executam em <1 hora para 10^7 amostras.",
                                "Documentação completa: inclui código, resultados e análise.",
                                "Aplicação contextual: relaciona a Monte Carlo em Engenharia Civil.",
                                "Criatividade: testa múltiplos geradores e compara."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: uso de testes qui-quadrado e distribuições exponenciais.",
                                "Programação: implementação numérica com FFT e simulações.",
                                "Engenharia Civil: validação RNG para simulações Monte Carlo em análise estrutural.",
                                "Matemática Computacional: teoria de números e análise espectral."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para avaliação de confiabilidade de estruturas civis, como previsão de falhas em pontes sob cargas aleatórias; testes garantem que amostras sejam verdadeiramente pseudo-aleatórias, evitando vieses em estimativas de risco."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.8.3.3.3",
                            "name": "Identificar falhas comuns",
                            "description": "Reconhecer problemas como lattice structure ou curto período em geradores ruins, e soluções como combinação de geradores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Propriedades Desejáveis de Sequências Pseudo-Aleatórias",
                                  "subSteps": [
                                    "Estude as cinco propriedades principais: uniformidade, independência, período longo, baixa autocorrelação e ausência de padrões detectáveis.",
                                    "Analise testes estatísticos como χ² para uniformidade e runs test para independência.",
                                    "Compare sequências ideais (verdadeiramente aleatórias) com pseudo-aleatórias usando gráficos de dispersão.",
                                    "Liste exemplos de violações potenciais em contextos de Monte Carlo.",
                                    "Crie um checklist pessoal das propriedades desejáveis."
                                  ],
                                  "verification": "Checklist preenchido corretamente com pelo menos 80% de precisão em quiz autoavaliativo sobre propriedades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de Knuth 'The Art of Computer Programming' (Vol. 2), notebook Jupyter para gráficos.",
                                  "tips": "Use visualizações como plots de pontos para intuitivamente entender independência.",
                                  "learningObjective": "Compreender as bases para identificar desvios em PRNGs.",
                                  "commonMistakes": "Confundir uniformidade com independência; ignorar propriedades de longo alcance como período."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Falhas Comuns em Geradores Pseudo-Aleatórios",
                                  "subSteps": [
                                    "Aprenda sobre lattice structure em geradores lineares congruenciais (LCG): pontos se alinham em retas ou planos em espaço multidimensional.",
                                    "Investigue curto período: ciclos repetem prematuramente, detectável por testes de poker ou serial correlation.",
                                    "Examine correlações seriais e autocorrelações em geradores como Middle-Square Method.",
                                    "Analise falhas em geradores específicos como RANDU (LCG com m=2^31, ruim multiplier).",
                                    "Registre definições e testes diagnósticos para cada falha."
                                  ],
                                  "verification": "Resuma cada falha em um parágrafo e gere uma sequência de 1000 números para demonstrar visualmente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python com NumPy/Random, artigos sobre falhas de PRNG (e.g., Marsaglia's diehard tests).",
                                  "tips": "Gere plots 2D/3D para visualizar lattice structures imediatamente.",
                                  "learningObjective": "Reconhecer padrões característicos de falhas comuns em PRNGs ruins.",
                                  "commonMistakes": "Atribuir falhas a ruído aleatório em vez de estrutura determinística."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos Práticos de Geradores Ruins e Bons",
                                  "subSteps": [
                                    "Implemente e teste um LCG ruim (a=1, c=1, m=16) para curto período.",
                                    "Compare com um bom LCG (parâmetros de Hull-Dobell) usando testes estatísticos.",
                                    "Gere scatter plots para detectar lattice em múltiplas dimensões.",
                                    "Aplique testes como spectral test para quantificar lattice structure.",
                                    "Documente achados em relatório comparativo."
                                  ],
                                  "verification": "Relatório com plots e p-values de testes mostrando identificação correta de pelo menos 3 falhas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python (matplotlib, scipy.stats), gerador online de PRNG como practrand.org.",
                                  "tips": "Aumente dimensões gradualmente (2D para 5D) para ver lattice emergir.",
                                  "learningObjective": "Aplicar testes para diagnosticar falhas em geradores reais.",
                                  "commonMistakes": "Usar amostras pequenas (<10^4); ignorar efeitos dimensionais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Soluções e Combinações de Geradores",
                                  "subSteps": [
                                    "Estude combinação de geradores: XOR de dois LCGs ou Mersenne Twister.",
                                    "Implemente um híbrido (e.g., LCG + Xorshift) e compare testes com geradores isolados.",
                                    "Avalie trade-offs: custo computacional vs. qualidade pseudo-aleatória.",
                                    "Teste em simulação Monte Carlo simples (e.g., π estimation) para impacto de falhas.",
                                    "Crie guidelines para escolher/combinar PRNGs em engenharia."
                                  ],
                                  "verification": "Implementação funcional com testes mostrando melhoria em pelo menos 2 métricas (período, lattice-free).",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Biblioteca random de Python, código de referência para PCG ou MT19937.",
                                  "tips": "Use seeds diferentes para combinar; valide com battery de testes NIST.",
                                  "learningObjective": "Identificar e mitigar falhas usando técnicas de combinação.",
                                  "commonMistakes": "Combinar geradores correlacionados; subestimar overhead computacional."
                                }
                              ],
                              "practicalExample": "Implemente um LCG ruim (X_{n+1} = (16807 * X_n) mod 2^31 -1, seed=1) e gere 10.000 pontos em 3D. Observe lattice structure nos plots de dispersão (pontos em 15 planos). Corrija combinando com Xorshift128 via XOR e reverifique ausência de estrutura.",
                              "finalVerifications": [
                                "Explicar lattice structure e demonstrar em plot 3D de LCG ruim.",
                                "Identificar curto período em sequência cíclica e calcular seu comprimento exato.",
                                "Aplicar pelo menos 3 testes estatísticos (χ², runs, spectral) a um PRNG e interpretar resultados.",
                                "Propor combinação de dois geradores para corrigir falha específica.",
                                "Simular impacto de PRNG ruim em estimativa Monte Carlo de integral (erro >10%).",
                                "Checklist de propriedades desejáveis validado para gerador híbrido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de falhas: 90% em 10 exemplos testados.",
                                "Qualidade de visualizações e testes estatísticos: p-values corretamente interpretados.",
                                "Criatividade em soluções de combinação: pelo menos uma melhoria mensurável.",
                                "Relatórios claros com evidências: estrutura lógica e referências.",
                                "Compreensão conceitual: explicação verbal sem erros em propriedades.",
                                "Eficiência prática: tempo de execução otimizado em simulações."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses e análise de distribuições.",
                                "Programação: Implementação eficiente de algoritmos numéricos.",
                                "Engenharia Civil: Simulações Monte Carlo para análise de risco em estruturas.",
                                "Matemática: Teoria dos números e análise modular.",
                                "Ciência de Dados: Validação de dados sintéticos em ML."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para análise probabilística de falhas em pontes ou barragens, PRNGs ruins com lattice structure podem enviesar distribuições de carga, levando a subestimação de riscos e projetos inseguros; identificar e corrigir garante precisão em avaliações de engenharia civil."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.8.3.3.4",
                            "name": "Relacionar com Monte Carlo",
                            "description": "Explicar como propriedades inadequadas afetam precisão em simulações de Monte Carlo para problemas de engenharia civil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Propriedades Desejáveis e Inadequadas de Sequências Pseudo-Aleatórias",
                                  "subSteps": [
                                    "Liste as propriedades desejáveis: uniformidade, independência, período longo e ausência de correlações.",
                                    "Identifique propriedades inadequadas comuns: padrões cíclicos, correlações seriais e viés na distribuição.",
                                    "Compare exemplos de bons (Mersenne Twister) vs ruins (Linear Congruential Generator simples) geradores.",
                                    "Calcule estatísticas básicas como teste de χ² para uniformidade em uma sequência gerada.",
                                    "Discuta implicações qualitativas de cada propriedade inadequada."
                                  ],
                                  "verification": "Gere uma sequência pseudo-aleatória e aplique testes estatísticos para confirmar compreensão das propriedades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/SciPy, documentação de geradores RNG, calculadora estatística.",
                                  "tips": "Use visualizações como histogramas para detectar viés rapidamente.",
                                  "learningObjective": "Compreender e diferenciar propriedades que garantem qualidade em sequências pseudo-aleatórias.",
                                  "commonMistakes": "Confundir independência com uniformidade; ignorar impacto de sementes iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Método de Monte Carlo e sua Dependência em Aleatoriedade",
                                  "subSteps": [
                                    "Explique o princípio: usar amostras aleatórias para estimar integrais ou distribuições probabilísticas.",
                                    "Descreva a convergência: erro proporcional a 1/sqrt(N), onde N é o número de simulações.",
                                    "Analise como variância e correlações nas amostras afetam a precisão da estimativa.",
                                    "Implemente um Monte Carlo simples para estimar π usando pontos aleatórios em um círculo.",
                                    "Meça a variância da estimativa variando o gerador RNG."
                                  ],
                                  "verification": "Execute simulação de Monte Carlo para π e compare erros com diferentes RNGs.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/Jupyter Notebook, bibliotecas NumPy e Matplotlib.",
                                  "tips": "Aumente N iterativamente para observar convergência e impacto de RNG ruim.",
                                  "learningObjective": "Dominar fundamentos de Monte Carlo e sua sensibilidade à qualidade das amostras aleatórias.",
                                  "commonMistakes": "Subestimar o papel da variância; usar N muito pequeno para testes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impactos de Propriedades Inadequadas na Precisão de Monte Carlo",
                                  "subSteps": [
                                    "Simule correlação serial: gere sequências correlacionadas e aplique em Monte Carlo para π.",
                                    "Teste viés: use RNG com distribuição não-uniforme e observe desvio na estimativa.",
                                    "Examine período curto: repita simulações além do período e detecte ciclos na saída.",
                                    "Quantifique erros: calcule viés e variância estatística para cada caso inadequado.",
                                    "Compare com RNG ideal: use múltiplos seeds e agregue resultados."
                                  ],
                                  "verification": "Gere gráficos de erro vs número de simulações para RNG bom vs ruim.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código Python customizado para RNGs defeituosos, SciPy para testes estatísticos.",
                                  "tips": "Autocorrelação plots revelam padrões ocultos em sequências.",
                                  "learningObjective": "Quantificar como falhas em propriedades pseudo-aleatórias degradam precisão em Monte Carlo.",
                                  "commonMistakes": "Atribuir erros apenas a N baixo, ignorando qualidade do RNG."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conceitos a Problemas de Engenharia Civil",
                                  "subSteps": [
                                    "Selecione problema: simulação de carga aleatória em uma viga ou propagação de incertezas em fundações.",
                                    "Modele o problema: defina variáveis aleatórias (ex: vento, peso de solo) com distribuições reais.",
                                    "Implemente Monte Carlo com RNG bom e ruim, estimando probabilidade de falha.",
                                    "Analise resultados: compare precisão, tempo de convergência e confiança nos intervalos.",
                                    "Relatório: documente impactos em decisões de engenharia (ex: sobredimensionamento devido a viés)."
                                  ],
                                  "verification": "Produza relatório com tabelas/gráficos mostrando diferenças de precisão em contexto civil.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com bibliotecas de engenharia (ex: NumPy, SciPy, possivelmente OpenSees para simulação estrutural).",
                                  "tips": "Use distribuições reais de ASCE para cargas em estruturas civis.",
                                  "learningObjective": "Relacionar falhas em RNG com erros práticos em simulações de engenharia civil.",
                                  "commonMistakes": "Simplificar demais o modelo físico; não considerar dimensionalidade alta."
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para avaliar a segurança de uma ponte sob cargas de vento aleatórias, um RNG com correlação serial subestima a variância das cargas, levando a uma probabilidade de falha 20% menor que a real, potencialmente aprovando um projeto inseguro.",
                              "finalVerifications": [
                                "Explicar verbalmente como correlação serial aumenta variância efetiva em Monte Carlo.",
                                "Implementar e comparar simulações com RNGs diferentes, mostrando gráficos de convergência.",
                                "Identificar propriedade inadequada em uma sequência dada e prever seu impacto.",
                                "Aplicar a um caso civil simples e justificar escolha de RNG.",
                                "Calcular erro teórico devido a viés em uma estimativa Monte Carlo.",
                                "Discutir trade-offs entre velocidade e precisão de RNGs em projetos reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de propriedades inadequadas (90% acerto em testes).",
                                "Capacidade de quantificar impactos via simulações (erro <5% em exemplos controlados).",
                                "Clareza na explicação de mecanismos de degradação de precisão.",
                                "Relevância da aplicação a engenharia civil com dados realistas.",
                                "Uso correto de testes estatísticos e visualizações.",
                                "Relatório estruturado com conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses e análise de variância.",
                                "Programação: Implementação eficiente de algoritmos RNG.",
                                "Física/Mecânica: Modelagem estocástica de cargas em estruturas.",
                                "Probabilidade: Teorema do limite central e convergência em Monte Carlo.",
                                "Ética em Engenharia: Riscos de simulações imprecisas em segurança pública."
                              ],
                              "realWorldApplication": "Na análise de risco de barragens ou edifícios altos, simulações Monte Carlo com RNG inadequado podem superestimar estabilidade, levando a falhas catastróficas como visto em colapsos históricos por subestimação de incertezas; engenheiros usam RNG certificados (ex: PCG) para garantir precisão em normas como Eurocode."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.4",
                    "name": "Método Congruencial Linear",
                    "description": "Algoritmo padrão para gerar números pseudo-aleatórios com parâmetros módulo, multiplicador e incremento.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.4.1",
                        "name": "Fundamentos do Método Congruencial Linear",
                        "description": "Introdução ao algoritmo padrão para geração de números pseudo-aleatórios, incluindo sua definição e propósito na simulação computacional.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.4.1.1",
                            "name": "Definir o Método Congruencial Linear",
                            "description": "Explicar que o Método Congruencial Linear (MCL) é um algoritmo determinístico que gera uma sequência de números pseudo-aleatórios usando recursão linear modular, com semente inicial X0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Aleatoriedade e Pseudo-Aleatoriedade",
                                  "subSteps": [
                                    "Pesquise a diferença entre números aleatórios verdadeiros e pseudo-aleatórios.",
                                    "Leia sobre a necessidade de sequências determinísticas em computação.",
                                    "Identifique aplicações em simulações computacionais, como Monte Carlo.",
                                    "Anote exemplos de geradores pseudo-aleatórios simples.",
                                    "Discuta limitações de hardware para aleatoriedade verdadeira."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a diferença entre aleatoriedade verdadeira e pseudo-aleatoriedade, citando pelo menos duas aplicações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet para pesquisa",
                                    "Caderno e caneta"
                                  ],
                                  "tips": "Use analogias como 'dados físicos vs. dados simulados em um jogo de computador' para fixar o conceito.",
                                  "learningObjective": "Compreender por que o MCL é necessário em contextos computacionais determinísticos.",
                                  "commonMistakes": [
                                    "Confundir pseudo-aleatoriedade com aleatoriedade verdadeira",
                                    "Ignorar o aspecto determinístico baseado na semente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Apresentar a Fórmula do Método Congruencial Linear",
                                  "subSteps": [
                                    "Escreva a fórmula recursiva: X_{n+1} = (a * X_n + c) mod m.",
                                    "Identifique que é um algoritmo determinístico com recursão linear modular.",
                                    "Desenhe um diagrama de fluxo mostrando a iteração a partir de X0.",
                                    "Calcule manualmente o primeiro passo com valores hipotéticos (ex: a=5, X0=3, c=1, m=16).",
                                    "Explique o papel da operação módulo na restrição do intervalo [0, m-1]."
                                  ],
                                  "verification": "Reproduza a fórmula corretamente e calcule X1 a partir de parâmetros dados sem consultar notas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora simples"
                                  ],
                                  "tips": "Memorize a fórmula como 'multiplicar por a, somar c, módulo m' para facilitar a recordação.",
                                  "learningObjective": "Memorizar e reproduzir a fórmula central do MCL.",
                                  "commonMistakes": [
                                    "Esquecer o módulo m",
                                    "Confundir a ordem das operações (multiplicação antes da soma)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar os Parâmetros e a Semente Inicial",
                                  "subSteps": [
                                    "Defina X0 como a semente inicial, que determina toda a sequência.",
                                    "Descreva 'a' como o multiplicador, influenciando o período.",
                                    "Explique 'c' como o incremento (pode ser zero para multiplicativo).",
                                    "Detalhe 'm' como o módulo, definindo o tamanho do intervalo.",
                                    "Discuta escolhas típicas: m=2^k, a ímpar, etc., para boas propriedades.",
                                    "Crie uma tabela resumindo cada parâmetro e seu impacto."
                                  ],
                                  "verification": "Preencha uma tabela com definições e exemplos numéricos para cada parâmetro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Exemplos de parâmetros de fontes confiáveis"
                                  ],
                                  "tips": "Pense nos parâmetros como 'ingredientes' de uma receita: cada um afeta o 'sabor' (qualidade) da sequência.",
                                  "learningObjective": "Dominar o significado e o papel de cada componente na fórmula.",
                                  "commonMistakes": [
                                    "Achar que X0 é opcional",
                                    "Não entender que m define o range dos números gerados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Propriedades e Condições para Boas Sequências",
                                  "subSteps": [
                                    "Estude o período máximo (idealmente m para c≠0).",
                                    "Liste condições de Hull-Dobell para período completo.",
                                    "Simule uma sequência curta e observe repetições.",
                                    "Compare MCL com outros geradores simples.",
                                    "Relacione com aplicações em Engenharia Civil, como simulações Monte Carlo."
                                  ],
                                  "verification": "Liste 3 condições para período ótimo e verifique com um exemplo numérico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python para simulação opcional",
                                    "Referências teóricas"
                                  ],
                                  "tips": "Teste parâmetros ruins (ex: a=1) para ver ciclos curtos e aprender na prática.",
                                  "learningObjective": "Compreender fatores que tornam o MCL eficaz para pseudo-aleatoriedade.",
                                  "commonMistakes": [
                                    "Ignorar dependência da semente",
                                    "Achar que qualquer a,c,m gera boa aleatoriedade"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando X0=17, a=5, c=1, m=100: X1=(5*17 +1) mod 100=86; X2=(5*86 +1) mod 100=31; X3=(5*31 +1) mod 100=56. Essa sequência pode ser usada em simulações de cargas aleatórias em estruturas civis via Monte Carlo.",
                              "finalVerifications": [
                                "Recitar a fórmula MCL com todos os parâmetros corretos.",
                                "Explicar o impacto da semente X0 na reproducibilidade.",
                                "Calcular 3 iterações manualmente com parâmetros dados.",
                                "Identificar pelo menos 2 condições para bom período.",
                                "Relacionar MCL a uma aplicação em simulações computacionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na reprodução da fórmula (100% dos componentes corretos).",
                                "Compreensão demonstrada via cálculo manual sem erros.",
                                "Explicação clara dos parâmetros e suas funções.",
                                "Identificação correta de propriedades e limitações.",
                                "Conexão lógica com contextos reais como Monte Carlo.",
                                "Uso de terminologia técnica apropriada (ex: 'recursão linear modular')."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em linguagens como Python ou MATLAB.",
                                "Estatística: Avaliação de uniformidade e independência das sequências.",
                                "Engenharia Civil: Simulações Monte Carlo para análise de riscos estruturais.",
                                "Matemática: Aritmética modular e teoria dos números."
                              ],
                              "realWorldApplication": "No contexto de Engenharia Civil, o MCL gera números pseudo-aleatórios para simulações Monte Carlo, modelando variáveis incertas como cargas de vento ou tráfego em pontes, permitindo previsões probabilísticas de falhas estruturais sem hardware aleatório verdadeiro."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.1.2",
                            "name": "Identificar os componentes básicos do MCL",
                            "description": "Reconhecer os elementos essenciais: semente inicial (X0), módulo (m), multiplicador (a) e incremento (c), e sua relação na fórmula X_{n+1} = (a * X_n + c) mod m.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito geral do Método Congruencial Linear (MCL)",
                                  "subSteps": [
                                    "Pesquise a definição de MCL como gerador de números pseudo-aleatórios.",
                                    "Identifique que o MCL é um algoritmo determinístico usado para simular aleatoriedade.",
                                    "Leia sobre sua importância em simulações computacionais, como no Método de Monte Carlo.",
                                    "Anote os quatro componentes principais mencionados na descrição: X0, m, a e c.",
                                    "Visualize um diagrama de fluxo do processo iterativo do MCL."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases explicando o que é MCL e liste os quatro componentes básicos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Notebook, acesso à internet para artigos introdutórios sobre MCL (ex: Wikipedia ou tutoriais de números pseudo-aleatórios).",
                                  "tips": "Comece com fontes visuais como diagramas para facilitar a compreensão inicial.",
                                  "learningObjective": "Compreender o propósito e os componentes fundamentais do MCL.",
                                  "commonMistakes": "Confundir MCL com geradores verdadeiramente aleatórios; ignorar que é pseudo-aleatório."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar cada componente individual: X0, m, a e c",
                                  "subSteps": [
                                    "Defina X0 como a semente inicial (valor inicial entre 0 e m-1).",
                                    "Explique m como o módulo (determina o range dos números gerados, geralmente uma potência de 2).",
                                    "Descreva a como o multiplicador (constante que 'embaralha' o valor anterior, tipicamente ímpar).",
                                    "Detalhe c como o incremento (aditivo para evitar padrões curtos, pode ser 0 em variantes).",
                                    "Crie uma tabela comparativa com definições, papéis e restrições típicas para cada um."
                                  ],
                                  "verification": "Preencha uma tabela com colunas: Componente, Definição, Exemplo numérico simples e Restrições.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel ou planilha digital (Google Sheets/Excel) para tabela.",
                                  "tips": "Use exemplos numéricos pequenos, como m=10, para testar intuição.",
                                  "learningObjective": "Reconhecer e diferenciar precisamente cada um dos quatro componentes do MCL.",
                                  "commonMistakes": "Confundir a com m (multiplicador vs. módulo); escolher valores inadequados para testes iniciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender a fórmula de recursão X_{n+1} = (a * X_n + c) mod m",
                                  "subSteps": [
                                    "Escreva a fórmula e identifique cada termo: X_{n+1} (novo valor), a*X_n (multiplicação), +c (incremento), mod m (redução ao módulo).",
                                    "Explique o papel do 'mod m' para manter os valores no intervalo [0, m-1].",
                                    "Trace um exemplo manual: comece com X0=3, a=5, c=7, m=16; calcule X1 e X2.",
                                    "Discuta como a iteração gera a sequência pseudo-aleatória.",
                                    "Identifique dependências: todos os componentes são necessários para a recursão."
                                  ],
                                  "verification": "Calcule manualmente 3 iterações de uma sequência MCL com parâmetros dados e rotule cada componente na fórmula.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou papel para cálculos manuais; pseudocódigo simples.",
                                  "tips": "Faça cálculos passo a passo na fórmula para visualizar o fluxo.",
                                  "learningObjective": "Entender como os componentes interagem na fórmula recursiva do MCL.",
                                  "commonMistakes": "Esquecer o 'mod m' levando a números crescentes; confundir ordem das operações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação dos componentes em exemplos reais",
                                  "subSteps": [
                                    "Analise um exemplo dado: parâmetros X0=123, a=1664525, c=1013904223, m=2^32; identifique cada um.",
                                    "Crie seu próprio conjunto de parâmetros e verifique se atendem critérios básicos (ex: 0 ≤ X0 < m).",
                                    "Compare com código Python simples: def mcl(x0, a, c, m, n): ...",
                                    "Identifique componentes em descrições textuais ou diagramas.",
                                    "Teste com variações: MCL com c=0 (multiplicativo)."
                                  ],
                                  "verification": "Dado um conjunto de parâmetros e fórmula, rotule corretamente X0, a, c, m em 3 exemplos diferentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código simples (ex: Python online como Replit) ou papel.",
                                  "tips": "Sempre verifique se X_{n+1} está no range [0, m-1] após mod.",
                                  "learningObjective": "Aplicar o conhecimento para identificar componentes em contextos variados.",
                                  "commonMistakes": "Não validar range após módulo; ignorar dependências entre parâmetros."
                                }
                              ],
                              "practicalExample": "Considere parâmetros para simulação em Engenharia Civil: X0=42 (semente), a=1664525 (multiplicador), c=1013904223 (incremento), m=4294967296 (2^32, módulo). Calcule X1 = (1664525 * 42 + 1013904223) mod 4294967296 = 1577058325. Aqui, identifique: X0 inicia, a multiplica, c adiciona variabilidade, m limita o range para uso em Monte Carlo.",
                              "finalVerifications": [
                                "Liste corretamente os quatro componentes: X0, m, a, c sem omissões.",
                                "Explique a fórmula X_{n+1} = (a * X_n + c) mod m verbalmente.",
                                "Identifique componentes em um exemplo numérico fornecido.",
                                "Diferencie papéis: semente vs. multiplicador vs. incremento vs. módulo.",
                                "Calcule uma iteração manual corretamente.",
                                "Reconheça que mod m garante valores no intervalo [0, m-1]."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cada componente (100% correto).",
                                "Compreensão da interdependência na fórmula (explicação clara).",
                                "Habilidade em aplicar a exemplos concretos sem erros de cálculo.",
                                "Uso correto de terminologia (semente, módulo, etc.).",
                                "Validação de ranges e restrições básicas.",
                                "Capacidade de traçar 2-3 iterações manuais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra modular e aritmética de inteiros.",
                                "Programação: Implementação de loops recursivos em linguagens como Python ou C.",
                                "Estatística: Geração de números pseudo-aleatórios para simulações.",
                                "Engenharia Civil: Aplicações em Método de Monte Carlo para análise de riscos estruturais."
                              ],
                              "realWorldApplication": "No Método de Monte Carlo para simulações em Engenharia Civil, o MCL gera números pseudo-aleatórios para modelar cargas variáveis em estruturas, prever falhas probabilísticas ou otimizar projetos de pontes sob incertezas, permitindo análises robustas sem hardware de RNG verdadeiro."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.1.3",
                            "name": "Diferenciar números pseudo-aleatórios de aleatórios verdadeiros",
                            "description": "Compreender que o MCL produz sequências que aparentam aleatoriedade, mas são periódicos e reproduzíveis, ideal para simulações em engenharia como Monte Carlo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender números aleatórios verdadeiros",
                                  "subSteps": [
                                    "Defina aleatoriedade verdadeira como oriunda de processos físicos imprevisíveis, como ruído térmico ou decaimento radioativo.",
                                    "Estude fontes comuns: geradores quânticos, ruído atmosférico ou hardware especializado.",
                                    "Discuta propriedades: imprevisibilidade total, ausência de padrões ou periodicidade detectável.",
                                    "Compare com determinismo: aleatórios verdadeiros não são reproduzíveis com a mesma semente.",
                                    "Pesquise exemplos reais em criptografia e simulações científicas."
                                  ],
                                  "verification": "Resuma em um parágrafo as características únicas dos aleatórios verdadeiros e cite duas fontes reais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigos sobre geradores de números aleatórios quânticos",
                                    "Vídeos educativos sobre entropia em computação"
                                  ],
                                  "tips": "Foquem em exemplos físicos para diferenciar de algoritmos.",
                                  "learningObjective": "Identificar fontes e propriedades fundamentais de aleatoriedade verdadeira.",
                                  "commonMistakes": [
                                    "Confundir com pseudo-aleatórios simulados",
                                    "Ignorar a não-reprodutibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Método Congruencial Linear (MCL)",
                                  "subSteps": [
                                    "Revise a fórmula do MCL: X_{n+1} = (a * X_n + c) mod m.",
                                    "Explique parâmetros: semente X_0, multiplicador a, incremento c, módulo m.",
                                    "Gere manualmente uma sequência curta com parâmetros simples (ex: a=5, c=3, m=16, X0=1).",
                                    "Observe a reproduzibilidade: execute com mesma semente e compare resultados.",
                                    "Calcule o período máximo possível (m) e identifique quando ele se repete."
                                  ],
                                  "verification": "Gere uma sequência de 20 números e demonstre que ela se repete após certo ponto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou planilha Excel",
                                    "Documentação sobre MCL em linguagens como Python (random module)"
                                  ],
                                  "tips": "Use planilhas para visualizar a sequência e detectar ciclos visualmente.",
                                  "learningObjective": "Dominar a geração e propriedades básicas de pseudo-aleatórios via MCL.",
                                  "commonMistakes": [
                                    "Escolher parâmetros ruins que causem período curto",
                                    "Esquecer o módulo m na redução"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar diferenças chave entre pseudo e verdadeiros",
                                  "subSteps": [
                                    "Liste propriedades pseudo: determinístico, periódico, reproduzível com semente.",
                                    "Liste propriedades verdadeiras: não-determinístico, aperiódico, não-reproduzível.",
                                    "Analise testes estatísticos: distribuição uniforme aparente mas falha em testes de independência longa.",
                                    "Discuta limitações do MCL: período finito ≤ m, correlações detectáveis.",
                                    "Compare visualmente histogramas e sequências longas de ambos."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 5 diferenças claras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramentas online de testes de aleatoriedade (ex: DIEHARD tests)",
                                    "Gráficos gerados em Python/MATLAB"
                                  ],
                                  "tips": "Gere sequências longas (>1000) para revelar periodicidade.",
                                  "learningObjective": "Discernir propriedades matemáticas e práticas que distinguem os dois tipos.",
                                  "commonMistakes": [
                                    "Achar pseudo-aleatórios 'bons o suficiente' sem testar período",
                                    "Ignorar impacto da semente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar diferenciação em testes práticos",
                                  "subSteps": [
                                    "Implemente MCL em código e gere sequência longa; plote para visualizar ciclo.",
                                    "Simule aleatório verdadeiro com dados reais (ex: API de ruído quântico).",
                                    "Aplique testes: autocorrelação, teste de poker, spectral test para detectar padrões.",
                                    "Avalie adequação: pseudo para simulações rápidas, verdadeiro para segurança.",
                                    "Documente conclusões sobre uso em Monte Carlo."
                                  ],
                                  "verification": "Execute testes e interprete resultados mostrando falhas do pseudo-aleatório.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com numpy/random",
                                    "Biblioteca random.org para dados verdadeiros",
                                    "Ferramentas de plotagem (matplotlib)"
                                  ],
                                  "tips": "Comece com código simples; valide com seeds conhecidas.",
                                  "learningObjective": "Executar testes práticos para diferenciar na prática.",
                                  "commonMistakes": [
                                    "Usar sequências curtas que mascaram periodicidade",
                                    "Não normalizar dados para testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere uma sequência MCL com m=100, a=23, c=47, X0=42. Após 100 números, ela cicla. Compare com números de random.org: a MCL repete exatamente com mesma semente, enquanto o verdadeiro varia a cada execução.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças principais sem hesitação.",
                                "Gerar e analisar uma sequência MCL identificando seu período.",
                                "Interpretar resultados de um teste estatístico em pseudo vs verdadeiro.",
                                "Justificar por que MCL é ideal para Monte Carlo apesar de ser pseudo.",
                                "Criar diagrama comparativo das propriedades.",
                                "Discutir limitações em aplicações sensíveis como criptografia."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de aleatoriedade verdadeira vs pseudo (90%+ correta).",
                                "Correta implementação e análise de MCL com período detectado.",
                                "Uso adequado de testes estatísticos com interpretação válida.",
                                "Clareza na tabela/diagrama comparativo.",
                                "Conexão explícita com simulações Monte Carlo.",
                                "Ausência de confusões comuns como equiparar aparente aleatoriedade a verdadeira."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Testes de hipóteses para aleatoriedade.",
                                "Programação: Implementação de algoritmos geradores em Python/C++.",
                                "Criptografia: Importância de entropia verdadeira em segurança.",
                                "Física: Fontes quânticas de aleatoriedade.",
                                "Engenharia de Software: Reprodutibilidade em testes e simulações."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para análise de estruturas civis sob cargas aleatórias, MCL permite reprodutibilidade para validação de resultados, evitando variações indesejadas de verdadeiros aleatórios, otimizando tempo computacional em projetos de engenharia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.4.2",
                        "name": "Parâmetros do Método Congruencial Linear",
                        "description": "Análise detalhada dos parâmetros módulo, multiplicador e incremento, incluindo critérios de escolha para maximizar o período da sequência.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.4.2.1",
                            "name": "Descrever o papel do módulo (m)",
                            "description": "Explicar que m deve ser um grande primo ou potência de 2 para maximizar o período, tipicamente 2^31 - 1 ou similar, evitando ciclos curtos na geração pseudo-aleatória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Método Congruencial Linear (MCL) e o Papel Inicial de m",
                                  "subSteps": [
                                    "Revise a fórmula do MCL: X_{n+1} = (a * X_n + c) mod m.",
                                    "Identifique m como o módulo que limita o range dos números gerados (0 a m-1).",
                                    "Explique que m define o espaço de estados possível para a sequência pseudo-aleatória.",
                                    "Discuta como a operação 'mod m' garante que os valores fiquem dentro do intervalo.",
                                    "Anote exemplos simples de m pequeno (ex: m=10) e observe os valores gerados."
                                  ],
                                  "verification": "Escreva uma definição de m em suas próprias palavras e liste 3 funções básicas dele no MCL.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação do MCL (Wikipedia ou notas de aula)",
                                    "Calculadora ou papel para simulações manuais"
                                  ],
                                  "tips": "Comece com m pequeno para visualizar o ciclo completo antes de escalar.",
                                  "learningObjective": "Entender m como delimitador do espaço de números pseudo-aleatórios no MCL.",
                                  "commonMistakes": [
                                    "Confundir m com o multiplicador a",
                                    "Ignorar que m afeta todos os parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Impacto de m no Período da Sequência Pseudo-Aleatória",
                                  "subSteps": [
                                    "Defina 'período' como o comprimento antes da repetição da sequência.",
                                    "Simule sequências com m pequeno (ex: m=5) e observe ciclos curtos.",
                                    "Compare com m maior (ex: m=16=2^4) e note diferença no período máximo possível (m).",
                                    "Aprenda que o período ótimo é m se condições de Hull-Dobell forem atendidas.",
                                    "Calcule períodos para diferentes m usando ferramentas online ou código simples."
                                  ],
                                  "verification": "Gere uma sequência com m=10 e identifique o período; repita com m=17 (primo).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou Excel para simulações",
                                    "Tabela de números primos até 100"
                                  ],
                                  "tips": "Registre sequências em uma tabela para visualizar repetições visualmente.",
                                  "learningObjective": "Reconhecer como m pequeno causa ciclos curtos, comprometendo a aleatoriedade.",
                                  "commonMistakes": [
                                    "Assumir período sempre = m sem condições adequadas",
                                    "Não testar múltiplas sementes X0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Critérios Ótimos para Escolha de m",
                                  "subSteps": [
                                    "Liste critérios: m primo grande ou potência de 2 para maximizar período.",
                                    "Explique por que primos evitam divisores comuns com a e c.",
                                    "Discuta exemplos: m=2^31 -1 (Mersenne prime) ou 2^32 para compatibilidade computacional.",
                                    "Compare prós/contras: potências de 2 rápidas em hardware, primos melhor distribuição.",
                                    "Pesquise referências como Knuth 'The Art of Computer Programming' para validação."
                                  ],
                                  "verification": "Classifique 5 valores de m (primo, potência 2, composto) e justifique adequação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de primos grandes (online)",
                                    "Livro ou PDF de Knuth Vol.2"
                                  ],
                                  "tips": "Use 2^31-1=2147483647 como benchmark padrão em simulações.",
                                  "learningObjective": "Selecionar m ideal baseado em maximização de período e eficiência.",
                                  "commonMistakes": [
                                    "Escolher m par não-potência de 2",
                                    "Usar m muito pequeno para testes reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar o Papel de m em Contextos Práticos",
                                  "subSteps": [
                                    "Implemente MCL em código com diferentes m e meça períodos.",
                                    "Teste com m ótimo vs. ruim em uma simulação simples (ex: gerar 1000 números).",
                                    "Analise distribuição (histograma) para checar uniformidade.",
                                    "Documente impactos: ciclos curtos levam a amostras enviesadas.",
                                    "Redija uma explicação completa do papel de m para um relatório."
                                  ],
                                  "verification": "Execute código e produza gráfico mostrando período e distribuição para 2 m's.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use seed fixa para reprodutibilidade e compare estatísticas descritivas.",
                                  "learningObjective": "Descrever integralmente o papel de m com evidências empíricas.",
                                  "commonMistakes": [
                                    "Não normalizar saídas para [0,1]",
                                    "Ignorar overflow em linguagens de 32-bit"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para estimar a probabilidade de falha em uma viga de concreto sob cargas aleatórias, configure o MCL com m=2^31-1, a=1664525, c=1013904223 e X0=1. Gere 1 milhão de amostras uniformes; o grande m garante período >10^6, evitando repetições que superestimariam riscos.",
                              "finalVerifications": [
                                "Explica corretamente a fórmula MCL destacando mod m.",
                                "Identifica que período máx = m sob condições ideais.",
                                "Recomenda m primo ou 2^k com justificativa.",
                                "Distingue impactos de m ruim (ciclos curtos) vs. bom.",
                                "Fornece exemplo numérico de sequência com período.",
                                "Liga m a qualidade pseudo-aleatória em simulações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do papel de m (10/10).",
                                "Profundidade na explicação de período e ciclos (9/10).",
                                "Correta identificação de m ótimos com exemplos (9/10).",
                                "Uso de evidências/simulações para suporte (8/10).",
                                "Clareza e estrutura na comunicação (8/10).",
                                "Conexão com aplicações em Monte Carlo (7/10)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primos, congruências).",
                                "Programação: Implementação de algoritmos numéricos.",
                                "Estatística: Geração de variáveis aleatórias uniformes.",
                                "Engenharia Civil: Simulações estocásticas em estruturas."
                              ],
                              "realWorldApplication": "Na engenharia civil, métodos como MCL com m adequado (ex: 2^31-1) são usados em simulações Monte Carlo para modelar incertezas em cargas sísmicas ou materiais, garantindo previsões confiáveis de segurança estrutural sem artefatos de ciclos curtos que invalidariam análises de risco."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.8.4.2.2",
                            "name": "Explicar a escolha do multiplicador (a)",
                            "description": "Detalhar que a deve satisfazer condições como a-1 divisível por todos os fatores primos de m e a ≡ 1 mod 4 para m=2^k, garantindo período completo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel do multiplicador 'a' no Método Congruencial Linear (MCL)",
                                  "subSteps": [
                                    "Definir o MCL: X_{n+1} = (a * X_n + c) mod m.",
                                    "Explicar que 'a' influencia o período da sequência pseudoaleatória.",
                                    "Introduzir o conceito de período completo: gerar m valores distintos antes de repetir.",
                                    "Discutir por que um bom 'a' é crucial para uniformidade e independência.",
                                    "Revisar teorema de Hull-Dobell para condições de período completo."
                                  ],
                                  "verification": "O aluno pode descrever verbalmente ou por escrito o impacto de 'a' no período do MCL.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Teorema de Hull-Dobell (documento PDF ou wiki)",
                                    "Exemplo de código Python para MCL"
                                  ],
                                  "tips": "Comece com um exemplo simples com m pequeno para visualizar sequências.",
                                  "learningObjective": "Entender o papel fundamental de 'a' na qualidade da geração pseudoaleatória.",
                                  "commonMistakes": "Confundir 'a' com 'c' ou ignorar dependência em 'm'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar as condições gerais para período completo envolvendo 'a'",
                                  "subSteps": [
                                    "Condição 1: a ≡ 1 (mod p) para todo primo p que divide m (ou seja, p divide a-1).",
                                    "Explicar que isso garante que a sequência cubra todos os resíduos mod p.",
                                    "Discutir necessidade de gcd(c, m) = 1 (complementar a 'a').",
                                    "Verificar com fatoração de m para identificar primos.",
                                    "Testar condição em exemplo: para m=15 (3*5), a-1 deve ser divisível por 3 e 5."
                                  ],
                                  "verification": "Listar corretamente as condições gerais e aplicar a um m dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python para fatoração",
                                    "Tabela de primos até 100"
                                  ],
                                  "tips": "Fatore m primeiro: use trial division ou sympy.factorint().",
                                  "learningObjective": "Identificar e justificar as condições gerais sobre 'a' para período completo.",
                                  "commonMistakes": "Esquecer que a-1 deve ser divisível pelos primos, não por m inteiro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar condições específicas para m = 2^k e outros casos especiais",
                                  "subSteps": [
                                    "Para m = 2^k (k ≥ 2): a ≡ 1 (mod 4) se k ≥ 3.",
                                    "Explicar por que mod 4: garante ciclo completo em potências de 2.",
                                    "Para m = p^k (p primo ímpar): a ≡ 1 (mod p).",
                                    "Casos mistos: combinar condições para todos fatores primos.",
                                    "Verificar: para m=16=2^4, a=5 (5≡1 mod 4, 4|4)."
                                  ],
                                  "verification": "Escolher 'a' válido para m=2^5=32 e justificar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para cálculos modulares",
                                    "Código Python para testar período"
                                  ],
                                  "tips": "Use propriedades modulares: a mod 4 =1 implica a=4k+1.",
                                  "learningObjective": "Dominar condições especiais para diferentes formas de m.",
                                  "commonMistakes": "Aplicar a≡1 mod 4 só para k=1 ou 2, onde não é necessário."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar escolha de 'a' e validar com simulações",
                                  "subSteps": [
                                    "Selecionar 'a' candidatos: primos como 1664525 para m=2^32.",
                                    "Implementar MCL em código e medir período.",
                                    "Comparar 'a' bom vs ruim: plotar sequências e histogramas.",
                                    "Analisar trade-offs: 'a' grande para avalanche effect.",
                                    "Documentar escolha justificando condições."
                                  ],
                                  "verification": "Gerar sequência com período completo e comprovar com código.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com numpy/matplotlib",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Teste seed=0 e verifique se todos 0 a m-1 aparecem exatamente uma vez.",
                                  "learningObjective": "Aplicar critérios para escolher e validar 'a' na prática.",
                                  "commonMistakes": "Não testar período real, só condições teóricas."
                                }
                              ],
                              "practicalExample": "Para m=16 (2^4) em simulação Monte Carlo de falhas estruturais: escolha a=5. Verificação: 5≡1 mod 4 (5-1=4 divisível por 4), gcd(c=1,16)=1. Sequência com seed=1: 6,3,15,11,9,13,14,10,2,1,7,4,0,8,12,5 (período 16 completo).",
                              "finalVerifications": [
                                "Explicar verbalmente as condições para período completo.",
                                "Escolher 'a' correto para m=100 (2^2*5^2).",
                                "Identificar erro em a=3 para m=16 (3≢1 mod 4).",
                                "Simular MCL e confirmar período m.",
                                "Justificar por que a≡1 mod p cobre resíduos.",
                                "Comparar períodos com a bom/ruim."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas condições de Hull-Dobell (100%).",
                                "Correta aplicação a casos especiais (m=2^k).",
                                "Validação prática via simulação (período verificado).",
                                "Justificativa clara e matemática.",
                                "Identificação de erros comuns em escolhas de 'a'.",
                                "Conexão com qualidade pseudoaleatória."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Números: Congruências e fatoração.",
                                "Programação: Implementação de geradores RNG em Python/R.",
                                "Estatística: Testes de uniformidade (Chi-quadrado).",
                                "Engenharia Civil: Monte Carlo para análise de risco estrutural.",
                                "Criptografia: Geradores seguros baseados em LCG modificado."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para previsão de falhas em estruturas civis (ex: pontes sob cargas aleatórias), um 'a' bem escolhido garante amostras uniformes, evitando viés em estimativas de probabilidade de colapso, otimizando projetos seguros e econômicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.8.4.2.3",
                            "name": "Analisar o impacto do incremento (c)",
                            "description": "Compreender que c=0 gera MCL multiplicativo (melhor para alguns casos), mas c>0 (ímpar e coprimo com m) melhora uniformidade; c=1 é comum.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel do incremento (c) na fórmula do Método Congruencial Linear (MCL)",
                                  "subSteps": [
                                    "Revise a fórmula do MCL: X_{n+1} = (a * X_n + c) mod m",
                                    "Identifique c como o termo de incremento aditivo",
                                    "Explique como c afeta a sequência quando X_0 = 0",
                                    "Discuta o impacto inicial de c na primeira iteração",
                                    "Compare verbalmente com o caso sem c (c=0)"
                                  ],
                                  "verification": "Escreva uma explicação de 100 palavras sobre o papel de c e recite a fórmula corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Referência à fórmula MCL"
                                  ],
                                  "tips": "Visualize c como um 'empurrão' constante na sequência para evitar padrões ruins.",
                                  "learningObjective": "Entender conceitualmente o incremento c como modificador aditivo na geração de números pseudoaleatórios.",
                                  "commonMistakes": [
                                    "Confundir c com o multiplicador a",
                                    "Ignorar o módulo m no impacto de c"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o caso especial c=0 (MCL Multiplicativo)",
                                  "subSteps": [
                                    "Implemente MCL com c=0 em Python ou calculadora",
                                    "Gere uma sequência longa (ex: 1000 números) com sementes variadas",
                                    "Observe o período e padrões (ex: se X_0=0, sequência fica zero)",
                                    "Plote histograma para verificar distribuição",
                                    "Registre métrias como autocorrelação"
                                  ],
                                  "verification": "Gere e plote histograma mostrando falta de uniformidade em certos casos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com numpy/matplotlib ou Excel",
                                    "Código template MCL"
                                  ],
                                  "tips": "Use semente X_0 ≠ 0 para ver comportamento multiplicativo puro.",
                                  "learningObjective": "Identificar limitações do MCL multiplicativo, como dependência da semente e menor uniformidade.",
                                  "commonMistakes": [
                                    "Usar semente zero sem notar colapso",
                                    "Sequências curtas que mascaram problemas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar impactos de c>0 com condições ótimas (ímpar e coprimo com m)",
                                  "subSteps": [
                                    "Escolha m grande (ex: 2^31-1), c=1 (ímpar, coprimo)",
                                    "Teste c ímpar vs par, e coprimo vs não coprimo com m",
                                    "Gere sequências e compare histogramas com c=0",
                                    "Meça uniformidade via teste qui-quadrado simples",
                                    "Teste c=1 especificamente e note melhorias"
                                  ],
                                  "verification": "Compare histogramas lado a lado mostrando maior uniformidade com c>0 ótimo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "Biblioteca scipy para testes estatísticos"
                                  ],
                                  "tips": "Verifique gcd(c, m)=1 com função math.gcd() para coprimalidade.",
                                  "learningObjective": "Compreender como c>0, especialmente ímpar e coprimo, melhora uniformidade e período.",
                                  "commonMistakes": [
                                    "Escolher c par levando a subperíodos",
                                    "Não testar múltiplas sementes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar impactos e sintetizar conclusões sobre escolha de c",
                                  "subSteps": [
                                    "Compile resultados de c=0 vs c=1 vs c inválido em tabela",
                                    "Analise trade-offs: simplicidade (c=0) vs uniformidade (c>0)",
                                    "Simule aplicação em Monte Carlo (ex: 1000 amostras para integral)",
                                    "Discuta quando usar cada caso",
                                    "Escreva relatório resumido"
                                  ],
                                  "verification": "Crie tabela comparativa com métricas de uniformidade e erro em simulação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela",
                                    "Resultados anteriores"
                                  ],
                                  "tips": "Priorize c=1 para casos gerais por simplicidade e bom desempenho.",
                                  "learningObjective": "Sintetizar análise para recomendar c baseado em contexto.",
                                  "commonMistakes": [
                                    "Generalizar de poucos testes",
                                    "Ignorar impacto no período total"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para estimar a probabilidade de falha em uma viga de concreto, gere 10.000 números pseudoaleatórios com MCL: use c=0 (multiplicativo) e observe viés em regiões baixas; mude para c=1 (coprimo com m=2^31-1) e veja estimativa convergir mais uniformemente para o valor real (ex: de 0.15 para 0.12 verdadeiro).",
                              "finalVerifications": [
                                "Explicar verbalmente por que c=0 falha com X_0=0",
                                "Demonstrar histograma uniforme com c=1 vs não-uniforme com c=0",
                                "Identificar condições: c ímpar e gcd(c,m)=1",
                                "Comparar erro em simulação Monte Carlo com diferentes c",
                                "Recomendar c=1 para aplicações gerais em Engenharia Civil"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de limitações de c=0 (peso 20%)",
                                "Correta aplicação de condições ótimas para c>0 (peso 25%)",
                                "Qualidade de visualizações e métricas de uniformidade (peso 25%)",
                                "Análise comparativa clara e fundamentada (peso 20%)",
                                "Síntese prática para Monte Carlo (peso 10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de uniformidade (qui-quadrado, Kolmogorov-Smirnov)",
                                "Programação: Implementação numérica e visualização de dados",
                                "Matemática: Teoria dos números (coprimalidade, módulo)",
                                "Engenharia Civil: Simulações estocásticas em análise de estruturas"
                              ],
                              "realWorldApplication": "Na análise de confiabilidade de barragens via Monte Carlo, escolher c>0 ótimo no MCL garante amostras uniformes para modelar cargas aleatórias, evitando subestimação de riscos e otimizando designs seguros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.4.3",
                        "name": "Implementação e Avaliação do MCL",
                        "description": "Passos para codificar o algoritmo, gerar sequências normalizadas e avaliar propriedades como período e uniformidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.4.3.1",
                            "name": "Implementar a iteração do MCL em pseudocódigo",
                            "description": "Escrever o loop recursivo X = (a * X + c) % m, iniciando com X0, e normalizar para [0,1] via U = X / m.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir parâmetros e compreender a fórmula do MCL",
                                  "subSteps": [
                                    "Identifique os parâmetros necessários: semente X0, multiplicador a, incremento c e módulo m.",
                                    "Revise a fórmula recursiva: X_{n+1} = (a * X_n + c) % m.",
                                    "Entenda a normalização: U_n = X_n / m para obter valores em [0,1].",
                                    "Escolha valores de exemplo para teste: a=5, c=3, m=16, X0=0.",
                                    "Anote restrições: 0 < a < m, 0 ≤ c < m, m > 0, X0 entre 0 e m-1."
                                  ],
                                  "verification": "Lista de parâmetros anotada corretamente com valores de exemplo e fórmula escrita.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples",
                                  "tips": "Use valores pequenos para m inicialmente para facilitar cálculos manuais.",
                                  "learningObjective": "Compreender os componentes fundamentais do Método Congruencial Linear (MCL).",
                                  "commonMistakes": "Confundir a ordem dos parâmetros ou esquecer o operador módulo %."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a inicialização no pseudocódigo",
                                  "subSteps": [
                                    "Inicie o pseudocódigo com declaração de variáveis: X, U, n (contador).",
                                    "Defina X = X0 (semente inicial).",
                                    "Especifique o número de iterações desejadas, ex: N = 10.",
                                    "Inclua cabeçalho: 'Pseudocódigo para Iteração MCL'.",
                                    "Adicione comentários explicando cada linha inicial."
                                  ],
                                  "verification": "Pseudocódigo inicia com variáveis declaradas e X = X0 corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto ou bloco de notas",
                                  "tips": "Use convenções claras como 'INÍCIO' e 'FIM' para delimitar o algoritmo.",
                                  "learningObjective": "Configurar corretamente a semente e variáveis iniciais no pseudocódigo.",
                                  "commonMistakes": "Esquecer de declarar o contador de iterações ou inicializar X incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever o loop recursivo e normalização",
                                  "subSteps": [
                                    "Crie um loop 'ENQUANTO n < N' ou 'REPETIR N vezes'.",
                                    "Dentro do loop: calcule novo_X = (a * X + c) % m.",
                                    "Atualize X = novo_X.",
                                    "Normalize: U = X / m.",
                                    "Armazene ou imprima U (ex: 'IMPRIMIR U').",
                                    "Incremente n = n + 1."
                                  ],
                                  "verification": "Loop gera sequência de X e U corretamente ao simular manualmente 3 iterações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto e calculadora para verificação manual",
                                  "tips": "Teste o loop com exemplo: iteração 1 deve dar X1=3, U1=0.1875.",
                                  "learningObjective": "Implementar a recursão e normalização em estrutura de loop pseudocódigo.",
                                  "commonMistakes": "Usar divisão inteira em vez de real para normalização ou esquecer o módulo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar, testar e documentar o pseudocódigo",
                                  "subSteps": [
                                    "Adicione saída final: 'FIM'.",
                                    "Simule 5 iterações manualmente e compare com pseudocódigo.",
                                    "Inclua comentários em cada linha crítica.",
                                    "Verifique se produz números pseudoaleatórios em [0,1].",
                                    "Otimize para clareza: use indentação e nomes descritivos."
                                  ],
                                  "verification": "Simulação manual coincide com execução lógica do pseudocódigo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto e papel para simulação",
                                  "tips": "Imprima a sequência gerada para visualização rápida.",
                                  "learningObjective": "Validar e documentar o pseudocódigo completo para reutilização.",
                                  "commonMistakes": "Não testar com múltiplas iterações ou deixar comentários vagos."
                                }
                              ],
                              "practicalExample": "Com a=5, c=3, m=16, X0=0, N=5: Sequência X: 0,3,18%16=2,13,68%16=4; U: 0,0.1875,0.125,0.8125,0.25. Pseudocódigo gera exatamente isso.",
                              "finalVerifications": [
                                "Pseudocódigo inicia com X = X0 e termina após N iterações.",
                                "Cada iteração aplica corretamente X = (a*X + c) % m.",
                                "Normalização U = X / m produz valores em [0,1].",
                                "Simulação manual de 5 iterações coincide com lógica.",
                                "Código é legível com comentários e indentação.",
                                "Não há erros de overflow ou divisão por zero."
                              ],
                              "assessmentCriteria": [
                                "Correção da fórmula recursiva e normalização (40%).",
                                "Estrutura clara de loop e inicialização (20%).",
                                "Comentários detalhados e indentação (15%).",
                                "Teste com exemplo numérico incluído (15%).",
                                "Ausência de erros comuns como falta de módulo (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Geração de amostras aleatórias para simulações.",
                                "Programação: Estruturas de controle (loops) em pseudocódigo.",
                                "Engenharia Civil: Aplicação em Monte Carlo para análise de riscos estruturais.",
                                "Matemática: Operações modulares e aritmética modular."
                              ],
                              "realWorldApplication": "Em engenharia civil, o MCL gera números pseudoaleatórios para simulações Monte Carlo, avaliando probabilidades de falha em estruturas sob cargas variáveis, otimizando projetos de pontes e edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.8.4.3.2",
                            "name": "Gerar e visualizar uma sequência pseudo-aleatória",
                            "description": "Produzir uma sequência de N números U_i e plotar histograma para verificar uniformidade, usando ferramentas como MATLAB ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e validar parâmetros do Método Congruencial Linear (MCL)",
                                  "subSteps": [
                                    "Escolha o módulo m como um grande primo ou potência de 2 (ex: m = 2^31 - 1).",
                                    "Selecione multiplicador a com propriedades específicas (ex: a = 1103515245 para bom período).",
                                    "Defina incremento c > 0 e não múltiplo de m (ex: c = 12345).",
                                    "Escolha semente X0 inicial entre 0 e m-1 (ex: X0 = 1).",
                                    "Verifique condições de Hull-Dobell para período máximo."
                                  ],
                                  "verification": "Liste os parâmetros escolhidos e confirme que atendem critérios matemáticos básicos (período m se c≠0 e condições ok).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de MCL (Wikipedia ou livro de simulação), calculadora ou Python para testes rápidos.",
                                  "tips": "Use parâmetros testados da literatura para evitar erros iniciais; priorize m grande para melhor aleatoriedade.",
                                  "learningObjective": "Compreender como parâmetros afetam qualidade da sequência pseudo-aleatória.",
                                  "commonMistakes": "Escolher a=1 (sequência constante), c=0 sem condições (período curto), m pequeno (padrões repetitivos)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração da sequência X_i usando MCL em Python",
                                  "subSteps": [
                                    "Instale bibliotecas: import numpy as np e matplotlib.pyplot as plt.",
                                    "Defina função geradora: def mcl(seed, a, c, m, n): com loop for i in range(n): X_next = (a * X + c) % m; X = X_next; yield X.",
                                    "Gere lista de N=10000 valores X_i iniciando com X = seed.",
                                    "Teste com N pequeno (ex: 10) e imprima para depuração.",
                                    "Armazene em array numpy para eficiência."
                                  ],
                                  "verification": "Execute print(X[:10]) e confirme que sequência é gerada corretamente sem overflow ou padrões óbvios.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python 3+, Jupyter Notebook ou IDE (VS Code/PyCharm), bibliotecas numpy e matplotlib.",
                                  "tips": "Use int64 para m grande; evite float para evitar precisão perdida.",
                                  "learningObjective": "Implementar iterativamente o MCL para produzir sequência bruta X_i.",
                                  "commonMistakes": "Overflow em multiplicação (use % m após cada operação), esquecer de atualizar X, loop infinito."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Normalizar para U_i e preparar dados para visualização",
                                  "subSteps": [
                                    "Converta X_i para U_i = X_i / m para obter valores em [0,1).",
                                    "Gere array U = np.array(X) / m com N=10000 elementos.",
                                    "Verifique estatísticas básicas: np.mean(U) ≈ 0.5, np.std(U) ≈ 1/sqrt(12).",
                                    "Divida em bins para histograma (ex: 50 bins).",
                                    "Salve U em variável para plotting."
                                  ],
                                  "verification": "Execute print(np.mean(U), np.std(U)) e confirme valores próximos a 0.5 e 0.2887.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmos do step anterior, numpy para operações vetoriais.",
                                  "tips": "Use np.histogram para pré-visualização rápida antes de plotar.",
                                  "learningObjective": "Transformar sequência inteira em uniformes [0,1) e validar propriedades estatísticas iniciais.",
                                  "commonMistakes": "Dividir por (m-1) em vez de m, usar float prematuro causando bias, N muito pequeno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar histograma e avaliar uniformidade",
                                  "subSteps": [
                                    "Crie histograma: plt.hist(U, bins=50, density=True, alpha=0.7).",
                                    "Adicione linha de referência: x = np.linspace(0,1,100); plt.plot(x, np.ones(100), 'r--').",
                                    "Ajuste rótulos: plt.xlabel('U_i'), plt.ylabel('Densidade'), plt.title('Histograma de Uniformidade').",
                                    "Exiba e salve: plt.show(); plt.savefig('histograma_mcl.png').",
                                    "Analise visualmente: procure platô uniforme sem picos/vales."
                                  ],
                                  "verification": "Histograma mostra distribuição plana próxima à linha vermelha; sem clusters ou gaps.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matplotlib instalado, Jupyter para visualização interativa.",
                                  "tips": "Aumente bins para N grande; use density=True para comparar com uniforme teórica.",
                                  "learningObjective": "Visualizar e interpretar histograma para validar uniformidade pseudo-aleatória.",
                                  "commonMistakes": "Bins inadequados (muito poucos/muitos), esquecer density=True (eixo y errado), escala errada."
                                }
                              ],
                              "practicalExample": "Usando Python em Jupyter: def mcl(seed=1, a=1103515245, c=12345, m=2**31-1, n=10000): X = seed; seq = []; for _ in range(n): X = (a * X + c) % m; seq.append(X / m); return np.array(seq). U = mcl(); plt.hist(U, bins=50, density=True); plt.plot(np.linspace(0,1,100), np.ones(100), 'r--'); plt.show(). O histograma deve ser uniforme.",
                              "finalVerifications": [
                                "Sequência U_i gerada com N=10000 elementos em [0,1).",
                                "Média ≈0.5 e desvio padrão ≈0.2887.",
                                "Histograma exibe platô uniforme com 50 bins.",
                                "Nenhum padrão cíclico ou cluster visível.",
                                "Código reproduzível e salvo como imagem.",
                                "Estatísticas estatísticas (chi-quadrado opcional) indicam uniformidade."
                              ],
                              "assessmentCriteria": [
                                "Parâmetros MCL corretos e justificados.",
                                "Implementação do loop MCL sem erros numéricos.",
                                "Normalização precisa para U_i em [0,1).",
                                "Histograma plotted com bins adequados e linha de referência.",
                                "Análise qualitativa da uniformidade fornecida.",
                                "Código limpo, comentado e executável."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Testes de uniformidade (qui-quadrado).",
                                "Programação Computacional: Loops, funções e visualização de dados.",
                                "Engenharia Civil: Simulações Monte Carlo para análise de riscos estruturais.",
                                "Matemática Discreta: Aritmética modular e propriedades de períodos."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, gera números pseudo-aleatórios para simulações Monte Carlo, modelando cargas aleatórias em pontes ou edifícios, prevendo probabilidades de falha sob ventos variáveis ou tráfego imprevisível."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.8.4.3.3",
                            "name": "Calcular o período da sequência",
                            "description": "Determinar o comprimento máximo antes da repetição, verificando condições de Hull-Dobell para período m quando c>0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar parâmetros do Método Congruencial Linear (MCL) e preparar estruturas de rastreamento",
                                  "subSteps": [
                                    "Obtenha ou defina os parâmetros: semente X₀, multiplicador a, incremento c (>0), módulo m.",
                                    "Verifique pré-condições: c > 0 e todos parâmetros inteiros positivos com 0 ≤ X₀ < m.",
                                    "Inicialize um dicionário (ou mapa) para rastrear o índice de cada valor X_i gerado.",
                                    "Inicialize uma lista para armazenar a sequência de X_i.",
                                    "Defina X_current = X₀ e index = 0."
                                  ],
                                  "verification": "Parâmetros válidos configurados e estruturas vazias prontas sem erros de inicialização.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou interpretador Python/Jupyter Notebook",
                                    "Papel e caneta para anotações manuais",
                                    "Documentação do teorema de Hull-Dobell"
                                  ],
                                  "tips": [
                                    "Escolha m não muito grande (ex: <1000) para simulação manual eficiente.",
                                    "Use tipos de dados inteiros para evitar erros de precisão.",
                                    "Salve os parâmetros em variáveis nomeadas claramente."
                                  ],
                                  "learningObjective": "Preparar uma simulação robusta para geração de sequência MCL com rastreamento eficiente.",
                                  "commonMistakes": [
                                    "Esquecer de verificar 0 ≤ X₀ < m.",
                                    "Usar float em vez de int para cálculos modulares.",
                                    "Não inicializar index em 0."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar a sequência até detectar a primeira repetição",
                                  "subSteps": [
                                    "Inicie um loop: compute X_next = (a * X_current + c) % m.",
                                    "Verifique se X_next já existe no dicionário de vistos; se sim, anote o índice repetido e pare.",
                                    "Caso contrário, adicione X_next ao dicionário com o índice atual e à lista da sequência.",
                                    "Atualize X_current = X_next e incremente index.",
                                    "Continue até detectar repetição ou limite máximo (ex: 2*m iterações para segurança)."
                                  ],
                                  "verification": "Sequência gerada com pelo menos m termos ou até repetição detectada, sem overflow ou loops infinitos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Interpretador de programação (Python recomendado)",
                                    "Planilha para tracking manual se m pequeno"
                                  ],
                                  "tips": [
                                    "Implemente o loop em código para automação: use dict.get(X_next, -1) != -1 para check.",
                                    "Registre a sequência em uma lista para visualização posterior.",
                                    "Defina um safeguard contra períodos longos com max_iter."
                                  ],
                                  "learningObjective": "Implementar geração eficiente de sequência pseudo-aleatória com detecção de ciclo.",
                                  "commonMistakes": [
                                    "Erro no cálculo modular: esquecer % m após multiplicação.",
                                    "Não detectar repetição corretamente devido a chaves erradas no dict.",
                                    "Loop infinito por falta de limite máximo."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o comprimento do período a partir da repetição detectada",
                                  "subSteps": [
                                    "Identifique o valor repetido X_rep e seu índice original index_rep do dicionário.",
                                    "O período τ é calculado como index_atual - index_rep.",
                                    "O pré-período (opcional) é index_rep se X_rep == X₀, senão analise transient.",
                                    "Confirme gerando mais termos para verificar se o ciclo se repete consistentemente.",
                                    "Registre o período máximo antes da repetição completa."
                                  ],
                                  "verification": "Período τ computado numericamente e sequência valida o ciclo (ex: X_{n+τ} == X_n para n >= index_rep).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código Python com print da sequência",
                                    "Gráfico ou tabela da sequência para visualização"
                                  ],
                                  "tips": [
                                    "Para MCL com c>0, o ciclo geralmente começa cedo; foque no primeiro repeat de qualquer X.",
                                    "Teste com sequência conhecida: valide τ == m se condições atendidas.",
                                    "Use assert para automação de verificação."
                                  ],
                                  "learningObjective": "Determinar precisamente o tamanho do ciclo na sequência gerada pelo MCL.",
                                  "commonMistakes": [
                                    "Confundir período com pré-período.",
                                    "Calcular τ errado: usar index errado para repeat.",
                                    "Ignorar que repeat pode não ser do X₀."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar condições do teorema de Hull-Dobell e validar o período",
                                  "subSteps": [
                                    "Verifique gcd(c, m) == 1.",
                                    "Para cada primo p dividindo m, cheque se a ≡ 1 (mod p).",
                                    "Se 4 divide m, verifique a ≡ 1 (mod 4).",
                                    "Se todas condições atendidas, confirme se τ == m (período completo).",
                                    "Caso contrário, documente por que o período é menor e compare com simulação."
                                  ],
                                  "verification": "Condições de Hull-Dobell avaliadas corretamente; τ matches expectativa teórica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Função gcd em Python (math.gcd)",
                                    "Lista de fatores primos de m (use fatoração)",
                                    "Referência do teorema de Hull-Dobell"
                                  ],
                                  "tips": [
                                    "Fatore m primeiro para prazos p. Ex: sympy.factorint(m).",
                                    "Se falha, τ divide m tipicamente.",
                                    "Automatize checks em funções separadas."
                                  ],
                                  "learningObjective": "Aplicar teoria dos números para prever e validar o período máximo teórico.",
                                  "commonMistakes": [
                                    "gcd(c,m) !=1 permite τ < m.",
                                    "Esquecer condição mod 4 para m múltiplo de 4.",
                                    "Não fatorar m corretamente para prazos p."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar resultados e avaliar qualidade do gerador",
                                  "subSteps": [
                                    "Registre parâmetros, sequência parcial, τ calculado e status Hull-Dobell.",
                                    "Compare τ com m e note implicações para aleatoriedade.",
                                    "Teste com variações de parâmetros para observar impactos.",
                                    "Gere relatório: 'Período = τ / m = fração'.",
                                    "Sugira otimizações para período completo."
                                  ],
                                  "verification": "Relatório completo com τ correto e análise coerente com teoria.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notebook Markdown ou documento",
                                    "Gráficos de sequência (plot index vs X_i)"
                                  ],
                                  "tips": [
                                    "Visualize ciclo com plot para intuição.",
                                    "Teste múltiplos X₀ para período invariante.",
                                    "Salve código reutilizável."
                                  ],
                                  "learningObjective": "Sintetizar simulação e teoria para avaliação crítica do MCL.",
                                  "commonMistakes": [
                                    "Não testar múltiplos seeds.",
                                    "Ignorar discrepâncias simulação vs teoria.",
                                    "Relatório incompleto sem fração τ/m."
                                  ]
                                }
                              ],
                              "practicalExample": "Para MCL com m=5, a=2, c=1, X₀=0: Sequência = [0, 1, 3, 2, 0, ...]. Repetição de 0 em index=4, index_rep=0 → τ=4. Hull-Dobell: gcd(1,5)=1, mas a=2 ≢1 mod5 → não full period (confirma τ=4<5).",
                              "finalVerifications": [
                                "Sequência cicla corretamente com período τ consistente em múltiplas runs.",
                                "Condições de Hull-Dobell checadas sem erros e alinhadas com τ.",
                                "Código/simulação executa sem erros para m até 10^4.",
                                "τ divide m quando aplicável.",
                                "Fração τ/m documentada e >0.8 para bons geradores.",
                                "Testes com X₀ diferentes dão mesmo τ."
                              ],
                              "assessmentCriteria": [
                                "Precisão: τ correto matches simulação e teoria (100%).",
                                "Eficiência: Simulação O(m) tempo, sem loops desnecessários.",
                                "Completude: Todos checks Hull-Dobell implementados.",
                                "Clareza: Código/relatório bem documentado com comentários.",
                                "Robustez: Lida com edge cases (m=1, c=0 inválido).",
                                "Análise: Explica por que τ < m se aplicável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números (gcd, congruências modulares).",
                                "Programação: Estruturas de dados (dict, lists), algoritmos de detecção de ciclo.",
                                "Estatística: Qualidade de geradores pseudo-aleatórios para Monte Carlo.",
                                "Engenharia Civil: Simulações probabilísticas em análise de estruturas.",
                                "Física: Modelagem estocástica em dinâmica de fluidos ou cargas aleatórias."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para engenharia civil, como estimar probabilidades de falha em estruturas sob cargas sísmicas aleatórias, onde um período longo garante uniformidade na amostragem pseudo-aleatória, evitando viés em análises de risco."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.4.2.2",
                              "10.1.8.4.2.3"
                            ]
                          },
                          {
                            "id": "10.1.8.4.3.4",
                            "name": "Aplicar MCL em simulação Monte Carlo simples",
                            "description": "Usar sequência gerada para estimar integral ou probabilidade em problema de engenharia civil, como análise de cargas aleatórias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema de engenharia civil e parâmetros do MCL",
                                  "subSteps": [
                                    "Identifique o problema: ex., estimar probabilidade de carga total em laje exceder 10 kN com 5 cargas U(0,3) kN cada.",
                                    "Escolha parâmetros MCL: módulo m (>10^6), semente X0, multiplicador a (coprime com m), incremento c (se misto).",
                                    "Defina tamanho da amostra N (ex., 10^4) para Monte Carlo.",
                                    "Escreva fórmula da simulação: X_total = sum(3 * U_i) onde U_i de MCL uniformizado.",
                                    "Planeje threshold e estimativa P = (número de falhas)/N."
                                  ],
                                  "verification": "Documentação clara do problema e parâmetros anotados no código ou notebook.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Jupyter Notebook ou editor Python, papel para rascunho.",
                                  "tips": "Use m=2^31-1 (Mersenne prime) para boa aleatoriedade.",
                                  "learningObjective": "Compreender como mapear problema real para simulação Monte Carlo com MCL.",
                                  "commonMistakes": "Escolher m pequeno levando a período curto; ignorar coprimaridade de a e m."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar gerador MCL e gerar sequência pseudo-aleatória",
                                  "subSteps": [
                                    "Codifique função MCL: X_{n+1} = (a*X_n + c) mod m.",
                                    "Normalize para U[0,1]: U_n = X_n / m.",
                                    "Gere lista ou array de N números U_i.",
                                    "Teste inicial: plote histograma para checar uniformidade.",
                                    "Salve sequência em variável para uso posterior."
                                  ],
                                  "verification": "Sequência gerada tem comprimento N e valores em [0,1); histograma uniforme.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy e Matplotlib.",
                                  "tips": "Use int64 para evitar overflow em Python.",
                                  "learningObjective": "Implementar corretamente MCL e validar saída básica.",
                                  "commonMistakes": "Esquecer mod m causando overflow; não normalizar para [0,1)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulação Monte Carlo usando a sequência MCL",
                                  "subSteps": [
                                    "Gere cargas: loads = [3 * U_i for i in range(5*N)] em blocos de 5.",
                                    "Para cada conjunto de 5 cargas, compute X_total = sum(loads[5*k:5*(k+1)]).",
                                    "Conte falhas: num_failures = sum(1 for total in totals if total > 10).",
                                    "Estime P = num_failures / N.",
                                    "Execute múltiplas runs para checar variância."
                                  ],
                                  "verification": "Código roda sem erros; P estimado é razoável (ex., ~0.01-0.1 dependendo params).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com NumPy para vetores eficientes.",
                                  "tips": "Vetorize com NumPy para velocidade: loads = 3 * U[:5*N].reshape(-1,5).sum(axis=1).",
                                  "learningObjective": "Aplicar números pseudo-aleatórios em loop de simulação Monte Carlo.",
                                  "commonMistakes": "Corrigir índices errados em reshape; usar N muito pequeno para precisão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e validar a simulação",
                                  "subSteps": [
                                    "Compute IC 95% para P: use desvio padrão de Bernoulli sqrt(P(1-P)/N).",
                                    "Compare com solução analítica: para 5 U(0,3), X~ Irwin-Hall escalado.",
                                    "Plote histograma de X_total e CDF empírica.",
                                    "Avalie qualidade MCL: teste chi-quadrado ou runs test simples.",
                                    "Documente conclusões e sugestões de melhoria."
                                  ],
                                  "verification": "IC contém valor teórico; plots mostram convergência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com SciPy para testes estatísticos, Matplotlib.",
                                  "tips": "Aumente N para 10^5 se necessário para precisão.",
                                  "learningObjective": "Interpretar resultados Monte Carlo e validar gerador.",
                                  "commonMistakes": "Ignorar variância alta; não comparar com analítico."
                                }
                              ],
                              "practicalExample": "Em uma laje de edifício, estimar P(carga total > 10 kN) com 5 cargas vivas independentes U(0,3) kN usando 10^4 amostras MCL (m=2147483647, a=16807, c=0, X0=1). Resultado: P≈0.032, validado vs. analítico.",
                              "finalVerifications": [
                                "Sequência MCL passa teste de uniformidade visual (histograma).",
                                "Estimativa P converge com N crescente (erro <5%).",
                                "Código reproduzível roda em <1 min para N=10^4.",
                                "Comparação com solução exata tem erro relativo <10%.",
                                "Relatório inclui plots e IC 95%.",
                                "Testes de aleatoriedade (chi2 p-value >0.05)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimativa (erro <10% vs. teórico).",
                                "Eficiência computacional (tempo razoável para N grande).",
                                "Qualidade do código (comentado, vetorizado, sem erros).",
                                "Validação completa (testes, plots, IC).",
                                "Conexão clara com problema de engenharia civil.",
                                "Documentação de parâmetros e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística (estimadores, IC).",
                                "Programação Computacional (NumPy, vetores).",
                                "Análise Estrutural (cargas aleatórias em estruturas).",
                                "Simulação Numérica (Monte Carlo em engenharia)."
                              ],
                              "realWorldApplication": "Na engenharia civil, aplica-se para análise de confiabilidade de pontes ou edifícios sob cargas variáveis como vento ou tráfego, estimando probabilidades de falha para dimensionamento seguro e econômico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.5",
                    "name": "Princípios do Método de Monte Carlo",
                    "description": "Uso de amostragem aleatória para estimar valores integrais e resolver problemas probabilísticos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.5.1",
                        "name": "Fundamentos da Amostragem Aleatória",
                        "description": "Compreensão dos princípios básicos de geração de números pseudo-aleatórios e sua importância para simulações estocásticas no método de Monte Carlo.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.5.1.1",
                            "name": "Identificar propriedades de números pseudo-aleatórios",
                            "description": "Reconhecer características como uniformidade, independência e período em geradores de números aleatórios lineares congruentes (LCR) e sua adequação para simulações Monte Carlo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Números Pseudo-Aleatórios e Geradores LCG",
                                  "subSteps": [
                                    "Defina números pseudo-aleatórios como sequências determinísticas que aparentam aleatoriedade.",
                                    "Explique a fórmula do gerador linear congruente (LCG): X_{n+1} = (a * X_n + c) mod m.",
                                    "Identifique os parâmetros chave: semente (X_0), multiplicador (a), incremento (c) e módulo (m).",
                                    "Gere uma sequência manual simples com parâmetros exemplo: m=10, a=3, c=1, X_0=0.",
                                    "Discuta por que pseudo-aleatórios são usados em vez de verdadeiramente aleatórios em computação."
                                  ],
                                  "verification": "Gere corretamente uma sequência de 10 números usando a fórmula LCG manualmente e explique cada parâmetro.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou planilha Excel",
                                    "Documentação sobre LCG (ex: Wikipedia ou livro de simulação)"
                                  ],
                                  "tips": "Comece com valores pequenos de m para visualizar padrões facilmente.",
                                  "learningObjective": "Entender a mecânica básica dos LCG e sua natureza determinística.",
                                  "commonMistakes": [
                                    "Confundir pseudo-aleatório com aleatório verdadeiro",
                                    "Erros de cálculo na fórmula modular"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Analisar Propriedades de Uniformidade e Independência",
                                  "subSteps": [
                                    "Defina uniformidade: distribuição aproximadamente igual em [0,1] após normalização.",
                                    "Gere 1000 números LCG em código (Python ou MATLAB) e plote histograma para checar uniformidade.",
                                    "Defina independência: ausência de correlação entre números consecutivos (teste de autocorrelação).",
                                    "Calcule coeficiente de correlação entre pares consecutivos e verifique se próximo de zero.",
                                    "Compare sequências com bons e maus parâmetros para observar diferenças."
                                  ],
                                  "verification": "Produza histogramas e gráficos de autocorrelação mostrando uniformidade e independência.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB",
                                    "Código exemplo de LCG"
                                  ],
                                  "tips": "Use normalização X/m para mapear para [0,1]; teste múltiplas sementes.",
                                  "learningObjective": "Reconhecer visual e estatisticamente uniformidade e independência em sequências LCG.",
                                  "commonMistakes": [
                                    "Ignorar normalização ao plotar",
                                    "Usar amostras muito pequenas para testes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Período e Sua Importância",
                                  "subSteps": [
                                    "Defina período como o comprimento antes da repetição da sequência.",
                                    "Calcule o período máximo de um LCG (m) e condições para atingi-lo (Hull-Dobell theorem).",
                                    "Gere sequências com parâmetros ruins (ex: a=1) e observe períodos curtos.",
                                    "Use código para detectar o período contando até repetição da semente.",
                                    "Discuta impacto de período curto: ciclos detectáveis em simulações longas."
                                  ],
                                  "verification": "Identifique e calcule períodos de pelo menos 3 sequências LCG diferentes.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python para detecção de período",
                                    "Tabela de parâmetros LCG bons (ex: m=2^31-1)"
                                  ],
                                  "tips": "Implemente um loop para contar iterações até X_n == X_0.",
                                  "learningObjective": "Medir e interpretar o período de LCGs.",
                                  "commonMistakes": [
                                    "Confundir período com ciclo completo sem teorema",
                                    "Overflow em cálculos modulares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Adequação para Simulações Monte Carlo",
                                  "subSteps": [
                                    "Revise Monte Carlo: usa amostras aleatórias para estimar integrais/probabilidades.",
                                    "Teste LCG em simulação simples: estimar π via pontos em círculo.",
                                    "Compare resultados com diferentes LCGs (bom vs ruim) e aleatoriedade verdadeira.",
                                    "Avalie falhas: viés por falta de uniformidade, padrões por baixa independência.",
                                    "Conclua critérios: bom LCG precisa período longo, uniformidade e independência."
                                  ],
                                  "verification": "Execute simulação Monte Carlo com LCG e discuta precisão vs amostras.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Código Python para Monte Carlo π",
                                    "Gerador random() nativo para comparação"
                                  ],
                                  "tips": "Aumente N amostras para ver efeitos de período curto.",
                                  "learningObjective": "Ligar propriedades LCG à performance em Monte Carlo.",
                                  "commonMistakes": [
                                    "Não comparar com benchmark",
                                    "Ignorar erros de precisão em N pequeno"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um LCG com m=100, a=23, c=47, X0=42. Gere 50 números, plote histograma (uniformidade), autocorrelação (independência) e detecte período. Use em Monte Carlo para estimar área sob y=sin(x), comparando com resultados conhecidos.",
                              "finalVerifications": [
                                "Gere e analise sequência LCG mostrando uniformidade via histograma.",
                                "Calcule e interprete autocorrelação para independência.",
                                "Determine período e verifique condições de maximalidade.",
                                "Aplique em Monte Carlo e identifique impactos de propriedades ruins.",
                                "Explique verbalmente por que certas propriedades são críticas para simulações.",
                                "Compare LCG com random() nativo em testes estatísticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração e cálculo de sequências LCG (90% correto).",
                                "Qualidade de visualizações (histogramas, autocorr) indicando compreensão.",
                                "Correta identificação de período e ligação com teoremas.",
                                "Análise qualitativa/quantitativa de adequação Monte Carlo.",
                                "Uso correto de testes estatísticos (ex: chi-quadrado para uniformidade).",
                                "Clareza em relatórios/explicações de propriedades."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses para uniformidade e independência.",
                                "Programação: Implementação de algoritmos iterativos e visualização de dados.",
                                "Engenharia Civil: Simulações Monte Carlo para análise de risco em estruturas.",
                                "Matemática: Teoria modular e teoremas número (Hull-Dobell).",
                                "Física: Modelagem estocástica em dinâmica de fluidos ou materiais."
                              ],
                              "realWorldApplication": "Em engenharia civil, números pseudo-aleatórios LCG com boas propriedades são usados em simulações Monte Carlo para prever falhas em barragens ou pontes sob cargas aleatórias (vento, tráfego), garantindo estimativas confiáveis de risco sem padrões detectáveis que invalidem resultados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.5.1.2",
                            "name": "Implementar gerador de números aleatórios simples",
                            "description": "Desenvolver código em linguagem de programação (ex: MATLAB ou Python) para gerar sequências uniformemente distribuídas no intervalo [0,1] usando método LCR.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os fundamentos do Gerador Linear Congruencial (LCG)",
                                  "subSteps": [
                                    "Pesquise a fórmula do LCG: X_{n+1} = (a * X_n + c) mod m, onde a é multiplicador, c incremento, m módulo, X_0 semente.",
                                    "Aprenda como normalizar para [0,1]: U_n = X_n / m.",
                                    "Identifique requisitos para boa uniformidade: m grande (potência de 2), a primitiva módulo m, c > 0.",
                                    "Estude propriedades: período máximo, independência estatística.",
                                    "Anote exemplos de parâmetros ruins vs. bons (ex: m=2^31, a=1664525, c=1013904223)."
                                  ],
                                  "verification": "Resuma em um parágrafo os componentes do LCG e dê um exemplo manual de 3 iterações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook para anotações, acesso à internet para documentação (Wikipedia ou livros de simulação).",
                                  "tips": "Use calculadora para simular iterações manuais e visualizar o ciclo.",
                                  "learningObjective": "Compreender a matemática por trás do LCG e seus parâmetros chave.",
                                  "commonMistakes": "Confundir normalização (dividir por m-1 em vez de m); ignorar overflow em implementações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar parâmetros e preparar ambiente de programação",
                                  "subSteps": [
                                    "Instale Python e bibliotecas: numpy, matplotlib via pip.",
                                    "Escolha parâmetros padrão: m=2**31, a=1664525, c=1013904223, X0=12345.",
                                    "Defina comprimento da sequência: N=10000.",
                                    "Crie um esboço do pseudocódigo: inicializar semente, loop para gerar X_n, normalizar U_n.",
                                    "Teste ambiente rodando um script simples de print('Hello World')."
                                  ],
                                  "verification": "Confirme instalação listando 'numpy' e 'matplotlib' no Python e anotando parâmetros escolhidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Computador com Python 3+, terminal ou Jupyter Notebook, editor como VS Code.",
                                  "tips": "Use Jupyter para interatividade; evite m muito pequeno para testes iniciais.",
                                  "learningObjective": "Preparar ferramentas e parâmetros otimizados para implementação robusta.",
                                  "commonMistakes": "Escolher parâmetros ruins levando a período curto; não usar int64 para evitar overflow."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o código do gerador LCG",
                                  "subSteps": [
                                    "Escreva função lcg(seed, a, c, m, n): liste U em array numpy.",
                                    "Implemente loop: for i in range(n): X = (a*X + c) % m; U.append(X/m).",
                                    "Adicione docstring explicando parâmetros e retorno.",
                                    "Salve como script .py e execute para gerar sequência.",
                                    "Armazene sequência em variável para próximos passos."
                                  ],
                                  "verification": "Execute o código e imprima primeiros 10 valores; confirme todos em [0,1).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código, Python com numpy.",
                                  "tips": "Use % para módulo em Python; vetorize se possível para eficiência.",
                                  "learningObjective": "Codificar corretamente o algoritmo LCG em Python.",
                                  "commonMistakes": "Erro de overflow (use int64 explicitamente); loop off-by-one no range(n)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, visualizar e validar a sequência gerada",
                                  "subSteps": [
                                    "Gere histograma: plt.hist(U, bins=50, density=True); plt.show().",
                                    "Calcule estatísticas: media = np.mean(U), variancia = np.var(U); compare com 0.5 e 1/12.",
                                    "Teste correlação serial: plote U[i] vs U[i+1].",
                                    "Rode teste chi-quadrado simples para uniformidade.",
                                    "Documente resultados em comentários no código."
                                  ],
                                  "verification": "Histograma uniforme, média ~0.5, sem padrões visíveis em scatter plot.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com matplotlib e numpy.",
                                  "tips": "Aumente bins para N grande; use seed fixa para reprodutibilidade.",
                                  "learningObjective": "Avaliar empiricamente a qualidade da amostragem uniforme.",
                                  "commonMistakes": "Ignorar normalização levando a valores >=1; bins inadequados distorcendo visualização."
                                }
                              ],
                              "practicalExample": "Implemente um LCG em Python com parâmetros m=2**31, a=1664525, c=1013904223, seed=42, N=10000. Gere U, plote histograma mostrando distribuição uniforme em [0,1], calcule média (deve ser ~0.5) e use em simulação Monte Carlo simples: estime pi jogando 'dardos' em círculo unitário.",
                              "finalVerifications": [
                                "Código gera sequência de N números em [0,1) sem erros de overflow.",
                                "Histograma visualmente uniforme com 50 bins.",
                                "Média da sequência entre 0.49 e 0.51.",
                                "Variância próxima de 1/12 (~0.0833).",
                                "Scatter plot U[i] vs U[i+1] sem correlação linear.",
                                "Teste chi-quadrado p-value >0.05 indicando uniformidade."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: fórmula LCG e normalização exatas.",
                                "Escolha de parâmetros: período longo e boas propriedades estatísticas.",
                                "Eficiência do código: loop otimizado, uso de numpy.",
                                "Visualizações claras: histograma e scatter plot informativos.",
                                "Validação quantitativa: estatísticas e testes estatísticos incluídos.",
                                "Documentação: comentários e docstrings completas."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: testes de uniformidade e propriedades esperadas.",
                                "Programação Computacional: implementação de algoritmos iterativos.",
                                "Engenharia Civil: geração de inputs aleatórios para simulações Monte Carlo em análise estrutural.",
                                "Matemática Numérica: análise de erros e precisão em aritmética modular."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, use LCG para simulações Monte Carlo em análise de risco de falha estrutural (ex: cargas de vento aleatórias), previsão de tráfego em pontes ou otimização de reservatórios hidráulicos sob incertezas probabilísticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.5.1.3",
                            "name": "Avaliar qualidade de sequências aleatórias",
                            "description": "Aplicar testes estatísticos básicos (teste de qui-quadrado, poker, corridas) para validar a aleatoriedade de uma sequência gerada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios dos testes de aleatoriedade",
                                  "subSteps": [
                                    "Estude o teste de Poker: analisa frequências de padrões em dígitos (pares, sequências, etc.) comparando com distribuição esperada.",
                                    "Revise o teste de Corridas (Runs Test): identifica sequências de aumentos/diminuições para detectar dependências.",
                                    "Aprenda o teste Qui-Quadrado: compara frequências observadas vs. esperadas em categorias de dígitos.",
                                    "Colete fórmulas e tabelas críticas para cada teste (graus de liberdade, valores p).",
                                    "Pratique com exemplos simples de sequências curtas."
                                  ],
                                  "verification": "Resuma em um parágrafo cada teste e liste as hipóteses nula/alternativa corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de estatística ou PDF online sobre testes de RNG, calculadora, papel e caneta.",
                                  "tips": "Use diagramas visuais para mapear padrões no teste de Poker.",
                                  "learningObjective": "Dominar os fundamentos teóricos para aplicar testes corretamente.",
                                  "commonMistakes": "Confundir teste de Poker com probabilidades de cartas reais; ignorar normalização de sequências."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e pré-processar a sequência aleatória",
                                  "subSteps": [
                                    "Gere ou obtenha uma sequência de pelo menos 1000 dígitos pseudo-aleatórios (ex: usando Python random ou LCG).",
                                    "Converta a sequência em dígitos individuais (0-9) se necessário.",
                                    "Divida em blocos apropriados: 5 dígitos para Poker, pares para corridas, categorias para Qui-Quadrado.",
                                    "Calcule estatísticas básicas: frequência de cada dígito, comprimento total.",
                                    "Documente a fonte do gerador para contextualizar resultados."
                                  ],
                                  "verification": "Verifique se a sequência tem comprimento adequado e frequências iniciais estão balanceadas (próximas de 10%).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com bibliotecas numpy/random, editor de código (Jupyter Notebook), planilha Excel.",
                                  "tips": "Use funções prontas como np.random.uniform para gerar sequências rapidamente.",
                                  "learningObjective": "Preparar dados de forma padronizada para testes estatísticos.",
                                  "commonMistakes": "Usar sequências curtas (<500 dígitos), que invalidam testes; não normalizar para 0-9."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o teste de Poker e teste de Corridas",
                                  "subSteps": [
                                    "Para Poker: Conte padrões em grupos de 5 dígitos (todas iguais, uma par, etc.) e calcule qui-quadrado adaptado.",
                                    "Compare com tabela de χ² para 4 gl, rejeite H0 se >9.49 (α=0.05).",
                                    "Para Corridas: Codifique +1/-1 para aumentos/diminuições, conte runs e compare Z-score com normal padrão.",
                                    "Registre p-values para ambos testes.",
                                    "Interprete: p>0.05 indica aleatoriedade."
                                  ],
                                  "verification": "Mostre tabelas de contagens e cálculos finais com p-values anotados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python customizado ou script para contagens, tabela χ² impressa.",
                                  "tips": "Automatize contagens com loops em Python para evitar erros manuais.",
                                  "learningObjective": "Executar testes não-paramétricos com precisão numérica.",
                                  "commonMistakes": "Erros na categorização de padrões Poker; confundir runs up/down."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar teste Qui-Quadrado e analisar resultados globais",
                                  "subSteps": [
                                    "Conte frequências de dígitos 0-9 e calcule χ² = Σ(O-E)²/E com E=N/10.",
                                    "Determine graus de liberdade (9) e compare com tabela crítica (16.92 para α=0.05).",
                                    "Agregue resultados dos três testes em um relatório.",
                                    "Conclua se a sequência passa (todos testes aceitam H0) ou falha.",
                                    "Sugira melhorias no gerador se necessário."
                                  ],
                                  "verification": "Relatório final com χ² calculado, p-value e decisão para cada teste.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python scipy.stats.chi2, calculadora para validação manual.",
                                  "tips": "Use scipy.stats.chisquare para verificação rápida após cálculo manual.",
                                  "learningObjective": "Integrar múltiplos testes para avaliação robusta de aleatoriedade.",
                                  "commonMistakes": "Esquecer graus de liberdade; interpretar p-value incorretamente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e documentar a avaliação",
                                  "subSteps": [
                                    "Discuta limitações: testes detectam falhas específicas, não provam verdadeira aleatoriedade.",
                                    "Compare com benchmarks de RNG conhecidos (Mersenne Twister).",
                                    "Prepare visualizações: histogramas de frequências, plot de runs.",
                                    "Escreva conclusão para uso em Monte Carlo.",
                                    "Arquive código e resultados para reprodutibilidade."
                                  ],
                                  "verification": "Relatório completo com gráficos e recomendação de uso da sequência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matplotlib para plots, documento Word/Markdown.",
                                  "tips": "Sempre inclua seed para reprodutibilidade em simulações.",
                                  "learningObjective": "Comunicar resultados técnicos de forma clara e acionável.",
                                  "commonMistakes": "Superestimar aleatoriedade baseada em poucos testes; omitir limitações."
                                }
                              ],
                              "practicalExample": "Gere uma sequência de 1000 dígitos usando linear congruential generator (LCG) com parâmetros a=1664525, c=1013904223, m=2**32. Aplique os testes: Poker deve mostrar distribuição uniforme de padrões, Corridas com Z próximo de 0, Qui-Quadrado com χ² <16.92. Se todos passarem, use em simulação Monte Carlo para modelar cargas de vento em uma ponte.",
                              "finalVerifications": [
                                "Todos os três testes resultam em p-value >0.05.",
                                "Frequências de dígitos estão dentro de ±5% do esperado.",
                                "Número de runs está entre limites teóricos para o tamanho da sequência.",
                                "Cálculos manuais coincidem com implementações computacionais.",
                                "Relatório inclui gráficos de frequências e runs plot.",
                                "Conclusão justificada com evidências quantitativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de χ² e Z-scores (erro <1%).",
                                "Correta categorização de padrões no teste de Poker.",
                                "Interpretação consistente de p-values e decisões H0.",
                                "Uso adequado de software para automação e validação.",
                                "Relatório claro com visualizações e limitações discutidas.",
                                "Aplicação contextualizada ao Monte Carlo em engenharia."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Testes de hipóteses e distribuições χ².",
                                "Programação Computacional: Implementação em Python/NumPy.",
                                "Probabilidade e Simulações: Fundamentos de Monte Carlo.",
                                "Engenharia Civil: Análise estocástica de cargas e riscos."
                              ],
                              "realWorldApplication": "Em engenharia civil, validar sequências aleatórias garante precisão em simulações Monte Carlo para previsão de falhas em barragens, análise sísmica de edifícios e otimização de projetos sob ventos turbulentos, evitando vieses que levam a sub ou superestimação de riscos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.5.2",
                        "name": "Estimativa de Integrais por Monte Carlo",
                        "description": "Aplicação da amostragem aleatória para aproximar integrais definidas multidimensionais, explorando a média amostral como estimador.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.5.2.1",
                            "name": "Formular integral como problema de Monte Carlo",
                            "description": "Transformar uma integral ∫f(x)dx em [a,b] na expectativa E[f(U)] onde U ~ Uniforme[a,b], justificando pela lei forte dos grandes números.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de integral definida",
                                  "subSteps": [
                                    "Revise a definição de ∫_a^b f(x) dx como o limite de somas de Riemann.",
                                    "Identifique o papel do intervalo [a, b] e da função f(x) contínua.",
                                    "Calcule manualmente uma integral simples, como ∫_0^1 x dx = 1/2, para fixar o conceito.",
                                    "Discuta por que integrais analíticas nem sempre são viáveis para funções complexas.",
                                    "Esboce graficamente a área sob a curva para visualização intuitiva."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição e compute um exemplo simples corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de cálculo ou notas de aula",
                                    "Papel e lápis para esboços",
                                    "Calculadora gráfica opcional"
                                  ],
                                  "tips": "Use visualizações gráficas para conectar o conceito abstrato à geometria intuitiva.",
                                  "learningObjective": "Entender o significado geométrico e analítico de uma integral definida.",
                                  "commonMistakes": [
                                    "Confundir integral definida com indefinida",
                                    "Esquecer os limites de integração",
                                    "Ignorar continuidade de f(x)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir distribuição uniforme e expectativa",
                                  "subSteps": [
                                    "Defina a variável aleatória uniforme U ~ Uniforme[a, b], com densidade 1/(b-a).",
                                    "Calcule a expectativa E[g(U)] = ∫_a^b g(u) * (1/(b-a)) du para função genérica g.",
                                    "Verifique que E[U] = (a+b)/2 e Var(U) = (b-a)^2 / 12.",
                                    "Gere amostras uniformes manualmente ou via software para intervalos simples.",
                                    "Compare expectativa teórica com média amostral de 10 amostras."
                                  ],
                                  "verification": "Compute E[U] e E[U^2] corretamente para [0,1] e gere amostras que aproximem esses valores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software como Python (NumPy.random.uniform) ou Excel",
                                    "Tabela de números aleatórios"
                                  ],
                                  "tips": "Sempre normalize pela densidade para evitar erros de escala.",
                                  "learningObjective": "Dominar o conceito de expectativa para variáveis uniformes contínuas.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/(b-a) na densidade",
                                    "Confundir uniforme discreta com contínua",
                                    "Usar média sem normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reformular a integral como expectativa",
                                  "subSteps": [
                                    "Mostre que ∫_a^b f(x) dx = (b-a) * E[f(U)] onde U ~ Uniforme[a, b].",
                                    "Derive algebricamente: E[f(U)] = ∫_a^b f(u)/(b-a) du, logo integral = (b-a) E[f(U)].",
                                    "Aplique a uma função exemplo: para f(x)=x em [0,1], E[U]=0.5, integral=0.5.",
                                    "Teste com f(x)=x^2 em [0,1]: E[U^2]=1/3, integral=1/3.",
                                    "Escreva a fórmula geral em notação matemática clara."
                                  ],
                                  "verification": "Derive e aplique a reformulação corretamente para dois exemplos distintos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel para derivação",
                                    "Software para plotar f(x) e histograma de f(U)"
                                  ],
                                  "tips": "Pense na integral como 'média ponderada' pela largura do intervalo.",
                                  "learningObjective": "Transformar integral em expectativa de forma algébrica precisa.",
                                  "commonMistakes": [
                                    "Esquecer o fator (b-a)",
                                    "Inverter a relação E[f(U)] e integral",
                                    "Aplicar a funções não contínuas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar convergência pela Lei Forte dos Grandes Números",
                                  "subSteps": [
                                    "Enuncie a LLN: média amostral \bar{f}_n → E[f(U)] quase certamente quando n→∞.",
                                    "Explique por que f(U_i) são i.i.d. sob amostragem uniforme independente.",
                                    "Simule numericamente: gere N=1000 amostras U_i, compute (b-a)/N ∑ f(U_i), observe convergência.",
                                    "Discuta condições: f contínua (ou integrável) garante E|f(U)|<∞.",
                                    "Compare erro para N=10, 100, 1000 em um exemplo fixo."
                                  ],
                                  "verification": "Simule e demonstre convergência numérica com gráfico de erro vs. N.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python ou MATLAB com random.uniform e matplotlib",
                                    "Notebook Jupyter para simulação"
                                  ],
                                  "tips": "Use sementes fixas para reprodutibilidade em simulações.",
                                  "learningObjective": "Justificar rigorosamente a validade do método Monte Carlo via LLN.",
                                  "commonMistakes": [
                                    "Confundir LLN forte com fraca",
                                    "Ignorar i.i.d.",
                                    "Atribuir convergência sem condições em f"
                                  ]
                                }
                              ],
                              "practicalExample": "Para estimar ∫_0^1 sin(x^2) dx (sem antiderivada elementar), formule como 1 * E[sin(U^2)] com U~Uniforme[0,1]. Simule 10.000 U_i, compute média sin(U_i^2) ≈ 0.310, valor exato conhecido ≈ 0.312.",
                              "finalVerifications": [
                                "Derive corretamente ∫_a^b f(x) dx = (b-a) E[f(U)].",
                                "Simule Monte Carlo para integral conhecida e erro <5%.",
                                "Enuncie e prove informalmente LLN para o contexto.",
                                "Aplique a exemplo não-trivial com função irregular.",
                                "Explique limitações (ex: f descontínua).",
                                "Compare com método analítico onde possível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica (100% correta).",
                                "Correção na justificativa teórica via LLN.",
                                "Qualidade da simulação numérica (convergência demonstrada).",
                                "Clareza na explicação oral/escrita.",
                                "Criatividade em exemplo próprio.",
                                "Identificação de erros potenciais."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Expectativas e teoremas limite.",
                                "Estatística: Estimadores não viesados e convergência.",
                                "Programação: Geração de aleatórios e simulações.",
                                "Cálculo: Integrais como limites.",
                                "Engenharia Civil: Modelagem de incertezas em cargas/volumes."
                              ],
                              "realWorldApplication": "Em Engenharia Civil, estimar volume de concreto em formas irregulares ou áreas de seções transversais complexas em barragens, onde geometria é incerta, usando Monte Carlo para integrar funções de perfis reais sem soluções analíticas exatas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.5.2.2",
                            "name": "Implementar integração Monte Carlo básica",
                            "description": "Codificar algoritmo para estimar ∫f(x)dx gerando N amostras aleatórias, calculando média e intervalo de confiança via variância amostral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função integranda e os limites de integração",
                                  "subSteps": [
                                    "Escolha uma função f(x) contínua e os limites a e b do intervalo de integração.",
                                    "Implemente a função f(x) em Python usando NumPy para facilitar cálculos vetorizados.",
                                    "Defina os parâmetros N (número de amostras) e o intervalo [a, b].",
                                    "Teste a função f(x) com valores conhecidos para validar.",
                                    "Documente a integral analítica conhecida para comparação futura."
                                  ],
                                  "verification": "Execute f(x) em pontos conhecidos e confirme saídas corretas; exemplo: para f(x)=x^2 em x=0.5, deve retornar 0.25.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "Biblioteca NumPy",
                                    "Editor de código (VS Code ou Jupyter Notebook)"
                                  ],
                                  "tips": "Comece com funções simples como f(x)=x^2 para depuração rápida.",
                                  "learningObjective": "Compreender como especificar o problema de integração numérica via Monte Carlo.",
                                  "commonMistakes": [
                                    "Definir limites incorretos (ex: esquecer que Monte Carlo é para [a,b] uniforme)",
                                    "Não importar NumPy corretamente",
                                    "Função f(x) não vetorizada levando a lentidão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar amostras aleatórias uniformes e avaliar f(x)",
                                  "subSteps": [
                                    "Use np.random.uniform(a, b, N) para gerar N pontos xi aleatórios no intervalo [a, b].",
                                    "Calcule os valores yi = f(xi) para cada amostra.",
                                    "Armazene xi e yi em arrays NumPy para eficiência.",
                                    "Visualize as amostras com um scatter plot para confirmar distribuição uniforme.",
                                    "Experimente diferentes valores de N (ex: 100, 1000) para observar variabilidade."
                                  ],
                                  "verification": "Plote histograma de xi; deve ser uniforme em [a,b]; comprimento de yi == N.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "NumPy",
                                    "Matplotlib para visualização",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use seed com np.random.seed(42) para reprodutibilidade durante testes.",
                                  "learningObjective": "Dominar geração de amostras aleatórias e avaliação da integranda.",
                                  "commonMistakes": [
                                    "Gerar amostras fora de [a,b]",
                                    "Confundir uniforme com normal",
                                    "Não vetorizar f(xi) causando loops lentos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular média amostral, variância e intervalo de confiança",
                                  "subSteps": [
                                    "Calcule a largura do intervalo h = (b - a).",
                                    "Compute a média mu = np.mean(yi) * h para estimar a integral.",
                                    "Calcule a variância amostral var = np.var(yi, ddof=1) * h**2 / N.",
                                    "Desvio padrão sigma = sqrt(var); IC 95% = mu ± 1.96 * sigma / sqrt(N).",
                                    "Implemente em uma função que retorne estimativa, IC inferior e superior."
                                  ],
                                  "verification": "Para ∫x^2 dx de 0 a 1 com N grande, mu ≈ 0.333; IC contém 1/3.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NumPy (funções mean, var)",
                                    "Documentação SciPy.stats para norm.ppf se necessário"
                                  ],
                                  "tips": "Use ddof=1 para variância amostral não viesada.",
                                  "learningObjective": "Aplicar teoria estatística para estimativa e incerteza da integral.",
                                  "commonMistakes": [
                                    "Esquecer multiplicar por h=(b-a)",
                                    "Usar variância populacional (ddof=0)",
                                    "Erro na fórmula do erro padrão do IC"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar função completa, testar e analisar convergência",
                                  "subSteps": [
                                    "Crie uma função monte_carlo_integral(f, a, b, N) que retorne estimativa e IC.",
                                    "Teste com integral conhecida: ∫sin(x) dx de 0 a π (valor=2).",
                                    "Rode simulações para N=10^3, 10^4, 10^5 e plote erro vs N (log-log).",
                                    "Compare com método analítico ou quadratura numérica (ex: scipy.integrate.quad).",
                                    "Analise como o IC encolhe com sqrt(1/N)."
                                  ],
                                  "verification": "Gráfico de convergência mostra declínio de erro; IC cobre valor verdadeiro em >95% das runs.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "NumPy, Matplotlib, SciPy (opcional para comparação)"
                                  ],
                                  "tips": "Loop sobre N log-spaced para eficiência; salve resultados em DataFrame Pandas.",
                                  "learningObjective": "Integrar todos os componentes em código robusto e validar numericamente.",
                                  "commonMistakes": [
                                    "Não normalizar por h",
                                    "Ignorar dependência O(1/sqrt(N))",
                                    "Overfitting a um N sem testar convergência"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o algoritmo para estimar ∫_0^1 x^2 dx (valor exato=1/3≈0.333). Gere N=10000 amostras uniformes em [0,1], calcule média*1=0.334±0.005 (IC 95%), confirmando convergência.",
                              "finalVerifications": [
                                "Código executa sem erros para N até 10^6.",
                                "Estimativa converge para valor analítico com N crescente.",
                                "Intervalo de confiança diminui como O(1/sqrt(N)).",
                                "Visualizações mostram amostras uniformes e convergência.",
                                "Função é reutilizável para qualquer f(x) contínua.",
                                "Reprodutível com seed fixo."
                              ],
                              "assessmentCriteria": [
                                "Correção da estimativa da integral (erro <1% para N=10^5).",
                                "Implementação precisa do IC via variância amostral.",
                                "Eficiência: vetorização NumPy, sem loops desnecessários.",
                                "Validação com múltiplos N e gráfico de convergência.",
                                "Código limpo, comentado e modular.",
                                "Tratamento de edge cases (N pequeno, f(x) oscilante)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência, variância amostral, teorema central do limite.",
                                "Programação: Vetorização NumPy, funções modulares, visualização Matplotlib.",
                                "Cálculo Numérico: Comparação com quadratura determinística.",
                                "Engenharia Civil: Modelagem de áreas/volumes irregulares em projetos geotécnicos.",
                                "Probabilidade: Distribuição uniforme, convergência em probabilidade."
                              ],
                              "realWorldApplication": "Em engenharia civil, estima volumes de escavações com geometrias complexas (ex: túneis irregulares), áreas de bacias hidrográficas ou integrais em simulações de difusão em solos heterogêneos, onde métodos determinísticos falham."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.8.5.2.3",
                            "name": "Analisar erro de convergência",
                            "description": "Calcular erro padrão O(1/√N) e demonstrar convergência empírica plotando estimativas vs. N para função teste como π/4 via integral de arco.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a teoria do erro padrão no Método de Monte Carlo",
                                  "subSteps": [
                                    "Estude a fórmula do erro padrão para estimativas de integrais: σ ≈ √(Var(f)/N), onde Var(f) é a variância da função f.",
                                    "Derive ou memorize que o erro converge como O(1/√N) para grandes N.",
                                    "Calcule Var(f) para a função teste f(x) = √(1 - x²) no intervalo [0,1], que estima π/4.",
                                    "Explique em suas palavras por que o Monte Carlo tem convergência lenta comparada a métodos determinísticos.",
                                    "Resolva um exemplo numérico simples com N=100 para estimar o erro padrão."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando o erro O(1/√N) e calcule Var(f) corretamente para f(x).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Monte Carlo ou notas de aula",
                                    "Calculadora ou Python para variância",
                                    "Papel e caneta para derivações"
                                  ],
                                  "tips": "Use aproximações analíticas para Var(f) quando possível; foque na intuição estatística.",
                                  "learningObjective": "Compreender teoricamente a taxa de convergência do Método de Monte Carlo.",
                                  "commonMistakes": [
                                    "Confundir erro padrão com erro absoluto",
                                    "Ignorar a dependência na variância da função"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a estimativa de integral para π/4 usando Monte Carlo",
                                  "subSteps": [
                                    "Defina a função f(x) = √(1 - x²) e o domínio [0,1] para ∫f(x)dx = π/4.",
                                    "Escreva código para gerar N amostras uniformes em [0,1] e calcular a média de f(x_i).",
                                    "Execute para N fixo (ex: 10^4) e compare com o valor verdadeiro π/4 ≈ 0.7854.",
                                    "Calcule a estimativa e o erro absoluto inicial.",
                                    "Teste com 3 valores diferentes de N para observar variação."
                                  ],
                                  "verification": "Código roda sem erros e estimativa para N=10^4 está dentro de 1% do valor verdadeiro.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Jupyter Notebook",
                                    "Documentação do NumPy.random"
                                  ],
                                  "tips": "Use np.mean e np.random.uniform para eficiência; seed o random para reprodutibilidade.",
                                  "learningObjective": "Implementar corretamente a amostragem Monte Carlo para uma integral conhecida.",
                                  "commonMistakes": [
                                    "Gerar amostras fora do domínio",
                                    "Esquecer de multiplicar pela largura do intervalo (aqui 1)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações múltiplas para diferentes N e coletar estatísticas",
                                  "subSteps": [
                                    "Defina uma lista de N: [10^2, 10^3, 10^4, 10^5, 10^6].",
                                    "Para cada N, execute M=100 runs independentes, calculando média e desvio padrão das estimativas.",
                                    "Registre: estimativa média, erro padrão empírico σ_emp = std(estimativas)/√M, e erro vs verdadeiro.",
                                    "Calcule o erro relativo médio para cada N.",
                                    "Salve dados em arrays ou DataFrame para análise."
                                  ],
                                  "verification": "Tabela ou array com estatísticas para todos N, mostrando σ_emp decrescendo com N.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy, Pandas",
                                    "Jupyter Notebook",
                                    "Computador com boa performance para N=10^6"
                                  ],
                                  "tips": "Vetorize as runs com loops ou broadcasting para velocidade; use tqdm para progresso.",
                                  "learningObjective": "Coletar dados empíricos de convergência através de múltiplas simulações.",
                                  "commonMistakes": [
                                    "Poucas runs (M baixo leva a variância alta)",
                                    "Não usar runs independentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar estimativas e erros vs. N e analisar convergência",
                                  "subSteps": [
                                    "Crie log-log plot de erro médio vs. N, sobreponha linha teórica O(1/√N).",
                                    "Plote trajetórias de estimativas individuais para visualização de variância.",
                                    "Ajuste uma reta no log-log para estimar o expoente de convergência (deve ser -0.5).",
                                    "Compare σ_emp com √(Var(f)/N) teórico.",
                                    "Documente observações sobre quando a convergência empírica matches a teoria."
                                  ],
                                  "verification": "Plots gerados mostram clara tendência O(1/√N) com slope ≈ -0.5 no log-log.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Matplotlib ou Seaborn",
                                    "SciPy para curve_fit",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use plt.loglog() para escalas log; adicione legendas e labels claros.",
                                  "learningObjective": "Visualizar e quantificar empiricamente a convergência do método.",
                                  "commonMistakes": [
                                    "Escalas erradas no plot (use log-log para ordem)",
                                    "Ignorar regimes pequenos N onde teoria falha"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e demonstrar implicações",
                                  "subSteps": [
                                    "Calcule o coeficiente de determinação (R²) do fit log-log para validar O(1/√N).",
                                    "Discuta limitações: custo computacional para precisão alta.",
                                    "Sugira melhorias como amostragem de importância.",
                                    "Escreva relatório curto com conclusões.",
                                    "Teste sensibilidade variando a função f."
                                  ],
                                  "verification": "Relatório de 300 palavras com R² > 0.95 e discussão de implicações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "SciPy.stats.linregress",
                                    "Word ou Markdown para relatório"
                                  ],
                                  "tips": "Foque em evidências quantitativas; relacione com aplicações reais.",
                                  "learningObjective": "Analisar criticamente dados empíricos e conectar com teoria.",
                                  "commonMistakes": [
                                    "Overfitting no fit sem validação",
                                    "Ignorar viés em pequenos N"
                                  ]
                                }
                              ],
                              "practicalExample": "Em engenharia civil, use Monte Carlo para estimar a probabilidade de falha em uma estrutura sob carga aleatória (ex: vento). Analise como o erro de convergência afeta a confiança na probabilidade estimada de 1/1000, plotando vs. número de simulações N.",
                              "finalVerifications": [
                                "Cálculo correto de erro padrão teórico O(1/√N) para a função teste.",
                                "Plots log-log mostram slope próximo de -0.5 com R² alto.",
                                "Estatísticas de 100 runs por N coletadas e salvas.",
                                "Estimativa para N=10^6 converge para π/4 dentro de 0.1%.",
                                "Relatório discute limitações e melhorias.",
                                "Código é reprodutível com seed fixo."
                              ],
                              "assessmentCriteria": [
                                "Precisão teórica: derivação correta de erro (30%)",
                                "Implementação de código: eficiência e correção (25%)",
                                "Qualidade dos plots e análise quantitativa (20%)",
                                "Coleta de dados empíricos robusta (M≥50 runs) (15%)",
                                "Relatório claro e insights profundos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: variância, distribuições e teorema do limite central",
                                "Programação: NumPy, loops vetorizados e visualização de dados",
                                "Cálculo Numérico: comparação com quadratura determinística",
                                "Engenharia de Probabilidade: análise de risco e confiabilidade"
                              ],
                              "realWorldApplication": "Na engenharia civil, analisar erro de convergência em simulações Monte Carlo para previsão de inundações, dimensionamento sísmico ou fadiga de materiais, garantindo que N seja suficiente para precisão regulatória (ex: erro <1% em probabilidades críticas)."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.8.5.2.4",
                            "name": "Comparar com métodos determinísticos",
                            "description": "Contrastar precisão e custo computacional de Monte Carlo com quadratura de Gauss ou Simpson para integrais unidimensionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar métodos determinísticos: Quadratura de Gauss e Regra de Simpson",
                                  "subSteps": [
                                    "Estude a fórmula da Regra de Simpson para integrais unidimensionais: aproximação polinomial quadrática.",
                                    "Aprenda os nós e pesos da Quadratura de Gauss para diferentes ordens (ex: 2, 3 pontos).",
                                    "Calcule manualmente uma integral simples, como ∫_0^1 x^2 dx, usando ambos os métodos.",
                                    "Registre o erro em relação ao valor exato (1/3 ≈ 0.3333)."
                                  ],
                                  "verification": "Realize cálculos manuais e compare com valor exato; erro < 1% indica compreensão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, calculadora, tabela de nós/pesos de Gauss (online ou livro de métodos numéricos).",
                                  "tips": "Comece com funções polinomiais para verificar exatidão dos métodos.",
                                  "learningObjective": "Compreender a base teórica e aplicação de quadraturas determinísticas.",
                                  "commonMistakes": "Confundir nós de Gauss com pontos de Simpson; ignorar limites de integração."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar o método de Monte Carlo para estimativa de integrais",
                                  "subSteps": [
                                    "Lembre a fórmula: I ≈ (b-a)/N * Σ f(x_i) onde x_i ~ Uniforme[a,b].",
                                    "Entenda o erro estatístico: desvio padrão σ/√N, com variância Var(f)/N.",
                                    "Implemente em código simples para ∫_0^1 x^2 dx com N=1000 amostras.",
                                    "Execute múltiplas simulações para observar variabilidade."
                                  ],
                                  "verification": "Código roda e estima próximo de 0.3333 com erro médio ~1/√N.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python ou MATLAB com numpy/random.",
                                  "tips": "Use seed para reprodutibilidade inicial, depois randomize.",
                                  "learningObjective": "Dominar a formulação probabilística do Monte Carlo.",
                                  "commonMistakes": "Esquecer de multiplicar pela largura do intervalo (b-a); usar N muito pequeno."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar exemplos numéricos comparativos",
                                  "subSteps": [
                                    "Escolha função teste: f(x) = sin(x) em [0, π], exato=2.",
                                    "Compute com Simpson (10 intervalos) e Gauss (5 pontos).",
                                    "Rode Monte Carlo com N=10^3, 10^4, 10^5 amostras (10 repetições cada).",
                                    "Registre tempos de execução e erros absolutos."
                                  ],
                                  "verification": "Tabelas de resultados com erros e tempos para cada método/N.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (timeit, numpy), planilha Excel para tabelas.",
                                  "tips": "Meça tempo com %timeit no Jupyter para precisão.",
                                  "learningObjective": "Gerar dados empíricos para comparação prática.",
                                  "commonMistakes": "Não repetir simulações Monte Carlo; medir tempo sem warm-up."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar precisão e custo computacional",
                                  "subSteps": [
                                    "Compare erros: determinístico (fixo) vs. Monte Carlo (√N convergence).",
                                    "Calcule custo: flops para Gauss/Simpson vs. N avaliações f em Monte Carlo.",
                                    "Plote erro vs. custo (log-log) para visualizar trade-offs.",
                                    "Discuta cenários: dim high vs. smooth functions."
                                  ],
                                  "verification": "Gráficos mostram Monte Carlo converge mais devagar, mas escalável em alta dim.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python matplotlib para plots.",
                                  "tips": "Use eixo log para erro e custo; destaque ponto de equilíbrio.",
                                  "learningObjective": "Quantificar vantagens/desvantagens quantitativamente.",
                                  "commonMistakes": "Ignorar custo de geração de aleatórios; generalizar de 1D para high-D sem cuidado."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar trade-offs e recomendações",
                                  "subSteps": [
                                    "Liste prós/contras: determinístico (preciso, caro em dim>1) vs. MC (robusto, lento converge).",
                                    "Defina regras: use determinístico para 1D smooth; MC para irregulares/high-D.",
                                    "Aplique a contexto de Engenharia Civil (ex: integrais em simulações estocásticas).",
                                    "Escreva relatório curto com conclusões."
                                  ],
                                  "verification": "Relatório de 1 página resume comparações e regras de escolha.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto.",
                                  "tips": "Use bullet points para clareza; inclua referência bibliográfica.",
                                  "learningObjective": "Capacitar decisão informada entre métodos.",
                                  "commonMistakes": "Superestimar precisão MC sem N grande; subestimar custo determinístico em 1D."
                                }
                              ],
                              "practicalExample": "Compare a estimativa de ∫_0^π sin(x) dx (exato=2) usando Regra de Simpson com 10 intervalos (erro ~10^-5, tempo <1s), Quadratura de Gauss 5 pontos (erro ~10^-7), e Monte Carlo com N=10^6 (erro médio ~0.01, tempo ~2s). Monte Carlo varia, mas converge; determinísticos são exatos para baixa ordem.",
                              "finalVerifications": [
                                "Explica convergência O(1/√N) do MC vs. exponencial dos determinísticos.",
                                "Identifica que MC é melhor para dimensões >3.",
                                "Apresenta tabelas/gráficos de erro vs. custo.",
                                "Recomenda método para integral 1D smooth: Gauss.",
                                "Discute impacto de variância da função f no MC.",
                                "Verifica com nova função teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos e implementação (80% peso).",
                                "Análise quantitativa de erro e custo (flops/tempo).",
                                "Gráficos claros e interpretados corretamente.",
                                "Discussão equilibrada de trade-offs.",
                                "Relatório bem estruturado e sem erros conceituais.",
                                "Criatividade em exemplos adicionais."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: análise de variância e intervalos de confiança no MC.",
                                "Programação: otimização de loops e medição de performance.",
                                "Matemática Numérica: teoria de erros de aproximação.",
                                "Engenharia Civil: simulações probabilísticas em estruturas."
                              ],
                              "realWorldApplication": "Na Engenharia Civil, comparar MC com Gauss para integrar distribuições de carga em vigas (MC para incertezas high-D em solos; Gauss para perfis 1D de tensão conhecidos), otimizando simulações de confiabilidade estrutural."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.5.3",
                        "name": "Aplicações em Problemas Probabilísticos",
                        "description": "Uso do Monte Carlo para estimar probabilidades, expectativas e soluções de equações integrais em contextos de engenharia civil.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.5.3.1",
                            "name": "Estimar probabilidades via simulação",
                            "description": "Simular eventos raros (ex: probabilidade de falha estrutural) gerando amostras e contando proporção de sucessos, com análise de variância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema probabilístico e modelar variáveis",
                                  "subSteps": [
                                    "Identifique o evento raro a simular, como falha estrutural em uma ponte devido a cargas extremas.",
                                    "Liste as variáveis aleatórias envolvidas (ex: carga máxima, resistência do material, fatores ambientais).",
                                    "Defina distribuições probabilísticas para cada variável (ex: normal para resistência, exponencial para cargas).",
                                    "Estabeleça critérios de falha (ex: tensão > resistência).",
                                    "Escreva a função lógica de falha em pseudocódigo."
                                  ],
                                  "verification": "Modelo documentado com distribuições e função de falha clara, testado manualmente com 10 cenários.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou editor de texto; documentação de distribuições probabilísticas (ex: Wikipedia ou SciPy docs).",
                                  "tips": "Comece com poucas variáveis para simplificar; use diagramas para visualizar o modelo.",
                                  "learningObjective": "Compreender como traduzir problemas reais em modelos probabilísticos acionáveis.",
                                  "commonMistakes": "Ignorar correlações entre variáveis ou escolher distribuições inadequadas sem justificativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração de amostras aleatórias",
                                  "subSteps": [
                                    "Configure ambiente de programação com bibliotecas (ex: NumPy para Python).",
                                    "Crie funções para gerar amostras de cada variável conforme suas distribuições.",
                                    "Implemente um loop para gerar N amostras independentes (ex: N=10^6 para eventos raros).",
                                    "Teste a geração com histogramas para validar distribuições.",
                                    "Otimize para eficiência computacional (ex: vetorização no NumPy)."
                                  ],
                                  "verification": "Histogramas das amostras geradas coincidem com as distribuições teóricas (teste visual e estatístico como KS-test).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy e Matplotlib; Jupyter Notebook.",
                                  "tips": "Use np.random.seed() para reprodutibilidade durante desenvolvimento.",
                                  "learningObjective": "Dominar geração de números pseudoaleatórios e amostragem de distribuições multivariadas.",
                                  "commonMistakes": "Gerar amostras insuficientes inicialmente ou não vetorizar, causando lentidão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações e estimar probabilidade",
                                  "subSteps": [
                                    "Aplique a função de falha a cada amostra simulada.",
                                    "Conte o número de falhas (sucessos no evento raro).",
                                    "Calcule a estimativa de probabilidade: p_hat = falhas / N.",
                                    "Registre p_hat para diferentes valores de N e observe convergência.",
                                    "Plote curvas de convergência para visualizar estabilidade."
                                  ],
                                  "verification": "Probabilidade estimada estabiliza com aumento de N; gráfico de convergência mostra platô.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python do Step 2; Matplotlib para plots.",
                                  "tips": "Para eventos raros (p<0.01), use N grande (10^6+) e monitore tempo de execução.",
                                  "learningObjective": "Aplicar Lei dos Grandes Números para estimar probabilidades via proporção amostral.",
                                  "commonMistakes": "Confundir sucessos com falhas ou não normalizar pela contagem total."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar variância e intervalos de confiança",
                                  "subSteps": [
                                    "Calcule variância da estimativa: var(p_hat) = p_hat*(1-p_hat)/N.",
                                    "Compute erro padrão: sqrt(var(p_hat)).",
                                    "Calcule intervalo de confiança 95% usando aproximação normal: p_hat ± 1.96 * erro_padrão.",
                                    "Para eventos raros, considere aproximações alternativas (ex: Wilson score).",
                                    "Avalie sensibilidade variando N e distribuições."
                                  ],
                                  "verification": "Intervalo de confiança reportado com justificativa; testes de sensibilidade mostram robustez.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python; fórmulas estatísticas (ex: cheat sheet de intervalos de confiança).",
                                  "tips": "Para p muito pequeno, aumente N até que o IC seja aceitável (ex: largura < 0.001).",
                                  "learningObjective": "Quantificar incerteza na estimativa probabilística e interpretar variância amostral.",
                                  "commonMistakes": "Usar aproximação normal para p muito próximo de 0 ou 1 sem ajustes."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e validar simulação",
                                  "subSteps": [
                                    "Compare p_hat com valores analíticos conhecidos (se disponíveis).",
                                    "Discuta implicações para engenharia (ex: risco aceitável <10^-4).",
                                    "Realize validação cruzada variando sementes e parâmetros.",
                                    "Documente relatório com p_hat, IC e recomendações.",
                                    "Sugira melhorias (ex: importance sampling para raros)."
                                  ],
                                  "verification": "Relatório completo com interpretação coerente e validação quantitativa.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Resultados anteriores; template de relatório.",
                                  "tips": "Sempre relacione de volta ao problema real para contextualizar.",
                                  "learningObjective": "Integrar análise probabilística em decisões de engenharia com rigor.",
                                  "commonMistakes": "Superestimar precisão sem IC ou ignorar viés no modelo."
                                }
                              ],
                              "practicalExample": "Simule a probabilidade de falha de uma viga de concreto sob carga viva variável (distribuição exponencial λ=5kN/m) e resistência normal μ=50MPa, σ=5MPa. Falha se carga > resistência * fator segurança 1.5. Use N=10^7 simulações para estimar P(falha) e seu IC 95%.",
                              "finalVerifications": [
                                "Estimativa de probabilidade converge com N>10^6.",
                                "Intervalo de confiança 95% calculado corretamente e reportado.",
                                "Histogramas validam distribuições de entrada.",
                                "Gráfico de convergência mostra estabilidade.",
                                "Relatório interpreta risco no contexto de engenharia civil.",
                                "Código é reprodutível com seed fixa."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimativa (erro <5% de p_hat).",
                                "Correta modelagem de distribuições e função de falha.",
                                "Análise de variância e IC apropriados para eventos raros.",
                                "Eficiência computacional (tempo razoável para N grande).",
                                "Interpretação clara e conexões com aplicações reais.",
                                "Código limpo, comentado e validado."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Lei dos Grandes Números, Teorema Central do Limite.",
                                "Programação: Vetorização, otimização numérica (NumPy/SciPy).",
                                "Engenharia Civil: Análise de risco estrutural, normas de segurança (ex: Eurocode).",
                                "Física/Mecânica: Modelos de falha e distribuições de cargas.",
                                "Gestão de Riscos: Quantificação de incertezas em projetos."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para estimar risco de colapso de pontes ou edifícios sob eventos raros como terremotos ou ventos extremos, auxiliando no dimensionamento seguro e econômico, como na análise probabilística de confiabilidade em projetos da FEMA ou normas ABNT NBR."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.8.5.3.2",
                            "name": "Resolver problemas de valor esperado",
                            "description": "Calcular E[g(X)] para variável aleatória X via amostragem direta, aplicando a problemas como tempo médio de fluxo em redes hidráulicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Valor Esperado e Método de Monte Carlo",
                                  "subSteps": [
                                    "Defina valor esperado E[g(X)] como a média de g(X) sobre a distribuição de X.",
                                    "Explique o teorema da lei dos grandes números que justifica a convergência da média amostral para E[g(X)].",
                                    "Discuta amostragem direta: gerar N amostras independentes X_i ~ distribuição de X.",
                                    "Revise distribuições comuns em engenharia civil, como normal ou log-normal para tempos de fluxo.",
                                    "Estude o exemplo de tempo médio de fluxo em redes hidráulicas como E[T], onde T é tempo total."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e resolva um exercício teórico simples sem código.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Probabilidade (ex: Ross), Notas de aula sobre Monte Carlo, Calculadora"
                                  ],
                                  "tips": "Use analogias como 'média de lançamentos de dados' para visualizar a convergência.",
                                  "learningObjective": "Dominar a teoria por trás da estimativa de E[g(X)] via Monte Carlo.",
                                  "commonMistakes": [
                                    "Confundir valor esperado com variância",
                                    "Ignorar independência das amostras",
                                    "Esquecer normalização da distribuição"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Geração de Amostras Aleatórias",
                                  "subSteps": [
                                    "Escolha a distribuição de X (ex: normal para tempos hidráulicos com média μ e desvio σ).",
                                    "Implemente gerador de números aleatórios em Python usando numpy.random.",
                                    "Gere N amostras (N=10^4 a 10^6) e visualize histograma para validar distribuição.",
                                    "Defina a função g(X), como g(X) = X para tempo direto ou soma para rede.",
                                    "Salve amostras em array para reutilização."
                                  ],
                                  "verification": "Plote histograma das amostras e confirme que coincide com PDF teórica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy e Matplotlib, Jupyter Notebook"
                                  ],
                                  "tips": "Use seed para reprodutibilidade: np.random.seed(42).",
                                  "learningObjective": "Gerar amostras independentes representativas da distribuição alvo.",
                                  "commonMistakes": [
                                    "Usar N muito pequeno levando a alta variância",
                                    "Não definir seed causando resultados não reproduzíveis",
                                    "Escolha errada de distribuição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Estimativa do Valor Esperado",
                                  "subSteps": [
                                    "Compute g(X_i) para cada amostra i=1 a N.",
                                    "Calcule a média amostral: estimativa = (1/N) * sum g(X_i).",
                                    "Estime erro padrão: sqrt(var(g(X))/N), usando amostra para var.",
                                    "Execute múltiplas simulações (M=100 runs) e plote convergência vs N.",
                                    "Compare com valor analítico se conhecido."
                                  ],
                                  "verification": "Mostre que a estimativa converge para valor teórico ao aumentar N.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python do Step 2, SciPy para estatísticas"
                                  ],
                                  "tips": "Vetorize cálculos com NumPy para eficiência.",
                                  "learningObjective": "Implementar e validar a estimativa numérica de E[g(X)].",
                                  "commonMistakes": [
                                    "Não dividir por N",
                                    "Confundir média com mediana",
                                    "Ignorar variância na interpretação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Problema de Redes Hidráulicas",
                                  "subSteps": [
                                    "Modele rede simples: 3 trechos com tempos T1, T2, T3 ~ Normal(μ_i, σ_i).",
                                    "Defina g(X) = max(T1+T2, T3) ou soma para tempo total de fluxo.",
                                    "Gere amostras multivariadas com correlações se aplicável (np.random.multivariate_normal).",
                                    "Estime E[g(X)] e intervalos de confiança (média ± 2*erro padrão).",
                                    "Interprete resultados: tempo médio esperado e risco de atraso."
                                  ],
                                  "verification": "Gere relatório com estimativa, IC e plot de distribuição de g(X).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código anterior, Diagrama de rede hidráulica desenhado"
                                  ],
                                  "tips": "Comece com rede serial simples antes de paralela.",
                                  "learningObjective": "Aplicar Monte Carlo a problema engenheiril real.",
                                  "commonMistakes": [
                                    "Modelar incorretamente dependências na rede",
                                    "Usar distribuições inadequadas para tempos",
                                    "Interpretar IC como intervalo determinístico"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Precisão e Otimizar",
                                  "subSteps": [
                                    "Calcule estatísticas: bias, MSE vs solução analítica.",
                                    "Teste sensibilidade a N, distribuição parâmetros.",
                                    "Implemente acelerações: amostragem de importância se aplicável.",
                                    "Documente limitações: tempo computacional para N grande.",
                                    "Proponha melhorias para cenários reais."
                                  ],
                                  "verification": "Compare erro numérico com analítico em <5%.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Códigos anteriores, Ferramentas de profiling (timeit)"
                                  ],
                                  "tips": "Use loops para variar N e plote curvas de convergência.",
                                  "learningObjective": "Avaliar e refinar a simulação Monte Carlo.",
                                  "commonMistakes": [
                                    "Sobreestimar precisão com N insuficiente",
                                    "Não considerar custo computacional",
                                    "Ignorar viés em g não-linear"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede hidráulica com dois caminhos paralelos: Caminho A (T_A ~ N(10,2) dias), Caminho B (T_B ~ N(12,3) dias). Tempo total T = min(T_A, T_B). Estime E[T] via 10^5 amostras: gere X_i = [T_Ai, T_Bi], compute g(X_i)=min(T_Ai,T_Bi), média ≈ 8.2 dias.",
                              "finalVerifications": [
                                "Implementa código que estima E[g(X)] com erro <1% do valor verdadeiro.",
                                "Explica lei dos grandes números e convergência em relatório.",
                                "Aplica corretamente a rede hidráulica com IC de 95%.",
                                "Identifica e corrige 3 erros comuns em simulações.",
                                "Compara Monte Carlo com solução analítica para caso simples.",
                                "Documenta código com comentários e reprodutibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimativa (erro relativo <5%).",
                                "Qualidade do código (eficiente, vetorizado, comentado).",
                                "Validação visual (histogramas, plots de convergência).",
                                "Interpretação correta de resultados e IC.",
                                "Aplicação contextualizada à engenharia civil.",
                                "Análise de sensibilidade e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Lei dos Grandes Números, IC.",
                                "Programação Computacional: NumPy, simulações numéricas.",
                                "Engenharia Hidráulica: Modelagem de fluxos e tempos.",
                                "Otimização: Amostragem de importância, redução de variância.",
                                "Análise de Dados: Visualização e validação estatística."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, estima tempo médio e variabilidade de fluxo em redes de esgoto ou abastecimento, auxiliando no planejamento de prazos, alocação de recursos e mitigação de riscos de inundações ou atrasos em construções hidráulicas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.8.5.3.3",
                            "name": "Aplicar Monte Carlo em equações integrais",
                            "description": "Aproximar soluções de equações de Fredholm do tipo ∫K(x,y)u(y)dy = f(x) iterando amostras aleatórias em problemas de engenharia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular a equação de Fredholm e definir componentes",
                                  "subSteps": [
                                    "Identifique a equação ∫K(x,y)u(y)dy = f(x) e especifique o intervalo de integração.",
                                    "Defina o kernel K(x,y), a função f(x) e condições de contorno para um problema de engenharia civil.",
                                    "Discretize o domínio se necessário, dividindo em pontos de avaliação.",
                                    "Esboce a representação probabilística: u(x) ≈ (1/N) Σ [f(y_i)/K(x,y_i)] onde y_i são amostras aleatórias.",
                                    "Valide as funções K e f com testes simples de consistência."
                                  ],
                                  "verification": "Verifique se K(x,y), f(x) e o intervalo estão corretamente definidos e satisfazem propriedades de Fredholm (ex.: kernel simétrico).",
                                  "estimatedTime": "2 horas",
                                  "materials": "Papel e lápis, software de matemática como MATLAB ou Python (NumPy), documentação de equações integrais.",
                                  "tips": "Comece com um kernel simples como K(x,y)=1 para testar entendimento.",
                                  "learningObjective": "Compreender e configurar matematicamente uma equação de Fredholm para aplicação Monte Carlo.",
                                  "commonMistakes": "Ignorar normalização do kernel ou escolher intervalo incorreto, levando a divergência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o gerador de números aleatórios e amostragem",
                                  "subSteps": [
                                    "Implemente um gerador de números pseudo-aleatórios uniforme no intervalo de y.",
                                    "Gere N amostras iniciais y_i ~ Uniform[intervalo].",
                                    "Aplique técnica de amostragem por importância se K(x,y) variar muito.",
                                    "Teste a qualidade das amostras com histograma e teste de uniformidade (Kolmogorov-Smirnov).",
                                    "Ajuste semente para reprodutibilidade em depuração."
                                  ],
                                  "verification": "Histograma das amostras mostra distribuição uniforme; estatísticas descritivas batem com o intervalo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python (NumPy.random, SciPy.stats), MATLAB rand(), planilha para testes iniciais.",
                                  "tips": "Use N=1000 inicialmente para testes rápidos antes de escalar.",
                                  "learningObjective": "Dominar geração de amostras aleatórias adequadas para integração Monte Carlo.",
                                  "commonMistakes": "Gerar amostras fora do domínio ou usar distribuição errada (ex.: normal em vez de uniforme)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar iterações Monte Carlo para aproximação da solução",
                                  "subSteps": [
                                    "Calcule estimativa inicial u_0(x) = f(x) / média(K(x,y_i)).",
                                    "Itere: u_{k+1}(x) = (1/N) Σ [u_k(y_i) / p(y_i)] onde p é densidade de amostragem.",
                                    "Execute múltiplas iterações (ex.: 50-100) até convergência.",
                                    "Monitore erro médio quadrático entre iterações sucessivas.",
                                    "Paralelize computação se N grande usando loops vetorizados."
                                  ],
                                  "verification": "Erro entre u_k e u_{k+1} < threshold (ex.: 1e-4); plote convergência.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python (NumPy para vetores, Matplotlib para plots), Jupyter Notebook.",
                                  "tips": "Vectorize operações para velocidade; use tqdm para barra de progresso em loops.",
                                  "learningObjective": "Executar o algoritmo iterativo Monte Carlo para resolver equações integrais.",
                                  "commonMistakes": "Não normalizar pesos das amostras, causando viés na estimativa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar precisão, convergência e aplicar a problema de engenharia",
                                  "subSteps": [
                                    "Calcule intervalo de confiança via variância das amostras (σ/√N).",
                                    "Compare com solução analítica se disponível ou método numérico alternativo (ex.: quadratura).",
                                    "Aplique a um caso de engenharia civil: ex., modelar deflexão de vigas com kernel de Green.",
                                    "Analise sensibilidade a N e número de iterações.",
                                    "Documente resultados em relatório com gráficos."
                                  ],
                                  "verification": "Intervalo de confiança contém solução conhecida; erro < 5% em pontos chave.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Software de plotagem (Matplotlib/Plotly), referências de problemas de engenharia civil.",
                                  "tips": "Aumente N em regiões de alta variância do kernel.",
                                  "learningObjective": "Validar e contextualizar a solução Monte Carlo em aplicações reais.",
                                  "commonMistakes": "Subestimar N, levando a alta variância; ignorar autocorrelação em iterações."
                                }
                              ],
                              "practicalExample": "Em engenharia civil, aplique a uma equação de Fredholm para modelar a difusão de poluentes em solo: K(x,y)=exp(-|x-y|/λ), f(x)=concentração inicial. Gere 10.000 amostras y_i em [0,10], itere 100 vezes para estimar u(x), a concentração ao longo do tempo, validando contra simulação finita.",
                              "finalVerifications": [
                                "A solução u(x) converge monotonicamente com iterações.",
                                "Intervalo de confiança diminui com √N.",
                                "Erro relativo < 2% comparado a método exato em 80% dos pontos.",
                                "Gráficos mostram suavidade física esperada para o problema.",
                                "Código roda em <5 minutos para N=10k.",
                                "Resultados reprodutíveis com mesma semente."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro médio <1e-3.",
                                "Eficiência: Tempo de computação escalável com N.",
                                "Correção matemática: Normalização e amostragem adequadas.",
                                "Validação: Comparação com benchmarks.",
                                "Documentação: Código comentado e relatório claro.",
                                "Aplicação contextual: Ligação relevante a engenharia civil."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Amostragem e intervalos de confiança.",
                                "Programação Computacional: Implementação numérica em Python/MATLAB.",
                                "Análise Numérica: Comparação com métodos determinísticos.",
                                "Engenharia Civil: Modelagem de problemas como difusão ou vibrações."
                              ],
                              "realWorldApplication": "Na engenharia civil, usado para aproximar respostas em estruturas sob cargas estocásticas, como previsão de falhas em barragens por infiltração probabilística ou otimização de fundações em solos heterogêneos, onde soluções analíticas são inviáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.6",
                    "name": "Aplicações do Monte Carlo em Engenharia Civil",
                    "description": "Simulações de incertezas em estruturas e processos estocásticos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.6.1",
                        "name": "Análise de Confiabilidade Estrutural",
                        "description": "Aplicação do método Monte Carlo para simular incertezas em cargas, materiais e geometria de estruturas civis, calculando probabilidades de falha e fatores de segurança.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.6.1.1",
                            "name": "Modelar incertezas em parâmetros estruturais",
                            "description": "Identificar e quantificar variáveis aleatórias como resistência do concreto, módulo de elasticidade e cargas vivas, definindo distribuições probabilísticas adequadas (normal, lognormal).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar parâmetros estruturais sujeitos a incertezas",
                                  "subSteps": [
                                    "Revise o projeto estrutural para listar parâmetros como resistência do concreto (f_c), módulo de elasticidade (E), cargas vivas (Q) e cargas mortas (G).",
                                    "Classifique cada parâmetro quanto à fonte de incerteza: variabilidade material, fabricação, condições ambientais ou modelagem.",
                                    "Consulte normas como ABNT NBR 6118 ou Eurocode para identificar quais parâmetros são tipicamente aleatórios.",
                                    "Documente faixas típicas de variação baseadas em literatura (ex: CV de 15-25% para f_c).",
                                    "Crie uma tabela inicial com parâmetro, tipo de incerteza e razões para modelagem probabilística."
                                  ],
                                  "verification": "Tabela completa com pelo menos 4 parâmetros identificados e justificados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Normas técnicas (NBR 6118, Eurocode)",
                                    "Literatura de engenharia estrutural",
                                    "Planilha Excel ou Google Sheets"
                                  ],
                                  "tips": "Priorize parâmetros com maior impacto na confiabilidade via análise de sensibilidade preliminar.",
                                  "learningObjective": "Reconhecer e catalogar fontes de incerteza em parâmetros estruturais.",
                                  "commonMistakes": [
                                    "Ignorar incertezas em cargas dinâmicas",
                                    "Confundir variabilidade inerente com erros de medição"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e analisar dados estatísticos dos parâmetros",
                                  "subSteps": [
                                    "Busque dados experimentais de bancos como fib Model Code ou relatórios de ensaios (média, desvio padrão, assimetria).",
                                    "Calcule estatísticas descritivas: média (μ), desvio padrão (σ), coeficiente de variação (CV = σ/μ).",
                                    "Realize testes de normalidade (Kolmogorov-Smirnov) ou QQ-plots para dados iniciais.",
                                    "Compile histogramas para visualizar distribuições empíricas de f_c, E e Q.",
                                    "Ajuste para dados truncados ou censurados comuns em ensaios de concreto."
                                  ],
                                  "verification": "Relatório com estatísticas calculadas e gráficos para cada parâmetro.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados de ensaios (ex: UniBridges database)",
                                    "Software: Python (scipy.stats), R ou Excel",
                                    "Biblioteca de dados estruturais"
                                  ],
                                  "tips": "Use amostras grandes (>30) para confiabilidade; complemente com literatura se dados próprios forem escassos.",
                                  "learningObjective": "Extrair e resumir evidências estatísticas para quantificar incertezas.",
                                  "commonMistakes": [
                                    "Usar médias determinísticas sem CV",
                                    "Não tratar outliers em dados de campo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e parametrizar distribuições probabilísticas adequadas",
                                  "subSteps": [
                                    "Avalie candidatas: normal para E e Q simétricos; lognormal para f_c (positiva e assimétrica).",
                                    "Estime parâmetros via MLE (Maximum Likelihood Estimation) ou momentos (μ, σ).",
                                    "Compare fits com testes (AIC, BIC) e gráficos de densidade superposta.",
                                    "Defina suporte (ex: f_c > 0) e hiperparâmetros para lognormal (μ_ln, σ_ln).",
                                    "Gere 1000 amostras simuladas para validar momentos da distribuição escolhida."
                                  ],
                                  "verification": "Lista de distribuições finais com parâmetros estimados e métricas de ajuste (ex: KS p-value > 0.05).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python: numpy, scipy.stats, matplotlib",
                                    "R: fitdistrplus package",
                                    "Tabelas de normas probabilísticas"
                                  ],
                                  "tips": "Prefira lognormal para propriedades de materiais com cauda direita; teste sensibilidade a parâmetros.",
                                  "learningObjective": "Escolher e calibrar distribuições que capturam realismo da incerteza.",
                                  "commonMistakes": [
                                    "Forçar normal em dados assimétricos",
                                    "Ignorar correlações entre parâmetros como f_c e E"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e documentar o modelo de incerteza",
                                  "subSteps": [
                                    "Simule Monte Carlo com 10^4 runs e compare CDF empírica vs. teórica.",
                                    "Realize análise de sensibilidade: variação no risco de falha ao alterar distribuições.",
                                    "Documente suposições, limitações (ex: independência) e referências.",
                                    "Teste convergência gerando amostras e verificando estabilidade de momentos.",
                                    "Prepare script reprodutível para geração de amostras aleatórias."
                                  ],
                                  "verification": "Script validado gerando amostras com momentos matching dados reais (±5%).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python para Monte Carlo",
                                    "Software de simulação (MATLAB ou OpenSees)",
                                    "Documentação template"
                                  ],
                                  "tips": "Inclua seed para reprodutibilidade; valide contra casos benchmark da literatura.",
                                  "learningObjective": "Garantir robustez e reprodutibilidade do modelo probabilístico.",
                                  "commonMistakes": [
                                    "Não validar fit com simulações",
                                    "Subestimar caudas extremas em lognormal"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma laje de concreto armado de 200m², modele f_c ~ Lognormal(μ_ln=4.1, σ_ln=0.15) baseado em CV=18%, E ~ Normal(30GPa, 4.5GPa) e Q ~ Gumbel(5kN/m², 1.2kN/m²). Gere 10^5 amostras para input em análise Monte Carlo de deslocamento máximo.",
                              "finalVerifications": [
                                "Estatísticas simuladas (μ, σ, skewness) coincidem com dados reais (±10%).",
                                "Gráficos QQ e histogramas mostram bom fit visual.",
                                "Testes de bondade de ajuste (KS, AD) aprovados (p>0.05).",
                                "Análise de sensibilidade confirma impacto dominante de f_c.",
                                "Script gera amostras reprodutíveis e eficientes.",
                                "Documentação inclui normas e referências usadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pelo menos 4 parâmetros relevantes (peso: 20%).",
                                "Qualidade dos dados e estatísticas calculadas (peso: 25%).",
                                "Adequação das distribuições escolhidas com justificativa quantitativa (peso: 30%).",
                                "Validação completa via simulação e sensibilidade (peso: 15%).",
                                "Clareza e completude da documentação (peso: 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência bayesiana e testes de hipóteses para fits.",
                                "Programação: Implementação em Python/R para MLE e Monte Carlo.",
                                "Física/Mecânica: Compreensão de propriedades materiais e cargas.",
                                "Gestão de Riscos: Integração com análise de confiabilidade.",
                                "Matemática Computacional: Geração de números aleatórios e integração numérica."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou edifícios altos, como a Ponte Rio-Niterói, modelar incertezas em f_c e ventos via Monte Carlo garante fatores de segurança calibrados probabilisticamente, reduzindo sobredimensionamento em 10-20% e otimizando custos sem comprometer a confiabilidade (β>3.8)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.6.1.2",
                            "name": "Implementar simulação Monte Carlo para falha estrutural",
                            "description": "Gerar amostras aleatórias usando geradores de números pseudo-aleatórios e avaliar o estado limite de colapso em vigas ou pilares, contando o número de simulações que excedem o critério de falha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo estrutural e parâmetros de entrada",
                                  "subSteps": [
                                    "Identifique o elemento estrutural (ex: viga ou pilar) e seu modelo matemático de falha.",
                                    "Defina variáveis aleatórias (ex: carga, resistência do material, geometria) com distribuições probabilísticas (normal, lognormal).",
                                    "Estabeleça o critério de falha (estado limite: tensão > resistência).",
                                    "Especifique o número de simulações (ex: 10.000).",
                                    "Documente todos os parâmetros em um dicionário ou classe."
                                  ],
                                  "verification": "Verifique se todos os parâmetros estão definidos corretamente e o modelo matemático está implementado sem erros sintáticos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (Python/Jupyter), bibliotecas NumPy e SciPy.",
                                  "tips": "Use distribuições realistas baseadas em normas como ABNT NBR 6118.",
                                  "learningObjective": "Compreender e modelar o problema de confiabilidade estrutural com variáveis estocásticas.",
                                  "commonMistakes": "Ignorar correlações entre variáveis ou usar distribuições inadequadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar gerador de números pseudo-aleatórios e amostras",
                                  "subSteps": [
                                    "Importe bibliotecas: numpy.random para geração de amostras.",
                                    "Configure sementes para reprodutibilidade (np.random.seed(42)).",
                                    "Gere matriz de amostras para todas as variáveis (ex: shape=(n_sim, n_vars)).",
                                    "Valide as amostras geradas (histograma para checar distribuições).",
                                    "Armazene amostras em array eficiente."
                                  ],
                                  "verification": "Execute código para gerar amostras e plote histogramas; confirme que seguem as distribuições pretendidas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy, Matplotlib para visualização.",
                                  "tips": "Use np.random.multivariate_normal para variáveis correlacionadas.",
                                  "learningObjective": "Dominar geração de amostras multivariadas pseudo-aleatórias.",
                                  "commonMistakes": "Não definir semente, levando a resultados irreprodutíveis; overflow em amostras extremas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver função de avaliação do estado limite",
                                  "subSteps": [
                                    "Crie função que recebe uma amostra e computa o estado limite (ex: momento fletor vs. capacidade).",
                                    "Implemente equações de mecânica estrutural (ex: σ = M*y/I para tensão).",
                                    "Defina condição de falha: se g(amostra) <= 0, falha.",
                                    "Teste função com amostras determinísticas conhecidas.",
                                    "Vetorize a função para eficiência com np.vectorize ou broadcasting."
                                  ],
                                  "verification": "Teste unitário: aplique em 10 amostras fixas e confirme saídas lógicas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python, calculadora para validação manual.",
                                  "tips": "Linearize o modelo se possível para acelerar computação.",
                                  "learningObjective": "Implementar funções de performance para análise de confiabilidade.",
                                  "commonMistakes": "Erros em fórmulas estruturais; não vetorizar, causando lentidão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulações e calcular probabilidade de falha",
                                  "subSteps": [
                                    "Aplique função de avaliação a todas as amostras em loop ou vetorizado.",
                                    "Conte número de falhas (np.sum(falhas)).",
                                    "Calcule Pf = num_falhas / n_simulacoes.",
                                    "Calcule intervalo de confiança (ex: usando binomial).",
                                    "Registre tempo de execução."
                                  ],
                                  "verification": "Confirme que Pf está entre 0 e 1, e tempo < 1min para 10k sims.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Jupyter Notebook para execução interativa.",
                                  "tips": "Use numba ou paralelismo para >100k sims.",
                                  "learningObjective": "Executar Monte Carlo em escala e estimar probabilidades.",
                                  "commonMistakes": "Dividir por zero; ignorar convergência (aumentar n_sim se var(Pf) alta)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e visualizar resultados",
                                  "subSteps": [
                                    "Gere histogramas de g() e Pf.",
                                    "Plote curvas de convergência (Pf vs. n_sim).",
                                    "Compare com analítico se possível.",
                                    "Gere relatório com Pf, IC e insights.",
                                    "Salve código e resultados."
                                  ],
                                  "verification": "Plots gerados corretamente; Pf converge com mais sims.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matplotlib/Seaborn, Pandas para dados.",
                                  "tips": "Use subplots para múltiplas visualizações.",
                                  "learningObjective": "Interpretar e comunicar resultados de Monte Carlo.",
                                  "commonMistakes": "Escalas erradas em plots; superestimar precisão sem IC."
                                }
                              ],
                              "practicalExample": "Simule falha em viga biapoiada de 5m, carga uniformemente distribuída ~N(50kN/m,10%), resistência ~Lognormal(30MPa,0.2CV), falha se tensão max > resistência. Rode 10k sims, espere Pf ~1e-3.",
                              "finalVerifications": [
                                "Código executa sem erros para 10k simulações em <2min.",
                                "Probabilidade de falha (Pf) é coerente com valores esperados (ex: 10^-3 a 10^-4).",
                                "Histogramas confirmam distribuições de entrada e g().",
                                "Intervalo de confiança de Pf é calculado e reportado.",
                                "Resultados reprodutíveis com semente fixa.",
                                "Relatório inclui interpretação e recomendações."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Pf converge corretamente com n_sim >5k.",
                                "Eficiência: Tempo de execução otimizado (vetorização/paralelismo).",
                                "Correção: Função de falha implementada com equações estruturais exatas.",
                                "Visualização: Plots claros e informativos.",
                                "Documentação: Código comentado e relatório completo.",
                                "Robustez: Trata edge cases (amostras extremas)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuições probabilísticas e intervalos de confiança.",
                                "Programação: Vetorização NumPy e otimização de código.",
                                "Mecânica dos Materiais: Estados limite e critérios de colapso.",
                                "Probabilidade: Teorema do Limite Central em Monte Carlo.",
                                "Gestão de Riscos: Aplicação em normas de segurança estrutural."
                              ],
                              "realWorldApplication": "Avaliar risco de colapso em pontes, edifícios ou barragens sob cargas variáveis (vento, sismo), auxiliando dimensionamento seguro e econômico conforme normas como Eurocode ou NBR 8681."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.6.1.3",
                            "name": "Calcular e interpretar índices de confiabilidade",
                            "description": "Estimar a probabilidade de falha (Pf) a partir da fração de simulações falhas e calcular o índice de confiabilidade β, comparando com normas como NBR 6118.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Confiabilidade Estrutural",
                                  "subSteps": [
                                    "Estudar a definição de probabilidade de falha (Pf) como a fração de estados no espaço de parâmetros que violam o critério de segurança.",
                                    "Aprender a relação entre Pf e o índice de confiabilidade β, dada por β = -Φ⁻¹(Pf), onde Φ⁻¹ é a inversa da função de distribuição normal padrão.",
                                    "Revisar os requisitos da norma NBR 6118 para valores mínimos de β em estados limite últimos (ELU) e serviço (ELS).",
                                    "Entender como o Método de Monte Carlo estima Pf através de simulações aleatórias.",
                                    "Identificar variáveis aleatórias típicas em estruturas civis, como resistência de materiais e cargas."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando Pf, β e sua relação com NBR 6118, com exemplos numéricos simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Norma NBR 6118 (PDF)",
                                    "Livro 'Reliability of Structures' ou equivalente",
                                    "Notas de aula sobre Monte Carlo"
                                  ],
                                  "tips": "Desenhe o espaço de estados (G>0 seguro, G<0 falha) para visualizar conceitos.",
                                  "learningObjective": "Dominar os fundamentos teóricos de índices de confiabilidade e seu embasamento normativo.",
                                  "commonMistakes": [
                                    "Confundir Pf com frequência de falha",
                                    "Ignorar a normalidade padrão na definição de β",
                                    "Não consultar a norma específica para contextos brasileiros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e Executar Simulações Monte Carlo",
                                  "subSteps": [
                                    "Definir um modelo estrutural simples, como uma viga biapoiada sob carga uniforme.",
                                    "Especificar distribuições probabilísticas para variáveis de entrada (ex: carga ~ Normal(μ,σ), resistência ~ Lognormal).",
                                    "Implementar gerador de números aleatórios para amostrar N=10⁵ realizações.",
                                    "Definir função de limite G (ex: G = resistência - carga * fator; falha se G ≤ 0).",
                                    "Executar simulações e registrar número de falhas (Nf)."
                                  ],
                                  "verification": "Produzir um log ou output mostrando N_total, Nf e fração inicial de falhas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com bibliotecas NumPy, SciPy e Matplotlib",
                                    "Jupyter Notebook",
                                    "Exemplo de código Monte Carlo"
                                  ],
                                  "tips": "Fixe a semente aleatória (np.random.seed(42)) para resultados reprodutíveis durante testes.",
                                  "learningObjective": "Implementar corretamente simulações Monte Carlo para análise de confiabilidade.",
                                  "commonMistakes": [
                                    "Número de simulações muito baixo (causa variância alta)",
                                    "Definição incorreta da função de limite G",
                                    "Não normalizar variáveis adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Probabilidade de Falha (Pf)",
                                  "subSteps": [
                                    "Computar Pf = Nf / N_total.",
                                    "Calcular intervalo de confiança (IC) de 95% usando aproximação normal: IC = Pf ± 1.96 * sqrt(Pf*(1-Pf)/N).",
                                    "Plotar curva de convergência de Pf em função do número de simulações.",
                                    "Verificar se Pf estabilizou (variação <1% nos últimos 20% das simulações).",
                                    "Documentar incertezas associadas à estimativa."
                                  ],
                                  "verification": "Gerar gráfico de convergência e tabela com Pf e IC precisos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python/MATLAB da simulação",
                                    "Ferramentas de visualização (Matplotlib/Excel)"
                                  ],
                                  "tips": "Para Pf muito baixa (<10^{-4}), aumente N ou use variance reduction techniques.",
                                  "learningObjective": "Estimar Pf com quantificação de incerteza a partir de dados de Monte Carlo.",
                                  "commonMistakes": [
                                    "Omitir intervalo de confiança",
                                    "Arredondar Pf prematuramente",
                                    "Não testar convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular, Interpretar e Comparar o Índice de Confiabilidade β",
                                  "subSteps": [
                                    "Calcular β = -scipy.stats.norm.ppf(Pf) ou equivalente.",
                                    "Comparar β com limites da NBR 6118 (ex: β ≥ 3,5 para ELU com vida útil 50 anos).",
                                    "Interpretar: β=3 indica Pf≈0,00135 (falha rara); discutir implicações de segurança.",
                                    "Realizar análise de sensibilidade variando parâmetros chave.",
                                    "Elaborar relatório final com Pf, β, IC e recomendações."
                                  ],
                                  "verification": "Produzir relatório PDF com cálculos, gráficos e conformidade com NBR 6118.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Biblioteca SciPy.stats",
                                    "Norma NBR 6118",
                                    "Template de relatório LaTeX/Word"
                                  ],
                                  "tips": "Use β médio do IC de Pf para uma faixa conservadora.",
                                  "learningObjective": "Interpretar β no contexto normativo e aplicar em decisões de projeto.",
                                  "commonMistakes": [
                                    "Sinal errado em β (deve ser positivo para baixa Pf)",
                                    "Comparar com normas não aplicáveis (ex: ISO em vez de NBR)",
                                    "Ignorar sensibilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma coluna de concreto armado em edifício residencial: simule 100.000 cenários com variabilidade na carga axial (Normal(1000,150 kN)) e resistência à compressão (Lognormal(30,5 MPa)). Obtenha Nf=135, Pf=0.00135, β=3.02. Como β < 3.5 (NBR 6118 ELU), redimensione a seção transversal.",
                              "finalVerifications": [
                                "Pf calculado corretamente como Nf/N_total com IC reportado.",
                                "β computado via inversa normal padrão com precisão numérica.",
                                "Interpretação inclui comparação explícita com NBR 6118.",
                                "Gráficos de convergência e sensibilidade presentes.",
                                "Relatório documenta todas as premissas e código fonte.",
                                "Conclusões sobre aceitabilidade do projeto."
                              ],
                              "assessmentCriteria": [
                                "Precisão de Pf e β (erro <0.5%).",
                                "Correta implementação e verificação de Monte Carlo.",
                                "Interpretação normativa alinhada com NBR 6118.",
                                "Relatório claro, com visualizações e análise de incertezas.",
                                "Análise de sensibilidade realizada.",
                                "Código limpo e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: Estimativa binomial e funções quantílicas.",
                                "Programação Computacional: Simulações numéricas em Python/SciPy.",
                                "Gestão de Riscos: Avaliação quantitativa de falhas em engenharia.",
                                "Materiais e Estruturas: Modelagem de variáveis aleatórias em concreto e aço.",
                                "Normas Técnicas: Aplicação de ABNT em projetos civis."
                              ],
                              "realWorldApplication": "Em projetos de pontes, edifícios e barragens, onde o cálculo de β via Monte Carlo garante que a probabilidade de falha estrutural seja inferior a 10^{-3} a 10^{-5} durante a vida útil, atendendo NBR 6118 e evitando colapsos como o de estruturas subdimensionadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.6.2",
                        "name": "Simulação de Propriedades de Materiais Estocásticos",
                        "description": "Uso do Monte Carlo para modelar variabilidade em solos, concreto e aço, simulando respostas como assentamentos ou deformações em fundações e elementos estruturais.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.6.2.1",
                            "name": "Definir distribuições para propriedades geotécnicas",
                            "description": "Atribuir distribuições probabilísticas a parâmetros como ângulo de atrito, coesão e módulo de cisalhamento em solos, baseando-se em ensaios de campo e laboratoriais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e Pré-processamento de Dados Geotécnicos",
                                  "subSteps": [
                                    "Reúna dados de ensaios de campo (SPT, CPT) e laboratoriais (triaxial, cisalhamento direto) para parâmetros como ângulo de atrito (φ), coesão (c) e módulo de cisalhamento (G).",
                                    "Registre valores médios, desvios padrão e número de amostras de múltiplos pontos do sítio.",
                                    "Limpe os dados: remova outliers usando boxplot ou teste de Grubbs (p<0.05).",
                                    "Calcule estatísticas descritivas: média, mediana, assimetria e curtose.",
                                    "Transforme dados se necessário (log para distribuições assimétricas)."
                                  ],
                                  "verification": "Tabela de dados limpos com estatísticas descritivas gerada e outliers documentados.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Relatórios de ensaios de campo/laboratório",
                                    "Software: Excel, R ou Python (pandas)",
                                    "Normas ABNT NBR 6484 e 11598"
                                  ],
                                  "tips": "Priorize dados de ensaios representativos do perfil do solo; documente fontes para rastreabilidade.",
                                  "learningObjective": "Preparar dados geotécnicos confiáveis para modelagem probabilística.",
                                  "commonMistakes": [
                                    "Incluir dados não representativos do sítio",
                                    "Ignorar transformações para normalizar dados assimétricos",
                                    "Não documentar remoção de outliers"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Análise Exploratória e Seleção de Distribuição",
                                  "subSteps": [
                                    "Plote histogramas, boxplots e QQ-plots para cada parâmetro (φ, c, G).",
                                    "Avalie assimetria: se skew >1, considere lognormal ou gamma; se simétrico, normal.",
                                    "Use testes preliminares: Shapiro-Wilk para normalidade (p>0.05 indica normal).",
                                    "Considere conhecimento de domínio: coesão frequentemente lognormal, φ normal.",
                                    "Selecione 2-3 candidatas por parâmetro baseadas em literatura (ex: Phoon & Kulhawy, 1999)."
                                  ],
                                  "verification": "Relatório com plots e justificativa para distribuições candidatas selecionadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software: R (fitdistrplus) ou Python (scipy.stats, matplotlib)",
                                    "Literatura: 'Reliability-Based Design in Geotechnical Engineering'"
                                  ],
                                  "tips": "Visualize sempre antes de testes; plots guiam melhor que testes isolados.",
                                  "learningObjective": "Identificar distribuições adequadas via análise exploratória e expertise de domínio.",
                                  "commonMistakes": [
                                    "Assumir normal sem verificação",
                                    "Ignorar conhecimento geotécnico específico",
                                    "Selecionar distribuição sem plots visuais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajuste de Parâmetros da Distribuição",
                                  "subSteps": [
                                    "Ajuste parâmetros via Máxima Verossimilhança (MLE) para cada candidata.",
                                    "Calcule intervalos de confiança (95%) para média e desvio padrão.",
                                    "Compare AIC/BIC entre candidatas; menor valor indica melhor ajuste.",
                                    "Gere amostras simuladas e compare com dados empíricos via histogramas sobrepostos.",
                                    "Documente valores finais: ex. φ ~ Normal(25°, 4°)."
                                  ],
                                  "verification": "Tabela com parâmetros ajustados, AIC/BIC e plots de ajuste para cada parâmetro.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python (scipy.stats.fit) ou R (fitdist)",
                                    "Biblioteca NumPy para simulações"
                                  ],
                                  "tips": "Use MLE para robustez; evite momentos para dados pequenos (n<30).",
                                  "learningObjective": "Estimar parâmetros probabilísticos de forma estatisticamente rigorosa.",
                                  "commonMistakes": [
                                    "Usar média/desvio empírico sem ajuste",
                                    "Não comparar múltiplas distribuições",
                                    "Ignorar limites físicos (ex: φ>0)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação e Testes de Ajuste",
                                  "subSteps": [
                                    "Aplique testes de goodness-of-fit: Kolmogorov-Smirnov (KS, p>0.05), Anderson-Darling.",
                                    "Gere QQ-plots e P-P plots; verifique linearidade.",
                                    "Simule Monte Carlo (10k amostras) e compare percentis (5%, 50%, 95%) com dados.",
                                    "Avalie sensibilidade: varie parâmetros ±10% e cheque impacto em estatísticas.",
                                    "Conclua com distribuição final e razões para rejeição de alternativas."
                                  ],
                                  "verification": "Relatório final com resultados de testes (p-values), plots e distribuição selecionada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "R (goftest) ou Python (scipy.stats.kstest)",
                                    "Literatura de validação probabilística"
                                  ],
                                  "tips": "Combine testes formais com visuais; rejeite se múltiplos falham.",
                                  "learningObjective": "Validar distribuições para garantir representatividade em simulações.",
                                  "commonMistakes": [
                                    "Aceitar ajuste fraco só por p>0.05 em um teste",
                                    "Não simular para verificação prática",
                                    "Omitir sensibilidade a parâmetros"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um solo arenoso em fundação de edifício: dados de 20 ensaios triaxiais dão φ com média 32°, desvio 3.5°. Análise mostra normalidade (Shapiro p=0.12); ajuste MLE: Normal(32°, 3.5°). Validação KS p=0.08. Use em Monte Carlo para capacidade de carga.",
                              "finalVerifications": [
                                "Distribuições selecionadas ajustam dados (todos KS p>0.05).",
                                "Parâmetros com IC 95% razoáveis e limites físicos respeitados.",
                                "Plots QQ/P-P lineares para todos parâmetros.",
                                "Simulações Monte Carlo reproduzem estatísticas empíricas (percentis ±5%).",
                                "Documentação completa com fontes e justificativas.",
                                "Sensibilidade testada sem mudanças drásticas."
                              ],
                              "assessmentCriteria": [
                                "Correta coleta e limpeza de dados (sem outliers injustificados).",
                                "Seleção de distribuições baseada em análise + domínio (≥2 candidatas testadas).",
                                "Ajuste preciso via MLE com comparação AIC/BIC.",
                                "Validação robusta (testes + plots + simulações).",
                                "Relatório claro e acionável para Monte Carlo.",
                                "Consideração de variabilidade espacial em solos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Ajuste de distribuições e testes de hipóteses.",
                                "Engenharia de Solos: Interpretação de ensaios SPT/CPT/triaxial.",
                                "Probabilidade: Geração aleatória e simulação Monte Carlo.",
                                "Programação: Implementação em Python/R para análise automatizada.",
                                "Gestão de Riscos: Análise de confiabilidade em projetos civis."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para dimensionamento de estacas ou taludes, onde variabilidade de φ e c determina fatores de segurança, evitando super ou sub-dimensionamento em projetos de infraestrutura como pontes e barragens."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.6.2.2",
                            "name": "Simular capacidade de carga de fundações",
                            "description": "Executar simulações Monte Carlo para calcular a capacidade última de estacas ou sapatas, avaliando a variabilidade na resposta e determinando fatores de segurança probabilísticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo de capacidade de carga e identificar variáveis estocásticas",
                                  "subSteps": [
                                    "Estabelecer a fórmula de capacidade última para estacas (ex: Q_ult = Q_ponta + Q_atrito) ou sapatas (ex: Q_ult = c*Nc*B*L + γ*D*Nq*B*L + 0.5*γ*B*Nγ*B*L).",
                                    "Identificar variáveis aleatórias: resistência do solo (c, φ), unidade de peso (γ), dimensões geométricas (diâmetro, comprimento).",
                                    "Escolher distribuições probabilísticas adequadas (ex: normal para γ, lognormal para c, beta para φ).",
                                    "Definir médias, desvios padrão e coeficientes de variação baseados em normas como ABNT NBR 6122.",
                                    "Documentar o modelo em um diagrama ou pseudocódigo."
                                  ],
                                  "verification": "Verificar se o modelo matemático está corretamente formulado e todas as variáveis estocásticas foram listadas com suas distribuições em um documento ou notebook.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Notebook Jupyter ou Python IDE, normas técnicas (NBR 6122), calculadora científica.",
                                  "tips": "Use referências de literatura como Bowles ou Das para fórmulas padrão de fundações.",
                                  "learningObjective": "Compreender e modelar deterministicamente a capacidade de carga, incorporando variabilidade estocástica.",
                                  "commonMistakes": "Ignorar correlações entre variáveis do solo (ex: c e φ); escolher distribuições inadequadas sem justificativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar geradores de números aleatórios e distribuições probabilísticas",
                                  "subSteps": [
                                    "Implementar em Python usando bibliotecas numpy.random e scipy.stats para gerar amostras (ex: np.random.lognormal para c).",
                                    "Definir sementes para reprodutibilidade (np.random.seed(42)).",
                                    "Gerar histogramas para validar as distribuições geradas contra as teóricas.",
                                    "Testar 1000 amostras iniciais para cada variável e calcular estatísticas descritivas (média, variância).",
                                    "Criar uma função que retorne vetores de parâmetros aleatórios para N simulações."
                                  ],
                                  "verification": "Executar script e confirmar que histogramas e estatísticas coincidem com parâmetros definidos (erro < 5%).",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python com numpy, scipy, matplotlib; ambiente Jupyter.",
                                  "tips": "Use scipy.stats para distribuições avançadas e plotar QQ-plots para validação visual.",
                                  "learningObjective": "Dominar geração de variáveis aleatórias realistas para modelagem estocástica em engenharia.",
                                  "commonMistakes": "Não definir semente, levando a resultados irreprodutíveis; gerar amostras insuficientes para validação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações Monte Carlo para capacidade de carga",
                                  "subSteps": [
                                    "Definir número de simulações (ex: 10.000 runs para convergência).",
                                    "Implementar loop principal: para cada run, gerar parâmetros aleatórios e calcular Q_ult.",
                                    "Armazenar resultados em array (capacidades simuladas).",
                                    "Monitorar progresso com barras de progresso (tqdm) e salvar checkpoints.",
                                    "Calcular capacidade característica (ex: 5% quantil para estado limite último)."
                                  ],
                                  "verification": "Verificar convergência plotando média móvel de Q_ult vs. número de runs (estabiliza após 5000).",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com numpy, tqdm; hardware com pelo menos 8GB RAM.",
                                  "tips": "Vetorize cálculos com numpy para acelerar (evite loops puros).",
                                  "learningObjective": "Implementar eficientemente simulações Monte Carlo para problemas de engenharia.",
                                  "commonMistakes": "Número insuficiente de runs causando variabilidade alta; overflow numérico em fórmulas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e determinar fatores de segurança probabilísticos",
                                  "subSteps": [
                                    "Calcular estatísticas: média, desvio padrão, coeficiente de variação, histogramas de Q_ult.",
                                    "Determinar fatores de segurança probabilísticos (ex: FS_prob = média(Q_ult)/Q_caracteristica com probabilidade de falha < 10^-3).",
                                    "Plotar distribuições de Q_ult e curvas de confiabilidade.",
                                    "Comparar com abordagens determinísticas e discutir implicações.",
                                    "Gerar relatório com conclusões e recomendações de design."
                                  ],
                                  "verification": "Produzir gráficos e tabela de estatísticas; FS_prob deve ser consistente com literatura (tipicamente 2.5-3.5).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python com matplotlib, seaborn, scipy.stats; LaTeX ou Markdown para relatório.",
                                  "tips": "Use bootstrap para intervalos de confiança nas estatísticas.",
                                  "learningObjective": "Interpretar saídas Monte Carlo para tomada de decisões em projeto estrutural.",
                                  "commonMistakes": "Interpretar erroneamente quantis (ex: confundir 5% com média); ignorar caudas da distribuição."
                                }
                              ],
                              "practicalExample": "Simule a capacidade de carga de uma estaca de concreto armado de 40cm diâmetro e 12m comprimento em solo argiloso (c ~ lognormal(50kPa, CV=0.3), φ ~ normal(25°, CV=0.15), γ ~ normal(18kN/m³, CV=0.1)). Execute 10.000 runs e determine o FS probabilístico para garantir P(falha) < 0.1%.",
                              "finalVerifications": [
                                "O script roda sem erros e produz 10.000 capacidades simuladas.",
                                "Histogramas das variáveis e Q_ult validam as distribuições assumidas.",
                                "Convergência confirmada com plot de média vs. runs.",
                                "FS probabilístico calculado corretamente (ex: 2.8 com P(Q_ult < Q_carga) = 5%).",
                                "Relatório inclui gráficos, estatísticas e comparação determinística.",
                                "Código é reprodutível com semente fixa."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo de capacidade de carga (alinhado com normas).",
                                "Correta implementação de distribuições e geração aleatória.",
                                "Eficiência e convergência da simulação Monte Carlo.",
                                "Análise estatística robusta com visualizações claras.",
                                "Interpretação correta de resultados para fatores de segurança.",
                                "Qualidade do relatório e documentação do código."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: Distribuições, quantis e análise de risco.",
                                "Programação Computacional: Python, vetoração e visualização de dados.",
                                "Mecânica dos Solos: Modelos de fundações e propriedades estocásticas.",
                                "Gestão de Riscos: Abordagens probabilísticas em projetos de engenharia."
                              ],
                              "realWorldApplication": "Em projetos de edifícios altos ou pontes, simulações Monte Carlo otimizam o dimensionamento de fundações considerando variabilidade geotécnica, reduzindo sobredimensionamento (economia de 10-20%) e aumentando segurança contra falhas raras, conforme usado em normas Eurocode 7 ou projetos da Petrobras."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.6.2.3",
                            "name": "Analisar histogramas de resultados simulados",
                            "description": "Gerar e interpretar histogramas e curvas de densidade dos resultados de simulações, identificando percentis para dimensionamento conservador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados simulados e gerar histogramas e curvas de densidade",
                                  "subSteps": [
                                    "Colete ou gere um conjunto de dados simulados via Monte Carlo (ex: 10.000 amostras de resistência à compressão de concreto estocástico).",
                                    "Selecione a ferramenta de análise (Python com Matplotlib/Seaborn, R ou Excel).",
                                    "Plote o histograma com bins adequados (regra de Sturges ou Freedman-Diaconis).",
                                    "Sobreponha a curva de densidade kernel (KDE) estimada.",
                                    "Ajuste eixos, rótulos e legenda para clareza visual."
                                  ],
                                  "verification": "Verifique se o histograma e KDE são exibidos corretamente sem erros de plotagem e com dados normalizados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software Python/R com bibliotecas (numpy, matplotlib, seaborn ou ggplot2)",
                                    "Dataset simulado (CSV ou array)"
                                  ],
                                  "tips": "Use bins = int(sqrt(n)) para n amostras; normalize para facilitar comparação.",
                                  "learningObjective": "Dominar a visualização inicial de distribuições simuladas.",
                                  "commonMistakes": [
                                    "Poucos bins levando a histograma irregular",
                                    "Escala inadequada nos eixos",
                                    "Omitir KDE que revela assimetrias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar características descritivas do histograma",
                                  "subSteps": [
                                    "Identifique o centro (média, mediana) e compare com o histograma.",
                                    "Avalie a dispersão (desvio padrão, quartis) e simetria/assimetria.",
                                    "Detecte multimodalidade, caudas pesadas ou outliers.",
                                    "Calcule estatísticas resumidas (skewness, kurtosis).",
                                    "Anote observações qualitativas sobre a forma da distribuição."
                                  ],
                                  "verification": "Liste estatísticas chave e descreva a forma em 3-5 frases coerentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código para estatísticas descritivas (pandas.describe() ou summary() no R)",
                                    "Gráfico gerado no step 1"
                                  ],
                                  "tips": "Use boxplot auxiliar para confirmar quartis; skewness >1 indica assimetria direita.",
                                  "learningObjective": "Interpretar visual e quantitativamente distribuições empíricas.",
                                  "commonMistakes": [
                                    "Confundir mediana com média em distribuições assimétricas",
                                    "Ignorar caudas que afetam dimensionamento",
                                    "Não quantificar dispersão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e calcular percentis chave",
                                  "subSteps": [
                                    "Defina percentis relevantes para conservadorismo (ex: 5%, 50%, 95%).",
                                    "Calcule percentis usando funções (numpy.percentile() ou quantile() no R).",
                                    "Marque percentis no histograma/KDE com linhas verticais.",
                                    "Compare percentis com normas de engenharia (ex: ACI para concreto).",
                                    "Documente valores e incertezas (intervalos de confiança bootstrap)."
                                  ],
                                  "verification": "Tabela com percentis calculados e plot atualizado com marcações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Funções de percentil no software",
                                    "Histograma do step 1"
                                  ],
                                  "tips": "Para conservadorismo, foque em percentis baixos (ex: P5 para mínima); use 10k+ amostras para precisão.",
                                  "learningObjective": "Extrair quantis probabilísticos de simulações para análise de risco.",
                                  "commonMistakes": [
                                    "Usar percentis errados (ex: P95 como conservador)",
                                    "Amostras insuficientes levando a percentis instáveis",
                                    "Não marcar visualmente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados para dimensionamento conservador",
                                  "subSteps": [
                                    "Relacione percentis a critérios de projeto (ex: usar P5 para dimensionar seção).",
                                    "Avalie impacto da variabilidade na segurança estrutural.",
                                    "Compare com abordagens determinísticas e discuta vantagens.",
                                    "Recomende fatores de segurança baseados em percentis.",
                                    "Gere relatório com conclusões e sugestões de refinamento."
                                  ],
                                  "verification": "Relatório de 1 página com interpretação, dimensionamento proposto e justificativa probabilística.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Normas de engenharia (ex: Eurocode, ACI)",
                                    "Resultados dos steps anteriores"
                                  ],
                                  "tips": "Dimensionamento conservador: use percentil baixo + fator de segurança; sensibilidade em variância.",
                                  "learningObjective": "Aplicar análise probabilística em decisões de engenharia civil.",
                                  "commonMistakes": [
                                    "Ignorar contexto de aplicação",
                                    "Sobre-dimensionar sem justificar risco",
                                    "Não comparar com determinístico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em simulação Monte Carlo de resistência à compressão de concreto (μ=30 MPa, CV=15%), gere 20k amostras. Plote histograma/KDE, identifique P5=22 MPa, e dimensione uma coluna para carga onde determinístico usaria 30 MPa, mas conservador usa 22 MPa com FS=1.5, reduzindo seção em 20%.",
                              "finalVerifications": [
                                "Histograma e KDE plotados corretamente com marcações de percentis.",
                                "Estatísticas descritivas e percentis calculados com precisão (±1%).",
                                "Interpretação inclui análise de risco e comparação determinística/probabilística.",
                                "Relatório final com dimensionamento conservador proposto.",
                                "Gráficos salvos e reproduzíveis.",
                                "Conclusões alinhadas ao contexto de materiais estocásticos em engenharia civil."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração e visualização (bins, KDE suave).",
                                "Correção na identificação de percentis e estatísticas (erro <5%).",
                                "Profundidade da interpretação qualitativa/quantitativa.",
                                "Relevância ao dimensionamento conservador com justificativa.",
                                "Clareza e completude do relatório/visualizações.",
                                "Uso adequado de amostras e métodos numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuições empíricas e quantis.",
                                "Programação: Manipulação de dados e visualização (Python/R).",
                                "Probabilidade: Análise de risco e Monte Carlo.",
                                "Engenharia Mecânica: Variabilidade em materiais compósitos.",
                                "Gestão de Projetos: Decisões baseadas em incerteza."
                              ],
                              "realWorldApplication": "Em projetos de estruturas civis, como pontes ou edifícios, analisar histogramas de simulações Monte Carlo de propriedades estocásticas (ex: resistência de solo ou concreto) permite dimensionamento conservador via percentis baixos (P1-P10), otimizando custos e elevando segurança contra falhas raras, conforme normas como Eurocode 0 (princípio dos estados limite)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.6.3",
                        "name": "Modelagem de Processos Estocásticos em Hidrologia",
                        "description": "Aplicação do método Monte Carlo em simulações de eventos hidrológicos incertos, como vazões de cheias e precipitações, para dimensionamento de barragens e canais.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.6.3.1",
                            "name": "Gerar séries sintéticas de precipitação",
                            "description": "Usar Monte Carlo com processos estocásticos como chuva de Poisson ou Markov para gerar sequências longas de dados pluviométricos, superando limitações de registros históricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e parametrizar o modelo estocástico",
                                  "subSteps": [
                                    "Estudar os processos estocásticos adequados: chuva de Poisson para eventos discretos e cadeia de Markov para dependências temporais.",
                                    "Analisar dados históricos de precipitação para estimar parâmetros como taxa λ (média de precipitação) e probabilidades de transição.",
                                    "Ajustar o modelo para sazonalidade, dividindo em períodos úmidos/secos.",
                                    "Testar ajuste inicial com histogramas e funções de autocorrelação.",
                                    "Documentar os parâmetros escolhidos (ex: λ_dia_seco = 0.1, λ_dia_chuvoso = 10mm)."
                                  ],
                                  "verification": "Parâmetros estimados reproduzem estatísticas básicas dos dados reais (média, variância, frequência de eventos).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Dados históricos de precipitação (ex: INMET)",
                                    "Python (bibliotecas numpy, scipy.stats)",
                                    "R (pacote fitdistrplus)"
                                  ],
                                  "tips": "Use máxima verossimilhança para estimar λ; considere clustering de eventos para realismo.",
                                  "learningObjective": "Compreender e parametrizar modelos Poisson e Markov para precipitação.",
                                  "commonMistakes": [
                                    "Ignorar dependências seriais (autocorrelação)",
                                    "Não ajustar por sazonalidade",
                                    "Usar λ única sem distinção seco/chuvoso"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o gerador de séries sintéticas",
                                  "subSteps": [
                                    "Codificar o processo de Poisson: gerar tempos inter-evento exponenciais e magnitudes gamma.",
                                    "Para Markov: definir matriz de transição (seco para chuvoso, etc.) e simular estados sequenciais.",
                                    "Implementar função para gerar uma única realização de N dias/anos.",
                                    "Adicionar ruído ou variações para múltiplos cenários climáticos.",
                                    "Testar a função com séries curtas e plotar resultados iniciais."
                                  ],
                                  "verification": "Função gera séries sem erros e produz saídas plausíveis (ex: plot de precipitação diária).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python (numpy.random, pandas)",
                                    "Jupyter Notebook para prototipagem",
                                    "Exemplos de código de simulação estocástica"
                                  ],
                                  "tips": "Use np.random.exponential para inter-eventos e np.random.gamma para intensidades.",
                                  "learningObjective": "Desenvolver código para simular processos estocásticos em precipitação.",
                                  "commonMistakes": [
                                    "Gerar eventos independentes sem Markov para persistência",
                                    "Escala errada em magnitudes",
                                    "Loops ineficientes para séries longas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações Monte Carlo",
                                  "subSteps": [
                                    "Configurar Monte Carlo: gerar M=1000 realizações de séries longas (ex: 100 anos).",
                                    "Paralelizar simulações para eficiência (usar multiprocessing ou vectorização).",
                                    "Calcular estatísticas agregadas: percentis, durações de secas, máximos anuais.",
                                    "Armazenar e visualizar ensemble (histogramas, boxplots).",
                                    "Ajustar hiperparâmetros se estatísticas divergem."
                                  ],
                                  "verification": "Ensemble gerado com M realizações e estatísticas computadas sem falhas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python (numpy, pandas, matplotlib, joblib para paralelismo)",
                                    "Computador com >8GB RAM"
                                  ],
                                  "tips": "Vectorize onde possível para acelerar; salve resultados em HDF5 para grandes ensembles.",
                                  "learningObjective": "Aplicar Monte Carlo para superar limitações de dados históricos.",
                                  "commonMistakes": [
                                    "Número insuficiente de realizações (M<100)",
                                    "Não paralelizar, causando lentidão",
                                    "Ignorar variância entre realizações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e analisar as séries sintéticas",
                                  "subSteps": [
                                    "Comparar estatísticas sintéticas vs. históricas: média, variância, KS-test, QQ-plots.",
                                    "Avaliar eventos extremos: retornos de máximos, durações de secas.",
                                    "Realizar testes de adesão (Kolmogorov-Smirnov, chi-quadrado).",
                                    "Visualizar: séries temporais sobrepostas, espectros de potência.",
                                    "Documentar relatório com conclusões e sugestões de refinamento."
                                  ],
                                  "verification": "Testes estatísticos mostram p-valor >0.05, indicando similaridade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python (scipy.stats para testes, seaborn para plots)",
                                    "Dados históricos para benchmark"
                                  ],
                                  "tips": "Use múltiplos testes; foque em momentos e dependências temporais.",
                                  "learningObjective": "Validar qualidade de séries sintéticas geradas.",
                                  "commonMistakes": [
                                    "Apenas visual, sem testes quantitativos",
                                    "Comparar apenas médias",
                                    "Não checar extremos"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados históricos de São Paulo (INMET, 1961-2020), estime λ=2.5mm/dia para Poisson composto. Gere 1000 séries de 100 anos diários via Monte Carlo com Markov (P(seco|seco)=0.9). Valide com KS-test (p>0.1) e use para simular enchentes recorrentes.",
                              "finalVerifications": [
                                "Série sintética reproduz distribuição empírica histórica (KS-test aceito).",
                                "Estatísticas de extremos (máximos anuais) coincidem em 95% CI.",
                                "Persistência de eventos úmidos/secos similar (autocorrelação lag-1).",
                                "Ensemble cobre variabilidade climática (percentis 5-95%).",
                                "Código executa em <10min para 1000 realizações.",
                                "Relatório documenta parâmetros e validações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na estimação de parâmetros (erro <10%).",
                                "Eficiência computacional do Monte Carlo (tempo/M realização).",
                                "Qualidade da validação estatística (múltiplos testes passados).",
                                "Realismo das séries em eventos extremos e sazonais.",
                                "Clareza do código e documentação.",
                                "Capacidade de adaptar para cenários futuros (ex: +20% λ)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência, testes de hipótese, processos estocásticos.",
                                "Programação: Simulação numérica, paralelismo em Python/R.",
                                "Hidrologia: Modelagem de bacias, análise de secas/enchentes.",
                                "Engenharia Civil: Dimensionamento hidráulico probabilístico.",
                                "Mudanças Climáticas: Geração de cenários futuros."
                              ],
                              "realWorldApplication": "Geração de séries longas para dimensionamento de reservatórios, previsão de déficits hídricos em sistemas urbanos (ex: Sistema Cantareira), avaliação de riscos de enchentes em projetos de drenagem, e planejamento agrícola sob variabilidade climática."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.6.3.2",
                            "name": "Simular vazões máximas em bacias hidrográficas",
                            "description": "Modelar transformações chuva-vazão com parâmetros aleatórios e aplicar Monte Carlo para estimar vazões de projeto com períodos de retorno específicos (ex: 100 anos).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados hidrológicos e modelo chuva-vazão base",
                                  "subSteps": [
                                    "Coletar dados históricos de precipitação e vazão para a bacia hidrográfica alvo.",
                                    "Selecionar um modelo simples de transformação chuva-vazão, como o método racional ou Clark Unit Hydrograph.",
                                    "Calibrar parâmetros iniciais do modelo (ex: tempo de concentração, fator de runoff) usando dados observados.",
                                    "Definir características da bacia: área, coeficiente de runoff, perdas iniciais.",
                                    "Estruturar dados em formato tabular para simulação (ex: planilha ou array em Python)."
                                  ],
                                  "verification": "Modelo base reproduz hidrograma observado com erro médio <20% em picos.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Dados hidrológicos históricos (USGS ou ANA)",
                                    "Software: Python (NumPy, Pandas), Excel",
                                    "Documentação de modelos hidrológicos"
                                  ],
                                  "tips": "Use dados de eventos de chuva intensas para calibração precisa; normalize unidades (mm/h para precipitação).",
                                  "learningObjective": "Compreender e implementar um modelo determinístico chuva-vazão como base para simulações estocásticas.",
                                  "commonMistakes": [
                                    "Ignorar perdas iniciais levando a superestimação de vazões",
                                    "Usar dados não representativos da bacia",
                                    "Não calibrar parâmetros adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir distribuições probabilísticas para parâmetros aleatórios",
                                  "subSteps": [
                                    "Identificar parâmetros incertos: intensidade de chuva, coeficiente de runoff, tempo de concentração.",
                                    "Ajustar distribuições estatísticas aos dados históricos (ex: Gumbel para máximas anuais de chuva, log-normal para runoff).",
                                    "Estimar parâmetros das distribuições (média, desvio padrão, shape) via método dos momentos ou máxima verossimilhança.",
                                    "Gerar amostras aleatórias de cada parâmetro usando geradores de números aleatórios.",
                                    "Validar distribuições com testes QQ-plot ou Kolmogorov-Smirnov."
                                  ],
                                  "verification": "QQ-plots mostram boa adequação das distribuições aos dados empíricos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python: SciPy.stats para distribuições",
                                    "Dados históricos de máximas",
                                    "Ferramentas de ajuste: fitdist em R ou Python"
                                  ],
                                  "tips": "Priorize distribuições físicas (ex: não-negativas); use bootstrap para incertezas em parâmetros.",
                                  "learningObjective": "Modelar incertezas em parâmetros hidrológicos com distribuições probabilísticas apropriadas.",
                                  "commonMistakes": [
                                    "Escolher distribuição inadequada (ex: normal para dados assimétricos)",
                                    "Subestimar caudas pesadas em eventos extremos",
                                    "Não testar adequação da distribuição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar simulação Monte Carlo para múltiplas realizações",
                                  "subSteps": [
                                    "Configurar loop Monte Carlo com N=10.000 simulações.",
                                    "Para cada iteração: amostrar parâmetros, aplicar modelo chuva-vazão, extrair vazão máxima.",
                                    "Armazenar todas as vazões máximas simuladas em um vetor.",
                                    "Otimizar código para eficiência (vetorização em NumPy).",
                                    "Implementar paralelização se necessário (ex: joblib em Python)."
                                  ],
                                  "verification": "Simulação completa roda em <5 minutos com N=10k; histograma de vazões mostra variabilidade esperada.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Python: NumPy.random, Pandas",
                                    "Jupyter Notebook para prototipagem",
                                    "Biblioteca hydrotools se disponível"
                                  ],
                                  "tips": "Use sementes aleatórias fixas para reprodutibilidade; monitore convergência com N crescente.",
                                  "learningObjective": "Executar simulações estocásticas Monte Carlo para propagar incertezas em modelos hidrológicos.",
                                  "commonMistakes": [
                                    "N insuficiente levando a variância alta",
                                    "Erros de indexação no loop",
                                    "Não vetorizar causando lentidão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estimar vazões de projeto para períodos de retorno específicos",
                                  "subSteps": [
                                    "Ordenar vazões máximas simuladas em ordem decrescente.",
                                    "Calcular percentis empíricos: para T=100 anos, percentil = 1 - 1/T (99%).",
                                    "Ajustar distribuição teórica aos resultados Monte Carlo (ex: Gumbel ou Log-Pearson Type III).",
                                    "Computar intervalos de confiança via bootstrap nas simulações.",
                                    "Gerar relatório com vazões para T=10, 50, 100 anos."
                                  ],
                                  "verification": "Vazão T=100 anos converge com ±5% ao aumentar N; IC 95% razoável.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python: NumPy.percentile, SciPy.stats",
                                    "Bibliotecas de extreme value theory"
                                  ],
                                  "tips": "Use plotting para visualizar distribuição cumulativa; valide com dados históricos raros.",
                                  "learningObjective": "Extrair quantis de risco de simulações Monte Carlo para design hidrológico.",
                                  "commonMistakes": [
                                    "Confundir percentil com média",
                                    "Ignorar correlações entre parâmetros",
                                    "Percentil errado para período de retorno"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar, visualizar e interpretar resultados",
                                  "subSteps": [
                                    "Comparar vazões simuladas com observadas históricas.",
                                    "Criar gráficos: histograma de vazões, hidrogramas selecionados, curva de duração.",
                                    "Realizar análise de sensibilidade variando distribuições.",
                                    "Documentar suposições e limitações.",
                                    "Preparar relatório com recomendações para engenharia."
                                  ],
                                  "verification": "Gráficos mostram consistência; sensibilidade <20% variação em vazão crítica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python: Matplotlib, Seaborn",
                                    "Relatório template LaTeX ou Word"
                                  ],
                                  "tips": "Use log-escala para vazões; destaque incertezas em relatório.",
                                  "learningObjective": "Interpretar e comunicar resultados de Monte Carlo em contexto de engenharia civil.",
                                  "commonMistakes": [
                                    "Sobrepor confiança nos resultados sem validação",
                                    "Gráficos ilegíveis",
                                    "Ignorar limitações do modelo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a bacia do Rio Tietê (área 1000 km²), simule 10k eventos de chuva de 24h com intensidade Gumbel (média 100 mm, CV=0.3), runoff log-normal (média 0.4), tempo de concentração uniforme (2-4h). Estime vazão de pico T=100 anos (~1500 m³/s) para dimensionar ponte.",
                              "finalVerifications": [
                                "Simulação Monte Carlo gera vazões consistentes com eventos históricos extremos.",
                                "Vazão T=100 anos calculada com IC 95% <15% da mediana.",
                                "Código roda eficientemente e é reprodutível.",
                                "Análise de sensibilidade identifica parâmetros dominantes.",
                                "Relatório inclui gráficos claros e interpretações práticas.",
                                "Validação com dados reais mostra viés <10%."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de distribuições probabilísticas (30%)",
                                "Correta implementação e convergência do Monte Carlo (25%)",
                                "Qualidade da estimação de quantis e ICs (20%)",
                                "Visualizações e validação robustas (15%)",
                                "Relatório claro com aplicações reais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Distribuições extremas e quantis.",
                                "Programação Computacional: Python para simulações numéricas.",
                                "Hidrologia e Recursos Hídricos: Modelos chuva-vazão.",
                                "Engenharia de Riscos: Análise de incertezas estocásticas.",
                                "Visualização de Dados: Gráficos para comunicação científica."
                              ],
                              "realWorldApplication": "Dimensionamento de estruturas hidráulicas como barragens, pontes e sistemas de drenagem urbana, considerando riscos de inundações raras (ex: eventos 1/100 anos) em projetos de engenharia civil no Brasil, conforme normas NBR 12076 e ANA."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.6.3.3",
                            "name": "Avaliar riscos de inundação",
                            "description": "Calcular probabilidades de transbordo de vertedouros ou diques a partir de simulações, gerando curvas de risco e auxiliando no planejamento de defesas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender fundamentos de modelagem hidrológica estocástica e Método de Monte Carlo",
                                  "subSteps": [
                                    "Estudar variáveis hidrológicas estocásticas como precipitação, vazão e níveis de água.",
                                    "Revisar princípios do Método de Monte Carlo para simulações probabilísticas.",
                                    "Identificar componentes de vertedouros e diques em sistemas hidráulicos.",
                                    "Analisar exemplos de curvas de risco de inundação em literatura técnica.",
                                    "Definir probabilidades de transbordo baseadas em eventos extremos."
                                  ],
                                  "verification": "Elaborar um mapa conceitual conectando Monte Carlo à hidrologia estocástica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Hidrologia Aplicada'",
                                    "Tutorial sobre Monte Carlo em Python",
                                    "Dados hidrológicos históricos (USGS ou ANA)"
                                  ],
                                  "tips": "Priorize variáveis com alta variância, como chuvas intensas, para simulações realistas.",
                                  "learningObjective": "Dominar conceitos teóricos para modelar incertezas em processos hidrológicos.",
                                  "commonMistakes": [
                                    "Ignorar distribuições probabilísticas adequadas (ex: usar normal em vez de Gumbel para máximos)",
                                    "Subestimar correlações entre variáveis hidrológicas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o modelo hidrológico e parâmetros de entrada",
                                  "subSteps": [
                                    "Coletar dados históricos de precipitação, vazão e topografia da bacia hidrográfica.",
                                    "Definir distribuições probabilísticas para variáveis aleatórias (ex: log-normal para precipitação).",
                                    "Modelar o vertedouro ou dique com equações hidráulicas (ex: weir flow equation).",
                                    "Estabelecer número de iterações Monte Carlo (mínimo 10.000 para convergência).",
                                    "Implementar gerador de números aleatórios em software (Python ou MATLAB)."
                                  ],
                                  "verification": "Gerar 100 amostras iniciais e validar distribuições com histogramas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software Python com NumPy/SciPy",
                                    "Dados da ANA (Agência Nacional de Águas)",
                                    "Planilhas Excel para prototipagem"
                                  ],
                                  "tips": "Use testes de Kolmogorov-Smirnov para validar adequação das distribuições.",
                                  "learningObjective": "Preparar entradas realistas e parametrizadas para simulações.",
                                  "commonMistakes": [
                                    "Número insuficiente de simulações levando a variância alta",
                                    "Dados não calibrados causando viés"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações Monte Carlo e gerar curvas de risco",
                                  "subSteps": [
                                    "Rodar simulações completas gerando cenários de transbordo.",
                                    "Calcular probabilidades de excedência para diferentes níveis de água.",
                                    "Construir curvas de risco (probabilidade vs. vazão ou altura).",
                                    "Aplicar análise de sensibilidade em parâmetros chave.",
                                    "Exportar resultados em gráficos e tabelas."
                                  ],
                                  "verification": "Verificar convergência plotando erro padrão vs. número de iterações.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código Python com Matplotlib/Seaborn",
                                    "Jupyter Notebook",
                                    "Computador com boa capacidade computacional"
                                  ],
                                  "tips": "Paralelize simulações com multiprocessing para eficiência.",
                                  "learningObjective": "Executar e processar simulações para quantificar riscos probabilísticos.",
                                  "commonMistakes": [
                                    "Não tratar outliers em simulações extremas",
                                    "Escala errada nos eixos das curvas de risco"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e auxiliar no planejamento de defesas",
                                  "subSteps": [
                                    "Interpretar curvas de risco para identificar níveis de retorno (ex: 100 anos).",
                                    "Recomendar alturas de diques baseadas em probabilidades aceitáveis.",
                                    "Simular cenários de mitigação (ex: aumento de capacidade do vertedouro).",
                                    "Documentar relatório com mapas de risco e recomendações.",
                                    "Validar modelo com eventos históricos reais."
                                  ],
                                  "verification": "Produzir relatório com curvas e propostas de defesa viáveis.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "GIS software como QGIS para mapas",
                                    "Templates de relatórios técnicos"
                                  ],
                                  "tips": "Considere custos-benefícios na recomendação de defesas.",
                                  "learningObjective": "Aplicar resultados em decisões de engenharia prática.",
                                  "commonMistakes": [
                                    "Ignorar incertezas não modeladas como mudanças climáticas",
                                    "Recomendações não ancoradas em probabilidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o risco de transbordo do vertedouro do Rio Tietê em São Paulo: use dados históricos de chuvas (média 100mm/dia, desvio 50mm), 50.000 iterações Monte Carlo, gere curva de risco mostrando 2% de chance de inundação acima de 5m, recomendando dique de 5.5m.",
                              "finalVerifications": [
                                "Curva de risco gerada com convergência confirmada (erro <1%).",
                                "Probabilidades calculadas coincidem com eventos históricos (±10%).",
                                "Relatório inclui pelo menos 3 cenários de mitigação.",
                                "Gráficos claros com legendas e unidades corretas.",
                                "Validação cruzada com dados reais de inundação.",
                                "Recomendações quantificadas em termos de redução de risco."
                              ],
                              "assessmentCriteria": [
                                "Precisão das distribuições probabilísticas usadas (teste KS >0.95).",
                                "Número e qualidade das simulações (mínimo 10k iterações).",
                                "Clareza e correção das curvas de risco geradas.",
                                "Profundidade da análise de sensibilidade.",
                                "Relevância das recomendações para planejamento de defesas.",
                                "Documentação completa e profissional do processo."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: Distribuições e análise de incertezas.",
                                "Programação Computacional: Implementação em Python/R.",
                                "Engenharia Ambiental: Gestão de recursos hídricos.",
                                "Gestão de Riscos: Análise custo-benefício em projetos civis.",
                                "Mudanças Climáticas: Incorporação de cenários futuros."
                              ],
                              "realWorldApplication": "Em prefeituras e empresas de engenharia, como a Sabesp ou Defesa Civil, para dimensionar diques em cidades ribeirinhas, emitir alertas precoces de enchentes e planejar investimentos em infraestrutura resiliente, reduzindo danos econômicos e vidas perdidas em eventos como as cheias do Rio Paraná."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.6.3.4",
                            "name": "Otimizar número de simulações para convergência",
                            "description": "Determinar o tamanho mínimo de amostra necessário para estabilizar estimativas probabilísticas, usando critérios como coeficiente de variação ou intervalos de confiança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Convergência em Simulações Monte Carlo",
                                  "subSteps": [
                                    "Revise os princípios do Método de Monte Carlo e como a convergência depende do número de simulações.",
                                    "Estude critérios de convergência: Coeficiente de Variação (CV = desvio padrão / média) e Intervalos de Confiança (IC) baseados em t-Student ou normal.",
                                    "Identifique o problema hidrológico específico, como modelagem de vazão máxima em uma bacia hidrográfica.",
                                    "Defina tolerâncias alvo para CV (ex: <5%) e largura de IC (ex: ±10%).",
                                    "Calcule amostra inicial estimada usando fórmulas aproximadas: n ≈ (Z * CV / ε)^2, onde ε é precisão desejada."
                                  ],
                                  "verification": "Resuma em um documento os critérios escolhidos e justificativas, com fórmulas anotadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Monte Carlo, notebook Jupyter, calculadora científica.",
                                  "tips": "Comece com exemplos simples de literatura hidrológica para contextualizar.",
                                  "learningObjective": "Dominar métricas de convergência para guiar otimizações.",
                                  "commonMistakes": "Confundir CV com variância absoluta; ignorar distribuição não-normal dos dados hidrológicos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Simulação Base e Funções de Monitoramento",
                                  "subSteps": [
                                    "Desenvolva o modelo estocástico em Python: gere números aleatórios para parâmetros hidrológicos (ex: precipitação via distribuição exponencial).",
                                    "Crie funções para calcular estatísticas: média, desvio padrão, CV e IC a cada incremento de simulações.",
                                    "Implemente loop incremental: adicione simulações em blocos de 100-1000 até atingir tolerância.",
                                    "Gere gráficos de convergência: CV e largura IC vs. número de simulações.",
                                    "Teste com 10.000 simulações fixas para validar o código."
                                  ],
                                  "verification": "Execute o código e verifique se gráficos mostram estabilização gradual.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python com NumPy, SciPy, Matplotlib; dados hidrológicos de exemplo (ex: série temporal de vazão).",
                                  "tips": "Use vetores pré-alocados para eficiência computacional em loops grandes.",
                                  "learningObjective": "Construir ferramentas automatizadas para monitoramento de convergência.",
                                  "commonMistakes": "Usar blocos fixos muito grandes, atrasando detecção precoce; não seedar gerador aleatório para reprodutibilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar e Monitorar Convergência Incremental",
                                  "subSteps": [
                                    "Inicie simulações com n=100 e incremente até CV <5% ou IC dentro da tolerância.",
                                    "Registre histórico: número de simulações, CV, limites IC em cada iteração.",
                                    "Analise oscilações: identifique platôs de estabilização.",
                                    "Repita com 3 sementes diferentes para avaliar variabilidade.",
                                    "Ajuste tolerâncias se necessário, baseado em trade-off precisão vs. tempo computacional."
                                  ],
                                  "verification": "Gráfico final mostra convergência abaixo de thresholds com <20% variabilidade entre runs.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook Jupyter rodando simulações; computador com pelo menos 8GB RAM.",
                                  "tips": "Monitore uso de CPU; pare early se convergência rápida.",
                                  "learningObjective": "Aplicar monitoramento dinâmico para eficiência.",
                                  "commonMistakes": "Parar prematuramente em flutuações temporárias; ignorar correlação serial em séries hidrológicas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Validar Otimização",
                                  "subSteps": [
                                    "Determine n_mínimo médio das runs e intervalo de confiança dele.",
                                    "Compare com benchmarks analíticos ou literatura hidrológica.",
                                    "Calcule economia computacional: tempo total vs. n fixo de 100.000.",
                                    "Documente relatório: n_mínimo, gráficos, sensibilidade a parâmetros.",
                                    "Teste robustez variando distribuições de entrada (ex: log-normal vs. gamma)."
                                  ],
                                  "verification": "Relatório PDF com n_mínimo justificado e validação cruzada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramentas de plotting avançadas (Seaborn), LaTeX ou Markdown para relatório.",
                                  "tips": "Use boxplots para variabilidade entre sementes.",
                                  "learningObjective": "Interpretar e validar otimizações para uso prático.",
                                  "commonMistakes": "Sobreestimar convergência sem múltiplas runs; não reportar incertezas no n_mínimo."
                                }
                              ],
                              "practicalExample": "Em modelagem de vazão máxima anual de um rio, gere simulações Monte Carlo com precipitação exponencial e coeficiente de runoff uniforme. Monitore CV da vazão 100-anos até <5%, alcançando n_mínimo ≈ 5.000 simulações, reduzindo tempo de 2h para 10min vs. 100.000 fixas.",
                              "finalVerifications": [
                                "CV estabilizado abaixo de 5% em pelo menos 3 runs independentes.",
                                "Largura de IC <10% da média estimada.",
                                "Gráficos mostram platô claro após n_mínimo.",
                                "Tempo computacional reportado e otimizado (>50% redução vs. fixo).",
                                "Relatório inclui sensibilidade a sementes e parâmetros.",
                                "Validação com benchmark conhecido (ex: fórmula analítica para casos simples)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação de critérios CV/IC (código correto e eficiente).",
                                "Efetividade da otimização: n_mínimo mínimo viável com convergência robusta.",
                                "Qualidade de visualizações e análise de variabilidade.",
                                "Documentação clara com justificativas e trade-offs.",
                                "Aplicação contextualizada à hidrologia (distribuições realistas).",
                                "Reprodutibilidade total (seeds, dados de entrada)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e intervalos de confiança.",
                                "Programação: Otimização de loops e análise numérica.",
                                "Hidrologia: Modelagem estocástica de processos naturais.",
                                "Computação Científica: Paralelização para grandes n.",
                                "Gestão de Riscos: Aplicações em engenharia de desastres."
                              ],
                              "realWorldApplication": "Otimizar simulações Monte Carlo para previsão de cheias em bacias hidrográficas, permitindo engenheiros civis dimensionar barragens com precisão probabilística eficiente, reduzindo custos computacionais em projetos de infraestrutura resiliente a mudanças climáticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 375
          }
        ],
        "totalSkills": 375
      }
    ]
  }
}