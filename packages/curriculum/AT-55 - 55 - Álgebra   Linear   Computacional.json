{
  "formatVersion": "1.0",
  "exportDate": "2025-12-05T22:15:22.340Z",
  "appVersion": "1.0.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - AT-55",
      "lastUpdated": "2025-12-05",
      "totalAtomicSkills": 290
    },
    "areas": [
      {
        "id": "10",
        "name": "Matemática",
        "description": "Disciplinas fundamentais de Matemática Aplicada e Computacional.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "Álgebra Linear Computacional",
            "description": "Decomposição em valores singulares. Sensibilidade de sistemas de equações lineares. Ortogonalização e decomposição QR. Quadrados mínimos lineares. Análise de sensibilidade. Análise de métodos iterativos clássicos para sistemas lineares. Bibliografia: GOLUB, G. H.; VAN LOAN, C. F. Matrix computations. 3. ed. Baltimore: Johns Hopkins University Press, 1996. MEYER, C. D. Matrix analysis and applied linear algebra. Philadelphia: SIAM, 2000. WATKINS, D. S. Fundamentals of matrix computations. 3. ed. New York: Wiley, 2010.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Decomposição em Valores Singulares",
                "description": "Estudo da decomposição SVD de matrizes, fundamental para análise numérica e compressão de dados.",
                "totalSkills": 45,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Definição Formal da Decomposição SVD",
                    "description": "Definição da SVD de uma matriz A como A = U Σ V^T, onde U e V são ortogonais e Σ é diagonal com valores singulares.",
                    "individualConcepts": [
                      {
                        "id": "55.1.1.1.1",
                        "name": "Matrizes Ortogonais",
                        "description": "Matrizes Q tais que Q^T Q = I, implicando que Q^T = Q^{-1}, fundamentais para as matrizes U e V na decomposição SVD, preservando normas e ângulos.",
                        "specificSkills": [
                          {
                            "id": "55.1.1.1.1.1",
                            "name": "Definir matriz ortogonal",
                            "description": "Enunciar a definição formal de uma matriz ortogonal como uma matriz real Q m×m onde as colunas (ou linhas) formam uma base ortonormal, satisfazendo Q^T Q = Q Q^T = I_m.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de ortogonalidade e bases ortonormais",
                                  "subSteps": [
                                    "Lembre-se da definição de vetores ortogonais: produto interno zero.",
                                    "Defina norma de um vetor: raiz quadrada do produto interno consigo mesmo.",
                                    "Explique base ortonormal: conjunto de vetores ortogonais unitários que formam base.",
                                    "Verifique exemplos em R^2 e R^3.",
                                    "Discuta importância em espaços vetoriais reais."
                                  ],
                                  "verification": "Escreva definições corretas e forneça um exemplo de base ortonormal em R^2.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Álgebra Linear (capítulo de produtos internos)"
                                  ],
                                  "tips": "Use vetores canônicos como exemplo inicial para simplicidade.",
                                  "learningObjective": "Compreender os blocos de construção para matrizes ortogonais.",
                                  "commonMistakes": [
                                    "Confundir ortogonal com perpendicular em dimensões >2",
                                    "Esquecer que normas devem ser 1 (unitários)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir matriz ortogonal pelas colunas como base ortonormal",
                                  "subSteps": [
                                    "Considere uma matriz Q m×m real com colunas q1, q2, ..., qm.",
                                    "Exija que <qi, qj> = δ_ij (delta de Kronecker: 1 se i=j, 0 caso contrário).",
                                    "Verifique que colunas têm norma 1 e são ortogonais entre si.",
                                    "Estenda para linhas: propriedades simétricas.",
                                    "Confirme que isso implica linear independência e base para R^m."
                                  ],
                                  "verification": "Construa uma matriz 2x2 cujas colunas formem base ortonormal e verifique manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou software como MATLAB/Octave para verificação",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Comece com m=2 para visualização geométrica (rotações).",
                                  "learningObjective": "Associar matriz ortogonal diretamente a bases ortonormais.",
                                  "commonMistakes": [
                                    "Ignorar que deve ser quadrada m×m",
                                    "Confundir colunas com linhas sem mencionar equivalência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer a condição algébrica Q^T Q = I_m",
                                  "subSteps": [
                                    "Calcule o produto Q^T Q: entrada (i,j) é <qi, qj>.",
                                    "Mostre que isso resulta na matriz identidade I_m.",
                                    "Discuta Q Q^T = I_m pela simetria das colunas/linhas.",
                                    "Prove que Q é invertível com Q^{-1} = Q^T.",
                                    "Verifique com multiplicação matricial explícita para m=2."
                                  ],
                                  "verification": "Compute Q^T Q para uma matriz exemplo e confirme = I.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de álgebra linear (Python NumPy ou similar)",
                                    "Tabela de multiplicação matricial"
                                  ],
                                  "tips": "Lembre-se: transposta inverte papéis de linhas e colunas.",
                                  "learningObjective": "Conectar definição geométrica à algébrica matricial.",
                                  "commonMistakes": [
                                    "Esquecer transposição Q^T",
                                    "Achar que Q Q^T ≠ Q^T Q em geral (mas sim para ortogonais)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Consolidar definição formal e propriedades equivalentes",
                                  "subSteps": [
                                    "Enuncie definição completa: Q real m×m com Q^T Q = Q Q^T = I_m.",
                                    "Liste propriedades: preserva normas (isometria), autoadjunta em certo sentido.",
                                    "Compare definições via colunas vs. produto matricial.",
                                    "Discuta generalizações (complexas: unitárias).",
                                    "Resolva exercício: classifique matrizes como ortogonais ou não."
                                  ],
                                  "verification": "Escreva a definição formal verbatim e prove uma propriedade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exercícios impressos",
                                    "Referência: Strang 'Introduction to Linear Algebra'"
                                  ],
                                  "tips": "Memorize: 'Ortogonal se transposta é inversa'.",
                                  "learningObjective": "Enunciar e justificar a definição formal com precisão.",
                                  "commonMistakes": [
                                    "Omitir 'real' ou dimensão quadrada",
                                    "Confundir com matrizes simétricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere Q = [[cosθ, -sinθ], [sinθ, cosθ]] (matriz de rotação). Compute Q^T Q e verifique = I_2, confirmando que é ortogonal para qualquer θ.",
                              "finalVerifications": [
                                "Enunciar corretamente a definição formal incluindo Q^T Q = I_m.",
                                "Explicar equivalência entre colunas ortonormais e condição matricial.",
                                "Verificar ortogonalidade de uma matriz 2x2 dada.",
                                "Listar pelo menos duas propriedades de matrizes ortogonais.",
                                "Diferenciar de matrizes unitárias no contexto complexo."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na enunciação da definição (40%)",
                                "Correção na derivação de Q^T Q = I (30%)",
                                "Uso correto de terminologia (base ortonormal, transposição) (15%)",
                                "Exemplos relevantes e verificações numéricas (10%)",
                                "Clareza na explicação de equivalências (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Transformações rígidas e conservação de comprimento.",
                                "Computação Gráfica: Rotações e normalização de vetores.",
                                "Processamento de Sinais: Filtros ortogonais em wavelets.",
                                "Estatística: Análise de componentes principais (PCA) via ortogonais."
                              ],
                              "realWorldApplication": "Matrizes ortogonais são cruciais na Decomposição em Valores Singulares (SVD) para compressão de imagens JPEG, sistemas de recomendação (Netflix) e estabilização de sinais em engenharia."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "55.1.1.1.1.2",
                            "name": "Verificar ortogonalidade",
                            "description": "Dado uma matriz Q, computar Q^T Q e confirmar se resulta na identidade, ou verificar se as colunas têm norma unitária e são ortogonais entre si.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de ortogonalidade",
                                  "subSteps": [
                                    "Defina matriz ortogonal: uma matriz Q cujas colunas são ortonormais (norma unitária e mutuamente ortogonais).",
                                    "Explique a propriedade chave: Q^T Q = I, onde I é a identidade.",
                                    "Recorde como calcular norma de um vetor: ||q|| = sqrt(q^T q).",
                                    "Entenda produto escalar: q_i^T q_j = 0 para i ≠ j.",
                                    "Discuta tolerância numérica em computação (ex: 1e-10)."
                                  ],
                                  "verification": "Explique por escrito ou verbalmente as definições e propriedades, com um exemplo simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Calculadora básica",
                                    "Referência de álgebra linear"
                                  ],
                                  "tips": "Visualize colunas como vetores perpendiculares em um espaço unitário.",
                                  "learningObjective": "Dominar a definição formal e propriedades de matrizes ortogonais.",
                                  "commonMistakes": [
                                    "Confundir ortogonal com simétrica.",
                                    "Ignorar normalização (norma=1).",
                                    "Esquecer tolerância em cálculos numéricos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar normas unitárias das colunas",
                                  "subSteps": [
                                    "Identifique e extraia cada coluna q_i da matriz Q.",
                                    "Para cada q_i, compute q_i^T q_i.",
                                    "Calcule a norma: sqrt(q_i^T q_i) e verifique se ≈ 1.",
                                    "Registre os valores para todas as colunas.",
                                    "Se não for unitária, normalize dividindo por sua norma (opcional para diagnóstico)."
                                  ],
                                  "verification": "Todas as normas das colunas são iguais a 1 (ou dentro de tolerância 1e-10).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz Q exemplo",
                                    "Software NumPy/Python ou MATLAB",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Use funções prontas como np.linalg.norm() para agilizar.",
                                  "learningObjective": "Aplicar cálculo de normas para validar normalização das colunas.",
                                  "commonMistakes": [
                                    "Usar norma L1 ou L-infinito em vez de L2.",
                                    "Arredondar prematuramente.",
                                    "Confundir linhas com colunas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar ortogonalidade entre pares de colunas",
                                  "subSteps": [
                                    "Liste todos os pares de colunas distintas (i < j).",
                                    "Para cada par, compute o produto escalar q_i^T q_j.",
                                    "Confirme que cada produto escalar ≈ 0.",
                                    "Registre uma tabela de resultados.",
                                    "Analise se algum desvio indica não-ortogonalidade."
                                  ],
                                  "verification": "Todos os produtos escalares entre colunas pares são zero (tolerância 1e-10).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz Q",
                                    "Planilha Excel ou Jupyter Notebook",
                                    "Biblioteca NumPy"
                                  ],
                                  "tips": "Comece com matrizes pequenas (2x2) para praticar manualmente.",
                                  "learningObjective": "Verificar independência ortogonal via produtos escalares.",
                                  "commonMistakes": [
                                    "Calcular q_i^T q_i em vez de pares.",
                                    "Pular pares simétricos.",
                                    "Ignorar sinal nos produtos escalares."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar Q^T Q e confirmar identidade",
                                  "subSteps": [
                                    "Calcule a transposta Q^T da matriz Q.",
                                    "Multiplique Q^T por Q para obter o produto.",
                                    "Compare elemento a elemento com a matriz identidade I.",
                                    "Verifique diagonal =1 e fora da diagonal =0 (com tolerância).",
                                    "Conclua se Q é ortogonal baseado no resultado."
                                  ],
                                  "verification": "A matriz resultante é igual à identidade (todas diferenças < 1e-10).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de álgebra linear (NumPy, MATLAB)",
                                    "Matriz Q de teste"
                                  ],
                                  "tips": "Use np.allclose(A, I, atol=1e-10) para verificação automática.",
                                  "learningObjective": "Validar ortogonalidade via multiplicação matricial direta.",
                                  "commonMistakes": [
                                    "Transpor incorretamente.",
                                    "Multiplicar Q Q^T em vez de Q^T Q.",
                                    "Não verificar todos os elementos."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere Q = [[√2/2, -√2/2], [√2/2, √2/2]] (matriz de rotação 45°). Compute normas das colunas: ambas √((0.5)+(0.5))=1. Produtos escalares: (√2/2)(-√2/2) + (√2/2)(√2/2) = -0.5 + 0.5 = 0. Q^T Q = [[1,0],[0,1]].",
                              "finalVerifications": [
                                "Todas colunas têm norma unitária.",
                                "Todos produtos escalares entre colunas pares são zero.",
                                "Q^T Q resulta na matriz identidade.",
                                "Nenhum elemento fora da tolerância numérica.",
                                "Conclusão correta: ortogonal ou não.",
                                "Documentação dos cálculos intermediários."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (erro < 1e-10).",
                                "Correta extração e manipulação de colunas.",
                                "Uso apropriado de tolerância numérica.",
                                "Explicação clara dos passos e resultados.",
                                "Identificação e correção de erros potenciais.",
                                "Eficiência no uso de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar verificação em Python com NumPy.",
                                "Física: Matrizes ortogonais em rotações e transformações rígidas.",
                                "Processamento de Imagens: Em SVD para compressão JPEG.",
                                "Estatística: Bases ortonormais em PCA."
                              ],
                              "realWorldApplication": "Verificação de ortogonalidade é essencial na decomposição QR para resolução numérica de sistemas lineares, na SVD para redução dimensional em machine learning, e em simulações físicas para preservar normas em transformações."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "55.1.1.1.1.3",
                            "name": "Propriedades de preservação",
                            "description": "Explicar como multiplicação por matriz ortogonal preserva a norma euclidiana de vetores (||Qx||_2 = ||x||_2) e ângulos entre vetores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição e Propriedades Básicas de Matrizes Ortogonais",
                                  "subSteps": [
                                    "Defina matriz ortogonal: Q tal que Q^T Q = I, onde Q^T é a transposta de Q.",
                                    "Explique que as colunas (e linhas) de Q são vetores unitários ortogonais entre si.",
                                    "Verifique a propriedade multiplicando Q por Q^T: deve resultar na identidade.",
                                    "Discuta isometria: transformações que preservam distâncias.",
                                    "Liste exemplos simples, como matrizes de rotação 2D."
                                  ],
                                  "verification": "Construa uma matriz 2x2 ortogonal e confirme Q^T Q = I usando cálculo manual ou software.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Caderno, calculadora, software como MATLAB/Octave ou Python (NumPy).",
                                  "tips": "Sempre normalize vetores antes de ortogonalizar para evitar erros numéricos.",
                                  "learningObjective": "Compreender a definição formal e propriedades fundamentais de matrizes ortogonais.",
                                  "commonMistakes": "Confundir ortogonal com simétrica (Q^T = Q) ou unitária (apenas diagonal unitária)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar a Preservação da Norma Euclidiana",
                                  "subSteps": [
                                    "Lembre a norma euclidiana: ||x||_2 = sqrt(x^T x).",
                                    "Calcule ||Qx||_2^2 = (Qx)^T (Qx) = x^T Q^T Q x.",
                                    "Substitua Q^T Q = I: x^T I x = x^T x = ||x||_2^2.",
                                    "Conclua que ||Qx||_2 = ||x||_2 para todo x.",
                                    "Teste com vetor unitário e não-unitário."
                                  ],
                                  "verification": "Derive a igualdade algebricamente e teste numericamente com x = [1,0]^T e Q de rotação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel para derivação, Python/NumPy para verificação numérica.",
                                  "tips": "Use notação matricial consistente e expanda para vetores 2D primeiro.",
                                  "learningObjective": "Derivar matematicamente a preservação da norma por multiplicação ortogonal.",
                                  "commonMistakes": "Esquecer o quadrado na norma ou inverter Q e Q^T na multiplicação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar a Preservação de Ângulos via Produto Interno",
                                  "subSteps": [
                                    "Defina produto interno: x · y = x^T y, e cosθ = (x·y) / (||x|| ||y||).",
                                    "Calcule (Qx) · (Qy) = (Qx)^T (Qy) = x^T Q^T Q y = x^T y.",
                                    "Como normas são preservadas, cosθ_{Qx,Qy} = cosθ_{x,y}.",
                                    "Conclua que ângulos entre vetores são preservados.",
                                    "Discuta implicações para distâncias: ||Qx - Qy|| = ||x - y||."
                                  ],
                                  "verification": "Calcule ângulos antes e depois da transformação para dois vetores não ortogonais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora científica, software para ângulos (acos).",
                                  "tips": "Visualize geometricamente: ortogonais são rotações/reflexões rígidas.",
                                  "learningObjective": "Demonstrar que matrizes ortogonais preservam produtos internos e ângulos.",
                                  "commonMistakes": "Ignorar preservação de normas ao calcular cosθ ou confundir com preservação de orientação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar com Exemplos Práticos",
                                  "subSteps": [
                                    "Escolha Q como matriz de rotação por 90°: [[0,-1],[1,0]].",
                                    "Aplique a vetores x=[1,1], y=[1,0]; compute normas e ângulos antes/depois.",
                                    "Use SVD para extrair Q de uma matriz aleatória.",
                                    "Compare graficamente usando plots.",
                                    "Resuma propriedades em um quadro comparativo."
                                  ],
                                  "verification": "Normas e ângulos coincidem dentro de tolerância numérica (1e-10).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (Matplotlib, NumPy), ou MATLAB.",
                                  "tips": "Use seed para reprodutibilidade em simulações numéricas.",
                                  "learningObjective": "Aplicar teorema em exemplos concretos para internalizar a propriedade.",
                                  "commonMistakes": "Erros de arredondamento; sempre verifique com precisão dupla."
                                }
                              ],
                              "practicalExample": "Considere uma matriz de rotação 2D Q = [[cosθ, -sinθ], [sinθ, cosθ]] com θ=45°. Para vetores x=[3,4] (norma 5) e y=[1,0], aplique Qx e Qy. Verifique: ||Qx||=5, ||Qy||=1, e ângulo entre x e y (53°) igual ao entre Qx e Qy, simulando rotação de um braço robótico sem distorção.",
                              "finalVerifications": [
                                "Deriva corretamente ||Qx||_2 = ||x||_2 usando álgebra matricial.",
                                "Explica verbalmente por que ângulos são preservados via produto interno.",
                                "Computa numericamente normas e ângulos para exemplo 2D/3D com precisão.",
                                "Identifica matriz ortogonal simples e verifica Q^T Q = I.",
                                "Discute geometricamente como rotações/reflexões preservam formas.",
                                "Aplica propriedade em contexto de SVD (Q em UΣV^T)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação algébrica (sem erros em Q^T Q).",
                                "Correção numérica em exemplos (erro <1e-10).",
                                "Explicação clara de implicações geométricas.",
                                "Uso correto de notação vetorial/matrices.",
                                "Identificação de erros comuns em contraexemplos.",
                                "Conexão com aplicações reais como rotações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Preservação de energia cinética em rotações (norma como velocidade).",
                                "Computação Gráfica: Transformações rígidas em jogos/ animações 3D.",
                                "Processamento de Sinais: Filtros ortogonais em wavelets.",
                                "Estatística: Preservação de variância em PCA via ortogonalização."
                              ],
                              "realWorldApplication": "Em visão computacional, a decomposição SVD usa matrizes ortogonais (U,V) para comprimir imagens sem distorcer proporções ou ângulos, como no algoritmo de recomendação Netflix ou estabilização de vídeos em drones, preservando normas para manter intensidades de pixels."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "55.1.1.1.2",
                        "name": "Valores Singulares",
                        "description": "Números não-negativos σ_i ordenados em ordem decrescente, raízes quadradas dos autovalores de A^T A ou A A^T, diagonais na matriz Σ da SVD.",
                        "specificSkills": [
                          {
                            "id": "55.1.1.1.2.1",
                            "name": "Definir valores singulares",
                            "description": "Definir os valores singulares de A ∈ ℝ^{m×n} como σ_1 ≥ σ_2 ≥ ... ≥ σ_r ≥ 0, onde r = rank(A), sendo σ_i = √λ_i com λ_i autovalores de A^T A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Pré-requisitos: Matrizes, Autovalores e Rank",
                                  "subSteps": [
                                    "Lembre-se da definição de uma matriz A ∈ ℝ^{m×n} e suas dimensões.",
                                    "Revise o conceito de autovalores de uma matriz simétrica positiva semi-definida.",
                                    "Entenda o rank(A) como a dimensão do espaço coluna não-trivial.",
                                    "Calcule A^T A para uma matriz exemplo pequena, verificando que é simétrica e positiva semi-definida.",
                                    "Identifique os autovalores de A^T A usando um exemplo 2x2."
                                  ],
                                  "verification": "Liste corretamente os pré-requisitos e compute A^T A para uma matriz dada sem erros.",
                                  "estimatedTime": "20-25 minutes",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Matriz exemplo: A = [[1,0],[0,2]]"
                                  ],
                                  "tips": "Comece com matrizes quadradas para simplificar antes de generalizar para retangulares.",
                                  "learningObjective": "Compreender os fundamentos necessários para definir valores singulares.",
                                  "commonMistakes": [
                                    "Confundir A^T A com A A^T",
                                    "Esquecer que A^T A é sempre simétrica",
                                    "Ignorar que autovalores podem ser zero"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender os Autovalores de A^T A",
                                  "subSteps": [
                                    "Prove que A^T A é simétrica ( (A^T A)^T = A^T (A^T)^T = A^T A ).",
                                    "Mostre que autovalores de A^T A são não-negativos (x^T A^T A x = ||A x||^2 ≥ 0).",
                                    "Ordene os autovalores λ_1 ≥ λ_2 ≥ ... ≥ λ_n ≥ 0.",
                                    "Identifique r como o número de λ_i > 0, igual ao rank(A).",
                                    "Compute autovalores para A = [[1,1],[0,1]] e liste λ_i."
                                  ],
                                  "verification": "Explique por que λ_i ≥ 0 e compute corretamente para pelo menos duas matrizes.",
                                  "estimatedTime": "25-30 minutes",
                                  "materials": [
                                    "Software de álgebra linear (Python NumPy ou MATLAB)",
                                    "Exemplos de matrizes retangulares"
                                  ],
                                  "tips": "Use decomposição espectral para matrizes pequenas para visualizar λ_i.",
                                  "learningObjective": "Dominar as propriedades dos autovalores de A^T A.",
                                  "commonMistakes": [
                                    "Assumir λ_i sempre positivos",
                                    "Confundir multiplicidade algébrica com geométrica",
                                    "Não ordenar λ_i decrescentemente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir os Valores Singulares σ_i",
                                  "subSteps": [
                                    "Defina σ_i = √λ_i para i=1 a r, onde λ_i são autovalores positivos de A^T A.",
                                    "Estenda σ_{r+1} = ... = σ_min(m,n) = 0 se necessário.",
                                    "Ordene σ_1 ≥ σ_2 ≥ ... ≥ σ_r > 0 ≥ σ_{r+1} = ... = 0.",
                                    "Verifique com exemplo: para A acima, compute σ_i explicitamente.",
                                    "Relacione: o maior σ_1 é a norma 2 de A (maior alongamento)."
                                  ],
                                  "verification": "Escreva a definição formal completa e aplique a uma matriz, obtendo σ_i corretos.",
                                  "estimatedTime": "20-25 minutes",
                                  "materials": [
                                    "Calculadora gráfica para raízes",
                                    "Tabela de autovalores pré-computados"
                                  ],
                                  "tips": "Lembre-se: σ_i medem 'forças' das direções principais da matriz.",
                                  "learningObjective": "Definir precisamente os valores singulares e sua relação com λ_i.",
                                  "commonMistakes": [
                                    "Esquecer a raiz quadrada",
                                    "Não zerar σ_i além do rank",
                                    "Ordenar incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Contextualizar na SVD",
                                  "subSteps": [
                                    "Recapitule: SVD é A = U Σ V^T, com Σ diagonal contendo σ_i.",
                                    "Confirme que número de σ_i > 0 é rank(A).",
                                    "Compare σ_i de A e A^T (mesmos não-zero).",
                                    "Resolva exercício: dada A 3x2, encontre σ_i sem computar SVD completa.",
                                    "Discuta singularidades: σ_i = 0 implica colunas linearmente dependentes."
                                  ],
                                  "verification": "Responda perguntas sobre relação SVD e rank usando a definição.",
                                  "estimatedTime": "15-20 minutes",
                                  "materials": [
                                    "Livro de Álgebra Linear (ex: Strang)",
                                    "Quiz de verificação rápida"
                                  ],
                                  "tips": "Visualize geometricamente: σ_i como escalas em direções singulares.",
                                  "learningObjective": "Integrar a definição de σ_i no quadro completo da SVD.",
                                  "commonMistakes": [
                                    "Confundir σ_i com autovalores de A",
                                    "Ignorar diferenças dimensionais m≠n",
                                    "Não relacionar com rank"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3, 0], [0, 0]] ∈ ℝ^{2×2}, compute A^T A = [[9,0],[0,0]]. Autovalores λ_1=9, λ_2=0. Assim, σ_1=3, σ_2=0, r=1.",
                              "finalVerifications": [
                                "Defina corretamente σ_i para qualquer A ∈ ℝ^{m×n}.",
                                "Compute σ_i a partir de autovalores de A^T A em exemplo dado.",
                                "Identifique r = rank(A) pelo número de σ_i > 0.",
                                "Explique por que σ_i ≥ 0 e ordenados decrescentemente.",
                                "Diferencie σ_i de autovalores de A.",
                                "Aplique em matriz retangular 3x2."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% match com σ_i = √λ_i).",
                                "Correta ordenação e truncamento em r.",
                                "Compreensão de propriedades (simetria, não-negatividade).",
                                "Aplicação correta em exemplos numéricos.",
                                "Integração com conceitos SVD e rank.",
                                "Explicação clara sem erros conceituais."
                              ],
                              "crossCurricularConnections": [
                                "Ciência de Dados: σ_i em PCA para redução dimensional.",
                                "Física: Modos normais em vibrações (autovalores de A^T A).",
                                "Computação: Compressão de imagens via SVD truncada.",
                                "Estatística: Análise de componentes principais.",
                                "Engenharia: Estabilidade numérica em simulações."
                              ],
                              "realWorldApplication": "Em processamento de imagens, os valores singulares σ_i permitem compressão eficiente retendo os maiores (baixa rank approximation), usada no JPEG2000 e recomendação Netflix."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "55.1.1.1.1"
                            ]
                          },
                          {
                            "id": "55.1.1.1.2.2",
                            "name": "Relacionar com autovalores",
                            "description": "Explicar a relação entre valores singulares de A e autovalores de A^T A (para colunas) ou A A^T (para linhas), destacando multiplicidade e ordenação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as matrizes A^T A e A A^T",
                                  "subSteps": [
                                    "Revise a transposição de matrizes: A^T inverte linhas e colunas.",
                                    "Compute A^T A para uma matriz A m x n (resultado n x n, simétrica positiva semi-definida).",
                                    "Compute A A^T (resultado m x m, também simétrica positiva semi-definida).",
                                    "Note que autovalores de ambas são não-negativos.",
                                    "Verifique com uma matriz exemplo pequena."
                                  ],
                                  "verification": "Confirme que A^T A é simétrica (A^T A = (A^T A)^T) e compute traço para soma de autovalores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora matricial ou Python (NumPy).",
                                  "tips": "Sempre normalize colunas de A para insights iniciais sobre normas.",
                                  "learningObjective": "Compreender por que A^T A captura normas e ângulos entre colunas de A.",
                                  "commonMistakes": "Confundir A^T A (para colunas) com A A^T (para linhas); esquecer que são simétricas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular autovalores de A^T A e relacionar com valores singulares",
                                  "subSteps": [
                                    "Defina autovalores λ de A^T A onde A^T A v = λ v, com ||v||=1.",
                                    "Mostre que os valores singulares σ_i de A são σ_i = √λ_i, ordenados σ_1 ≥ σ_2 ≥ ... ≥ 0.",
                                    "Prove geometricamente: ||A u||^2 = u^T A^T A u = λ ||u||^2 para vetor u coluna de A.",
                                    "Compute numericamente para exemplo: A = [[3,0],[0,4]], A^T A = [[9,0],[0,16]], λ=9,16 → σ=3,4.",
                                    "Verifique que menores σ correspondem a direções de pouca variação."
                                  ],
                                  "verification": "Calcule σ via SVD e confirme σ_i^2 = λ_i ordenados decrescentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software como MATLAB, Python (numpy.linalg.eig, svd) ou calculadora simbólica.",
                                  "tips": "Ordene autovalores decrescentes antes de tirar raiz quadrada.",
                                  "learningObjective": "Estabelecer a conexão matemática σ = √λ entre SVD e autovalores.",
                                  "commonMistakes": "Esquecer de ordenar λ decrescente ou tomar √λ negativo (sempre ≥0)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar multiplicidade algébrica e geométrica",
                                  "subSteps": [
                                    "Defina multiplicidade algébrica (raiz do polinômio característico) e geométrica (dimensão do eigenspace).",
                                    "Mostre que para A^T A, multiplicidades de λ coincidem com as de σ=√λ no SVD.",
                                    "Exemplo: Se λ=0 com mult. alg. k, então rank(A) = n - k.",
                                    "Compare para A A^T: mesmos λ >0, mas mult. de 0 pode diferir por dim(n-m).",
                                    "Verifique com matriz rank-deficient: A=[[1,0],[0,0]], λ=1,0."
                                  ],
                                  "verification": "Conte dimensões de nullspace de A^T A e compare com mult. de λ=0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matriz de exemplo rank-deficient, solver de autovalores.",
                                  "tips": "Use deflacionamento para multiplicidades altas em computação.",
                                  "learningObjective": "Compreender como multiplicidades preservam informações de nulidade.",
                                  "commonMistakes": "Ignorar diferença de mult. de 0 entre A^T A e A A^T se m ≠ n."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar ordenação e propriedades finais",
                                  "subSteps": [
                                    "Estabeleça ordenação: σ_1 ≥ σ_2 ≥ ... ≥ σ_min(m,n) ≥ 0.",
                                    "Discuta propriedades: soma σ_i^2 = ||A||_F^2 (norma Frobenius).",
                                    "Compare colunas (A^T A) vs linhas (A A^T) para SVD assimétrico.",
                                    "Aplique a uma matriz real: compute ambos e SVD para validação.",
                                    "Resuma teorema: valores singulares são √ dos autovalores não-zero compartilhados."
                                  ],
                                  "verification": "Confirme ordenação e soma σ_i^2 = trace(A^T A) via cálculo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python/MATLAB para SVD e eigvals comparativos.",
                                  "tips": "Visualize com heatmaps de A^T A para intuitividade.",
                                  "learningObjective": "Dominar ordenação, multiplicidade e distinções colunas/linhas.",
                                  "commonMistakes": "Assumir m=n sempre; confundir ordenação com autovalores não ordenados."
                                }
                              ],
                              "practicalExample": "Para A = [[1, 2], [0, 1], [1, 0]] (3x2):\nA^T A = [[2, 2], [2, 5]], autovalores ≈6.618, 0.382 → σ≈2.572, 0.618.\nA A^T = [[2,1,1],[1,2,0],[1,0,1]], autovalores ≈3.618, 1, 0.382 → mesmos σ>0 + extra 0.",
                              "finalVerifications": [
                                "Computar autovalores de A^T A e confirmar σ_i = √λ_i ordenados.",
                                "Verificar multiplicidade de λ=0 equals codimensão do range(A).",
                                "Comparar SVD nativo com √eigvals para precisão numérica.",
                                "Confirmar soma σ_i^2 = ||A||_F^2.",
                                "Testar para m≠n: mult. λ=0 difere em A A^T.",
                                "Visualizar vetores singulares alinhados com autovetores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação σ = √λ com prova geométrica.",
                                "Correta identificação de multiplicidades e ordenação.",
                                "Uso apropriado de exemplos numéricos com validação.",
                                "Distinção clara entre A^T A (colunas) e A A^T (linhas).",
                                "Compreensão de propriedades como norma Frobenius.",
                                "Aplicação correta em casos rank-deficient."
                              ],
                              "crossCurricularConnections": [
                                "Ciência de Dados: PCA usa autovalores de matriz de covariância similar a A^T A.",
                                "Física: Modos normais em vibrações (autovalores de matrizes massa-rigidez).",
                                "Processamento de Sinais: Análise de frequência via SVD de Hankel matrices.",
                                "Computação Gráfica: Compressão de texturas via truncagem de σ pequenos."
                              ],
                              "realWorldApplication": "Em compressão de imagens (JPEG2000), SVD trunca σ pequenos derivados de autovalores de A^T A, reduzindo dados mantendo qualidade; em recomendação (Netflix), relaciona latente factors via SVD de matriz usuário-item."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "55.1.1.1.1"
                            ]
                          },
                          {
                            "id": "55.1.1.1.2.3",
                            "name": "Construir matriz Σ",
                            "description": "Dada uma matriz A m×n, construir Σ como matriz m×n diagonal com σ_i na diagonal principal (preenchendo zeros extras se m ≠ n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar dimensões da matriz A e obter valores singulares ordenados",
                                  "subSteps": [
                                    "Examine a matriz A e anote suas dimensões m (linhas) e n (colunas).",
                                    "Obtenha a lista de valores singulares σ₁ ≥ σ₂ ≥ ... ≥ σᵣ > 0 da decomposição SVD de A, onde r ≤ min(m,n).",
                                    "Ordene os valores singulares em ordem não crescente, completando com zeros se necessário até min(m,n).",
                                    "Anote k = min(m,n), o número máximo de elementos na diagonal principal.",
                                    "Verifique se todos σ_i são não-negativos."
                                  ],
                                  "verification": "Lista de dimensões (m,n) e σ_i ordenados corretamente documentados em um papel ou software.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Matriz A fornecida",
                                    "Lista de valores singulares da SVD",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Sempre ordene σ_i em ordem decrescente para padronização na SVD.",
                                  "learningObjective": "Compreender as entradas necessárias (dimensões e σ_i) para construir Σ corretamente.",
                                  "commonMistakes": [
                                    "Confundir m com n",
                                    "Não ordenar σ_i decrescentemente",
                                    "Incluir σ_i negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a matriz Σ com zeros nas dimensões m × n",
                                  "subSteps": [
                                    "Crie uma matriz vazia de tamanho m × n.",
                                    "Preencha todos os elementos com zero (Σ_{ij} = 0 para todo i,j inicialmente).",
                                    "Confirme as dimensões da matriz inicializada.",
                                    "Rotule as linhas e colunas para clareza (opcional, mas útil).",
                                    "Salve ou anote a matriz zero em formato legível."
                                  ],
                                  "verification": "Matriz Σ inicial tem exatamente m linhas e n colunas, todos elementos zero.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Software como Python/NumPy, MATLAB ou papel quadriculado"
                                  ],
                                  "tips": "Use funções como np.zeros((m,n)) em Python para eficiência.",
                                  "learningObjective": "Dominar a criação de matrizes zero com dimensões específicas.",
                                  "commonMistakes": [
                                    "Dimensões invertidas (n × m)",
                                    "Deixar elementos não-zero acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preencher a diagonal principal de Σ com os valores singulares",
                                  "subSteps": [
                                    "Para i de 1 a k = min(m,n), defina Σ_{i,i} = σ_i.",
                                    "Se m > n, as linhas extras (de n+1 a m) permanecem com zeros na diagonal e off-diagonal.",
                                    "Se n > m, as colunas extras (de m+1 a n) permanecem com zeros.",
                                    "Verifique cada posição diagonal preenchida.",
                                    "Confirme que elementos fora da diagonal principal permanecem zero."
                                  ],
                                  "verification": "Todos Σ_{i,i} = σ_i para i=1 a min(m,n), e zeros fora da diagonal.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Matriz Σ inicializada",
                                    "Lista de σ_i"
                                  ],
                                  "tips": "Preencha diagonal de cima para baixo para evitar erros de indexação.",
                                  "learningObjective": "Aplicar corretamente os σ_i na estrutura diagonal retangular.",
                                  "commonMistakes": [
                                    "Colocar σ_i fora da diagonal",
                                    "Exceder min(m,n) posições",
                                    "Preencher diagonal secundária"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e finalizar a matriz Σ",
                                  "subSteps": [
                                    "Verifique dimensões finais: m × n.",
                                    "Confirme propriedades: diagonal com σ_i corretos, resto zeros.",
                                    "Teste multiplicação conceitual: Σ deve preservar normas em SVD.",
                                    "Compare com definição formal de SVD.",
                                    "Documente a matriz final."
                                  ],
                                  "verification": "Σ satisfaz todas as propriedades da SVD e dimensões corretas.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Matriz Σ preenchida",
                                    "Referência de SVD"
                                  ],
                                  "tips": "Use print ou visualização para inspecionar a matriz.",
                                  "learningObjective": "Garantir que Σ atenda aos critérios matemáticos da decomposição SVD.",
                                  "commonMistakes": [
                                    "Ignorar retangularidade (m ≠ n)",
                                    "Erros de arredondamento em σ_i"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A 3×2 com valores singulares σ₁=5, σ₂=3: Σ = [[5, 0], [0, 3], [0, 0]]. Note a terceira linha de zeros pois m=3 > n=2.",
                              "finalVerifications": [
                                "Σ tem dimensões exatas m × n.",
                                "Elementos da diagonal principal são exatamente os σ_i ordenados até min(m,n).",
                                "Todos elementos off-diagonal são zero.",
                                "Se m > n, linhas extras são vetores zero.",
                                "Se n > m, colunas extras são vetores zero.",
                                "Σ é semi-definida positiva (raízes quadradas das autovalores de AᵀA)."
                              ],
                              "assessmentCriteria": [
                                "Correção das dimensões e preenchimento diagonal (peso 40%).",
                                "Ordenação correta e não-negatividade dos σ_i (peso 20%).",
                                "Zeros corretos em off-diagonal e extras (peso 20%).",
                                "Validação completa sem erros (peso 10%).",
                                "Clareza na documentação e exemplo prático (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Σ em NumPy com np.diag() para SVD.",
                                "Estatística: Usar em Análise de Componentes Principais (PCA).",
                                "Ciência de Dados: Compressão de matrizes em machine learning.",
                                "Física: Modelagem de sistemas lineares em mecânica quântica."
                              ],
                              "realWorldApplication": "Na compressão de imagens, Σ truncada (mantendo top-k σ_i) reduz dados mantendo qualidade, usada em JPEG2000 e recomendação de Netflix."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "55.1.1.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "55.1.1.1.3",
                        "name": "Definição Formal da Decomposição SVD",
                        "description": "Decomposição de A ∈ ℝ^{m×n} como A = U Σ V^T, onde U ∈ ℝ^{m×m} e V ∈ ℝ^{n×n} são ortogonais, e Σ ∈ ℝ^{m×n} é diagonal com valores singulares.",
                        "specificSkills": [
                          {
                            "id": "55.1.1.1.3.1",
                            "name": "Enunciar definição SVD completa",
                            "description": "Estabelecer formalmente que toda matriz A m×n admite SVD A = U Σ V^T com U e V ortogonais, Σ diagonal não-negativa ordenada, e colunas de U/V como autovetores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de ortogonalidade e decomposições matriciais",
                                  "subSteps": [
                                    "Defina uma matriz ortogonal: uma matriz Q tal que Q^T Q = I.",
                                    "Explique as propriedades: colunas e linhas são ortonormais.",
                                    "Recapitule autovetores e autovalores de uma matriz simétrica.",
                                    "Discuta matrizes diagonais e sua importância em decomposições.",
                                    "Identifique exemplos simples de matrizes ortogonais, como matrizes de rotação."
                                  ],
                                  "verification": "Escreva definições corretas de matriz ortogonal e autovetor em um papel e confira com uma referência padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Álgebra Linear (ex: Strang), notas de aula, calculadora simbólica como SymPy.",
                                  "tips": "Use diagramas vetoriais para visualizar ortonormalidade.",
                                  "learningObjective": "Compreender os blocos de construção da SVD: ortogonalidade e diagonalização.",
                                  "commonMistakes": "Confundir ortogonal com simétrica; lembrar que ortogonais preservam normas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a forma geral da decomposição SVD",
                                  "subSteps": [
                                    "Escreva a equação SVD: A = U Σ V^T para A m×n.",
                                    "Identifique dimensões: U m×m, Σ m×n, V n×n.",
                                    "Explique o papel de cada parte: U e V rotacionam, Σ escala.",
                                    "Diferencie SVD de autodecomposição (válida só para quadradas).",
                                    "Visualize geometricamente como transformação linear."
                                  ],
                                  "verification": "Desenhe um diagrama da multiplicação matricial U Σ V^T e rotule dimensões corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta para diagramas, software como MATLAB ou Python (NumPy) para visualizar.",
                                  "tips": "Pense em SVD como 'eixo principal' generalizado para retângulos.",
                                  "learningObjective": "Dominar a notação e estrutura dimensional da SVD.",
                                  "commonMistakes": "Esquecer o transposto em V^T; confundir dimensões de Σ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar propriedades específicas dos componentes SVD",
                                  "subSteps": [
                                    "Descreva Σ: diagonal com valores singulares σ_i ≥ 0, ordenados σ_1 ≥ σ_2 ≥ ... ≥ 0.",
                                    "Especifique U: colunas são autovetores de A A^T (ortogonais).",
                                    "Especifique V: colunas são autovetores de A^T A (ortogonais).",
                                    "Discuta não-negatividade e ordenação decrescente dos σ_i.",
                                    "Mencione unicidade (exceto ambiguidades em σ_i iguais)."
                                  ],
                                  "verification": "Liste as 5 propriedades chave de U, Σ, V e verifique contra definição formal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Referência teórica (ex: Golub & Van Loan), quadro branco para equações.",
                                  "tips": "Lembre: valores singulares são raízes quadradas dos autovalores de A^T A.",
                                  "learningObjective": "Internalizar propriedades exatas para enunciado preciso.",
                                  "commonMistakes": "Omitir ordenação decrescente ou não-negatividade; confundir autovetores de A A^T vs A^T A."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Enunciar e praticar a definição formal completa da SVD",
                                  "subSteps": [
                                    "Escreva o teorema: Toda A m×n admite SVD A = U Σ V^T com U, V ortogonais, Σ diagonal não-negativa ordenada.",
                                    "Inclua: colunas de U são autovetores de A A^T, V de A^T A.",
                                    "Pratique verbalizando a definição em voz alta.",
                                    "Compare com definições parciais para identificar omissões.",
                                    "Teste em matriz exemplo pequena (2x2)."
                                  ],
                                  "verification": "Escreva a definição completa de memória e peça feedback de um par ou autoavalie.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matriz exemplo impressa, gravador de áudio para autoavaliação.",
                                  "tips": "Use mnemônicos: 'U Σ V^T: Ortogonal, Diagonal Não-negativa, Ordenada'.",
                                  "learningObjective": "Capacitar-se a enunciar SVD formalmente sem consulta.",
                                  "commonMistakes": "Esquecer conexão com autovetores ou ordenação."
                                }
                              ],
                              "practicalExample": "Para A = [[3, 0], [0, 2]], SVD é A = I * diag(3,2) * I^T, com σ1=3, σ2=2; U=V=I (identidade ortogonal).",
                              "finalVerifications": [
                                "Enuncie verbalmente a definição completa sem erros.",
                                "Escreva A = U Σ V^T com propriedades corretas.",
                                "Identifique autovetores corretos para U e V em exemplo simples.",
                                "Explique ordenação e não-negatividade de Σ.",
                                "Diferencie SVD de EVD (eigenvalue decomposition)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação: U Σ V^T correto.",
                                "Menção explícita a ortogonalidade de U e V.",
                                "Descrição correta de Σ (diagonal, ≥0, ordenada decrescente).",
                                "Inclusão de autovetores de A A^T e A^T A.",
                                "Existência para qualquer A m×n (não só quadrada).",
                                "Ausência de omissões chave no enunciado."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Redução dimensional em ML (PCA via SVD).",
                                "Física: Mecânica quântica (operadores hermitianos).",
                                "Engenharia: Compressão de sinais e processamento de imagens.",
                                "Estatística: Análise de componentes principais."
                              ],
                              "realWorldApplication": "SVD é usada em recomendação de Netflix (fatores latentes), compressão JPEG (aproximação de baixo rank) e reconhecimento facial (análise de eigenfaces)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "55.1.1.1.1",
                              "55.1.1.1.2"
                            ]
                          },
                          {
                            "id": "55.1.1.1.3.2",
                            "name": "Interpretar componentes SVD",
                            "description": "Descrever o papel de U (base ortonormal para espaço coluna de A), Σ (escalas singulares) e V (base ortonormal para espaço linha de A).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Bases Ortonormais e Espaços Vetoriais",
                                  "subSteps": [
                                    "Defina base ortonormal: conjunto de vetores unitários mutuamente ortogonais.",
                                    "Explique propriedades: produto interno zero entre vetores distintos, norma 1.",
                                    "Relacione com espaços coluna (col(A)) e linha (row(A)) de uma matriz A.",
                                    "Discuta por que ortonormalidade facilita cálculos em decomposições.",
                                    "Verifique com exemplo simples: matriz identidade."
                                  ],
                                  "verification": "Escreva as propriedades de uma base ortonormal e dê um exemplo 2D.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de álgebra linear",
                                    "Calculadora matricial ou Python/NumPy"
                                  ],
                                  "tips": "Use a decomposição QR para visualizar bases ortonormais.",
                                  "learningObjective": "Compreender o papel fundamental das bases ortonormais nos componentes SVD.",
                                  "commonMistakes": [
                                    "Confundir ortogonal com ortonormal (esquecer normalização)",
                                    "Ignorar que bases SVD são para subespaços específicos de A"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar a Matriz U: Base Ortonormal para o Espaço Coluna de A",
                                  "subSteps": [
                                    "Defina U como matriz m x r cujas colunas são os vetores singulares esquerdos.",
                                    "Explique que colunas de U formam base ortonormal para col(A), o espaço gerado pelas colunas de A.",
                                    "Mostre geometricamente: U rotaciona/escala para alinhar com eixos principais.",
                                    "Calcule para matriz exemplo: encontre col(A) e projete.",
                                    "Verifique: A = U * (Σ V^T), então colunas de A são combinações lineares de colunas de U."
                                  ],
                                  "verification": "Para uma matriz A dada, identifique dim(col(A)) e descreva como U a spans.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz exemplo 3x2",
                                    "Software como MATLAB ou Jupyter Notebook com NumPy"
                                  ],
                                  "tips": "Lembre-se: U é 'left' porque multiplica pela esquerda, afetando linhas de A.",
                                  "learningObjective": "Descrever precisamente o papel geométrico e algébrico de U no SVD.",
                                  "commonMistakes": [
                                    "Pensar que U spans todo R^m (só spans col(A))",
                                    "Confundir U com autovetores de A A^T"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a Matriz Σ: Valores Singulares e Escalas",
                                  "subSteps": [
                                    "Defina Σ como matriz diagonal r x r com entradas σ1 ≥ σ2 ≥ ... ≥ σr ≥ 0 (valores singulares).",
                                    "Explique origem: raízes dos autovalores de A A^T ou A^T A.",
                                    "Discuta interpretação: σi mede 'importância' ou alongamento na direção i-ésima.",
                                    "Relacione com norma: ||A||_2 = σ1 (maior valor singular).",
                                    "Exemplo: zeros em Σ indicam nulidade."
                                  ],
                                  "verification": "Para SVD de A, liste valores singulares e ordene-os corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de SVD computado",
                                    "Tabela de autovalores de A A^T"
                                  ],
                                  "tips": "Valores singulares decrescentes ajudam em aproximações de baixo rank.",
                                  "learningObjective": "Explicar como Σ captura as escalas de deformação induzidas por A.",
                                  "commonMistakes": [
                                    "Confundir com autovalores (SVD para retângulos, não quadrados)",
                                    "Esquecer não-negatividade e ordenação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a Matriz V: Base Ortonormal para o Espaço Linha de A",
                                  "subSteps": [
                                    "Defina V como matriz n x r cujas colunas são vetores singulares direitos.",
                                    "Explique que colunas de V formam base ortonormal para row(A), espaço gerado pelas linhas de A.",
                                    "Mostre relação: linhas de A são combinações de linhas de V escaladas por Σ.",
                                    "Verifique reconstrução: A ≈ U Σ V^T para rank baixo.",
                                    "Integre: SVD captura rotação (U), escala (Σ), rotação inversa (V^T)."
                                  ],
                                  "verification": "Descreva row(A) usando colunas de V e dê exemplo numérico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz exemplo com SVD completo",
                                    "Gráficos de transformação linear"
                                  ],
                                  "tips": "V^T rotaciona o espaço de entrada para alinhar com Σ.",
                                  "learningObjective": "Compreender o papel de V na decomposição total SVD.",
                                  "commonMistakes": [
                                    "Confundir row(A) com col(A)",
                                    "Esquecer que V é para o domínio de A"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Componentes SVD e Verificar Compreensão",
                                  "subSteps": [
                                    "Escreva A = U Σ V^T e interprete cada parte.",
                                    "Discuta unicidade (até sinais) e economia SVD.",
                                    "Aplique a matriz exemplo completa.",
                                    "Compare com outras decomposições (ex: autovalores para quadradas).",
                                    "Resolva exercício: interprete SVD sem calcular."
                                  ],
                                  "verification": "Reconstrua A de seus componentes e explique cada papel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "SVD completo de matriz 3x2",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Pense em SVD como 'autovalores generalizados' para qualquer matriz.",
                                  "learningObjective": "Sintetizar interpretações de U, Σ e V em uma visão coesa do SVD.",
                                  "commonMistakes": [
                                    "Ignorar transposição em V^T",
                                    "Confundir espaços de U e V"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[1, 0], [0, 2], [0, 0]] (3x2), SVD é U = [[1,0],[0,1],[0,0]] (aprox.), Σ = diag(2,1), V = I_2. U spans col(A) = span{e1, e2} em R^3; Σ escala por 2 e 1; V spans row(A) = R^2. Reconstrução captura compressão vertical.",
                              "finalVerifications": [
                                "Explicar verbalmente o papel de U para uma matriz rank 2.",
                                "Identificar valores singulares como raízes de autovalores de A^T A.",
                                "Desenhar geometricamente como U, Σ, V transformam uma elipse unitária.",
                                "Verificar se colunas de U são ortonormais via produto interno.",
                                "Aplicar a uma matriz e confirmar A = U Σ V^T numericamente.",
                                "Discutir o que acontece quando σ_r = 0."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos espaços vetoriais associados (col(A), row(A)).",
                                "Correta distinção entre propriedades ortonormais e ortogonais.",
                                "Interpretação geométrica clara (rotação-escala-rotação).",
                                "Uso correto de terminologia (vetores singulares esquerdos/direitos).",
                                "Capacidade de integrar componentes na equação SVD.",
                                "Identificação de erros comuns em exemplos numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Machine Learning: Redução de dimensionalidade via truncado SVD em PCA.",
                                "Processamento de Imagens: Compressão JPEG2000 usando SVD de blocos.",
                                "Física: Análise de vibrações modais via SVD de matrizes de rigidez.",
                                "Estatística: Análise de correspondência múltipla com SVD."
                              ],
                              "realWorldApplication": "Em sistemas de recomendação (Netflix), SVD decompõe matriz usuário-filme: U captura preferências usuário, Σ forças de itens, V perfis de filmes, permitindo predições eficientes e redução de ruído em grandes datasets."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "55.1.1.1.3.1"
                            ]
                          },
                          {
                            "id": "55.1.1.1.3.3",
                            "name": "Verificar SVD",
                            "description": "Dadas U, Σ, V, computar U Σ V^T e confirmar igualdade com A original, usando propriedades ortogonais para validação numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as matrizes e verificar dimensões e propriedades básicas",
                                  "subSteps": [
                                    "Carregue a matriz original A e as matrizes U, Σ e V fornecidas.",
                                    "Verifique as dimensões: U deve ser m x m, Σ m x n diagonal, V n x n.",
                                    "Confirme que Σ é diagonal com valores não-negativos decrescentes.",
                                    "Visualize as matrizes usando ferramentas de plotagem ou print.",
                                    "Registre as dimensões em um log para referência."
                                  ],
                                  "verification": "Dimensões de U, Σ, V são compatíveis com A (m x n) e propriedades básicas confirmadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz A, U, Σ, V",
                                    "Python com NumPy ou MATLAB"
                                  ],
                                  "tips": [
                                    "Use np.shape() para dimensões e np.diag() para extrair valores de Σ.",
                                    "Sempre transpose V como V.T."
                                  ],
                                  "learningObjective": "Garantir compatibilidade dimensional e integridade das matrizes SVD antes do cálculo.",
                                  "commonMistakes": [
                                    "Confundir dimensões de U e V",
                                    "Esquecer que Σ é retangular para m ≠ n",
                                    "Não verificar se Σ é diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar o produto matricial U Σ V^T",
                                  "subSteps": [
                                    "Construa Σ como matriz diagonal usando np.diag() ou equivalente.",
                                    "Calcule V^T (transposta de V).",
                                    "Multiplique Σ por V^T para obter Σ V^T.",
                                    "Multiplique U por (Σ V^T) para obter o produto final Ũ = U Σ V^T.",
                                    "Armazene o resultado em uma nova matriz B."
                                  ],
                                  "verification": "Matriz B computada sem erros de broadcasting ou dimensões incompatíveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Bibliotecas NumPy/MATLAB",
                                    "Script de código preparado"
                                  ],
                                  "tips": [
                                    "Use @ para multiplicação matricial em NumPy (ex: U @ Sigma @ V.T).",
                                    "Evite loops; use operações vetoriais."
                                  ],
                                  "learningObjective": "Executar corretamente a reconstrução matricial da SVD.",
                                  "commonMistakes": [
                                    "Esquecer a transposta V^T",
                                    "Usar multiplicação elemento a elemento (*)",
                                    "Erro na construção de Σ retangular"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar B com A original e calcular erro numérico",
                                  "subSteps": [
                                    "Calcule a diferença absoluta |A - B| elemento a elemento.",
                                    "Compute a norma Frobenius ||A - B||_F = sqrt(sum(|A-B|^2)).",
                                    "Defina uma tolerância ε (ex: 1e-10) e verifique se ||A - B||_F < ε.",
                                    "Calcule erro relativo: ||A - B||_F / ||A||_F < ε_rel.",
                                    "Gere um relatório com valores de erro."
                                  ],
                                  "verification": "Erro absoluto e relativo abaixo da tolerância especificada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Funções np.linalg.norm()",
                                    "Tolerância ε definida"
                                  ],
                                  "tips": [
                                    "Use np.allclose(A, B, atol=1e-10) para verificação rápida.",
                                    "Escolha ε baseado na precisão da máquina (eps ~1e-16)."
                                  ],
                                  "learningObjective": "Avaliar numericamente a igualdade A ≈ U Σ V^T considerando erros de ponto flutuante.",
                                  "commonMistakes": [
                                    "Comparar exatidão sem tolerância",
                                    "Usar norma L1 em vez de Frobenius",
                                    "Ignorar normalização relativa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar propriedades ortogonais de U e V",
                                  "subSteps": [
                                    "Compute U^T U e verifique se é identidade I (||U^T U - I|| < ε).",
                                    "Compute V^T V e confirme identidade.",
                                    "Opcionalmente, verifique colunas de U e V como vetores unitários.",
                                    "Calcule normas das colunas de U e V (devem ser ~1).",
                                    "Registre desvios e confirme ortogonalidade."
                                  ],
                                  "verification": "U e V são aproximadamente ortogonais dentro da tolerância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "np.dot() ou @ para produtos",
                                    "np.eye() para identidade"
                                  ],
                                  "tips": [
                                    "Use np.allclose(U.T @ U, np.eye(m)) para eficiência.",
                                    "Ortogonalidade valida a qualidade da decomposição SVD."
                                  ],
                                  "learningObjective": "Usar propriedades ortogonais para validação adicional da SVD.",
                                  "commonMistakes": [
                                    "Verificar U U^T em vez de U^T U",
                                    "Não usar tolerância em ortogonalidade",
                                    "Confundir com normalização"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = np.array([[3, 1, 1], [-1, 3, 1]]), uma SVD possível é U = [[0.707, -0.408, 0.577], ...] (valores exatos via np.linalg.svd), Σ = diag([4.24, 2.0, 0]), V. Compute B = U @ Σ @ V.T, verifique ||A - B||_F < 1e-12 e U.T @ U ≈ I.",
                              "finalVerifications": [
                                "||A - U Σ V^T||_F < 1e-10",
                                "Erro relativo ||A - B||_F / ||A||_F < 1e-8",
                                "||U^T U - I||_F < 1e-10",
                                "||V^T V - I||_F < 1e-10",
                                "Valores singulares em Σ são não-negativos e decrescentes",
                                "Sem NaN ou inf em qualquer matriz"
                              ],
                              "assessmentCriteria": [
                                "Cálculo preciso do produto U Σ V^T sem erros dimensionais",
                                "Uso correto de tolerâncias numéricas para comparação",
                                "Verificação completa de ortogonalidade de U e V",
                                "Relatório claro com métricas de erro (absoluto e relativo)",
                                "Identificação e discussão de potenciais erros numéricos",
                                "Eficiência computacional (uso de operações matriciais)"
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica (NumPy, MATLAB para álgebra linear)",
                                "Análise Numérica (erros de ponto flutuante e condicionamento)",
                                "Machine Learning (validação de PCA/SVD em redução dimensional)",
                                "Processamento de Sinais (compressão via SVD)"
                              ],
                              "realWorldApplication": "Em sistemas de recomendação (Netflix), verificar SVD garante que fatores latentes reconstruam a matriz de ratings com precisão, evitando perda de dados em predições; em compressão de imagens, valida retenção de qualidade após redução de rank."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "55.1.1.1.3.1"
                            ]
                          },
                          {
                            "id": "55.1.1.1.3.4",
                            "name": "Casos especiais SVD",
                            "description": "Discutir SVD para matrizes quadradas simétricas (coincide com autodecomposição) e matrizes rank-deficient (valores singulares zero).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão e Identificação de Matrizes Quadradas Simétricas em SVD",
                                  "subSteps": [
                                    "Revise a definição formal de SVD: A = U Σ V^T para qualquer matriz A m×n.",
                                    "Identifique propriedades de matrizes quadradas simétricas: A = A^T e n×n.",
                                    "Demonstre que para A simétrica, os autovetores são ortogonais e autovalores reais.",
                                    "Explique por que SVD coincide com decomposição espectral: Σ diagonal com |λ_i|.",
                                    "Compute manualmente SVD de uma matriz simétrica 2×2 simples."
                                  ],
                                  "verification": "Construa SVD de uma matriz simétrica dada e confirme que U = V (até sinal).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora matricial ou software como MATLAB/Octave",
                                    "Papel e lápis para cálculos manuais",
                                    "Referência: 'Matrix Computations' de Golub & Van Loan (cap. 8)"
                                  ],
                                  "tips": "Sempre normalize colunas de U e V para ortonormalidade; use autovalores absolutos em Σ.",
                                  "learningObjective": "Compreender como SVD se especializa em autodecomposição para matrizes simétricas.",
                                  "commonMistakes": [
                                    "Confundir autovalores negativos com valores singulares (sempre não-negativos)",
                                    "Esquecer de verificar simetria A = A^T",
                                    "Não ordenar valores singulares em ordem decrescente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Análise de SVD para Matrizes Rank-Deficient",
                                  "subSteps": [
                                    "Defina rank-deficiência: rank(A) < min(m,n), implicando valores singulares zero.",
                                    "Discuta o número de zeros em Σ: exatamente min(m,n) - rank(A) zeros no final.",
                                    "Explique impactos: soluções mínimas norma para Ax = b via pseudoinversa.",
                                    "Compute SVD de uma matriz rank-deficient 3×2 e identifique zeros em Σ.",
                                    "Verifique estabilidade numérica: zeros exatos vs. numéricos pequenos."
                                  ],
                                  "verification": "Identifique e conte valores singulares zero em SVD de matriz rank-deficient fornecida.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software NumPy/Python ou MATLAB para SVD numérica",
                                    "Matrizes de exemplo rank-deficient impressas",
                                    "Artigo: 'Singular Value Decomposition' da Wikipedia para fórmulas"
                                  ],
                                  "tips": "Use tolerância numérica (e.g., 1e-10) para detectar zeros em computação flutuante.",
                                  "learningObjective": "Dominar o tratamento de rank-deficiência via zeros em valores singulares.",
                                  "commonMistakes": [
                                    "Assumir rank completo sem verificação",
                                    "Ignorar pseudoinversa em sistemas subdeterminados",
                                    "Confundir zeros em Σ com não-invertibilidade total"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparação, Exemplos e Discussão de Casos Especiais",
                                  "subSteps": [
                                    "Compare SVD simétrica vs. geral: U = V e Σ = diag(|λ_i|).",
                                    "Analise matriz rank-deficient simétrica: combinação dos casos.",
                                    "Resolva problemas: encontre base nula via V correspondente a σ_i=0.",
                                    "Discuta quando usar SVD vs. autodecomposição em software.",
                                    "Crie tabela resumindo propriedades para ambos casos."
                                  ],
                                  "verification": "Resuma diferenças em tabela e aplique a uma matriz mista (simétrica rank-deficient).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabelas",
                                    "Jupyter Notebook para exemplos interativos",
                                    "Exercícios de álgebra linear online (Khan Academy)"
                                  ],
                                  "tips": "Lembre: SVD generaliza autovalores para retângulos/não-simétricas.",
                                  "learningObjective": "Sintetizar casos especiais e suas implicações práticas.",
                                  "commonMistakes": [
                                    "Não considerar sinais em U/V para simétricas",
                                    "Subestimar importância de ordenação em Σ",
                                    "Confundir rank com dimensão do espaço nulo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação e Aplicação Prática dos Casos Especiais",
                                  "subSteps": [
                                    "Implemente SVD manual para matriz simétrica 3×3.",
                                    "Teste rank-deficiência removendo linha/coluna e recompute.",
                                    "Use pseudoinversa para resolver Ax=b com A rank-deficient.",
                                    "Compare resultados numéricos com analíticos.",
                                    "Documente observações sobre coincidências e zeros."
                                  ],
                                  "verification": "Produza relatório com SVs, U, V e discussões para 2 matrizes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "MATLAB ou equivalente gratuito (Octave)",
                                    "Templates de relatório LaTeX/Markdown"
                                  ],
                                  "tips": "Valide com np.linalg.svd() e compare com eig() para simétricas.",
                                  "learningObjective": "Aplicar e validar casos especiais em cenários computacionais.",
                                  "commonMistakes": [
                                    "Erro de arredondamento em zeros numéricos",
                                    "Inverter ordem de Σ",
                                    "Não verificar A ≈ U Σ V^T"
                                  ]
                                }
                              ],
                              "practicalExample": "Para matriz simétrica A = [[3,1],[1,3]], SVD é U = [[0.707,0.707],[0.707,-0.707]], Σ = diag(4,2), V=U. Para rank-deficient B = [[1,0],[0,0],[0,0]], SVD tem σ1=1, σ2=0, σ3=0, revelando rank=1.",
                              "finalVerifications": [
                                "Explicar verbalmente coincidência SVD-autovalores para simétricas.",
                                "Identificar número de zeros em Σ para dada rank.",
                                "Computar pseudoinversa via SVD para rank-deficient.",
                                "Verificar reconstrução A = U Σ V^T para ambos casos.",
                                "Discutir estabilidade numérica de zeros.",
                                "Comparar eig() vs svd() em software para simétrica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de propriedades simétricas (90%+ correto).",
                                "Correta contagem e interpretação de valores singulares zero.",
                                "Validade de reconstruções SVD (erro <1e-10).",
                                "Clareza na discussão de coincidências com autodecomposição.",
                                "Profundidade em exemplos práticos e comparações.",
                                "Uso correto de tolerâncias numéricas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: PCA via SVD em matrizes de covariância simétricas.",
                                "Ciência de Dados: Redução dimensional com truncagem de σ_i=0.",
                                "Computação Gráfica: Transformações rank-deficient em modelagem 3D.",
                                "Otimização: Pseudoinversas para mínimos quadrados.",
                                "Física: Modos normais via autovalores simétricos."
                              ],
                              "realWorldApplication": "Em processamento de imagens, SVD rank-deficient comprime dados removendo σ_i≈0; em finanças, matrizes de covariância simétricas usam SVD para análise de risco via PCA."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "55.1.1.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Valores e Vetores Singulares",
                    "description": "Conceitos de valores singulares σ_i, vetores singulares esquerdos (colunas de U) e direitos (colunas de V).",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Valores Singulares σ_i",
                        "description": "Os valores singulares de uma matriz A ∈ ℝ^{m×n} são as raízes quadradas não negativas dos autovalores da matriz AᵀA (ou AAᵀ), ordenados de forma decrescente σ₁ ≥ σ₂ ≥ ⋯ ≥ σ_r > 0, onde r é o posto de A. Eles quantificam a 'magnitude' das direções principais de ação da matriz.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Definir valores singulares",
                            "description": "Explicar a definição formal de valores singulares como √λ_i, onde λ_i são autovalores de AᵀA, e identificar o número de valores singulares positivos como o posto da matriz.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar autovalores de AᵀA",
                                  "subSteps": [
                                    "Lembre-se da definição de autovalores: λ tal que existe v ≠ 0 com AᵀA v = λ v.",
                                    "Confirme que AᵀA é simétrica e positiva semi-definida, logo autovalores λ_i ≥ 0.",
                                    "Discuta propriedades: traço(AᵀA) = soma λ_i, e det(AᵀA) = produto λ_i.",
                                    "Pratique computando autovalores para uma matriz simples 2x2.",
                                    "Verifique que autovetores são ortogonais devido à simetria."
                                  ],
                                  "verification": "Resolva o problema de autovalores para AᵀA onde A = [[1,0],[0,2]] e liste λ1, λ2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora matricial ou software como MATLAB/Octave; notas de álgebra linear.",
                                  "tips": "Sempre normalize autovetores para facilitar comparações.",
                                  "learningObjective": "Compreender a base teórica de autovalores de AᵀA como pré-requisito para SVD.",
                                  "commonMistakes": "Confundir autovalores de A com os de AᵀA; esquecer que λ_i ≥ 0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir formalmente valores singulares",
                                  "subSteps": [
                                    "Defina σ_i = √λ_i, onde λ_i são autovalores de AᵀA ordenados decrescentemente.",
                                    "Explique que σ_1 ≥ σ_2 ≥ ... ≥ σ_r > 0 são os valores singulares não-nulos.",
                                    "Discuta que há min(m,n) valores singulares possíveis para A m×n.",
                                    "Mostre a relação ||A||_2 = σ_1 (norma espectral).",
                                    "Derive brevemente por que σ_i = ||A u_i|| para autovetor u_i de AᵀA."
                                  ],
                                  "verification": "Escreva a definição formal de σ_i para uma matriz genérica A e compute para A = [[3,0],[0,4]].",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de papel para derivações; tabela de fórmulas de normas.",
                                  "tips": "Ordene λ_i decrescente antes de tirar raiz para manter convenção.",
                                  "learningObjective": "Estabelecer a definição precisa de valores singulares como raízes de autovalores.",
                                  "commonMistakes": "Tirar raiz quadrada de λ_i sem ordenar; confundir com autovalores de A."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar valores singulares ao posto da matriz",
                                  "subSteps": [
                                    "Identifique que o posto de A, rank(A), é o número de σ_i > 0.",
                                    "Explique que σ_i = 0 iff coluna de A é linearmente dependente.",
                                    "Discuta nulidade: dim(ker(A)) = n - rank(A), onde n = colunas.",
                                    "Verifique com teorema da dimensão: rank(A) + nullity(A) = n.",
                                    "Aplique a uma matriz rank-deficient, como A = [[1,2],[2,4]]."
                                  ],
                                  "verification": "Para A = [[1,1],[1,1]], compute σ_i e confirme rank(A) = 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exemplos de matrizes rank-deficient; software para SVD.",
                                  "tips": "Use tolerância numérica (ex: 1e-10) para σ_i ≈ 0 em computação.",
                                  "learningObjective": "Conectar valores singulares positivos diretamente ao conceito de posto.",
                                  "commonMistakes": "Contar todos σ_i incluindo zeros; ignorar precisão numérica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e sintetizar a definição completa",
                                  "subSteps": [
                                    "Compute SVD parcial para matriz 3x2: encontre λ_i de AᵀA, σ_i, e rank.",
                                    "Explique verbalmente a definição para um colega ou em voz alta.",
                                    "Resolva exercício: dado σ_i, reconstrua propriedades de AᵀA.",
                                    "Compare com definições alternativas (ex: max ||Ax||/||x||).",
                                    "Registre em um resumo: definição + posto + exemplo."
                                  ],
                                  "verification": "Produza um relatório de 1 página definindo σ_i e provando rank(A) = # {σ_i > 0}.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Matriz de exercício; ferramenta computacional como Python NumPy.",
                                  "tips": "Sempre verifique simetria de AᵀA antes de prosseguir.",
                                  "learningObjective": "Sintetizar e aplicar a definição em contextos variados.",
                                  "commonMistakes": "Esquecer ordenação decrescente; confundir σ_i com elementos da diagonal de Σ."
                                }
                              ],
                              "practicalExample": "Para A = [[1, 0], [0, 2], [3, 4]] (3x2), compute AᵀA = [[10, 12], [12, 20]], autovalores λ1≈27.38, λ2≈2.62, então σ1≈5.23, σ2≈1.62 (ambos >0), rank(A)=2.",
                              "finalVerifications": [
                                "Definição correta de σ_i = √λ_i com λ_i de AᵀA.",
                                "Identificação precisa de rank(A) como número de σ_i > 0.",
                                "Cálculo correto para pelo menos dois exemplos numéricos.",
                                "Explicação da não-negatividade dos σ_i.",
                                "Reconhecimento de ordenação decrescente.",
                                "Aplicação a matriz rank-deficient."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% match com √λ_i).",
                                "Correção em cálculos de autovalores e raízes.",
                                "Compreensão conceitual do posto via σ_i > 0.",
                                "Clareza na explicação escrita/oral.",
                                "Uso apropriado de exemplos e verificações.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Implementação numérica de SVD em PCA.",
                                "Física: Valores singulares em análise de tensores de tensão.",
                                "Estatística: Redução de dimensionalidade em dados multivariados.",
                                "Engenharia: Compressão de sinais e análise de estabilidade."
                              ],
                              "realWorldApplication": "Em processamento de imagens, os valores singulares de SVD determinam componentes principais para compressão (ex: JPEG), onde rank baixo permite redução sem perda perceptível de qualidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Calcular valores singulares para matrizes pequenas",
                            "description": "Computar os valores singulares de uma matriz 2×2 ou 3×3 calculando os autovalores de AᵀA e extraindo as raízes quadradas, ordenando-os decrescentemente.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Relacionar valores singulares com normas de matriz",
                            "description": "Associar σ₁ à norma espectral ||A||₂, σ_min ao valor condicional cond₂(A) = σ₁/σ_r, e explicar implicações para estabilidade numérica.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Vetores Singulares Direitos",
                        "description": "Os vetores singulares direitos de A são os autovetores ortonormais de AᵀA, formando as colunas da matriz V na decomposição SVD A = UΣVᵀ, satisfazendo AᵀA v_i = σ_i² v_i.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Definir vetores singulares direitos",
                            "description": "Descrever os vetores singulares direitos como autovetores de AᵀA normalizados, com ortonormalidade {v_i}, e seu papel como direções de entrada na SVD.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a matriz AᵀA e suas propriedades",
                                  "subSteps": [
                                    "Revise o conceito de transposta de uma matriz: Aᵀ é a matriz com linhas e colunas trocadas.",
                                    "Multiplique Aᵀ por A para formar AᵀA, notando que resulta em uma matriz quadrada m x m se A é m x n.",
                                    "Verifique que AᵀA é simétrica (AᵀA = (AᵀA)ᵀ) e semidefinida positiva (xᵀ AᵀA x ≥ 0 para todo x).",
                                    "Discuta por que AᵀA captura as normas das colunas de A.",
                                    "Calcule um exemplo simples manualmente."
                                  ],
                                  "verification": "Confirme que AᵀA é simétrica e calcule seus autovalores não-negativos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lápis e papel",
                                    "Calculadora matricial",
                                    "Notebook Jupyter com NumPy"
                                  ],
                                  "tips": "Sempre verifique a simetria multiplicando por um vetor teste e confirmando positividade.",
                                  "learningObjective": "Identificar propriedades fundamentais de AᵀA e sua relevância para autovalores.",
                                  "commonMistakes": [
                                    "Confundir AᵀA com AAᵀ (que é para vetores singulares esquerdos)",
                                    "Esquecer de normalizar autovetores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir autovetores e autovalores de AᵀA",
                                  "subSteps": [
                                    "Lembre que autovetores v satisfazem AᵀA v = σ² v, onde σ² são autovalores não-negativos.",
                                    "Ordene os autovalores em ordem decrescente: σ₁² ≥ σ₂² ≥ ... ≥ σᵣ² > 0.",
                                    "Encontre autovetores correspondentes {v₁, v₂, ..., vₘ} formando uma base ortonormal.",
                                    "Use diagonalização: AᵀA = V Σ² Vᵀ, onde V é a matriz de autovetores.",
                                    "Pratique computando para uma matriz 2x2."
                                  ],
                                  "verification": "Resolva AᵀA v = λ v para λ = σ² e normalize v para ||v|| = 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software NumPy/SciPy para eigen decomp",
                                    "Exemplos de matrizes impressas"
                                  ],
                                  "tips": "Use np.linalg.eigh para matrizes simétricas em Python para verificação rápida.",
                                  "learningObjective": "Calcular e interpretar autovetores de AᵀA como direções principais.",
                                  "commonMistakes": [
                                    "Não ordenar autovalores decrescentemente",
                                    "Esquecer que autovalores são σ², não σ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir vetores singulares direitos como autovetores normalizados",
                                  "subSteps": [
                                    "Defina v_i como o autovetor normalizado de AᵀA associado a σ_i² (i=1 a r).",
                                    "Estabeleça ortonormalidade: v_iᵀ v_j = δ_{ij} (base ortonormal).",
                                    "Note que A v_i = σ_i u_i, ligando a vetores singulares esquerdos u_i.",
                                    "Construa a matriz V = [v₁ | v₂ | ... | v_r] com colunas v_i.",
                                    "Verifique normalização: ||v_i||₂ = 1 para cada i."
                                  ],
                                  "verification": "Mostre que {v_i} são ortonormais e AᵀA v_i = σ_i² v_i com ||v_i||=1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz exemplo A impressa",
                                    "Python com SVD built-in para checagem"
                                  ],
                                  "tips": "Gram-Schmidt pode ajudar a ortonormalizar se necessário, mas eigen já fornece.",
                                  "learningObjective": "Formalizar v_i como vetores singulares direitos na SVD.",
                                  "commonMistakes": [
                                    "Confundir normalização L1 com L2",
                                    "Ignorar zeros para σ_i=0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar o papel dos vetores singulares direitos na SVD",
                                  "subSteps": [
                                    "Na SVD A = U Σ Vᵀ, V tem colunas v_i: direções de entrada/rotacionadas.",
                                    "v_i maximiza ||A x|| para ||x||=1 no subespaço dos primeiros i vetores.",
                                    "Discuta interpretação geométrica: alongamentos σ_i nas direções v_i.",
                                    "Ligue a redução de rank: primeiros r vetores capturam toda a imagem de A.",
                                    "Compare com PCA: v_i são componentes principais de AᵀA."
                                  ],
                                  "verification": "Descreva como A v_i = σ_i u_i e interprete na decomposição SVD.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama visual de SVD",
                                    "Vídeo curto sobre interpretação geométrica"
                                  ],
                                  "tips": "Visualize com plot de elipse: A transforma esfera unitária em elipse com eixos σ_i v_i.",
                                  "learningObjective": "Entender v_i como direções de entrada na transformação linear A.",
                                  "commonMistakes": [
                                    "Confundir v_i (direita) com u_i (esquerda)",
                                    "Pensar que v_i são colunas de A"
                                  ]
                                }
                              ],
                              "practicalExample": "Para A = [[3, 0], [0, 2]], AᵀA = [[9, 0], [0, 4]]. Autovalores σ₁²=9 (σ₁=3), σ₂²=4 (σ₂=2). Vetores singulares direitos: v₁ = [1, 0]ᵀ, v₂ = [0, 1]ᵀ (já normalizados e ortonormais). SVD: A = U Σ Vᵀ com V identidade.",
                              "finalVerifications": [
                                "Defina v_i como autovetores normalizados de AᵀA ordenados por σ_i decrescente.",
                                "Prove ortonormalidade: v_iᵀ v_j = δ_{ij}.",
                                "Explique A v_i = σ_i u_i.",
                                "Descreva papel na SVD: colunas de V como direções de entrada.",
                                "Verifique com exemplo numérico: compute v_i para A dada.",
                                "Diferencie de vetores singulares esquerdos u_i de AAᵀ."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na definição e propriedades (40%)",
                                "Clareza na explicação de ortonormalidade e normalização (20%)",
                                "Interpretação precisa do papel na SVD (20%)",
                                "Uso correto de notação (AᵀA, σ_i, v_i) (10%)",
                                "Exemplo prático computado corretamente (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modos normais em vibrações (autovetores de matriz de massa-rigidez).",
                                "Ciência de Dados: Direções principais em PCA para redução dimensional.",
                                "Processamento de Sinais: Bases ortonormais em filtros wavelet.",
                                "Computação Gráfica: Transformações lineares em renderização."
                              ],
                              "realWorldApplication": "Em compressão de imagens (JPEG2000), os vetores singulares direitos v_i de blocos de pixels representam direções de variação nos dados originais, permitindo reconstrução eficiente com poucos termos de maior σ_i, reduzindo armazenamento sem perda perceptível de qualidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Calcular vetores singulares direitos",
                            "description": "Para uma matriz pequena, computar AᵀA, encontrar autovetores associados a cada σ_i² e normalizá-los para obter as colunas de V.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Verificar propriedades ortonormais",
                            "description": "Verificar que VᵀV = I, confirmando ortonormalidade dos vetores singulares direitos, e relacionar com a decomposição espectral de AᵀA.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Vetores Singulares Esquerdos",
                        "description": "Os vetores singulares esquerdos de A são os autovetores ortonormais de AAᵀ, formando as colunas da matriz U na SVD A = UΣVᵀ, satisfazendo AAᵀ u_i = σ_i² u_i.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Definir vetores singulares esquerdos",
                            "description": "Explicar os vetores singulares esquerdos como autovetores de AAᵀ normalizados, com ortonormalidade {u_i}, e seu papel como direções de saída na SVD.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Calcular vetores singulares esquerdos",
                            "description": "Computar AAᵀ para uma matriz pequena, diagonalizar para obter autovetores u_i associados a σ_i² e normalizá-los para as colunas de U.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Relacionar u_i com A v_i",
                            "description": "Demonstrar que u_i = A v_i / σ_i para σ_i > 0, verificando a consistência entre vetores esquerdos, direitos e valores singulares na SVD.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Decomposição em Valores Singulares (SVD)",
                                  "subSteps": [
                                    "Relembre a forma SVD: A = U Σ V^T, onde U e V são ortonormais, Σ diagonal com σ_i ≥ 0.",
                                    "Identifique u_i como i-ésima coluna de U (vetor singular esquerdo), v_i como i-ésima coluna de V (vetor singular direito).",
                                    "Confirme que σ_i > 0 para os primeiros r valores singulares (rank de A).",
                                    "Estude a propriedade: colunas de U são autovetores de A A^T, V de A^T A.",
                                    "Anote as dimensões: U (m x m), Σ (m x n), V (n x n) para A (m x n)."
                                  ],
                                  "verification": "Escreva a equação SVD completa e defina corretamente u_i, v_i, σ_i em um papel ou notebook.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre SVD",
                                    "Notebook Jupyter ou papel"
                                  ],
                                  "tips": "Use diagramas para visualizar U, Σ, V multiplicando para formar A.",
                                  "learningObjective": "Compreender os componentes fundamentais da SVD e suas relações.",
                                  "commonMistakes": "Confundir u_i (esquerdo) com v_i (direito) ou ignorar σ_i decrescentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular A v_i para um Índice i Específico",
                                  "subSteps": [
                                    "Selecione uma matriz A exemplo (ex: 2x2) e compute sua SVD usando software.",
                                    "Extraia v_i e σ_i para i=1 (maior σ_i).",
                                    "Multiplique A v_i matematicamente ou numericamente.",
                                    "Verifique a norma de A v_i: deve ser σ_i, pois ||A v_i|| = σ_i ||v_i|| = σ_i.",
                                    "Registre o vetor resultante w_i = A v_i."
                                  ],
                                  "verification": "Confirme que ||A v_i|| ≈ σ_i usando norma euclidiana.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy (np.linalg.svd)",
                                    "Matriz exemplo A = [[3, 0], [0, 2]]"
                                  ],
                                  "tips": "Use np.dot(A, v_i) no código para precisão numérica.",
                                  "learningObjective": "Executar multiplicação matricial A v_i e relacionar com σ_i.",
                                  "commonMistakes": "Usar v_i não normalizado ou errar dimensões na multiplicação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Computar u_i = (A v_i) / σ_i",
                                  "subSteps": [
                                    "Partindo de A = U Σ V^T, multiplique por v_i: A v_i = U Σ e_i = σ_i u_i (pois V^T v_i = e_i).",
                                    "Assim, u_i = A v_i / σ_i para σ_i > 0.",
                                    "Compute numericamente: divida w_i por σ_i.",
                                    "Verifique se o resultado tem norma 1 (ortonormalidade).",
                                    "Compare com u_i da SVD computada."
                                  ],
                                  "verification": "|| (A v_i)/σ_i || = 1 e igual a u_i da decomposição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python estendendo o Step 2",
                                    "Calculadora simbólica como SymPy opcional"
                                  ],
                                  "tips": "Normalize explicitamente se houver erro numérico pequeno (<1e-10).",
                                  "learningObjective": "Demonstrar algebricamente e numericamente a relação u_i = A v_i / σ_i.",
                                  "commonMistakes": "Dividir por σ_i = 0 ou esquecer normalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Consistência para Múltiplos i e Propriedades Gerais",
                                  "subSteps": [
                                    "Repita para i=2 até r (rank), confirmando u_i ⊥ u_j para i ≠ j.",
                                    "Verifique A ≈ Σ u_i σ_i v_i^T (aproximação de baixo rank).",
                                    "Teste com matriz ruidosa para robustez numérica.",
                                    "Analise resíduos: ||A - Σ_{i=1}^k σ_i u_i v_i^T|| diminui com k.",
                                    "Documente observações sobre precisão."
                                  ],
                                  "verification": "Todos u_i coincidem com SVD e são ortonormais (U^T U = I).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo código Python",
                                    "Matriz maior 3x3 para teste"
                                  ],
                                  "tips": "Use loop for i in range(min(m,n)) no código.",
                                  "learningObjective": "Validar a relação em contexto completo da SVD.",
                                  "commonMistakes": "Ignorar σ_i pequenos (quase zero) ou não checar ortogonalidade."
                                }
                              ],
                              "practicalExample": "Para A = [[3, 1], [1, 3]], SVD dá σ1≈3.16, v1≈[0.707,0.707], A v1 ≈ [3.16*0.707, 3.16*0.707] = σ1 [0.707,0.707] = σ1 u1, assim u1 = A v1 / σ1 ≈ [0.707, 0.707]. Repita para i=2.",
                              "finalVerifications": [
                                "u_i computado = A v_i / σ_i coincide com u_i da SVD (erro <1e-10).",
                                "||u_i|| = 1 e u_i · u_j = 0 para i ≠ j.",
                                "A v_i = σ_i u_i algebricamente e numericamente.",
                                "Reconstrução parcial Σ σ_i u_i v_i^T aproxima A.",
                                "Teste com 2-3 matrizes diferentes confirma consistência.",
                                "Norma de resíduos diminui com mais termos."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica na relação u_i = A v_i / σ_i (erro relativo <1%).",
                                "Correta derivação algébrica da propriedade SVD.",
                                "Verificação de ortonormalidade de U.",
                                "Uso adequado de ferramentas computacionais sem erros de indexação.",
                                "Análise de consistência para múltiplos i.",
                                "Identificação e correção de erros numéricos comuns."
                              ],
                              "crossCurricularConnections": [
                                "Ciência de Dados: Base para PCA e redução dimensional.",
                                "Processamento de Sinais: Compressão de imagens via SVD truncada.",
                                "Física Computacional: Modos normais em dinâmica de sistemas.",
                                "Machine Learning: Inicialização de fatores em modelos de matriz baixa rank."
                              ],
                              "realWorldApplication": "Em recomendação de Netflix, SVD relaciona vetores latentes de usuários (u_i) com itens (v_i) para prever preferências; em compressão de imagens JPEG2000, trunca σ_i pequenos preservando u_i ≈ A v_i / σ_i para features principais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.2",
                              "10.1.1.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Propriedades da SVD",
                    "description": "Propriedades como unicidade dos valores singulares, relação com normas e posto da matriz, e decomposição de posto baixo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Unicidade dos Valores Singulares",
                        "description": "A unicidade dos valores singulares na decomposição SVD, independentemente da escolha das matrizes fatoradas, garantindo que os valores σ_i sejam os mesmos para qualquer fatoração válida.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Definir e identificar valores singulares únicos",
                            "description": "Explicar a definição formal dos valores singulares como raízes quadradas dos autovalores da matriz A*A^T ou A^T*A, e demonstrar que eles são intrínsecos à matriz A, não dependendo das matrizes U e V.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Provar a unicidade dos valores singulares",
                            "description": "Realizar a prova matemática da unicidade mostrando que os autovalores de A*A^T e A^T*A coincidem (exceto possivelmente zeros), e assim os σ_i ordenados são únicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de SVD e Valores Singulares",
                                  "subSteps": [
                                    "Defina a Decomposição em Valores Singulares (SVD) para uma matriz A m×n como A = U Σ V^T, onde U e V são ortogonais e Σ é diagonal com entradas σ_i ≥ 0 ordenadas decrescentemente.",
                                    "Explique que os valores singulares σ_i são as raízes quadradas dos autovalores de A^T A ou A A^T.",
                                    "Estabeleça a notação: r = rank(A), e os r primeiros σ_i > 0 são os não-nulos.",
                                    "Lembre que a unicidade refere-se aos σ_i ordenados, não às matrizes U e V."
                                  ],
                                  "verification": "Escreva as definições em um papel e confirme que σ_i = √λ_i onde λ_i são autovalores positivos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, livro de Álgebra Linear (ex: Strang)",
                                  "tips": "Use diagramas para visualizar U, Σ, V.",
                                  "learningObjective": "Compreender a relação fundamental entre SVD e autovalores.",
                                  "commonMistakes": "Confundir valores singulares com autovalores de A diretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Matrizes A A^T e A^T A",
                                  "subSteps": [
                                    "Note que A A^T é m×m simétrica positiva semidefinida, assim como A^T A é n×n.",
                                    "Estabeleça que os autovalores de A A^T são λ_1 ≥ ... ≥ λ_m ≥ 0, e de A^T A são μ_1 ≥ ... ≥ μ_n ≥ 0.",
                                    "Observe que trace(A A^T) = trace(A^T A) = ||A||_F^2, ligando as somas de autovalores.",
                                    "Discuta o número de autovalores zero: m - r para A A^T e n - r para A^T A."
                                  ],
                                  "verification": "Calcule trace(A A^T) para uma matriz exemplo e confirme igualdade com trace(A^T A).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou software como Python/NumPy para exemplo simples",
                                  "tips": "Comece com A quadrada para intuição antes de generalizar.",
                                  "learningObjective": "Reconhecer propriedades espectrais de A A^T e A^T A.",
                                  "commonMistakes": "Esquecer que são simétricas e têm autovalores reais não-negativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que Autovalores Não-Zero Coincidem",
                                  "subSteps": [
                                    "Suponha λ > 0 autovalor de A A^T com autovetor u ≠ 0: A A^T u = λ u.",
                                    "Mostre que v = A^T u / √λ é autovetor de A^T A: A^T A v = λ v, e ||v||=1.",
                                    "Inversamente, para μ > 0 de A^T A com v, u = A v / √μ é autovetor de A A^T.",
                                    "Conclua que os r autovalores positivos {λ_1, ..., λ_r} = {μ_1, ..., μ_r}, ordenados.",
                                    "Prove que multiplicidades coincidem para cada λ > 0."
                                  ],
                                  "verification": "Escreva a prova formal dos dois sentidos e verifique com um vetor exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel para derivações algébricas",
                                  "tips": "Normalize vetores para preservar normas euclidianas.",
                                  "learningObjective": "Dominar a prova de coincidência dos autovalores não-zero.",
                                  "commonMistakes": "Não normalizar corretamente, levando a ||v|| ≠ 1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estabelecer Unicidade dos Valores Singulares Ordenados",
                                  "subSteps": [
                                    "Defina σ_i = √λ_i para i=1 a r, e σ_i=0 para i>r.",
                                    "Como λ_i ordenados são únicos (autovalores distintos ou com multiplicidade), σ_i decrescentes são únicos.",
                                    "Note que zeros extras não afetam unicidade dos σ_i ordenados.",
                                    "Conclua que em qualquer SVD, os σ_i são os mesmos."
                                  ],
                                  "verification": "Para uma matriz exemplo, compute autovalores e extraia σ_i, confirmando igualdade em múltiplas SVDs.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software como MATLAB ou Python (numpy.linalg.svd)",
                                  "tips": "Teste com matriz rank-deficiente para ver zeros.",
                                  "learningObjective": "Concluir a unicidade a partir da coincidência espectral.",
                                  "commonMistakes": "Ignorar multiplicidades ou ordenação decrescente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Generalizar a Prova",
                                  "subSteps": [
                                    "Resuma a prova: autovalores não-zero iguais ⇒ σ_i = √λ_i únicos quando ordenados.",
                                    "Discuta casos especiais: A quadrada, rank-plena, nula.",
                                    "Relacione com propriedades de normas: σ_1 = ||A||_2, etc.",
                                    "Pense em implicações para estabilidade numérica em computação."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a prova completa e teste em uma matriz 2x3.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exemplo matricial impresso",
                                  "tips": "Use abstração: foque em propriedades invariantes.",
                                  "learningObjective": "Internalizar e generalizar o teorema de unicidade.",
                                  "commonMistakes": "Confundir unicidade de Σ com de U,V."
                                }
                              ],
                              "practicalExample": "Considere A = [[1,0],[0,2],[0,0]] (3x2). Compute A A^T = diag(1,4,0), autovalores 4,1,0 → σ = [2,1,0]. A^T A = [[1,0],[0,4]], autovalores 1,4 → mesmo σ. Qualquer SVD terá esses σ_i exatos.",
                              "finalVerifications": [
                                "Pode provar que autovetor u de A A^T gera v para A^T A?",
                                "Consegue mostrar multiplicidades coincidem para λ>0?",
                                "Computa σ_i corretamente de autovalores para matriz exemplo?",
                                "Explica por que ordenação garante unicidade?",
                                "Discute impacto de rank em zeros?",
                                "Resume prova em 5 linhas?"
                              ],
                              "assessmentCriteria": [
                                "Clareza na derivação da correspondência u ↔ v.",
                                "Correta normalização e preservação de autovalores.",
                                "Tratamento preciso de autovalores zero e multiplicidades.",
                                "Lógica impecável na conclusão de unicidade ordenada.",
                                "Uso correto de propriedades simétricas e normas.",
                                "Generalização para dimensões arbitrárias m,n."
                              ],
                              "crossCurricularConnections": [
                                "Física: Espectro de operadores em mecânica quântica (similar a A A†).",
                                "Computação: Estabilidade numérica em algoritmos SVD (Golub-Reinsch).",
                                "Estatística: Análise de componentes principais (PCA) via SVD.",
                                "Otimização: Problema de decomposição espectral em machine learning."
                              ],
                              "realWorldApplication": "Em sistemas de recomendação (Netflix), SVD comprime matrizes usuário-item; unicidade dos σ_i garante que fatores latentes sejam consistentes independentemente do algoritmo, permitindo reconstruções estáveis e escaláveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Aplicar unicidade em exemplos numéricos",
                            "description": "Computar SVD de uma matriz usando software ou manualmente e verificar que diferentes implementações produzem os mesmos valores singulares ordenados.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Relação da SVD com Normas da Matriz",
                        "description": "Como os valores singulares determinam as normas principais da matriz, como a norma espectral (σ_max) e a norma de Frobenius (raiz da soma dos quadrados dos σ_i).",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Expressar norma 2 via valor singular máximo",
                            "description": "Demonstrar que ||A||_2 = σ_1 (maior valor singular), interpretando geometricamente como o alongamento máximo da matriz em direções unitárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição da Norma 2 da Matriz",
                                  "subSteps": [
                                    "Lembre a definição: ||A||_2 = sup_{||x||_2=1} ||Ax||_2, o ganho máximo da transformação linear A sobre vetores unitários.",
                                    "Interprete geometricamente como o alongamento máximo que A causa em qualquer direção unitária.",
                                    "Calcule ||A||_2 para matrizes simples, como diagonais (onde ||A||_2 = max |λ_i|).",
                                    "Compare com outras normas (ex: norma 1, infinito) para destacar diferenças.",
                                    "Pratique com uma matriz 2x2 não diagonal para intuição."
                                  ],
                                  "verification": "Calcule ||A||_2 para A = [[2,0],[0,1]] e confirme que é 2, o maior alongamento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou Python/NumPy para verificação"
                                  ],
                                  "tips": "Pense em ||A||_2 como o 'estiramento máximo' de A; visualize elipsoides unitários mapeados.",
                                  "learningObjective": "Dominar a definição e interpretação geométrica inicial da norma 2.",
                                  "commonMistakes": [
                                    "Confundir com norma espectral de autovalores (válida só para normais); usar ||A||_F em vez de ||A||_2."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Decomposição em Valores Singulares (SVD)",
                                  "subSteps": [
                                    "Revise SVD: A = U Σ V^T, onde Σ tem valores singulares σ_1 ≥ σ_2 ≥ ... ≥ 0 na diagonal.",
                                    "Explique que σ_i são as semi-eixos do elipsoide imagem da esfera unitária sob A.",
                                    "Calcule SVD manualmente para matriz 2x2: encontre V via autovetores de A^T A.",
                                    "Verifique propriedades: σ_1 é o maior valor singular, raiz do maior autovalor de A^T A.",
                                    "Use software para SVD de matriz maior e observe os σ_i."
                                  ],
                                  "verification": "Decomponha A = [[1,1],[0,1]] em SVD e identifique σ_1 ≈ 1.618.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Python com NumPy (np.linalg.svd)",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "A^T A é simétrica positiva semidefinida; seus autovalores são σ_i^2.",
                                  "learningObjective": "Compreender SVD e o papel dos valores singulares como alongamentos.",
                                  "commonMistakes": [
                                    "Esquecer que SVD existe para qualquer matriz, não só quadrada; confundir U e V."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Relação ||A||_2 = σ_1",
                                  "subSteps": [
                                    "Mostre que ||Ax||_2 ≤ σ_1 ||x||_2 para todo x, com igualdade para vetor singular direito.",
                                    "Prove: ||Ax||_2^2 = x^T A^T A x ≤ λ_max(A^T A) x^T x = σ_1^2 ||x||_2^2.",
                                    "Demonstre o atingimento: para v_1 (autovetor de A^T A com λ=σ_1^2), ||A v_1||_2 = σ_1.",
                                    "Generalize para qualquer ||x||_2=1 via Rayleigh quotient.",
                                    "Verifique numericamente com SVD computada."
                                  ],
                                  "verification": "Para A da Step 2, confirme ||A||_2 = σ_1 via sup e via SVD.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel e lápis para prova",
                                    "Python/NumPy para ||A||_2 via np.linalg.norm(A, 2)"
                                  ],
                                  "tips": "Use o fato de que o máximo de x^T M x / x^T x é λ_max para M = A^T A.",
                                  "learningObjective": "Provar analiticamente que a norma 2 é o maior valor singular.",
                                  "commonMistakes": [
                                    "Ignorar normalização ||x||=1; confundir σ_1 com autovalor de A."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Geometricamente a Relação",
                                  "subSteps": [
                                    "Visualize: esfera unitária ||x||_2=1 mapeada por A para elipsoide com semi-eixo maior σ_1.",
                                    "Desenhe para 2D: A alonga direção v_1 por σ_1, contrai outras.",
                                    "Explique por que σ_1 captura o alongamento máximo: raio máximo do elipsoide.",
                                    "Conecte a prova: direção de máximo ganho é o primeiro vetor singular direito.",
                                    "Crie gráfico ou simulação para matriz não simétrica."
                                  ],
                                  "verification": "Descreva/esboce o mapeamento geométrico para A = [[3,0],[0,1]] e identifique alongamento máximo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para desenhos",
                                    "Software como MATLAB/GeoGebra ou Python Matplotlib para plot"
                                  ],
                                  "tips": "Pense em A como deformação elíptica; σ_1 é o diâmetro maior.",
                                  "learningObjective": "Interpretar ||A||_2 = σ_1 geometricamente como alongamento máximo.",
                                  "commonMistakes": [
                                    "Confundir elipsoide imagem com o de autovalores; ignorar rotação por U/V."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[4, 3], [0, 2]]. SVD: σ_1 ≈ 5 (maior alongamento). Calcule ||A||_2 = sup_{||x||=1} ||Ax|| ≈ 5, atingido em x ≈ [0.8, 0.6]. Geometricamente, A alonga a direção [0.8, 0.6] por 5 unidades, confirmando ||A||_2 = σ_1.",
                              "finalVerifications": [
                                "Calcule corretamente SVD e identifique σ_1 para matriz 2x2x3 dada.",
                                "Prove ||A||_2 ≤ σ_1 e mostre igualdade com vetor singular.",
                                "Explique geometricamente o alongamento máximo em direção unitária.",
                                "Verifique numericamente com software: np.linalg.norm(A,2) == σ_1.",
                                "Aplique a uma matriz 3x2 e confirme interpretação.",
                                "Responda: Por que ||A||_2 não depende de autovalores de A?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e prova de ||A||_2 = σ_1 (80% peso).",
                                "Clareza na interpretação geométrica com esboço ou descrição.",
                                "Correção em cálculos SVD e norma para exemplos.",
                                "Uso adequado de vetores singulares para atingimento do supremo.",
                                "Identificação de erros comuns e conexões com propriedades SVD.",
                                "Profundidade em substeps e verificações pessoais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Normas em operadores lineares para dinâmica quântica (evolução unitária).",
                                "Ciência da Computação: Condicionamento κ(A) = σ_1 / σ_min em solvers numéricos.",
                                "Engenharia: Análise de estabilidade em controle de sistemas lineares.",
                                "Processamento de Sinais: Filtro de ruído via truncada SVD, onde σ_1 domina sinal."
                              ],
                              "realWorldApplication": "Em machine learning, ||A||_2 = σ_1 mede o Lipschitz constant de camadas lineares em redes neurais, essencial para garantir convergência em gradiente descendente e evitar explosão de gradientes; usado em PCA para redução dimensional priorizando componentes de maior variância (σ_1)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Calcular norma de Frobenius usando SVD",
                            "description": "Provar e aplicar a fórmula ||A||_F = sqrt(∑ σ_i²), comparando com a definição direta soma de quadrados dos elementos de A.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Relacionar condição da matriz com SVD",
                            "description": "Explicar que o número de condição κ_2(A) = σ_1 / σ_min, e analisar sensibilidade numérica usando essa relação.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Relação com Posto e Decomposição de Posto Baixo",
                        "description": "Determinação do posto da matriz pelo número de valores singulares não nulos e uso da SVD truncada para aproximações de posto baixo.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Determinar posto via valores singulares",
                            "description": "Identificar que rank(A) = número de σ_i > 0 (tolerância numérica), provando que A é singular se σ_min = 0.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Construir decomposição de posto baixo",
                            "description": "Gerar a aproximação A_k = U_k Σ_k V_k^T, onde k < rank(A), e provar que minimiza o erro em norma 2 entre matrizes de posto ≤ k.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Aplicar SVD truncada em dados",
                            "description": "Usar SVD de posto baixo para compressão de imagens ou redução de dimensionalidade, computando numericamente e avaliando erro de reconstrução.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Algoritmos de Computação da SVD",
                    "description": "Métodos numéricos principais, como o algoritmo de Golub-Reinsch ou via decomposição QR iterativa.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Algoritmo de Golub-Reinsch",
                        "description": "Algoritmo clássico para computação da Decomposição em Valores Singulares (SVD) de uma matriz retangular, baseado em bidiagonalização por transformações Householder seguidas de iterações QR para refinamento dos valores singulares e vetores.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Descrever os passos da bidiagonalização",
                            "description": "Explicar detalhadamente o processo de redução da matriz A (m x n) a uma forma bidiagonal superior usando reflexões de Householder, incluindo a eliminação de elementos fora da banda e a preservação da SVD.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Implementar iterações QR para valores singulares",
                            "description": "Desenvolver pseudocódigo para as iterações QR no bloco bidiagonal, descrevendo como os valores singulares convergem e como acumular os vetores singulares esquerdos e direitos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Analisar complexidade computacional",
                            "description": "Calcular e discutir a complexidade aritmética do algoritmo, aproximadamente O(m n^2) para m >= n, e comparar com implementações modernas como divide-and-conquer.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Método via Decomposição QR Iterativa",
                        "description": "Abordagem iterativa para SVD que aplica sucessivas decomposições QR à matriz, convergindo para uma forma diagonal com valores singulares na diagonal, útil para matrizes grandes e esparsas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Explicar o processo iterativo QR",
                            "description": "Detalhar como iniciar com A0 = A, computar QR, definir A_{k+1} = R_k Q_k, e monitorar a convergência até que A_k seja quase diagonal com os valores singulares.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Discutir recuperação de vetores singulares",
                            "description": "Descrever como acumular os vetores singulares esquerdos (produto das Q's) e direitos (produto das R's transpostas), garantindo ortogonalidade.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Avaliar estabilidade numérica",
                            "description": "Analisar a sensibilidade do método à perturbações de arredondamento, relacionando com a condição dos valores singulares e referenciando resultados de Golub e Van Loan.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Comparação e Considerações Numéricas",
                        "description": "Análise comparativa entre os algoritmos de Golub-Reinsch e QR iterativa, incluindo estabilidade, eficiência para diferentes tamanhos de matriz e ligações com decomposição QR e análise de sensibilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Comparar complexidades e aplicações",
                            "description": "Elaborar tabela comparativa de custos computacionais, precisão e cenários ideais (ex.: densas vs. esparsas), citando bibliografia como Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Relacionar com quadrados mínimos e sensibilidade",
                            "description": "Explicar como os algoritmos SVD impactam a resolução de problemas de quadrados mínimos lineares e análise de sensibilidade de sistemas lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Quadrados Mínimos Lineares",
                                  "subSteps": [
                                    "Defina o problema de quadrados mínimos: minimize ||Ax - b||_2 para sistemas sobredeterminados.",
                                    "Explique a solução normal: x = (A^T A)^{-1} A^T b, destacando problemas de ill-conditioned matrices.",
                                    "Discuta limitações numéricas, como instabilidade quando A tem rank deficiente.",
                                    "Implemente um exemplo simples em Python usando numpy para resolver um sistema 3x2.",
                                    "Compare resultados com solução exata para sistemas consistentes."
                                  ],
                                  "verification": "Resolva um sistema sobredeterminado e verifique se o resíduo ||Ax - b|| é mínimo usando np.linalg.norm.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com numpy, scipy; notas de álgebra linear (ex: Strang's book).",
                                  "tips": "Sempre normalize os dados para melhorar condicionamento.",
                                  "learningObjective": "Compreender a formulação e desafios numéricos dos quadrados mínimos.",
                                  "commonMistakes": "Confundir com sistemas quadrados; ignorar pseudoinverso."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir SVD e sua Aplicação em Quadrados Mínimos",
                                  "subSteps": [
                                    "Lembre a decomposição SVD: A = U Σ V^T, onde Σ contém valores singulares σ_i.",
                                    "Derive a solução via SVD: x = V Σ^+ U^T b, onde Σ^+ é a pseudoinversa.",
                                    "Explique como SVD lida com rank deficiente: ignora σ_i ≈ 0.",
                                    "Implemente em código: use np.linalg.svd para computar pseudoinversa e resolver Ax=b.",
                                    "Compare tempo e precisão com método normal em matrizes ill-conditioned."
                                  ],
                                  "verification": "Confirme que a solução SVD coincide com a pseudoinversa np.linalg.pinv(A) @ b.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (numpy.linalg.svd, pinv); Jupyter notebook.",
                                  "tips": "Use full_matrices=False para eficiência em matrizes retangulares.",
                                  "learningObjective": "Dominar como SVD fornece solução estável para least squares.",
                                  "commonMistakes": "Usar SVD econômica sem entender impactos em pseudoinversa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Sensibilidade Usando Valores Singulares",
                                  "subSteps": [
                                    "Defina sensibilidade: condição number κ(A) = σ_max / σ_min.",
                                    "Explique impacto em least squares: erro em x amplificado por κ(A).",
                                    "Discuta análise de sensibilidade para perturbações em b e A via SVD.",
                                    "Calcule bounds de erro: ||δx|| / ||x|| ≤ κ(A) ||δb|| / ||b||.",
                                    "Simule numericamente: adicione ruído a b e observe variação em x via SVD."
                                  ],
                                  "verification": "Compute κ(A) e verifique amplificação de erro em simulação coincide com teoria.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python; exemplos de matrizes (Vandermonde ill-conditioned).",
                                  "tips": "Registre σ_i em log scale para visualizar gaps.",
                                  "learningObjective": "Relacionar valores singulares à estabilidade e sensibilidade.",
                                  "commonMistakes": "Ignorar que σ_min pequeno causa alta sensibilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Algoritmos SVD e Considerações Numéricas",
                                  "subSteps": [
                                    "Liste algoritmos SVD: Golub-Reinsch (bidiagonalização), R-SVD para sparse.",
                                    "Compare estabilidade: SVD > QR para least squares em casos rank-deficient.",
                                    "Avalie custo computacional: O(mn^2) para m>>n.",
                                    "Teste em dados reais: ajuste de regressão linear com ruído.",
                                    "Discuta truncamento SVD para regularização (low-rank approximation)."
                                  ],
                                  "verification": "Execute benchmarks: tempo e erro relativo entre SVD e lsqr (scipy).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Scipy (linalg.svd, optimize.lsqr); datasets sintéticos.",
                                  "tips": "Use threshold relativo para cutoff de σ_i (ex: 1e-10 * σ_max).",
                                  "learningObjective": "Avaliar trade-offs numéricos de SVD em least squares e sensibilidade.",
                                  "commonMistakes": "Subestimar custo de SVD para matrizes grandes."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Aplicar Conceitos",
                                  "subSteps": [
                                    "Resuma: SVD resolve least squares estável e quantifica sensibilidade via σ_i.",
                                    "Crie fluxograma: quando usar SVD vs. outros (QR, CG).",
                                    "Resolva problema completo: dados de sensores com ruído.",
                                    "Analise sensibilidade do modelo final.",
                                    "Documente relatório com plots de σ_i e resíduos."
                                  ],
                                  "verification": "Gere relatório mostrando solução SVD, κ(A), e análise de erro.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Jupyter; matplotlib para plots.",
                                  "tips": "Sempre reporte múltiplos κ (2-norm, Frobenius).",
                                  "learningObjective": "Integrar SVD para least squares e sensibilidade em problemas reais.",
                                  "commonMistakes": "Não considerar escala de dados afetando σ_i."
                                }
                              ],
                              "practicalExample": "Em engenharia civil, use SVD para ajustar modelo de regressão em dados de deformação de uma ponte (matriz A 100x5 de sensores vs. parâmetros). Compute x via SVD, analise sensibilidade a ruído de medição via σ_min baixo, identificando parâmetros instáveis.",
                              "finalVerifications": [
                                "Explicar corretamente pseudoinversa via SVD para least squares.",
                                "Calcular e interpretar condição number κ(A) de exemplo.",
                                "Simular erro amplificado e matching com bounds teóricos.",
                                "Comparar precisão SVD vs. normal equations em código.",
                                "Identificar quando truncar SVD para regularização.",
                                "Produzir relatório com plots de singular values e resíduos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: derivação SVD-least squares (80%+ correto).",
                                "Implementação numérica: código roda sem erros, resultados precisos (1e-10).",
                                "Análise de sensibilidade: interpretação correta de σ_i e κ(A).",
                                "Comparação algoritmos: trade-offs custo/estabilidade justificados.",
                                "Exemplo prático: aplicação coerente com contexto real.",
                                "Clareza comunicação: fluxograma/relatório bem estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: regressão linear ridge via truncada SVD.",
                                "Ciência da Computação: compressão de dados e PCA.",
                                "Engenharia: análise de estruturas e controle de sistemas.",
                                "Física: modelagem de sinais com ruído."
                              ],
                              "realWorldApplication": "Em machine learning, SVD resolve least squares para treinamento de redes neurais lineares e analisa sensibilidade a dados ruidosos em sistemas de recomendação (Netflix), onde σ_min baixo indica features instáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Aplicações da SVD",
                    "description": "Uso em compressão de dados, quadrados mínimos e análise de sensibilidade numérica.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Compressão de Dados usando SVD",
                        "description": "Aplicação da decomposição em valores singulares (SVD) para reduzir a dimensionalidade de matrizes, permitindo a compressão eficiente de dados como imagens, vídeos e conjuntos de dados de alta dimensão, preservando a informação essencial.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Compreender a SVD truncada",
                            "description": "Explicar o conceito de SVD truncada, onde apenas os maiores valores singulares e vetores singulares correspondentes são retidos para aproximar a matriz original com perda mínima de informação, e calcular o erro de aproximação via norma de Frobenius.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Aplicar SVD truncada em compressão de imagens",
                            "description": "Demonstrar o processo de decomposição SVD de uma matriz representando uma imagem em tons de cinza, selecionar k valores singulares para truncagem, reconstruir a imagem aproximada e quantificar a taxa de compressão e qualidade via erro relativo.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Avaliar trade-offs na compressão SVD",
                            "description": "Analisar o impacto do número de componentes truncados (k) na qualidade da reconstrução e no fator de compressão, utilizando métricas como PSNR (Peak Signal-to-Noise Ratio) e discutir limitações numéricas em implementações computacionais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Quadrados Mínimos via SVD",
                        "description": "Utilização da SVD para resolver problemas de mínimos quadrados lineares, incluindo sistemas super-determinados ou mal-condicionados, via pseudoinversa de Moore-Penrose.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Derivar a pseudoinversa usando SVD",
                            "description": "Derivar a fórmula da pseudoinversa A^+ = V Σ^+ U^T a partir da SVD A = U Σ V^T, explicando o recíproco dos valores singulares não-nulos e o tratamento de singularidades.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Resolver sistemas Ax ≈ b com SVD",
                            "description": "Aplicar a SVD para computar a solução de mínimos quadrados x = A^+ b, interpretando os componentes associados a valores singulares pequenos como ruído e realizando regularização via truncagem.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Comparar com método QR para mínimos quadrados",
                            "description": "Comparar a estabilidade numérica e eficiência computacional da solução via SVD versus decomposição QR para problemas de mínimos quadrados, citando referências como Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Análise de Sensibilidade Numérica com SVD",
                        "description": "Emprego dos valores singulares da SVD para quantificar a sensibilidade condicional de matrizes, sistemas lineares e eigenvalores, avaliando amplificação de erros em computações numéricas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Calcular o número de condição via SVD",
                            "description": "Definir e calcular o número de condição cond(A) = σ_max / σ_min usando os valores singulares da SVD, interpretando seu significado na amplificação de erros relativos em soluções de Ax = b.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Analisar sensibilidade de soluções lineares",
                            "description": "Aplicar teoremas de perturbação (e.g., de Golub & Van Loan) para estimar ||Δx|| / ||x|| ≤ cond(A) ||Δb|| / ||b|| + cond(A) ||ΔA|| / ||A||, usando SVD para identificar direções sensíveis via vetores singulares.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Avaliar sensibilidade em métodos iterativos",
                            "description": "Discutir como os valores singulares influenciam a convergência de métodos iterativos como CG ou GMRES para sistemas lineares, relacionando com análise de espectro e referências como Watkins.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Sensibilidade de Sistemas de Equações Lineares",
                "description": "Análise da estabilidade e perturbações em soluções de sistemas lineares sob variações nos dados de entrada.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Número de Condição de Matrizes",
                    "description": "Definição e interpretação do número de condição κ(A) como medida de sensibilidade da solução a perturbações.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Definição do Número de Condição κ(A)",
                        "description": "Apresentação formal da definição do número de condição para matrizes invertíveis, incluindo sua dependência da norma matricial utilizada e propriedades básicas como κ(A) ≥ 1.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Definir o número de condição",
                            "description": "Formular a definição precisa de κ(A) = ‖A‖ ⋅ ‖A⁻¹‖ para qualquer norma matricial consistente e explicar por que ela quantifica a amplificação de erros.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Identificar propriedades básicas",
                            "description": "Listar e demonstrar propriedades como κ(A) ≥ 1, κ(αA) = κ(A) para escalar α ≠ 0, e o efeito da similaridade ortogonal κ(QᵀAQ) = κ(A).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Calcular κ(A) em normas específicas",
                            "description": "Computar o número de condição nas normas 1, ∞ e 2 para matrizes 2x2 ou 3x3, envolvendo cálculo de inversa e normas vetoriais inducidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar a norma e calcular ||A|| para matrizes 2x2 ou 3x3",
                                  "subSteps": [
                                    "Escolha a norma específica: 1 (soma máxima das colunas absolutas), ∞ (soma máxima das linhas absolutas) ou 2 (maior valor singular via autovalores de AᵀA).",
                                    "Para norma 1: compute a soma absoluta de cada coluna e pegue o máximo.",
                                    "Para norma ∞: compute a soma absoluta de cada linha e pegue o máximo.",
                                    "Para norma 2: calcule AᵀA, encontre autovalores, tome sqrt do maior.",
                                    "Registre o valor de ||A|| com precisão decimal adequada (ex: 4 casas)."
                                  ],
                                  "verification": "Confirme que ||A|| coincide com cálculo manual ou software (ex: MATLAB/Python).",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Matriz A dada, calculadora ou Python/MATLAB com numpy/scipy.",
                                  "tips": "Use valores absolutos em todas somas; para norma 2, verifique simetria de AᵀA.",
                                  "learningObjective": "Dominar definição e computação de normas de matriz induzidas.",
                                  "commonMistakes": "Esquecer valores absolutos nas somas; confundir normas 1 e ∞."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar invertibilidade e calcular a matriz inversa A⁻¹",
                                  "subSteps": [
                                    "Calcule det(A); se det(A) = 0, A não é invertível (κ indefinido).",
                                    "Para 2x2: use fórmula adj(A)/det(A).",
                                    "Para 3x3: use método de cofatores ou eliminação gaussiana.",
                                    "Verifique A * A⁻¹ ≈ I (identidade) com erro < 10^{-6}.",
                                    "Registre A⁻¹ com precisão adequada."
                                  ],
                                  "verification": "Multiplique A * A⁻¹ e confirme identidade aproximada.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": "Matriz A, papel para Gauss-Jordan ou software numérico.",
                                  "tips": "Prefira Gauss-Jordan para precisão numérica em 3x3.",
                                  "learningObjective": "Computar inversas manualmente e validar numericamente.",
                                  "commonMistakes": "Dividir por det(A)=0; erros de sinal em cofatores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular ||A⁻¹|| na mesma norma escolhida",
                                  "subSteps": [
                                    "Aplique o mesmo procedimento do Step 1 à matriz A⁻¹.",
                                    "Para norma 1: máximo das somas de colunas absolutas de A⁻¹.",
                                    "Para norma ∞: máximo das somas de linhas absolutas de A⁻¹.",
                                    "Para norma 2: compute (A⁻¹)ᵀ A⁻¹, autovalores, sqrt do maior.",
                                    "Anote ||A⁻¹|| com precisão."
                                  ],
                                  "verification": "Compare com cálculo independente para consistência.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Matriz A⁻¹, mesma ferramenta do Step 1.",
                                  "tips": "Reutilize fórmulas do Step 1 para eficiência.",
                                  "learningObjective": "Aplicar normas consistentemente a inversas.",
                                  "commonMistakes": "Usar norma errada; propagar erros de A⁻¹."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar κ(A) = ||A|| * ||A⁻¹|| e interpretar resultados",
                                  "subSteps": [
                                    "Multiplique ||A|| por ||A⁻¹|| para obter κ(A).",
                                    "Repita para as três normas se requerido.",
                                    "Compare κ entre normas: geralmente κ₂ ≤ κ₁, κ₂ ≤ κ∞.",
                                    "Interprete: κ=1 (bem condicionado), κ>10^6 (mal condicionado).",
                                    "Documente tabela com ||A||, ||A⁻¹||, κ para cada norma."
                                  ],
                                  "verification": "Confirme multiplicação e compare com software (ex: cond(A,p) no MATLAB).",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": "Valores de ||A|| e ||A⁻¹||, planilha para tabela.",
                                  "tips": "Sempre relacione κ à sensibilidade de soluções lineares.",
                                  "learningObjective": "Entender número de condição como medida de sensibilidade.",
                                  "commonMistakes": "Esquecer multiplicação; interpretar κ baixo como sempre bom."
                                }
                              ],
                              "practicalExample": "Para A = [[2, 1], [1, 1]] (2x2):\n- Norma 1: ||A||=3, A⁻¹=[[1,-1],[-1,2]], ||A⁻¹||=3, κ=9.\n- Norma ∞: ||A||=3, ||A⁻¹||=3, κ=9.\n- Norma 2: ||A||≈2.414, ||A⁻¹||≈2.414, κ≈5.828. Verifique com cálculos exatos.",
                              "finalVerifications": [
                                "κ(A) calculado corretamente para pelo menos duas normas.",
                                "A * A⁻¹ ≈ I com erro residual mínimo.",
                                "Comparação entre normas 1, ∞ e 2 consistente (κ₂ menor ou igual).",
                                "Interpretação qualitativa de condicionamento fornecida.",
                                "Tabela de resultados clara e precisa.",
                                "Valores condizem com verificação em software."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de normas e inversa (erro <1%).",
                                "Completude: todos substeps executados.",
                                "Correção conceitual: uso correto de definições de normas induzidas.",
                                "Validação numérica adequada (multiplicações matriz).",
                                "Interpretação do número de condição.",
                                "Clareza na documentação de passos e tabela."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em Python/NumPy para análise numérica.",
                                "Física: Estabilidade em sistemas dinâmicos lineares.",
                                "Engenharia: Análise de erros em simulações finitas.",
                                "Estatística: Condicionamento em regressão linear múltipla."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, calcular κ(A) avalia sensibilidade de soluções de equações lineares em modelos de estruturas, prevendo amplificação de erros de medição em até κ vezes, essencial para designs seguros de aviões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Número de Condição via Decomposição em Valores Singulares (SVD)",
                        "description": "Relação entre o número de condição na norma 2 e os valores singulares de A, destacando κ₂(A) = σ_max / σ_min.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Relacionar SVD com κ₂(A)",
                            "description": "Explicar como a decomposição SVD A = UΣVᵀ implica κ₂(A) = σ₁ / σₙ, onde σ₁ ≥ ... ≥ σₙ > 0 para A invertível.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.1",
                              "10.1.2.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Calcular κ₂(A) usando SVD",
                            "description": "Realizar a decomposição SVD de uma matriz numérica pequena e extrair κ₂(A) a partir dos valores singulares, usando software como MATLAB ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos teóricos de SVD e número de condição κ₂(A)",
                                  "subSteps": [
                                    "Lembre-se da definição de Decomposição em Valores Singulares (SVD): A = U Σ V^T, onde Σ contém os valores singulares σ_i em ordem decrescente.",
                                    "Entenda que o número de condição 2-norma κ₂(A) = σ_max / σ_min, medindo sensibilidade de A.",
                                    "Revise propriedades: κ₂(A) ≥ 1, e κ₂(A) = 1 se A ortogonal.",
                                    "Estude impacto em sistemas lineares: alto κ₂ indica instabilidade numérica.",
                                    "Consulte documentação de SVD em Python (numpy.linalg.svd)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula de κ₂(A) e dê um exemplo simples de matriz com κ₂=1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook Jupyter ou Python IDE",
                                    "Documentação NumPy: numpy.linalg.svd",
                                    "Livro ou notas de Álgebra Linear Computacional"
                                  ],
                                  "tips": "Use diagramas visuais para Σ e memorize que σ_i são raízes quadradas dos autovalores de A^T A.",
                                  "learningObjective": "Compreender a base teórica de SVD e κ₂(A) para aplicação prática.",
                                  "commonMistakes": [
                                    "Confundir σ_max com σ_min",
                                    "Ignorar normalização das colunas de U e V"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar ambiente computacional e definir matriz de exemplo",
                                  "subSteps": [
                                    "Instale ou importe bibliotecas: import numpy as np.",
                                    "Defina uma matriz pequena A, ex: A = np.array([[1, 2], [3, 4]]).",
                                    "Verifique dimensões de A com A.shape.",
                                    "Escolha matrizes variadas: bem condicionada (ortogonal) e mal condicionada (quase singular).",
                                    "Salve A em variável para reutilização."
                                  ],
                                  "verification": "Execute print(A) e print(A.shape) sem erros, confirmando setup correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3+ com NumPy instalado (pip install numpy)",
                                    "Jupyter Notebook para visualização interativa"
                                  ],
                                  "tips": "Use np.random.seed(42) para reprodutibilidade em matrizes aleatórias.",
                                  "learningObjective": "Configurar ambiente para computação numérica confiável.",
                                  "commonMistakes": [
                                    "Esquecer import numpy as np",
                                    "Definir matriz com dtype incorreto (use float64)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar decomposição SVD da matriz A",
                                  "subSteps": [
                                    "Execute U, S, Vt = np.linalg.svd(A, full_matrices=False).",
                                    "Inspecione shapes: U (m x k), S (k,), Vt (k x n), onde k = min(m,n).",
                                    "Visualize valores singulares: print(S).",
                                    "Confirme reconstrução: A_recon = U @ np.diag(S) @ Vt; np.allclose(A, A_recon).",
                                    "Teste com full_matrices=True para matrizes não quadradas."
                                  ],
                                  "verification": "A reconstruída é igual a A original (erro < 1e-10).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python do passo anterior",
                                    "Função np.linalg.svd"
                                  ],
                                  "tips": "Use full_matrices=False para eficiência em matrizes retangulares.",
                                  "learningObjective": "Executar SVD corretamente e validar decomposição.",
                                  "commonMistakes": [
                                    "Confundir ordem de U, S, Vt",
                                    "Não usar np.diag(S) na reconstrução"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair valores singulares e calcular κ₂(A)",
                                  "subSteps": [
                                    "Identifique σ_max = S[0], σ_min = S[-1].",
                                    "Calcule kappa = S[0] / S[-1] se S[-1] > 0 else inf.",
                                    "Use np.linalg.cond(A, 2) para validar: deve igualar kappa.",
                                    "Registre κ₂ para diferentes matrizes e compare.",
                                    "Interprete: κ₂ > 10^6 indica mal condicionada."
                                  ],
                                  "verification": "Comparar kappa manual com np.linalg.cond(A, 2); diferença < 1e-12.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Resultado SVD do passo 3",
                                    "Função np.linalg.cond"
                                  ],
                                  "tips": "Lide com σ_min ≈ 0 usando np.spacing(1) para precisão numérica.",
                                  "learningObjective": "Calcular e interpretar κ₂(A) a partir de SVD.",
                                  "commonMistakes": [
                                    "Dividir por zero sem checagem",
                                    "Usar norma errada (ex: cond(A,1) em vez de 2)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e interpretar resultados no contexto de sensibilidade",
                                  "subSteps": [
                                    "Perturbe A: A_pert = A + 0.01*np.random.randn(*A.shape).",
                                    "Resolva Ax=b e A_pert x_pert = b; compare ||x - x_pert|| / ||x||.",
                                    "Relacione com bound teórico: ||Δx||/||x|| ≤ κ₂(A) ||ΔA||/||A||.",
                                    "Gere relatório com κ₂, interpretação e gráfico de S.",
                                    "Discuta escalonamento de A para reduzir κ₂."
                                  ],
                                  "verification": "Simulação de perturbação confirma sensibilidade prevista por κ₂.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "np.linalg.solve para Ax=b",
                                    "Matplotlib para plot(S)"
                                  ],
                                  "tips": "Escolha b = np.ones(A.shape[1]) para simplicidade.",
                                  "learningObjective": "Aplicar κ₂ em análise de sensibilidade prática.",
                                  "commonMistakes": [
                                    "Ignorar normalização nas perturbações",
                                    "Confundir erros relativos"
                                  ]
                                },
                                {
                                  "practicalExample": "Para A = np.array([[1, 2], [3, 4]]):\nU, S, Vt = np.linalg.svd(A)\nprint(S)  # ≈ [5.4649857, 0.36596619]\nκ₂(A) = 5.4649857 / 0.36596619 ≈ 14.94\nVerifique com np.linalg.cond(A, 2). Isso mostra A moderadamente condicionada.",
                                  "finalVerifications": [
                                    "SVD decompõe corretamente A (reconstrução exata).",
                                    "σ_max e σ_min identificados precisamente.",
                                    "κ₂(A) calculado como ratio correto.",
                                    "Validação com np.linalg.cond coincide.",
                                    "Interpretação de sensibilidade coerente com exemplo perturbado."
                                  ],
                                  "assessmentCriteria": [
                                    "Precisão numérica na SVD e κ₂ (erro < 1e-10).",
                                    "Correta identificação de singular values.",
                                    "Interpretação qualitativa de condicionamento.",
                                    "Uso apropriado de software sem erros.",
                                    "Relatório claro com passos e conclusões."
                                  ],
                                  "crossCurricularConnections": [
                                    "Análise Numérica: Estabilidade em métodos iterativos.",
                                    "Ciência de Dados: Redução dimensional via PCA (baseada em SVD).",
                                    "Engenharia: Simulações finitas elementos (condicionamento de rigidez).",
                                    "Física Computacional: Modelagem de sistemas dinâmicos.",
                                    "Machine Learning: Regularização em regressão linear."
                                  ],
                                  "realWorldApplication": "Em engenharia aeroespacial, calcular κ₂ via SVD avalia estabilidade de matrizes de rigidez em simulações FEM, previnendo erros catastróficos em predições de falhas estruturais devido a ruído numérico."
                                }
                              ]
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Interpretar valores singulares extremos",
                            "description": "Analisar como valores singulares pequenos indicam ill-condicionamento e demonstrar com exemplos o colapso de σ_min em matrizes próximas à singularidade.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.1",
                              "10.1.2.1.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Interpretação como Medida de Sensibilidade",
                        "description": "Aplicação do número de condição na análise de sensibilidade de soluções de sistemas lineares Ax = b a perturbações em A e b.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Enunciar teoremas de sensibilidade",
                            "description": "Estabelecer os teoremas de condicionamento: |Δx/x| ≤ κ(A) |ΔA/A| + κ(A) |Δb/b| aproximadamente, para erros relativos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.3",
                              "10.1.2.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Analisar exemplo numérico de sensibilidade",
                            "description": "Resolver Ax = b para uma matriz condicional, perturbar A e b ligeiramente, comparar erros na solução e relacionar com κ(A).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.3.1",
                              "10.1.2.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.3",
                            "name": "Avaliar impacto em métodos numéricos",
                            "description": "Discutir como alto κ(A) afeta precisão em decomposição QR, Gauss e métodos iterativos, citando referências como Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.3.1",
                              "10.1.2.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Perturbações no Vetor Independente b",
                    "description": "Análise do impacto relativo de erros em b sobre a solução x em Ax = b.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Perturbação Absoluta e Relativa no Vetor b",
                        "description": "Definição e caracterização das perturbações δb no vetor independente b do sistema Ax = b, incluindo perturbações absolutas e relativas medidas por normas vetoriais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Definir perturbação absoluta em b",
                            "description": "Explicar o conceito de perturbação absoluta δb como uma pequena variação adicionada ao vetor b original, representando erros de arredondamento ou medição, e calcular sua norma ||δb|| utilizando normas como a norma 2 ou infinito.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Calcular perturbação relativa em b",
                            "description": "Determinar a perturbação relativa ||δb|| / ||b||, interpretando-a como a fração relativa de erro no vetor b, e compará-la com níveis típicos de precisão em computação numérica (ex.: máquina epsilon).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Identificar fontes de perturbações em b",
                            "description": "Listar e descrever fontes comuns de perturbações em b, como erros de medição em dados reais, arredondamentos em computação flutuante e ruído aleatório, relacionando com aplicações práticas.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Perturbação Induzida na Solução x",
                        "description": "Análise da variação δx na solução x causada por δb, utilizando a relação δx = A^{-1} δb e estimativas de normas para quantificar o impacto absoluto.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Derivar a fórmula δx = A^{-1} δb",
                            "description": "Partir do sistema perturbado A(x + δx) = b + δb e derivar analiticamente que δx = A^{-1} δb, assumindo A não singular.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Estimar ||δx|| usando norma de A^{-1}",
                            "description": "Aplicar a desigualdade ||δx|| ≤ ||A^{-1}|| ⋅ ||δb|| para estimar o erro absoluto na solução, escolhendo normas compatíveis (ex.: norma 2) e interpretando o papel amplificador de ||A^{-1}||.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar o teorema de perturbação para sistemas lineares",
                                  "subSteps": [
                                    "Revise a fórmula de perturbação: para Ax = b, com perturbação δb, a solução perturbada é x + δx onde A(x + δx) = b + δb.",
                                    "Derive ou lembre que δx = A^{-1} δb, logo ||δx|| ≤ ||A^{-1}|| ⋅ ||δb|| por propriedades de normas.",
                                    "Entenda que ||A^{-1}|| atua como fator amplificador do erro relativo.",
                                    "Discuta compatibilidade de normas: use norma induzida pelo vetor (ex.: norma 2 para vetores euclidianos).",
                                    "Exemplo rápido: para norma infinito, ||A^{-1}||_∞ é máximo de soma de linhas absolutas de A^{-1}."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a derivação da desigualdade e dê um exemplo simples.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Livro de Álgebra Linear Numérica (ex: Golub-Van Loan)",
                                    "Folha de anotações",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Sempre relacione com o condition number κ(A) = ||A|| ⋅ ||A^{-1}|| para contexto amplo.",
                                  "learningObjective": "Compreender a origem matemática da estimativa de erro ||δx||.",
                                  "commonMistakes": [
                                    "Confundir ||δx|| com erro relativo ||δx||/||x||.",
                                    "Ignorar compatibilidade de normas entre matriz e vetor."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a norma de A^{-1} para uma matriz dada",
                                  "subSteps": [
                                    "Inverta a matriz A numericamente ou analiticamente (para matrizes pequenas).",
                                    "Escolha a norma: priorize norma 2 (singular value decomposition) ou norma 1/∞ para simplicidade.",
                                    "Para norma 2: use svd(A) onde ||A||_2 = maior valor singular; para A^{-1}, 1/menor valor singular de A.",
                                    "Implemente em software: em Python/NumPy, np.linalg.norm(np.linalg.inv(A), 2).",
                                    "Valide com propriedades: ||A^{-1}|| ≥ 1/||A||."
                                  ],
                                  "verification": "Compute ||A^{-1}|| para uma matriz teste e compare com valor teórico.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Software NumPy/MATLAB",
                                    "Matriz de exemplo 2x2 ou 3x3",
                                    "Documentação de normas em NumPy"
                                  ],
                                  "tips": "Para matrizes grandes, evite inversão explícita; use cond(A) ≈ ||A|| ||A^{-1}||.",
                                  "learningObjective": "Dominar o cálculo prático de ||A^{-1}|| em diferentes normas.",
                                  "commonMistakes": [
                                    "Usar norma errada (ex: Frobenius em vez de induzida).",
                                    "Inverter matriz numericamente sem checar condicionamento."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a desigualdade para estimar ||δx||",
                                  "subSteps": [
                                    "Meça ||δb|| na mesma norma escolhida.",
                                    "Calcule o limite superior: ||δx|| ≤ ||A^{-1}|| ⋅ ||δb||.",
                                    "Compare com erro real: resolva sistema original e perturbado, compute ||δx|| exato.",
                                    "Calcule erro relativo: ||δx|| / ||x|| ≤ κ(A) ⋅ ||δb|| / ||b||.",
                                    "Registre o valor de ||A^{-1}|| como amplificador (ex: se >1, amplifica erros)."
                                  ],
                                  "verification": "Para um exemplo dado, produza estimativa e compare com ||δx|| verdadeiro (erro < estimativa).",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Código Python/MATLAB pronto",
                                    "Dados de b e δb sintéticos"
                                  ],
                                  "tips": "Gere δb como ruído gaussiano para simular erros de arredondamento.",
                                  "learningObjective": "Aplicar a fórmula para obter bound acionável no erro.",
                                  "commonMistakes": [
                                    "Esquecer de usar normas consistentes.",
                                    "Interpretar bound como igualdade exata."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e escolher normas adequadas",
                                  "subSteps": [
                                    "Analise se ||A^{-1}|| é grande: indica sistema ill-condicionado.",
                                    "Teste múltiplas normas (1,2,∞) e compare bounds.",
                                    "Discuta implicações: precisão numérica limitada por ||A^{-1}||.",
                                    "Sugira melhorias: regularização ou pré-condicionadores para reduzir ||A^{-1}||.",
                                    "Documente relatório: norma usada, bound obtido, interpretação."
                                  ],
                                  "verification": "Escreva parágrafo interpretando o amplificador em contexto do problema.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Templates de relatório",
                                    "Gráficos de erro vs. perturbação"
                                  ],
                                  "tips": "Norma 2 é ideal para vetores físicos; norma ∞ para erros máximos.",
                                  "learningObjective": "Interpretar o papel amplificador e selecionar normas contextualmente.",
                                  "commonMistakes": [
                                    "Ignorar que bound é conservador (pode ser solto).",
                                    "Não testar sensibilidade a escolha de norma."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = [[2,1],[1,1]], b = [3,2], x = [1,1]. Inverta A: A^{-1} = [[1,-1],[-1,2]], ||A^{-1}||_∞ = 3. Deixe δb = [0.01, 0.01], ||δb||_∞=0.01. Então ||δx||_∞ ≤ 3*0.01=0.03. Solução real: x' ≈ [1.005, 0.995], ||δx||_∞=0.005 < 0.03.",
                              "finalVerifications": [
                                "Deriva corretamente δx = A^{-1} δb.",
                                "Calcula ||A^{-1}|| com precisão numérica.",
                                "Aplica desigualdade e obtém bound válido.",
                                "Compara bound com erro real.",
                                "Interpreta ||A^{-1}|| como amplificador.",
                                "Escolhe norma compatível e justifica."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de normas e inversa (erro < 1e-10).",
                                "Correta aplicação da desigualdade (bound >= erro real).",
                                "Interpretação qualitativa do amplificador.",
                                "Seleção justificada de norma.",
                                "Clareza no relatório com gráficos opcionais.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/NumPy para análise de estabilidade.",
                                "Engenharia Computacional: Análise de erros em simulações FEM.",
                                "Estatística: Bounds em regressão linear (A = X^T X).",
                                "Física Computacional: Estabilidade em solvers de EDOs."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, estima erros em modelos de estruturas sob cargas perturbadas (δb de medições sensores), garantindo segurança quando ||A^{-1}|| amplifica ruídos para δx tolerável em deslocamentos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Resolver numericamente sistema perturbado",
                            "description": "Implementar em software (ex.: MATLAB ou Python) a resolução de Ax = b e A(x + δx) = b + δb, comparando x e x + δx para validar a teoria.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Análise de Sensibilidade Relativa",
                        "description": "Avaliação do impacto relativo de erros em b sobre x, destacando o número de condição de A como fator amplificador da sensibilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Derivar bound relativo de sensibilidade",
                            "description": "Demonstrar que ||δx|| / ||x|| ≤ cond(A) ⋅ (||δb|| / ||b||), onde cond(A) = ||A|| ⋅ ||A^{-1}||, provando o limite superior teórico da amplificação relativa.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.1",
                              "10.1.2.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Calcular e interpretar cond(A)",
                            "description": "Computar o número de condição cond(A) para matrizes dadas usando decomposição SVD ou normas diretas, e interpretar valores altos (ex.: cond(A) > 10^6) como indicativo de alta sensibilidade.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Analisar exemplo de sensibilidade",
                            "description": "Construir e analisar um exemplo numérico onde uma pequena perturbação relativa em b (ex.: 10^{-10}) causa grande erro relativo em x devido a cond(A) elevado, relacionando com referências como Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar ou construir uma matriz A mal-condicionada",
                                  "subSteps": [
                                    "Pesquise exemplos clássicos de matrizes ill-condicionadas, como matriz de Hilbert 2x2 ou A = [[1, 1], [1, 1 + 10^{-4}]]",
                                    "Calcule o determinante de A para confirmar que é pequeno (próximo de zero, mas não singular)",
                                    "Implemente A em uma ferramenta computacional (ex.: Python com NumPy ou MATLAB)",
                                    "Calcule a norma de A (ex.: norma 2) usando funções prontas",
                                    "Verifique preliminarmente a condição de A com cond(A) = ||A|| * ||A^{-1}|| > 10^4"
                                  ],
                                  "verification": "Matriz A possui cond(A) > 10^4, comprovado por cálculo numérico",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/NumPy ou MATLAB",
                                    "Referência: Golub & Van Loan, Capítulo 2 sobre análise de condição"
                                  ],
                                  "tips": "Comece com matrizes 2x2 para simplicidade; evite matrizes singulares acidentalmente",
                                  "learningObjective": "Compreender como propriedades espectrais levam a alta condição numérica",
                                  "commonMistakes": [
                                    "Escolher A com cond(A) baixa (bem-condicionada)",
                                    "Usar precisão insuficiente em cálculos de norma",
                                    "Ignorar verificação de invertibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir vetor b e resolver o sistema original Ax = b",
                                  "subSteps": [
                                    "Escolha b compatível com A, ex.: b = [2, 2 + 10^{-4}] para o exemplo de A acima",
                                    "Resolva Ax = b usando decomposição LU ou qr_solve para precisão",
                                    "Calcule a norma de b (||b||_2) e armazene a solução exata x",
                                    "Verifique a resíduo ||Ax - b|| para confirmar precisão da solução",
                                    "Registre ||x||_2 para uso posterior"
                                  ],
                                  "verification": "Resíduo ||Ax - b|| / ||b|| < 10^{-12}, indicando solução precisa",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software numérico (NumPy.linalg.solve)",
                                    "Papel e calculadora para verificação manual 2x2"
                                  ],
                                  "tips": "Use solvers estáveis como lu_factor para evitar erros de arredondamento prematuros",
                                  "learningObjective": "Executar resolução precisa de sistemas lineares bem definidos",
                                  "commonMistakes": [
                                    "Escolher b que torne x muito pequeno",
                                    "Não verificar resíduo após solução",
                                    "Usar inversa explícita A^{-1}b (instável)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir perturbação relativa pequena em b",
                                  "subSteps": [
                                    "Defina δb com ||δb|| / ||b|| ≈ 10^{-10}, ex.: δb = 10^{-10} * ||b|| * vetor unitário aleatório",
                                    "Crie b' = b + δb",
                                    "Calcule e registre o erro relativo em b: rel_err_b = ||δb|| / ||b||",
                                    "Garanta que a perturbação simule ruído de máquina ou medição",
                                    "Documente o valor exato de rel_err_b usado"
                                  ],
                                  "verification": "||b' - b|| / ||b|| está na ordem de 10^{-10}, conforme especificado",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "NumPy para geração de vetores aleatórios normalizados",
                                    "Documentação IEEE 754 para eps máquina"
                                  ],
                                  "tips": "Use np.random.randn() normalizado para realismo em simulações",
                                  "learningObjective": "Modelar perturbações relativas pequenas típicas em computação numérica",
                                  "commonMistakes": [
                                    "Perturbação absoluta em vez de relativa",
                                    "Valor de δb muito grande, mascarando o efeito",
                                    "Não normalizar corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o sistema perturbado e calcular erros relativos",
                                  "subSteps": [
                                    "Resolva A x' = b' usando o mesmo solver do passo 2",
                                    "Calcule erro relativo em x: rel_err_x = ||x' - x|| / ||x||",
                                    "Verifique resíduo para b': ||A x' - b'|| / ||b'|| < 10^{-12}",
                                    "Compare rel_err_x com rel_err_b * cond(A)",
                                    "Registre todos os valores numéricos"
                                  ],
                                  "verification": "rel_err_x ≈ cond(A) * rel_err_b, com fator dentro de 0.5 a 2",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Funções NumPy: linalg.norm, linalg.cond",
                                    "Planilha para tabulação de resultados"
                                  ],
                                  "tips": "Calcule cond(A) com np.linalg.cond(A, p=2) para precisão",
                                  "learningObjective": "Quantificar amplificação de erros devido à condição da matriz",
                                  "commonMistakes": [
                                    "Erro de arredondamento em normas",
                                    "Comparar erros absolutos em vez de relativos",
                                    "Esquecer de calcular cond(A)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e relacionar com teoria de sensibilidade",
                                  "subSteps": [
                                    "Cite teorema de sensibilidade relativa de Golub & Van Loan: rel_err_x ≤ cond(A) * rel_err_b",
                                    "Interprete o exemplo: explique por que cond(A) alto amplifica erros",
                                    "Discuta autovalores de A como causa raiz (gap pequeno)",
                                    "Gere gráfico de erros vs. tamanho de perturbação (opcional)",
                                    "Conclua limitações e referencie literatura"
                                  ],
                                  "verification": "Relatório escrito relaciona corretamente observação numérica com teoria",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Golub & Van Loan (PDF ou livro)",
                                    "Jupyter Notebook para gráficos"
                                  ],
                                  "tips": "Foque no bound teórico vs. observado; mencione componente forward/backward error",
                                  "learningObjective": "Conectar experimento numérico com análise teórica de estabilidade",
                                  "commonMistakes": [
                                    "Ignorar bound teórico (apenas números)",
                                    "Atribuir erro só a cond(A) sem discutir solver",
                                    "Não citar referências adequadamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Matriz A = [[1.0, 1.0], [1.0, 1.0001]], b = [2.0001, 2.00020001]. cond(A) ≈ 10000. Perturbe b com δb tal que ||δb||/||b|| = 10^{-10}, resolva x e x', observe ||x'-x||/||x|| ≈ 10^{-6}, amplificado por cond(A).",
                              "finalVerifications": [
                                "cond(A) calculado corretamente e elevado (>10^3)?",
                                "Erro relativo em x amplificado por fator próximo a cond(A)?",
                                "Resíduos de ambos os sistemas <10^{-12}?",
                                "Relatório cita Golub & Van Loan e teorema de sensibilidade?",
                                "Interpretação explica gap nos autovalores?",
                                "Exemplo reproduzível em código fornecido?"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erros <1% do teórico)",
                                "Correta identificação de causa (cond(A) alta)",
                                "Clareza na relação teoria-experimento",
                                "Uso apropriado de ferramentas computacionais",
                                "Profundidade na análise de autovalores e normas",
                                "Relatório estruturado e referenciado"
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/MATLAB para análise de estabilidade",
                                "Física Computacional: Modelagem de sistemas com ruído em medições (ex.: equilíbrios mecânicos)",
                                "Estatística: Análise de propagação de erros em regressão linear",
                                "Engenharia de Software: Testes de robustez em solvers lineares"
                              ],
                              "realWorldApplication": "Em simulações de engenharia estrutural, pequenas incertezas em cargas (b) podem levar a erros catastróficos em deformações (x) se a matriz de rigidez (A) for ill-condicionada, guiando escolhas de pré-condicionadores em CFD ou FEA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Perturbações na Matriz A",
                    "description": "Estudo da sensibilidade da solução x a variações na matriz dos coeficientes A.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Número de Condição da Matriz A",
                        "description": "O número de condição cond(A) = ||A|| · ||A^{-1}||, tipicamente na norma 2, mede a amplificação de erros relativos na solução x devido a perturbações na matriz A em sistemas lineares Ax = b.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Calcular o número de condição usando normas matriciais",
                            "description": "Computar cond_2(A) = σ_max / σ_min via decomposição em valores singulares (SVD) ou aproximações para matrizes grandes, utilizando software como MATLAB ou Python (NumPy).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Interpretar o impacto do cond(A) na sensibilidade",
                            "description": "Analisar como valores altos de cond(A) (>10^6) indicam instabilidade numérica, relacionando com perda de precisão em ponto flutuante IEEE 754.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Comparar cond(A) em diferentes normas",
                            "description": "Calcular e comparar cond_1(A), cond_2(A) e cond_∞(A), discutindo equivalência assintótica e implicações para análise de sensibilidade.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.75 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Análise Perturbacional para Variações em A",
                        "description": "Estudo das bounds para o erro relativo na solução x quando A é perturbada por δA pequena, com b fixo: ||δx|| / ||x|| ≈ cond(A) · ||δA|| / ||A||.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Enunciar e derivar o teorema de sensibilidade para perturbações em A",
                            "description": "Derivar a desigualdade ||δx|| / ||x|| ≤ cond(A) · ||δA|| / (||A|| (1 - cond(A) ||δA|| / ||A||)) a partir da fórmula de perturbação relativa.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Aplicar bounds perturbacionais em exemplos numéricos",
                            "description": "Resolver Ax = b, perturbar A com δA aleatória de norma relativa 10^{-10}, comparar erro computado com bound teórico usando Golub & Van Loan (Cap. 2).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Analisar casos de A mal-condicionada",
                            "description": "Estudar matrizes de Hilbert ou Vandermonde, quantificar amplificação de erros e propor reformulações para mitigar sensibilidade.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1",
                              "10.1.2.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Decomposição em Valores Singulares (SVD) para Sensibilidade",
                        "description": "A SVD A = UΣV^T revela cond_2(A) = σ_1 / σ_n e direções associadas a singularidades, essenciais para quantificar sensibilidade a perturbações em A.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Computar SVD e extrair medidas de sensibilidade",
                            "description": "Implementar svd(A) em software, identificar valores singulares pequenos e calcular cond_2(A), relacionando com sensibilidade de x.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Interpretar vetores singulares na análise de perturbações",
                            "description": "Examinar colunas de U e V correspondentes a σ_n pequeno, mostrando como perturbações em direções específicas amplificam erros em x.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.75 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1",
                              "10.1.2.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Usar SVD para regularização em sistemas sensíveis",
                            "description": "Aplicar truncagem de SVD (SVD de posto baixo) para aproximar soluções estáveis a perturbações em A mal-condicionada.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2",
                              "10.1.2.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Relação com Decomposição em Valores Singulares (SVD)",
                    "description": "Uso da SVD para computar o condicionamento e analisar a estabilidade de sistemas lineares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Decomposição em Valores Singulares (SVD)",
                        "description": "Fundamentos da decomposição em valores singulares de uma matriz, incluindo sua definição, propriedades ortogonais e relação com autovalores.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Definir e representar a SVD",
                            "description": "Explicar a decomposição SVD de uma matriz A m×n como A = U Σ V^T, onde U e V são matrizes ortogonais e Σ é diagonal com valores singulares não negativos em ordem decrescente.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Identificar propriedades da SVD",
                            "description": "Listar e demonstrar propriedades como unicidade dos valores singulares, ortogonalidade de U e V, e relação com o posto e norma da matriz.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Computar SVD manualmente para matrizes pequenas",
                            "description": "Realizar o cálculo passo a passo da SVD para matrizes 2×2 ou 3×3, usando autovalores de A^T A e A A^T.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Número de Condição via SVD",
                        "description": "Uso dos valores singulares para determinar o número de condição de uma matriz e sua interpretação numérica.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Calcular o número de condição cond(A)",
                            "description": "Definir cond(A) = σ_max / σ_min, onde σ_max e σ_min são o maior e menor valores singulares positivos, e computá-lo a partir da SVD.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Interpretar o impacto do condicionamento",
                            "description": "Explicar como um cond(A) grande indica amplificação de erros em soluções de sistemas lineares Ax = b.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Comparar com outras medidas de condição",
                            "description": "Relacionar cond_2(A) via SVD com normas 1, ∞ e Frobenius, destacando superioridade da SVD para análise precisa.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Análise de Sensibilidade com SVD",
                        "description": "Aplicação da SVD para quantificar a sensibilidade e estabilidade de soluções de sistemas lineares sob perturbações.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Analisar sensibilidade a perturbações em b",
                            "description": "Derivar e aplicar |δx| / |x| ≤ cond(A) |δb| / |b| usando SVD para estimar erros relativos na solução x.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Analisar sensibilidade a perturbações em A",
                            "description": "Estimar |δx| / |x| ≤ cond(A) (|δA| / |A| + |δb| / |b|) e usar valores singulares para identificar direções sensíveis.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Avaliar estabilidade numérica via SVD",
                            "description": "Interpretar o espectro de valores singulares para diagnosticar il-condicionamento e prever estabilidade de métodos numéricos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.4",
                            "name": "Aplicar SVD em exemplos computacionais",
                            "description": "Usar software como MATLAB ou Python para decompor matrizes, calcular cond e simular perturbações em sistemas lineares.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Limites de Erro Relativo",
                    "description": "Teoremas que ligam o erro na solução ao condicionamento e às perturbações relativas nos dados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Número de Condição de Matrizes",
                        "description": "O número de condição κ(A) quantifica a sensibilidade da solução de Ax = b a pequenas perturbações nos dados, sendo definido como κ(A) = ||A|| ⋅ ||A⁻¹|| para normas compatíveis, e relacionado aos valores singulares via decomposição SVD.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Definir o número de condição relativo",
                            "description": "Explicar a definição formal de κ₂(A) = σ_max(A)/σ_min(A) usando decomposição em valores singulares (SVD) e interpretar seu papel na amplificação de erros relativos na solução.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Calcular o número de condição via SVD",
                            "description": "Dado uma matriz A, computar a SVD e extrair κ₂(A), comparando com estimativas por normas como ||A||_F e ||A||_2, usando exemplos numéricos de Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Interpretar o impacto do condicionamento",
                            "description": "Analisar como κ(A) grande implica perda de precisão numérica, ilustrando com matrizes mal condicionadas como a matriz de Hilbert e discutindo limites práticos em computação.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Perturbações Relativas nos Termos Independentes",
                        "description": "Análise de como perturbações relativas δb/||b|| afetam o erro relativo na solução x, com limites dados por teoremas que envolvem o condicionamento da matriz A.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Enunciar o teorema para perturbações em b",
                            "description": "Estabelecer o limite |δx|/||x|| ≤ κ(A) ⋅ |δb|/||b|| para perturbações pequenas, assumindo A não singular, conforme análise de sensibilidade em Meyer (2000).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Provar o limite de erro relativo para b",
                            "description": "Derivar o teorema usando normas de vetor e matriz, mostrando que ||δx||/||x|| ≈ κ(A) ||δb||/||b|| para perturbações infinitesimais, com passos detalhados.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Aplicar em exemplos numéricos",
                            "description": "Resolver numericamente Ax = b com b perturbado, medir erros relativos e verificar o limite κ(A) ⋅ |δb|/||b|| usando software como MATLAB ou Python.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1",
                              "10.1.2.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Limites de Erro para Perturbações em A e b",
                        "description": "Teoremas gerais que ligam o erro relativo na solução a perturbações relativas em A e b simultaneamente, incluindo o bound aproximado |δx|/||x|| ≤ κ(A) (||δA||/||A|| + ||δb||/||b||).",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Enunciar o teorema completo de sensibilidade",
                            "description": "Apresentar o teorema de perturbação relativa para sistemas lineares: se (A + δA)(x + δx) = b + δb com ||δA|| pequeno, então |δx|/||x|| ≤ [κ(A)/(1 - κ(A)||δA||/||A||)] (||δA||/||A|| + ||δb||/||b||).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1",
                              "10.1.2.5.2"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Derivar bounds para perturbações em A",
                            "description": "Provar o componente de perturbação em A usando a identidade δx ≈ -A⁻¹ δA x + A⁻¹ δb, levando ao fator κ(A) ||δA||/||A||.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1",
                              "10.1.2.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Analisar casos de estudo",
                            "description": "Examinar exemplos de Golub & Van Loan (1996), como sistemas com A perturbada, computando erros e comparando com bounds teóricos para validar os limites.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.4",
                            "name": "Discutir implicações computacionais",
                            "description": "Relacionar os limites com precisão em ponto flutuante, discutindo quando κ(A) ε_machine ≈ 1 causa perda total de precisão, citando Watkins (2010).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Ortogonalização e Decomposição QR",
                "description": "Técnicas de ortogonalização de vetores e fatoração QR para resolução eficiente de problemas lineares.",
                "totalSkills": 55,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Processo de Gram-Schmidt",
                    "description": "Método clássico para obter uma base ortogonal a partir de vetores linearmente independentes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Fundamentos de Ortogonalidade",
                        "description": "Conceitos básicos de produto interno, ortogonalidade e bases ortonormais necessários para compreender o processo de Gram-Schmidt.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Calcular produto interno e norma de vetores",
                            "description": "Realizar o cálculo do produto interno entre vetores em R^n e derivar a norma euclidiana a partir dele, identificando vetores ortogonais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Verificar ortogonalidade de um conjunto de vetores",
                            "description": "Determinar se um conjunto de vetores forma uma base ortogonal ou ortonormal, computando produtos internos e normalizando vetores quando necessário.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Projetar vetor sobre subespaço ortogonal",
                            "description": "Calcular a projeção ortogonal de um vetor sobre a direção de outro vetor, usando a fórmula de projeção escalar.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Algoritmo Clássico de Gram-Schmidt",
                        "description": "Descrição passo a passo do processo clássico para ortogonalizar uma base linearmente independente.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Aplicar o primeiro passo do Gram-Schmidt",
                            "description": "Definir o primeiro vetor ortogonal como o primeiro vetor da base original e subtrair suas projeções dos vetores subsequentes.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Executar iterações subsequentes do processo",
                            "description": "Para cada vetor subsequente, subtrair as projeções sobre todos os vetores ortogonais anteriores, garantindo linear independência.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Normalizar para obter base ortonormal",
                            "description": "Dividir cada vetor ortogonal por sua norma para formar uma base ortonormal, verificando a propriedade de produto interno nulo.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.4",
                            "name": "Implementar Gram-Schmidt em pseudocódigo",
                            "description": "Escrever pseudocódigo para o processo completo, incluindo loops para subtração de projeções e normalização.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Estabilidade Numérica e Modificações",
                        "description": "Análise de problemas numéricos no Gram-Schmidt clássico e introdução ao processo modificado para maior estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Identificar perda de ortogonalidade numérica",
                            "description": "Explicar como erros de arredondamento acumulam no processo clássico, levando a vetores não exatamente ortogonais, com exemplos em baixa dimensão.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.4"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Aplicar o processo de Gram-Schmidt modificado",
                            "description": "Implementar a versão modificada, normalizando após cada projeção para reduzir erros de cancelamento, e comparar com o clássico.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.3",
                            "name": "Relacionar com decomposição QR",
                            "description": "Demonstrar como o Gram-Schmidt gera a decomposição QR de uma matriz, com Q ortogonal e R triangular superior.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Ortogonalização de Gram-Schmidt Modificada",
                    "description": "Versão numericamente estável do processo de Gram-Schmidt para evitar erros de arredondamento.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Processo Clássico de Gram-Schmidt e suas Limitações Numéricas",
                        "description": "Apresentação do algoritmo clássico de Gram-Schmidt para ortogonalização de vetores e identificação dos problemas de instabilidade numérica causados por erros de arredondamento, como perda de ortogonalidade e cancelamento catastrófico.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Descrever os passos do processo de Gram-Schmidt clássico",
                            "description": "Explicar detalhadamente os passos do algoritmo clássico: normalização do primeiro vetor, projeção e subtração subsequentes para obter uma base ortogonal a partir de uma base linearmente independente, destacando a dependência sequencial das operações.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Identificar problemas de arredondamento no Gram-Schmidt clássico",
                            "description": "Analisar como erros de arredondamento em aritmética de ponto flutuante levam à perda de ortogonalidade, ilustrando com exemplos numéricos simples onde a base resultante apresenta ângulos não perpendiculares devido a cancelamento catastrófico.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Implementar Gram-Schmidt clássico em pseudocódigo",
                            "description": "Escrever pseudocódigo para o processo clássico aplicado a uma matriz coluna A m x n, gerando Q ortonormal e R superior triangular, e testar com matrizes pequenas para observar degradação numérica.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Princípios da Ortogonalização de Gram-Schmidt Modificada",
                        "description": "Explicação da versão modificada (MGS) que melhora a estabilidade numérica ao alterar a ordem das operações de projeção e subtração, minimizando a propagação de erros de arredondamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Explicar a diferença entre Gram-Schmidt clássico e modificado",
                            "description": "Comparar as duas versões: no clássico, subtrai-se antes de projetar nos vetores subsequentes; na MGS, projeta-se e subtrai-se imediatamente para cada vetor, reduzindo o impacto de erros acumulados.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Derivar as fórmulas matemáticas da MGS",
                            "description": "Derivar as expressões para os coeficientes r_{ij} = q_i^T a_j e atualização a_j := a_j - r_{ij} q_i, mostrando matematicamente por que essa ordem é numericamente estável em comparação ao clássico.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Analisar a estabilidade numérica da MGS",
                            "description": "Discutir análises teóricas (baseadas em Golub & Van Loan) sobre o crescimento de erros, comparando o fator de condição e a ortogonalidade preservada da MGS versus o clássico em termos de máquina epsilon.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Implementação e Aplicação da MGS na Decomposição QR",
                        "description": "Desenvolvimento prático do algoritmo MGS para computação da decomposição QR de forma estável, com exemplos e verificação de propriedades.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Escrever pseudocódigo completo da MGS",
                            "description": "Implementar o algoritmo MGS em pseudocódigo para uma matriz A, produzindo Q e R tal que A = QR, com loops aninhados para j=1 a n e i=1 a j-1, incluindo normalização.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Aplicar MGS a exemplos numéricos",
                            "description": "Resolver numericamente a ortogonalização de uma matriz 4x3 mal-condicionada usando MGS, verificando ||I - Q^T Q|| < tol e comparando com GS clássico para demonstrar superioridade.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Verificar propriedades da decomposição QR via MGS",
                            "description": "Testar se A = QR aproximadamente, analisar sensibilidade em relação a perturbações e discutir uso em quadrados mínimos lineares, referenciando bibliografia como Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.3",
                              "10.1.3.2.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Decomposição QR",
                    "description": "Fatoração de matrizes em produto de matriz ortogonal Q e triangular superior R.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Definição e Propriedades da Decomposição QR",
                        "description": "A decomposição QR é uma fatoração de uma matriz A (m x n, com m >= n e posto completo) em A = QR, onde Q é uma matriz ortogonal (QᵀQ = I) cujas colunas são ortonormais e R é uma matriz triangular superior com elementos diagonais positivos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Identificar propriedades de Q e R",
                            "description": "Reconhecer que as colunas de Q formam uma base ortonormal para o espaço coluna de A, que R captura os coeficientes da projeção e que ||A||_F = ||R||_F devido à isometria de Q.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Verificar decomposição QR",
                            "description": "Dadas matrizes Q e R candidatas, computar o produto QR e validar as propriedades ortogonal de Q (QᵀQ ≈ I) e triangular superior de R usando cálculos manuais ou numéricos simples.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Determinar existência e unicidade da QR",
                            "description": "Explicar as condições para existência (posto completo de A) e unicidade (diagonais positivas de R) da decomposição QR para matrizes reais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Construção da Decomposição QR via Gram-Schmidt",
                        "description": "O processo de Gram-Schmidt clássico e modificado ortogonaliza as colunas de A para formar Q, com R obtida dos coeficientes de projeção, destacando questões numéricas de estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Aplicar Gram-Schmidt clássico",
                            "description": "Executar o algoritmo de Gram-Schmidt clássico passo a passo em uma matriz A pequena (ex: 3x3), computando q_k = (a_k - soma proj) / norma, e formando R com os coeficientes de projeção.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Implementar Gram-Schmidt modificado",
                            "description": "Realizar o Gram-Schmidt modificado para evitar cancelamentos numéricos, atualizando R explicitamente com r_{jk} = q_jᵀ a_k e subtraindo múltiplos de colunas anteriores.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Analisar estabilidade numérica do Gram-Schmidt",
                            "description": "Identificar perdas de ortogonalidade no Gram-Schmidt clássico devido a cancelamentos subtrativos e comparar com o modificado em termos de erro relativo.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.2.4",
                            "name": "Computar QR para matrizes com posto deficiente",
                            "description": "Adaptar o processo para matrizes com colunas linearmente dependentes, identificando zeros na diagonal de R.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Algoritmos Estáveis e Aplicações da Decomposição QR",
                        "description": "Métodos numéricamente estáveis como Householder e Givens para QR, e aplicações em resolução de sistemas lineares via Qᵀb e quadrados mínimos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Descrever transformações Householder para QR",
                            "description": "Explicar como reflexões Householder eliminam subdiagonal de colunas sucessivas de A para triangularizar em R, preservando ortogonalidade.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Aplicar rotações Givens para QR",
                            "description": "Usar rotações Givens para zerar elementos específicos abaixo da diagonal, comparando com Householder em termos de preenchimento e custo computacional.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Resolver sistemas lineares com QR",
                            "description": "Dado Ax = b, computar QR, resolver Ry = Qᵀb por substituição retroativa e obter x = y, analisando estabilidade.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.4",
                            "name": "Usar QR em quadrados mínimos lineares",
                            "description": "Para min ||Ax - b||₂ com A m x n (m > n), formar base ortonormal com Q, projetar b em colunas de A via Qᵀb e resolver sistema triangular.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Refletores de Householder",
                    "description": "Transformações ortogonais para zerar subdiagonais e computar decomposição QR.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Definição e Propriedades dos Refletores de Householder",
                        "description": "Os refletores de Householder são transformações ortogonais elementares definidas por H = I - 2uu^T / (u^Tu), onde u é um vetor coluna não nulo. São simétricos (H^T = H), unitários (H^H = I ou H^2 = I para reais) e usados para introduzir zeros em vetores sem alterar a norma.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Derivar a matriz do refletor de Householder",
                            "description": "Dado um vetor u, construir explicitamente a matriz H = I - 2uu^T / ||u||^2 e verificar que ela reflete sobre o hiperplano ortogonal a u.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Verificar propriedades ortogonais e simetria",
                            "description": "Demonstrar algebricamente que H é simétrica e H^2 = I, preservando a norma euclidiana de vetores (||Hx||_2 = ||x||_2).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Calcular refletor para vetor simples",
                            "description": "Computar manualmente H para u = [1,1]^T e aplicar a um vetor teste, verificando o reflexo geométrico.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Construção do Vetor Householder para Zerar Subdiagonais",
                        "description": "Para um vetor x = [x1, x2, ..., xn]^T com n>=2, construir u = x ± ||x|| e1 (escolhendo sinal para estabilidade numérica) tal que Hx = ±||x|| e1, zerando os componentes de 2 a n.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Escolher o vetor u para mapear x em múltiplo de e1",
                            "description": "Derivar u = x - α e1, onde α = sign(x1) ||x||_2, garantindo que ||u||_2 seja estável e Hx tenha zeros abaixo da primeira entrada.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Evitar cancelamento numérico na escolha do sinal",
                            "description": "Explicar por que α = -sign(x1) ||x||_2 minimiza o risco de cancelamento em u1 = x1 - α, maximizando ||u||_2.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Implementar construção computacionalmente",
                            "description": "Escrever pseudocódigo para calcular u e β = 2 / ||u||^2, evitando computar H explicitamente (aplicação por multiplicação de casas).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Aplicação dos Refletores na Decomposição QR",
                        "description": "Aplicar refletores de Householder sequencialmente às colunas de A (m x n), introduzindo zeros abaixo da diagonal em R, obtendo A = QR com Q ortogonal e R triangular superior.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Triangularizar primeira coluna de A",
                            "description": "Construir H1 para zerar subdiagonal da primeira coluna de A, aplicando H1 A para obter zeros abaixo de (1,1).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Aplicar refletores subsequentes às colunas restantes",
                            "description": "Para k=2 a n, construir Hk atuando em linhas k:m e colunas k:n, acumulando Q = H1 H2 ... Hn.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Analisar complexidade e estabilidade da QR por Householder",
                            "description": "Calcular custo operacional (≈ 2mn^2 - 2n^3/3 flops) e discutir superioridade em estabilidade numérica sobre Gram-Schmidt.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.4",
                            "name": "Exemplo numérico completo de decomposição QR",
                            "description": "Realizar decomposição QR manual para matriz 3x3, verificando A = QR e ortogonalidade de Q.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Rotações de Givens",
                    "description": "Rotações planas para introduzir zeros em matrizes e auxiliar na fatoração QR.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Matriz de Rotação de Givens",
                        "description": "Matriz ortogonal que atua como uma rotação no plano definido por duas linhas ou colunas específicas de uma matriz, preservando a norma euclidiana e introduzindo zeros de forma estável numericamente.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Identificar a estrutura de uma matriz de Givens",
                            "description": "Reconhecer a forma padrão de uma matriz de rotação de Givens G(i,j,θ) como uma matriz identidade com um bloco 2x2 nas posições (i,i), (i,j), (j,i) e (j,j), onde o bloco é [[c, s], [-s, c]] com c = cos(θ) e s = sin(θ).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Verificar propriedades ortogonais",
                            "description": "Demonstrar que G^T G = I e det(G) = 1, calculando o produto e confirmando a ortogonalidade e propriedades de rotação para qualquer θ.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Calcular ação sobre vetores e matrizes",
                            "description": "Aplicar multiplicação à esquerda ou direita por G para rotacionar componentes específicas de um vetor ou coluna de matriz, preservando a norma.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Construção para Introduzir Zeros",
                        "description": "Determinação dos parâmetros c e s de uma rotação de Givens para zerar um elemento específico em uma posição (i,j) de uma matriz, minimizando perturbações numéricas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Derivar fórmulas para c e s",
                            "description": "Dado um vetor [f, g]^T, calcular r = sqrt(f² + g²), c = f/r, s = g/r (com tratamento para f=0 ou g=0), garantindo estabilidade numérica evitando cancelamentos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Aplicar rotação para zerar elemento",
                            "description": "Executar G * [a_{k,i}, a_{k,j}]^T = [r, 0]^T para linhas ou colunas, atualizando apenas as posições i e j afetadas.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Tratar casos numéricos especiais",
                            "description": "Implementar variantes estáveis como c = 1/sqrt(1 + (g/f)²) quando |f| >> |g|, evitando overflow ou underflow em computação de ponto flutuante.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Aplicação na Fatoração QR via Givens",
                        "description": "Sequência de rotações de Givens aplicadas sistematicamente para triangularizar uma matriz A em Q R, onde Q é produto de Givens e R é triangular superior.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Descrever algoritmo de QR com Givens",
                            "description": "Explicar o processo: para cada coluna k de 1 a n-1, aplicar rotações G(i,k,θ) para i = k+1 a m, zerando subdiagonal na coluna k.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Implementar pseudocódigo para QR",
                            "description": "Escrever pseudocódigo eficiente que armazena Q implicitamente como produto de Givens, aplicando rotações apenas nas linhas/colunas relevantes para economia computacional O(m n²).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Analisar estabilidade e custo computacional",
                            "description": "Comparar estabilidade com Householder (Givens bom para matrizes esparsas ou paralelizáveis) e custo: cerca de 2 m n² flops para m x n matriz.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.6",
                    "name": "Aplicações da Decomposição QR",
                    "description": "Uso em resolução de sistemas lineares e problemas de mínimos quadrados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.6.1",
                        "name": "Resolução de Sistemas Lineares com Decomposição QR",
                        "description": "Exploração do uso da decomposição QR para resolver sistemas lineares Ax = b de forma estável numericamente, evitando a formação de matrizes mal-condicionadas e aproveitando a ortogonalidade das matrizes Q e R.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.1.1",
                            "name": "Identificar condições para aplicação da QR em sistemas lineares",
                            "description": "Reconhecer cenários onde a decomposição QR é preferível à eliminação gaussiana, como em matrizes quadradas trianguláveis com fatores ortogonais, considerando estabilidade numérica e sensibilidade conforme Golub & Van Loan (1996).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.1.2",
                            "name": "Implementar resolução via forward substitution em R",
                            "description": "Após obter A = QR, resolver Qy = b por substituição frontal e Rx = y por back substitution, implementando algoritmos em pseudocódigo ou MATLAB para sistemas lineares consistentes.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.1.3",
                            "name": "Analisar estabilidade numérica da abordagem QR",
                            "description": "Comparar o condicionamento relativo do erro em soluções obtidas por QR versus métodos diretos, utilizando análise de sensibilidade de sistemas lineares e boundos de erro baseados em ||Q||=1 e cond(R).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.6.2",
                        "name": "Solução de Problemas de Mínimos Quadrados com Decomposição QR",
                        "description": "Aplicação da decomposição QR para resolver problemas de mínimos quadrados lineares min ||Ax - b||_2, evitando a formação explícita de A^T A que amplifica erros numéricos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.2.1",
                            "name": "Formular o problema de mínimos quadrados via QR",
                            "description": "Derivar que a solução x minimiza ||Ax - b|| quando A = QR, resolvendo R x = Q^T b, destacando a estabilidade superior ao método das equações normais (Meyer, 2000).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.2.2",
                            "name": "Aplicar QR com Householder para mínimos quadrados",
                            "description": "Implementar reflexão de Householder para computar QR de A m x n (m >= n), reduzindo a zero subdiagonal de A, e resolver o sistema reduzido para x, com exemplos numéricos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.2.3",
                            "name": "Avaliar sensibilidade em problemas superdeterminados",
                            "description": "Analisar o impacto do condicionamento de A na solução de mínimos quadrados via QR, comparando com decomposição em valores singulares e discutindo rank-deficiência (Watkins, 2010).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Quadrados Mínimos Lineares",
                "description": "Métodos para encontrar a melhor aproximação de soluções em sistemas lineares incompatíveis.",
                "totalSkills": 41,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Formulação do Problema dos Mínimos Quadrados Lineares",
                    "description": "Definição do problema de minimizar ||Ax - b||_2 para sistemas lineares incompatíveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1.1",
                        "name": "Sistemas Lineares Incompatíveis",
                        "description": "Caracterização de sistemas lineares Ax = b sem solução exata, ocorrendo quando o vetor b não pertence ao espaço coluna de A, levando à necessidade de soluções aproximadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1.1",
                            "name": "Identificar incompatibilidade de sistemas lineares",
                            "description": "Determinar se Ax = b é incompatível verificando se rank(A) = rank([A|b]) ou usando testes geométricos e algébricos, como projeção de b sobre col(A).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.1.2",
                            "name": "Interpretar geometricamente a incompatibilidade",
                            "description": "Explicar visualmente por que b não está no espaço coluna de A em dimensões baixas (R^2 ou R^3) e o conceito de distância mínima ao subespaço.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.1.3",
                            "name": "Diagnosticar incompatibilidade via fatorações",
                            "description": "Usar decomposição QR ou SVD para detectar incompatibilidade, identificando singularidades ou resíduos não nulos em sistemas supostamente exatos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.1.2",
                        "name": "Norma Euclidiana do Resíduo",
                        "description": "Definição da norma L2, ||Ax - b||_2, como medida quadrática do erro de aproximação em sistemas lineares, enfatizando sua interpretação como energia ou distância euclidiana.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.2.1",
                            "name": "Calcular a norma do resíduo",
                            "description": "Computar ||r||_2 = sqrt(r^T r) para r = b - Ax, incluindo casos numéricos com matrizes pequenas e interpretação do valor mínimo possível.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2.2",
                            "name": "Propriedades da norma L2 em contextos lineares",
                            "description": "Explicar propriedades como positividade, homogeneidade e submultiplicatividade, e por que ela é preferida para mínimos quadrados em álgebra linear computacional.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.1.3",
                        "name": "Formulação Matemática dos Mínimos Quadrados Lineares",
                        "description": "Enunciado preciso do problema: encontrar argmin_x ||Ax - b||_2 para A m x n com m > n e rank(A) = n, incluindo equivalência com minimização de ||Ax - b||_2^2 e condições de otimalidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.3.1",
                            "name": "Escrever a formulação do problema",
                            "description": "Formular matematicamente o problema de mínimos quadrados como min_x ||Ax - b||_2 sujeito a sistemas incompatíveis, distinguindo de problemas exatos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3.2",
                            "name": "Derivar as equações normais",
                            "description": "Obter A^T A x = A^T b como condição necessária de otimalidade via cálculo de gradiente ou projeção ortogonal, citando referências como Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3.3",
                            "name": "Interpretar a solução geometricamente",
                            "description": "Descrever a solução x* como aquela cujo Ax* é a projeção ortogonal de b sobre col(A), com resíduo perpendicular ao espaço coluna.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Equações Normais",
                    "description": "Derivação das equações A^T A x = A^T b e condições de existência e unicidade da solução.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1.1",
                        "name": "Derivação das Equações Normais",
                        "description": "Processo matemático para obter as equações A^T A x = A^T b a partir da minimização da norma quadrática do resíduo ||Ax - b||_2^2.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1.1",
                            "name": "Formular o problema de quadrados mínimos lineares",
                            "description": "Dado um sistema sobredeterminado Ax = b com m > n, formular o problema como minimizar ||Ax - b||_2^2, identificando o resíduo r = b - Ax e a norma euclidiana.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.1.2",
                            "name": "Derivar as equações normais por cálculo variacional",
                            "description": "Usar cálculo multivariável para minimizar f(x) = ||Ax - b||_2^2 = (Ax - b)^T (Ax - b), computando o gradiente ∇f(x) = 2 A^T (Ax - b) = 0, levando a A^T A x = A^T b.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.1.3",
                            "name": "Interpretar geometricamente via projeção ortogonal",
                            "description": "Explicar que a solução minimiza o resíduo perpendicular às colunas de A, ou seja, A^T r = 0, implicando A^T (b - Ax) = 0, resultando em A^T A x = A^T b.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.1.2",
                        "name": "Propriedades da Matriz Normal A^T A",
                        "description": "Características da matriz simétrica A^T A, incluindo positividade semidefinida e relação com o posto de A.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.2.1",
                            "name": "Verificar simetria e semidefinitude positiva",
                            "description": "Provar que A^T A é simétrica ( (A^T A)^T = A^T A ) e x^T (A^T A) x = ||A x||_2^2 ≥ 0 para todo x.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2.2",
                            "name": "Relacionar posto e autovalores de A^T A com A",
                            "description": "Mostrar que rank(A^T A) = rank(A) e os autovalores não-nulos de A^T A coincidem com os quadrados dos singulares de A.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.1.3",
                        "name": "Condições de Existência e Unicidade da Solução",
                        "description": "Análise das condições para que o sistema A^T A x = A^T b admita solução única, múltiplas ou nenhuma.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.3.1",
                            "name": "Provar existência da solução nas equações normais",
                            "description": "Demonstrar que A^T b está sempre no alcance de A^T A, pois alcance(A^T A) = alcance(A^T), garantindo existência de pelo menos uma solução para qualquer b.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3.2",
                            "name": "Determinar condição de unicidade",
                            "description": "Estabelecer que a solução é única se e somente se rank(A) = n (colunas linearmente independentes), equivalente a A^T A invertível ou ker(A) = {0}.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3.3",
                            "name": "Descrever soluções no caso de múltiplas soluções",
                            "description": "Explicar que, se rank(A) < n, as soluções são x = x_part + ker(A), onde x_part é uma solução particular e ker(A) é o núcleo de A.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Resolução via Decomposição QR",
                    "description": "Uso da ortogonalização QR para resolver eficientemente problemas de mínimos quadrados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Decomposição QR",
                        "description": "Decomposição de uma matriz retangular A (m x n, m >= n) em A = QR, onde Q é ortogonal (colunas ortonormais) e R é triangular superior, obtida via processos de ortogonalização como Gram-Schmidt.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Definir e caracterizar a decomposição QR",
                            "description": "Explicar a decomposição QR como A = QR com Q ortogonal (Q^T Q = I) e R triangular superior, listar propriedades como preservação de normas e ângulos, e identificar condições para existência única (colunas linearmente independentes).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Implementar ortogonalização Gram-Schmidt clássica",
                            "description": "Derivar e codificar o algoritmo Gram-Schmidt clássico para computar Q e R a partir de A, analisando passos iterativos de projeção ortogonal e normalização.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Comparar Gram-Schmidt clássica e modificada",
                            "description": "Analisar a sensibilidade numérica da Gram-Schmidt clássica à perda de ortogonalidade por erros de arredondamento e demonstrar a versão modificada para maior estabilidade.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Problema dos Mínimos Quadrados Lineares",
                        "description": "Formulação do problema min ||Ax - b||_2^2 para sistemas superdeterminados, com solução x = (A^T A)^{-1} A^T b sujeita a instabilidades numéricas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Formular o problema de mínimos quadrados",
                            "description": "Derivar a equação normal A^T A x = A^T b a partir da minimização da norma residual ||Ax - b||_2^2 e discutir condições de existência e unicidade da solução.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Analisar limitações da solução normal",
                            "description": "Explicar a ill-condicionamento de A^T A quando A é mal-condicionada, ilustrando com exemplos numéricos a amplificação de erros.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Resolução de Mínimos Quadrados via QR",
                        "description": "Uso da decomposição QR para transformar o problema em um sistema triangular bem-condicionado: min ||Rx - Q^T b||_2 com back-substitution.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Derivar a solução via decomposição QR",
                            "description": "Mostrar que min ||Ax - b||_2 = min ||QRx - b||_2 = min ||Rx - Q^T b||_2, justificando a estabilidade devido à ortogonalidade de Q e triangularidade de R.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Implementar o algoritmo QR para mínimos quadrados",
                            "description": "Codificar o processo completo: computar QR de A, calcular c = Q^T b, resolver Rx = c por substituição reversa, e estimar o resíduo.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Avaliar vantagens numéricas e sensibilidade",
                            "description": "Comparar estabilidade e custo computacional do método QR com equações normais, referenciando análise de sensibilidade de Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Resolução via Decomposição SVD",
                    "description": "Aplicação da decomposição em valores singulares para soluções estáveis, inclusive em casos de posto deficiente.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Decomposição em Valores Singulares (SVD)",
                        "description": "A decomposição SVD de uma matriz A ∈ ℝ^{m×n} é expressa como A = U Σ V^T, onde U ∈ ℝ^{m×m} e V ∈ ℝ^{n×n} são matrizes ortogonais, e Σ ∈ ℝ^{m×n} é diagonal com valores singulares não-negativos σ₁ ≥ σ₂ ≥ ... ≥ σ_r > 0, r sendo o posto de A. Essa decomposição é fundamental para soluções numéricas estáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Definir e interpretar componentes da SVD",
                            "description": "Explicar os componentes U, Σ e V da SVD, incluindo o significado geométrico dos valores singulares como alongamentos semi-eixos de elipsoides e vetores singulares como direções principais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Calcular SVD manualmente para matrizes pequenas",
                            "description": "Realizar o cálculo passo a passo da SVD para matrizes 2×2 ou 3×2, usando eigen decomposição de A^T A e A A^T, e verificar a ortogonalidade de U e V.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Identificar propriedades numéricas da SVD",
                            "description": "Listar e demonstrar propriedades como rank(A) = número de σ_i > 0, ||A||_2 = σ_max, e estabilidade computacional da SVD em comparação com outras fatorizações.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Problema dos Quadrados Mínimos Lineares",
                        "description": "Resolver o problema min_{x} ||Ax - b||_2 para A ∈ ℝ^{m×n} com m ≥ n, incluindo a caracterização da solução via equações normais A^T A x = A^T b e condições de unicidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Formular o problema de quadrados mínimos",
                            "description": "Derivar a norma residual ||Ax - b||_2^2 e condições para soluções mínimas, distinguindo casos de posto completo e deficiente.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Resolver via equações normais",
                            "description": "Explicar limitações numéricas das equações normais devido à formação de A^T A, que amplifica erros de arredondamento em matrizes mal-condicionadas.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Resolução de Quadrados Mínimos via SVD",
                        "description": "Aplicação da SVD para obter a pseudo-inversa A^+ = V Σ^+ U^T, onde Σ^+ inverte os σ_i > 0, fornecendo soluções estáveis x = A^+ b, mínimo norma entre soluções mínimas, e tratamento de posto deficiente via truncamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Derivar a solução mínima via pseudo-inversa SVD",
                            "description": "Demonstrar que x = V Σ^+ U^T b minimiza ||Ax - b||_2 e, se não única, tem mínimo ||x||_2, com prova usando propriedades ortogonais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Tratar casos de posto deficiente com SVD",
                            "description": "Aplicar truncamento de valores singulares pequenos (thresholding) para regularização, resolvendo sistemas rank-deficient e analisando estabilidade.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Analisar sensibilidade numérica da solução SVD",
                            "description": "Quantificar a condição do problema de QM via σ_min / σ_max e comparar estabilidade da SVD com QR ou equações normais, usando exemplos numéricos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Análise de Sensibilidade em Mínimos Quadrados",
                    "description": "Estudo do condicionamento e sensibilidade da solução aos erros em A e b.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Condicionamento em Problemas de Mínimos Quadrados",
                        "description": "Análise do número de condição da matriz A no contexto de quadrados mínimos lineares, utilizando decomposição em valores singulares (SVD) e decomposição QR para avaliar a estabilidade numérica da solução.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Calcular o número de condição via SVD",
                            "description": "Computar o número de condição cond(A) = σ_max / σ_min a partir da decomposição SVD de A, interpretando seu impacto na amplificação de erros na solução dos mínimos quadrados.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Avaliar condicionamento usando decomposição QR",
                            "description": "Utilizar a decomposição QR para estimar o condicionamento de A em problemas de mínimos quadrados, comparando com SVD e analisando a estabilidade do processo de ortogonalização.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Interpretar o papel dos valores singulares pequenos",
                            "description": "Identificar e interpretar valores singulares pequenos em A, relacionando-os à ill-condição e à sensibilidade da pseudoinversa em soluções de mínimos quadrados.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Sensibilidade a Perturbações em b",
                        "description": "Estudo de como erros relativos no vetor b se propagam para a solução x em ||Ax - b||_2 mínimo, derivando bounds de erro baseados no condicionamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Derivar bound de erro para δb",
                            "description": "Derivar e aplicar a fórmula ||δx|| / ||x|| ≤ cond(A) * ||δb|| / ||b|| para perturbações em b, usando propriedades da pseudoinversa de A.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Analisar erro no resíduo",
                            "description": "Analisar a sensibilidade do resíduo r = b - Ax a perturbações em b, distinguindo entre componente no espaço coluna de A e ortogonal.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Simular propagação de erro em b",
                            "description": "Implementar simulações numéricas para observar a amplificação de ruído em b na solução x, usando MATLAB ou Python com SVD.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Sensibilidade a Perturbações em A",
                        "description": "Análise da sensibilidade da solução x aos erros na matriz A, incluindo bounds para perturbações relativas e o papel do condicionamento em problemas mal-condicionados.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Derivar bound de sensibilidade para δA",
                            "description": "Estabelecer bounds como ||δx|| / ||x|| ≤ [cond(A)^2 * ||δA|| / ||A||] / (1 - cond(A) * ||δA|| / ||A||), baseado em resultados de Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1",
                              "10.1.4.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Comparar sensibilidade em A vs b",
                            "description": "Comparar quantitativamente a sensibilidade a erros em A versus b, destacando que perturbações em A são tipicamente mais danosas devido ao fator cond(A)^2.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Aplicar análise em problemas reais",
                            "description": "Aplicar a análise de sensibilidade a um problema de regressão linear real, avaliando o impacto de erros em A (dados) e b (observações) usando SVD.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.2",
                              "10.1.4.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Análise de Sensibilidade",
                "description": "Avaliação geral da robustez numérica de algoritmos e decomposições matriciais.",
                "totalSkills": 48,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Número de Condição de Matrizes",
                    "description": "Medida quantitativa da sensibilidade de uma matriz a perturbações, definida como a razão entre normas do maior e menor valor singular.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Definição e Interpretação do Número de Condição",
                        "description": "Conceito fundamental que define o número de condição como uma medida quantitativa da sensibilidade de uma matriz a pequenas perturbações, expresso como cond(A) = ||A|| · ||A^{-1}|| para normas compatíveis, indicando amplificação de erros.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Definir o número de condição usando normas matriciais",
                            "description": "Explicar e formular cond_p(A) = ||A||_p · ||A^{-1}||_p para p=1,2,∞, destacando que valores altos indicam ill-condicionamento e maior sensibilidade numérica.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Interpretar o significado de sensibilidade via número de condição",
                            "description": "Analisar como cond(A) ≈ 10^k implica perda de k dígitos significativos em computações, relacionando com estabilidade numérica em álgebra linear computacional.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Calcular o número de condição para matrizes pequenas",
                            "description": "Computar cond_2(A) manualmente para matrizes 2x2 ou 3x3, usando normas euclidianas e inversa, e interpretar resultados numéricos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Número de Condição via Decomposição em Valores Singulares (SVD)",
                        "description": "Relação direta entre o número de condição na norma 2 e os valores singulares de A, onde cond_2(A) = σ_max / σ_min, facilitando análise espectral da sensibilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Relacionar cond_2(A) com valores singulares da SVD",
                            "description": "Derivar e demonstrar que para A = UΣV^T, cond_2(A) = σ_1 / σ_n, explicando por que matrizes com valores singulares próximos são bem condicionadas.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Identificar propriedades especiais do número de condição",
                            "description": "Reconhecer que cond(A) = 1 para matrizes ortogonais, cond(AB) ≤ cond(A)cond(B) e cond(A^T) = cond(A), com exemplos computacionais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Extrair o número de condição de uma decomposição SVD",
                            "description": "Dado os valores singulares de uma SVD computada, calcular cond_2(A) e avaliar o condicionamento, relacionando com estabilidade em métodos numéricos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Aplicações na Análise de Sensibilidade de Sistemas Lineares",
                        "description": "Uso do número de condição para quantificar erros em soluções de Ax = b, incluindo bounds para perturbações em A e b, relevante para equações lineares e quadrados mínimos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Aplicar bounds de erro relativo usando cond(A)",
                            "description": "Formular e derivar |x - ˃x| / ||x|| ≤ cond(A) (|A - ˃A| / ||A|| + |b - ˃b| / ||b||), explicando amplificação de erros relativos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.2",
                              "10.1.5.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Analisar sensibilidade em problemas de quadrados mínimos",
                            "description": "Estender o conceito para min ||Ax - b||_2, onde cond(A) afeta a estabilidade da solução via pseudoinversa, com exemplos de decomposição QR e SVD.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Avaliar condicionamento em métodos iterativos",
                            "description": "Relacionar cond(A) com convergência de métodos como Gauss-Seidel ou gradiente conjugado, citando referências de Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Sensibilidade de Sistemas Lineares Ax=b",
                    "description": "Análise de como pequenas perturbações em A ou b afetam a solução x, usando o número de condição.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Número de Condição da Matriz",
                        "description": "Definição e propriedades do número de condição κ(A) = ||A|| ⋅ ||A⁻¹||, que mede a sensibilidade da solução de Ax = b a perturbações, com ênfase em normas como a norma 2 via decomposição em valores singulares (SVD).",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Definir o número de condição",
                            "description": "Explicar a definição matemática do número de condição κ(A) para uma matriz invertível A, incluindo sua interpretação como amplificador relativo de erros em sistemas lineares.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Calcular κ(A) usando normas",
                            "description": "Computar o número de condição em diferentes normas (1, 2, ∞), utilizando SVD para a norma 2, e implementar em software como MATLAB ou Python para matrizes numéricas.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Interpretar valores de κ(A)",
                            "description": "Analisar o significado de κ(A) = 1 (bem condicionado), κ(A) ≈ 10^k (moderadamente/fortemente mal condicionado) e relacionar com estabilidade numérica de soluções.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Sensibilidade a Perturbações em b",
                        "description": "Análise do impacto de pequenas mudanças δb no vetor de lado direito b sobre a solução x, com a estimativa relativa ||δx||/||x|| ≤ κ(A) ⋅ ||δb||/||b||.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Derivar a estimativa de erro para δb",
                            "description": "Derivar e demonstrar a desigualdade ||δx||/||x|| ≤ κ(A) ⋅ ||δb||/||b|| a partir da fórmula de perturbação para sistemas lineares Ax = b.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Aplicar em exemplos numéricos",
                            "description": "Resolver numericamente um sistema Ax = b, introduzir perturbações δb e verificar empiricamente o bound κ(A) ⋅ ||δb||/||b|| comparando com ||δx||/||x||.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Avaliar estabilidade com ruído",
                            "description": "Discutir casos onde o bound é atingido (vetores singulares) e interpretar resultados em contextos de ruído de medição em aplicações reais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Sensibilidade a Perturbações em A",
                        "description": "Estudo do efeito de perturbações δA na matriz dos coeficientes A sobre x, com bounds como ||δx||/||x|| ≤ (κ(A) / (1 - κ(A)||δA||/||A||)) ⋅ (||δA||/||A|| + ||δb||/||b||), assumindo perturbações pequenas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Derivar bound para perturbações em A",
                            "description": "Derivar a fórmula de sensibilidade para δA, incluindo o termo quadrático κ(A)^2 em aproximações de primeira ordem, e condições para validade (||δA|| < 1/||A^{-1}||).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Implementar análise computacional",
                            "description": "Usar SVD ou decomposição QR para estimar κ(A), simular perturbações δA aleatórias e quantificar o erro relativo em x via código numérico.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1",
                              "10.1.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Comparar sensibilidade em A e b",
                            "description": "Comparar graficamente ou tabularmente o impacto relativo de perturbações em A versus b, destacando quando κ(A)^2 domina em matrizes mal condicionadas.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.1",
                              "10.1.5.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Robustez da Decomposição QR",
                    "description": "Avaliação da estabilidade numérica da ortogonalização QR em relação a erros de arredondamento.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Decomposição QR e Métodos de Ortogonalização",
                        "description": "Compreensão dos algoritmos fundamentais para computar a decomposição QR de uma matriz, incluindo reflexões de Householder e rotações de Givens, e sua importância na estabilidade numérica.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Descrever os passos do algoritmo de Householder para QR",
                            "description": "Explicar detalhadamente o processo de aplicação sucessiva de reflexões de Householder para triangularizar uma matriz A em Q e R, destacando a preservação da norma e ortogonalidade.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Comparar Householder e Givens para estabilidade",
                            "description": "Analisar as diferenças entre os métodos de Householder e Givens em termos de contagem de flops, preenchimento e sensibilidade a erros de arredondamento em matrizes densas e esparsas.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Implementar pseudocódigo básico de QR via Householder",
                            "description": "Escrever pseudocódigo para o algoritmo de Householder, incluindo computação dos refletors e aplicação à matriz, considerando operações em aritmética exata.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Modelo de Erros de Arredondamento em Computações Matriciais",
                        "description": "Modelagem matemática dos erros introduzidos pela aritmética de ponto flutuante em operações como multiplicação e soma de matrizes, essencial para análise de sensibilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Explicar o modelo fl(n) de Wilkinson",
                            "description": "Descrever o modelo padrão de aritmética de ponto flutuante fl(x op y) = (x op y)(1 + δ) com |δ| ≤ u, e estendê-lo para operações matriciais como produto de matrizes.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Derivar bounds de erro para operações básicas",
                            "description": "Derivar ligações para erros relativos em soma, produto escalar e produto de matrizes, usando o conceito de máquina epsilon e crescimento de erros.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Aplicar modelo de erro a transformações ortogonais",
                            "description": "Analisar como erros de arredondamento afetam a ortogonalidade em transformações como Householder, mostrando perda de Q^T Q = I.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Estabilidade Numérica e Robustez da Decomposição QR",
                        "description": "Avaliação quantitativa da estabilidade backward da decomposição QR, demonstrando que os erros computados correspondem a perturbações pequenas na matriz original.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Definir estabilidade backward para fatorizações",
                            "description": "Explicar o conceito de estabilidade backward: computar fatores de uma matriz perturbada próxima à original, com bound |ΔA| ≤ ε ||A||.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Provar robustez da QR via Householder",
                            "description": "Demonstrar, usando análise de erros, que a QR computada satisfaz Q_hat R_hat = (A + ΔA) com ||ΔA|| / ||A|| = O(n u), onde u é a precisão da máquina.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Interpretar resultados de Golub & Van Loan",
                            "description": "Analisar teoremas do livro 'Matrix Computations' sobre perda de ortogonalidade O(n u) e implicações para quadrados mínimos e eigenvalores.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.4",
                            "name": "Comparar estabilidade com outras fatorizações",
                            "description": "Contrastar a robustez da QR com LU e Cholesky, destacando vantagens em problemas mal-condicionados e aplicações em análise de sensibilidade.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Sensibilidade na Decomposição em Valores Singulares (SVD)",
                    "description": "Estudo da robustez da SVD para análise de rank e pseudoinversas sob perturbações.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Sensibilidade dos Valores Singulares",
                        "description": "Estudo das perturbações nos valores singulares de uma matriz sob pequenas variações nos elementos da matriz original, incluindo teoremas de Weyl e Mirsky.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Aplicar teorema de Weyl para valores singulares",
                            "description": "Calcular limites superiores para a variação dos valores singulares individuais sob perturbações normadas da matriz, usando desigualdades como |σ_i(A+E) - σ_i(A)| ≤ ||E||_2.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Analisar teorema de Mirsky para espectro singular",
                            "description": "Avaliar a sensibilidade do conjunto completo de valores singulares, computando distâncias entre espectros singulares de matrizes perturbadas via normas de Frobenius ou espectral.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Interpretar curvas de singular values em análises numéricas",
                            "description": "Identificar gaps nos valores singulares para prever robustez contra ruído, plotando e analisando decaimento de singular values em exemplos computacionais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Análise de Rank Numérico via SVD",
                        "description": "Avaliação da robustez da SVD na determinação do rank efetivo de matrizes ruidosas, considerando thresholds baseados em perturbações.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Definir rank numérico com base em singular values",
                            "description": "Estabelecer critérios para rank numérico, como σ_k ≥ ε ||A||_2, onde ε relaciona-se à magnitude da perturbação relativa.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Avaliar estabilidade do rank sob perturbações",
                            "description": "Simular perturbações aleatórias em matrizes de rank-deficiente e observar mudanças no rank numérico estimado pela SVD.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Comparar métodos de threshold para rank",
                            "description": "Implementar e comparar thresholds fixos, adaptativos e baseados em ruído para determinação precisa de rank em dados reais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Sensibilidade da Pseudoinversa via SVD",
                        "description": "Análise da estabilidade da pseudoinversa de Moore-Penrose computada pela SVD sob perturbações, com foco em condições de singularidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Calcular pseudoinversa estável via SVD truncada",
                            "description": "Construir pseudoinversa regularizada usando apenas singular values acima de um threshold, minimizando amplificação de erros em soluções de mínimos quadrados.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Quantificar erro na pseudoinversa perturbada",
                            "description": "Derivar e aplicar bornas para ||A^+ + E^+ - A^+||, relacionando com o menor valor singular não-nulo e norma da perturbação.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Aplicar em problemas de mínimos quadrados",
                            "description": "Resolver sistemas superdeterminados perturbados usando pseudoinversa SVD e analisar sensibilidade da solução em termos de condição numérica.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.4",
                            "name": "Comparar com outras decomposições para pseudoinversas",
                            "description": "Contrastar estabilidade da pseudoinversa via SVD com abordagens QR ou métodos iterativos em cenários de alta condição.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Análise de Sensibilidade em Quadrados Mínimos",
                    "description": "Exame da estabilidade numérica das soluções de mínimos quadrados lineares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Sensibilidade em Sistemas Lineares",
                        "description": "Fundamentos da análise de sensibilidade numérica para soluções de sistemas de equações lineares, incluindo medidas de condição e impacto de perturbações em dados de entrada.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Calcular o número de condição de uma matriz",
                            "description": "Computar o número de condição cond(A) = ||A|| * ||A^{-1}|| usando normas adequadas e interpretar seu significado na amplificação de erros em soluções de Ax = b.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Analisar perturbações em soluções lineares",
                            "description": "Derivar e aplicar bounds para erros relativos em soluções x de Ax = b sob perturbações δA e δb, usando desigualdades como ||δx|| / ||x|| ≤ cond(A) * (||δA|| / ||A|| + ||δb|| / ||b||).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Interpretar estabilidade de sistemas lineares",
                            "description": "Classificar sistemas como bem-condicionados ou mal-condicionados com base no número de condição e discutir implicações computacionais em algoritmos numéricos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Decomposição QR e Quadrados Mínimos",
                        "description": "Uso da decomposição QR para resolver problemas de mínimos quadrados lineares e análise de sua estabilidade numérica.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Realizar decomposição QR via ortogonalização",
                            "description": "Implementar e aplicar a decomposição QR usando Gram-Schmidt ou Householder para resolver min ||Ax - b||_2 via R y = Q^T b.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Avaliar sensibilidade na decomposição QR",
                            "description": "Analisar a estabilidade da solução de mínimos quadrados via QR, considerando o crescimento de erros em Q e R sob perturbações.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Comparar estabilidade de métodos diretos para LS",
                            "description": "Comparar a análise de sensibilidade entre resolução normal (A^T A x = A^T b) e QR, destacando problemas de condicionamento quadrático.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Decomposição em Valores Singulares (SVD)",
                        "description": "Aplicação da SVD na análise de sensibilidade para problemas de mínimos quadrados, especialmente em casos mal-condicionados.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Computar decomposição SVD",
                            "description": "Calcular A = U Σ V^T e interpretar valores singulares σ_i como medidas de 'rank' e sensibilidade em mínimos quadrados.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Aplicar SVD em mínimos quadrados",
                            "description": "Resolver min ||Ax - b||_2 usando SVD: x = V Σ^+ U^T b, e analisar sensibilidade via razão σ_max / σ_min.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Avaliar estabilidade via pseudoinversa",
                            "description": "Discutir bounds de erro para soluções via pseudoinversa SVD, incluindo regularização para problemas rank-deficient.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.4",
                            "name": "Comparar SVD e QR em sensibilidade",
                            "description": "Comparar análises de sensibilidade entre QR e SVD para mínimos quadrados, com ênfase em casos com pequenos valores singulares.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Análise de Métodos Iterativos Clássicos",
                "description": "Estudo da convergência e eficiência de métodos iterativos como Jacobi e Gauss-Seidel para sistemas lineares.",
                "totalSkills": 54,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Método Iterativo de Jacobi",
                    "description": "Definição e algoritmo do método de Jacobi para resolução de sistemas lineares Ax=b.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Decomposição Matricial para o Método de Jacobi",
                        "description": "Compreender a decomposição da matriz coeficiente A em componentes diagonal D, subdiagonal L (triangular inferior estrita) e superdiagonal U (triangular superior estrita), onde A = D + L + U, essencial para o método iterativo de Jacobi em sistemas lineares Ax = b.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Identificar a decomposição A = D + L + U",
                            "description": "Dado um sistema linear Ax = b, decompor a matriz A nas partes diagonal dominante D, triangular inferior estrita L e triangular superior estrita U, reconhecendo que para Jacobi se usa A = D - (L + U).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Verificar diagonal dominância",
                            "description": "Determinar se uma matriz é estritamente diagonal dominante (condição comum para convergência de Jacobi), calculando |a_ii| > sum_{j≠i} |a_ij| para cada i.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Calcular a inversa da matriz diagonal D^{-1}",
                            "description": "Computar a inversa da matriz diagonal D, que é trivial pois D^{-1} tem elementos 1/d_ii na diagonal, preparando para as iterações do método.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Fórmula de Iteração do Método de Jacobi",
                        "description": "Derivar e aplicar a fórmula iterativa x^{(k+1)} = D^{-1} (b - (L + U) x^{(k)}), que atualiza a aproximação da solução a partir de um vetor inicial x^{(0)}.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Derivar a fórmula de iteração de Jacobi",
                            "description": "Partindo de Ax = b e A = D - (L + U), resolver para x = D^{-1} (b - (L + U) x), obtendo a forma iterativa fixa para o método de Jacobi.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Aplicar uma iteração manual",
                            "description": "Dado um sistema 2x2 ou 3x3 diagonal dominante, com x^{(0)}, calcular r = b - (L + U) x^{(0)} e x^{(1)} = D^{-1} r manualmente.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Interpretar o erro entre iterações",
                            "description": "Calcular a diferença ||x^{(k+1)} - x^{(k)}|| e discutir sua relação com a convergência do método.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Algoritmo Completo e Critério de Parada",
                        "description": "Implementar o algoritmo passo a passo do método de Jacobi, incluindo escolha de x^{(0)}, número máximo de iterações e critérios de parada baseados em tolerância de erro.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Escrever o pseudocódigo do algoritmo de Jacobi",
                            "description": "Desenvolver pseudocódigo com: decomposição A, inicialização x0, loop iterativo com atualização x_new = D_inv * (b - (L+U)*x_old), verificação de convergência ||x_new - x_old|| < tol ou k > max_iter.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Definir critérios de parada",
                            "description": "Explicar e implementar critérios como norma do resíduo ||Ax - b|| < tol, norma da diferença ||x^{(k+1)} - x^{(k)}|| < tol ou número máximo de iterações.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Executar o algoritmo em exemplo numérico",
                            "description": "Resolver um sistema 3x3 com Jacobi, mostrando 5 iterações, calculando erros e verificando convergência, comparando com solução exata.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.4",
                            "name": "Analisar limitações iniciais do método",
                            "description": "Discutir casos onde Jacobi pode não convergir (ex: matriz não diagonal dominante) e mencionar relação com raio espectral de iteração.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Método Iterativo de Gauss-Seidel",
                    "description": "Definição e algoritmo do método de Gauss-Seidel, destacando o uso de valores atualizados durante a iteração.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Definição do Método de Gauss-Seidel",
                        "description": "Apresentação formal do método de Gauss-Seidel como um processo iterativo para resolver sistemas lineares Ax = b, baseado na decomposição da matriz A em triangulares estrita inferior (L), diagonal (D) e superior (U), com ênfase na convergência sob condições de diagonal-dominância.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Identificar a forma matricial do método",
                            "description": "Reconhecer a representação (D + L)x^{(k+1)} = b - U x^{(k)}, onde os componentes de x^{(k+1)} são calculados sequencialmente utilizando valores atualizados na mesma iteração.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Explicar condições de aplicabilidade",
                            "description": "Descrever requisitos como diagonal-dominância ou simetria positiva definida para garantir convergência, citando teoremas relevantes de análise de métodos iterativos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Comparar com eliminação direta",
                            "description": "Discutir vantagens do Gauss-Seidel para matrizes esparsas e grandes, em contraste com métodos diretos como LU que podem ser caros computacionalmente.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Algoritmo do Método de Gauss-Seidel",
                        "description": "Descrição passo a passo do pseudocódigo do algoritmo, incluindo inicialização, critério de parada e atualização sequencial das componentes do vetor solução.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Implementar o pseudocódigo básico",
                            "description": "Escrever o algoritmo em pseudocódigo com loop iterativo, cálculo de resíduos e tolerância epsilon para parada baseada em norma do erro.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Calcular iterações manuais",
                            "description": "Executar 3-5 iterações manualmente para um sistema 3x3, mostrando as atualizações sequenciais de x1, x2, x3 em cada passo.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Definir critérios de parada",
                            "description": "Explicar uso de norma do vetor diferença ||x^{(k+1)} - x^{(k)}|| < ε ou norma do resíduo ||b - A x^{(k)}|| < ε, com exemplos numéricos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Uso de Valores Atualizados na Iteração",
                        "description": "Destaque da principal diferença em relação ao método de Jacobi: o emprego imediato dos valores recém-calculados nas equações subsequentes da mesma iteração, acelerando a convergência.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Contrastar com o método de Jacobi",
                            "description": "Comparar as fórmulas iterativas, ilustrando graficamente ou tabularmente como o Gauss-Seidel usa x_i^{(k+1)} para j > i, enquanto Jacobi usa apenas x^{(k)}.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Analisar impacto na convergência",
                            "description": "Demonstrar, via raio espectral da matriz de iteração, que o Gauss-Seidel geralmente converge mais rápido que Jacobi para matrizes diagonal-dominantes.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Implementar variação com relaxação",
                            "description": "Estender o algoritmo para Gauss-Seidel com parâmetro de relaxação ω, explicando como ω=1 recupera o método original e valores de ω aceleram convergência.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Matriz de Iteração e Raio Espectral",
                    "description": "Conceitos de matriz de iteração e raio espectral como base para análise de convergência.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Matriz de Iteração",
                        "description": "A matriz de iteração G é o elemento central nos métodos iterativos estacionários para resolver sistemas lineares Ax = b, onde a iteração é expressa como x_{k+1} = G x_k + c, com G derivada da decomposição de A (ex.: para Jacobi, G = I - D^{-1}A; para Gauss-Seidel, envolve triangulares).",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Definir métodos iterativos estacionários lineares",
                            "description": "Explicar a forma geral x_{k+1} = G x_k + c para métodos iterativos estacionários, identificando G como matriz de iteração e c como vetor constante derivado de b e A.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Construir matriz de iteração para método de Jacobi",
                            "description": "Dada uma matriz A decomposta em diagonal D, subdiagonal L e superdiagonal U, derivar G_J = I - D^{-1}A = D^{-1}(L + U) e computar explicitamente para matrizes tridiagonais ou sparse.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Construir matriz de iteração para método de Gauss-Seidel",
                            "description": "Derivar G_{GS} = (D + L)^{-1} (-U) a partir da decomposição A = D + L + U, e comparar com Jacobi em termos de estrutura e propriedades espectrais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.4",
                            "name": "Relacionar matriz de iteração com normas e condicionamento",
                            "description": "Analisar como o condicionamento de A (via análise de sensibilidade) afeta a escolha da decomposição para minimizar ||G|| em métodos clássicos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Raio Espectral",
                        "description": "O raio espectral ρ(G) é o máximo dos módulos dos autovalores de G, servindo como critério fundamental para a convergência de métodos iterativos: o método converge se e somente se ρ(G) < 1, com taxa de convergência determinada por ρ(G).",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Definir raio espectral e espectro de uma matriz",
                            "description": "Definir o espectro σ(G) como o conjunto de autovalores λ_i e ρ(G) = max_i |λ_i|, relacionando com normas de matriz (ρ(G) ≤ ||G|| para qualquer norma subordinada).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Calcular raio espectral de matrizes de iteração clássicas",
                            "description": "Computar autovalores e ρ(G) para exemplos simples (matrizes 2x2 ou circulares), usando ferramentas numéricas ou propriedades analíticas para Jacobi e Gauss-Seidel.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Aplicar teorema de convergência via raio espectral",
                            "description": "Estabelecer e provar que ||G^k|| → 0 iff ρ(G) < 1, com limite superior da taxa de convergência dado por ρ(G), e aplicar a sistemas com A diagonal dominante.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.4",
                            "name": "Analisar sensibilidade da convergência ao raio espectral",
                            "description": "Investigar como perturbações em A afetam ρ(G), relacionando com análise de sensibilidade de sistemas lineares e decomposições como QR ou SVD para previsão de comportamento.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Critérios de Convergência",
                    "description": "Condições como matriz diagonalmente dominante estrita e ρ(G)<1 para garantia de convergência.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Matriz Diagonalmente Dominante Estrita",
                        "description": "Definição de matriz diagonalmente dominante estrita, onde para cada linha i, o valor absoluto do elemento diagonal |a_{ii}| é estritamente maior que a soma dos valores absolutos dos elementos fora da diagonal ∑_{j≠i} |a_{ij}|. Essa propriedade garante a não-singularidade da matriz e a convergência de métodos iterativos clássicos como Jacobi e Gauss-Seidel.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Definir matriz diagonalmente dominante estrita",
                            "description": "Explicar formalmente a definição matemática de uma matriz diagonalmente dominante estrita, incluindo exemplos numéricos de matrizes que satisfazem e que não satisfazem a condição.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Verificar diagonal dominância em matrizes dadas",
                            "description": "Aplicar o critério para determinar se uma matriz específica é diagonalmente dominante estrita, calculando somas por linha e comparando com o elemento diagonal, com exercícios em matrizes 3x3 ou maiores.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Relacionar com não-singularidade",
                            "description": "Demonstrar que toda matriz diagonalmente dominante estrita é não-singular, usando argumentos baseados em suposição por contradição e norma de vetores.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Raio Espectral ρ(G) < 1",
                        "description": "O raio espectral ρ(G) de uma matriz G é o máximo módulo dos autovalores |λ_max|. Para métodos iterativos x^{k+1} = G x^k + c, a convergência é garantida se ρ(G) < 1, pois ||G^k|| → 0 quando k → ∞.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Calcular o raio espectral de G",
                            "description": "Computar os autovalores de uma matriz de iteração G (ex.: para Jacobi ou Gauss-Seidel) e determinar ρ(G), usando ferramentas computacionais ou métodos analíticos para matrizes pequenas.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Interpretar ρ(G) < 1 para convergência",
                            "description": "Explicar o teorema de convergência: se ρ(G) < 1, então o método iterativo converge para a solução única independentemente da inicialização, com prova esboçada baseada em normas induzidas.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Estimar taxa de convergência via ρ(G)",
                            "description": "Calcular o erro assintótico e a taxa de convergência aproximada como ρ(G), ilustrando com exemplos numéricos de iterações.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Teoremas de Convergência para Métodos Clássicos",
                        "description": "Teoremas específicos que ligam condições como diagonal dominância estrita à propriedade ρ(G) < 1 para métodos de Jacobi e Gauss-Seidel, com referências à bibliografia (Golub & Van Loan, Meyer).",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Provar convergência de Jacobi sob diagonal dominância",
                            "description": "Demonstrar que para Jacobi, se A é diagonalmente dominante estrita, então ρ(G_J) < 1, onde G_J = I - D^{-1}A, usando normas de linha infinita.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Provar convergência de Gauss-Seidel",
                            "description": "Explicar e provar que diagonal dominância estrita implica ρ(G_{GS}) < 1 para Gauss-Seidel, destacando que converge pelo menos tão rápido quanto Jacobi.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Aplicar critérios em problemas reais",
                            "description": "Analisar um sistema linear de uma aplicação (ex.: equações de Poisson) e verificar critérios de convergência para escolha de método iterativo.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Análise de Convergência de Jacobi e Gauss-Seidel",
                    "description": "Estudo comparativo da convergência dos métodos, incluindo taxa de convergência assintótica.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Condições de Convergência do Método de Jacobi",
                        "description": "Estudo das condições necessárias e suficientes para a convergência do método iterativo de Jacobi em sistemas lineares Ax=b, incluindo o critério baseado no raio espectral da matriz de iteração.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Definir a matriz de iteração de Jacobi",
                            "description": "Construir a matriz de iteração B_J = D^{-1}(L+U) a partir da decomposição A = D - L - U, onde D é diagonal, L tri-inferior e U tri-superior, e verificar sua forma explícita para um sistema genérico.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Estabelecer o critério de convergência",
                            "description": "Demonstrar que o método de Jacobi converge se e somente se o raio espectral ρ(B_J) < 1, utilizando normas matriciais e teoremas de convergência iterativa.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Aplicar critérios suficientes",
                            "description": "Verificar convergência usando condições suficientes como dominância diagonal estrita ou norma infinito de B_J < 1, com exemplos numéricos de matrizes 3x3.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Condições de Convergência do Método de Gauss-Seidel",
                        "description": "Análise das condições de convergência do método de Gauss-Seidel, destacando sua relação com o método de Jacobi e o uso de decomposições matriciais para determinar o raio espectral.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Definir a matriz de iteração de Gauss-Seidel",
                            "description": "Construir B_{GS} = (D-L)^{-1}U a partir da decomposição A = D - L - U e explicar a diferença em relação ao Jacobi pela incorporação do triângulo inferior.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Provar relação com Jacobi",
                            "description": "Demonstrar que ρ(B_{GS}) ≤ ρ(B_J), com igualdade para matrizes simétricas positivas definidas, usando propriedades espectrais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Verificar convergência prática",
                            "description": "Aplicar critérios de convergência para Gauss-Seidel em matrizes diagonalmente dominantes e simétricas, com contraexemplos onde Jacobi converge mas GS diverge.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Taxa de Convergência Assintótica e Comparação",
                        "description": "Estudo comparativo das taxas de convergência dos métodos Jacobi e Gauss-Seidel, incluindo a definição e cálculo da taxa assintótica baseada no raio espectral.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Definir taxa de convergência assintótica",
                            "description": "Explicar que a taxa de convergência é dada por μ = -log(ρ(B)), onde ρ(B) é o raio espectral da matriz de iteração, e calcular para casos simples.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Comparar taxas entre Jacobi e GS",
                            "description": "Comparar numericamente ρ(B_J) e ρ(B_{GS}) para matrizes tridiagonais e ilustração de aceleração do GS (até quadrática em alguns casos).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Analisar sensibilidade da taxa",
                            "description": "Estudar como perturbações na matriz A afetam ρ(B) e consequentemente a taxa de convergência, referenciando análise de sensibilidade de Golub & Van Loan.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.6",
                    "name": "Eficiência Computacional dos Métodos",
                    "description": "Avaliação do custo por iteração e número de iterações necessárias para precisão desejada.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.6.1",
                        "name": "Custo Computacional por Iteração",
                        "description": "Avaliação detalhada do número de operações de ponto flutuante (flops) e requisitos de armazenamento necessários para uma única iteração dos métodos iterativos clássicos, como Jacobi, Gauss-Seidel e SOR, considerando matrizes densas e esparsas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.6.1.1",
                            "name": "Identificar operações principais nos métodos iterativos",
                            "description": "Listar e classificar as operações aritméticas (somas, produtos, divisões) envolvidas em uma iteração de Jacobi, Gauss-Seidel e SOR para um sistema Ax = b de dimensão n.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.1.2",
                            "name": "Calcular flops por iteração para matrizes densas",
                            "description": "Derivar e calcular o custo em flops para uma iteração completa: 8n² para Jacobi denso, aproximadamente 5n² para Gauss-Seidel denso e similar para SOR com parâmetro ω.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.1.3",
                            "name": "Analisar custo para matrizes esparsas",
                            "description": "Estimar flops por iteração em termos de nnz (número de não-nulos) para implementações esparsas, destacando vantagens sobre métodos diretos para grandes sistemas esparsos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.6.2",
                        "name": "Número de Iterações para Precisão Desejada",
                        "description": "Estimação do número de iterações k necessário para que o erro relativo atinja uma tolerância ε, baseado na taxa de convergência medida pelo raio espectral ρ da matriz de iteração.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.6.2.1",
                            "name": "Determinar o raio espectral da matriz de iteração",
                            "description": "Calcular ρ para Jacobi (ρ = ρ(D^{-1}(L+U))), Gauss-Seidel (ρ(M^{-1}N)) e SOR otimizado, relacionando com autovalores da matriz A.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.2.2",
                            "name": "Estimar iterações via fórmula assintótica",
                            "description": "Usar k ≈ log(ε / ||x0 - x*||) / log(ρ) para prever o número de iterações necessárias, assumindo convergência linear.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.2.3",
                            "name": "Analisar dependência na condição da matriz",
                            "description": "Explicar como o número de iterações cresce com κ(A), o número de condição, e discutir impacto da assimetria ou indefinidade em métodos clássicos.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.6.3",
                        "name": "Eficiência Global e Comparação",
                        "description": "Avaliação do custo total computacional (flops por iteração × número de iterações) e comparação entre métodos iterativos clássicos e diretos, considerando precisão desejada e propriedades da matriz.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.6.3.1",
                            "name": "Calcular custo total para precisão ε",
                            "description": "Computar flops totais como (flops/iter) × k(ε, ρ) para cada método e comparar numericamente para exemplos com n=1000 e κ variando.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.3.2",
                            "name": "Comparar eficiência entre Jacobi, GS e SOR",
                            "description": "Discutir cenários onde SOR é superior (ω ótimo reduz ρ), GS melhor que Jacobi para matrizes simétricas positivas definidas, e limitações para matrizes mal-condicionadas.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.3.3",
                            "name": "Avaliar trade-offs com métodos diretos",
                            "description": "Comparar custo iterativo total com decomposição LU (O(n³)) ou QR (O(n³)), destacando quando iterativos são preferíveis (esparsidade, n grande).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 290
          }
        ],
        "totalSkills": 290
      }
    ]
  }
}